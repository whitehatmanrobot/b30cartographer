        GetExitCodeProcess(pi.hProcess, &dw);

                        // Close the Thread
                        CloseHandle(pi.hThread);

                        // Close the Process
                        CloseHandle(pi.hProcess);
                    }

                    // Patch up the store root for version we are returning to
                    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, pszRoot, 0, KEY_SET_VALUE, &hkeyT))
                    {
                        RegSetValueEx(hkeyT, c_szRegStoreRootDir, 0, dwType, (LPBYTE)pszStore, (lstrlen(pszStore) + 1) * sizeof(TCHAR));
                        RegCloseKey(hkeyT);
                    }
                }
            }
            RegCloseKey(hkeySrc);
        }
        break;
    }
}


/*******************************************************************

  NAME:       ConfigureOldVer
  
 SYNOPSIS:   Calls into INF to config older version
    
********************************************************************/
void ConfigureOldVer()
{
    TCHAR szSectionName[128];
    TCHAR szInfFile[MAX_PATH];
    BOOL bUser = (TIME_USER == si.stTime);
    SETUPVER sv, svInterim;
    
    GetVerInfo(&sv, NULL);
    
    // Patch up User or Machine
    if (sv < VER_MAX)
    {
        wsprintf(szInfFile, c_szFileEntryFmt, si.szInfDir, si.pszInfFile);
        wsprintf(szSectionName, bUser ? c_szUserRevertFmt : c_szMachineRevertFmt, c_szSects[sv]);
        (*si.pfnRunSetup)(NULL, szInfFile, szSectionName, si.szInfDir, si.szAppName, NULL, 
                          RSC_FLAG_INF | (bUser ? 0 : RSC_FLAG_NGCONV) | OE_QUIET, 0);
    }

    // Handle interim builds (user only)
    if (bUser && InterimBuild(&svInterim))
    {
        switch(si.saApp)
        {
        case APP_OE:
            HandleInterimOE(svInterim, sv);
            break;
        }
    }
}


/*******************************************************************

  NAME:       SelectNewClient
  
********************************************************************/
void SelectNewClient(LPCTSTR pszClient)
{
    BOOL fMail;
    BOOL fNone = TRUE;
    SETUPVER sv;
    PFN_ISETDEFCLIENT pfn;
    
    if (!lstrcmpi(pszClient, c_szNews))
    {
        pfn = ISetDefaultNewsHandler;
        fMail = FALSE;
    }
    else
    {
        pfn = ISetDefaultMailHandler;
        fMail = TRUE;
    }
    
    // If we went IMN to 5.0, we will show up as NOT_HANDLED as our subkeys are gone by now
    if ((HANDLED_CURR == DefaultClientSet(pszClient)) || (NOT_HANDLED == DefaultClientSet(pszClient)))
    {
        GetVerInfo(&sv, NULL);
        switch (sv)
        {
        case VER_4_0:
            // If prev ver was 4.0x, could have been Outlook News Reader
            if (FValidClient(pszClient, c_szMOE))
            {
                (*pfn)(c_szMOE, 0);
                fNone = FALSE;
            }
            else if (FValidClient(pszClient, c_szOutlook))
            {
                (*pfn)(c_szOutlook, 0);
                fNone = FALSE;
            }
            break;
            
        case VER_1_0:
            // If prev ver was 1.0, IMN may or may not be around (cool, eh?)
            if (FValidClient(pszClient, c_szIMN))
            {
                (*pfn)(c_szIMN, 0);
                fNone = FALSE;
            }
            break;
        }
    }

    if (fNone)
    {
        (*pfn)(_T(""), 0);
        SetUrlDllDefault(fMail);
    }

}


/*******************************************************************

  NAME:       SelectNewClients
  
********************************************************************/
void SelectNewClients()
{
    switch (si.saApp)
    {
    case APP_OE:
        SelectNewClient(c_szNews);
        SelectNewClient(c_szMail);
        break;
        
    case APP_WAB:
    default:
        break;
    }
}


/*******************************************************************

  NAME:       UpdateVersionInfo
  
********************************************************************/
void UpdateVersionInfo()
{
    HKEY hkeyT;
    DWORD dwType, cb;
    TCHAR szT[50]={0};
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyT))
    {
        cb = sizeof(szT);
        if (CALLER_IE == si.caller)
        {
            RegQueryValueEx(hkeyT, c_szRegPrevVer, NULL, &dwType, (LPBYTE)szT, &cb);
            RegSetValueEx(hkeyT, c_szRegCurrVer, 0, REG_SZ, (LPBYTE)szT, (lstrlen(szT) + 1) * sizeof(TCHAR));
        }
        else
            // Special case OS installs that can uninstall OE
            // As there is no rollback, current version should become nothing
            RegSetValueEx(hkeyT, c_szRegCurrVer, 0, REG_SZ, (LPBYTE)c_szBLDnone, (lstrlen(c_szBLDnone) + 1) * sizeof(TCHAR));
        RegSetValueEx(hkeyT, c_szRegPrevVer, 0, REG_SZ, (LPBYTE)c_szBLDnone, (lstrlen(c_szBLDnone) + 1) * sizeof(TCHAR));
        RegCloseKey(hkeyT);
    }
}


/*******************************************************************

  NAME:       PreRollback
  
********************************************************************/
void PreRollback()
{
    switch (si.saApp)
    {
    case APP_OE:
        RegisterExes(FALSE);
        break;
    case APP_WAB:
    default:
        break;
    }
}


/*******************************************************************

  NAME:       CreateWinLinks
  
    SYNOPSIS:   Generates special files in Windows Directory
    
********************************************************************/
void CreateWinLinks()
{
    UINT uLen, cb;
    TCHAR szPath[MAX_PATH];
    TCHAR szDesc[CCHMAX_STRINGRES];
    HANDLE hFile;
    
    lstrcpy(szPath, si.szWinDir);
    uLen = lstrlen(szPath);
    
    // generate the link description
    cb = LoadString(g_hInstance, IDS_OLD_MAIL, szDesc, ARRAYSIZE(szDesc));
    
    // ---- MAIL
    lstrcpy(&szPath[uLen], szDesc);
    cb += uLen;
    lstrcpy(&szPath[cb], c_szMailGuid);
    
    // create the link target
    hFile = CreateFile(szPath, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, 
        NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    
    // ---- NEWS
    cb = LoadString(g_hInstance, IDS_OLD_NEWS, szDesc, ARRAYSIZE(szDesc));
    
    // generate the path to the link target
    lstrcpy(&szPath[uLen], szDesc);
    cb += uLen;
    lstrcpy(&szPath[cb], c_szNewsGuid);
    
    // create the link target
    hFile = CreateFile(szPath, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, 
        NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
}


/*******************************************************************

  NAME:       PostRollback
  
********************************************************************/
void PostRollback()
{
    SETUPVER sv;    
    GetVerInfo(&sv, NULL);
    
    switch (si.saApp)
    {
    case APP_OE:
        if (VER_1_0 == sv)
            CreateWinLinks();
        break;
    case APP_WAB:
    default:
        break;
    }
}

#if 0
/*******************************************************************

  NAME:       RemoveJIT
  
********************************************************************/
void RemoveJIT()
{
    HKEY hkey;
    DWORD cb, dw;
    TCHAR szPath[MAX_PATH], szExpanded[MAX_PATH];
    LPTSTR pszPath;
    
    switch (si.saApp)
    {
    case APP_OE:
        // WAB
        wsprintf(szPath, c_szPathFileFmt, c_szRegUninstall, c_szRegUninstallWAB);
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPath, 0, KEY_QUERY_VALUE, &hkey))
        {
            cb = sizeof(szPath);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szQuietUninstall, 0, &dw, (LPBYTE)szPath, &cb))
            {
                STARTUPINFO sti;
                PROCESS_INFORMATION pi;
                
                if (REG_EXPAND_SZ == dw)
                {
                    ZeroMemory(szExpanded, ARRAYSIZE(szExpanded));
                    ExpandEnvironmentStrings(szPath, szExpanded, ARRAYSIZE(szExpanded));
                    pszPath = szExpanded;
                }
                else
                    pszPath = szPath;
                
                ZeroMemory(&sti, sizeof(STARTUPINFO));
                sti.cb = sizeof(STARTUPINFO);
                
                if (CreateProcess(NULL, pszPath, NULL, NULL, FALSE, 0, NULL, NULL, &sti, &pi))
                {
                    WaitForSingleObject(pi.hProcess, INFINITE);
                    GetExitCodeProcess(pi.hProcess, &dw);
                    CloseHandle(pi.hThread);
                    CloseHandle(pi.hProcess);
                }
            }
            
            RegCloseKey(hkey);
        }
        break;
        
    case APP_WAB:
    default:
        break;
    }
}
#endif

/*******************************************************************

  NAME:       RequiredIE
  
  SYNOPSIS:   Requires IE5 for uninstall
    
********************************************************************/
BOOL RequiredIE()
{
    HKEY hkey;
    TCHAR szVer[VERLEN];
    BOOL fOK = FALSE;
    DWORD cb;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szIEKey, 0, KEY_READ, &hkey))
    {
        cb = ARRAYSIZE(szVer);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szValueVersion, 0, NULL, (LPBYTE)szVer, &cb))
        {
            WORD wVer[4];
            WORD wVerOE[4] = {5,0,0,0};
            
            ConvertStrToVer(szVer, wVer);

            if (!(fOK = GoodEnough(wVer, wVerOE)))
                LOG("[WARNING]: Insufficient IE for uninstall");
        }
        RegCloseKey(hkey);
    }

    return fOK;
}


/*******************************************************************

  NAME:       UnInstallMachine
  
    SYNOPSIS:   Handles Application uninstallation
    
********************************************************************/
BOOL UnInstallMachine()
{
    HRESULT hr = E_FAIL;
    TCHAR szArgs[2 * MAX_PATH];
    TCHAR szInfFile[MAX_PATH];
    UINT uID;

    // Require at least IE 5 to uninstall
    if (!RequiredIE() && (si.fPrompt ? (IDNO == MsgBox(NULL, IDS_WARN_OLDIE, MB_ICONEXCLAMATION, MB_YESNO | MB_DEFBUTTON2)) : TRUE))
    {
        LOG("[ERROR] Setup canceled");
        return FALSE;
    }
    
    switch (si.saApp)
    {
    case APP_OE:
        uID = IDS_UNINSTALL_OE;
        break;
    case APP_WAB:
        uID = IDS_UNINSTALL_WAB;
        break;
    default:
        return FALSE;
    }
    
    // Make sure the user really wants to uninstall and there is nothing preventing it
    if (IDNO == MsgBox(NULL, uID, MB_YESNO, MB_ICONEXCLAMATION ) ||
        !OKDespiteDependencies())
    {
        LOG("[ERROR] Setup canceled");
            return FALSE;
    }
    
    // We'll need to move files around and write to HKLM, so require admin privs
    if (!IsNTAdmin())
    {
        LOG("[ERROR] User does not have administrative privileges")
            MsgBox(NULL, IDS_NO_ADMIN_PRIVILEGES, MB_ICONSTOP, MB_OK);
        return FALSE;
    }
    
    // Update version info in the reg
    UpdateVersionInfo();

    wsprintf(szInfFile, c_szFileEntryFmt, si.szInfDir, si.pszInfFile);
    if (CALLER_IE == si.caller)
    {    
        // Do any housework before the uninstall
        PreRollback();
        
        // UnRegister OCXs (immediately)
        (*si.pfnRunSetup)(NULL, szInfFile, c_szUnRegisterOCX, si.szInfDir, si.szAppName, NULL, RSC_FLAG_INF | RSC_FLAG_NGCONV | OE_QUIET, 0);

        // Return files to original state    
        wsprintf(szArgs, c_szLaunchExFmt, szInfFile, c_szMachineInstallSectionEx, c_szEmpty, ALINF_ROLLBACK | ALINF_NGCONV | OE_QUIET);
        hr = (*si.pfnLaunchEx)(NULL, NULL, szArgs, 0);

        // Keys off current
        PostRollback();

        // Patch up Old version so that it runs (keys off current)
        ConfigureOldVer();
    }
    else
    {
        // Set up the per user stub
        (*si.pfnRunSetup)(NULL, szInfFile, c_szGenInstallSection, si.szInfDir, si.szAppName, NULL, RSC_FLAG_INF | RSC_FLAG_NGCONV | OE_QUIET, 0);
    }
   
    // Figure out who will be the default handlers now that app is gone
    SelectNewClients();
    
    // Uninstall JIT'd in items
    // RemoveJIT();
    
    // To simplify matters, we always want our stubs to run (not very ZAW like)
    if (si.fPrompt)
        Reboot(TRUE);

    // Special case Memphis uninstall - no bits to return to, so just remove the icons now
    if (CALLER_IE != si.caller)
    {
        UnInstallUser();
        // Destory uninstalling user's installed info in case they install an older version without
        // rebooting first
        UpdateStubInfo(FALSE);
    }
    
    return TRUE;
}


/*******************************************************************

  NAME:       CleanupPerUser
  
  SYNOPSIS:   Handles per user cleanup
    
********************************************************************/
void CleanupPerUser()
{
    switch (si.saApp)
    {
    case APP_WAB:
        // Backwards migrate the connection settings
        BackMigrateConnSettings();
        break;

    default:
        break;
    }
}


/*******************************************************************

  NAME:       UnInstallUser
  
    SYNOPSIS:   Handles User uninstallation (icons etc)
    
********************************************************************/
void UnInstallUser()
{
    // Remove desktop and quicklaunch links
    HandleLinks(FALSE);
    
    // Call into the correct per user stub
    if (CALLER_IE == si.caller)
        ConfigureOldVer();

    // Handle any per user uninstall cleanup
    CleanupPerUser();

    if (IsXPSP1OrLater())
    {
        DeleteKeyRecursively(HKEY_CURRENT_USER, "Software\\Microsoft\\Active Setup\\Installed Components\\>{881dd1c5-3dcf-431b-b061-f3f88e8be88a}");
    }
}

/*******************************************************************

  NAME:     BackMigrateConnSettings

    SYNOPSIS:   OE4.1 or the versions before that did not have the 
    connection setting type InternetConnectionSetting. So while 
    downgrading from OE5 to OE4.1 or prior, we migrate 
    InternetConnectionSetting to LAN for every account in every identity
*******************************************************************/

void BackMigrateConnSettings()
{
    HKEY    hKeyAccounts = NULL;
    DWORD   dwAcctSubKeys = 0;
    LONG    retval;
    DWORD   index = 0;
    LPTSTR  lpszAccountName = NULL;
    HKEY    hKeyAccountName = NULL;
    DWORD   memsize = 0;
    DWORD   dwValue;
    DWORD   cbData = sizeof(DWORD);
    DWORD   cbMaxAcctSubKeyLen;
    DWORD   DataType;
    DWORD   dwConnSettingsMigrated = 0;

    //This setting is in \\HKCU\Software\Microsoft\InternetAccountManager\Accounts
    
    retval = RegOpenKey(HKEY_CURRENT_USER, c_szIAMAccounts, &hKeyAccounts);
    if (ERROR_SUCCESS != retval)
        goto exit;

    retval = RegQueryValueEx(hKeyAccounts, c_szConnSettingsMigrated, NULL,  &DataType,
                            (LPBYTE)&dwConnSettingsMigrated, &cbData);
    
    if ((retval != ERROR_FILE_NOT_FOUND) && (retval != ERROR_SUCCESS || dwConnSettingsMigrated == 0))
        goto exit;

    retval = RegQueryInfoKey(hKeyAccounts, NULL, NULL, NULL, &dwAcctSubKeys, 
                         &cbMaxAcctSubKeyLen, NULL, NULL, NULL, NULL, NULL, NULL);

    if (ERROR_SUCCESS != retval)
        goto exit;

    memsize = sizeof(TCHAR) * cbMaxAcctSubKeyLen;

    if (!MemAlloc((LPVOID*)&lpszAccountName, memsize))
    {
        lpszAccountName = NULL;
        goto exit;
    }

    ZeroMemory(lpszAccountName, memsize);

    while (index < dwAcctSubKeys)
    {
        retval = RegEnumKey(hKeyAccounts, index, lpszAccountName, memsize);
        
        index++;

        if (ERROR_SUCCESS != retval)
            continue;

        retval = RegOpenKey(hKeyAccounts, lpszAccountName, &hKeyAccountName);
        if (ERROR_SUCCESS != retval)
            continue;

        cbData = sizeof(DWORD);
        retval = RegQueryValueEx(hKeyAccountName, c_szConnectionType, NULL, &DataType, (LPBYTE)&dwValue, &cbData);
        if (ERROR_SUCCESS != retval)
        {
            RegCloseKey(hKeyAccountName);
            continue;
        }

        if (dwValue == CONNECTION_TYPE_INETSETTINGS)
        {
            dwValue = CONNECTION_TYPE_LAN;
            retval = RegSetValueEx(hKeyAccountName, c_szConnectionType, 0, REG_DWORD, (const BYTE *)&dwValue, 
                                   sizeof(DWORD));
        }

        RegCloseKey(hKeyAccountName);
    }

    //Set this to zero so, when we upgrade when we do forward migration based on this key value
    dwConnSettingsMigrated = 0;
    RegSetValueEx(hKeyAccounts, c_szConnSettingsMigrated, 0, REG_DWORD, (const BYTE*)&dwConnSettingsMigrated, 
                  sizeof(DWORD));

exit:
    SafeMemFree(lpszAccountName);

    if (hKeyAccounts)
        RegCloseKey(hKeyAccounts);
}

const char c_szMailToHandler[]       = "rundll32.exe url.dll,MailToProtocolHandler %l";
const char c_szNewsHandler[]         = "rundll32.exe url.dll,NewsProtocolHandler %l";
 
const char c_szDefIcon[]             = "DefaultIcon";
const char c_szURLProtocol[]         = "URL Protocol";
const char c_szEditFlags[]           = "EditFlags";

const char c_szSysDirExpand[]        = "%SystemRoot%\\System32";
const char c_szUrlDllIconFmt[]       = "%s\\url.dll,%d";

void SetUrlDllDefault(BOOL fMailTo)
{
    char sz[MAX_PATH], szIcon[MAX_PATH];
    HKEY hkey, hkeyT;
    DWORD dw, type;
    int cch;

    if (si.osv.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        lstrcpy(sz, c_szSysDirExpand);
        type = REG_EXPAND_SZ;
    }
    else
    {
        GetSystemDirectory(sz, ARRAYSIZE(sz));
        type = REG_SZ;
    }
    wsprintf(szIcon, c_szUrlDllIconFmt, sz, fMailTo ? 2 : 1);

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, fMailTo ? c_szURLMailTo : c_szURLNews, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw))
    {
        cch = LoadString(g_hInstance, fMailTo ? IDS_URLDLLMAILTONAME : IDS_URLDLLNEWSNAME, sz, ARRAYSIZE(sz)) + 1;
        RegSetValueEx(hkey, NULL, 0, REG_SZ, (LPBYTE)sz, cch); 

        dw = 2;
        RegSetValueEx(hkey, c_szEditFlags, 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));

        RegSetValueEx(hkey, c_szURLProtocol, 0, REG_SZ, (LPBYTE)c_szEmpty, 1); 

        if (ERROR_SUCCESS == RegCreateKeyEx(hkey, c_szDefIcon, 0, NULL,
                                REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkeyT, &dw)) 
        {
            RegSetValueEx(hkeyT, NULL, 0, type, (LPBYTE)szIcon, lstrlen(szIcon) + 1);
            RegCloseKey(hkeyT);
        }

        // c_szRegOpen[1] to skip over slash needed elsewhere
        if (ERROR_SUCCESS == RegCreateKeyEx(hkey, &c_szRegOpen[1], 0, NULL,
                                REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkeyT, &dw)) 
        {
            if (fMailTo)
                RegSetValueEx(hkeyT, NULL, 0, REG_SZ, (LPBYTE)c_szMailToHandler, sizeof(c_szMailToHandler));
            else
                RegSetValueEx(hkeyT, NULL, 0, REG_SZ, (LPBYTE)c_szNewsHandler, sizeof(c_szNewsHandler));

            RegCloseKey(hkeyT);
        }

        RegCloseKey(hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\setup\wizard\util.h ===
#pragma once

HRESULT GetExeVer(LPCTSTR pszExeName, WORD *pwVer, LPTSTR pszVer, int cch);
HRESULT GetFileVer(LPCTSTR pszExePath, LPTSTR pszVer, DWORD cch);
UINT GetSystemWindowsDirectoryWrap(LPTSTR pszBuffer, UINT uSize);
void GetVers(WORD *pwVerCurr,WORD *pwVerPrev);
BOOL GoodEnough(WORD *pwVerGot, WORD *pwVerNeed);
BOOL OEFileBackedUp(LPTSTR pszFullPath, int cch);
int MsgBox(HWND hWnd, UINT nMsgID, UINT uIcon, UINT uButtons);
void ConvertStrToVer(LPCSTR pszStr, WORD *pwVer);
SETUPVER ConvertVerToEnum(WORD *pwVer);
void GetVerInfo(SETUPVER *psvCurr, SETUPVER *psvPrev);
BOOL InterimBuild(SETUPVER *psv);
BOOL GetASetupVer(LPCTSTR pszGUID, WORD *pwVer, LPTSTR pszVer, int cch);
BOOL IsNTAdmin(void);
void RegisterExes(BOOL fReg);
// Implemented in staticrt.lib
STDAPI_(BOOL) PathRemoveFileSpec(LPTSTR pFile);

BOOL IsXPSP1OrLater();
DWORD DeleteKeyRecursively(IN HKEY hkey, IN LPCSTR pszSubKey);


#ifdef DEFINE_UTIL
SETUPINFO si;
// Keep this in order with the enumeration SETUPVER in wizdef.h
//                           None         1.0         1.1         4.0         5.0 B1     5.0
#else
extern SETUPINFO si;
#endif

#ifdef SETUP_LOG
#ifdef DEFINE_UTIL
char szLogBuffer[256];
#else
extern char szLogBuffer[256];
#endif

void OpenLogFile();
void CloseLogFile();
void LogMessage(LPTSTR pszMsg, BOOL fNewLine);
void LogRegistry(HKEY hkeyMain, LPTSTR pszSub);
#define LOG_OPEN         OpenLogFile();
#define LOG_CLOSE        CloseLogFile();
#define LOG(_a)          LogMessage(_a, TRUE);       
#define LOG2(_a)         LogMessage(_a, FALSE);       
#define LOGREG(_a,_b)    LogRegistry(_a,_b);

#else

#define LOG_OPEN   
#define LOG_CLOSE  
#define LOG(_a)    
#define LOG2(_a) 
#define LOGREG(_a,_b) 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\setup\wizard\wizard.h ===
#ifndef _WIZARD_H_
#define _WIZARD_H_

#define _MSOERT_
#define MSOERT_NO_STRPARSE
#define MSOERT_NO_BYTESTM
#define MSOERT_NO_ENUMFMT
#define MSOERT_NO_CLOGFILE
#define MSOERT_NO_LISTOBJS

#include <windows.h>
#include <windowsx.h>
#include <regstr.h>
#include <msoert.h>
#include <tchar.h>

#include <comctrlp.h>
#include <shlobj.h>
#ifdef NT_BUILD
#include <shlobjp.h>
#else
#include <shsemip.h>
#endif

#include "wizdef.h"
#include "ids.h"

// Globals

extern HINSTANCE    g_hInstance;     // global module instance handle

// Defines

// functions in PROPMGR.C
void InstallUser();
HRESULT InstallMachine();
void HandleV1Uninstall(BOOL fSetup);
void HandleLinks(BOOL fCreate);
BOOL MigrateSettings();
void CopySettings(HKEY hkey, SETUPVER sv, BOOL bUpgrade);
BOOL bVerInfoExists(SETUPVER sv);
HRESULT CreateLink(LPCTSTR lpszPathObj, LPCTSTR lpszArg, LPCTSTR lpszPathLink, LPCTSTR lpszDesc, LPCTSTR lpszIcon, int iIcon);
BOOL UninstallOEMapi();
void UpdateStubInfo(BOOL fInstall);

// functions in UNINSTALL.C
void UnInstallUser();
BOOL UnInstallMachine();
LONG RegDeleteKeyRecursive(HKEY hKey, LPCTSTR lpszSubKey);
void BackMigrateConnSettings();


// functions in MENU.CPP
void DisplayMenu();

#endif // _WIZARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\setup\wizard\strings.h ===
#ifndef _STRINGS_H_
#define _STRINGS_H_

#include <strconst.h>
#include <ntverp.h>

// ********** R E G I S T R Y
#define STR_REG_ADV_INFO            "Software\\Microsoft\\Advanced INF Setup"
#define STR_FILE_WAB                "AddressBook"
#define STR_FILE_OE                 "OutlookExpress"


STR_GLOBAL(c_szOutlookNews,         "Software\\Microsoft\\Office\\8.0\\Outlook\\Newsreader");
    STR_GLOBAL(c_szNewsPath,        "NewsPath");

    STR_GLOBAL(c_szVERnone,         "None");
    STR_GLOBAL(c_szVER1_0,          "1.0");
    STR_GLOBAL(c_szVER1_1,          "1.1");
    STR_GLOBAL(c_szVER4_0,          "4.0x");
    STR_GLOBAL(c_szVER5B1,          "5.0");
    STR_GLOBAL(c_szVER5_0,          "5.x");
    STR_GLOBAL(c_szVER5B1old,       "5.0 B1");
    STR_GLOBAL(c_szBLDnone,         "0,00,0000,0");
    STR_GLOBAL(c_szBLD1_0,          "1,00,0000,0");
    STR_GLOBAL(c_szBLD1_1,          "1,01,0000,0");
    STR_GLOBAL(c_szBLD4_0,          "4,72,2106,8");
    STR_GLOBAL(c_szBLD5B1,          "5,00,518,0");
    // Only used in a pinch
    STR_GLOBAL(c_szBLDnew,          "5,00,0809,0100");
    STR_GLOBAL(c_szRegProfiles,     "Profiles");
    STR_GLOBAL(c_szReg50,           "5.0");
STR_GLOBAL(c_szRegMailPop3,         "Mail\\POP3");
STR_GLOBAL(c_szRegVerInfo,          STR_REG_PATH_FLAT "\\Version Info");
STR_GLOBAL(c_szRegSharedSetup,      STR_REG_PATH_ROOT "\\Shared Settings\\Setup");
STR_GLOBAL(c_szWABRegSharedSetup,   STR_REG_WAB_ROOT  "\\Shared Settings\\Setup");
STR_GLOBAL(c_szRegNoBakInfo,        "No Backup Info");
STR_GLOBAL(c_szRegCurrVerMinor,     "Current Minor");
STR_GLOBAL(c_szRegAcctMgr,          STR_REG_IAM_FLAT);
STR_GLOBAL(c_szRegAcctMgrAccts,     STR_REG_IAM_FLAT  "\\Accounts");
STR_GLOBAL(c_szRegWAB,              STR_REG_WAB_FLAT);
#define c_szQuickLaunchDir_LEN      41
STR_GLOBAL(c_szQuickLaunchDir,      "Microsoft\\Internet Explorer\\Quick Launch\\");
STR_GLOBAL(c_szUserName,            "UserName");
STR_GLOBAL(c_szRegASetup,           "Software\\Microsoft\\Active Setup\\Installed Components");
STR_GLOBAL(c_szBackupPath,          "BackupPath");
STR_GLOBAL(c_szDesktop,             "Desktop");
STR_GLOBAL(c_szValueCommonDTop,     "Common Desktop");
STR_GLOBAL(c_szIsInstalled,         "IsInstalled");
STR_GLOBAL(c_szRegUninstall,        STR_REG_WIN_ROOT "\\Uninstall");
STR_GLOBAL(c_szRegUninstallWAB,     "AddressBook");
STR_GLOBAL(c_szQuietUninstall,      "QuietUninstallString");
STR_GLOBAL(c_szSettingsToLWP,       "MigToLWP");
STR_GLOBAL(c_szSettingsToLWPVer,    "MigToLWPVer");
STR_GLOBAL(c_szRegAdvInfoWAB,       STR_REG_ADV_INFO "\\" STR_FILE_WAB);
STR_GLOBAL(c_szRegAdvInfoOE,        STR_REG_ADV_INFO "\\" STR_FILE_OE);
STR_GLOBAL(c_szBackupRegPathName,   "BackupRegPathName");
STR_GLOBAL(c_szBackupFileName,      "BackupFileName");
STR_GLOBAL(c_szBackupDir,           "BackupPath");
STR_GLOBAL(c_szCommonFilesDir,      "CommonFilesDir");
STR_GLOBAL(c_szHKLM,                "HKLM");
STR_GLOBAL(c_szHKCU,                "HKCU");
STR_GLOBAL(c_szRegBackup,           "RegBackup");
STR_GLOBAL(c_szRequiresIESys,       "RequiresIESysFile");
STR_GLOBAL(c_szRequiresOESys,       "RequiresOESysFile");
STR_GLOBAL(c_szRequiresWABSys,      "RequiresWABSysFile");
STR_GLOBAL(c_szSMAccessories,       "SM_AccessoriesName");
STR_GLOBAL(c_szIEKey,               STR_REG_PATH_IE);
STR_GLOBAL(c_szIESetupKey,          "Software\\Microsoft\\IE Setup\\SETUP");
STR_GLOBAL(c_szIEInstallMode,       "InstallMode");
STR_GLOBAL(c_szDisableOLCheck,      "DisableOL");
STR_GLOBAL(c_szDisablePhoneCheck,   "DisablePH");
STR_GLOBAL(c_szLaunchWorks,         "LaunchWorks");
STR_GLOBAL(c_szLatestINF,           "LatestINF");
STR_GLOBAL(c_szLocale,              "Locale");

// ********** S T R I N G S

// ++++ Command line Options
STR_GLOBAL(c_szUninstallFlag,       "/UNINSTALL");
STR_GLOBAL(c_szInstallFlag,         "/INSTALL");
STR_GLOBAL(c_szUserFlag,            "/USER");
STR_GLOBAL(c_szPromptFlag,          "/PROMPT");
STR_GLOBAL(c_szAppFlag,             "/APP");
STR_GLOBAL(c_szCallerFlag,          "/CALLER");
STR_GLOBAL(c_szINIFlag,             "/INI");
STR_GLOBAL(c_szIconsFlag,           "/ICONS");
STR_GLOBAL(c_szOFF,                 "OFF");
STR_GLOBAL(c_szAppOE,               "OE");
STR_GLOBAL(c_szAppWAB,              "WAB");
STR_GLOBAL(c_szIE50,                "IE50");
STR_GLOBAL(c_szWIN9X,               "WIN9X");
STR_GLOBAL(c_szWINNT,               "WINNT");

STR_GLOBAL(c_szArgTemplate,         "/root,\"%s\"");
STR_GLOBAL(c_szUnregFmt,            "\"%s\\%s\" /unreg");
STR_GLOBAL(c_szRegFmt,              "\"%s\\%s\" /reg");

STR_GLOBAL(c_szMigFmt,              "%s /type:%s /src:%s /dst:default");
STR_GLOBAL(c_szV1,                  "V5B1-V1");
STR_GLOBAL(c_szV4,                  "V5B1-V4");

// ++++ Filenames
STR_GLOBAL(c_szMsimnInf,            "msoe50.inf");
STR_GLOBAL(c_szWABInf,              "wab50.inf");
STR_GLOBAL(c_szExplorer,            "EXPLORER.EXE");
STR_GLOBAL(c_szWABFindDll,          "wabfind.dll");
STR_GLOBAL(c_szWABFindDllIe3,       "wabfind.ie3");
STR_GLOBAL(c_szOldMainExe,          "msimn.exe");
STR_GLOBAL(c_szInetcomm,            "inetcomm.dll");
STR_GLOBAL(c_szInetres,             "inetres.dll");
STR_GLOBAL(c_szMsoeacct,            "msoeacct.dll");
STR_GLOBAL(c_szMsoert2,             "msoert2.dll");
STR_GLOBAL(c_szFileLog,             "OEWABLog.txt");
STR_GLOBAL(c_szWAB32,               "wab32.dll");
STR_GLOBAL(c_szWABEXE,              "wab.exe");
STR_GLOBAL(c_szMAILNEWS,            "mailnews.dll");
STR_GLOBAL(c_szWABComponent,        STR_FILE_WAB);
STR_GLOBAL(c_szOEComponent,         STR_FILE_OE);
STR_GLOBAL(c_szSlashWABComponent,   "\\" STR_FILE_WAB);
STR_GLOBAL(c_szPhoneExe,            "msphone.exe");
STR_GLOBAL(c_szOutlookExe,          "outlook.exe");

// ++++ msoe50inf sections
STR_GLOBAL(c_szUserInstallSection,  "User.Install");
STR_GLOBAL(c_szUserInstallSectionOEOnXPSP1OrLater, "User.Install.WinXP.SP1OrLater");
STR_GLOBAL(c_szMachineInstallSectionEx,"DefaultInstall_EX");
STR_GLOBAL(c_szMachineInstallSection,"DefaultInstall");
STR_GLOBAL(c_szNewUserRegSection,   "New.User.Reg.Install");
STR_GLOBAL(c_szRestoreV1WithWAB,    "Restore.v1.InstallWithWAB");
STR_GLOBAL(c_szRestoreV1,           "Restore.v1.Install");
STR_GLOBAL(c_szRegisterPermOCX,     "DefaultInstall_PermRegister");
STR_GLOBAL(c_szRegisterOCX,         "DefaultInstall_Register");
STR_GLOBAL(c_szUnRegisterOCX,       "DefaultInstall_UnRegister");
STR_GLOBAL(c_szGenInstallSection,   "GenInstall");
STR_GLOBAL(c_szStringSection,       "Strings");

// ++++ Misc
STR_GLOBAL(c_szBackupSection,       "backup");
STR_GLOBAL(c_szINFSlash,            "INF\\");
STR_GLOBAL(c_szDotINI,              ".INI");
STR_GLOBAL(c_szStarIDX,             "*.IDX");
STR_GLOBAL(c_szDotDAT,              ".DAT");
#define c_szLinkFmt_LEN             4
STR_GLOBAL(c_szLinkFmt,             "%s.lnk");
STR_GLOBAL(c_szLaunchFmt,           "%s,%s,%s,%d");
STR_GLOBAL(c_szFmtMapiMailExt,      "%s.MAPIMail");
STR_GLOBAL(c_szLaunchExFmt,         "%s,%s,%s,%d");
STR_GLOBAL(c_szMachineRevertFmt,    "RevertTo_%s.Machine");
STR_GLOBAL(c_szUserRevertFmt,       "RevertTo_%s.User");
STR_GLOBAL(c_szFileEntryFmt,        "%s%s");
STR_GLOBAL(c_szIE4Dir,              "IE 4.0\\");
STR_GLOBAL(c_szMailGuid,            ".{89292102-4755-11cf-9DC2-00AA006C2B84}");
STR_GLOBAL(c_szNewsGuid,            ".{89292103-4755-11cf-9DC2-00AA006C2B84}");
STR_GLOBAL(c_szOEGUID,              "{44BBA840-CC51-11CF-AAFA-00AA00B6015C}");
STR_GLOBAL(c_szWABGUID,             "{7790769C-0471-11d2-AF11-00C04FA35D02}");
STR_GLOBAL(c_szOLNEWSGUID,          "{70F82C18-3D15-11d1-8596-00C04FB92601}");
STR_GLOBAL(c_szMailSlash,           "Mail\\");
STR_GLOBAL(c_szBackedup,            "20");
STR_GLOBAL(c_szNotBackedup,         "-1");
STR_GLOBAL(c_szVersionOE,           "VERSION_OE");
STR_GLOBAL(c_szAccessoriesString,   "STR_ACCESSORIES_GRP");

#endif // _STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\shell\makefile.inc ===
$O\msimn.res : $(O)\selfreg.inf

selfreg.src : strings.src reg.src reg2.src

$(O)\selfreg.inx : selfreg.src
    cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\setup\wizard\wizdef.h ===
#ifndef _WIZDEF_H_
#define _WIZDEF_H_

#include <advpub.h>

#define SETUP_LOG

// Data structures
typedef enum
    {
    VER_NONE = 0,
    VER_1_0,
    VER_1_1,
    VER_4_0,
    VER_5_0_B1,
    VER_5_0,
    VER_6_0,
    VER_MAX,
    } SETUPVER;

typedef enum 
    {
    MODE_UNKNOWN = 0,
    MODE_INSTALL,
    MODE_UNINSTALL,
    MODE_ICONS,
    } SETUPMODE;

typedef enum 
    {
    TIME_MACHINE = 0,
    TIME_USER,
    } SETUPTIME;

typedef enum 
    {
    APP_UNKNOWN = 0,
    APP_OE,
    APP_WAB,
    } SETUPAPP;

typedef enum
    {
    CALLER_IE = 0,
    CALLER_WIN9X,
    CALLER_WINNT,
    } CALLER;

typedef struct tagSETUPINFO
    {
    TCHAR           szSysDir[MAX_PATH];
    TCHAR           szWinDir[MAX_PATH];
    TCHAR           szAppName[MAX_PATH];
    TCHAR           szCurrentDir[MAX_PATH];
    TCHAR           szInfDir[MAX_PATH];
    TCHAR           szINI[MAX_PATH];
    LPCTSTR         pszVerInfo;
    LPCTSTR         pszInfFile;
    OSVERSIONINFO   osv;

    BOOL            fNoIcons:1;
    BOOL            fPrompt:1;
    CALLER          caller;

    SETUPMODE       smMode;
    SETUPTIME       stTime;
    SETUPAPP        saApp;

    HINSTANCE       hInstAdvPack;
    RUNSETUPCOMMAND pfnRunSetup;
    LAUNCHINFSECTIONEX pfnLaunchEx;
    ADVINSTALLFILE  pfnCopyFile;
    ADDDELBACKUPENTRY pfnAddDel;
    REGSAVERESTORE  pfnRegRestore;
#ifdef SETUP_LOG
    HANDLE           hLogFile;
#endif
    } SETUPINFO;

typedef HRESULT (*PFN_ISETDEFCLIENT)(LPCTSTR,DWORD);

#define OE_QUIET  RSC_FLAG_QUIET

#define VERLEN 20

// Taken from -s \\trango\slmadd, -p setup, active\ie4setup\ie4setup.h
#define REDIST_REMOVELINKS              1
#define REDIST_DONT_TAKE_ASSOCIATION    2

// Icons OE Setup might create or delete
typedef enum
{
    ICON_ICWBAD = 0,
    ICON_DESKTOP,
    ICON_QLAUNCH,
    ICON_MAPIRECIP,
    ICON_QLAUNCH_OLD,
    // Keep this one last!
    ICON_LAST_ICON,
} OEICON;

// Flags used by FGetLinkInfo
#define LI_PATH     1
#define LI_TARGET   2
#define LI_DESC     4

#endif // _WIZDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\shell\resource.h ===
#ifndef __RESOURCE_H
#define __RESOURCE_H

// string resources
#define idsOutlookExpress
#define idsStartupCantCreateMutex       100
#define idsStartupCantWaitForMutex      101
#define idsStartupCantLoadMSOEDLL       102
#define idsStartupCantInitMSOEDLL       103
#define idsStartupFailureUnknown        100

// icon resources
#define idiGenericMail  2
#define idiNews         3
#define idiMsgPropSent  4
#define idiArtPropPost  5
#define idiMail         6
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\shell\pch.h ===
#include <windows.h>
#include <windowsx.h>
#ifdef WIN16
#include "athena16.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\shell\msimnp.h ===
#ifndef __MSIMNP_H__
#define __MSIMNP_H__

#if !defined (ARRAYSIZE) || !defined (WIN16)
#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))
#endif

#endif // __MSIMNP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\staticrt\bytestm.cpp ===
// --------------------------------------------------------------------------------
// Bytestm.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "bytestm.h"

// -------------------------------------------------------------------------
// CByteStream::CByteStream
// -------------------------------------------------------------------------
CByteStream::CByteStream(LPBYTE pb, ULONG cb)
{
    Assert(pb ? cb > 0 : TRUE);
    m_cRef = 1;
    m_cbData = cb;
    m_iData = 0;
    m_pbData = pb;
    m_cbAlloc = 0;
}

// -------------------------------------------------------------------------
// CByteStream::CByteStream
// -------------------------------------------------------------------------
CByteStream::~CByteStream(void)
{
    SafeMemFree(m_pbData);
}

// -------------------------------------------------------------------------
// CByteStream::QueryInterface
// -------------------------------------------------------------------------
STDMETHODIMP CByteStream::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);
    
    // Init
    *ppv = NULL;
    
    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IStream == riid)
        *ppv = (IStream *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }
    
    // AddRef It
    ((IUnknown *)*ppv)->AddRef();
    
    // Done
    return S_OK;
}

// -------------------------------------------------------------------------
// CByteStream::AddRef
// -------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CByteStream::AddRef(void)
{
    return ++m_cRef;
}

// -------------------------------------------------------------------------
// CByteStream::Release
// -------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CByteStream::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CByteStream::_HrGrowBuffer
// --------------------------------------------------------------------------------
HRESULT CByteStream::_HrGrowBuffer(ULONG cbNeeded, ULONG cbExtra)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbAlloc;
    LPBYTE      pbNew;

    // Realloc
    IF_WIN32( CHECKALLOC(pbNew = (LPBYTE)CoTaskMemRealloc(m_pbData, m_cbData + cbNeeded + cbExtra)); )
    IF_WIN16( CHECKALLOC(pbNew = (LPBYTE)g_pMalloc->Realloc(m_pbData, m_cbData + cbNeeded + cbExtra)); )
    
    // Set m_pbData
    m_pbData = pbNew;
    
    // Set Allocated Size
    m_cbAlloc = m_cbData + cbNeeded + cbExtra;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CByteStream::SetSize
// --------------------------------------------------------------------------------
STDMETHODIMP CByteStream::SetSize(ULARGE_INTEGER uliSize)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbSize=uliSize.LowPart;

    // Invalid Arg
    Assert(0 == uliSize.HighPart);

    // Greater thena current size
    if (cbSize + 2 > m_cbAlloc)
    {
        // Grow It
        CHECKHR(hr = _HrGrowBuffer(cbSize, 256));
    }

    // Save New Size
    m_cbData = cbSize;

    // Adjust m_iData
    if (m_iData > m_cbData)
        m_iData = m_cbData;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CByteStream::Write
// --------------------------------------------------------------------------------
STDMETHODIMP CByteStream::Write(const void HUGEP_16 *pv, ULONG cb, ULONG *pcbWritten)
{
    // Locals
    HRESULT     hr=S_OK;
    
    // Grow the buffer - always leave space for two nulls
    if (m_cbData + cb + 2 > m_cbAlloc)
    {
        // Grow It
        CHECKHR(hr = _HrGrowBuffer(cb, 256));
    }
    
    // Write the data
    CopyMemory(m_pbData + m_iData, (LPBYTE)pv, cb);

    // Increment Index
    m_iData += cb;

    // Increment m_cbData ?
    if (m_iData > m_cbData)
        m_cbData = m_iData;
   
    // Return amount written
    if (pcbWritten)
        *pcbWritten = cb;
    
exit:
    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CByteStream::Read
// -------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CByteStream::Read(LPVOID pv, ULONG cb, ULONG *pcbRead)
#else
STDMETHODIMP CByteStream::Read(VOID HUGEP *pv, ULONG cb, ULONG *pcbRead)
#endif // !WIN16
{
    // Locals
    ULONG cbRead=0;
    
    // Validate Args
    Assert(pv && m_iData <= m_cbData);
    
    // No Data
    if (m_cbData > 0)
    {
        // Determine how must to copy from current page...
        cbRead = min(cb - cbRead, m_cbData - m_iData);
        
        // Has this page been committed
        CopyMemory((LPBYTE)pv, (LPBYTE)(m_pbData + m_iData), cbRead);
        
        // Increment cbRead
        m_iData += cbRead;
    }
    
    // Return amount read
    if (pcbRead)
        *pcbRead = cbRead;
    
    // Done
    return S_OK;
}

// -------------------------------------------------------------------------
// CByteStream::Seek
// -------------------------------------------------------------------------
STDMETHODIMP CByteStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNew)
{
    // Locals
    HRESULT         hr=S_OK;
    LONG            lMove;
    ULONG           iNew;
    
    // No high part
    Assert(dlibMove.HighPart == 0);
    
    // Set lMove
#ifdef MAC
    lMove = dlibMove.LowPart;
#else   // !MAC
    lMove = (ULONG)dlibMove.QuadPart;
#endif  // MAC
    
    // Seek the file pointer
    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        if (lMove < 0)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
        iNew = lMove;
        break;
        
    case STREAM_SEEK_CUR:
        if (lMove < 0 && (ULONG)(abs(lMove)) > m_iData)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
        iNew = m_iData + lMove;
        break;
        
    case STREAM_SEEK_END:
        if (lMove < 0 || (ULONG)lMove > m_cbData)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
        iNew = m_cbData - lMove;
        break;
        
    default:
        hr = TrapError(STG_E_INVALIDFUNCTION);
        goto exit;
    }
    
    // New offset greater than size...
    m_iData = min(iNew, m_cbData);
    
    // Return Position
    if (plibNew)
#ifdef MAC
        ULISet32(*plibNew, m_iData);
#else   // !MAC
    plibNew->QuadPart = (LONGLONG)m_iData;
#endif  // MAC
    
exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CByteStream::Stat
// --------------------------------------------------------------------------------
STDMETHODIMP CByteStream::Stat(STATSTG *pStat, DWORD)
{
    // Parameters
    Assert(pStat);
    
    // If that failed, lets generate our own information (mainly, fill in size
    ZeroMemory(pStat, sizeof(STATSTG));
    pStat->type = STGTY_STREAM;
#ifdef MAC
    ULISet32(pStat->cbSize, m_cbData);
#else   // !MAC
    pStat->cbSize.QuadPart = m_cbData;
#endif  // MAC
    
    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CByteStream::ResetObject
// --------------------------------------------------------------------------------
void CByteStream::ResetObject(void)
{
    m_cbData = 0;
    m_iData = 0;
    m_pbData = NULL;
    m_cbAlloc = 0;
}

// --------------------------------------------------------------------------------
// CByteStream::AcquireBytes
// --------------------------------------------------------------------------------
void CByteStream::AcquireBytes(ULONG *pcb, LPBYTE *ppb, ACQUIRETYPE actype)
{
    // Return Bytes ?
    if (ppb)
    {
        // Give them by data
        *ppb = m_pbData;
        
        // Return the Size
        if (pcb)
            *pcb = m_cbData;
        
        // I don't own it anymore
        if (ACQ_DISPLACE == actype)
            ResetObject();
    }
    
    // Return Size ?
    else if (pcb)
        *pcb = m_cbData;
}

// --------------------------------------------------------------------------------
// CByteStream::HrAcquireStringA
// --------------------------------------------------------------------------------
HRESULT CByteStream::HrAcquireStringA(ULONG *pcch, LPSTR *ppszStringA, ACQUIRETYPE actype)
{
    // Locals
    HRESULT     hr=S_OK;

    // Return Bytes ?
    if (ppszStringA)
    {
        // Write a Null
        CHECKHR(hr = Write("", 1, NULL));
        
        // Give them by data
        *ppszStringA = (LPSTR)m_pbData;
        
        // Return the Size
        if (pcch)
            *pcch = m_cbData - 1;
        
        // I don't own it anymore
        if (ACQ_DISPLACE == actype)
            ResetObject();
    }
    
    // Return Size ?
    else if (pcch)
        *pcch = m_cbData;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CByteStream::AcquireStringW
// --------------------------------------------------------------------------------
HRESULT CByteStream::HrAcquireStringW(ULONG *pcch, LPWSTR *ppszStringW, ACQUIRETYPE actype)
{
    // Locals
    HRESULT     hr=S_OK;

    // Return Bytes ?
    if (ppszStringW)
    {
        // Write a Null
        CHECKHR(hr = Write("", 1, NULL));
        CHECKHR(hr = Write("", 1, NULL));
        
        // Give them by data
        *ppszStringW = (LPWSTR)m_pbData;
        
        // Return the Size
        if (pcch)
            *pcch = ((m_cbData - 2) / sizeof(WCHAR));
        
        // I don't own it anymore
        if (ACQ_DISPLACE == actype)
            ResetObject();
    }
    
    // Return Size ?
    else if (pcch)
        *pcch = (m_cbData / sizeof(WCHAR));

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\staticrt\debug.c ===
// --------------------------------------------------------------------------------
// Debug.c
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include <windows.h>
#include <stdarg.h>
#include "msoedbg.h"

ASSERTDATA

#ifdef DEBUG

#define E_PENDING          _HRESULT_TYPEDEF_(0x8000000AL)
#define FACILITY_INTERNET  12
#define MIME_E_NOT_FOUND   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_INTERNET, 0xCE05)

// --------------------------------------------------------------------------------
// DebugStrf
// --------------------------------------------------------------------------------
__cdecl DebugStrf(LPTSTR lpszFormat, ...)
{
    static TCHAR szDebugBuff[500];
    va_list arglist;

    va_start(arglist, lpszFormat);
    wvsprintf(szDebugBuff, lpszFormat, arglist);
    va_end(arglist);

    OutputDebugString(szDebugBuff);
}

// --------------------------------------------------------------------------------
// HrTrace
// --------------------------------------------------------------------------------
HRESULT HrTrace(HRESULT hr, LPSTR lpszFile, INT nLine)
{
    if (FAILED(hr) && MIME_E_NOT_FOUND != hr && E_PENDING != hr && E_NOINTERFACE != hr)
        DebugTrace("%s(%d) - HRESULT - %0X\n", lpszFile, nLine, hr);
    return hr;
}

// --------------------------------------------------------------------------------
// AssertSzFn
// --------------------------------------------------------------------------------
void AssertSzFn(LPSTR szMsg, LPSTR szFile, int nLine)
{
    static const char rgch1[]     = "File %s, line %d:";
    static const char rgch2[]     = "Unknown file:";
    static const char szAssert[]  = "Assert Failure";
    static const char szInstructions[] = "\n\nPress Abort to stop execution and break into a debugger.\nPress Retry to break into the debugger.\nPress Ignore to continue running the program.";

    char    rgch[1024];
    char   *lpsz;
    int     ret, cch;
    HWND    hwndActive;
    DWORD   dwFlags = MB_ABORTRETRYIGNORE | MB_ICONHAND | MB_SYSTEMMODAL | MB_SETFOREGROUND;

    if (szFile)
        wsprintf(rgch, rgch1, szFile, nLine);
    else
        lstrcpy(rgch, rgch2);

    lstrcat(rgch, szInstructions);
    
    cch = lstrlen(rgch);
    Assert(lstrlen(szMsg)<(512-cch-3));
    lpsz = &rgch[cch];
    *lpsz++ = '\n';
    *lpsz++ = '\n';
    lstrcpy(lpsz, szMsg);

    // If the active window is NULL, and we are running on
    // WinNT, let's set the MB_SERVICE_NOTIFICATION flag.  That
    // way, if we are running as a service, the message box will
    // pop-up on the desktop.
    //
    // NOTE:  This might not work in the case where we are a
    // service, and the current thread has called CoInitializeEx
    // with COINIT_APARTMENTTHREADED - 'cause in that case,
    // GetActiveWindow might return non-NULL  (apartment model
    // threads have message queues).  But hey - life's not
    // perfect...
    hwndActive = GetActiveWindow();
    if (hwndActive == NULL)
    {
        OSVERSIONINFO osvi;

        osvi.dwOSVersionInfoSize = sizeof(osvi);
        if (GetVersionEx(&osvi) && (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT))
        {
            // See the docs for MessageBox and the MB_SERVICE_NOTIFICATION flag
            // to see why we do this...
            if (osvi.dwMajorVersion < 4)
            {
                dwFlags |= MB_SERVICE_NOTIFICATION_NT3X;
            }
            else
            {
                dwFlags |= MB_SERVICE_NOTIFICATION;
            }
        }
    }

    ret = MessageBox(hwndActive, rgch, szAssert, dwFlags);

    if ((IDABORT == ret) || (IDRETRY== ret))
        DebugBreak();

    /* Force a hard exit w/ a GP-fault so that Dr. Watson generates a nice stack trace log. */
    if (ret == IDABORT)
        *(LPBYTE)0 = 1; // write to address 0 causes GP-fault
}

// --------------------------------------------------------------------------------
// NFAssertSzFn
// --------------------------------------------------------------------------------
void NFAssertSzFn(LPSTR szMsg, LPSTR szFile, int nLine)
{
    char rgch[512];
#ifdef MAC
    static const char rgch1[] = "Non-fatal assert:\n\tFile %s, line %u:\n\t%s\n";
#else   // !MAC
    static const char rgch1[] = "Non-fatal assert:\r\n\tFile %s, line %u:\r\n\t%s\r\n";
#endif  // MAC
    wsprintf(rgch, rgch1, szFile, nLine, szMsg ? szMsg : "");
    OutputDebugString(rgch);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\shell\res.h ===
#ifndef __RES_H
#define __RES_H

// string resources
#define idsOutlookExpress               99
#define idsStartupCantCreateMutex       100
#define idsStartupCantWaitForMutex      101
#define idsStartupCantLoadMSOEDLL       102
#define idsStartupCantInitMSOEDLL       103
#define idsStartupFailureUnknown        104
#define idsStartupModNotFoundMSOEDLL    105
#define idsStartupDllInitFailedMSOEDLL  106
#define idsStartupCantFindMSOEDLL       107
#define idsStartupCantFindResMSOEDLL    108

#define idiMailEXE          2
#define idiNewsEXE          3
#define idiMsgPropSentEXE   4
#define idiArtPropPostEXE   5

#endif // __RES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\staticrt\demand.cpp ===
// --------------------------------------------------------------------------------
// Demand.cpp
// Written By: jimsch, brimo, t-erikne (bastardized by sbailey)
// --------------------------------------------------------------------------------
// W4 stuff
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

// --------------------------------------------------------------------------------
// Includes
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "shlwapi.h"
#include "shared.h"
#define IMPLEMENT_LOADER_FUNCTIONS
#include "demand.h"

// --------------------------------------------------------------------------------
// CRIT_GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
    temp = (TYP_##fn) GetProcAddress(h, #fn);   \
    if (temp)                                   \
        VAR_##fn = temp;                        \
    else                                        \
        {                                       \
        AssertSz(0, VAR_##fn" failed to load"); \
        goto error;                             \
        }

// --------------------------------------------------------------------------------
// RESET
// --------------------------------------------------------------------------------
#define RESET(fn) VAR_##fn = LOADER_##fn;

// --------------------------------------------------------------------------------
// GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR(h, fn) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
    Assert(VAR_##fn != NULL); \
    if(NULL == VAR_##fn ) { \
        VAR_##fn  = LOADER_##fn; \
    }

// Use this for exports not available on all platforms
#define GET_PROC_ADDR_NOASSERT(h, fn) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
    if(NULL == VAR_##fn ) { \
        VAR_##fn  = LOADER_##fn; \
    }


// --------------------------------------------------------------------------------
// GET_PROC_ADDR_ORDINAL
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR_ORDINAL(h, fn, ord) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, MAKEINTRESOURCE(ord));  \
    Assert(VAR_##fn != NULL);  \
    if(NULL == VAR_##fn ) { \
        VAR_##fn  = LOADER_##fn; \
    }


// --------------------------------------------------------------------------------
// GET_PROC_ADDR3
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR3(h, fn, varname) \
    VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
    Assert(VAR_##varname != NULL);

// --------------------------------------------------------------------------------
// Static Globals
// --------------------------------------------------------------------------------
static HMODULE s_hCrypt     = NULL;
static HMODULE s_hCryptDlg  = NULL;
static HMODULE s_hWinTrust  = NULL;
static HMODULE s_hWinINET   = NULL;
static HMODULE s_hShell32   = NULL;
static HMODULE s_hOleAut32  = NULL;
static HMODULE s_hComDlg32  = NULL;
static HMODULE s_hVersion   = NULL;
static HMODULE s_hUrlmon    = NULL;
static HMODULE s_hShDocVw   = NULL;
static HMODULE s_hInetCPL   = NULL;
static HMODULE s_hMSO9      = NULL;
static HMODULE s_hWinMM     = NULL;
static HMODULE s_hRichEdit  = NULL;
static HMODULE s_hMLANG     = NULL;
static HMODULE s_hWSOCK     = NULL;
static HMODULE s_hPstoreC   = NULL;
static HMODULE s_hRAS       = NULL;
static HMODULE s_hAdvApi    = NULL;
static HMODULE s_hCryptUI   = NULL;
static HMODULE s_ShlWapi    = NULL;
static HMODULE s_hMSI       = NULL;

static CRITICAL_SECTION g_csDefLoad = {0};

BOOL            g_FSupportV3 = FALSE;

IF_DEBUG(static BOOL s_fInit = FALSE;)

// --------------------------------------------------------------------------------
// InitDemandLoadedLibs
// --------------------------------------------------------------------------------
void InitDemandLoadedLibs(void)
{
    InitializeCriticalSection(&g_csDefLoad);
    IF_DEBUG(s_fInit = TRUE;)
}

// --------------------------------------------------------------------------------
// FreeDemandLoadedLibs
// --------------------------------------------------------------------------------
void FreeDemandLoadedLibs(void)
{
    EnterCriticalSection(&g_csDefLoad);
    SafeFreeLibrary(s_hCrypt);
    SafeFreeLibrary(s_hCryptDlg);
    SafeFreeLibrary(s_hWinTrust);
    SafeFreeLibrary(s_hWinINET);
    SafeFreeLibrary(s_hWSOCK);
    SafeFreeLibrary(s_hShell32);
    SafeFreeLibrary(s_hOleAut32);
    SafeFreeLibrary(s_hComDlg32);
    SafeFreeLibrary(s_hVersion);
    SafeFreeLibrary(s_hUrlmon);
    SafeFreeLibrary(s_hMLANG);
    SafeFreeLibrary(s_hShDocVw);
    SafeFreeLibrary(s_hInetCPL);
    SafeFreeLibrary(s_hMSO9);
    SafeFreeLibrary(s_hWinMM);
    SafeFreeLibrary(s_hRichEdit);
    SafeFreeLibrary(s_hPstoreC);
    SafeFreeLibrary(s_hRAS);
    SafeFreeLibrary(s_hAdvApi);
    SafeFreeLibrary(s_ShlWapi);
    SafeFreeLibrary(s_hMSI);

    IF_DEBUG(s_fInit = FALSE;)
    LeaveCriticalSection(&g_csDefLoad);
    DeleteCriticalSection(&g_csDefLoad);
}

#ifdef DEAD
// --------------------------------------------------------------------------------
// CorrectAcctManPath
// --------------------------------------------------------------------------------
BOOL CorrectAcctManPath(LPTSTR pszPath, DWORD cb, DWORD *pdwT)
{
    HKEY hKey = NULL;
    BOOL fRet = FALSE;

    // Tracing
    TraceCall("CorrectAcctManPath");
    
    // Tact 1: Look for msoeacct.dll in same dir as inetcomm.dll

    // Try to open the inetcomm regkey
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegInetCommDll, 0, KEY_QUERY_VALUE, &hKey))
    {
        TraceResult(E_FAIL);
        goto exit;
    }

    // Query the Value
    if (ERROR_SUCCESS != RegQueryValueEx(hKey, c_szDllPath, 0, pdwT, (LPBYTE)pszPath, &cb))
    {
        TraceResult(E_FAIL);
        goto exit;
    }

    fRet = TRUE;

exit:
    // Cleanup
    if (hKey)
        RegCloseKey(hKey);

    return fRet;
}
#endif // DEAD

BOOL IsSMIME3Supported(void)
{
    if (0 == s_hCrypt)
        DemandLoadCrypt32();

    return(g_FSupportV3);
}

// --------------------------------------------------------------------------------
// DemandLoadCrypt32
// --------------------------------------------------------------------------------
BOOL DemandLoadCrypt32(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hCrypt)
        {
        s_hCrypt = LoadLibrary("CRYPT32.DLL");
        AssertSz((NULL != s_hCrypt), TEXT("LoadLibrary failed on CRYPT32.DLL"));

        if (0 == s_hCrypt)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hCrypt, CertRDNValueToStrA);
            GET_PROC_ADDR(s_hCrypt, CertAddCertificateContextToStore)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCertificateToStore)
            GET_PROC_ADDR(s_hCrypt, CertGetIssuerCertificateFromStore)
            GET_PROC_ADDR(s_hCrypt, CertEnumCertificatesInStore)
            GET_PROC_ADDR(s_hCrypt, CertFreeCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertFindCertificateInStore)
            GET_PROC_ADDR(s_hCrypt, CertVerifyTimeValidity)
            GET_PROC_ADDR(s_hCrypt, CertCompareCertificate)
            GET_PROC_ADDR(s_hCrypt, CertCompareCertificateName)
            GET_PROC_ADDR(s_hCrypt, CertCompareIntegerBlob)
            GET_PROC_ADDR(s_hCrypt, CertOpenStore)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateStore)
            GET_PROC_ADDR(s_hCrypt, CertCloseStore)
            GET_PROC_ADDR(s_hCrypt, CertControlStore)
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertGetSubjectCertificateFromStore)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObject)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObjectEx)
            GET_PROC_ADDR(s_hCrypt, CertFindRDNAttr)
            GET_PROC_ADDR(s_hCrypt, CryptMsgOpenToEncode)
            GET_PROC_ADDR(s_hCrypt, CryptMsgOpenToDecode)
            GET_PROC_ADDR(s_hCrypt, CryptMsgControl)
            GET_PROC_ADDR(s_hCrypt, CryptMsgUpdate)
            GET_PROC_ADDR(s_hCrypt, CryptMsgGetParam)
            GET_PROC_ADDR(s_hCrypt, CryptMsgClose)
            GET_PROC_ADDR(s_hCrypt, CryptEncodeObject)
            GET_PROC_ADDR(s_hCrypt, CryptEncodeObjectEx)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCRLToStore)
            GET_PROC_ADDR(s_hCrypt, CertEnumCRLsInStore)
            GET_PROC_ADDR(s_hCrypt, CertFindExtension)
            GET_PROC_ADDR(s_hCrypt, CertCreateCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertGetEnhancedKeyUsage);
            GET_PROC_ADDR(s_hCrypt, CertNameToStrA);
            GET_PROC_ADDR(s_hCrypt, CertAddStoreToCollection);
            GET_PROC_ADDR(s_hCrypt, CertVerifySubjectCertificateContext);
            GET_PROC_ADDR(s_hCrypt, CertSetCertificateContextProperty);
            GET_PROC_ADDR(s_hCrypt, CertFreeCertificateChain);
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateChain);
            GET_PROC_ADDR(s_hCrypt, CertVerifyCertificateChainPolicy);


            //
            //  We need to make a determination if the dll supports the
            //  new APIs we need or not
            //

            if (GetProcAddress(s_hCrypt, "CryptMsgVerifyCountersignatureEncodedEx") != NULL) {
                g_FSupportV3 = TRUE;
            }
        }
    }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

#ifdef DEAD
// --------------------------------------------------------------------------------
// SmartLoadLibrary
// --------------------------------------------------------------------------------
HINSTANCE SmartLoadLibrary(HKEY hKeyRoot, LPCSTR pszRegRoot, LPCSTR pszRegValue,
    LPCSTR pszDllName)
{
    // Locals
    BOOL            fProblem=FALSE;
    HINSTANCE       hInst=NULL;
    HKEY            hKey=NULL, hKey2 = NULL;
    CHAR            szPath[MAX_PATH];
    DWORD           cb=ARRAYSIZE(szPath);
    DWORD           dwT;
    DWORD           iEnd;
    LPSTR           pszPath=szPath;
    CHAR            szT[MAX_PATH];

    // Tracing
    TraceCall("SmartLoadLibrary");
    
    // Try to open the regkey
    if (ERROR_SUCCESS != RegOpenKeyEx(hKeyRoot, pszRegRoot, 0, KEY_QUERY_VALUE, &hKey))
    {
        TraceResult(E_FAIL);
        goto exit;
    }

    // Query the Value
    if (ERROR_SUCCESS != RegQueryValueEx(hKey, pszRegValue, 0, &dwT, (LPBYTE)szPath, &cb))
    {
        TraceResult(E_FAIL);
        goto exit;
    }

    // Special case: msoeacct reg entry may have been hosed by OL98
    // Looking for outlacct.dll\0 which has 13 characters
    if (!lstrcmpi(&szPath[cb-sizeof(TCHAR)*13], c_szOutlAcctManDll))
    {
        if (!CorrectAcctManPath(szPath, ARRAYSIZE(szPath), &dwT))
            // We're in trouble, couldn't find Inetcomm's path
            goto desperate;

        fProblem = TRUE;
    }

    // Remove the file name from the path
    PathRemoveFileSpec(szPath);

    // Get the End
    iEnd = lstrlen(szPath);

    // Append a backslash
    szPath[iEnd++] = '\\';

    // Append the Dll Name
    lstrcpyn(&szPath[iEnd], pszDllName, MAX_PATH - iEnd);

    if (fProblem)
    {
        // Try to open the regkey to save ourself in future - will fail if we are not admin!
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegMsoeAcctDll, 0, KEY_SET_VALUE, &hKey2))
        {
            RegSetValueEx(hKey2, c_szDllPath, 0, dwT, (LPBYTE)szPath, (iEnd+lstrlen(pszDllName)+1)*sizeof(TCHAR));
            RegCloseKey(hKey2);
        }
    }

    // Expand Sz ?
    if (REG_EXPAND_SZ == dwT)
    {
        // Expand It
        cb = ExpandEnvironmentStrings(szPath, szT, ARRAYSIZE(szT));

        // Failure
        if (cb == 0 || cb > ARRAYSIZE(szT))
        {
            TraceResult(E_FAIL);
            goto exit;
        }

        // Change pszPath
        pszPath = szT;
    }


    // Try to Load Library the Dll
    hInst = LoadLibrary(pszPath);

desperate:

    // Failure ?
    if (NULL == hInst)
    {
        // If we are not going to try the GetModuleFName, just try the dll name
        hInst = LoadLibrary(pszDllName);

        // We really failed
        if (NULL == hInst)
        {
            TraceResult(E_FAIL);
            goto exit;
        }
    }

exit:
    // Cleanup
    if (hKey)
        RegCloseKey(hKey);

    // Done
    return hInst;
}
#endif // DEAD

// --------------------------------------------------------------------------------
// DemandLoadCryptDlg
// --------------------------------------------------------------------------------
BOOL DemandLoadCryptDlg(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hCryptDlg)
        {
        s_hCryptDlg = LoadLibrary("CRYPTDLG.DLL");
        AssertSz((NULL != s_hCryptDlg), TEXT("LoadLibrary failed on CRYPTDLG.DLL"));

        if (0 == s_hCryptDlg)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hCryptDlg, CertViewPropertiesA)
            GET_PROC_ADDR(s_hCryptDlg, GetFriendlyNameOfCertA)
            GET_PROC_ADDR(s_hCryptDlg, CertSelectCertificateA)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadWinTrust
// --------------------------------------------------------------------------------
BOOL DemandLoadWinTrust(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWinTrust)
        {
        s_hWinTrust = LoadLibrary("WINTRUST.DLL");
        AssertSz((NULL != s_hWinTrust), TEXT("LoadLibrary failed on WINTRUST.DLL"));

        if (0 == s_hWinTrust)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWinTrust, WinVerifyTrust)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadWinINET
// --------------------------------------------------------------------------------
BOOL DemandLoadWinINET(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWinINET)
        {
        s_hWinINET = LoadLibrary("WININET.DLL");
        AssertSz((NULL != s_hWinINET), TEXT("LoadLibrary failed on WININET.DLL"));

        if (0 == s_hWinINET)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWinINET, RetrieveUrlCacheEntryFileA)
            GET_PROC_ADDR(s_hWinINET, UnlockUrlCacheEntryFileA)
            GET_PROC_ADDR(s_hWinINET, InternetQueryOptionA)
            GET_PROC_ADDR(s_hWinINET, InternetSetOptionA)
            GET_PROC_ADDR(s_hWinINET, InternetDialA)
            GET_PROC_ADDR(s_hWinINET, InternetHangUp)
            GET_PROC_ADDR(s_hWinINET, InternetGetConnectedStateExA)
            GET_PROC_ADDR(s_hWinINET, InternetCombineUrlA)
            GET_PROC_ADDR(s_hWinINET, InternetCrackUrlA)
            GET_PROC_ADDR(s_hWinINET, InternetCloseHandle)
            GET_PROC_ADDR(s_hWinINET, InternetReadFile)
            GET_PROC_ADDR(s_hWinINET, InternetConnectA)
            GET_PROC_ADDR(s_hWinINET, InternetOpenA)
            GET_PROC_ADDR(s_hWinINET, InternetSetStatusCallbackA)
            GET_PROC_ADDR(s_hWinINET, HttpQueryInfoA)
            GET_PROC_ADDR(s_hWinINET, HttpOpenRequestA)
            GET_PROC_ADDR(s_hWinINET, HttpAddRequestHeadersA)
            GET_PROC_ADDR(s_hWinINET, HttpSendRequestA)
            GET_PROC_ADDR(s_hWinINET, InternetWriteFile)
            GET_PROC_ADDR(s_hWinINET, HttpEndRequestA)
            GET_PROC_ADDR(s_hWinINET, HttpSendRequestExA)
            GET_PROC_ADDR(s_hWinINET, CommitUrlCacheEntryA)
            GET_PROC_ADDR(s_hWinINET, CreateUrlCacheEntryA)
            GET_PROC_ADDR(s_hWinINET, DeleteUrlCacheEntryA)

            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadWSOCK32
// --------------------------------------------------------------------------------
BOOL DemandLoadWSOCK32()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWSOCK)
        {
        s_hWSOCK = LoadLibrary("WSOCK32.DLL");
        AssertSz((NULL != s_hWSOCK), TEXT("LoadLibrary failed on WSOCK32.DLL"));

        if (0 == s_hWSOCK)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWSOCK, WSAStartup)
            GET_PROC_ADDR(s_hWSOCK, WSACleanup)
            GET_PROC_ADDR(s_hWSOCK, WSAGetLastError)
            GET_PROC_ADDR(s_hWSOCK, gethostname)
            GET_PROC_ADDR(s_hWSOCK, gethostbyname)
            GET_PROC_ADDR(s_hWSOCK, WSAAsyncGetHostByName)
            GET_PROC_ADDR(s_hWSOCK, inet_addr)
            GET_PROC_ADDR(s_hWSOCK, htons)
            GET_PROC_ADDR(s_hWSOCK, WSACancelAsyncRequest)
            GET_PROC_ADDR(s_hWSOCK, send)
            GET_PROC_ADDR(s_hWSOCK, connect)
            GET_PROC_ADDR(s_hWSOCK, WSAAsyncSelect)
            GET_PROC_ADDR(s_hWSOCK, socket)
            GET_PROC_ADDR(s_hWSOCK, inet_ntoa)
            GET_PROC_ADDR(s_hWSOCK, closesocket)
            GET_PROC_ADDR(s_hWSOCK, recv)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadSHELL32
// --------------------------------------------------------------------------------
BOOL DemandLoadSHELL32(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hShell32)
        {
        s_hShell32 = LoadLibrary("SHELL32.DLL");
        AssertSz((NULL != s_hShell32), TEXT("LoadLibrary failed on SHELL32.DLL"));

        if (0 == s_hShell32)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hShell32, SHGetPathFromIDListA);
            GET_PROC_ADDR_NOASSERT(s_hShell32, SHGetPathFromIDListW);
            GET_PROC_ADDR(s_hShell32, SHGetSpecialFolderLocation);
            GET_PROC_ADDR_ORDINAL(s_hShell32, SHFree, 195);
            GET_PROC_ADDR(s_hShell32, SHBrowseForFolderA);
            GET_PROC_ADDR_NOASSERT(s_hShell32, SHBrowseForFolderW);
            GET_PROC_ADDR_NOASSERT(s_hShell32, SHSetUnreadMailCountW);
            GET_PROC_ADDR(s_hShell32, ShellExecuteA);
            GET_PROC_ADDR(s_hShell32, ShellExecuteExA);
            GET_PROC_ADDR(s_hShell32, DragQueryFileA);
            GET_PROC_ADDR(s_hShell32, SHGetFileInfoA);
            GET_PROC_ADDR(s_hShell32, Shell_NotifyIconA);
            GET_PROC_ADDR(s_hShell32, ExtractIconA);
            GET_PROC_ADDR(s_hShell32, SHFileOperationA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}
         
#if 0
// --------------------------------------------------------------------------------
// DemandLoadOLEAUT32
// --------------------------------------------------------------------------------
BOOL DemandLoadOLEAUT32(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hOleAut32)
        {
        s_hOleAut32 = LoadLibrary("OLEAUT32.DLL");
        AssertSz((BOOL)s_hOleAut32, TEXT("LoadLibrary failed on OLEAUT32.DLL"));

        if (0 == s_hOleAut32)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hOleAut32, SafeArrayCreate);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayPutElement);
            GET_PROC_ADDR(s_hOleAut32, DispInvoke);
            GET_PROC_ADDR(s_hOleAut32, DispGetIDsOfNames);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayDestroy);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayGetUBound);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayGetLBound);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayGetElement);
            GET_PROC_ADDR(s_hOleAut32, SysAllocStringByteLen);
            GET_PROC_ADDR(s_hOleAut32, SysReAllocString);
            GET_PROC_ADDR(s_hOleAut32, SysAllocStringLen);
            GET_PROC_ADDR(s_hOleAut32, SysAllocString);
            GET_PROC_ADDR(s_hOleAut32, SysFreeString);
            GET_PROC_ADDR(s_hOleAut32, SysStringLen);
            GET_PROC_ADDR(s_hOleAut32, VariantInit);
            GET_PROC_ADDR(s_hOleAut32, LoadTypeLib);
            GET_PROC_ADDR(s_hOleAut32, RegisterTypeLib);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayAccessData);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayUnaccessData);
            GET_PROC_ADDR(s_hOleAut32, SysStringByteLen);
            GET_PROC_ADDR(s_hOleAut32, VariantClear);
            GET_PROC_ADDR(s_hOleAut32, VariantCopy);
            GET_PROC_ADDR(s_hOleAut32, SetErrorInfo);
            GET_PROC_ADDR(s_hOleAut32, CreateErrorInfo);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}
#endif

// --------------------------------------------------------------------------------
// DemandLoadCOMDLG32
// --------------------------------------------------------------------------------
BOOL DemandLoadCOMDLG32(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hComDlg32)
        {
        s_hComDlg32 = LoadLibrary("COMDLG32.DLL");
        AssertSz((NULL != s_hComDlg32), TEXT("LoadLibrary failed on COMDLG32.DLL"));

        if (0 == s_hComDlg32)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hComDlg32, GetSaveFileNameA);
            GET_PROC_ADDR(s_hComDlg32, GetOpenFileNameA);
            GET_PROC_ADDR(s_hComDlg32, ChooseFontA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadVERSION
// --------------------------------------------------------------------------------
BOOL DemandLoadVERSION(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hVersion)
        {
        s_hVersion = LoadLibrary("VERSION.DLL");
        AssertSz((NULL != s_hVersion), TEXT("LoadLibrary failed on VERSION.DLL"));

        if (0 == s_hVersion)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hVersion, VerQueryValueA);
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoA);
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoSizeA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadURLMON
// --------------------------------------------------------------------------------
BOOL DemandLoadURLMON(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hUrlmon)
        {
        s_hUrlmon = LoadLibrary("URLMON.DLL");
        AssertSz((NULL != s_hUrlmon), TEXT("LoadLibrary failed on URLMON.DLL"));

        if (0 == s_hUrlmon)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hUrlmon, CreateURLMoniker);
            GET_PROC_ADDR(s_hUrlmon, URLOpenBlockingStreamA);
            GET_PROC_ADDR(s_hUrlmon, FindMimeFromData);
            GET_PROC_ADDR(s_hUrlmon, CoInternetCombineUrl);
            GET_PROC_ADDR(s_hUrlmon, RegisterBindStatusCallback);
            GET_PROC_ADDR(s_hUrlmon, RevokeBindStatusCallback);
            GET_PROC_ADDR(s_hUrlmon, FaultInIEFeature);
            GET_PROC_ADDR(s_hUrlmon, CoInternetGetSecurityUrl);
            GET_PROC_ADDR(s_hUrlmon, ObtainUserAgentString);
            GET_PROC_ADDR(s_hUrlmon, CoInternetCreateSecurityManager);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadMLANG
// --------------------------------------------------------------------------------
BOOL DemandLoadMLANG(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hMLANG)
        {
        s_hMLANG = LoadLibrary("MLANG.DLL");
        AssertSz((NULL != s_hMLANG), TEXT("LoadLibrary failed on MLANG.DLL"));

        if (0 == s_hMLANG)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hMLANG, IsConvertINetStringAvailable)
            GET_PROC_ADDR(s_hMLANG, ConvertINetString)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadSHDOCVW
// --------------------------------------------------------------------------------
BOOL DemandLoadSHDOCVW()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hShDocVw)
        {
        s_hShDocVw = LoadLibrary("SHDOCVW.DLL");
        AssertSz((NULL != s_hShDocVw), TEXT("LoadLibrary failed on SHDOCVW.DLL"));

        if (0 == s_hShDocVw)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hShDocVw, AddUrlToFavorites);
            GET_PROC_ADDR(s_hShDocVw, SetQueryNetSessionCount);
            GET_PROC_ADDR(s_hShDocVw, SetShellOfflineState);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadINETCPL
// --------------------------------------------------------------------------------
BOOL DemandLoadINETCPL()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hInetCPL)
        {
        s_hInetCPL = LoadLibrary("INETCPL.CPL");
        AssertSz((NULL != s_hInetCPL), TEXT("LoadLibrary failed on INETCPL.CPL"));

        if (0 == s_hInetCPL)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hInetCPL, OpenFontsDialog);
            GET_PROC_ADDR(s_hInetCPL, LaunchConnectionDialog);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadMSO9
// --------------------------------------------------------------------------------
BOOL DemandLoadMSO9(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hMSO9)
        {
#ifdef DEBUG
        s_hMSO9 = LoadLibrary("mso9d.DLL");
        if (!s_hMSO9)
            s_hMSO9 = LoadLibrary("mso9.DLL");
#else
        s_hMSO9 = LoadLibrary("mso9.DLL");
#endif
        AssertSz((NULL != s_hMSO9), TEXT("LoadLibrary failed on MSO9.DLL"));

        if (0 == s_hMSO9)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR3(s_hMSO9, _MsoFGetComponentManager@4, MsoFGetComponentManager);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadWinMM
// --------------------------------------------------------------------------------
BOOL DemandLoadWinMM(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWinMM)
        {
        s_hWinMM = LoadLibrary("winmm.dll");
        AssertSz((NULL != s_hWinMM), TEXT("LoadLibrary failed on WINMM.DLL"));

        if (0 == s_hWinMM)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWinMM, sndPlaySoundA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadRichEdit
// --------------------------------------------------------------------------------
BOOL DemandLoadRichEdit(void)
{
    if (!s_hRichEdit)
        {
        s_hRichEdit = LoadLibrary("RICHED32.DLL");
        if (!s_hRichEdit)
            return FALSE;
        }

    return TRUE;
}

// --------------------------------------------------------------------------------
// DemandLoadPStoreC
// --------------------------------------------------------------------------------
BOOL DemandLoadPStoreC()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hPstoreC)
        {
        s_hPstoreC = LoadLibrary("PSTOREC.DLL");
        AssertSz((NULL != s_hPstoreC), TEXT("LoadLibrary failed on PSTOREC.DLL"));

        if (0 == s_hPstoreC)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hPstoreC, PStoreCreateInstance);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadRAS
// --------------------------------------------------------------------------------
BOOL DemandLoadRAS()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hRAS)
        {
        s_hRAS = LoadLibrary("RASAPI32.DLL");
        AssertSz((NULL != s_hRAS), TEXT("LoadLibrary failed on RASAPI32.DLL"));

        if (0 == s_hRAS)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hRAS, RasEnumEntriesA)
            GET_PROC_ADDR(s_hRAS, RasEditPhonebookEntryA)
            GET_PROC_ADDR(s_hRAS, RasCreatePhonebookEntryA)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

BOOL IsWin95()
{
    OSVERSIONINFOA       ver;
    ver.dwOSVersionInfoSize = sizeof(ver);

    if (GetVersionExA(&ver))
        {
        return (VER_PLATFORM_WIN32_WINDOWS == ver.dwPlatformId);
        }
    return FALSE;
}

BOOL MyCryptAcquireContextW(HCRYPTPROV * phProv, LPCWSTR pszContainer,
                            LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags)
{
    char        rgch1[256];
    char        rgch2[256];

    if (pszContainer != NULL)
        {
        WideCharToMultiByte(CP_ACP, 0, pszContainer, -1, rgch1, sizeof(rgch1),
                            NULL, NULL);
        pszContainer = (LPWSTR) rgch1;
        }

    if (pszProvider != NULL)
        {
        WideCharToMultiByte(CP_ACP, 0, pszProvider, -1, rgch2, sizeof(rgch2),
                            NULL, NULL);
        pszProvider = (LPWSTR) rgch2;
        }

    return CryptAcquireContextA(phProv, (LPCSTR) pszContainer,
                                (LPCSTR) pszProvider, dwProvType, dwFlags);
}

BOOL MY_CryptContextAddRef(HCRYPTPROV, DWORD * , DWORD )
{
#ifdef DEBUG
    return TRUE;
#else  // !DEBUG
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
#endif // DEBUG
}

BOOL MY_CryptDuplicateKey(HCRYPTKEY , DWORD * , DWORD , HCRYPTKEY * )
{
#ifdef DEBUG
    return TRUE;
#else // !DEBUG
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
#endif // DEBUG
}

BOOL DemandLoadAdvApi32()
{
    BOOL                fRet = TRUE;
    OSVERSIONINFOA       ver;

    ver.dwOSVersionInfoSize = sizeof(ver);

    Assert(s_fInit);

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hAdvApi)
        {
        if(!GetVersionExA(&ver))
            {
            fRet = FALSE;
            goto exit;
            }

        s_hAdvApi = LoadLibrary("ADVAPI32.DLL");
        AssertSz((NULL != s_hAdvApi), TEXT("LoadLibrary failed on ADVAPI32.DLL"));

        if (0 == s_hAdvApi)
            fRet = FALSE;
        else
            {
            if (VER_PLATFORM_WIN32_WINDOWS == ver.dwPlatformId) // Win95
                CryptAcquireContextW = MyCryptAcquireContextW;
            else
                GET_PROC_ADDR(s_hAdvApi, CryptAcquireContextW)

            VAR_CryptContextAddRef = LOADER_CryptContextAddRef;
            if((ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5))  //NT5
                {
                GET_PROC_ADDR(s_hAdvApi, CryptContextAddRef);
                GET_PROC_ADDR(s_hAdvApi, CryptDuplicateKey);
                }

            if (VAR_CryptContextAddRef == LOADER_CryptContextAddRef)
                VAR_CryptContextAddRef = MY_CryptContextAddRef;

            if (VAR_CryptDuplicateKey == LOADER_CryptDuplicateKey)
                VAR_CryptDuplicateKey = MY_CryptDuplicateKey;
            }
        }

exit:
    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

HINSTANCE DemandLoadShlWapi()
{
    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);
    
    if (!s_ShlWapi)
    {
        s_ShlWapi = LoadLibrary("shlwapi.dll");
        AssertSz((NULL != s_ShlWapi), TEXT("LoadLibrary failed on ShlWAPI.DLL"));
        
    }
    
    LeaveCriticalSection(&g_csDefLoad);
    return((HINSTANCE) s_ShlWapi);
}

BOOL DemandLoadCryptUI()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hCryptUI)
    {
        s_hCryptUI = LoadLibrary("CRYPTUI.DLL");
        AssertSz((NULL != s_hCryptUI), TEXT("LoadLibrary failed on CRYPTUI.DLL"));

        if (0 == s_hCryptUI)
            fRet = FALSE;
        else
        {
            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgCertMgr)
        }
    }
    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}


// --------------------------------------------------------------------------------
// DemandLoadMSI
// --------------------------------------------------------------------------------
BOOL DemandLoadMSI(void)
{
    BOOL fRet = TRUE;
    static BOOL s_fMSIInited = FALSE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    // Unlike other demand-loaded dlls, this dll may not exist and that's fine.  
    // In these cases s_hMSI will always be NULL, so we need another flag to tell
    // us whether we are inited.
    if (FALSE == s_fMSIInited)
    {
        s_fMSIInited = TRUE;

        s_hMSI = LoadLibrary("MSI.DLL");
        if (NULL == s_hMSI)
            fRet = FALSE;
        else
        {
            // It's okay to use the asserting macro here because while MSI is
            // optional, if present it must have these entry points
            GET_PROC_ADDR(s_hMSI, MsiEnumComponentQualifiersA);
            GET_PROC_ADDR(s_hMSI, MsiProvideQualifiedComponentA);
            GET_PROC_ADDR(s_hMSI, MsiLocateComponentA);
            GET_PROC_ADDR(s_hMSI, MsiSetInternalUI);
        }
    }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\shell\msimn.c ===
// --------------------------------------------------------------------------------
// MSIMN.C
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.h"
#define DEFINE_STRCONST
#include <msoeapi.h>
#include "msimnp.h"
#include "res.h"
#include "../msoeres/resource.h"
#include "shared.h"
#include "msoert.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include <mapicode.h>
#include "error.h"

// --------------------------------------------------------------------------------
// String Consts
// --------------------------------------------------------------------------------
static const WCHAR c_wszRegCmd[]      = L"/reg";
static const WCHAR c_wszUnRegCmd[]    = L"/unreg";
static const WCHAR c_wszEmpty[]       = L"";
static const char c_szLangDll[]     = "MSOERES.DLL";
static const char c_szOLNewsKey[]   = "Software\\Clients\\News\\Microsoft Outlook";
static const char c_szRegOLNews[]   = "OLNews";
static const char c_szRegFlat[]     = "Software\\Microsoft\\Outlook Express";
static const char c_szDontUpgradeOLNews[] = "NoUpgradeOLNews";

// --------------------------------------------------------------------------------
// Debug Strings
// --------------------------------------------------------------------------------
#ifdef DEBUG
static const TCHAR c_szDebug[]      = "mshtmdbg.dll";
static const TCHAR c_szDebugUI[]    = "DbgExDoTracePointsDialog";
static const TCHAR c_szRegSpy[]     = "DbgExGetMallocSpy";
static const WCHAR c_wszInvokeUI[]  = L"/d";
#endif

// --------------------------------------------------------------------------------
// MSHTMDBG.DLL Prototypes
// --------------------------------------------------------------------------------
#ifdef DEBUG
typedef void (STDAPICALLTYPE *PFNDEBUGUI)(BOOL);
typedef void *(STDAPICALLTYPE *PFNREGSPY)(void);
#endif

// --------------------------------------------------------------------------------
// Debug Prototypes
// --------------------------------------------------------------------------------
#ifdef DEBUG
void LoadMSHTMDBG(LPWSTR pwszCmdLine);
#endif

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
int WinMainT(HINSTANCE hInst, HINSTANCE hInstPrev, LPWSTR pwszCmdLine, int nCmdShow);

// --------------------------------------------------------------------------------
// UpgradeOLNewsReader()
// --------------------------------------------------------------------------------
void UpgradeOLNewsReader(HINSTANCE hInst)
{
    HKEY hkey;
    BOOL fOK = TRUE;
    DWORD dwDont, cb;
    
    // Make sure this functionality hasn't been disabled
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_READ, &hkey))
    {
        cb = sizeof(dwDont);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szDontUpgradeOLNews, 0, NULL, (LPBYTE)&dwDont, &cb))
            fOK = 0 == dwDont;

        RegCloseKey(hkey);
    }

    if (fOK && ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szOLNewsKey, 0, KEY_READ, &hkey))
    {
        RegCloseKey(hkey);

        CallRegInstall(hInst, hInst, c_szRegOLNews, (LPSTR)c_szOLNewsKey);
    }
}

// --------------------------------------------------------------------------------
// ModuleEntry - Stolen from the CRT, used to shirink our code
// --------------------------------------------------------------------------------
int _stdcall ModuleEntry(void)
{
    // Locals
    int             i;
    STARTUPINFOA    si;
    LPWSTR          pwszCmdLine;

    // Get the command line
    pwszCmdLine = GetCommandLineW();

    // We don't want the "No disk in drive X:" requesters, so we set the critical error mask such that calls will just silently fail
    SetErrorMode(SEM_FAILCRITICALERRORS);

    // Parse the command line
    if ( *pwszCmdLine == L'\"') 
    {
        // Scan, and skip over, subsequent characters until another double-quote or a null is encountered.
        while ( *++pwszCmdLine && (*pwszCmdLine != L'\"'))
            {};

        // If we stopped on a double-quote (usual case), skip over it.
        if (*pwszCmdLine == L'\"')
            pwszCmdLine++;
    }
    else 
    {
        while (*pwszCmdLine > L' ')
            pwszCmdLine++;
    }

    // Skip past any white space preceeding the second token.
    while (*pwszCmdLine && (*pwszCmdLine <= L' ')) 
        pwszCmdLine++;

    // Get startup information...
    si.dwFlags = 0;
    GetStartupInfoA(&si);

    // Call the real winmain
    i = WinMainT(GetModuleHandle(NULL), NULL, pwszCmdLine, (si.dwFlags & STARTF_USESHOWWINDOW) ? si.wShowWindow : SW_SHOWDEFAULT);

    // Since we now have a way for an extension to tell us when it is finished, we will terminate all processes when the main thread goes away.
    ExitProcess(i);

    // Done
    return i;
}

// --------------------------------------------------------------------------------
// WinMain
// --------------------------------------------------------------------------------
int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, LPSTR pszCmdLine, int nCmdShow)
{
    // Just call ModuleEntry
    return(ModuleEntry());
}

// --------------------------------------------------------------------------------
// WinMainT
// --------------------------------------------------------------------------------
int WinMainT(HINSTANCE hInst, HINSTANCE hInstPrev, LPWSTR pwszCmdLine, int nCmdShow)
{
    // Locals
    HANDLE      hMutex=NULL;
    HWND        hwnd;
    DWORD       dwWait, dwError;
    INT         nErrorIds=0;
    PFNSTART    pfnStart;
    HINSTANCE   hInstMSOEDLL=NULL;
    HRESULT     hrOE;
    HINSTANCE   hInstUSER=NULL;
    static BOOL fFirstID=TRUE;

    // Register
    if (0 == StrCmpIW(c_wszRegCmd, pwszCmdLine))
    {
        CallRegInstall(hInst, hInst, c_szReg, NULL);
        
        // It not great to do this here, but we've only just written the OEOL keys,
        // and it would be worst to hit the reg during startup
        UpgradeOLNewsReader(hInst);

        return(1);
    }

    // Unregister
    else if (0 == StrCmpIW(c_wszUnRegCmd, pwszCmdLine))
    {
        CallRegInstall(hInst, hInst, c_szUnReg, NULL);
        return(1);
    }

    // Create the start shared mutex
    hMutex = CreateMutex(NULL, FALSE, STR_MSOEAPI_INSTANCEMUTEX);
    if (NULL == hMutex)
    {
        nErrorIds = idsStartupCantCreateMutex;
        goto exit;
    }

    // Wait for any current startups/shutdowns to finish
    dwWait = WaitForSingleObject(hMutex, (1000 * 60));
    if (dwWait != WAIT_OBJECT_0)
    {
        nErrorIds = idsStartupCantWaitForMutex;
        goto exit;
    }

    // Look for a current instance of the application
    hwnd = FindWindowWrapW(STRW_MSOEAPI_INSTANCECLASS, NULL);

    // is there another instance running already?
    if (NULL != hwnd)
    {
        // Locals
        COPYDATASTRUCT cds;
        DWORD_PTR      dwResult;

        // Some friendly output
        IF_DEBUG(OutputDebugString("Another instance of Athena was found...\n\n");)

        // Initialize the Copy data structure
        cds.dwData = MSOEAPI_ACDM_CMDLINE;
        cds.cbData = pwszCmdLine ? (lstrlenW(pwszCmdLine)+1)*sizeof(*pwszCmdLine) : 0;
        cds.lpData = pwszCmdLine;

        // On NT5, we need to call this to allow our window in the other process to take the foreground
        hInstUSER = LoadLibrary("USER32.DLL");
        if (hInstUSER)
        {
            FARPROC pfn = GetProcAddress(hInstUSER, "AllowSetForegroundWindow");
            if (pfn)
            {
                DWORD dwProcessId;
                GetWindowThreadProcessId(hwnd, &dwProcessId);
                (*pfn)(dwProcessId);
            }

            FreeLibrary(hInstUSER);
        }

        // Show the window into the foreground
        SetForegroundWindow(hwnd);
        SendMessageTimeout(hwnd, WM_COPYDATA, (WPARAM)NULL, (LPARAM)&cds, SMTO_ABORTIFHUNG, 1500, &dwResult);
    }

    // Lets load msoe.dll
    else
    {
        // Load Debug DLL
        IF_DEBUG(LoadMSHTMDBG(pwszCmdLine);)

        // Get the proc address of MSOE.DLL
        hInstMSOEDLL = LoadLibrary(STR_MSOEAPI_DLLNAME);

        // Did we load the dll
        if (NULL == hInstMSOEDLL)
        {
            dwError = GetLastError();
            if (dwError == ERROR_MOD_NOT_FOUND)
            {
                if (0xffffffff == GetFileAttributes(STR_MSOEAPI_DLLNAME))
                    nErrorIds = idsStartupCantFindMSOEDLL;
                else
                    nErrorIds = idsStartupModNotFoundMSOEDLL;
            }
            else if (dwError == ERROR_DLL_INIT_FAILED)
            {
                if (0xffffffff == GetFileAttributes(c_szLangDll))
                    nErrorIds = idsStartupCantFindResMSOEDLL;
                else
                    nErrorIds = idsStartupDllInitFailedMSOEDLL;
            }
            else
            {
                nErrorIds = idsStartupCantLoadMSOEDLL;
            }

            goto exit;
        }

        // Unlikely that this will fail
        pfnStart = (PFNSTART)GetProcAddress(hInstMSOEDLL, STR_MSOEAPI_START);

        // Did that Fail
        if (NULL == pfnStart)
        {
            nErrorIds = idsStartupCantLoadMSOEDLL;
            goto exit;
        }

        hrOE = S_RESTART_OE;
        
        while (S_RESTART_OE == hrOE)
        {
            hrOE = pfnStart(MSOEAPI_START_APPLICATION, (fFirstID ? pwszCmdLine : c_wszEmpty), nCmdShow);
            fFirstID = FALSE;
        }

        // NB: pfnInit will not return until the main message pump terminates
        if (SUCCEEDED(hrOE))
        {
            CloseHandle(hMutex);
            hMutex = NULL;
        }

        // The dll couldn't be loaded, as long as it wasn't due to need for ICW, display error
        else if (hrOE != hrUserCancel && hrOE != MAPI_E_USER_CANCEL)
        {
            nErrorIds = idsStartupCantInitMSOEDLL;
            goto exit;
        }
    }

exit:
    // Cleanup
    if (hMutex)
    {
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }

    // Free msoe.dll
    if (hInstMSOEDLL)
        FreeLibrary(hInstMSOEDLL);

    // Show an error ?
    if (0 != nErrorIds)
    {
        // Locals
        CHAR        szRes[255];
        CHAR        szTitle[100];

        // Load the 
        LoadString(hInst, idsOutlookExpress, szTitle, ARRAYSIZE(szTitle));

        // Load the 
        LoadString(hInst, nErrorIds, szRes, ARRAYSIZE(szRes));

        // Show the error message
        MessageBox(NULL, szRes, szTitle, MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);
    }


    IF_DEBUG(CoRevokeMallocSpy());

    // Done
    return nErrorIds;
}

#ifdef DEBUG
// --------------------------------------------------------------------------------
// LoadMSHTMDBG
// --------------------------------------------------------------------------------
void LoadMSHTMDBG(LPWSTR pwszCmdLine)
{
    // Load mshtmdbg.dll
    HINSTANCE hInstDebug = LoadLibrary(c_szDebug);

    // Did it load ?
    if (NULL != hInstDebug)
    {
        // Locals
        PFNREGSPY  pfnRegSpy;

        // If the user passed /d on the command line, lets configure mshtmdbg.dll
        if (0 == StrCmpIW(pwszCmdLine, c_wszInvokeUI))
        {
            // Locals
            PFNDEBUGUI pfnDebugUI;

            // Get the proc address of the UI
            pfnDebugUI = (PFNDEBUGUI)GetProcAddress(hInstDebug, c_szDebugUI);
            if (NULL != pfnDebugUI)
            {
                (*pfnDebugUI)(TRUE);
                goto exit;
            }
        }

        // Get the process address of the registration
        pfnRegSpy = (PFNREGSPY)GetProcAddress(hInstDebug, c_szRegSpy);
        if (NULL != pfnRegSpy)
        {
            LPMALLOCSPY pSpy = (IMallocSpy *)(*pfnRegSpy)();
            SideAssert(SUCCEEDED(CoRegisterMallocSpy(pSpy)));
        }
    }

exit:
    // Done
    return;
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\staticrt\privunk.cpp ===
// --------------------------------------------------------------------------------
// Privunk.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "privunk.h"
#include <shlobj.h>
#include <shlobjp.h>

// --------------------------------------------------------------------------------
// CPrivateUnknown::CPrivateUnknown
// --------------------------------------------------------------------------------
CPrivateUnknown::CPrivateUnknown(IUnknown *pUnkOuter) 
{
    m_pUnkOuter = pUnkOuter ? pUnkOuter : &m_cUnkInner;
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::SetOuter
// --------------------------------------------------------------------------------
void CPrivateUnknown::SetOuter(IUnknown *pUnkOuter)
{
    // Must have an outer, and should not have been aggregated yet...
    Assert(pUnkOuter && m_pUnkOuter == &m_cUnkInner);

    // Save pUnkOuter
    m_pUnkOuter = pUnkOuter;
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::CUnkInner::QueryInterface
// --------------------------------------------------------------------------------
HRESULT CPrivateUnknown::CUnkInner::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    // I can handle the unknown
    if (IsEqualIID(riid, IID_IUnknown))
    {
        // Return IUnknown
        *ppvObj = SAFECAST(this, IUnknown *);

        // Increment Ref Count
        InterlockedIncrement(&m_cRef);

        // Done
        return S_OK;
    }

    // Get my parent (computes the offset of the parent's base address)
    CPrivateUnknown *pParent = IToClass(CPrivateUnknown, m_cUnkInner, this);

    // Dispatch to PrivateQueryInterface
    return pParent->PrivateQueryInterface(riid, ppvObj);
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::CUnkInner::AddRef
// --------------------------------------------------------------------------------
ULONG CPrivateUnknown::CUnkInner::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::CUnkInner::Release
// --------------------------------------------------------------------------------
ULONG CPrivateUnknown::CUnkInner::Release(void)
{
    // Decrement Internal Reference Count
    LONG cRef = InterlockedDecrement(&m_cRef);

    // No dead yet...
    if (cRef > 0)
        return (ULONG)cRef;

    // Some groovy, mystical, disco stuff
    // protect against cached pointers bumping us up then down
    m_cRef = 1000; 

    // Get the parent
    CPrivateUnknown* pParent = IToClass(CPrivateUnknown, m_cUnkInner, this);

    // Kill the parent
    delete pParent;

    // Done
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\staticrt\shared.cpp ===
/*
*    shared.cpp
*    
*    History:
*      Feb '98: Created.
*    
*    Copyright (C) Microsoft Corp. 1998
*
*   Only place code in here that all dlls will have STATICALLY LINKED to them
*/

#include "pch.hxx"
#include <advpub.h>
#define DEFINE_SHARED_STRINGS
#include "shared.h"
#include <migerror.h>

// BUGBUG (neilbren)
// I'm going to clear all this SHLWAPI stuff out when I get a chance

#define CH_WHACK '\\'

// SHLWAPI
// add a backslash to a qualified path
//
// in:
//  lpszPath    path (A:, C:\foo, etc)
//
// out:
//  lpszPath    A:\, C:\foo\    ;
//
// returns:
//  pointer to the NULL that terminates the path
STDAPI_(LPTSTR)
PathAddBackslash(
    LPTSTR lpszPath)
{
    LPTSTR lpszEnd;

    // perf: avoid lstrlen call for guys who pass in ptr to end
    // of buffer (or rather, EOB - 1).
    // note that such callers need to check for overflow themselves.
    int ichPath = (*lpszPath && !*(lpszPath + 1)) ? 1 : lstrlen(lpszPath);

    // try to keep us from tromping over MAX_PATH in size.
    // if we find these cases, return NULL.  Note: We need to
    // check those places that call us to handle their GP fault
    // if they try to use the NULL!
    if (ichPath >= (MAX_PATH - 1))
    {
        Assert(FALSE);      // Let the caller know!
        return(NULL);
    }

    lpszEnd = lpszPath + ichPath;

    // this is really an error, caller shouldn't pass
    // an empty string
    if (!*lpszPath)
        return lpszEnd;

    /* Get the end of the source directory
    */
    switch(*CharPrev(lpszPath, lpszEnd)) {
    case CH_WHACK:
        break;

    default:
        *lpszEnd++ = CH_WHACK;
        *lpszEnd = TEXT('\0');
    }
    return lpszEnd;
}


/*
    Stolen from Path.c in Shlwapi so that we don't have to link this static lib to them
*/
STDAPI_(BOOL)
PathRemoveFileSpec(
    LPTSTR pFile)
{
    LPTSTR pT;
    LPTSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == TEXT('\\'))
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == TEXT(':')) {   // skip ":\" so we don't
            if (pT2[1] ==TEXT('\\'))    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == TEXT('\\'))) {
        // Is it just a '\'?
        if (*(pT+1) != TEXT('\0')) {
            // Nope.
            *(pT+1) = TEXT('\0');
            return TRUE;        // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}

/*
 * ChrCmpI - Case insensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared;
 *           HIBYTE of wMatch is 0 if not a DBC
 * Return    FALSE if match, TRUE if not
 */
BOOL ChrCmpIA(WORD w1, WORD wMatch)
{
    char sz1[3], sz2[3];

    if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
    {
        sz1[1] = HIBYTE(w1);
        sz1[2] = '\0';
    }
    else
        sz1[1] = '\0';

    *(WORD FAR *)sz2 = wMatch;
    sz2[2] = '\0';
    return lstrcmpiA(sz1, sz2);
}

/*
 * StrChrI - Find first occurrence of character in string, case insensitive
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR FAR PASCAL StrChrIA(LPCSTR lpStart, WORD wMatch)
{
    wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));

    for ( ; *lpStart; lpStart = AnsiNext(lpStart))
    {
        if (!ChrCmpIA(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            return((LPSTR)lpStart);
    }
    return (NULL);
}

/*
 * StrCmpNI     - Compare n bytes, case insensitive
 *
 * returns   See lstrcmpi return values.
 */
int FAR PASCAL StrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar)
{
    int i;
    LPCSTR lpszEnd = lpStr1 + nChar;

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); (lpStr1 = AnsiNext(lpStr1)), (lpStr2 = AnsiNext(lpStr2))) {
        WORD w1;
        WORD w2;

        // If either pointer is at the null terminator already,
        // we want to copy just one byte to make sure we don't read 
        // past the buffer (might be at a page boundary).

        w1 = (*lpStr1) ? *(UNALIGNED WORD *)lpStr1 : 0;
        w2 = (UINT)(IsDBCSLeadByte(*lpStr2)) ? *(UNALIGNED WORD *)lpStr2 : (WORD)(BYTE)(*lpStr2);

        i = ChrCmpIA(w1, w2);
        if (i)
            return i;
    }
    return 0;
}


/*
 * StrStrI   - Search for first occurrence of a substring, case insensitive
 *
 * Assumes   lpFirst points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
LPSTR FAR PASCAL StrStrIA(LPCSTR lpFirst, LPCSTR lpSrch)
{
    UINT uLen;
    WORD wMatch;

    uLen = (UINT)lstrlenA(lpSrch);
    wMatch = *(UNALIGNED WORD FAR *)lpSrch;

    for ( ; (lpFirst = StrChrIA(lpFirst, wMatch)) != 0 && StrCmpNIA(lpFirst, lpSrch, uLen);
         lpFirst=AnsiNext(lpFirst))
        continue; /* continue until we hit the end of the string or get a match */

    return((LPSTR)lpFirst);
}

BOOL GetProgramFilesDir(LPSTR pszPrgfDir, DWORD dwSize, DWORD dwVer)
{
    HKEY  hkey;
    DWORD dwType;

    *pszPrgfDir = 0;

    if (dwVer >= 5)
    {
        if ( GetEnvironmentVariable( TEXT("ProgramFiles"), pszPrgfDir, dwSize ) )
            return TRUE;
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegWinCurrVer, 0, KEY_QUERY_VALUE, &hkey))
    {
        if (dwVer >= 4)
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szProgFilesDir, 0, &dwType, (LPBYTE)pszPrgfDir, &dwSize))
            
            {
                char szSysDrv[5] = { 0 };

                // combine reg value and systemDrive to get the acurate ProgramFiles dir
                if ( GetEnvironmentVariable( TEXT("SystemDrive"), szSysDrv, ARRAYSIZE(szSysDrv) ) &&
                     szSysDrv[0] )
                    *pszPrgfDir = szSysDrv[0];
            }

        RegCloseKey(hkey);
        return TRUE;
    }
     
    return FALSE;
}

BOOL ReplaceSubString( LPSTR pszOutLine, LPCSTR pszOldLine, LPCSTR pszSubStr, LPCSTR pszSubReplacement )
{
    LPSTR	lpszStart = NULL;
    LPSTR	lpszNewLine;
    LPCSTR	lpszCur;
    BOOL	bFound = FALSE;
    int		ilen;

    lpszCur = pszOldLine;
    lpszNewLine = pszOutLine;
    while ( lpszStart = StrStrIA( lpszCur, pszSubStr ) )
    {
        // this module path has the systemroot            
        ilen = (int) (lpszStart - lpszCur);
        if ( ilen )
        {
            lstrcpyn( lpszNewLine, lpszCur, ilen + 1 );
            lpszNewLine += ilen;
        }
        lstrcpy( lpszNewLine, pszSubReplacement );

        lpszCur = lpszStart + lstrlen(pszSubStr);
        lpszNewLine += lstrlen(pszSubReplacement);
        bFound = TRUE;
    }

    lstrcpy( lpszNewLine, lpszCur );

    return bFound;
}

//==========================================================================================
// AddEnvInPath - Ripped from Advpack
//==========================================================================================
BOOL AddEnvInPath(LPCSTR pszOldPath, LPSTR pszNew)
{
    static OSVERSIONINFO verinfo;
    static BOOL          bNeedOSInfo=TRUE;

    CHAR szBuf[MAX_PATH], szEnvVar[MAX_PATH];
    CHAR szReplaceStr[100];    
    CHAR szSysDrv[5];
    BOOL bFound = FALSE;
    
    // Do we need to check the OS version or is it cached?
    if (bNeedOSInfo)
    {
        bNeedOSInfo = FALSE;
        verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if (GetVersionEx(&verinfo) == FALSE)
        {
            AssertSz(FALSE, "AddEnvInPath: Couldn't obtain OS ver info.");
            verinfo.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS;
        }
    }
        
    // Variable substitution is only supported on NT
    if(VER_PLATFORM_WIN32_NT != verinfo.dwPlatformId)
        goto exit;

    // Try to replace USERPROFILE
    if ( GetEnvironmentVariable( "UserProfile", szEnvVar, ARRAYSIZE(szEnvVar) )  &&
         ReplaceSubString( szBuf, pszOldPath, szEnvVar, "%UserProfile%" ) )
    {
        bFound = TRUE;
    }

    // Try to replace the Program Files Dir
    else if ( (verinfo.dwMajorVersion >= 5) && GetEnvironmentVariable( "ProgramFiles", szEnvVar, ARRAYSIZE(szEnvVar) ) &&
              ReplaceSubString( szBuf, pszOldPath, szEnvVar, "%ProgramFiles%" ) )
    {
        bFound = TRUE;
    }

    // replace c:\winnt Windows folder
    else if ( GetEnvironmentVariable( "SystemRoot", szEnvVar, ARRAYSIZE(szEnvVar) ) &&
              ReplaceSubString( szBuf, pszOldPath, szEnvVar, "%SystemRoot%" ) )
    {
        bFound = TRUE;
    }

    // Replace the c: System Drive letter
    else if ( GetEnvironmentVariable( "SystemDrive", szSysDrv, ARRAYSIZE(szSysDrv) ) && 
              ReplaceSubString( szBuf, pszOldPath, szSysDrv, "%SystemDrive%" ) )
    {
        bFound = TRUE;
    }

exit:
    // this way, if caller pass the same location for both params, still OK.
    if ( bFound ||  ( pszNew != pszOldPath ) )
        lstrcpy( pszNew, bFound ? szBuf : pszOldPath );
    return bFound;    
}


// --------------------------------------------------------------------------------
// CallRegInstall - Self-Registration Helper
// --------------------------------------------------------------------------------
HRESULT CallRegInstall(HINSTANCE hInstCaller, HINSTANCE hInstRes, LPCSTR pszSection, LPSTR pszExtra)
{
    AssertSz(hInstCaller, "[ARGS] CallRegInstall: NULL hInstCaller");
    AssertSz(hInstRes,    "[ARGS] CallRegInstall: NULL hInstRes");
    AssertSz(hInstRes,    "[ARGS] CallRegInstall: NULL pszSection");
    
    HRESULT     hr = E_FAIL;
    HINSTANCE   hAdvPack;
    REGINSTALL  pfnri;
    CHAR        szDll[MAX_PATH], szDir[MAX_PATH];
    int         cch;
    // 3 to allow for pszExtra
    STRENTRY    seReg[3];
    STRTABLE    stReg;

    hAdvPack = LoadLibraryA(c_szAdvPackDll);
    if (NULL == hAdvPack)
        goto exit;

    // Get our location
    GetModuleFileName(hInstCaller, szDll, ARRAYSIZE(szDll));

    // Get Proc Address for registration util
    pfnri = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
    if (NULL == pfnri)
        goto exit;

    AddEnvInPath(szDll,szDll);

    // Setup special registration stuff
    // Do this instead of relying on _SYS_MOD_PATH which loses spaces under '95
    stReg.cEntries = 0;
    seReg[stReg.cEntries].pszName = "SYS_MOD_PATH";
    seReg[stReg.cEntries].pszValue = szDll;
    stReg.cEntries++;    

    if (lstrlen(szDll) > MAX_PATH-1)
        lstrcpyn(szDir, szDll, MAX_PATH);
    else
        lstrcpy(szDir, szDll);
    PathRemoveFileSpec(szDir);

    seReg[stReg.cEntries].pszName = "SYS_MOD_PATH_DIR";
    seReg[stReg.cEntries].pszValue = szDir;
    stReg.cEntries++;
    
    // Allow for caller to give us another string to use in the INF
    if (pszExtra)
    {
        seReg[stReg.cEntries].pszName = "SYS_EXTRA";
        seReg[stReg.cEntries].pszValue = pszExtra;
        stReg.cEntries++;
    }
    
    stReg.pse = seReg;

    // Call the self-reg routine
    hr = pfnri(hInstRes, pszSection, &stReg);

exit:
    // Cleanup
    SafeFreeLibrary(hAdvPack);
    return(hr);
}


//--------------------------------------------------------------------------
// MakeFilePath
//--------------------------------------------------------------------------
HRESULT MakeFilePath(LPCSTR pszDirectory, LPCSTR pszFileName, 
    LPCSTR pszExtension, LPSTR pszFilePath, ULONG cchMaxFilePath)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cchDirectory=lstrlen(pszDirectory);

    // Trace
    TraceCall("MakeFilePath");

    // Invalid Args
    Assert(pszDirectory && pszFileName && pszExtension && pszFilePath && cchMaxFilePath >= MAX_PATH);
    Assert(pszExtension[0] == '\0' || pszExtension[0] == '.');

    // Remove for folders
    if (cchDirectory + 1 + lstrlen(pszFileName) + lstrlen(pszExtension) >= (INT)cchMaxFilePath)
    {
    	hr = TraceResult(E_FAIL);
    	goto exit;
    }

    // Do we need a backslash
    if ('\\' != *CharPrev(pszDirectory, pszDirectory + cchDirectory))
    {
        // Append backslash
        SideAssert(wsprintf(pszFilePath, "%s\\%s%s", pszDirectory, pszFileName, pszExtension) < (INT)cchMaxFilePath);
    }

    // Otherwise
    else
    {
        // Append backslash
        SideAssert(wsprintf(pszFilePath, "%s%s%s", pszDirectory, pszFileName, pszExtension) < (INT)cchMaxFilePath);
    }
    
exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CloseMemoryFile
// --------------------------------------------------------------------------------
HRESULT CloseMemoryFile(LPMEMORYFILE pFile)
{
    // Trace
    TraceCall("CloseMemoryFile");

    // Args
    Assert(pFile);

    // Close the View
    if (pFile->pView)
        UnmapViewOfFile(pFile->pView);

    // Close the Memory Map
    if (pFile->hMemoryMap)
        CloseHandle(pFile->hMemoryMap);

    // Close the File
    if (pFile->hFile)
        CloseHandle(pFile->hFile);

    // Zero
    ZeroMemory(pFile, sizeof(MEMORYFILE));

    // Done
    return S_OK;
}

//--------------------------------------------------------------------------
// OpenMemoryFile
//--------------------------------------------------------------------------
HRESULT OpenMemoryFile(LPCSTR pszFile, LPMEMORYFILE pFile)
{
    // Locals
    HRESULT     hr=S_OK;

    // Tracing
    TraceCall("OpenMemoryMappedFile");

    // Invalid Arg
    Assert(pszFile && pFile);

    // Init
    ZeroMemory(pFile, sizeof(MEMORYFILE));

    // Open the File
    pFile->hFile = CreateFile(pszFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_FLAG_RANDOM_ACCESS | FILE_ATTRIBUTE_NORMAL, NULL);

    // Failure
    if (INVALID_HANDLE_VALUE == pFile->hFile)
    {
        pFile->hFile = NULL;
        if (ERROR_SHARING_VIOLATION == GetLastError())
            hr = TraceResult(MIGRATE_E_SHARINGVIOLATION);
        else
            hr = TraceResult(MIGRATE_E_CANTOPENFILE);
        goto exit;
    }

    // Get the Size
    pFile->cbSize = ::GetFileSize(pFile->hFile, NULL);
    if (0xFFFFFFFF == pFile->cbSize)
    {
        hr = TraceResult(MIGRATE_E_CANTGETFILESIZE);
        goto exit;
    }

    // Create the file mapping
    pFile->hMemoryMap = CreateFileMapping(pFile->hFile, NULL, PAGE_READWRITE, 0, pFile->cbSize, NULL);

    // Failure ?
    if (NULL == pFile->hMemoryMap)
    {
        hr = TraceResult(MIGRATE_E_CANTCREATEFILEMAPPING);
        goto exit;
    }

    // Map a view of the entire file
    pFile->pView = MapViewOfFile(pFile->hMemoryMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);

    // Failure
    if (NULL == pFile->pView)
    {
        hr = TraceResult(MIGRATE_E_CANTMAPVIEWOFFILE);
        goto exit;
    }

exit:
    // Cleanup
    if (FAILED(hr))
        CloseMemoryFile(pFile);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\staticrt\msoedbg.cpp ===
// --------------------------------------------------------------------------------
// Msoedbg.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"

#ifdef DEBUG

LPSTR PathClipFile(LPSTR pszSrc, LPSTR pszDest)
{
    LPSTR   pszT=pszSrc;
    int     cDirs=0;

    if (pszSrc)
    {
        // compact path
        pszT = pszSrc + lstrlen(pszSrc)-1;
        while (pszT != pszSrc)
        {
            if (*pszT == '\\' && ++cDirs == 3)
                break;
        
            pszT--;
        }
        if (pszSrc != pszT)
        {
            // if we clipped the path, show a ~
            lstrcpy(pszDest, "~");
            lstrcpy(pszDest+1, pszT+1);
            return pszDest;
        }
    }
    return pszSrc;
}

// --------------------------------------------------------------------------------
// GetDebugTraceTagMask
// --------------------------------------------------------------------------------
DWORD GetDebugTraceTagMask(LPCSTR pszTag, SHOWTRACEMASK dwDefaultMask)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dwMask=dwDefaultMask;
    HKEY        hKeyOpen=NULL;
    DWORD       dwType;
    DWORD       cb;

    // Tracing
    TraceCall("GetDebugTraceTagMask");

    // Invalid Arg
    Assert(pszTag);

    // Open the Key
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Outlook Express\\Tracing", NULL, NULL, NULL, KEY_ALL_ACCESS, NULL, &hKeyOpen, &cb))
    {
        TraceResult(E_FAIL);
        goto exit;
    }

    // Query
    cb = sizeof(DWORD);
    if (ERROR_SUCCESS == RegQueryValueEx(hKeyOpen, pszTag, NULL, &dwType, (LPBYTE)&dwMask, &cb))
        goto exit;

    // Set to default value
    if (ERROR_SUCCESS != RegSetValueEx(hKeyOpen, pszTag, 0, REG_DWORD, (LPBYTE)&dwDefaultMask, sizeof(DWORD)))
    {
        TraceResult(E_FAIL);
        goto exit;
    }

exit:
    // Cleanup
    if (hKeyOpen)
        RegCloseKey(hKeyOpen);

    // Done
    return dwMask;
}

// --------------------------------------------------------------------------------
// DebugTraceEx
// --------------------------------------------------------------------------------
HRESULT DebugTraceEx(SHOWTRACEMASK dwMask, TRACEMACROTYPE tracetype, LPTRACELOGINFO pLog,
    HRESULT hr, LPSTR pszFile, INT nLine, LPCSTR pszMsg, LPCSTR pszFunc)
{
    TCHAR   rgchClip[MAX_PATH];
 
    // If pLog, reset dwMask
    if (pLog)
        dwMask = pLog->dwMask;
    
    // TRACE_CALL
    if (TRACE_CALL == tracetype)
    {
        // Trace Calls
        if (ISFLAGSET(dwMask, SHOW_TRACE_CALL) && pszFunc)
        {
            // No Message
            if (NULL == pszMsg)
            {
                // Do a Debug Trace
                DebugTrace("0x%08X: Call: %s(%d) - %s\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip), nLine, pszFunc);
            }

            // Do a message
            else
            {
                // Do a Debug Trace
                DebugTrace("0x%08X: Call: %s(%d) - %s - %s\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip), nLine, pszFunc, pszMsg);
            }
        }
    }

    // TRACE_INFO
    else if (TRACE_INFO == tracetype)
    {
        // Should we log
        if (ISFLAGSET(dwMask, SHOW_TRACE_INFO))
        {
            // Do a Debug Trace
            if (pszFunc)
                DebugTrace("0x%08X: Info: %s(%d) - %s - %s\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip), nLine, pszFunc, pszMsg);
            else
                DebugTrace("0x%08X: Info: %s(%d) - %s\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip), nLine, pszMsg);
        }
    }

    // TRACE_RESULT
    else
    {
        // No Message
        if (NULL == pszMsg)
        {
            // Do a Debug Trace
            if (pszFunc)
                DebugTrace("0x%08X: Result: %s(%d) - HRESULT(0x%08X) - GetLastError() = %d in %s\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip), nLine, hr, GetLastError(), pszFunc);
            else
                DebugTrace("0x%08X: Result: %s(%d) - HRESULT(0x%08X) - GetLastError() = %d\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip), nLine, hr, GetLastError());
        }

        // Do a message
        else
        {
            // Do a Debug Trace
            if (pszFunc)
                DebugTrace("0x%08X: Result: %s(%d) - HRESULT(0x%08X) - GetLastError() = %d - %s in %s\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip), nLine, hr, GetLastError(), pszMsg, pszFunc);
            else
                DebugTrace("0x%08X: Result: %s(%d) - HRESULT(0x%08X) - GetLastError() = %d - %s\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip), nLine, hr, GetLastError(), pszMsg);
        }
    }

    // Log File
    if (pLog && pLog->pLog)
        pLog->pLog->TraceLog(dwMask, tracetype, nLine, hr, pszMsg);

    // Done
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\statnery\makefile.inc ===
.SUFFIXES: .htx

.htx{$(O)}.htm:
        cleaninf -w -htm $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\staticrt\memutil.cpp ===
// --------------------------------------------------------------------------------
// Memutil.cpp
// This file is linked into other projects.
// --------------------------------------------------------------------------------
#include "pch.hxx"

// --------------------------------------------------------------------------------
// ZeroAllocate
// --------------------------------------------------------------------------------
LPVOID ZeroAllocate(DWORD cbSize)
{
    LPVOID pv = g_pMalloc->Alloc(cbSize);
    if (pv)
        ZeroMemory(pv, cbSize);
    return pv;
}

// --------------------------------------------------------------------------------
// MemAlloc
// --------------------------------------------------------------------------------
BOOL MemAlloc(LPVOID* ppv, ULONG cb) 
{
    Assert(ppv && cb);
    *ppv = g_pMalloc->Alloc(cb);
    if (NULL == *ppv)
        return FALSE;
    return TRUE;
}

// --------------------------------------------------------------------------------
// HrAlloc
// --------------------------------------------------------------------------------
HRESULT HrAlloc(LPVOID *ppv, ULONG cb) 
{
    Assert(ppv && cb);
    *ppv = g_pMalloc->Alloc(cb);
    if (NULL == *ppv)
        return TrapError(E_OUTOFMEMORY);
    return S_OK;
}

// --------------------------------------------------------------------------------
// MemRealloc
// --------------------------------------------------------------------------------
BOOL MemRealloc(LPVOID *ppv, ULONG cbNew) 
{
    Assert(ppv && cbNew);
    LPVOID pv = g_pMalloc->Realloc(*ppv, cbNew);
    if (NULL == pv)
        return FALSE;
    *ppv = pv;
    return TRUE;
}

// --------------------------------------------------------------------------------
// HrRealloc
// --------------------------------------------------------------------------------
HRESULT HrRealloc(LPVOID *ppv, ULONG cbNew) 
{
    Assert(ppv);
    LPVOID pv = g_pMalloc->Realloc(*ppv, cbNew);
    if (NULL == pv && 0 != cbNew)
        return TrapError(E_OUTOFMEMORY);
    *ppv = pv;
    return S_OK;
}

// "new" and "delete" come from libcmt.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\staticrt\lang.cpp ===
// Simple module for using MLLoadLibrary().
// This cannot be merged with shared.cpp, because it uses shlwapi.h. which conflict with 
// come constant in shared.h
// Created: 07/08/98 by YST


#include "pch.hxx"
#include <shlwapi.h>
#include <shlwapip.h>
#include "htmlhelp.h"
#include "shared.h"
#include "htmlhelp.h"
#include <demand.h>

typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
typedef int (STDAPICALLTYPE *PFNMLWINHELP)(HWND hWndCaller, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
typedef HWND (STDAPICALLTYPE *PFNMLHTMLHELP)(HWND hWndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);

static const char c_szShlwapiDll[] = "shlwapi.dll";
static const char c_szDllGetVersion[] = "DllGetVersion";

static PFNMLWINHELP     pfnWinHelp = NULL;
static PFNMLHTMLHELP    pfnHtmlHelp = NULL;
static BOOL fWinHelChecked = FALSE;
static BOOL fHtmlHelpChecked = FALSE;
static BOOL fNT5 = FALSE;

const OENONSTDCP OENonStdCPs[] = 
{
//  CodePage    Read        ReadMenu    Title       SendMenu   SmSend   Use SIO
    50001,      50001,      50001,      0,          0,          0,      0,  // General Autoselect
    50932,      50932,      50932,      0,          0,          50220,  0,  // Japanice Auto Select
    50949,      50949,      50949,      949,        0,          /*51*/949,  0,  // Korean Auto Select
//  50939,      50939,      50939,      0,          0,          0,      0,  // Chinese Auto Select
    51932,      51932,      51932,      0,          0,          50220,  0,  // Japanice EUC
    932,        932,        932,        0,          0,          50220,  0,  // Japanice Shift-JIS
    50225,      50225,      50225,      949,        0,          949,    0,  // Korean ISO-2022-KR
    50220,      50932,      0,          0,          50220,      50220,  0,  // Japanice JIS
    51949,      50949,      0,          949,        51949,      51949,  0,  // Korean
    949,        50949,      0,          0,          949,        949,    0,  // Korean Windows
    50221,      50932,      50932,      0,          0,          50220,  1,  // Esc(I ISO-2022-JP
    50222,      50932,      50932,      0,          0,          50220,  2,  // Esc(J ISO-2022-JP
    28598,      28598,      28598,      0,          0,          28598,  0,  // Hebrew visual
//  1255,       1255,       1255,       0,          0,          1255,   0,  // Hebrew Windows
    20127,      28591,      0,          0,          0,          28591,  0,  // US-ASCII
    862,        862,        862,        0,          0,          862,    0,  // Hebrew OEM (DOS)
    0, 0, 0, 0, 0, 0
};                                                  

HINSTANCE LoadLangDll(HINSTANCE hInstCaller, LPCSTR szDllName, BOOL fNT)
{
    char szPath[MAX_PATH];
    HINSTANCE hinstShlwapi;
    PFNMLLOADLIBARY pfn;
    DLLGETVERSIONPROC pfnVersion;
    int iEnd;
    DLLVERSIONINFO info;
    HINSTANCE hInst = NULL;

    hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    if (hinstShlwapi != NULL)
    {
        pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion != NULL)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                {
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, MAKEINTRESOURCE(377));
                    if (pfn != NULL)
                        hInst = pfn(szDllName, hInstCaller, (ML_NO_CROSSCODEPAGE));
                }
            }
        }

        FreeLibrary(hinstShlwapi);        
    }

    if ((NULL == hInst) && (GetModuleFileName(hInstCaller, szPath, ARRAYSIZE(szPath))))
    {
        PathRemoveFileSpec(szPath);
        iEnd = lstrlen(szPath);
        szPath[iEnd++] = '\\';
        lstrcpyn(&szPath[iEnd], szDllName, ARRAYSIZE(szPath)-iEnd);
        hInst = LoadLibrary(szPath);
    }

    AssertSz(hInst, "Failed to LoadLibrary Lang Dll");

    return(hInst);
}


// Get system architecture and OS version
BOOL GetPCAndOSTypes(SYSTEM_INFO * pSysInf, OSVERSIONINFO * pOsInf)
{
	GetSystemInfo(pSysInf);
    pOsInf->dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	return(GetVersionEx(pOsInf));
}

// PlugUI version of WinHelp
BOOL OEWinHelp(HWND hWndCaller, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData)
{
    if(!pfnWinHelp)
    {
        if(!fWinHelChecked)
        {
            HINSTANCE hinstShlwapi;
            PFNMLLOADLIBARY pfn;
            DLLGETVERSIONPROC pfnVersion;
            int iEnd;
            DLLVERSIONINFO info;
            HINSTANCE hInst = NULL;


            hinstShlwapi = DemandLoadShlWapi();

            // hinstShlwapi = LoadLibrary(c_szShlwapiDll);
            if (hinstShlwapi != NULL)
            {
                pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
                if (pfnVersion != NULL)
                {
                    info.cbSize = sizeof(DLLVERSIONINFO);
                    if (SUCCEEDED(pfnVersion(&info)))
                    {
                        if (info.dwMajorVersion >= 5)
                        {
                            // 395 is ordinal # fot MLWinHelp
                            pfnWinHelp = (PFNMLWINHELP)GetProcAddress(hinstShlwapi, MAKEINTRESOURCE(395));
                        }
                    }
                }
               //  FreeLibrary(hinstShlwapi);        
            }
            fWinHelChecked = TRUE;
        }
        if(pfnWinHelp)
            return(pfnWinHelp(hWndCaller, lpszHelp, uCommand, dwData));
        else
            return(WinHelp(hWndCaller, lpszHelp, uCommand, dwData));
    }
    else
        return(pfnWinHelp(hWndCaller, lpszHelp, uCommand, dwData));
}

// PlugUI version of HtmlHelp
HWND OEHtmlHelp(HWND hWndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData)
{
    if(!pfnHtmlHelp)
    {
        if(!fHtmlHelpChecked)
        {
            HINSTANCE hinstShlwapi;
            PFNMLLOADLIBARY pfn;
            DLLGETVERSIONPROC pfnVersion;
            int iEnd;
            DLLVERSIONINFO info;
            HINSTANCE hInst = NULL;

            hinstShlwapi = DemandLoadShlWapi();

            // hinstShlwapi = LoadLibrary(c_szShlwapiDll);
            if (hinstShlwapi != NULL)
            {
                pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
                if (pfnVersion != NULL)
                {
                    info.cbSize = sizeof(DLLVERSIONINFO);
                    if (SUCCEEDED(pfnVersion(&info)))
                    {
                        if (info.dwMajorVersion >= 5)
                        {
                            // 396 is ordinal # fot MLHTMLHelp
                            pfnHtmlHelp = (PFNMLHTMLHELP)GetProcAddress(hinstShlwapi, MAKEINTRESOURCE(396));

                            if(!fNT5)
                            {
                                OSVERSIONINFO OSInfo;
                                OSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

                                GetVersionEx(&OSInfo);
                                if((OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (OSInfo.dwMajorVersion >= 5))
                                    fNT5 = TRUE;
                            }
                        }
                    }
                }
               //  FreeLibrary(hinstShlwapi);        
            }
            fHtmlHelpChecked = TRUE;
        }
        if(pfnHtmlHelp)
            return(pfnHtmlHelp(hWndCaller, pszFile, uCommand, dwData, fNT5 ? ML_CROSSCODEPAGE_NT : ML_NO_CROSSCODEPAGE));
        else
            return(HtmlHelp(hWndCaller, pszFile, uCommand, dwData));
    }
    else
        return(pfnHtmlHelp(hWndCaller, pszFile, uCommand, dwData, fNT5 ? ML_CROSSCODEPAGE_NT : ML_NO_CROSSCODEPAGE));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\staticrt\strparse.cpp ===
// --------------------------------------------------------------------------------
// Strparse.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "strparse.h"

// --------------------------------------------------------------------------------
// FGROWNEEDED - Determines if we need to call _HrGrowDestination
// --------------------------------------------------------------------------------
#define FGROWNEEDED(_cbWrite)       (m_cchDest + _cbWrite + 1 > m_cbDestMax)

// --------------------------------------------------------------------------------
// CStringParser::CStringParser
// --------------------------------------------------------------------------------
CStringParser::CStringParser(void)
{
    m_cRef = 1;
    m_codepage = CP_ACP;
    m_pszSource = NULL;
    m_cchSource = 0;
    m_iSource = 0;
    m_pszDest = NULL;
    m_cchDest = 0;
    m_cbDestMax = 0;
    m_dwFlags = 0;
    m_pszTokens = NULL;
    m_cCommentNest = 0;
    ZeroMemory(m_rgbTokTable, sizeof(m_rgbTokTable));
    ZeroMemory(&m_rLiteral, sizeof(m_rLiteral));
}

// --------------------------------------------------------------------------------
// CStringParser::~CStringParser
// --------------------------------------------------------------------------------
CStringParser::~CStringParser(void)
{
    if (m_pszDest && m_pszDest != m_szScratch)
        g_pMalloc->Free(m_pszDest);
}

// --------------------------------------------------------------------------------
// CStringParser::AddRef
// --------------------------------------------------------------------------------
ULONG CStringParser::AddRef(void)
{
    return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CStringParser::AddRef
// --------------------------------------------------------------------------------
ULONG CStringParser::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CStringParser::Init
// --------------------------------------------------------------------------------
void CStringParser::Init(LPCSTR pszParseMe, ULONG cchParseMe, DWORD dwFlags)
{
    // Invalid Args
    Assert(NULL == m_pszSource && NULL == m_pszDest && pszParseMe && '\0' == pszParseMe[cchParseMe]);

    // Save Parse Flags
    m_dwFlags = dwFlags;

    // Safe the String
    m_pszSource = pszParseMe;
    m_cchSource = cchParseMe;

    // Setup Dest
    m_pszDest = m_szScratch;
    m_cbDestMax = sizeof(m_szScratch);
}

// --------------------------------------------------------------------------------
// CStringParser::SetTokens
// --------------------------------------------------------------------------------
void CStringParser::SetTokens(LPCSTR pszTokens)
{
    // Locals
    LPSTR psz;

    // Enable the tokens in the table
    if (m_pszTokens)
        for (psz=(LPSTR)m_pszTokens; *psz != '\0'; psz++)
            m_rgbTokTable[(UCHAR)(*psz)] = 0x00;

    // New Tokens
    if (pszTokens)
        for (psz=(LPSTR)pszTokens; *psz != '\0'; psz++)
            m_rgbTokTable[(UCHAR)(*psz)] = 0xff;

    // Save new tokens
    m_pszTokens = pszTokens;
}

// --------------------------------------------------------------------------------
// CStringParser::_HrGrowDestination
// --------------------------------------------------------------------------------
HRESULT CStringParser::_HrGrowDestination(ULONG cbWrite)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbAlloc;

    // We should need to grow, should have called FGROWNEEDED
    Assert(FGROWNEEDED(cbWrite));

    // Is this the first realloc
    if (m_pszDest == m_szScratch)
    {
        // Validate Current Size
        Assert(m_cbDestMax == sizeof(m_szScratch));

        // Compute New Size
        cbAlloc = max(m_cchSource + 1, m_cchDest + 256 + cbWrite);

        // Init pszValue
        CHECKALLOC(m_pszDest = (LPSTR)g_pMalloc->Alloc(cbAlloc));

        // Copy Current Value
        CopyMemory(m_pszDest, m_szScratch, m_cchDest);

        // Set Max Val
        m_cbDestMax = cbAlloc;
    }

    // Otherwise, need to realloc
    else
    {
        // Locals
        LPBYTE pbTemp;

        // Should already be bigger than m_cchSource + 1
        Assert(m_cbDestMax >= m_cchSource + 1);

        // Compute New Size
        cbAlloc = m_cbDestMax + 256 + cbWrite;

        // Realloc
        CHECKALLOC(pbTemp = (LPBYTE)g_pMalloc->Realloc((LPBYTE)m_pszDest, cbAlloc));

        // Save new pointer
        m_pszDest = (LPSTR)pbTemp;

        // Save new Size
        m_cbDestMax = cbAlloc;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CStringParser::FIsParseSpace
// --------------------------------------------------------------------------------
BOOL CStringParser::FIsParseSpace(CHAR ch, BOOL *pfCommentChar)
{
    // Locals
    WORD        wType;

    // Should not be DBCS
    Assert(ISFLAGSET(m_dwFlags, PSF_DBCS) ? !IsDBCSLeadByteEx(m_codepage, ch) : TRUE);

    // Comment Char
    *pfCommentChar = FALSE;

    // NoComments
    if (ISFLAGSET(m_dwFlags, PSF_NOCOMMENTS))    
    {
        // Comment Start ?
        if ('(' == ch)
        {
            // Increment Nested Count
            m_cCommentNest++;

            // Comment Char
            *pfCommentChar = TRUE;

            // Treat it as a space
            return TRUE;
        }

        // Comment End ?
        else if (')' == ch && m_cCommentNest)
        {
            // Decrement Nested Count
            m_cCommentNest--;

            // Comment Char
            *pfCommentChar = TRUE;

            // Treat it as a space
            return TRUE;
        }

        // Inside a Comment ?
        else if (m_cCommentNest)
        {
            // Comment Char
            *pfCommentChar = TRUE;

            // Treat it as a space
            return TRUE;
        }
    }

    // Get StringType
    if (' ' == ch || '\t' == ch || '\r' == ch || '\n' == ch)
        return(TRUE);

    // Not a space
    return(FALSE);

#if 0
    if (0 == GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, &ch, 1, &wType))
        wType = 0;

    // Return IsSpace
    return(ISFLAGSET(wType, C1_SPACE));
#endif
}

// --------------------------------------------------------------------------------
// CStringParser::ChSkip - Returns TRUE if done parsing
// --------------------------------------------------------------------------------
CHAR CStringParser::ChSkipWhite(void)
{
    // Locals
    CHAR    ch=0;
    BOOL    fCommentChar;

    // Loop
    while (1)
    {
        // Get Current Character
        ch = *(m_pszSource + m_iSource);

        // Are we done
        if ('\0' == ch)
            break;

        // Better not be done
        Assert(m_iSource < m_cchSource);

        // Look for DBCS characters
        if (ISFLAGSET(m_dwFlags, PSF_DBCS) && IsDBCSLeadByteEx(m_codepage, ch))
            break;

        // Not a space
        if (!FIsParseSpace(ch, &fCommentChar))
            break;

        // Goto Next Char
        m_iSource++;
    }

    // Done
    return ch;
}

// --------------------------------------------------------------------------------
// CStringParser::ChSkip - Returns TRUE if done parsing
// --------------------------------------------------------------------------------
CHAR CStringParser::ChSkip(void)
{
    // Locals
    CHAR ch = 0;

    // Loop
    while (1)
    {
        // Get Current Character
        ch = *(m_pszSource + m_iSource);

        // Are we done
        if ('\0' == ch)
            break;

        // Better not be done
        Assert(m_iSource < m_cchSource);

        // Look for DBCS characters
        if (ISFLAGSET(m_dwFlags, PSF_DBCS) && IsDBCSLeadByteEx(m_codepage, ch))
           break;

        // Compare for a token
        if (0x00 == m_rgbTokTable[(UCHAR)ch])
            break;

        // Goto Next Char
        m_iSource++;
    }

    // Done
    return ch;
}

// --------------------------------------------------------------------------------
// CStringParser::ChPeekNext
// --------------------------------------------------------------------------------
CHAR CStringParser::ChPeekNext(ULONG cchFromCurrent)
{
    // Locals
    CHAR    ch=0;
    BOOL    fCommentChar;

    // Past the end of the source
    if (m_iSource + cchFromCurrent >= m_cchSource)
        return '\0';

    // Return the character
    return *(m_pszSource + m_iSource + cchFromCurrent);
}

// --------------------------------------------------------------------------------
// CStringParser::_HrDoubleByteIncrement
// --------------------------------------------------------------------------------
HRESULT CStringParser::_HrDoubleByteIncrement(BOOL fEscape)
{
    // Locals
    HRESULT hr=S_OK;

    // Can I copy two more bytes to pszValue
    if (FGROWNEEDED(2))
    {
        // Otherwise, grow the buffer
        CHECKHR(hr = _HrGrowDestination(2));
    }

    // If Not an Escape Character or the last character is an escape character, then step over it
    if (FALSE == fEscape || m_iSource + 1 > m_cchSource)
        m_pszDest[m_cchDest++] = m_pszSource[m_iSource];

    // Next Character
    m_iSource++;

    // Copy Next Character
    if (m_iSource < m_cchSource)
        m_pszDest[m_cchDest++] = m_pszSource[m_iSource++];

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CStringParser::ChParse
// --------------------------------------------------------------------------------
CHAR CStringParser::ChParse(LPCSTR pszTokens, DWORD dwFlags)
{
    // Save Flags
    DWORD dwCurrFlags=m_dwFlags;

    // Reset Flags
    m_dwFlags = dwFlags;

    // Set Parsing Tokens
    SetTokens(pszTokens);

    // Parse
    CHAR chToken = ChParse();

    // Set Flags
    m_dwFlags = dwCurrFlags;

    // Return the Token
    return chToken;
}

// --------------------------------------------------------------------------------
// CStringParser::ChParse
// --------------------------------------------------------------------------------
CHAR CStringParser::ChParse(CHAR chStart, CHAR chEnd, DWORD dwFlags)
{
    // We really should have finished the last literal
    Assert(FALSE == m_rLiteral.fInside);

    // Save Flags
    DWORD dwCurrFlags = m_dwFlags;

    // Reset Flags
    m_dwFlags = dwFlags;

    // Set Parsing Tokens
    SetTokens(NULL);

    // Save Literal Info
    m_rLiteral.fInside = TRUE;
    m_rLiteral.chStart = chStart;
    m_rLiteral.chEnd = chEnd;
    m_rLiteral.cNested = 0;

    // Quoted String
    Assert('\"' == chStart ? '\"' == chEnd : TRUE);

    // Parse
    CHAR chToken = ChParse();

    // Not in a literal
    m_rLiteral.fInside = FALSE;

    // Reset Flags
    m_dwFlags = dwCurrFlags;

    // Return the Token
    return chToken;
}

// --------------------------------------------------------------------------------
// CStringParser::HrAppendValue
// --------------------------------------------------------------------------------
HRESULT CStringParser::HrAppendValue(CHAR ch)
{
    // Locals
    HRESULT hr=S_OK;

    // Just copy this character
    if (FGROWNEEDED(1))
    {
        // Otherwise, grow the buffer
        CHECKHR(hr = _HrGrowDestination(1));
    }

    // Insert the Character
    m_pszDest[m_cchDest++] = ch;

    // There is always room for a Null, look at FGROWNEEDED and _HrGrowDestination
    m_pszDest[m_cchDest] = '\0';

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CStringParser::ChParse
// --------------------------------------------------------------------------------
CHAR CStringParser::ChParse(void)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        ch;
    ULONG       iStart=m_iSource;
    LONG        iLastSpace=-1;
    CHAR        chToken;
    BOOL        fCommentChar;
    BOOL        fIsSpace;
    
    // Invalid Arg
    Assert(m_iSource <= m_cchSource && m_pszDest);

    // Init chToken
    chToken = '\0';

    // No Reset
    if (!ISFLAGSET(m_dwFlags, PSF_NORESET))
    {
        m_pszDest[0] = '\0';
        m_cchDest = 0;
    }

    // Skip Forward Whitespace
    if (ISFLAGSET(m_dwFlags, PSF_NOFRONTWS) && FALSE == m_rLiteral.fInside && '\0' == ChSkipWhite())
        goto TokenFound;

    // Save Starting Position
    while(1)
    {
        // Get the Next Character
        ch = *(m_pszSource + m_iSource);

        // Done
        if ('\0' == ch)
        {
            chToken = '\0';
            goto TokenFound;
        }

        // Better not be done
        Assert(m_iSource < m_cchSource);

        // If this is a DBCS lead byte
        if ((ISFLAGSET(m_dwFlags, PSF_DBCS) && IsDBCSLeadByteEx(m_codepage, ch)))
        {
            // _HrDoubleByteIncrement
            CHECKHR(hr = _HrDoubleByteIncrement(FALSE));
            iLastSpace = -1;        // reset space counter 

            // Goto Next Character
            continue;
        }

        // Check for escaped characters
        if (ISFLAGSET(m_dwFlags, PSF_ESCAPED) && '\\' == ch)
        {
            // _HrDoubleByteIncrement
            CHECKHR(hr = _HrDoubleByteIncrement(TRUE));
            iLastSpace = -1;        // reset space counter 

            // Goto Next Character
            continue;
        }

        // If not inside of a comment
        if (0 == m_cCommentNest)
        {
            if (m_rLiteral.fInside)
            {
                // End of quoted string
                if (ch == m_rLiteral.chEnd)
                {
                    // No nested ?
                    if (0 == m_rLiteral.cNested)
                    {
                        // We found a token
                        chToken = ch;

                        // Walk over this item in the string
                        m_iSource++;

                        // Ya-hoo, we found a token
                        hr = S_OK;

                        // Done
                        goto TokenFound;
                    }

                    // Otherwise, decrement nest
                    else
                        m_rLiteral.cNested--;
                }

                // Otherwise, check for nesting
                else if (m_rLiteral.chStart != m_rLiteral.chEnd && ch == m_rLiteral.chStart)
                    m_rLiteral.cNested++;
            }

            // Compare for a token - m_cCommentNest is only set if PSF_NOCOMMENTS is set
            else if (0xff == m_rgbTokTable[(UCHAR)ch])
            {
                // We found a token
                chToken = ch;

                // Walk over this item in the string
                m_iSource++;

                // Ya-hoo, we found a token
                hr = S_OK;

                // Done
                goto TokenFound;
            }
        }

        // Always Call
        fIsSpace = FIsParseSpace(ch, &fCommentChar);

        // Detect Spaces...
        if (ISFLAGSET(m_dwFlags, PSF_NOTRAILWS))
        {
            // If not a space, then kill iLastSpace
            if (!fIsSpace)
                iLastSpace = -1;

            // Otherwise, if not a consecutive space
            else if (-1 == iLastSpace)
                iLastSpace = m_cchDest;
		}

        // Copy the next character
        if (!fCommentChar)
        {
            // Make sure we have space
            if (FGROWNEEDED(1))
            {
                // Otherwise, grow the buffer
                CHECKHR(hr = _HrGrowDestination(1));
            }

            // Copy the character
            m_pszDest[m_cchDest++] = ch;
        }

        // Goto next char
        m_iSource++;
    }
    
TokenFound:
    // Determine correct end of string
    if (S_OK == hr && ISFLAGSET(m_dwFlags, PSF_NOTRAILWS) && FALSE == m_rLiteral.fInside)
        m_cchDest = (-1 == iLastSpace) ? m_cchDest : iLastSpace;

    // Otherwise, just insert a null
    Assert(m_cchDest < m_cbDestMax);

    // There is always room for a Null, look at FGROWNEEDED and _HrGrowDestination
    m_pszDest[m_cchDest] = '\0';

exit:
    // Failure Resets the parse to initial state
    if (FAILED(hr))
    {
        m_iSource = iStart;
        chToken = '\0';
    }

    // Validate Paren Nesting
    // AssertSz(m_cCommentNest == 0, "A string was parsed that has an un-balanced paren nesting.");

    // Done
    return chToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\staticrt\wstrpar.cpp ===
// --------------------------------------------------------------------------------
// wstrpar.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "wstrpar.h"

// --------------------------------------------------------------------------------
// FGROWNEEDED - Determines if we need to call _HrGrowDestination
// --------------------------------------------------------------------------------
#define FGROWNEEDED(_cchWrite) (m_cchDest + _cchWrite + sizeof(WCHAR) > m_cchDestMax)

// --------------------------------------------------------------------------------
// CStringParserW::CStringParserW
// --------------------------------------------------------------------------------
CStringParserW::CStringParserW(void)
{
    m_cRef = 1;
    m_pszSource = NULL;
    m_cchSource = 0;
    m_iSource = 0;
    m_pszDest = NULL;
    m_cchDest = 0;
    m_cchDestMax = 0;
    m_dwFlags = 0;
    m_pszTokens = NULL;
    m_cCommentNest = 0;
    ZeroMemory(&m_rLiteral, sizeof(m_rLiteral));
}

// --------------------------------------------------------------------------------
// CStringParserW::~CStringParserW
// --------------------------------------------------------------------------------
CStringParserW::~CStringParserW(void)
{
    if (m_pszDest && m_pszDest != m_szScratch)
        g_pMalloc->Free(m_pszDest);
}

// --------------------------------------------------------------------------------
// CStringParserW::AddRef
// --------------------------------------------------------------------------------
ULONG CStringParserW::AddRef(void)
{
    return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CStringParserW::AddRef
// --------------------------------------------------------------------------------
ULONG CStringParserW::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CStringParserW::Init
// --------------------------------------------------------------------------------
void CStringParserW::Init(LPCWSTR pszParseMe, ULONG cchParseMe, DWORD dwFlags)
{
    // Invalid Args
    Assert(NULL == m_pszSource && NULL == m_pszDest && pszParseMe && L'\0' == pszParseMe[cchParseMe]);

    // Save Parse Flags
    m_dwFlags = dwFlags;

    // Safe the String
    m_pszSource = pszParseMe;
    m_cchSource = cchParseMe;

    // Setup Dest
    m_pszDest = m_szScratch;
    m_cchDestMax = ARRAYSIZE(m_szScratch);
}

// --------------------------------------------------------------------------------
// CStringParserW::SetTokens
// --------------------------------------------------------------------------------
void CStringParserW::SetTokens(LPCWSTR pszTokens)
{
    // Save Tokens
    m_pszTokens = pszTokens;
}

// --------------------------------------------------------------------------------
// CStringParserW::_HrGrowDestination
// --------------------------------------------------------------------------------
HRESULT CStringParserW::_HrGrowDestination(ULONG cchWrite)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbAlloc;

    // We should need to grow, should have called FGROWNEEDED
    Assert(FGROWNEEDED(cchWrite));

    // Is this the first realloc
    if (m_pszDest == m_szScratch)
    {
        // Validate Current Size
        Assert(m_cchDestMax == ARRAYSIZE(m_szScratch));

        // Compute New Size
        cbAlloc = (max(m_cchSource + 1, m_cchDest + 256 + cchWrite) * sizeof(WCHAR));

        // Init pszValue
        CHECKALLOC(m_pszDest = (LPWSTR)g_pMalloc->Alloc(cbAlloc));

        // Copy Current Value
        CopyMemory((LPBYTE)m_pszDest, (LPBYTE)m_szScratch, (m_cchDest * sizeof(WCHAR)));

        // Set Max Val
        m_cchDestMax = (cbAlloc / sizeof(WCHAR));
    }

    // Otherwise, need to realloc
    else
    {
        // Locals
        LPBYTE pbTemp;

        // Should already be bigger than m_cchSource + 1
        Assert(m_cchDestMax >= m_cchSource + 1);

        // Compute New Size
        cbAlloc = ((m_cchDestMax + 256 + cchWrite) * sizeof(WCHAR));

        // Realloc
        CHECKALLOC(pbTemp = (LPBYTE)g_pMalloc->Realloc((LPBYTE)m_pszDest, cbAlloc));

        // Save new pointer
        m_pszDest = (LPWSTR)pbTemp;

        // Save new Size
        m_cchDestMax = (cbAlloc / sizeof(WCHAR));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CStringParserW::FIsParseSpace
// --------------------------------------------------------------------------------
BOOL CStringParserW::FIsParseSpace(WCHAR ch, BOOL *pfCommentChar)
{
    // Locals
    WORD        wType;

    // Comment Char
    *pfCommentChar = FALSE;

    // NoComments
    if (ISFLAGSET(m_dwFlags, PSF_NOCOMMENTS))    
    {
        // Comment Start ?
        if (L'(' == ch)
        {
            // Increment Nested Count
            m_cCommentNest++;

            // Comment Char
            *pfCommentChar = TRUE;

            // Treat it as a space
            return TRUE;
        }

        // Comment End ?
        else if (L')' == ch && m_cCommentNest)
        {
            // Decrement Nested Count
            m_cCommentNest--;

            // Comment Char
            *pfCommentChar = TRUE;

            // Treat it as a space
            return TRUE;
        }

        // Inside a Comment ?
        else if (m_cCommentNest)
        {
            // Comment Char
            *pfCommentChar = TRUE;

            // Treat it as a space
            return TRUE;
        }
    }

    // Get StringType
    if (L' ' == ch || L'\t' == ch || L'\r' == ch || L'\n' == ch)
        return(TRUE);

    // Not a space
    return(FALSE);
}

// --------------------------------------------------------------------------------
// CStringParserW::ChSkip - Returns TRUE if done parsing
// --------------------------------------------------------------------------------
WCHAR CStringParserW::ChSkipWhite(void)
{
    // Locals
    WCHAR   ch=0;
    BOOL    fCommentChar;

    // Loop
    while (1)
    {
        // Get Current Character
        ch = *(m_pszSource + m_iSource);

        // Are we done
        if (L'\0' == ch)
            break;

        // Better not be done
        Assert(m_iSource < m_cchSource);

        // Not a space
        if (!FIsParseSpace(ch, &fCommentChar))
            break;

        // Goto Next Char
        m_iSource++;
    }

    // Done
    return ch;
}

// --------------------------------------------------------------------------------
// CStringParserW::ChSkip - Returns TRUE if done parsing
// --------------------------------------------------------------------------------
WCHAR CStringParserW::ChSkip(void)
{
    // Locals
    WCHAR  ch=L'\0';
    LPWSTR pszT;

    // Loop
    while (1)
    {
        // Get Current Character
        ch = *(m_pszSource + m_iSource);

        // Are we done
        if (L'\0' == ch)
            break;

        // Better not be done
        Assert(m_iSource < m_cchSource);

        // Tokens ?
        if (m_pszTokens)
        {
            // Compare Against Tokens..
            for (pszT=(LPWSTR)m_pszTokens; *pszT != L'\0'; pszT++)
            {
                // Token Match ?
                if (ch == *pszT)
                    break;
            }

            // If we didn't match a token, then we are done
            if (L'\0' == *pszT)
                break;
        }

        // Goto Next Char
        m_iSource++;
    }

    // Done
    return ch;
}

// --------------------------------------------------------------------------------
// CStringParserW::ChPeekNext
// --------------------------------------------------------------------------------
WCHAR CStringParserW::ChPeekNext(ULONG cchFromCurrent)
{
    // Locals
    CHAR    ch=0;
    BOOL    fCommentChar;

    // Past the end of the source
    if (m_iSource + cchFromCurrent >= m_cchSource)
        return L'\0';

    // Return the character
    return *(m_pszSource + m_iSource + cchFromCurrent);
}

// --------------------------------------------------------------------------------
// CStringParserW::ChParse
// --------------------------------------------------------------------------------
WCHAR CStringParserW::ChParse(LPCWSTR pszTokens, DWORD dwFlags)
{
    // Save Flags
    DWORD dwCurrFlags=m_dwFlags;

    // Reset Flags
    m_dwFlags = dwFlags;

    // Set Parsing Tokens
    SetTokens(pszTokens);

    // Parse
    WCHAR chToken = ChParse();

    // Set Flags
    m_dwFlags = dwCurrFlags;

    // Return the Token
    return chToken;
}

// --------------------------------------------------------------------------------
// CStringParserW::ChParse
// --------------------------------------------------------------------------------
WCHAR CStringParserW::ChParse(WCHAR chStart, WCHAR chEnd, DWORD dwFlags)
{
    // We really should have finished the last literal
    Assert(FALSE == m_rLiteral.fInside);

    // Save Flags
    DWORD dwCurrFlags = m_dwFlags;

    // Reset Flags
    m_dwFlags = dwFlags;

    // Set Parsing Tokens
    SetTokens(NULL);

    // Save Literal Info
    m_rLiteral.fInside = TRUE;
    m_rLiteral.chStart = chStart;
    m_rLiteral.chEnd = chEnd;
    m_rLiteral.cNested = 0;

    // Quoted String
    Assert(L'\"' == chStart ? L'\"' == chEnd : TRUE);

    // Parse
    WCHAR chToken = ChParse();

    // Not in a literal
    m_rLiteral.fInside = FALSE;

    // Reset Flags
    m_dwFlags = dwCurrFlags;

    // Return the Token
    return chToken;
}

// --------------------------------------------------------------------------------
// CStringParserW::HrAppendValue
// --------------------------------------------------------------------------------
HRESULT CStringParserW::HrAppendValue(WCHAR ch)
{
    // Locals
    HRESULT hr=S_OK;

    // Just copy this character
    if (FGROWNEEDED(1))
    {
        // Otherwise, grow the buffer
        CHECKHR(hr = _HrGrowDestination(1));
    }

    // Insert the Character
    m_pszDest[m_cchDest++] = ch;

    // There is always room for a Null, look at FGROWNEEDED and _HrGrowDestination
    m_pszDest[m_cchDest] = L'\0';

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CStringParserW::ChParse
// --------------------------------------------------------------------------------
WCHAR CStringParserW::ChParse(void)
{
    // Locals
    HRESULT     hr=S_OK;
    WCHAR       ch;
    ULONG       iStart=m_iSource;
    LONG        iLastSpace=-1;
    WCHAR       chToken;
    BOOL        fCommentChar;
    BOOL        fIsSpace;
    LPWSTR      pszT;
    
    // Invalid Arg
    Assert(m_iSource <= m_cchSource && m_pszDest);

    // Init chToken
    chToken = L'\0';

    // No Reset
    if (!ISFLAGSET(m_dwFlags, PSF_NORESET))
    {
        m_pszDest[0] = L'\0';
        m_cchDest = 0;
    }

    // Skip Forward Whitespace
    if (ISFLAGSET(m_dwFlags, PSF_NOFRONTWS) && FALSE == m_rLiteral.fInside && L'\0' == ChSkipWhite())
        goto TokenFound;

    // Save Starting Position
    while(1)
    {
        // Get the Next Character
        ch = *(m_pszSource + m_iSource);

        // Done
        if (L'\0' == ch)
        {
            chToken = L'\0';
            goto TokenFound;
        }

        // Better not be done
        Assert(m_iSource < m_cchSource);

        // Check for escaped characters
        if (ISFLAGSET(m_dwFlags, PSF_ESCAPED) && L'\\' == ch)
        {
            // Can I copy two more bytes to pszValue
            if (FGROWNEEDED(2))
            {
                // Otherwise, grow the buffer
                CHECKHR(hr = _HrGrowDestination(2));
            }

            // If Not an Escape Character or the last character is an escape character, then step over it
            if (m_iSource + 1 > m_cchSource)
                m_pszDest[m_cchDest++] = m_pszSource[m_iSource];

            // Next Character
            m_iSource++;

            // Copy Next Character
            if (m_iSource < m_cchSource)
                m_pszDest[m_cchDest++] = m_pszSource[m_iSource++];

            // Reset space counter
            iLastSpace = -1;

            // Goto Next Character
            continue;
        }

        // If not inside of a comment
        if (0 == m_cCommentNest)
        {
            if (m_rLiteral.fInside)
            {
                // End of quoted string
                if (ch == m_rLiteral.chEnd)
                {
                    // No nested ?
                    if (0 == m_rLiteral.cNested)
                    {
                        // We found a token
                        chToken = ch;

                        // Walk over this item in the string
                        m_iSource++;

                        // Ya-hoo, we found a token
                        hr = S_OK;

                        // Done
                        goto TokenFound;
                    }

                    // Otherwise, decrement nest
                    else
                        m_rLiteral.cNested--;
                }

                // Otherwise, check for nesting
                else if (m_rLiteral.chStart != m_rLiteral.chEnd && ch == m_rLiteral.chStart)
                    m_rLiteral.cNested++;
            }

            // Compare for a token - m_cCommentNest is only set if PSF_NOCOMMENTS is set
            else if (m_pszTokens)
            {
                // If this is a token
                for (pszT=(LPWSTR)m_pszTokens; *pszT != L'\0'; pszT++)
                {
                    // Is this a token ?
                    if (ch == *pszT)
                        break;
                }

                // Found a token ?
                if (*pszT != L'\0')
                {
                    // We found a token
                    chToken = ch;

                    // Walk over this item in the string
                    m_iSource++;

                    // Ya-hoo, we found a token
                    hr = S_OK;

                    // Done
                    goto TokenFound;
                }
            }
        }

        // Always Call
        fIsSpace = FIsParseSpace(ch, &fCommentChar);

        // Detect Spaces...
        if (ISFLAGSET(m_dwFlags, PSF_NOTRAILWS))
        {
            // If not a space, then kill iLastSpace
            if (!fIsSpace)
                iLastSpace = -1;

            // Otherwise, if not a consecutive space
            else if (-1 == iLastSpace)
                iLastSpace = m_cchDest;
		}

        // Copy the next character
        if (!fCommentChar)
        {
            // Make sure we have space
            if (FGROWNEEDED(1))
            {
                // Otherwise, grow the buffer
                CHECKHR(hr = _HrGrowDestination(1));
            }

            // Copy the character
            m_pszDest[m_cchDest++] = ch;
        }

        // Goto next char
        m_iSource++;
    }
    
TokenFound:
    // Determine correct end of string
    if (S_OK == hr && ISFLAGSET(m_dwFlags, PSF_NOTRAILWS) && FALSE == m_rLiteral.fInside)
        m_cchDest = (-1 == iLastSpace) ? m_cchDest : iLastSpace;

    // Otherwise, just insert a null
    Assert(m_cchDest < m_cchDestMax);

    // There is always room for a Null, look at FGROWNEEDED and _HrGrowDestination
    m_pszDest[m_cchDest] = L'\0';

exit:
    // Failure Resets the parse to initial state
    if (FAILED(hr))
    {
        m_iSource = iStart;
        chToken = L'\0';
    }

    // Validate Paren Nesting
    // AssertSz(m_cCommentNest == 0, "A string was parsed that has an un-balanced paren nesting.");

    // Done
    return chToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\common.inc ===
ATHROOT=$(R)\..
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

NOT_LEAN_AND_MEAN=1

!ifndef WIN16
INCLUDES=$(INCLUDES);$(R)\common\h;$(BASEDIR)\private\windows\inc;$(ATHROOT)\inc;$(R)\wab32res
!else
INCLUDES=$(INCLUDES);$(R)\common\h;$(ATHROOT)\inc
!endif

USE_MAPSYM=1

!ifndef WIN16
C_DEFINES=$(C_DEFINES) -DWIN4
!endif
!ifndef WIN64
WIN32_IE_VERSION=0x0300
!else
WIN32_IE_VERSION=0x0500
!endif

!IF 0
The following conditional includes are from mac and/or
win16... things we don't care about and don't have files for
!ENDIF

CONDITIONAL_INCLUDES=\
    $(CONDITIONAL_INCLUDES) \
    macname1.h \
    macname2.h \
    utilmac.h  \
    mapiprof.h \
    ole2ui.h   \
    gapidos.h  \
    macos\msvcmac.h    \
    macos\menus.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\common\h\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

// Include Version headers
#include <winver.h>

/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION                     "4.0.200.0"
#define VER_FILEVERSION_STR         "4.0.200.0\0"
#define VER_FILEVERSION             4,0,200,0
#define VER_PRODUCTVERSION_STR      "4.0.200.0\0"
#define VER_PRODUCTVERSION          4,0,200,0

// #define OFFICIAL
// #define FINAL

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK

/** OS type **/
#define VER_FILEOS                  VOS_DOS_WINDOWS32

/** Type of build flags **/
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

/** Company Name **/
#define VER_COMPANYNAME_STR			"Microsoft Corporation\0"

/** Product Name **/
#define VER_PRODUCTNAME_STR      "Address Book\0"

/** Copyrights and Trademarks **/
#define VER_LEGALCOPYRIGHT_STR  "Copyright Microsoft Corp. 1995,1996\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\common\h\wabguid.h ===
/*
 *	M A P I G U I D . H
 *
 *	Master definitions of all GUID's for MAPI.
 *
 *	When included without INITGUID defined, this header file
 *	defines symbols that reference IIDs elsewhere.
 *
 *	When included with INITGUID defined and a "USES_IID_I..."
 *	statement for each IID used by the subsystem, it generates the
 *	bytes for those actual IIDs into the associated object file.
 *
 *	This range of 256 GUIDs reserved by OLE for MAPI use October 5, 1992.
 *
 *  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
 */

/*
 *	List of GUIDS allocated by MAPI
 *	
 *	0x00020300	IID_IMAPISession
 *	0x00020301	IID_IMAPITable
 *	0x00020302	IID_IMAPIAdviseSink
 *	0x00020303	IID_IMAPIProp
 *	0x00020304	IID_IProfSect
 *	0x00020305	IID_IMAPIStatus
 *	0x00020306	IID_IMsgStore
 *	0x00020307	IID_IMessage
 *	0x00020308	IID_IAttachment
 *	0x00020309	IID_IAddrBook
 *	0x0002030A	IID_IMailUser
 *	0x0002030B	IID_IMAPIContainer
 *	0x0002030C	IID_IMAPIFolder
 *	0x0002030D	IID_IABContainer
 *	0x0002030E	IID_IDistList
 *	0x0002030F	IID_IMAPISup
 *	0x00020310	IID_IMSProvider
 *	0x00020311	IID_IABProvider
 *	0x00020312	IID_IXPProvider
 *	0x00020313	IID_IMSLogon
 *	0x00020314	IID_IABLogon
 *	0x00020315	IID_IXPLogon
 *	0x00020316	IID_IMAPITableData
 *	0x00020317	IID_IMAPISpoolerInit
 *	0x00020318	IID_IMAPISpoolerSession
 *	0x00020319	IID_ITNEF
 *	0x0002031A	IID_IMAPIPropData
 *	0x0002031B	IID_IMAPIControl
 *	0x0002031C	IID_IProfAdmin
 *	0x0002031D	IID_IMsgServiceAdmin
 *	0x0002031E	IID_IMAPISpoolerService
 *	0x0002031F	IID_IMAPIProgress
 *	0x00020320	IID_ISpoolerHook
 *	0x00020321	IID_IMAPIViewContext
 *	0x00020322	IID_IMAPIFormMgr
 *	0x00020323	IID_IEnumMAPIFormProp
 *	0x00020324	IID_IMAPIFormInfo
 *	0x00020325	IID_IProviderAdmin
 *	0x00020327	IID_IMAPIForm
 *	0x00020328	PS_MAPI
 *	0x00020329	PS_PUBLIC_STRINGS
 *	0x0002032A	IID_IPersistMessage
 *	0x0002032B	IID_IMAPIViewAdviseSink
 *	0x0002032C	IID_IStreamDocfile
 *	0x0002032D	IID_IMAPIFormProp
 *	0x0002032E	IID_IMAPIFormContainer
 *	0x0002032F	IID_IMAPIFormAdviseSink
 *	0x00020330	IID_IStreamTnef
 *	0x00020350	IID_IMAPIFormFactory
 *	0x00020370	IID_IMAPIMessageSite
 *	0x00020380	PS_ROUTING_EMAIL_ADDRESSES
 *	0x00020381	PS_ROUTING_ADDRTYPE
 *	0x00020382	PS_ROUTING_DISPLAY_NAME
 *	0x00020383	PS_ROUTING_ENTRYID
 *	0x00020384	PS_ROUTING_SEARCH_KEY
 *	0x00020385	MUID_PROFILE_INSTANCE
 *	
 *	The remaining GUIDs from 0x00020300 to 0x000203FF are reserved by
 *	MAPI for future use.  The current maximum used by MAPI is 0x00020385
 *
 */

#ifndef MAPIGUID_H
#ifdef  INITGUID
#define MAPIGUID_H
#endif

/* Derive from IUnknown */
#if !defined(INITGUID) || defined(USES_IID_IMAPISession)
DEFINE_OLEGUID(IID_IMAPISession,	0x00020300, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPITable)
DEFINE_OLEGUID(IID_IMAPITable,		0x00020301, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIAdviseSink)
DEFINE_OLEGUID(IID_IMAPIAdviseSink,	0x00020302, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIControl)
DEFINE_OLEGUID(IID_IMAPIControl,	0x0002031B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfAdmin)
DEFINE_OLEGUID(IID_IProfAdmin,		0x0002031C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgServiceAdmin)
DEFINE_OLEGUID(IID_IMsgServiceAdmin,0x0002031D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProviderAdmin)
DEFINE_OLEGUID(IID_IProviderAdmin,	0x00020325, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIProgress)
DEFINE_OLEGUID(IID_IMAPIProgress,	0x0002031F, 0, 0);
#endif

/* MAPIProp or derive from MAPIProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIProp)
DEFINE_OLEGUID(IID_IMAPIProp,		0x00020303, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfSect)
DEFINE_OLEGUID(IID_IProfSect,		0x00020304, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIStatus)
DEFINE_OLEGUID(IID_IMAPIStatus,			0x00020305, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgStore)
DEFINE_OLEGUID(IID_IMsgStore,		0x00020306, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMessage)
DEFINE_OLEGUID(IID_IMessage,		0x00020307, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAttachment)
DEFINE_OLEGUID(IID_IAttachment,		0x00020308, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAddrBook)
DEFINE_OLEGUID(IID_IAddrBook,		0x00020309, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMailUser)
DEFINE_OLEGUID(IID_IMailUser,		0x0002030A, 0, 0);
#endif

/* MAPIContainer or derive from MAPIContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIContainer)
DEFINE_OLEGUID(IID_IMAPIContainer,	0x0002030B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFolder)
DEFINE_OLEGUID(IID_IMAPIFolder,		0x0002030C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABContainer)
DEFINE_OLEGUID(IID_IABContainer,	0x0002030D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IDistList)
DEFINE_OLEGUID(IID_IDistList,		0x0002030E, 0, 0);
#endif

/* MAPI Support Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISup)
DEFINE_OLEGUID(IID_IMAPISup,		0x0002030F, 0, 0);
#endif

/* Provider INIT objects */
#if !defined(INITGUID) || defined(USES_IID_IMSProvider)
DEFINE_OLEGUID(IID_IMSProvider,		0x00020310, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABProvider)
DEFINE_OLEGUID(IID_IABProvider,		0x00020311, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPProvider)
DEFINE_OLEGUID(IID_IXPProvider,		0x00020312, 0, 0);
#endif

/* Provider LOGON Objects */
#if !defined(INITGUID) || defined(USES_IID_IMSLogon)
DEFINE_OLEGUID(IID_IMSLogon,		0x00020313, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABLogon)
DEFINE_OLEGUID(IID_IABLogon,		0x00020314, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPLogon)
DEFINE_OLEGUID(IID_IXPLogon,		0x00020315, 0, 0);
#endif

/* IMAPITable-in-memory Table Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPITableData)
DEFINE_OLEGUID(IID_IMAPITableData,	0x00020316, 0, 0);
#endif

/* MAPI Spooler Init Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerInit)
DEFINE_OLEGUID(IID_IMAPISpoolerInit,	0x00020317, 0, 0);
#endif

/* MAPI Spooler Session Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerSession)
DEFINE_OLEGUID(IID_IMAPISpoolerSession,	0x00020318, 0, 0);
#endif

/* MAPI TNEF Object Interface */
#if !defined(INITGUID) || defined(USES_IID_ITNEF)
DEFINE_OLEGUID(IID_ITNEF,			0x00020319, 0, 0);
#endif

/* IMAPIProp-in-memory Property Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPIPropData)
DEFINE_OLEGUID(IID_IMAPIPropData,	0x0002031A, 0, 0);
#endif

/* MAPI Spooler Hook Object */
#if !defined(INITGUID) || defined(USES_IID_ISpoolerHook)
DEFINE_OLEGUID(IID_ISpoolerHook,	0x00020320, 0, 0);
#endif

/* MAPI Spooler Service Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerService)
DEFINE_OLEGUID(IID_IMAPISpoolerService,	0x0002031E, 0, 0);
#endif

/* MAPI forms, form manager, etc. */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewContext)
DEFINE_OLEGUID(IID_IMAPIViewContext,	0x00020321, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormMgr)
DEFINE_OLEGUID(IID_IMAPIFormMgr,	0x00020322, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IEnumMAPIFormProp)
DEFINE_OLEGUID(IID_IEnumMAPIFormProp,	0x00020323, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormInfo)
DEFINE_OLEGUID(IID_IMAPIFormInfo,	0x00020324, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIForm)
DEFINE_OLEGUID(IID_IMAPIForm,	0x00020327, 0, 0);
#endif


/* Well known guids for name<->id mappings */

/*  The name of MAPI's property set  */
#if !defined(INITGUID) || defined(USES_PS_MAPI)
DEFINE_OLEGUID(PS_MAPI,	0x00020328, 0, 0);
#endif

/*  The name of the set of public strings  */
#if !defined(INITGUID) || defined(USES_PS_PUBLIC_STRINGS)
DEFINE_OLEGUID(PS_PUBLIC_STRINGS,	0x00020329, 0, 0);
#endif




/* MAPI forms, form manager, (cont) */
#if !defined(INITGUID) || defined(USES_IID_IPersistMessage)
DEFINE_OLEGUID(IID_IPersistMessage,	0x0002032A, 0, 0);
#endif

/* IMAPIViewAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewAdviseSink)
DEFINE_OLEGUID(IID_IMAPIViewAdviseSink,	0x0002032B, 0, 0);
#endif

/* Message Store OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamDocfile)
DEFINE_OLEGUID(IID_IStreamDocfile, 0x0002032C, 0, 0);
#endif

/* IMAPIFormProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormProp)
DEFINE_OLEGUID(IID_IMAPIFormProp,	0x0002032D, 0, 0);
#endif

/* IMAPIFormContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormContainer)
DEFINE_OLEGUID(IID_IMAPIFormContainer, 0x0002032E, 0, 0);
#endif

/* IMAPIFormAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormAdviseSink)
DEFINE_OLEGUID(IID_IMAPIFormAdviseSink, 0x0002032F, 0, 0);
#endif

/* TNEF OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamTnef)
DEFINE_OLEGUID(IID_IStreamTnef, 0x00020330, 0, 0);
#endif

/* IMAPIFormFactory */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormFactory)
DEFINE_OLEGUID(IID_IMAPIFormFactory, 0x00020350, 0, 0);
#endif

/* IMAPIMessageSite */
#if !defined(INITGUID) || defined(USES_IID_IMAPIMessageSite)
DEFINE_OLEGUID(IID_IMAPIMessageSite, 0x00020370, 0, 0);
#endif



/* Well known guids routing property sets.
   Usefull when writing applications that route documents
   (i.e. Workflow) across gateways.  Gateways that speak MAPI
   should convert the properties found in the follow property
   sets appropriately. */

/*  PS_ROUTING_EMAIL_ADDRESSES:  Addresses that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_EMAIL_ADDRESSES)
DEFINE_OLEGUID(PS_ROUTING_EMAIL_ADDRESSES,	0x00020380, 0, 0);
#endif

/*  PS_ROUTING_ADDRTYPE:  Address types that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_ADDRTYPE)
DEFINE_OLEGUID(PS_ROUTING_ADDRTYPE,	0x00020381, 0, 0);
#endif

/*  PS_ROUTING_DISPLAY_NAME:  Display Name that corresponds to the other props */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_DISPLAY_NAME)
DEFINE_OLEGUID(PS_ROUTING_DISPLAY_NAME,	0x00020382, 0, 0);
#endif

/*  PS_ROUTING_ENTRYID:  (optional) EntryIDs that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_ENTRYID)
DEFINE_OLEGUID(PS_ROUTING_ENTRYID,	0x00020383, 0, 0);
#endif

/*  PS_ROUTING_SEARCH_KEY:  (optional) search keys that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_SEARCH_KEY)
DEFINE_OLEGUID(PS_ROUTING_SEARCH_KEY,	0x00020384, 0, 0);
#endif

/*	MUID_PROFILE_INSTANCE
	Well known section in a profile which contains a property (PR_SEARCH_KEY) which is unique
	for any given profile.  Applications and providers can depend on this value as being
	different for each unique profile. */
#if !defined(INITGUID) || defined(USES_MUID_PROFILE_INSTANCE)
DEFINE_OLEGUID(MUID_PROFILE_INSTANCE, 0x00020385, 0, 0);
#endif

#if !defined(INITGUID) || defined(IID_IWABExtInit)
DEFINE_GUID(IID_IWABExtInit, 0xea22ebf0, 0x87a4, 0x11d1, 0x9a, 0xcf, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b);
#endif


#endif	/* MAPIGUID_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\common\h\wabdbg.h ===
/*
 *  WABDBG.H
 *
 *  Debugging support for WAB service providers.
 *  Support functions are implemented in WABDBG.C.
 *
 *  History:
 *      03/04/96    brucek  Copied from MAPI's mapidbg.h
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef __WABDBG_H_
#define __WABDBG_H_

/*
 * Debugging Macros -------------------------------------------------------
 *
 *      IFDBG(x)        Results in the expression x if DEBUG is defined, or
 *                      to nothing if DEBUG is not defined
 *
 *      IFNDBG(x)       Results in the expression x if DEBUG is not defined,
 *                      or to nothing if DEBUG is defined
 *
 *      Unreferenced(a) Causes a to be referenced so that the compiler
 *                      doesn't issue warnings about unused local variables
 *                      which exist but are reserved for future use (eg
 *                      ulFlags in many cases)
 */

#if defined(DEBUG)
#define IFDBG(x)            x
#define IFNDBG(x)
#define LEAK_TEST           TRUE    // allow memory leak dumps in debug build
#else
#define IFDBG(x)
#define IFNDBG(x)           x
// #define LEAK_TEST           TRUE    // define to allow memory leak dumps in retail build
#endif

#ifdef __cplusplus
#define EXTERN_C_BEGIN      extern "C" {
#define EXTERN_C_END        }
#else
#define EXTERN_C_BEGIN
#define EXTERN_C_END
#endif

#define dimensionof(a)      (sizeof(a)/sizeof(*(a)))

#define Unreferenced(a)     ((void)(a))

typedef long SCODE;
typedef unsigned long ULONG;
typedef unsigned long DWORD;

/*
 *   Assert Macros ---------------------------------------------------------
 *
 *      Assert(a)       Displays a message indicating the file and line number
 *                      of this Assert() if a == 0.  OK'ing an assert traps
 *                      into the debugger.
 *
 *      AssertSz(a,sz)  Works like an Assert(), but displays the string sz
 *                      along with the file and line number.
 *
 *      Side asserts    A side assert works like an Assert(), but evaluates
 *                      'a' even when asserts are not enabled.
 *
 *      NF asserts      A NF (Non-Fatal) assert works like an Assert(), but
 *                      continues instead of trapping into the debugger when
 *                      OK'ed.
 */

#if defined(DEBUG) || defined(ASSERTS_ENABLED)
#define IFTRAP(x)           x
#else
#define IFTRAP(x)           0
#endif

#define Trap()                                          IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,TEXT("Trap")))
#define TrapSz(psz)                                     IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz))
#define TrapSz1(psz,a1)                                 IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1))
#define TrapSz2(psz,a1,a2)                              IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2))
#define TrapSz3(psz,a1,a2,a3)                           IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3))
#define TrapSz4(psz,a1,a2,a3,a4)                        IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4))
#define TrapSz5(psz,a1,a2,a3,a4,a5)                     IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5))
#define TrapSz6(psz,a1,a2,a3,a4,a5,a6)                  IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6))
#define TrapSz7(psz,a1,a2,a3,a4,a5,a6,a7)               IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7))
#define TrapSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)            IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8))
#define TrapSz9(psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)         IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9))

#define Assert(t)                                       IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,TEXT("Assertion Failure: ") TEXT(#t)),0))
#define AssertSz(t,psz)                                 IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz),0))
#define AssertSz1(t,psz,a1)                             IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1),0))
#define AssertSz2(t,psz,a1,a2)                          IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2),0))
#define AssertSz3(t,psz,a1,a2,a3)                       IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3),0))
#define AssertSz4(t,psz,a1,a2,a3,a4)                    IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4),0))
#define AssertSz5(t,psz,a1,a2,a3,a4,a5)                 IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5),0))
#define AssertSz6(t,psz,a1,a2,a3,a4,a5,a6)              IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define AssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)           IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define AssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)        IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))
#define AssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)     IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9),0))

#define SideAssert(t)                                   ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,TEXT("Assertion Failure: ") TEXT(#t))),0)
#define SideAssertSz(t,psz)                             ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz)),0)
#define SideAssertSz1(t,psz,a1)                         ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1)),0)
#define SideAssertSz2(t,psz,a1,a2)                      ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2)),0)
#define SideAssertSz3(t,psz,a1,a2,a3)                   ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3)),0)
#define SideAssertSz4(t,psz,a1,a2,a3,a4)                ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4)),0)
#define SideAssertSz5(t,psz,a1,a2,a3,a4,a5)             ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define SideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)          ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define SideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)       ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define SideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)    ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)
#define SideAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9) ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)),0)

#define NFAssert(t)                                     IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,TEXT("Assertion Failure: ") TEXT(#t)),0))
#define NFAssertSz(t,psz)                               IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz),0))
#define NFAssertSz1(t,psz,a1)                           IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1),0))
#define NFAssertSz2(t,psz,a1,a2)                        IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2),0))
#define NFAssertSz3(t,psz,a1,a2,a3)                     IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3),0))
#define NFAssertSz4(t,psz,a1,a2,a3,a4)                  IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4),0))
#define NFAssertSz5(t,psz,a1,a2,a3,a4,a5)               IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5),0))
#define NFAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)            IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define NFAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)         IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define NFAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)      IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))
#define NFAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)   IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9),0))

#define NFSideAssert(t)                                 ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,("Assertion Failure: ") TEXT(#t))),0)
#define NFSideAssertSz(t,psz)                           ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz)),0)
#define NFSideAssertSz1(t,psz,a1)                       ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1)),0)
#define NFSideAssertSz2(t,psz,a1,a2)                    ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2)),0)
#define NFSideAssertSz3(t,psz,a1,a2,a3)                 ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3)),0)
#define NFSideAssertSz4(t,psz,a1,a2,a3,a4)              ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4)),0)
#define NFSideAssertSz5(t,psz,a1,a2,a3,a4,a5)           ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define NFSideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)        ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define NFSideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)     ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define NFSideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)  ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)
#define NFSideAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)   ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)),0)

/*
 *   Trace Macros ------------------------------------------------------------
 *
 *      DebugTrace          Use for arbitrary formatted output. It
 *                          takes exactly the same arguments as the
 *                          Windows wsprintf() function.
 *      DebugTraceResult    Shorthand for error tracing with an
 *                          HRESULT. Arguments are the name of the
 *                          function (not quoted) and the HRESULT.
 *      DebugTraceSc        Shorthand for error tracing with an
 *                          SCODE. Arguments are the name of the
 *                          function (not quoted) and the SCODE.
 *      DebugTraceArg       Shorthand for invalid parameter
 *                          tracing. Arguments are the name of the
 *                          function (not quoted) and a quoted
 *                          string describing the bad parameter.
 */

#if defined(DEBUG) || defined(TRACES_ENABLED)
#define IFTRACE(x)          x
#define DebugTrace          DebugTraceFn
#else
#define IFTRACE(x)          0
#define DebugTrace          1?0:DebugTraceFn
#endif

#define DebugTraceResult(f,hr)                          IFTRACE(((hr) ? DebugTraceFn(TEXT(#f) TEXT(" returns 0x%08lX %s\n"), GetScode(hr), SzDecodeScode(GetScode(hr))) : 0))
#define DebugTraceSc(f,sc)                              IFTRACE(((sc) ? DebugTraceFn(TEXT(#f) TEXT(" returns 0x%08lX %s\n"), sc, SzDecodeScode(sc)) : 0))
#define DebugTraceArg(f,s)                              IFTRACE(DebugTraceFn(TEXT(#f) TEXT(": bad parameter: ") s TEXT("\n")))
#define DebugTraceLine()                                IFTRACE(DebugTraceFn(TEXT("File %s, Line %i  \n"),TEXT(__FILE__),__LINE__))
#define DebugTraceProblems(sz, rgprob)                  IFTRACE(DebugTraceProblemsFn(sz, rgprob))

#define TraceSz(psz)                                    IFTRACE(DebugTraceFn(TEXT("~") psz))
#define TraceSz1(psz,a1)                                IFTRACE(DebugTraceFn(TEXT("~") psz,a1))
#define TraceSz2(psz,a1,a2)                             IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2))
#define TraceSz3(psz,a1,a2,a3)                          IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2,a3))
#define TraceSz4(psz,a1,a2,a3,a4)                       IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2,a3,a4))
#define TraceSz5(psz,a1,a2,a3,a4,a5)                    IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2,a3,a4,a5))
#define TraceSz6(psz,a1,a2,a3,a4,a5,a6)                 IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2,a3,a4,a5,a6))
#define TraceSz7(psz,a1,a2,a3,a4,a5,a6,a7)              IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2,a3,a4,a5,a6,a7))
#define TraceSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)           IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2,a3,a4,a5,a6,a7,a8))
#define TraceSz9(psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)        IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2,a3,a4,a5,a6,a7,a8,a9))

/* Debugging Functions ---------------------------------------------------- */

EXTERN_C_BEGIN

#ifdef WIN16
#define EXPORTDBG   __export
#else
#define EXPORTDBG
#endif

int EXPORTDBG __cdecl       DebugTrapFn(int fFatal, TCHAR *pszFile, int iLine, TCHAR *pszFormat, ...);
int EXPORTDBG __cdecl       DebugTraceFn(TCHAR *pszFormat, ...);
void EXPORTDBG __cdecl      DebugTraceProblemsFn(TCHAR *sz, void *rgprob);
TCHAR * EXPORTDBG __cdecl    SzDecodeScodeFn(SCODE sc);
TCHAR * EXPORTDBG __cdecl    SzDecodeUlPropTypeFn(unsigned long ulPropType);
TCHAR * EXPORTDBG __cdecl    SzDecodeUlPropTagFn(unsigned long ulPropTag);
unsigned long EXPORTDBG __cdecl UlPropTagFromSzFn(TCHAR *psz);
SCODE EXPORTDBG __cdecl     ScodeFromSzFn(TCHAR *psz);
void * EXPORTDBG __cdecl    DBGMEM_EncapsulateFn(void * pmalloc, TCHAR *pszSubsys, int fCheckOften);
void EXPORTDBG __cdecl      DBGMEM_ShutdownFn(void * pmalloc);
void EXPORTDBG __cdecl      DBGMEM_CheckMemFn(void * pmalloc, int fReportOrphans);
#if defined(WIN32) && defined(_X86_) && defined(LEAK_TEST)
void EXPORTDBG __cdecl      DBGMEM_LeakHook(FARPROC pfn);
void EXPORTDBG __cdecl      GetCallStack(DWORD *, int, int);
#endif
void EXPORTDBG __cdecl      DBGMEM_NoLeakDetectFn(void * pmalloc, void *pv);
void EXPORTDBG __cdecl      DBGMEM_SetFailureAtFn(void * pmalloc, ULONG ulFailureAt);
SCODE EXPORTDBG __cdecl     ScCheckScFn(SCODE, SCODE *, TCHAR *, TCHAR *, int);
void * EXPORTDBG __cdecl    VMAlloc(ULONG);
void * EXPORTDBG __cdecl    VMAllocEx(ULONG, ULONG);
void * EXPORTDBG __cdecl    VMRealloc(void *, ULONG);
void * EXPORTDBG __cdecl    VMReallocEx(void *, ULONG, ULONG);
ULONG EXPORTDBG __cdecl     VMGetSize(void *);
ULONG EXPORTDBG __cdecl     VMGetSizeEx(void *, ULONG);
void EXPORTDBG __cdecl      VMFree(void *);
void EXPORTDBG __cdecl      VMFreeEx(void *, ULONG);

EXTERN_C_END

/*
 *  Debugging Macros -------------------------------------------------------
 *
 *      SzDecodeScode           Returns the string name of an SCODE
 *      SzDecodeUlPropTag       Returns the string name of a property
 *                              tag
 *      UlPropTagFromSz         Given a property tag's name, returns
 *                              its value
 *      ScodeFromSz             Given an SCODE's name, returns its
 *                              value
 *
 *      DBGMEM_Encapsulate      Given an IMalloc interface, adds heap-
 *                              checking functionality and returns a
 *                              wrapped interface
 *      DBGMEM_Shutdown         Undoes DBGMEM_Encapsulate, and prints
 *                              out information on any allocations made
 *                              since the interface was encapsulated
 *                              that have not yet been released.
 *      DBGMEM_CheckMem         Checks all memory allocated on the heap,
 *                              and optionally reports leaked blocks.
 *      DBGMEM_NoLeakDetect     Prevents a block from appearing on the leak
 *                              report.  Pass NULL for pv to inhibit leak
 *                              reports at all from this heap.
 */

#ifdef DEBUG

#define SzDecodeScode(_sc)              SzDecodeScodeFn(_sc)
#define SzDecodeUlPropType(_ulPropType) SzDecodeUlPropTypeFn(_ulPropType)
#define SzDecodeUlPropTag(_ulPropTag)   SzDecodeUlPropTagFn(_ulPropTag)
#define UlPropTagFromSz(_sz)            UlPropTagFromSzFn(_sz)
#define ScodeFromSz(_sz)                ScodeFromSzFn(_sz)
#define DBGMEM_Encapsulate(pm, psz, f)  DBGMEM_EncapsulateFn(pm, psz, f)
#define DBGMEM_Shutdown(pm)             DBGMEM_ShutdownFn(pm)
#define DBGMEM_CheckMem(pm, f)          DBGMEM_CheckMemFn(pm, f)
#define DBGMEM_NoLeakDetect(pm, pv)     DBGMEM_NoLeakDetectFn(pm, pv)
#define DBGMEM_SetFailureAt(pm, ul)     DBGMEM_SetFailureAtFn(pm, ul)

#else

#define SzDecodeScode(_sc)              (0)
#define SzDecodeUlPropType(_ulPropType) (0)
#define SzDecodeUlPropTag(_ulPropTag)   (0)
#define UlPropTagFromSz(_sz)            (0)
#define ScodeFromSz(_sz)                (0)

#if defined(__cplusplus) && !defined(CINTERFACE)
#define DBGMEM_Encapsulate(pmalloc, pszSubsys, fCheckOften) \
    ((pmalloc)->AddRef(), (pmalloc))
#define DBGMEM_Shutdown(pmalloc) \
    ((pmalloc)->Release())
#else
#define DBGMEM_Encapsulate(pmalloc, pszSubsys, fCheckOften) \
    ((pmalloc)->lpVtbl->AddRef(pmalloc), (pmalloc))
#define DBGMEM_Shutdown(pmalloc) \
    ((pmalloc)->lpVtbl->Release(pmalloc))
#endif
#define DBGMEM_CheckMem(pm, f)
#define DBGMEM_NoLeakDetect(pm, pv)
#define DBGMEM_SetFailureAt(pm, ul)

#endif

/*
 *  SCODE maps -------------------------------------------------------------
 *
 *      ScCheckSc       Given an SCODE and method name, verifies
 *                      that the SCODE can legally be returned from
 *                      thet method. Prints out a debug string if
 *                      it cannot.
 *      HrCheckHr       As ScCheckSc, for functions that return
 *                      HRESULT.
 */

#if defined(DEBUG) && !defined(DOS)
#define ScCheckSc(sc,fn)                ScCheckScFn(sc,fn##_Scodes,#fn,TEXT(__FILE__), __LINE__)
#define HrCheckHr(hr,fn)                HrCheckSc(GetScode(hr),fn)
#else
#define ScCheckSc(sc,fn)                (sc)
#define HrCheckHr(hr,fn)                (hr)
#endif

#define HrCheckSc(sc,fn)                ResultFromScode(ScCheckSc(sc,fn))

#if defined(DEBUG) && !defined(DOS)
extern SCODE Common_Scodes[];
extern SCODE WABAllocateBuffer_Scodes[];
extern SCODE WABAllocateMore_Scodes[];
extern SCODE WABFreeBuffer_Scodes[];

extern SCODE IUnknown_QueryInterface_Scodes[];
extern SCODE IUnknown_AddRef_Scodes[];
extern SCODE IUnknown_Release_Scodes[];
extern SCODE IUnknown_GetLastError_Scodes[];

extern SCODE IWABProp_CopyTo_Scodes[];
extern SCODE IWABProp_CopyProps_Scodes[];
extern SCODE IWABProp_DeleteProps_Scodes[];
extern SCODE IWABProp_GetIDsFromNames_Scodes[];
extern SCODE IWABProp_GetLastError_Scodes[];
extern SCODE IWABProp_GetNamesFromIDs_Scodes[];
extern SCODE IWABProp_GetPropList_Scodes[];
extern SCODE IWABProp_GetProps_Scodes[];
extern SCODE IWABProp_OpenProperty_Scodes[];
extern SCODE IWABProp_SetProps_Scodes[];
extern SCODE IWABProp_SaveChanges_Scodes[];

extern SCODE IStream_Read_Scodes[];
extern SCODE IStream_Write_Scodes[];
extern SCODE IStream_Seek_Scodes[];
extern SCODE IStream_SetSize_Scodes[];
extern SCODE IStream_Tell_Scodes[];
extern SCODE IStream_LockRegion_Scodes[];
extern SCODE IStream_UnlockRegion_Scodes[];
extern SCODE IStream_Clone_Scodes[];
extern SCODE IStream_CopyTo_Scodes[];
extern SCODE IStream_Revert_Scodes[];
extern SCODE IStream_Stat_Scodes[];
extern SCODE IStream_Commit_Scodes[];

extern SCODE IWABTable_GetLastError_Scodes[];
extern SCODE IWABTable_Advise_Scodes[];
extern SCODE IWABTable_Unadvise_Scodes[];
extern SCODE IWABTable_GetStatus_Scodes[];
extern SCODE IWABTable_SetColumns_Scodes[];
extern SCODE IWABTable_QueryColumns_Scodes[];
extern SCODE IWABTable_GetRowCount_Scodes[];
extern SCODE IWABTable_SeekRow_Scodes[];
extern SCODE IWABTable_SeekRowApprox_Scodes[];
extern SCODE IWABTable_QueryPosition_Scodes[];
extern SCODE IWABTable_FindRow_Scodes[];
extern SCODE IWABTable_Restrict_Scodes[];
extern SCODE IWABTable_CreateBookmark_Scodes[];
extern SCODE IWABTable_FreeBookmark_Scodes[];
extern SCODE IWABTable_SortTable_Scodes[];
extern SCODE IWABTable_QuerySortOrder_Scodes[];
extern SCODE IWABTable_QueryRows_Scodes[];
extern SCODE IWABTable_Abort_Scodes[];
extern SCODE IWABTable_ExpandRow_Scodes[];
extern SCODE IWABTable_CollapseRow_Scodes[];
extern SCODE IWABTable_WaitForCompletion_Scodes[];
extern SCODE IWABTable_GetCollapseState_Scodes[];
extern SCODE IWABTable_SetCollapseState_Scodes[];

extern SCODE IAddrBook_OpenEntry_Scodes[];
extern SCODE IAddrBook_CompareEntryIDs_Scodes[];
extern SCODE IAddrBook_CreateOneOff_Scodes[];
extern SCODE IAddrBook_ResolveName_Scodes[];
extern SCODE IAddrBook_Address_Scodes[];
extern SCODE IAddrBook_Details_Scodes[];
extern SCODE IAddrBook_RecipOptions_Scodes[];
extern SCODE IAddrBook_QueryDefaultRecipOpt_Scodes[];
extern SCODE IAddrBook_Address_Scodes[];
extern SCODE IAddrBook_ButtonPress_Scodes[];

extern SCODE IABContainer_GetContentsTable_Scodes[];
extern SCODE IABContainer_GetHierarchyTable_Scodes[];

extern SCODE INotifObj_ChangeEvMask_Scodes[];

#endif

/* ------------------------------------------------------------------------ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\common\h\debug.h ===
/*
 -  debug.h
 -
 *      Microsoft Internet Phone
 *		Debug functions prototypes and macros
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		11.16.95	Yoram Yaacovi		Created
 *
 */

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif
/*
 *	Debug message types
 */
#define AVERROR				0
#define AVTRACE				1
#define AVTRACEMEM			2

#if defined(DEBUG) || defined(TEST)

/*
 *  MACRO: DebugTrap(void)
 *
 *  PURPOSE: Executes a debug break (like 'int 3' on x86)
 *
 *  PARAMETERS:
 *    none
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *
 */

#ifdef OLD_STUFF
#define DebugTrap	DebugTrapFn()
#endif

#define DEBUGCHK(e)  if(!(e)) DebugTrap

/*
 *  MACRO: DebugPrintError(LPTSTR)
 *
 *  PURPOSE: Prints an error string to the debug output terminal
 *
 *  PARAMETERS:
 *    lpszFormat - a printf-style format
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    This macro calls the generic debug print macro, specifying
 *    that this is an error message
 *
 */

#define DebugPrintError(x)	DebugPrintfError x

/*
 *  MACRO: DebugPrintTrace(LPTSTR)
 *
 *  PURPOSE: Prints a trace string to the debug output terminal
 *
 *  PARAMETERS:
 *    lpszFormat - a printf-style format
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    This macro calls the generic debug print macro, specifying
 *    that this is an error message
 *
 */

#define DebugPrintTrace(x)	DebugPrintfTrace x

/*
 *  MACRO: DebugPrintErrorFileLine(DWORD, LPTSTR)
 *
 *  PURPOSE: Pretty print an error to the debugging output.
 *
 *  PARAMETERS:
 *    dwError - Actual error code
 *    pszPrefix  - String to prepend to the printed message.
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    It will take the error, turn it into a human
 *    readable string, prepend pszPrefix (so you
 *    can tag your errors), append __FILE__ and __LINE__
 *    and print it to the debugging output.
 *
 *    This macro is just a wrapper around OutputDebugLineErrorFileLine
 *    that is necessary to get proper values for __FILE__ and __LINE__.
 *
 */

#define DebugPrintErrorFileLine(dwError, pszPrefix) \
	DebugPrintFileLine(dwError, pszPrefix,\
		__FILE__, __LINE__)

/*
 *  MACRO: DebugPrintTraceFileLine(DWORD, LPTSTR)
 *
 *  PURPOSE: Pretty print a trace message to the debugging output.
 *
 *  PARAMETERS:
 *    dwParam- A paramter to trace
 *    pszPrefix  - String to prepend to the printed message.
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    Takes a parameter, prepend pszPrefix (so you
 *    can tag your traces), append __FILE__ and __LINE__
 *    and print it to the debugging output.
 *
 *    This macro is just a wrapper around OutputDebugLineErrorFileLine
 *    that is necessary to get proper values for __FILE__ and __LINE__.
 *
 */

#define DebugPrintTraceFileLine(dwParam, pszPrefix) \
	DebugPrintFileLine(dwParam, pszPrefix,\
		__FILE__, __LINE__)

void DebugPrintFileLine(
    DWORD dwError, LPTSTR szPrefix, 
    LPTSTR szFileName, DWORD nLineNumber);

void __cdecl DebugPrintf(ULONG ulFlags, LPTSTR lpszFormat, ...);
void __cdecl DebugPrintfError(LPTSTR lpszFormat, ...);
void __cdecl DebugPrintfTrace(LPTSTR lpszFormat, ...);

#ifdef OLD_STUFF
void DebugTrapFn(void);
#endif

LPTSTR FormatError(DWORD dwError,
    LPTSTR szOutputBuffer, DWORD dwSizeofOutputBuffer);


#else	// not DEBUG or TEST

#define DebugTrap
#define DebugPrintError(x)
#define DebugPrintTrace(x)
#define DebugPrintTraceFileLine(dwParam, pszPrefix)
#define DEBUGCHK(e)

#endif

#ifdef MEMORY_TRACKING

/*
 *  MACRO: DebugPrintTraceMem(LPTSTR)
 *
 *  PURPOSE: Prints a memory tracking trace string to the debug
 *				output terminal
 *
 *  PARAMETERS:
 *    lpszFormat - a printf-style format
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    This macro calls the generic debug print macro, specifying
 *    that this is an error message
 *
 */

#define DebugPrintTraceMem(x)	DebugPrintf(AVTRACEMEM, x)

#else	// no MEMORY_TRACKING

#define DebugPrintTraceMem(x)

#endif

#ifdef __cplusplus
}
#endif

#endif	//#ifndef _DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\cserve\dbgutil.h ===
/***********************************************************************
 *
 * DBGUTIL.H
 *
 * Debug Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/

#ifdef DEBUG
VOID _DebugObjectProps(BOOL fMAPI, LPMAPIPROP lpObject, LPTSTR Label);
VOID _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject);
void _DebugMapiTable(BOOL fMAPI, LPMAPITABLE lpTable);
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle);

#define WABDebugObjectProps(lpObject, Label) _DebugObjectProps(FALSE, lpObject, Label)
#define WABDebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define WABDebugMapiTable(lpTable) _DebugMapiTable(FALSE, lpTable)
#define WABDebugADRLIST(lpAdrList, lpszTitle) _DebugADRLIST(lpAdrList, lpszTitle)

#define MAPIDebugObjectProps(lpObject, Label) _DebugObjectProps(TRUE, lpObject, Label)
#define MAPIDebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define MAPIDebugMapiTable(lpTable) _DebugMapiTable(TRUE, lpTable)
#define MAPIDebugADRLIST(lpAdrList, lpszTitle) _DebugADRLIST(lpAdrList, lpszTitle)

#else

#define WABDebugObjectProps(lpObject, Label)
#define WABDebugProperties(lpProps, cProps, pszObject)
#define WABDebugMapiTable(lpTable)
#define WABDebugADRLIST(lpAdrList, lpszTitle)

#define MAPIDebugObjectProps(lpObject, Label)
#define MAPIDebugProperties(lpProps, cProps, pszObject)
#define MAPIDebugMapiTable(lpTable)
#define MAPIDebugADRLIST(lpAdrList, lpszTitle)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\common\h\wabmig.h ===
/*
 *  WABMIG.H
 *
 *  WAB Migration Interface
 *
 *  Note: Must follow inclusion of wab.h.
 *
 *  Copyright 1996,  Microsoft Corporation. All Rights Reserved.
 */

typedef struct _WAB_PROGRESS {
    DWORD numerator;       // Numerator for % done progress bar
    DWORD denominator;     // Denominator for % done progress bar
    LPTSTR lpText;         // Text to display in status area
} WAB_PROGRESS, FAR *LPWAB_PROGRESS;


typedef enum {
    WAB_REPLACE_ALWAYS,	
    WAB_REPLACE_NEVER,
    WAB_REPLACE_PROMPT
} WAB_REPLACE_OPTION, *LPWAB_REPLACE_OPTION;

typedef  struct _WAB_IMPORT_OPTIONS {
    WAB_REPLACE_OPTION ReplaceOption;   // On collision, Should import overwrite? Yes, no,  or prompt user.
    BOOL fNoErrors;                     // Don't display error pop-ups
} WAB_IMPORT_OPTIONS, *LPWAB_IMPORT_OPTIONS;


typedef WAB_IMPORT_OPTIONS WAB_EXPORT_OPTIONS;
typedef WAB_EXPORT_OPTIONS * LPWAB_EXPORT_OPTIONS;

typedef HRESULT (STDMETHODCALLTYPE WAB_PROGRESS_CALLBACK)(HWND hwnd,
                 LPWAB_PROGRESS lpProgress);
typedef WAB_PROGRESS_CALLBACK FAR * LPWAB_PROGRESS_CALLBACK;

typedef HRESULT (STDMETHODCALLTYPE WAB_IMPORT)(HWND hwnd,
                 LPADRBOOK lpAdrBook,
                 LPWABOBJECT lpWABObject,
                 LPWAB_PROGRESS_CALLBACK lpProgressCB,
                 LPWAB_IMPORT_OPTIONS lpOptions);
typedef WAB_IMPORT FAR * LPWAB_IMPORT;

typedef HRESULT (STDMETHODCALLTYPE WAB_EXPORT)(HWND hwnd,
                 LPADRBOOK lpAdrBook,
                 LPWABOBJECT lpWABObject,
                 LPWAB_PROGRESS_CALLBACK lpProgressCB,
                 LPWAB_EXPORT_OPTIONS lpOptions);
typedef WAB_EXPORT FAR * LPWAB_EXPORT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\cserve\dbgutil.c ===
/***********************************************************************
 *
 * DBGUTIL.C
 *
 * Debug utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/
#ifdef DEBUG
#include <windows.h>
//#include <mapix.h>
#include <wab.h>
#include <wabdbg.h>

#include "dbgutil.h"

#define _WAB_DBGUTIL_C

PUCHAR PropTagName(ULONG ulPropTag);
const TCHAR szNULL[] = "";

extern SCODE WABFreeBuffer(LPVOID lpBuffer);
VOID FAR CDECL _DebugTrace(LPSTR lpszFmt, ...);



/***************************************************************************

    Name      : FreeBufferAndNull

    Purpose   : Frees a MAPI buffer and NULLs the pointer

    Parameters: lppv = pointer to buffer pointer to free

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall FreeBufferAndNull(BOOL fMAPI, LPVOID * lppv) {
    if (lppv) {
        if (*lppv) {
            SCODE sc;
            if (fMAPI) {
#ifdef OLD_STUFF
                if (sc = MAPIFreeBuffer(*lppv)) {
                    DebugTrace("MAPIFreeBuffer(%x) -> 0x%08x\n", *lppv, sc);
                }
#endif // OLD_STUFF
            } else {
                if (sc = WABFreeBuffer(*lppv)) {
                    DebugTrace("WABFreeBuffer(%x) -> 0x%08x\n", *lppv, sc);
                }
            }
            *lppv = NULL;
        }
    }
}


/***************************************************************************

    Name      : ReleaseAndNull

    Purpose   : Releases an object and NULLs the pointer

    Parameters: lppv = pointer to pointer to object to release

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall ReleaseAndNull(LPVOID * lppv) {
    LPUNKNOWN * lppunk = (LPUNKNOWN *)lppv;

    if (lppunk) {
        if (*lppunk) {
            HRESULT hResult;

            if (hResult = (*lppunk)->lpVtbl->Release(*lppunk)) {
                DebugTrace("Release(%x) -> 0x%08x\n", *lppunk, GetScode(hResult));
            }
            *lppunk = NULL;
        }
    }
}


/***************************************************************************

    Name      : PropTypeString

    Purpose   : Map a proptype to a string

    Parameters: ulPropType = property type to map

    Returns   : string pointer to name of prop type

    Comment   :

***************************************************************************/
LPTSTR PropTypeString(ULONG ulPropType) {
    switch (ulPropType) {
        case PT_UNSPECIFIED:
            return("PT_UNSPECIFIED");
        case PT_NULL:
            return("PT_NULL       ");
        case PT_I2:
            return("PT_I2         ");
        case PT_LONG:
            return("PT_LONG       ");
        case PT_R4:
            return("PT_R4         ");
        case PT_DOUBLE:
            return("PT_DOUBLE     ");
        case PT_CURRENCY:
            return("PT_CURRENCY   ");
        case PT_APPTIME:
            return("PT_APPTIME    ");
        case PT_ERROR:
            return("PT_ERROR      ");
        case PT_BOOLEAN:
            return("PT_BOOLEAN    ");
        case PT_OBJECT:
            return("PT_OBJECT     ");
        case PT_I8:
            return("PT_I8         ");
        case PT_STRING8:
            return("PT_STRING8    ");
        case PT_UNICODE:
            return("PT_UNICODE    ");
        case PT_SYSTIME:
            return("PT_SYSTIME    ");
        case PT_CLSID:
            return("PT_CLSID      ");
        case PT_BINARY:
            return("PT_BINARY     ");
        case PT_MV_I2:
            return("PT_MV_I2      ");
        case PT_MV_LONG:
            return("PT_MV_LONG    ");
        case PT_MV_R4:
            return("PT_MV_R4      ");
        case PT_MV_DOUBLE:
            return("PT_MV_DOUBLE  ");
        case PT_MV_CURRENCY:
            return("PT_MV_CURRENCY");
        case PT_MV_APPTIME:
            return("PT_MV_APPTIME ");
        case PT_MV_SYSTIME:
            return("PT_MV_SYSTIME ");
        case PT_MV_STRING8:
            return("PT_MV_STRING8 ");
        case PT_MV_BINARY:
            return("PT_MV_BINARY  ");
        case PT_MV_UNICODE:
            return("PT_MV_UNICODE ");
        case PT_MV_CLSID:
            return("PT_MV_CLSID   ");
        case PT_MV_I8:
            return("PT_MV_I8      ");
        default:
            return("   <unknown>  ");
    }
}


/***************************************************************************

    Name      : TraceMVPStrings

    Purpose   : Debug trace a multivalued string property value

    Parameters: lpszCaption = caption string
                PropValue = property value to dump

    Returns   : none

    Comment   :

***************************************************************************/
void _TraceMVPStrings(LPTSTR lpszCaption, SPropValue PropValue) {
    ULONG i;

    DebugTrace("-----------------------------------------------------\n");
    DebugTrace("%s", lpszCaption);
    switch (PROP_TYPE(PropValue.ulPropTag)) {

        case PT_ERROR:
            DebugTrace("Error value 0x%08x\n", PropValue.Value.err);
            break;

        case PT_MV_TSTRING:
            DebugTrace("%u values\n", PropValue.Value.MVSZ.cValues);

            if (PropValue.Value.MVSZ.cValues) {
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
                for (i = 0; i < PropValue.Value.MVSZ.cValues; i++) {
                    DebugTrace("%u: \"%s\"\n", i, PropValue.Value.MVSZ.LPPSZ[i]);
                }
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
            }
            break;

        default:
            DebugTrace("TraceMVPStrings got incorrect property type %u for tag %x\n",
              PROP_TYPE(PropValue.ulPropTag), PropValue.ulPropTag);
            break;
    }
}


/***************************************************************************

    Name      : DebugBinary

    Purpose   : Debug dump an array of bytes

    Parameters: cb = number of bytes to dump
                lpb -> bytes to dump

    Returns   : none

    Comment   :

***************************************************************************/
#define DEBUG_NUM_BINARY_LINES  2
VOID DebugBinary(UINT cb, LPBYTE lpb) {
    UINT cbLines = 0;

#if (DEBUG_NUM_BINARY_LINES != 0)
    UINT cbi;

    while (cb && cbLines < DEBUG_NUM_BINARY_LINES) {
        cbi = min(cb, 16);
        cb -= cbi;

        switch (cbi) {
            case 16:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14],
                  lpb[15]);
                break;
            case 1:
                DebugTrace("%02x\n", lpb[0]);
                break;
            case 2:
                DebugTrace("%02x %02x\n", lpb[0], lpb[1]);
                break;
            case 3:
                DebugTrace("%02x %02x %02x\n", lpb[0], lpb[1], lpb[2]);
                break;
            case 4:
                DebugTrace("%02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3]);
                break;
            case 5:
                DebugTrace("%02x %02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3],
                  lpb[4]);
                break;
            case 6:
                DebugTrace("%02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5]);
                break;
            case 7:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6]);
                break;
            case 8:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7]);
                break;
            case 9:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8]);
                break;
            case 10:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9]);
                break;
            case 11:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10]);
                break;
            case 12:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11]);
                break;
            case 13:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12]);
                break;
            case 14:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13]);
                break;
            case 15:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14]);
                break;
        }
        lpb += cbi;
        cbLines++;
    }
    if (cb) {
        DebugTrace("<etc.>");    //
    }
#endif
}


#define RETURN_PROP_CASE(pt) case PROP_ID(pt): return(#pt)

/***************************************************************************

    Name      : PropTagName

    Purpose   : Associate a name with a property tag

    Parameters: ulPropTag = property tag

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
PUCHAR PropTagName(ULONG ulPropTag) {
    static UCHAR szPropTag[35]; // see string on default

    switch (PROP_ID(ulPropTag)) {

        RETURN_PROP_CASE(PR_INITIALS);
        RETURN_PROP_CASE(PR_SURNAME);
        RETURN_PROP_CASE(PR_TITLE);
        RETURN_PROP_CASE(PR_TELEX_NUMBER);
        RETURN_PROP_CASE(PR_GIVEN_NAME);
        RETURN_PROP_CASE(PR_PRIMARY_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PRIMARY_FAX_NUMBER);
        RETURN_PROP_CASE(PR_POSTAL_CODE);
        RETURN_PROP_CASE(PR_POSTAL_ADDRESS);
        RETURN_PROP_CASE(PR_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_PAGER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_OTHER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ORGANIZATIONAL_ID_NUMBER);
        RETURN_PROP_CASE(PR_OFFICE_LOCATION);
        RETURN_PROP_CASE(PR_LOCATION);
        RETURN_PROP_CASE(PR_LOCALITY);
        RETURN_PROP_CASE(PR_ISDN_NUMBER);
        RETURN_PROP_CASE(PR_GOVERNMENT_ID_NUMBER);
        RETURN_PROP_CASE(PR_GENERATION);
        RETURN_PROP_CASE(PR_DEPARTMENT_NAME);
        RETURN_PROP_CASE(PR_COUNTRY);
        RETURN_PROP_CASE(PR_COMPANY_NAME);
        RETURN_PROP_CASE(PR_COMMENT);
        RETURN_PROP_CASE(PR_CELLULAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CALLBACK_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS2_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_FAX_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT);
        RETURN_PROP_CASE(PR_ACCOUNT);
        RETURN_PROP_CASE(PR_TEMPLATEID);
        RETURN_PROP_CASE(PR_DETAILS_TABLE);
        RETURN_PROP_CASE(PR_SEARCH_KEY);
        RETURN_PROP_CASE(PR_LAST_MODIFICATION_TIME);
        RETURN_PROP_CASE(PR_CREATION_TIME);
        RETURN_PROP_CASE(PR_ENTRYID);
        RETURN_PROP_CASE(PR_RECORD_KEY);
        RETURN_PROP_CASE(PR_MAPPING_SIGNATURE);
        RETURN_PROP_CASE(PR_OBJECT_TYPE);
        RETURN_PROP_CASE(PR_ROWID);
        RETURN_PROP_CASE(PR_ADDRTYPE);
        RETURN_PROP_CASE(PR_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_EMAIL_ADDRESS);
        RETURN_PROP_CASE(PR_DEPTH);
        RETURN_PROP_CASE(PR_ROW_TYPE);
        RETURN_PROP_CASE(PR_RADIO_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_HOME_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_INSTANCE_KEY);
        RETURN_PROP_CASE(PR_DISPLAY_TYPE);
        RETURN_PROP_CASE(PR_RECIPIENT_TYPE);
        RETURN_PROP_CASE(PR_CONTAINER_FLAGS);
        RETURN_PROP_CASE(PR_DEF_CREATE_DL);
        RETURN_PROP_CASE(PR_DEF_CREATE_MAILUSER);
        RETURN_PROP_CASE(PR_CONTACT_ADDRTYPES);
        RETURN_PROP_CASE(PR_CONTACT_DEFAULT_ADDRESS_INDEX);
        RETURN_PROP_CASE(PR_CONTACT_EMAIL_ADDRESSES);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_CITY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_COUNTRY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POSTAL_CODE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STREET);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_MIDDLE_NAME);
        RETURN_PROP_CASE(PR_NICKNAME);
        RETURN_PROP_CASE(PR_PERSONAL_HOME_PAGE);
        RETURN_PROP_CASE(PR_BUSINESS_HOME_PAGE);
        RETURN_PROP_CASE(PR_MHS_COMMON_NAME);
        RETURN_PROP_CASE(PR_SEND_RICH_INFO);
        RETURN_PROP_CASE(PR_TRANSMITABLE_DISPLAY_NAME);

        default:
            wsprintf(szPropTag, "Unknown property tag 0x%x",
              PROP_ID(ulPropTag));
            return(szPropTag);
    }
}


/***************************************************************************

    Name      : DebugPropTagArray

    Purpose   : Displays MAPI property tags from a counted array

    Parameters: lpPropArray -> property array
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugPropTagArray(LPSPropTagArray lpPropArray, PUCHAR pszObject) {
    DWORD i;
    PUCHAR lpType;

    if (lpPropArray == NULL) {
        DebugTrace("Empty %s property tag array.\n", pszObject ? pszObject : szNULL);
        return;
    }

    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s property tags:\n", lpPropArray->cValues,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < lpPropArray->cValues ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpPropArray->aulPropTag[i],
          lpPropArray->aulPropTag[i] >> 16,
          lpPropArray->aulPropTag[i] & 0xffff);
#endif
        switch (lpPropArray->aulPropTag[i] & 0xffff) {
            case PT_STRING8:
                lpType = "STRING8";
                break;
            case PT_LONG:
                lpType = "LONG";
                break;
            case PT_I2:
                lpType = "I2";
                break;
            case PT_ERROR:
                lpType = "ERROR";
                break;
            case PT_BOOLEAN:
                lpType = "BOOLEAN";
                break;
            case PT_R4:
                lpType = "R4";
                break;
            case PT_DOUBLE:
                lpType = "DOUBLE";
                break;
            case PT_CURRENCY:
                lpType = "CURRENCY";
                break;
            case PT_APPTIME:
                lpType = "APPTIME";
                break;
            case PT_SYSTIME:
                lpType = "SYSTIME";
                break;
            case PT_UNICODE:
                lpType = "UNICODE";
                break;
            case PT_CLSID:
                lpType = "CLSID";
                break;
            case PT_BINARY:
                lpType = "BINARY";
                break;
            case PT_I8:
                lpType = "PT_I8";
                break;
            case PT_MV_I2:
                lpType = "MV_I2";
                break;
            case PT_MV_LONG:
                lpType = "MV_LONG";
                break;
            case PT_MV_R4:
                lpType = "MV_R4";
                break;
            case PT_MV_DOUBLE:
                lpType = "MV_DOUBLE";
                break;
            case PT_MV_CURRENCY:
                lpType = "MV_CURRENCY";
                break;
            case PT_MV_APPTIME:
                lpType = "MV_APPTIME";
                break;
            case PT_MV_SYSTIME:
                lpType = "MV_SYSTIME";
                break;
            case PT_MV_BINARY:
                lpType = "MV_BINARY";
                break;
            case PT_MV_STRING8:
                lpType = "MV_STRING8";
                break;
            case PT_MV_UNICODE:
                lpType = "MV_UNICODE";
                break;
            case PT_MV_CLSID:
                lpType = "MV_CLSID";
                break;
            case PT_MV_I8:
                lpType = "MV_I8";
                break;
            case PT_NULL:
                lpType = "NULL";
                break;
            case PT_OBJECT:
                lpType = "OBJECT";
                break;
            default:
                DebugTrace("<Unknown Property Type>");
                break;
        }
        DebugTrace("%s\t%s\n", PropTagName(lpPropArray->aulPropTag[i]), lpType);
    }
}


/***************************************************************************

    Name      : DebugProperties

    Purpose   : Displays MAPI properties in a property list

    Parameters: lpProps -> property list
                cProps = count of properties
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
void _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject) {
    DWORD i, j;


    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s properties:\n", cProps,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < cProps ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpProps[i].ulPropTag,
          lpProps[i].ulPropTag >> 16,
          lpProps[i].ulPropTag & 0xffff);
#endif
        DebugTrace("%s\n", PropTagName(lpProps[i].ulPropTag));

        switch (lpProps[i].ulPropTag & 0xffff) {
            case PT_STRING8:
                if (lstrlen(lpProps[i].Value.lpszA) < 1024) {
                    DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.lpszA);
                } else {
                    DebugTrace("STRING8 Value is too long to display\n");
                }
                break;
            case PT_LONG:
                DebugTrace("LONG Value:%u\n", lpProps[i].Value.l);
                break;
            case PT_I2:
                DebugTrace("I2 Value:%u\n", lpProps[i].Value.i);
                break;
            case PT_ERROR:
                DebugTrace("ERROR Value: 0x%08x\n", lpProps[i].Value.err);
                break;
            case PT_BOOLEAN:
                DebugTrace("BOOLEAN Value:%s\n", lpProps[i].Value.b ?
                  "TRUE" : "FALSE");
                break;
            case PT_R4:
                DebugTrace("R4 Value\n");
                break;
            case PT_DOUBLE:
                DebugTrace("DOUBLE Value\n");
                break;
            case PT_CURRENCY:
                DebugTrace("CURRENCY Value\n");
                break;
            case PT_APPTIME:
                DebugTrace("APPTIME Value\n");
                break;
            case PT_SYSTIME:
//                DebugTime(lpProps[i].Value.ft, "SYSTIME Value:%s\n");
                break;
            case PT_UNICODE:
                DebugTrace("UNICODE Value\n");
                break;
            case PT_CLSID:
                DebugTrace("CLSID Value\n");
                break;
            case PT_BINARY:
                DebugTrace("BINARY Value %u bytes:\n", lpProps[i].Value.bin.cb);
                DebugBinary(lpProps[i].Value.bin.cb, lpProps[i].Value.bin.lpb);
                break;
            case PT_I8:
                DebugTrace("LARGE_INTEGER Value\n");
                break;
            case PT_MV_I2:
                DebugTrace("MV_I2 Value\n");
                break;
            case PT_MV_LONG:
                DebugTrace("MV_LONG Value\n");
                break;
            case PT_MV_R4:
                DebugTrace("MV_R4 Value\n");
                break;
            case PT_MV_DOUBLE:
                DebugTrace("MV_DOUBLE Value\n");
                break;
            case PT_MV_CURRENCY:
                DebugTrace("MV_CURRENCY Value\n");
                break;
            case PT_MV_APPTIME:
                DebugTrace("MV_APPTIME Value\n");
                break;
            case PT_MV_SYSTIME:
                DebugTrace("MV_SYSTIME Value\n");
                break;
            case PT_MV_BINARY:
                DebugTrace("MV_BINARY with %u values\n", lpProps[i].Value.MVbin.cValues);
                for (j = 0; j < lpProps[i].Value.MVbin.cValues; j++) {
                    DebugTrace("BINARY Value %u: %u bytes\n", j, lpProps[i].Value.MVbin.lpbin[j].cb);
                    DebugBinary(lpProps[i].Value.MVbin.lpbin[j].cb, lpProps[i].Value.MVbin.lpbin[j].lpb);
                }
                break;
            case PT_MV_STRING8:
                DebugTrace("MV_STRING8 with %u values\n", lpProps[i].Value.MVszA.cValues);
                for (j = 0; j < lpProps[i].Value.MVszA.cValues; j++) {
                    if (lstrlen(lpProps[i].Value.MVszA.lppszA[j]) < 1024) {
                        DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.MVszA.lppszA[j]);
                    } else {
                        DebugTrace("STRING8 Value is too long to display\n");
                    }
                }
                break;
            case PT_MV_UNICODE:
                DebugTrace("MV_UNICODE Value\n");
                break;
            case PT_MV_CLSID:
                DebugTrace("MV_CLSID Value\n");
                break;
            case PT_MV_I8:
                DebugTrace("MV_I8 Value\n");
                break;
            case PT_NULL:
                DebugTrace("NULL Value\n");
                break;
            case PT_OBJECT:
                DebugTrace("OBJECT Value\n");
                break;
            default:
                DebugTrace("Unknown Property Type\n");
                break;
        }
    }
}


/***************************************************************************

    Name      : DebugADRLIST

    Purpose   : Displays structure of an ADRLIST including properties

    Parameters: lpAdrList -> ADRLSIT to show
                lpszTitle = string to identify this dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle) {
     ULONG i;
     TCHAR szTitle[250];

     for (i = 0; i < lpAdrList->cEntries; i++) {

         wsprintf(szTitle, "%s : Entry %u", lpszTitle, i);
         _DebugProperties(lpAdrList->aEntries[i].rgPropVals,
           lpAdrList->aEntries[i].cValues, szTitle);
     }
}


/***************************************************************************

    Name      : DebugObjectProps

    Purpose   : Displays MAPI properties of an object

    Parameters: fMAPI = TRUE if this is a MAPI object, FALSE if WAB
                lpObject -> object to dump
                Label = string to identify this prop dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugObjectProps(BOOL fMAPI, LPMAPIPROP lpObject, LPTSTR Label) {
    DWORD cProps = 0;
    LPSPropValue lpProps = NULL;
    HRESULT hr = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;


    hr = lpObject->lpVtbl->GetProps(lpObject, NULL, 0, &cProps, &lpProps);
    switch (sc = GetScode(hr)) {
        case SUCCESS_SUCCESS:
            break;

        case MAPI_W_ERRORS_RETURNED:
            DebugTrace("GetProps -> Errors Returned\n");
            break;

        default:
            DebugTrace("GetProps -> Error 0x%x\n", sc);
            return;
    }

    _DebugProperties(lpProps, cProps, Label);

    FreeBufferAndNull(fMAPI, &lpProps);
}


/*
 *	Destroys an SRowSet structure.
 */
STDAPI_(void)
MyFreeProws(BOOL fMAPI, LPSRowSet prows)
{
	ULONG		irow;

	if (!prows)
		return;

	for (irow = 0; irow < prows->cRows; ++irow)
		FreeBufferAndNull(fMAPI, &(prows->aRow[irow].lpProps));
	FreeBufferAndNull(fMAPI, &prows);
}


/***************************************************************************

    Name      : DebugMapiTable

    Purpose   : Displays structure of a MAPITABLE including properties

    Parameters: fMAPI = TRUE if this is a MAPI object, FALSE if WAB
                lpTable -> MAPITABLE to display

    Returns   : none

    Comment   : Don't sort the columns or rows here.  This routine should
                not produce side effects in the table.

***************************************************************************/
void _DebugMapiTable(BOOL fMAPI, LPMAPITABLE lpTable) {
    UCHAR szTemp[30];   // plenty for "ROW %u"
    ULONG ulCount;
    WORD wIndex;
    LPSRowSet lpsRow = NULL;
    ULONG ulCurrentRow = (ULONG)-1;
    ULONG ulNum, ulDen, lRowsSeeked;

    DebugTrace("=======================================\n");
    DebugTrace("+  Dump of MAPITABLE at 0x%x:\n", lpTable);
    DebugTrace("---------------------------------------\n");

    // How big is the table?
    lpTable->lpVtbl->GetRowCount(lpTable, 0, &ulCount);
    DebugTrace("Table contains %u rows\n", ulCount);

    // Save the current position in the table
    lpTable->lpVtbl->QueryPosition(lpTable, &ulCurrentRow, &ulNum, &ulDen);

    // Display the properties for each row in the table
    for (wIndex = 0; wIndex < ulCount; wIndex++) {
        // Get the next row
        lpTable->lpVtbl->QueryRows(lpTable, 1, 0, &lpsRow);

        if (lpsRow) {
//            Assert(lpsRow->cRows == 1); // should have exactly one row

            wsprintf(szTemp, "ROW %u", wIndex);

            _DebugProperties(lpsRow->aRow[0].lpProps,
              lpsRow->aRow[0].cValues, szTemp);

            MyFreeProws(fMAPI, lpsRow);
        }
    }

    // Restore the current position for the table
    if (ulCurrentRow != (ULONG)-1) {
        lpTable->lpVtbl->SeekRow(lpTable, BOOKMARK_BEGINNING, ulCurrentRow,
          &lRowsSeeked);
    }
}


/*
 * DebugTrace -- printf to the debugger console or debug output file
 * Takes printf style arguments.
 * Expects newline characters at the end of the string.
 */
VOID FAR CDECL _DebugTrace(LPSTR lpszFmt, ...) {
    va_list marker;
    TCHAR String[1100];

    va_start(marker, lpszFmt);
    wvsprintf(String, lpszFmt, marker);
        OutputDebugString(String);
}

int EXPORTDBG __cdecl DebugTraceFn(char *pszFormat, ...) {
    va_list marker;
    TCHAR String[1100];

    va_start(marker, pszFormat);
    wvsprintf(String, pszFormat, marker);
    OutputDebugString(String);
    return(0);
}


/*
 * DebugAssert
 *
 * From MAPI 1.0 SDK sample code
 */
int __cdecl DebugAssert(int fFatal, char *pszFile, int iLine,
  char *pszFormat, ...) {
    char    sz[512];
    va_list vl;
    int     id;

    lstrcpy(sz, "++++ WAB Debug Trap (");
    OutputDebugString(sz);

    va_start(vl, pszFormat);
    wvsprintf(sz, pszFormat, vl);
    va_end(vl);

    wsprintf(sz + lstrlen(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

    OutputDebugString(sz);

    // Hold down control key to prevent MessageBox
    if (GetAsyncKeyState(VK_CONTROL) >= 0) {
        id = MessageBox(NULL,
          sz,
          "Microsoft Windows Address Book Debug Trap",
          MB_ABORTRETRYIGNORE | MB_ICONHAND | MB_SYSTEMMODAL |
          (fFatal ? MB_DEFBUTTON1 : MB_DEFBUTTON3) );

        if (id == IDABORT)
            *((LPBYTE)NULL) = 0;
        else if (id == IDRETRY)
            DebugBreak();
    }

    return(0);
}


int EXPORTDBG __cdecl DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...) {
    char    sz[512];
    va_list vl;
    int     id;

    lstrcpy(sz, "++++ WAB Debug Trap (");
    OutputDebugString(sz);

    va_start(vl, pszFormat);
    wvsprintf(sz, pszFormat, vl);
    va_end(vl);

    wsprintf(sz + lstrlen(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

    OutputDebugString(sz);

    // Hold down control key to prevent MessageBox
    if (GetAsyncKeyState(VK_CONTROL) >= 0) {
        id = MessageBox(NULL,
          sz,
          "Microsoft Windows Address Book Debug Trap",
          MB_ABORTRETRYIGNORE | MB_ICONHAND | MB_SYSTEMMODAL |
          (fFatal ? MB_DEFBUTTON1 : MB_DEFBUTTON3) );

        if (id == IDABORT)
            *((LPBYTE)NULL) = 0;
        else if (id == IDRETRY)
            DebugBreak();
    }

    return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\cserve\resource.h ===
// Dialog Boxes
#define IDM_EXIT                            5

#define IDD_Replace                         103
#define IDD_Error                           104

// Control Identifiers
// Replace Dialog
#define IDC_YesToAll                        1020
#define IDC_NoToAll                         1021
#define IDC_Replace_Message                 1022

// Error Dialog
#define IDC_NoMoreError                     1030
#define IDC_ErrorMessage                    1031

//
#define MAX_RESOURCE_STRING                 256     // Ought to be enough

// String Identifiers
#define IDS_CSERVE_FILE_SPEC                1143
#define IDS_CSERVE_EXPORT_TITLE             1144
#define IDS_CSERVE_IMPORT_TITLE             1145
#define IDE_CSERVE_IMPORT_FILE_ERROR        1146
#define IDE_CSERVE_EXPORT_FILE_ERROR        1147
#define IDS_CSERVE_IMPORT_COLLISION         1148
#define IDS_REPLACE_MESSAGE                 1149

// Static Identifiers
#define IDC_STATIC                          -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wabmig\dbgutil.c ===
/***********************************************************************
 *
 * DBGUTIL.C
 *
 * Debug utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/
#ifdef DEBUG
#include <windows.h>
#include <mapix.h>
#include <wab.h>
#include <wabdbg.h>

#include "dbgutil.h"

#define _WAB_DBGUTIL_C

PUCHAR PropTagName(ULONG ulPropTag);
const TCHAR szNULL[] = "";

extern SCODE WABFreeBuffer(LPVOID lpBuffer);
VOID FAR CDECL _DebugTrace(LPSTR lpszFmt, ...);



/***************************************************************************

    Name      : FreeBufferAndNull

    Purpose   : Frees a MAPI buffer and NULLs the pointer

    Parameters: lppv = pointer to buffer pointer to free

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall FreeBufferAndNull(BOOL fMAPI, LPVOID * lppv) {
    if (lppv) {
        if (*lppv) {
            SCODE sc;
            if (fMAPI) {
#ifdef OLD_STUFF
                if (sc = MAPIFreeBuffer(*lppv)) {
                    DebugTrace("MAPIFreeBuffer(%x) -> 0x%08x\n", *lppv, sc);
                }
#endif // OLD_STUFF
                DebugTrace("Doh!  FreeBufferAndNull with MAPI Flag set.  Can't do that!\n");
                sc = MAPI_E_INVALID_PARAMETER;
            } else {
                if (sc = WABFreeBuffer(*lppv)) {
                    DebugTrace("WABFreeBuffer(%x) -> 0x%08x\n", *lppv, sc);
                }
            }
            *lppv = NULL;
        }
    }
}


/***************************************************************************

    Name      : ReleaseAndNull

    Purpose   : Releases an object and NULLs the pointer

    Parameters: lppv = pointer to pointer to object to release

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall ReleaseAndNull(LPVOID * lppv) {
    LPUNKNOWN * lppunk = (LPUNKNOWN *)lppv;

    if (lppunk) {
        if (*lppunk) {
            HRESULT hResult;

            if (hResult = (*lppunk)->lpVtbl->Release(*lppunk)) {
                DebugTrace("Release(%x) -> 0x%08x\n", *lppunk, GetScode(hResult));
            }
            *lppunk = NULL;
        }
    }
}


/***************************************************************************

    Name      : PropTypeString

    Purpose   : Map a proptype to a string

    Parameters: ulPropType = property type to map

    Returns   : string pointer to name of prop type

    Comment   :

***************************************************************************/
LPTSTR PropTypeString(ULONG ulPropType) {
    switch (ulPropType) {
        case PT_UNSPECIFIED:
            return("PT_UNSPECIFIED");
        case PT_NULL:
            return("PT_NULL       ");
        case PT_I2:
            return("PT_I2         ");
        case PT_LONG:
            return("PT_LONG       ");
        case PT_R4:
            return("PT_R4         ");
        case PT_DOUBLE:
            return("PT_DOUBLE     ");
        case PT_CURRENCY:
            return("PT_CURRENCY   ");
        case PT_APPTIME:
            return("PT_APPTIME    ");
        case PT_ERROR:
            return("PT_ERROR      ");
        case PT_BOOLEAN:
            return("PT_BOOLEAN    ");
        case PT_OBJECT:
            return("PT_OBJECT     ");
        case PT_I8:
            return("PT_I8         ");
        case PT_STRING8:
            return("PT_STRING8    ");
        case PT_UNICODE:
            return("PT_UNICODE    ");
        case PT_SYSTIME:
            return("PT_SYSTIME    ");
        case PT_CLSID:
            return("PT_CLSID      ");
        case PT_BINARY:
            return("PT_BINARY     ");
        case PT_MV_I2:
            return("PT_MV_I2      ");
        case PT_MV_LONG:
            return("PT_MV_LONG    ");
        case PT_MV_R4:
            return("PT_MV_R4      ");
        case PT_MV_DOUBLE:
            return("PT_MV_DOUBLE  ");
        case PT_MV_CURRENCY:
            return("PT_MV_CURRENCY");
        case PT_MV_APPTIME:
            return("PT_MV_APPTIME ");
        case PT_MV_SYSTIME:
            return("PT_MV_SYSTIME ");
        case PT_MV_STRING8:
            return("PT_MV_STRING8 ");
        case PT_MV_BINARY:
            return("PT_MV_BINARY  ");
        case PT_MV_UNICODE:
            return("PT_MV_UNICODE ");
        case PT_MV_CLSID:
            return("PT_MV_CLSID   ");
        case PT_MV_I8:
            return("PT_MV_I8      ");
        default:
            return("   <unknown>  ");
    }
}


/***************************************************************************

    Name      : TraceMVPStrings

    Purpose   : Debug trace a multivalued string property value

    Parameters: lpszCaption = caption string
                PropValue = property value to dump

    Returns   : none

    Comment   :

***************************************************************************/
void _TraceMVPStrings(LPTSTR lpszCaption, SPropValue PropValue) {
    ULONG i;

    DebugTrace("-----------------------------------------------------\n");
    DebugTrace("%s", lpszCaption);
    switch (PROP_TYPE(PropValue.ulPropTag)) {

        case PT_ERROR:
            DebugTrace("Error value 0x%08x\n", PropValue.Value.err);
            break;

        case PT_MV_TSTRING:
            DebugTrace("%u values\n", PropValue.Value.MVSZ.cValues);

            if (PropValue.Value.MVSZ.cValues) {
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
                for (i = 0; i < PropValue.Value.MVSZ.cValues; i++) {
                    DebugTrace("%u: \"%s\"\n", i, PropValue.Value.MVSZ.LPPSZ[i]);
                }
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
            }
            break;

        default:
            DebugTrace("TraceMVPStrings got incorrect property type %u for tag %x\n",
              PROP_TYPE(PropValue.ulPropTag), PropValue.ulPropTag);
            break;
    }
}


/***************************************************************************

    Name      : DebugBinary

    Purpose   : Debug dump an array of bytes

    Parameters: cb = number of bytes to dump
                lpb -> bytes to dump

    Returns   : none

    Comment   :

***************************************************************************/
#define DEBUG_NUM_BINARY_LINES  8
VOID DebugBinary(UINT cb, LPBYTE lpb) {
    UINT cbLines = 0;

#if (DEBUG_NUM_BINARY_LINES != 0)
    UINT cbi;

    while (cb && cbLines < DEBUG_NUM_BINARY_LINES) {
        cbi = min(cb, 16);
        cb -= cbi;

        switch (cbi) {
            case 16:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14],
                  lpb[15]);
                break;
            case 1:
                DebugTrace("%02x\n", lpb[0]);
                break;
            case 2:
                DebugTrace("%02x %02x\n", lpb[0], lpb[1]);
                break;
            case 3:
                DebugTrace("%02x %02x %02x\n", lpb[0], lpb[1], lpb[2]);
                break;
            case 4:
                DebugTrace("%02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3]);
                break;
            case 5:
                DebugTrace("%02x %02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3],
                  lpb[4]);
                break;
            case 6:
                DebugTrace("%02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5]);
                break;
            case 7:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6]);
                break;
            case 8:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7]);
                break;
            case 9:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8]);
                break;
            case 10:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9]);
                break;
            case 11:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10]);
                break;
            case 12:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11]);
                break;
            case 13:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12]);
                break;
            case 14:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13]);
                break;
            case 15:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14]);
                break;
        }
        lpb += cbi;
        cbLines++;
    }
    if (cb) {
        DebugTrace("<etc.>");    //
    }
#endif
}


#define RETURN_PROP_CASE(pt) case PROP_ID(pt): return(#pt)

/***************************************************************************

    Name      : PropTagName

    Purpose   : Associate a name with a property tag

    Parameters: ulPropTag = property tag

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
PUCHAR PropTagName(ULONG ulPropTag) {
    static UCHAR szPropTag[35]; // see string on default

    switch (PROP_ID(ulPropTag)) {

        RETURN_PROP_CASE(PR_INITIALS);
        RETURN_PROP_CASE(PR_SURNAME);
        RETURN_PROP_CASE(PR_TITLE);
        RETURN_PROP_CASE(PR_TELEX_NUMBER);
        RETURN_PROP_CASE(PR_GIVEN_NAME);
        RETURN_PROP_CASE(PR_PRIMARY_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PRIMARY_FAX_NUMBER);
        RETURN_PROP_CASE(PR_POSTAL_CODE);
        RETURN_PROP_CASE(PR_POSTAL_ADDRESS);
        RETURN_PROP_CASE(PR_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_PAGER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_OTHER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ORGANIZATIONAL_ID_NUMBER);
        RETURN_PROP_CASE(PR_OFFICE_LOCATION);
        RETURN_PROP_CASE(PR_LOCATION);
        RETURN_PROP_CASE(PR_LOCALITY);
        RETURN_PROP_CASE(PR_ISDN_NUMBER);
        RETURN_PROP_CASE(PR_GOVERNMENT_ID_NUMBER);
        RETURN_PROP_CASE(PR_GENERATION);
        RETURN_PROP_CASE(PR_DEPARTMENT_NAME);
        RETURN_PROP_CASE(PR_COUNTRY);
        RETURN_PROP_CASE(PR_COMPANY_NAME);
        RETURN_PROP_CASE(PR_COMMENT);
        RETURN_PROP_CASE(PR_CELLULAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CALLBACK_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS2_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_FAX_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT);
        RETURN_PROP_CASE(PR_ACCOUNT);
        RETURN_PROP_CASE(PR_TEMPLATEID);
        RETURN_PROP_CASE(PR_DETAILS_TABLE);
        RETURN_PROP_CASE(PR_SEARCH_KEY);
        RETURN_PROP_CASE(PR_LAST_MODIFICATION_TIME);
        RETURN_PROP_CASE(PR_CREATION_TIME);
        RETURN_PROP_CASE(PR_ENTRYID);
        RETURN_PROP_CASE(PR_RECORD_KEY);
        RETURN_PROP_CASE(PR_MAPPING_SIGNATURE);
        RETURN_PROP_CASE(PR_OBJECT_TYPE);
        RETURN_PROP_CASE(PR_ROWID);
        RETURN_PROP_CASE(PR_ADDRTYPE);
        RETURN_PROP_CASE(PR_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_EMAIL_ADDRESS);
        RETURN_PROP_CASE(PR_DEPTH);
        RETURN_PROP_CASE(PR_ROW_TYPE);
        RETURN_PROP_CASE(PR_RADIO_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_HOME_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_INSTANCE_KEY);
        RETURN_PROP_CASE(PR_DISPLAY_TYPE);
        RETURN_PROP_CASE(PR_RECIPIENT_TYPE);
        RETURN_PROP_CASE(PR_CONTAINER_FLAGS);
        RETURN_PROP_CASE(PR_DEF_CREATE_DL);
        RETURN_PROP_CASE(PR_DEF_CREATE_MAILUSER);
        RETURN_PROP_CASE(PR_CONTACT_ADDRTYPES);
        RETURN_PROP_CASE(PR_CONTACT_DEFAULT_ADDRESS_INDEX);
        RETURN_PROP_CASE(PR_CONTACT_EMAIL_ADDRESSES);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_CITY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_COUNTRY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POSTAL_CODE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STREET);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_MIDDLE_NAME);
        RETURN_PROP_CASE(PR_NICKNAME);
        RETURN_PROP_CASE(PR_PERSONAL_HOME_PAGE);
        RETURN_PROP_CASE(PR_BUSINESS_HOME_PAGE);
        RETURN_PROP_CASE(PR_MHS_COMMON_NAME);
        RETURN_PROP_CASE(PR_SEND_RICH_INFO);
        RETURN_PROP_CASE(PR_TRANSMITABLE_DISPLAY_NAME);

        default:
            wsprintf(szPropTag, "Unknown property tag 0x%x",
              PROP_ID(ulPropTag));
            return(szPropTag);
    }
}


/***************************************************************************

    Name      : DebugPropTagArray

    Purpose   : Displays MAPI property tags from a counted array

    Parameters: lpPropArray -> property array
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugPropTagArray(LPSPropTagArray lpPropArray, PUCHAR pszObject) {
    DWORD i;
    PUCHAR lpType;

    if (lpPropArray == NULL) {
        DebugTrace("Empty %s property tag array.\n", pszObject ? pszObject : szNULL);
        return;
    }

    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s property tags:\n", lpPropArray->cValues,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < lpPropArray->cValues ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpPropArray->aulPropTag[i],
          lpPropArray->aulPropTag[i] >> 16,
          lpPropArray->aulPropTag[i] & 0xffff);
#endif
        switch (lpPropArray->aulPropTag[i] & 0xffff) {
            case PT_STRING8:
                lpType = "STRING8";
                break;
            case PT_LONG:
                lpType = "LONG";
                break;
            case PT_I2:
                lpType = "I2";
                break;
            case PT_ERROR:
                lpType = "ERROR";
                break;
            case PT_BOOLEAN:
                lpType = "BOOLEAN";
                break;
            case PT_R4:
                lpType = "R4";
                break;
            case PT_DOUBLE:
                lpType = "DOUBLE";
                break;
            case PT_CURRENCY:
                lpType = "CURRENCY";
                break;
            case PT_APPTIME:
                lpType = "APPTIME";
                break;
            case PT_SYSTIME:
                lpType = "SYSTIME";
                break;
            case PT_UNICODE:
                lpType = "UNICODE";
                break;
            case PT_CLSID:
                lpType = "CLSID";
                break;
            case PT_BINARY:
                lpType = "BINARY";
                break;
            case PT_I8:
                lpType = "PT_I8";
                break;
            case PT_MV_I2:
                lpType = "MV_I2";
                break;
            case PT_MV_LONG:
                lpType = "MV_LONG";
                break;
            case PT_MV_R4:
                lpType = "MV_R4";
                break;
            case PT_MV_DOUBLE:
                lpType = "MV_DOUBLE";
                break;
            case PT_MV_CURRENCY:
                lpType = "MV_CURRENCY";
                break;
            case PT_MV_APPTIME:
                lpType = "MV_APPTIME";
                break;
            case PT_MV_SYSTIME:
                lpType = "MV_SYSTIME";
                break;
            case PT_MV_BINARY:
                lpType = "MV_BINARY";
                break;
            case PT_MV_STRING8:
                lpType = "MV_STRING8";
                break;
            case PT_MV_UNICODE:
                lpType = "MV_UNICODE";
                break;
            case PT_MV_CLSID:
                lpType = "MV_CLSID";
                break;
            case PT_MV_I8:
                lpType = "MV_I8";
                break;
            case PT_NULL:
                lpType = "NULL";
                break;
            case PT_OBJECT:
                lpType = "OBJECT";
                break;
            default:
                DebugTrace("<Unknown Property Type>");
                break;
        }
        DebugTrace("%s\t%s\n", PropTagName(lpPropArray->aulPropTag[i]), lpType);
    }
}


/***************************************************************************

    Name      : DebugProperties

    Purpose   : Displays MAPI properties in a property list

    Parameters: lpProps -> property list
                cProps = count of properties
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
void _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject) {
    DWORD i, j;


    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s properties:\n", cProps,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < cProps ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpProps[i].ulPropTag,
          lpProps[i].ulPropTag >> 16,
          lpProps[i].ulPropTag & 0xffff);
#endif
        DebugTrace("%s\n", PropTagName(lpProps[i].ulPropTag));

        switch (lpProps[i].ulPropTag & 0xffff) {
            case PT_STRING8:
                if (lstrlen(lpProps[i].Value.lpszA) < 1024) {
                    DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.lpszA);
                } else {
                    DebugTrace("STRING8 Value is too long to display\n");
                }
                break;
            case PT_LONG:
                DebugTrace("LONG Value:%u\n", lpProps[i].Value.l);
                break;
            case PT_I2:
                DebugTrace("I2 Value:%u\n", lpProps[i].Value.i);
                break;
            case PT_ERROR:
                DebugTrace("ERROR Value: 0x%08x\n", lpProps[i].Value.err);
                break;
            case PT_BOOLEAN:
                DebugTrace("BOOLEAN Value:%s\n", lpProps[i].Value.b ?
                  "TRUE" : "FALSE");
                break;
            case PT_R4:
                DebugTrace("R4 Value\n");
                break;
            case PT_DOUBLE:
                DebugTrace("DOUBLE Value\n");
                break;
            case PT_CURRENCY:
                DebugTrace("CURRENCY Value\n");
                break;
            case PT_APPTIME:
                DebugTrace("APPTIME Value\n");
                break;
            case PT_SYSTIME:
//                DebugTime(lpProps[i].Value.ft, "SYSTIME Value:%s\n");
                break;
            case PT_UNICODE:
                DebugTrace("UNICODE Value\n");
                break;
            case PT_CLSID:
                DebugTrace("CLSID Value\n");
                break;
            case PT_BINARY:
                DebugTrace("BINARY Value %u bytes:\n", lpProps[i].Value.bin.cb);
                DebugBinary(lpProps[i].Value.bin.cb, lpProps[i].Value.bin.lpb);
                break;
            case PT_I8:
                DebugTrace("LARGE_INTEGER Value\n");
                break;
            case PT_MV_I2:
                DebugTrace("MV_I2 Value\n");
                break;
            case PT_MV_LONG:
                DebugTrace("MV_LONG Value\n");
                break;
            case PT_MV_R4:
                DebugTrace("MV_R4 Value\n");
                break;
            case PT_MV_DOUBLE:
                DebugTrace("MV_DOUBLE Value\n");
                break;
            case PT_MV_CURRENCY:
                DebugTrace("MV_CURRENCY Value\n");
                break;
            case PT_MV_APPTIME:
                DebugTrace("MV_APPTIME Value\n");
                break;
            case PT_MV_SYSTIME:
                DebugTrace("MV_SYSTIME Value\n");
                break;
            case PT_MV_BINARY:
                DebugTrace("MV_BINARY with %u values\n", lpProps[i].Value.MVbin.cValues);
                for (j = 0; j < lpProps[i].Value.MVbin.cValues; j++) {
                    DebugTrace("BINARY Value %u: %u bytes\n", j, lpProps[i].Value.MVbin.lpbin[j].cb);
                    DebugBinary(lpProps[i].Value.MVbin.lpbin[j].cb, lpProps[i].Value.MVbin.lpbin[j].lpb);
                }
                break;
            case PT_MV_STRING8:
                DebugTrace("MV_STRING8 with %u values\n", lpProps[i].Value.MVszA.cValues);
                for (j = 0; j < lpProps[i].Value.MVszA.cValues; j++) {
                    if (lstrlen(lpProps[i].Value.MVszA.lppszA[j]) < 1024) {
                        DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.MVszA.lppszA[j]);
                    } else {
                        DebugTrace("STRING8 Value is too long to display\n");
                    }
                }
                break;
            case PT_MV_UNICODE:
                DebugTrace("MV_UNICODE Value\n");
                break;
            case PT_MV_CLSID:
                DebugTrace("MV_CLSID Value\n");
                break;
            case PT_MV_I8:
                DebugTrace("MV_I8 Value\n");
                break;
            case PT_NULL:
                DebugTrace("NULL Value\n");
                break;
            case PT_OBJECT:
                DebugTrace("OBJECT Value\n");
                break;
            default:
                DebugTrace("Unknown Property Type\n");
                break;
        }
    }
}


/***************************************************************************

    Name      : DebugADRLIST

    Purpose   : Displays structure of an ADRLIST including properties

    Parameters: lpAdrList -> ADRLSIT to show
                lpszTitle = string to identify this dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle) {
     ULONG i;
     TCHAR szTitle[250];

     for (i = 0; i < lpAdrList->cEntries; i++) {

         wsprintf(szTitle, "%s : Entry %u", lpszTitle, i);
         _DebugProperties(lpAdrList->aEntries[i].rgPropVals,
           lpAdrList->aEntries[i].cValues, szTitle);
     }
}


/***************************************************************************

    Name      : DebugObjectProps

    Purpose   : Displays MAPI properties of an object

    Parameters: fMAPI = TRUE if this is a MAPI object, FALSE if WAB
                lpObject -> object to dump
                Label = string to identify this prop dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugObjectProps(BOOL fMAPI, LPMAPIPROP lpObject, LPTSTR Label) {
    DWORD cProps = 0;
    LPSPropValue lpProps = NULL;
    HRESULT hr = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;


    hr = lpObject->lpVtbl->GetProps(lpObject, NULL, 0, &cProps, &lpProps);
    switch (sc = GetScode(hr)) {
        case SUCCESS_SUCCESS:
            break;

        case MAPI_W_ERRORS_RETURNED:
            DebugTrace("GetProps -> Errors Returned\n");
            break;

        default:
            DebugTrace("GetProps -> Error 0x%x\n", sc);
            return;
    }

    _DebugProperties(lpProps, cProps, Label);

    FreeBufferAndNull(fMAPI, &lpProps);
}


/*
 *	Destroys an SRowSet structure.
 */
STDAPI_(void)
MyFreeProws(BOOL fMAPI, LPSRowSet prows)
{
	ULONG		irow;

	if (!prows)
		return;

	for (irow = 0; irow < prows->cRows; ++irow)
		FreeBufferAndNull(fMAPI, &(prows->aRow[irow].lpProps));
	FreeBufferAndNull(fMAPI, &prows);
}


/***************************************************************************

    Name      : DebugMapiTable

    Purpose   : Displays structure of a MAPITABLE including properties

    Parameters: fMAPI = TRUE if this is a MAPI object, FALSE if WAB
                lpTable -> MAPITABLE to display

    Returns   : none

    Comment   : Don't sort the columns or rows here.  This routine should
                not produce side effects in the table.

***************************************************************************/
void _DebugMapiTable(BOOL fMAPI, LPMAPITABLE lpTable) {
    UCHAR szTemp[30];   // plenty for "ROW %u"
    ULONG ulCount;
    WORD wIndex;
    LPSRowSet lpsRow = NULL;
    ULONG ulCurrentRow = (ULONG)-1;
    ULONG ulNum, ulDen, lRowsSeeked;

    DebugTrace("=======================================\n");
    DebugTrace("+  Dump of MAPITABLE at 0x%x:\n", lpTable);
    DebugTrace("---------------------------------------\n");

    // How big is the table?
    lpTable->lpVtbl->GetRowCount(lpTable, 0, &ulCount);
    DebugTrace("Table contains %u rows\n", ulCount);

    // Save the current position in the table
    lpTable->lpVtbl->QueryPosition(lpTable, &ulCurrentRow, &ulNum, &ulDen);

    // Display the properties for each row in the table
    for (wIndex = 0; wIndex < ulCount; wIndex++) {
        // Get the next row
        lpTable->lpVtbl->QueryRows(lpTable, 1, 0, &lpsRow);

        if (lpsRow) {
//            Assert(lpsRow->cRows == 1); // should have exactly one row

            wsprintf(szTemp, "ROW %u", wIndex);

            _DebugProperties(lpsRow->aRow[0].lpProps,
              lpsRow->aRow[0].cValues, szTemp);

            MyFreeProws(fMAPI, lpsRow);
        }
    }

    // Restore the current position for the table
    if (ulCurrentRow != (ULONG)-1) {
        lpTable->lpVtbl->SeekRow(lpTable, BOOKMARK_BEGINNING, ulCurrentRow,
          &lRowsSeeked);
    }
}


void _DebugNamedProps(BOOL fMAPI, LPMAPIPROP lpObject, LPTSTR Label) {
    HRESULT             hResult;
    ULONG               cPropNames      = 0;
    LPMAPINAMEID  FAR * lppPropNames    = NULL;
    LPGUID              lpPropSetGuid   = NULL;
    LPSPropTagArray     lpPropTags      = NULL;
    ULONG i;
    LPMAPINAMEID lpmnidT;


    if( FAILED(hResult = lpObject->lpVtbl->GetNamesFromIDs(lpObject,
      &lpPropTags,
      lpPropSetGuid,
      0,
      &cPropNames,
      &lppPropNames))) {
        DebugTrace("GetNamesFromIDs -> %x\n", GetScode(hResult));
    } else {

        DebugTrace("Named Property Table for %s contains %d tags\n", Label, cPropNames);
        for (i = 0; i < cPropNames; i++) {
            lpmnidT = lppPropNames[i];

            if (lpmnidT->ulKind == MNID_STRING) {
                DebugTrace("%08x: %08x-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x  %ls\n", lpPropTags->aulPropTag[i],
                  lpmnidT->lpguid->Data1,
                  lpmnidT->lpguid->Data2,
                  lpmnidT->lpguid->Data3,
                  lpmnidT->lpguid->Data4[0],
                  lpmnidT->lpguid->Data4[1],
                  lpmnidT->lpguid->Data4[2],
                  lpmnidT->lpguid->Data4[3],
                  lpmnidT->lpguid->Data4[4],
                  lpmnidT->lpguid->Data4[5],
                  lpmnidT->lpguid->Data4[6],
                  lpmnidT->lpguid->Data4[7],
                  lpmnidT->Kind.lpwstrName);
            } else {
                DebugTrace("%08x: %08x-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x  %08x\n", lpPropTags->aulPropTag[i],
                  lpmnidT->lpguid->Data1,
                  lpmnidT->lpguid->Data2,
                  lpmnidT->lpguid->Data3,
                  lpmnidT->lpguid->Data4[0],
                  lpmnidT->lpguid->Data4[1],
                  lpmnidT->lpguid->Data4[2],
                  lpmnidT->lpguid->Data4[3],
                  lpmnidT->lpguid->Data4[4],
                  lpmnidT->lpguid->Data4[5],
                  lpmnidT->lpguid->Data4[6],
                  lpmnidT->lpguid->Data4[7],
                  lpmnidT->Kind.lID);
            }
        }

        if (cPropNames != 0) {
            FreeBufferAndNull(fMAPI, &lpPropTags);
        }
        FreeBufferAndNull(fMAPI, lppPropNames);
    }
}

// If you want all debug output to go to a file, uncomment this.
// #define DEBUG_FILE  TRUE


/*
 * DebugTrace -- printf to the debugger console or debug output file
 * Takes printf style arguments.
 * Expects newline characters at the end of the string.
 */
VOID FAR CDECL _DebugTrace(LPSTR lpszFmt, ...) {
    va_list marker;
    TCHAR String[1100];
#ifdef DEBUG_FILE
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbWritten;
#endif

    va_start(marker, lpszFmt);
    wvsprintf(String, lpszFmt, marker);

#ifdef DEBUG_FILE
    if (INVALID_HANDLE_VALUE != (hFile = CreateFile("c:\\debug.out", GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, 0, NULL))) {
        SetFilePointer(hFile, 0, 0, FILE_END);
        WriteFile(hFile, String, lstrlen(String), &cbWritten, NULL);
        CloseHandle(hFile);
    }
#else
    OutputDebugString(String);
#endif
}

int EXPORTDBG __cdecl DebugTraceFn(char *pszFormat, ...) {
    va_list marker;
    TCHAR String[1100];
#ifdef DEBUG_FILE
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbWritten;
#endif

    va_start(marker, pszFormat);
    wvsprintf(String, pszFormat, marker);
#ifdef DEBUG_FILE
    if (INVALID_HANDLE_VALUE != (hFile = CreateFile("c:\\debug.out", GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, 0, NULL))) {
        SetFilePointer(hFile, 0, 0, FILE_END);
        WriteFile(hFile, String, lstrlen(String), &cbWritten, NULL);
        CloseHandle(hFile);
    }
#else
        OutputDebugString(String);
#endif
    return(0);
}


/*
 * DebugAssert
 *
 * From MAPI 1.0 SDK sample code
 */
int __cdecl DebugAssert(int fFatal, char *pszFile, int iLine,
  char *pszFormat, ...) {
    char    sz[512];
    va_list vl;
    int     id;

    lstrcpy(sz, "++++ WAB Debug Trap (");
    OutputDebugString(sz);

    va_start(vl, pszFormat);
    wvsprintf(sz, pszFormat, vl);
    va_end(vl);

    wsprintf(sz + lstrlen(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

    OutputDebugString(sz);

    // Hold down control key to prevent MessageBox
    if (GetAsyncKeyState(VK_CONTROL) >= 0) {
        id = MessageBox(NULL,
          sz,
          "Microsoft Windows Address Book Debug Trap",
          MB_ABORTRETRYIGNORE | MB_ICONHAND | MB_SYSTEMMODAL |
          (fFatal ? MB_DEFBUTTON1 : MB_DEFBUTTON3) );

        if (id == IDABORT)
            *((LPBYTE)NULL) = 0;
        else if (id == IDRETRY)
            DebugBreak();
    }

    return(0);
}


int EXPORTDBG __cdecl DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...) {
    char    sz[512];
    va_list vl;
    int     id;

    lstrcpy(sz, "++++ WAB Debug Trap (");
    OutputDebugString(sz);

    va_start(vl, pszFormat);
    wvsprintf(sz, pszFormat, vl);
    va_end(vl);

    wsprintf(sz + lstrlen(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

    OutputDebugString(sz);

    // Hold down control key to prevent MessageBox
    if (GetAsyncKeyState(VK_CONTROL) >= 0) {
        id = MessageBox(NULL,
          sz,
          "Microsoft Windows Address Book Debug Trap",
          MB_ABORTRETRYIGNORE | MB_ICONHAND | MB_SYSTEMMODAL |
          (fFatal ? MB_DEFBUTTON1 : MB_DEFBUTTON3) );

        if (id == IDABORT)
            *((LPBYTE)NULL) = 0;
        else if (id == IDRETRY)
            DebugBreak();
    }

    return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\cserve\wmcserve.c ===
/*
 * WMCSERVE.C - Main entry to WMCSERVE import/exporter
 *
 */


#include <windows.h>
#include <wab.h>
#include <wabmig.h>
#include <wabdbg.h>
#include "dbgutil.h"
#include "resource.h"

#define MAX_UI_STR              256
#define MAX_BUF_STR             4 * MAX_UI_STR

// Per-process Globals
HINSTANCE hinst;
const LPTSTR szCompuserveFilter = "*.dat";
const LPTSTR szAtCompuserve = "@compuserve.com";
#define SIZEOF_AT_COMPUSERVE 15

const LPTSTR szSMTP = "SMTP";


//  Global WAB Allocator access functions
//
typedef struct _WAB_ALLOCATORS {
    LPWABOBJECT lpWABObject;
    LPWABALLOCATEBUFFER lpAllocateBuffer;
    LPWABALLOCATEMORE lpAllocateMore;
    LPWABFREEBUFFER lpFreeBuffer;
} WAB_ALLOCATORS, *LPWAB_ALLOCATORS;

WAB_ALLOCATORS WABAllocators = {0};

enum {
    iconPR_DEF_CREATE_MAILUSER = 0,
    iconPR_DEF_CREATE_DL,
    iconMax
};
static const SizedSPropTagArray(iconMax, ptaCon)=
{
    iconMax,
    {
        PR_DEF_CREATE_MAILUSER,
        PR_DEF_CREATE_DL,
    }
};

typedef enum {
    CONFIRM_YES,
    CONFIRM_NO,
    CONFIRM_YES_TO_ALL,
    CONFIRM_NO_TO_ALL,
    CONFIRM_ERROR
} CONFIRM_RESULT, *LPCONFIRM_RESULT;

typedef struct _ReplaceInfo {
    LPTSTR lpszDisplayName;         // Conflicting display name
    CONFIRM_RESULT ConfirmResult;   // Results from dialog
    LPWAB_IMPORT_OPTIONS lpImportOptions;
} REPLACE_INFO, * LPREPLACE_INFO;

/***************************************************************************

    Name      : SetGlobalBufferFunctions

    Purpose   : Set the global buffer functions based on methods from
                the WAB object.

    Parameters: lpWABObject = the open wab object

    Returns   : none

    Comment   :

***************************************************************************/
void SetGlobalBufferFunctions(LPWABOBJECT lpWABObject) {
    if (lpWABObject && ! WABAllocators.lpWABObject) {
        WABAllocators.lpAllocateBuffer = lpWABObject->lpVtbl->AllocateBuffer;
        WABAllocators.lpAllocateMore = lpWABObject->lpVtbl->AllocateMore;
        WABAllocators.lpFreeBuffer = lpWABObject->lpVtbl->FreeBuffer;
        WABAllocators.lpWABObject = lpWABObject;
    }
}


/***************************************************************************

    Name      : WABAllocateBuffer

    Purpose   : Use the WAB Allocator

    Parameters: cbSize = size to allocate
                lppBuffer = returned buffer

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABAllocateBuffer(ULONG cbSize, LPVOID FAR * lppBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpAllocateBuffer) {
        return(WABAllocators.lpAllocateBuffer(WABAllocators.lpWABObject, cbSize, lppBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


/***************************************************************************

    Name      : WABAllocateMore

    Purpose   : Use the WAB Allocator

    Parameters: cbSize = size to allocate
                lpObject = existing allocation
                lppBuffer = returned buffer

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABAllocateMore(ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpAllocateMore) {
        return(WABAllocators.lpAllocateMore(WABAllocators.lpWABObject, cbSize, lpObject, lppBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


/***************************************************************************

    Name      : WABFreeBuffer

    Purpose   : Use the WAB Allocator

    Parameters: lpBuffer = buffer to free

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABFreeBuffer(LPVOID lpBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpFreeBuffer) {
        return(WABAllocators.lpFreeBuffer(WABAllocators.lpWABObject, lpBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


//$$//////////////////////////////////////////////////////////////////////
//
//  LoadAllocString - Loads a string resource and allocates enough
//                    memory to hold it.
//
//  StringID - String identifier to load
//
//  returns the LocalAlloc'd, null terminated string.  Caller is responsible
//  for LocalFree'ing this buffer.  If the string can't be loaded or memory
//  can't be allocated, returns NULL.
//
//////////////////////////////////////////////////////////////////////////
LPTSTR LoadAllocString(int StringID) {
    ULONG ulSize = 0;
    LPTSTR lpBuffer = NULL;
    TCHAR szBuffer[261];    // Big enough?  Strings better be smaller than 260!

    ulSize = LoadString(hinst, StringID, szBuffer, sizeof(szBuffer));

    if (ulSize && (lpBuffer = LocalAlloc(LPTR, ulSize + 1))) {
        lstrcpy(lpBuffer, szBuffer);
    }

    return(lpBuffer);
}


//$$//////////////////////////////////////////////////////////////////////
//
//  FormatAllocFilter - Loads a file filter name string resource and
//                      formats it with the file extension filter
//
//  StringID - String identifier to load
//  szFilter - file name filter, ie, "*.vcf"
//
//  returns the LocalAlloc'd, null terminated string.  Caller is responsible
//  for LocalFree'ing this buffer.  If the string can't be loaded or memory
//  can't be allocated, returns NULL.
//
//////////////////////////////////////////////////////////////////////////
LPTSTR FormatAllocFilter(int StringID, const LPTSTR lpFilter) {
    LPTSTR lpFileType;
    LPTSTR lpTemp;
    LPTSTR lpBuffer = NULL;
    ULONG cbFileType, cbFilter;

    cbFilter = lstrlen(lpFilter);
    if (lpFileType = LoadAllocString(StringID)) {
        if (lpBuffer = LocalAlloc(LPTR, (cbFileType = lstrlen(lpFileType)) + 1 + lstrlen(lpFilter) + 2)) {
            lpTemp = lpBuffer;
            lstrcpy(lpTemp, lpFileType);
            lpTemp += cbFileType;
            lpTemp++;   // leave null there
            lstrcpy(lpTemp, lpFilter);
            lpTemp += cbFilter;
            lpTemp++;   // leave null there
            *lpTemp = '\0';
        }

        LocalFree(lpFileType);
    }

    return(lpBuffer);
}


//$$/////////////////////////////////////////////////////////////////////////
//
// ShowMessageBoxParam - Generic MessageBox displayer .. saves space all over
//
//  hWndParent  - Handle of Message Box Parent
//  MsgID       - resource id of message string
//  ulFlags     - MessageBox flags
//  ...         - format parameters
//
///////////////////////////////////////////////////////////////////////////
int __cdecl ShowMessageBoxParam(HWND hWndParent, int MsgId, int ulFlags, ...)
{
    TCHAR szBuf[MAX_BUF_STR] = "";
    TCHAR szCaption[MAX_PATH] = "";
    LPTSTR lpszBuffer = NULL;
    int iRet = 0;
    va_list	vl;

    va_start(vl, ulFlags);

    LoadString(hinst, MsgId, szBuf, sizeof(szBuf));
    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
      szBuf,
      0,0, //ignored
      (LPTSTR)&lpszBuffer,
      MAX_BUF_STR, //MAX_UI_STR
      &vl)) {
        TCHAR szCaption[MAX_PATH];
        GetWindowText(hWndParent, szCaption, sizeof(szCaption));
        if(!lstrlen(szCaption)) // if no caption get the parents caption - this is necessary for property sheets
        {
            GetWindowText(GetParent(hWndParent), szCaption, sizeof(szCaption));
            if(!lstrlen(szCaption)) //if still not caption, get the generic title
                LoadString(hinst, IDS_CSERVE_IMPORT_TITLE, szCaption, sizeof(szCaption));
        }
        iRet = MessageBox(hWndParent, lpszBuffer, szCaption, ulFlags);
        if(lpszBuffer) {
            LocalFree(lpszBuffer);
        }
    }
    va_end(vl);
    return(iRet);
}


INT_PTR CALLBACK ReplaceDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    LPREPLACE_INFO lpRI = (LPREPLACE_INFO)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (message) {
        case WM_INITDIALOG:
            {
                TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
                LPTSTR lpszMessage;

                SetWindowLongPtr(hwnd, DWLP_USER, lParam);  //Save this for future reference
                lpRI = (LPREPLACE_INFO)lParam;

                if (LoadString(hinst, IDS_REPLACE_MESSAGE, szBuffer, sizeof(szBuffer))) {

                    if (lpszMessage = LocalAlloc(LMEM_FIXED, lstrlen(szBuffer) + 1 + lstrlen(lpRI->lpszDisplayName))) {

                        wsprintf(lpszMessage, szBuffer, lpRI->lpszDisplayName);

                        DebugTrace("Status Message: %s\n", lpszMessage);
                        if (! SetDlgItemText(hwnd, IDC_Replace_Message, lpszMessage)) {
                            DebugTrace("SetDlgItemText -> %u\n", GetLastError());
                        }
                        LocalFree(lpszMessage);
                    }
                }
                return(TRUE);
            }

        case WM_COMMAND :
            switch (wParam) {
                case IDCLOSE:
                case IDNO:
                case IDCANCEL:
                    lpRI->ConfirmResult = CONFIRM_NO;
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDOK:
                case IDYES:
                    // Set the state of the parameter
                    lpRI->ConfirmResult = CONFIRM_YES;
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);


                case IDC_NoToAll:
                    lpRI->ConfirmResult = CONFIRM_NO_TO_ALL;
                    lpRI->lpImportOptions->ReplaceOption = WAB_REPLACE_NEVER;
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);

                case IDC_YesToAll:
                    lpRI->ConfirmResult = CONFIRM_YES_TO_ALL;
                    lpRI->lpImportOptions->ReplaceOption = WAB_REPLACE_ALWAYS;
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);

                    case IDM_EXIT:
                    SendMessage(hwnd, WM_DESTROY, 0, 0L);
                    return(0);

#ifdef OLD_STUFF
                    case IDHELP:
                    MessageBox(hwnd, "Help not yet implemented!",
                    szAppName, MB_ICONEXCLAMATION | MB_OK);
                    return(0);
#endif // OLD_STUFF
                }
            break ;

        case IDCANCEL:
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case WM_CLOSE:
            EndDialog(hwnd, FALSE);
            return(0);

        default:
            return(FALSE);
    }

    return(TRUE);
}


/***************************************************************************

    Name      : MigrateContact

    Purpose   : Migrates the user entry from CSERVE address book to the WAB

    Parameters: hwnd = main dialog window
                lpContainerWAB -> WAB PAB container
                lpCreateEIDsWAB -> SPropValue of default object creation EIDs
                lpName = display name
                lpAddress = email address
                lpOptions -> import options

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT MigrateContact(HWND hwnd,
  LPABCONT lpContainerWAB,
  LPSPropValue lpCreateEIDsWAB,
  LPTSTR lpName,
  LPTSTR lpAddress,
  LPWAB_IMPORT_OPTIONS lpOptions) {

    HRESULT hResult = hrSuccess;
    BOOL fDistList = FALSE;
    BOOL fDuplicate = FALSE;
    LPMAPIPROP lpMailUserWAB = NULL;
    SPropValue rgProps[3];
    LPSRowSet lpRow = NULL;
    LPMAPIPROP lpEntryWAB = NULL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    REPLACE_INFO RI;
    static TCHAR szBufferDLMessage[MAX_RESOURCE_STRING + 1] = "";
    LONG lListIndex = -1;
    ULONG iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
    LPTSTR lpTempAddress;
    LPTSTR lpAddressOrg = lpAddress;



    if (lpOptions->ReplaceOption == WAB_REPLACE_ALWAYS) {
        ulCreateFlags |= CREATE_REPLACE;
    }

    // Set up some object type specific variables
    iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
    fDistList = FALSE;


retry:
    if (HR_FAILED(hResult = lpContainerWAB->lpVtbl->CreateEntry(lpContainerWAB,
      lpCreateEIDsWAB[iCreateTemplate].Value.bin.cb,
      (LPENTRYID)lpCreateEIDsWAB[iCreateTemplate].Value.bin.lpb,
      ulCreateFlags,
      &lpMailUserWAB))) {
        DebugTrace("CreateEntry(WAB MailUser) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Munge the address to SMTP format
    // nuke the "INTERNET:"
    lpTempAddress = lpAddress;
    while (*lpTempAddress) {
        if (*lpTempAddress == ':') {
            lpAddress = lpTempAddress + 1;
            break;
        }
        lpTempAddress++;
    }
    if (lpAddress == lpAddressOrg) {
        // Must be a compuserve address, fix it
        lpTempAddress = lpAddress;
        while (*lpTempAddress) {
            if (*lpTempAddress == ',') {    // compuserve uses comma internally
                *lpTempAddress = '.';       // map to a period
            }
            lpTempAddress++;
        }

        lstrcat(lpAddress, szAtCompuserve);
    }


    rgProps[0].ulPropTag = PR_DISPLAY_NAME;
    rgProps[0].Value.LPSZ = lpName;

    rgProps[1].ulPropTag = PR_EMAIL_ADDRESS;
    rgProps[1].Value.LPSZ = lpAddress;

    rgProps[2].ulPropTag = PR_ADDRTYPE;
    rgProps[2].Value.LPSZ = szSMTP;


    // Set the properties on the WAB entry
    if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
      3,                        // cValues
      rgProps,                  // property array
      NULL))) {                 // problems array
        DebugTrace("MigrateEntry:SetProps(WAB) -> %x\n", GetScode(hResult));
        goto exit;
    }


    // Save the new wab mailuser or distlist
    if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
      KEEP_OPEN_READONLY | FORCE_SAVE))) {
        if (GetScode(hResult) == MAPI_E_COLLISION) {
            // Find the display name


            // Do we need to prompt?
            if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
                // Prompt user with dialog.  If they say YES, we should
                // recurse with the FORCE flag set.

                RI.lpszDisplayName = lpName;
                RI.ConfirmResult = CONFIRM_ERROR;
                RI.lpImportOptions = lpOptions;

                DialogBoxParam(hinst,
                  MAKEINTRESOURCE(IDD_Replace),
                  hwnd,
                  ReplaceDialogProc,
                  (LPARAM)&RI);

                switch (RI.ConfirmResult) {
                    case CONFIRM_YES:
                    case CONFIRM_YES_TO_ALL:
                        // YES
                        // Do it again!

                        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                        ulCreateFlags |= CREATE_REPLACE;
                        goto retry;
                        break;

                    default:
                        // NO
                        break;
                }
            }
            hResult = hrSuccess;

        } else {
            DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
        }
    }
exit:
    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
    }

    if (! HR_FAILED(hResult)) {
        hResult = hrSuccess;
    }

    return(hResult);
}


/*
 -  CServeImport
 -
 *  Purpose:
 *      Import a compuserve address book to the WAB
 *
 *  Arguments:
 *      hwnd            window handle
 *      lpAdrBook       Returned IAdrBook object
 *      lpWABOBJECT     Returned WABObject
 *      lpProgressCB    Progress callback
 *      lpOptions       Import options structure
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP CServeImport(HWND hwnd, LPADRBOOK lpAdrBook, LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPWAB_IMPORT_OPTIONS lpOptions) {
    SCODE sc = SUCCESS_SUCCESS;
    HRESULT hResult = hrSuccess;
    HANDLE hFile = NULL;
    OPENFILENAME ofn;
    LPTSTR lpFilter = FormatAllocFilter(IDS_CSERVE_FILE_SPEC, szCompuserveFilter);
    TCHAR szFileName[MAX_PATH + 1] = "addrbook.dat";
    BOOL fDone = FALSE;
    WORD wEntries = 0;
    DWORD i, j;
    ULONG ulBytesRead;
    BOOL fDL;
    TCHAR szPad[2];
    ULONG cbWABEID;
    LPENTRYID lpWABEID = NULL;
    LPABCONT lpContainerWAB = NULL;
    LPSPropValue lpCreateEIDsWAB = NULL;
    ULONG ulObjType;
    ULONG cProps;
    WAB_PROGRESS Progress;


    SetGlobalBufferFunctions(lpWABObject);


    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = hinst;
    ofn.lpstrFilter = lpFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = sizeof(szFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = LoadAllocString(IDS_CSERVE_IMPORT_TITLE);
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    // Find and Open the file
    if (GetOpenFileName(&ofn)) {
        if (INVALID_HANDLE_VALUE == (hFile = CreateFile(szFileName,
          GENERIC_READ,	
          FILE_SHARE_READ,
          NULL,
          OPEN_EXISTING,
          FILE_FLAG_SEQUENTIAL_SCAN,	
          NULL))) {
            // couldn't open file.
            ShowMessageBoxParam(hwnd, IDE_CSERVE_IMPORT_FILE_ERROR, MB_ICONEXCLAMATION, szFileName);
            hResult = ResultFromScode(MAPI_E_NOT_FOUND);
            goto exit;
        }


        //
        // Open the WAB's PAB container
        //
        if (hResult = lpAdrBook->lpVtbl->GetPAB(lpAdrBook,
          &cbWABEID,
          &lpWABEID)) {
            DebugTrace("WAB GetPAB -> %x\n", GetScode(hResult));
            goto exit;
        } else {
            if (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
              cbWABEID,     // size of EntryID to open
              lpWABEID,     // EntryID to open
              NULL,         // interface
              0,            // flags
              &ulObjType,
              (LPUNKNOWN *)&lpContainerWAB)) {
                DebugTrace("WAB OpenEntry(PAB) -> %x\n", GetScode(hResult));
                goto exit;
            }
        }

        // Get the WAB's creation entryids
        if ((hResult = lpContainerWAB->lpVtbl->GetProps(lpContainerWAB,
          (LPSPropTagArray)&ptaCon,
          0,
          &cProps,
          &lpCreateEIDsWAB))) {
            DebugTrace("Can't get container properties for WAB\n");
            // Bad stuff here!
            goto exit;
        }

        // Validate the properites
        if (lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
          lpCreateEIDsWAB[iconPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL) {
            DebugTrace("WAB: Container property errors\n");
            goto exit;
        }


        if (! ReadFile(hFile,
          szPad,
          sizeof(BYTE),
          &ulBytesRead,
          NULL)) {
            hResult = ResultFromScode(MAPI_E_CORRUPT_DATA);
            goto exit;
        } // toss this byte, don't know what it does

        // How many entries?
        if (! ReadFile(hFile,
          &wEntries,
          sizeof(wEntries),
          &ulBytesRead,
          NULL)) {
            hResult = ResultFromScode(MAPI_E_CORRUPT_DATA);
            goto exit;
        }

        Progress.denominator = (ULONG)wEntries;
        Progress.numerator = 0;
        Progress.lpText = NULL;

        for (i = 0; i < (DWORD)wEntries; i++) {
            WORD wEntry;
            BYTE bNameSize, bAddressSize;
            TCHAR szName[256];          // max is 2^8
            TCHAR szAddress[256 + SIZEOF_AT_COMPUSERVE];       // max is 2^8

            // Update progress bar
            Progress.numerator = i;
            lpProgressCB(hwnd, &Progress);

            // Read the entry number (should be == i + 1)
            if (! ReadFile(hFile,
              &wEntry,
              sizeof(wEntry),
              &ulBytesRead,
              NULL)) {
                hResult = ResultFromScode(MAPI_E_CORRUPT_DATA);
                goto exit;
            }

            if ((DWORD)(wEntry & 0x7F) != i + 1) {
                hResult = ResultFromScode(MAPI_E_CORRUPT_DATA);
                goto exit;
            }

            // Is this a DL?
            fDL = (wEntry & 0x80);

            // Read size of Name
            if (! ReadFile(hFile,
              &bNameSize,
              sizeof(bNameSize),
              &ulBytesRead,
              NULL)) {
                hResult = ResultFromScode(MAPI_E_CORRUPT_DATA);
                goto exit;
            }

            // Read name
            if (! ReadFile(hFile,
              &szName,
              (DWORD)bNameSize,
              &ulBytesRead,
              NULL)) {
                hResult = ResultFromScode(MAPI_E_CORRUPT_DATA);
                goto exit;
            }
            szName[bNameSize] = '\0';   // null terminate it.
            DebugTrace("%s:", szName);

            if (fDL) {
                BYTE bDLEntries;
                WORD wDLEntry;

                // Read the number of entries in this DL
                if (! ReadFile(hFile,
                  &bDLEntries,
                  sizeof(bDLEntries),
                  &ulBytesRead,
                  NULL)) {
                    hResult = ResultFromScode(MAPI_E_CORRUPT_DATA);
                    goto exit;
                }

                // Read in each DL entry identifier
                for (j = 0; j < (DWORD)bDLEntries; j++) {
                    if (! ReadFile(hFile,
                      &wDLEntry,
                      sizeof(wDLEntry),
                      &ulBytesRead,
                      NULL)) {
                        hResult = ResultFromScode(MAPI_E_CORRUPT_DATA);
                        goto exit;
                    }

                    DebugTrace(" %u", (DWORD)wDLEntry);
// BUGBUG: Need to implement DL entries
                }
                DebugTrace("\n");
            } else {
                // Read size of address
                if (! ReadFile(hFile,
                  &bAddressSize,
                  sizeof(bAddressSize),
                  &ulBytesRead,
                  NULL)) {
                    hResult = ResultFromScode(MAPI_E_CORRUPT_DATA);
                    goto exit;
                }

                // Read address
                if (! ReadFile(hFile,
                  &szAddress,
                  (DWORD)bAddressSize,
                  &ulBytesRead,
                  NULL)) {
                    hResult = ResultFromScode(MAPI_E_CORRUPT_DATA);
                    goto exit;
                }
                szAddress[bAddressSize] = '\0';   // null terminate it.
                DebugTrace("%s\n", szAddress);


                if (hResult = MigrateContact(hwnd,
                  lpContainerWAB,
                  lpCreateEIDsWAB,
                  szName,
                  szAddress,
                  lpOptions)) {
                    goto exit;
                }
            }

            // Read in terminator byte
            if (! ReadFile(hFile,
              szPad,
              sizeof(BYTE),
              &ulBytesRead,
              NULL)) {
                hResult = ResultFromScode(MAPI_E_CORRUPT_DATA);
                goto exit;
            } // toss this byte, don't know what it does
        }
    } else {
        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
    }


exit:
    // Free up memory and objects
    if (lpWABEID) {
        WABFreeBuffer(lpWABEID);
    }

    if (lpCreateEIDsWAB) {
        WABFreeBuffer(lpCreateEIDsWAB);
    }

    if (lpContainerWAB) {
        lpContainerWAB->lpVtbl->Release(lpContainerWAB);
    }


    if (hFile) {
        CloseHandle(hFile);
    }

    return(hResult);
}


/*
 -  CServeExport
 -
 *  Purpose:
 *      Export to a compuserve address book from the WAB
 *
 *  Arguments:
 *      hwnd            window handle
 *      lpAdrBook       Returned IAdrBook object
 *      lpWABOBJECT     Returned WABObject
 *      lpProgressCB    Progress callback
 *      lpOptions       Export options structure
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP CServeExport(HWND hwnd, LPADRBOOK lpAdrBook, LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPWAB_IMPORT_OPTIONS lpOptions) {
    SCODE sc = SUCCESS_SUCCESS;
    HRESULT hResult = hrSuccess;

    SetGlobalBufferFunctions(lpWABObject);

    return(hResult);
}


/*
 *	DLL entry point for Win32
 */

BOOL WINAPI _DllMainCRTStartup(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpvReserved) {
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            hinst = hinstDll;   // set global hinst
            break;

    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\cserve\makefile.inc ===
$O\globals.obj : globals.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\globals.c
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP

$O\wabguid.obj : wabguid.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\wabguid.c
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wabmig\dbgutil.h ===
/***********************************************************************
 *
 * DBGUTIL.H
 *
 * Debug Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/

#ifdef DEBUG
VOID _DebugObjectProps(BOOL fMAPI, LPMAPIPROP lpObject, LPTSTR Label);
VOID _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject);
void _DebugMapiTable(BOOL fMAPI, LPMAPITABLE lpTable);
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle);
void _DebugNamedProps(BOOL fMAPI, LPMAPIPROP lpObject, LPTSTR Label);
VOID DebugBinary(UINT cb, LPBYTE lpb);

#define WABDebugObjectProps(lpObject, Label) _DebugObjectProps(FALSE, lpObject, Label)
#define WABDebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define WABDebugMapiTable(lpTable) _DebugMapiTable(FALSE, lpTable)
#define WABDebugADRLIST(lpAdrList, lpszTitle) _DebugADRLIST(lpAdrList, lpszTitle)
#define WABDebugNamedProps(lpObject, Label) _DebugNamedProps(FALSE, lpObject, Label)

#define MAPIDebugObjectProps(lpObject, Label) _DebugObjectProps(TRUE, lpObject, Label)
#define MAPIDebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define MAPIDebugMapiTable(lpTable) _DebugMapiTable(TRUE, lpTable)
#define MAPIDebugADRLIST(lpAdrList, lpszTitle) _DebugADRLIST(lpAdrList, lpszTitle)
#define MAPIDebugNamedProps(lpObject, Label) _DebugNamedProps(TRUE, lpObject, Label)
#define DebugBinaryData(cb, lpb) DebugBinary(cb, lpb)

// VOID FAR CDECL DebugTrace(LPSTR lpszFmt, ...);

#else

#define WABDebugObjectProps(lpObject, Label)
#define WABDebugProperties(lpProps, cProps, pszObject)
#define WABDebugMapiTable(lpTable)
#define WABDebugADRLIST(lpAdrList, lpszTitle)
#define WABDebugNamedProps(lpObject, Label)

#define MAPIDebugObjectProps(lpObject, Label)
#define MAPIDebugProperties(lpProps, cProps, pszObject)
#define MAPIDebugMapiTable(lpTable)
#define MAPIDebugADRLIST(lpAdrList, lpszTitle)
#define MAPIDebugNamedProps(lpObject, Label)
#define DebugBinaryData(cb, lpb)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wabmig\_comctl.h ===
/*

	_comctl.h

*/

// This commctrl flag enables us to be compiled with the new commctrl headers
// yet work with the old commctrl dlls
#ifdef _WIN32_IE
#undef _WIN32_IE
#endif
#define _WIN32_IE 0x0300
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wabmig\import.c ===
/*
 *  IMPORT.C
 *
 *  Migrate PAB to WAB
 *
 *  Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#include "_wabmig.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"


BOOL HandleImportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName, LPTSTR lpEmailAddress);


/***************************************************************************

    Name      : ImportFinish

    Purpose   : Clean up after the migration process

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Re-enable the Import button on the UI.

***************************************************************************/
void ImportFinish(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    TCHAR szBufferTitle[MAX_RESOURCE_STRING + 1];

    DebugTrace(">>> Import Finished\n");

    if (! fError) {     // Leave error state displayed
        if (LoadString(hInst, IDS_STATE_IMPORT_COMPLETE, szBuffer, sizeof(szBuffer))) {
            DebugTrace("Status Message: %s\n", szBuffer);
            SetDlgItemText(hwnd, IDC_Message, szBuffer);

            if (! LoadString(hInst, IDS_APP_TITLE, szBufferTitle, sizeof(szBufferTitle))) {
                lstrcpy(szBufferTitle, "");
            }

            // Display a dialog telling user it's over
            MessageBox(hwnd, szBuffer,
              szBufferTitle, MB_ICONINFORMATION | MB_OK);
        }
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);
    }
    fError = FALSE;

    fMigrating = FALSE;

    // Re-enable the Import button here.
    EnableWindow(GetDlgItem(hwnd, IDC_Import), TRUE);
    // Change the Cancel button to Close
    if (LoadString(hInst, IDS_BUTTON_CLOSE, szBuffer, sizeof(szBuffer))) {
        SetDlgItemText(hwnd, IDCANCEL, szBuffer);
    }
}


/***************************************************************************

    Name      : ImportError

    Purpose   : Report fatal error and cleanup.

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Report error

***************************************************************************/
void ImportError(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace("Import ERROR\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_IMPORT_ERROR);

    ImportFinish(hwnd);
}


/***************************************************************************

    Name      : ImportCancel

    Purpose   : Report cancel error and cleanup.

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Report cancel error

***************************************************************************/
void ImportCancel(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace("Import Cancelled\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_IMPORT_CANCEL);

    ImportFinish(hwnd);
}

/***************************************************************************

    Name      : ImportFileBusyError

    Purpose   : Report File to Open is Busy

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Report File is Busy

***************************************************************************/
void ImportFileBusyError(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace("Import Cancelled\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_IMPORT_ERROR_FILEOPEN);

    ImportFinish(hwnd);
}



INT_PTR CALLBACK ImportDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    static HWND hwndLB = NULL;
    HRESULT hResult;

    Assert(! fExport);

    switch (message) {
        case WM_INITDIALOG:
            {
                SetWindowLongPtr(hwnd, DWLP_USER, lParam);

                InitCommonControls();
                SetDialogMessage(hwnd, IDS_STATE_IMPORT_IDLE);

                // Fill in the Target List box
                hwndLB = GetDlgItem(hwnd, IDC_Target);
                PopulateTargetList(hwndLB, NULL);

                ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);

                return(TRUE);
            }

        case WM_COMMAND :
            switch (LOWORD(wParam)) {
                case IDCANCEL:
                case IDCLOSE:
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDM_EXIT :
                    SendMessage(hwnd, WM_DESTROY, 0, 0L);
                    return(0);

                case IDC_Import:
                    {
                        LPWAB_IMPORT lpfnWABImport = NULL;
                        HINSTANCE hinstImportDll = NULL;
                        DWORD ec;
                        TCHAR szBuffer[MAX_RESOURCE_STRING + 1];

                        if (fMigrating) {
                            return(0);          // ignore if we're already migrating
                        }
                        fMigrating = TRUE;      // lock out

                        // reset options
                        ImportOptions.ReplaceOption = WAB_REPLACE_PROMPT;
                        ImportOptions.fNoErrors = FALSE;

                        // Gray out the button here.
                        EnableWindow(GetDlgItem(hwnd, IDC_Import), FALSE);
                        // Change the Close button to Cancel
                        if (LoadString(hInst, IDS_BUTTON_CANCEL, szBuffer, sizeof(szBuffer))) {
                            SetDlgItemText(hwnd, IDCANCEL, szBuffer);
                        }

                        if (lpImportDll && lpImportFn) {
                            if (! (hinstImportDll = LoadLibrary(lpImportDll))) {
                                DebugTrace("Couldn't load import dll [%s] -> %u\n", lpImportDll, GetLastError());
                                switch (GetLastError()) {
                                    case ERROR_FILE_NOT_FOUND:
                                        if (HandleImportError(hwnd,
                                          IDS_ERROR_DLL_NOT_FOUND,
                                          0,
                                          lpImportDll,
                                          NULL)) {
                                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                            ImportCancel(hwnd);
                                        } else {
                                            ImportError(hwnd);
                                        }
                                        break;

                                    default:
                                        if (HandleImportError(hwnd,
                                          IDS_ERROR_DLL_INVALID,
                                          0,
                                          lpImportDll,
                                          NULL)) {
                                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                            ImportCancel(hwnd);
                                        } else {
                                            ImportError(hwnd);
                                        }
                                        break;
                                }
                            } else {
                                if (! (lpfnWABImport = (LPWAB_IMPORT)GetProcAddress(hinstImportDll,
                                  lpImportFn))) {
                                    DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", lpImportFn, lpImportDll, GetLastError());
                                    switch (GetLastError()) {
                                        default:
                                            if (HandleImportError(hwnd,
                                              IDS_ERROR_DLL_INVALID,
                                              0,
                                              lpImportDll,
                                              NULL)) {
                                                hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                                ImportCancel(hwnd);
                                            } else {
                                                ImportError(hwnd);
                                            }
                                            break;
                                    }
                                } else {
                                    // Do it!
                                    __try
                                    {
                                        HRESULT hResult;
                                        BOOL fFinished = FALSE;
                                        WAB_PARAM wp = {0};
                                        LPWAB_PARAM lpwp = NULL;

                                        {
                                            LPWABMIGDLGPARAM lpwmdp = (LPWABMIGDLGPARAM) GetWindowLongPtr(hwnd, DWLP_USER);
                                            LPTSTR lpszFileName = lpwmdp->szFileName;
                                            wp.cbSize = sizeof(WAB_PARAM);
                                            wp.hwnd = hwnd;
                                            if(lstrlen(lpszFileName))
                                            {
                                                // we have a file name - use it to open the WAB
                                                wp.szFileName = lpszFileName;
                                                wp.ulFlags = 0;
                                            }
                                            else
                                            {
                                                wp.ulFlags = WAB_ENABLE_PROFILES;
                                            }
                                            lpwp = &wp;
                                        }

                                        hResult = lpfnWABOpen(&lpAdrBookWAB, &lpWABObject, lpwp, 0);
                                        if (SUCCEEDED(hResult))
                                        {
                                            if (hResult = lpfnWABImport(hwnd,
                                              lpAdrBookWAB,
                                              lpWABObject,
                                              (LPWAB_PROGRESS_CALLBACK)&ProgressCallback,
                                              &ImportOptions))
                                            {                                            
                                                switch (GetScode(hResult)) 
                                                {
                                                    case MAPI_E_USER_CANCEL:
                                                        ImportCancel(hwnd);
                                                        break;

                                                    case MAPI_E_BUSY:
                                                        ImportFileBusyError(hwnd);
                                                        break;
                                                    default:
                                                        ImportError(hwnd);
                                                        DebugTrace("Importer DLL returned %x\n", GetScode(hResult));
                                                        break;
                                                }

                                                fFinished = TRUE;
                                            }

                                            lpAdrBookWAB->lpVtbl->Release(lpAdrBookWAB);
                                            lpAdrBookWAB = NULL;
                                            lpWABObject->lpVtbl->Release(lpWABObject);
                                            lpWABObject = NULL;
                                            if (! fFinished)
                                            {
                                                // Make progress bar full.
                                                SendMessage(GetDlgItem(hwnd, IDC_Progress), PBM_SETRANGE, 0, MAKELPARAM(0, 100));
                                                SendMessage(GetDlgItem(hwnd, IDC_Progress), PBM_SETPOS, (WPARAM)100, 0);
                                                ImportFinish(hwnd);
                                            }
                                        }
                                        else
                                        {
                                            // Report fatal error
                                            TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
                                            TCHAR szBufferTitle[MAX_RESOURCE_STRING + 1];

                                            if (LoadString(hInst, IDS_STATE_IMPORT_ERROR, szBuffer, sizeof(szBuffer)))
                                            {
                                                SetDlgItemText(hwnd, IDC_Message, szBuffer);
                                                if (! LoadString(hInst, IDS_APP_TITLE, szBufferTitle, sizeof(szBufferTitle)))
                                                {
                                                    lstrcpy(szBufferTitle, "");
                                                }

                                                // Display a dialog telling user it's over
                                                MessageBox(hwnd, szBuffer,
                                                  szBufferTitle, MB_ICONINFORMATION | MB_OK);
                                            }

                                            fError = TRUE;
                                            ImportFinish(hwnd);
                                        }
                                    }
                                    __except (ec = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
                                    {
                                        DebugTrace("Exception 0x%08x in %s\n", ec, lpImportDll);
                                        if (HandleImportError(hwnd,
                                          IDS_ERROR_DLL_EXCEPTION,
                                          0,
                                          lpImportDll,
                                          NULL))
                                        {
                                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                            ImportCancel(hwnd);
                                        }
                                        else
                                        {
                                            ImportError(hwnd);
                                        }
                                    }
                                }
                            }
                        } else {
                            ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_SHOW);
                            PostMessage(hwnd, WM_COMMAND, ID_STATE_IMPORT_MU, 0);
                        }
                        FreeLibrary(hinstImportDll);                    
                    }
                    return(0);

                case IDC_Target:
                    switch (HIWORD(wParam)) {   // look for selection change
                        case LBN_SELCHANGE:
                            {
                                ULONG ulSelIndex, ulTableIndex;
                                TCHAR szCurSel[256];

                                // Enable the Import Button if it is disabled. The 'Import' Button is disabled initially.
                                HWND hButton = GetDlgItem(hwnd, IDC_Import);
                                if(hButton)
                                {
                                    if(!IsWindowEnabled(hButton))
                                        EnableWindow(hButton, TRUE);
                                }

                                //
                                // Get the text of the selected item in the listbox...
                                //
                                ulSelIndex = (ULONG) SendMessage((HWND)lParam, LB_GETCURSEL, 0, 0);
                                ulTableIndex = (ULONG) SendMessage((HWND)lParam, LB_GETITEMDATA, (WPARAM)ulSelIndex, 0);

                                SendMessage((HWND)lParam,
                                  LB_GETTEXT,
                                  (WPARAM)ulSelIndex,
                                  (LPARAM)szCurSel);
                                DebugTrace("Current selection is [%s]\n", szCurSel);

                                lpImportDll = rgTargetInfo[ulTableIndex].lpDll;
                                lpImportDesc = rgTargetInfo[ulTableIndex].lpDescription;
                                lpImportFn = rgTargetInfo[ulTableIndex].lpEntry;
                                lpImportName = rgTargetInfo[ulTableIndex].lpRegName;

                                SendMessage(hwnd, WM_SETREDRAW, TRUE, 0L);
                            }
                            break;

                        case LBN_DBLCLK:
                            PostMessage(hwnd, WM_COMMAND, (WPARAM)IDC_Import, 0);
                            break;
                    }
                    break;
                }
            break;

        case WM_CLOSE:
#ifdef OLD_STUFF
            if (fMigrating) {
                SendMessage(hwnd, WM_COMMAND, ID_STATE_IMPORT_FINISH, 0);
            }
#endif // OLD_STUFF
            EndDialog(hwnd, FALSE);
            return(0);

        case WM_DESTROY:
            FreeLBItemData(hwndLB);
            return(DefWindowProc(hwnd, message, wParam, lParam));

        default:
            return(FALSE);
    }

    return(TRUE);
}


/***************************************************************************

    Name      : HandleImportError

    Purpose   : Decides if a dialog needs to be displayed to
                indicate the failure and does so.

    Parameters: hwnd = main dialog window
                ids = String ID (optional: calculated from hResult if 0)
                hResult = Result of action
                lpDisplayName = display name of object that failed
                lpEmailAddress = email address of object that failed or NULL

    Returns   : TRUE if user requests ABORT.

    Comment   : Abort is not yet implemented in the dialog, but if you
                ever want to, just make this routine return TRUE;

***************************************************************************/
BOOL HandleImportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName, LPTSTR lpEmailAddress) {
    BOOL fAbort = FALSE;
    ERROR_INFO EI;

    if ((ids || hResult) && ! ImportOptions.fNoErrors) {
        if (ids == 0) {
            switch (GetScode(hResult)) {
                case WAB_W_BAD_EMAIL:
                    ids = lpEmailAddress ? IDS_ERROR_EMAIL_ADDRESS_2 : IDS_ERROR_EMAIL_ADDRESS_1;
                    break;

                case MAPI_E_NO_SUPPORT:
                    // Propbably failed to open contents on a distribution list
                    ids = IDS_ERROR_NO_SUPPORT;
                    break;

                case MAPI_E_USER_CANCEL:
                    return(TRUE);

                default:
                    if (HR_FAILED(hResult)) {
                        DebugTrace("Error Box for Hresult: 0x%08x\n", GetScode(hResult));
                        Assert(FALSE);      // want to know about it.
                        ids = IDS_ERROR_GENERAL;
                    }
                    break;
            }
        }

        EI.lpszDisplayName = lpDisplayName;
        EI.lpszEmailAddress = lpEmailAddress;
        EI.ErrorResult = ERROR_OK;
        EI.ids = ids;

        DialogBoxParam(hInst,
          MAKEINTRESOURCE(IDD_ErrorImport),
          hwnd,
          ErrorDialogProc,
          (LPARAM)&EI);

        fAbort = EI.ErrorResult == ERROR_ABORT;
    }

    return(fAbort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wabmig\emsabtag.h ===
/*
** --emsabtag.h---------------------------------------------------------------
**
**  Property tag definitions for standard properties of Exchange Address
**  Book objects.
**
**  Note: These proptags are only valid when talking directly to the
**  Exchange Server Address Book. They are specifically NOT valid when
**  trying to read properties from an object copied into another address
**  book provider (the Personal Address Book, for example).
**
**  Copyright (c) Microsoft Corp. 1986-1996. All rights reserved.
** ---------------------------------------------------------------------------
*/

#ifndef _EMSABTAG_H
#define _EMSABTAG_H

/*    
 * Flags for ulInterfaceOptions on OpenProperty   
 */
#define AB_SHOW_PHANTOMS                      2
#define AB_SHOW_OTHERS                            4

/*    
 * Flags for ulFlag on ResolveNames               
 */
#define EMS_AB_ADDRESS_LOOKUP                 0x01

/* 
 * Constructed, but externally visible. 
 */
#define PR_EMS_AB_SERVER                      PROP_TAG(PT_TSTRING,      0xFFFE)
#define PR_EMS_AB_SERVER_A                    PROP_TAG(PT_STRING8,      0xFFFE)
#define PR_EMS_AB_SERVER_W                    PROP_TAG(PT_UNICODE,      0xFFFE)
#define PR_EMS_AB_CONTAINERID                 PROP_TAG(PT_LONG,         0xFFFD)
#define PR_EMS_AB_DOS_ENTRYID                 PR_EMS_AB_CONTAINERID
#define PR_EMS_AB_PARENT_ENTRYID              PROP_TAG(PT_BINARY,       0xFFFC)
#define PR_EMS_AB_IS_MASTER                   PROP_TAG(PT_BOOLEAN,      0xFFFB)
#define PR_EMS_AB_OBJECT_OID                  PROP_TAG(PT_BINARY,       0xFFFA)
#define PR_EMS_AB_HIERARCHY_PATH              PROP_TAG(PT_TSTRING,      0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_A            PROP_TAG(PT_STRING8,      0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_W            PROP_TAG(PT_UNICODE,      0xFFF9)
#define PR_EMS_AB_CHILD_RDNS                  PROP_TAG(PT_MV_STRING8,   0xFFF8)

#define MIN_EMS_AB_CONSTRUCTED_PROP_ID        0xFFF8

#define PR_EMS_AB_OTHER_RECIPS                PROP_TAG(PT_OBJECT,       0xF000)

/* 
 * Prop tags defined in the schema. 
 */
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE      PROP_TAG(PT_TSTRING,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A    PROP_TAG(PT_STRING8,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W    PROP_TAG(PT_UNICODE,      0x39FF)

#define PR_EMS_AB_ACCESS_CATEGORY             PROP_TAG(PT_LONG,         0x8044)
#define PR_EMS_AB_ACTIVATION_SCHEDULE         PROP_TAG(PT_BINARY,       0x8045)
#define PR_EMS_AB_ACTIVATION_STYLE            PROP_TAG(PT_LONG,         0x8046)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE PROP_TAG(PT_BINARY,       0x8017)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS PROP_TAG(PT_BINARY, 0x8047)
#define PR_EMS_AB_ADDRESS_SYNTAX              PROP_TAG(PT_BINARY,       0x8018)
#define PR_EMS_AB_ADDRESS_TYPE                PROP_TAG(PT_TSTRING,      0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_A              PROP_TAG(PT_STRING8,      0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_W              PROP_TAG(PT_UNICODE,      0x8048)
#define PR_EMS_AB_ADMD                        PROP_TAG(PT_TSTRING,      0x8049)
#define PR_EMS_AB_ADMD_A                      PROP_TAG(PT_STRING8,      0x8049)
#define PR_EMS_AB_ADMD_W                      PROP_TAG(PT_UNICODE,      0x8049)
#define PR_EMS_AB_ADMIN_DESCRIPTION           PROP_TAG(PT_TSTRING,      0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_A         PROP_TAG(PT_STRING8,      0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_W         PROP_TAG(PT_UNICODE,      0x804A)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME          PROP_TAG(PT_TSTRING,      0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_A        PROP_TAG(PT_STRING8,      0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_W        PROP_TAG(PT_UNICODE,      0x804B)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL         PROP_TAG(PT_TSTRING,      0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_A       PROP_TAG(PT_STRING8,      0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_W       PROP_TAG(PT_UNICODE,      0x804C)
#define PR_EMS_AB_ALIASED_OBJECT_NAME         PROP_TAG(PT_TSTRING,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_A       PROP_TAG(PT_STRING8,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_W       PROP_TAG(PT_UNICODE,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_O       PROP_TAG(PT_OBJECT,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_T       PROP_TAG(PT_TSTRING,      0x804D)
#define PR_EMS_AB_ALT_RECIPIENT               PROP_TAG(PT_TSTRING,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_A             PROP_TAG(PT_STRING8,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_W             PROP_TAG(PT_UNICODE,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_O             PROP_TAG(PT_OBJECT,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_T             PROP_TAG(PT_TSTRING,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_BL            PROP_TAG(PT_MV_TSTRING,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_A          PROP_TAG(PT_MV_STRING8,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_W          PROP_TAG(PT_MV_UNICODE,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_O          PROP_TAG(PT_OBJECT,       0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_T          PROP_TAG(PT_MV_TSTRING,   0x804F)
#define PR_EMS_AB_ANCESTOR_ID                 PROP_TAG(PT_BINARY,       0x8050)
#define PR_EMS_AB_ASSOC_NT_ACCOUNT            PROP_TAG(PT_BINARY,       0x8027)
#define PR_EMS_AB_ASSOC_REMOTE_DXA            PROP_TAG(PT_MV_TSTRING,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_A          PROP_TAG(PT_MV_STRING8,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_W          PROP_TAG(PT_MV_UNICODE,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_O          PROP_TAG(PT_OBJECT,       0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_T          PROP_TAG(PT_MV_TSTRING,   0x8051)
#define PR_EMS_AB_ASSOCIATION_LIFETIME        PROP_TAG(PT_LONG,         0x8052)
#define PR_EMS_AB_AUTH_ORIG_BL                PROP_TAG(PT_MV_TSTRING,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_A              PROP_TAG(PT_MV_STRING8,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_W              PROP_TAG(PT_MV_UNICODE,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_O              PROP_TAG(PT_OBJECT,       0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_T              PROP_TAG(PT_MV_TSTRING,   0x8053)
#define PR_EMS_AB_AUTHORITY_REVOCATION_LIST   PROP_TAG(PT_MV_BINARY,    0x8026)
#define PR_EMS_AB_AUTHORIZED_DOMAIN           PROP_TAG(PT_TSTRING,      0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_A         PROP_TAG(PT_STRING8,      0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_W         PROP_TAG(PT_UNICODE,      0x8054)
#define PR_EMS_AB_AUTHORIZED_PASSWORD         PROP_TAG(PT_BINARY,       0x8055)
#define PR_EMS_AB_AUTHORIZED_USER             PROP_TAG(PT_TSTRING,      0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_A           PROP_TAG(PT_STRING8,      0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_W           PROP_TAG(PT_UNICODE,      0x8056)
#define PR_EMS_AB_AUTOREPLY                   PROP_TAG(PT_BOOLEAN,      0x800B)
#define PR_EMS_AB_AUTOREPLY_MESSAGE           PROP_TAG(PT_TSTRING,      0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_A         PROP_TAG(PT_STRING8,      0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_W         PROP_TAG(PT_UNICODE,      0x800A)
#define PR_EMS_AB_AUTOREPLY_SUBJECT           PROP_TAG(PT_TSTRING,      0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_A         PROP_TAG(PT_STRING8,      0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_W         PROP_TAG(PT_UNICODE,      0x803E)
#define PR_EMS_AB_BUSINESS_CATEGORY           PROP_TAG(PT_MV_TSTRING,   0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_A         PROP_TAG(PT_MV_STRING8,   0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_W         PROP_TAG(PT_MV_UNICODE,   0x8057)
#define PR_EMS_AB_BUSINESS_ROLES              PROP_TAG(PT_BINARY,       0x8023)
#define PR_EMS_AB_CA_CERTIFICATE              PROP_TAG(PT_MV_BINARY,    0x8003)
#define PR_EMS_AB_CAN_CREATE_PF               PROP_TAG(PT_MV_TSTRING,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_A             PROP_TAG(PT_MV_STRING8,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_W             PROP_TAG(PT_MV_UNICODE,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_O             PROP_TAG(PT_OBJECT,       0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_T             PROP_TAG(PT_MV_TSTRING,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_BL            PROP_TAG(PT_MV_TSTRING,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_A          PROP_TAG(PT_MV_STRING8,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_W          PROP_TAG(PT_MV_UNICODE,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_O          PROP_TAG(PT_OBJECT,       0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_T          PROP_TAG(PT_MV_TSTRING,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_DL            PROP_TAG(PT_MV_TSTRING,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_A          PROP_TAG(PT_MV_STRING8,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_W          PROP_TAG(PT_MV_UNICODE,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_O          PROP_TAG(PT_OBJECT,       0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_T          PROP_TAG(PT_MV_TSTRING,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL         PROP_TAG(PT_MV_TSTRING,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_A       PROP_TAG(PT_MV_STRING8,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_W       PROP_TAG(PT_MV_UNICODE,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_O       PROP_TAG(PT_OBJECT,       0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_T       PROP_TAG(PT_MV_TSTRING,   0x805B)
#define PR_EMS_AB_CAN_NOT_CREATE_PF           PROP_TAG(PT_MV_TSTRING,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_A         PROP_TAG(PT_MV_STRING8,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_W         PROP_TAG(PT_MV_UNICODE,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_O         PROP_TAG(PT_OBJECT,       0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_T         PROP_TAG(PT_MV_TSTRING,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL        PROP_TAG(PT_MV_TSTRING,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_A      PROP_TAG(PT_MV_STRING8,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_W      PROP_TAG(PT_MV_UNICODE,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_O      PROP_TAG(PT_OBJECT,       0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_T      PROP_TAG(PT_MV_TSTRING,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL        PROP_TAG(PT_MV_TSTRING,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_A      PROP_TAG(PT_MV_STRING8,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_W      PROP_TAG(PT_MV_UNICODE,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_O      PROP_TAG(PT_OBJECT,       0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_T      PROP_TAG(PT_MV_TSTRING,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL     PROP_TAG(PT_MV_TSTRING,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_A   PROP_TAG(PT_MV_STRING8,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_W   PROP_TAG(PT_MV_UNICODE,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_O   PROP_TAG(PT_OBJECT,       0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_T   PROP_TAG(PT_MV_TSTRING,   0x805F)
#define PR_EMS_AB_CAN_PRESERVE_DNS            PROP_TAG(PT_BOOLEAN,      0x8060)
#define PR_EMS_AB_CERTIFICATE_REVOCATION_LIST PROP_TAG(PT_BINARY,       0x8016)
#define PR_EMS_AB_CLOCK_ALERT_OFFSET          PROP_TAG(PT_LONG,         0x8061)
#define PR_EMS_AB_CLOCK_ALERT_REPAIR          PROP_TAG(PT_BOOLEAN,      0x8062)
#define PR_EMS_AB_CLOCK_WARNING_OFFSET        PROP_TAG(PT_LONG,         0x8063)
#define PR_EMS_AB_CLOCK_WARNING_REPAIR        PROP_TAG(PT_BOOLEAN,      0x8064)
#define PR_EMS_AB_COMPUTER_NAME               PROP_TAG(PT_TSTRING,      0x8065)
#define PR_EMS_AB_COMPUTER_NAME_A             PROP_TAG(PT_STRING8,      0x8065)
#define PR_EMS_AB_COMPUTER_NAME_W             PROP_TAG(PT_UNICODE,      0x8065)
#define PR_EMS_AB_CONNECTED_DOMAINS           PROP_TAG(PT_MV_TSTRING,   0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_A         PROP_TAG(PT_MV_STRING8,   0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_W         PROP_TAG(PT_MV_UNICODE,   0x8066)
#define PR_EMS_AB_CONTAINER_INFO              PROP_TAG(PT_LONG,         0x8067)
#define PR_EMS_AB_COST                        PROP_TAG(PT_LONG,         0x8068)
#define PR_EMS_AB_COUNTRY_NAME                PROP_TAG(PT_TSTRING,      0x8069)
#define PR_EMS_AB_COUNTRY_NAME_A              PROP_TAG(PT_STRING8,      0x8069)
#define PR_EMS_AB_COUNTRY_NAME_W              PROP_TAG(PT_UNICODE,      0x8069)
#define PR_EMS_AB_CROSS_CERTIFICATE_PAIR      PROP_TAG(PT_MV_BINARY,    0x8025)
#define PR_EMS_AB_DELIV_CONT_LENGTH           PROP_TAG(PT_LONG,         0x806A)
#define PR_EMS_AB_DELIV_EITS                  PROP_TAG(PT_MV_BINARY,    0x806B)
#define PR_EMS_AB_DELIV_EXT_CONT_TYPES        PROP_TAG(PT_MV_BINARY,    0x806C)
#define PR_EMS_AB_DELIVER_AND_REDIRECT        PROP_TAG(PT_BOOLEAN,      0x806D)
#define PR_EMS_AB_DELIVERY_MECHANISM          PROP_TAG(PT_LONG,         0x806E)
#define PR_EMS_AB_DESCRIPTION                 PROP_TAG(PT_MV_TSTRING,   0x806F)
#define PR_EMS_AB_DESCRIPTION_A               PROP_TAG(PT_MV_STRING8,   0x806F)
#define PR_EMS_AB_DESCRIPTION_W               PROP_TAG(PT_MV_UNICODE,   0x806F)
#define PR_EMS_AB_DESTINATION_INDICATOR       PROP_TAG(PT_MV_TSTRING,   0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_A     PROP_TAG(PT_MV_STRING8,   0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_W     PROP_TAG(PT_MV_UNICODE,   0x8070)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY          PROP_TAG(PT_TSTRING,      0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_A        PROP_TAG(PT_STRING8,      0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_W        PROP_TAG(PT_UNICODE,      0x8071)
#define PR_EMS_AB_DISPLAY_NAME_OVERRIDE       PROP_TAG(PT_BOOLEAN,      0x8001)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL      PROP_TAG(PT_MV_TSTRING,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_A    PROP_TAG(PT_MV_STRING8,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_W    PROP_TAG(PT_MV_UNICODE,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_O    PROP_TAG(PT_OBJECT,       0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_T    PROP_TAG(PT_MV_TSTRING,   0x8072)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL      PROP_TAG(PT_MV_TSTRING,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_A    PROP_TAG(PT_MV_STRING8,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_W    PROP_TAG(PT_MV_UNICODE,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_O    PROP_TAG(PT_OBJECT,       0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_T    PROP_TAG(PT_MV_TSTRING,   0x8073)
#define PR_EMS_AB_DL_MEMBER_RULE              PROP_TAG(PT_MV_BINARY,    0x8074)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP        PROP_TAG(PT_TSTRING,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_A      PROP_TAG(PT_STRING8,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_W      PROP_TAG(PT_UNICODE,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_O      PROP_TAG(PT_OBJECT,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_T      PROP_TAG(PT_TSTRING,      0x8075)
#define PR_EMS_AB_DOMAIN_NAME                 PROP_TAG(PT_TSTRING,      0x8076)
#define PR_EMS_AB_DOMAIN_NAME_A               PROP_TAG(PT_STRING8,      0x8076)
#define PR_EMS_AB_DOMAIN_NAME_W               PROP_TAG(PT_UNICODE,      0x8076)
#define PR_EMS_AB_DSA_SIGNATURE               PROP_TAG(PT_BINARY,       0x8077)
#define PR_EMS_AB_DXA_ADMIN_COPY              PROP_TAG(PT_BOOLEAN,      0x8078)
#define PR_EMS_AB_DXA_ADMIN_FORWARD           PROP_TAG(PT_BOOLEAN,      0x8079)
#define PR_EMS_AB_DXA_ADMIN_UPDATE            PROP_TAG(PT_LONG,         0x807A)
#define PR_EMS_AB_DXA_APPEND_REQCN            PROP_TAG(PT_BOOLEAN,      0x807B)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST     PROP_TAG(PT_MV_TSTRING,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_A   PROP_TAG(PT_MV_STRING8,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_W   PROP_TAG(PT_MV_UNICODE,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_O   PROP_TAG(PT_OBJECT,       0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_T   PROP_TAG(PT_MV_TSTRING,   0x807C)
#define PR_EMS_AB_DXA_CONF_REQ_TIME           PROP_TAG(PT_SYSTIME,      0x807D)
#define PR_EMS_AB_DXA_CONF_SEQ                PROP_TAG(PT_TSTRING,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_A              PROP_TAG(PT_STRING8,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_W              PROP_TAG(PT_UNICODE,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_USN            PROP_TAG(PT_LONG,         0x807F)
#define PR_EMS_AB_DXA_EXCHANGE_OPTIONS        PROP_TAG(PT_LONG,         0x8080)
#define PR_EMS_AB_DXA_EXPORT_NOW              PROP_TAG(PT_BOOLEAN,      0x8081)
#define PR_EMS_AB_DXA_FLAGS                   PROP_TAG(PT_LONG,         0x8082)
#define PR_EMS_AB_DXA_IMP_SEQ                 PROP_TAG(PT_TSTRING,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_A               PROP_TAG(PT_STRING8,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_W               PROP_TAG(PT_UNICODE,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x8084)
#define PR_EMS_AB_DXA_IMP_SEQ_USN             PROP_TAG(PT_LONG,         0x8085)
#define PR_EMS_AB_DXA_IMPORT_NOW              PROP_TAG(PT_BOOLEAN,      0x8086)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP         PROP_TAG(PT_MV_TSTRING,   0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_A       PROP_TAG(PT_MV_STRING8,   0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_W       PROP_TAG(PT_MV_UNICODE,   0x8087)
#define PR_EMS_AB_DXA_LOCAL_ADMIN             PROP_TAG(PT_TSTRING,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_A           PROP_TAG(PT_STRING8,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_W           PROP_TAG(PT_UNICODE,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_O           PROP_TAG(PT_OBJECT,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_T           PROP_TAG(PT_TSTRING,      0x8088)
#define PR_EMS_AB_DXA_LOGGING_LEVEL           PROP_TAG(PT_LONG,         0x8089)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE     PROP_TAG(PT_TSTRING,      0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_A   PROP_TAG(PT_STRING8,      0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_W   PROP_TAG(PT_UNICODE,      0x808A)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP        PROP_TAG(PT_MV_TSTRING,   0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_A      PROP_TAG(PT_MV_STRING8,   0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_W      PROP_TAG(PT_MV_UNICODE,   0x808B)
#define PR_EMS_AB_DXA_PASSWORD                PROP_TAG(PT_TSTRING,      0x808C)
#define PR_EMS_AB_DXA_PASSWORD_A              PROP_TAG(PT_STRING8,      0x808C)
#define PR_EMS_AB_DXA_PASSWORD_W              PROP_TAG(PT_UNICODE,      0x808C)
#define PR_EMS_AB_DXA_PREV_EXCHANGE_OPTIONS   PROP_TAG(PT_LONG,         0x808D)
#define PR_EMS_AB_DXA_PREV_EXPORT_NATIVE_ONLY PROP_TAG(PT_BOOLEAN,      0x808E)
#define PR_EMS_AB_DXA_PREV_IN_EXCHANGE_SENSITIVITY PROP_TAG(PT_LONG,    0x808F)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES     PROP_TAG(PT_TSTRING,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_A   PROP_TAG(PT_STRING8,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_W   PROP_TAG(PT_UNICODE,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_O   PROP_TAG(PT_OBJECT,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_T   PROP_TAG(PT_TSTRING,      0x8090)
#define PR_EMS_AB_DXA_PREV_REPLICATION_SENSITIVITY PROP_TAG(PT_LONG,    0x8091)
#define PR_EMS_AB_DXA_PREV_TEMPLATE_OPTIONS   PROP_TAG(PT_LONG,         0x8092)
#define PR_EMS_AB_DXA_PREV_TYPES              PROP_TAG(PT_LONG,         0x8093)
#define PR_EMS_AB_DXA_RECIPIENT_CP            PROP_TAG(PT_TSTRING,      0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_A          PROP_TAG(PT_STRING8,      0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_W          PROP_TAG(PT_UNICODE,      0x8094)
#define PR_EMS_AB_DXA_REMOTE_CLIENT           PROP_TAG(PT_TSTRING,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_A         PROP_TAG(PT_STRING8,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_W         PROP_TAG(PT_UNICODE,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_O         PROP_TAG(PT_OBJECT,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_T         PROP_TAG(PT_TSTRING,      0x8095)
#define PR_EMS_AB_DXA_REQ_SEQ                 PROP_TAG(PT_TSTRING,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_A               PROP_TAG(PT_STRING8,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_W               PROP_TAG(PT_UNICODE,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x8097)
#define PR_EMS_AB_DXA_REQ_SEQ_USN             PROP_TAG(PT_LONG,         0x8098)
#define PR_EMS_AB_DXA_REQNAME                 PROP_TAG(PT_TSTRING,      0x8099)
#define PR_EMS_AB_DXA_REQNAME_A               PROP_TAG(PT_STRING8,      0x8099)
#define PR_EMS_AB_DXA_REQNAME_W               PROP_TAG(PT_UNICODE,      0x8099)
#define PR_EMS_AB_DXA_SVR_SEQ                 PROP_TAG(PT_TSTRING,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_A               PROP_TAG(PT_STRING8,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_W               PROP_TAG(PT_UNICODE,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x809B)
#define PR_EMS_AB_DXA_SVR_SEQ_USN             PROP_TAG(PT_LONG,         0x809C)
#define PR_EMS_AB_DXA_TASK                    PROP_TAG(PT_LONG,         0x809D)
#define PR_EMS_AB_DXA_TEMPLATE_OPTIONS        PROP_TAG(PT_LONG,         0x809E)
#define PR_EMS_AB_DXA_TEMPLATE_TIMESTAMP      PROP_TAG(PT_SYSTIME,      0x809F)
#define PR_EMS_AB_DXA_TYPES                   PROP_TAG(PT_LONG,         0x80A0)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST   PROP_TAG(PT_MV_TSTRING,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_A PROP_TAG(PT_MV_STRING8,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_W PROP_TAG(PT_MV_UNICODE,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_O PROP_TAG(PT_OBJECT,       0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_T PROP_TAG(PT_MV_TSTRING,   0x80A1)
#define PR_EMS_AB_ENCAPSULATION_METHOD        PROP_TAG(PT_LONG,         0x80A2)
#define PR_EMS_AB_ENCRYPT                     PROP_TAG(PT_BOOLEAN,      0x80A3)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA         PROP_TAG(PT_MV_TSTRING,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_A       PROP_TAG(PT_MV_STRING8,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_W       PROP_TAG(PT_MV_UNICODE,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER      PROP_TAG(PT_MV_TSTRING,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_A    PROP_TAG(PT_MV_STRING8,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_W    PROP_TAG(PT_MV_UNICODE,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA     PROP_TAG(PT_TSTRING,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_A   PROP_TAG(PT_STRING8,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_W   PROP_TAG(PT_UNICODE,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER  PROP_TAG(PT_TSTRING,      0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_A PROP_TAG(PT_STRING8,     0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_W PROP_TAG(PT_UNICODE,     0x803D)
#define PR_EMS_AB_EXPAND_DLS_LOCALLY          PROP_TAG(PT_BOOLEAN,      0x80A4)
#define PR_EMS_AB_EXPIRATION_TIME             PROP_TAG(PT_SYSTIME,      0x8028)
#define PR_EMS_AB_EXPORT_CONTAINERS           PROP_TAG(PT_MV_TSTRING,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_A         PROP_TAG(PT_MV_STRING8,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_W         PROP_TAG(PT_MV_UNICODE,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_O         PROP_TAG(PT_OBJECT,       0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_T         PROP_TAG(PT_MV_TSTRING,   0x80A5)
#define PR_EMS_AB_EXPORT_CUSTOM_RECIPIENTS    PROP_TAG(PT_BOOLEAN,      0x80A6)
#define PR_EMS_AB_EXTENDED_CHARS_ALLOWED      PROP_TAG(PT_BOOLEAN,      0x80A7)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1       PROP_TAG(PT_TSTRING,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_A     PROP_TAG(PT_STRING8,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_W     PROP_TAG(PT_UNICODE,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10      PROP_TAG(PT_TSTRING,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_A    PROP_TAG(PT_STRING8,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_W    PROP_TAG(PT_UNICODE,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2       PROP_TAG(PT_TSTRING,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_A     PROP_TAG(PT_STRING8,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_W     PROP_TAG(PT_UNICODE,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3       PROP_TAG(PT_TSTRING,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_A     PROP_TAG(PT_STRING8,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_W     PROP_TAG(PT_UNICODE,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4       PROP_TAG(PT_TSTRING,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_A     PROP_TAG(PT_STRING8,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_W     PROP_TAG(PT_UNICODE,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5       PROP_TAG(PT_TSTRING,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_A     PROP_TAG(PT_STRING8,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_W     PROP_TAG(PT_UNICODE,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6       PROP_TAG(PT_TSTRING,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_A     PROP_TAG(PT_STRING8,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_W     PROP_TAG(PT_UNICODE,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7       PROP_TAG(PT_TSTRING,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_A     PROP_TAG(PT_STRING8,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_W     PROP_TAG(PT_UNICODE,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8       PROP_TAG(PT_TSTRING,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_A     PROP_TAG(PT_STRING8,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_W     PROP_TAG(PT_UNICODE,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9       PROP_TAG(PT_TSTRING,      0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_A     PROP_TAG(PT_STRING8,      0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_W     PROP_TAG(PT_UNICODE,      0x8035)
#define PR_EMS_AB_EXTENSION_DATA              PROP_TAG(PT_MV_BINARY,    0x80A8)
#define PR_EMS_AB_EXTENSION_NAME              PROP_TAG(PT_MV_TSTRING,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_A            PROP_TAG(PT_MV_STRING8,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_W            PROP_TAG(PT_MV_UNICODE,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED    PROP_TAG(PT_MV_TSTRING,   0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_A  PROP_TAG(PT_MV_STRING8,   0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_W  PROP_TAG(PT_MV_UNICODE,   0x80AA)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER  PROP_TAG(PT_MV_BINARY,    0x80AB)
#define PR_EMS_AB_FILE_VERSION                PROP_TAG(PT_BINARY,       0x80AC)
#define PR_EMS_AB_FILTER_LOCAL_ADDRESSES      PROP_TAG(PT_BOOLEAN,      0x80AD)
#define PR_EMS_AB_FOLDER_PATHNAME             PROP_TAG(PT_TSTRING,      0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_A           PROP_TAG(PT_STRING8,      0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_W           PROP_TAG(PT_UNICODE,      0x8004)
#define PR_EMS_AB_FOLDERS_CONTAINER           PROP_TAG(PT_TSTRING,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_A         PROP_TAG(PT_STRING8,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_W         PROP_TAG(PT_UNICODE,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_O         PROP_TAG(PT_OBJECT,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_T         PROP_TAG(PT_TSTRING,      0x80AE)
#define PR_EMS_AB_GARBAGE_COLL_PERIOD         PROP_TAG(PT_LONG,         0x80AF)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED          PROP_TAG(PT_TSTRING,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_A        PROP_TAG(PT_STRING8,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_W        PROP_TAG(PT_UNICODE,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG         PROP_TAG(PT_TSTRING,      0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_A       PROP_TAG(PT_STRING8,      0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_W       PROP_TAG(PT_UNICODE,      0x80B1)
#define PR_EMS_AB_GATEWAY_PROXY               PROP_TAG(PT_MV_TSTRING,   0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_A             PROP_TAG(PT_MV_STRING8,   0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_W             PROP_TAG(PT_MV_UNICODE,   0x80B2)
#define PR_EMS_AB_GATEWAY_ROUTING_TREE        PROP_TAG(PT_BINARY,       0x80B3)
#define PR_EMS_AB_GWART_LAST_MODIFIED         PROP_TAG(PT_SYSTIME,      0x80B4)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS        PROP_TAG(PT_MV_TSTRING,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_A      PROP_TAG(PT_MV_STRING8,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_W      PROP_TAG(PT_MV_UNICODE,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_O      PROP_TAG(PT_OBJECT,       0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_T      PROP_TAG(PT_MV_TSTRING,   0x80B5)
#define PR_EMS_AB_HAS_MASTER_NCS              PROP_TAG(PT_MV_TSTRING,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_A            PROP_TAG(PT_MV_STRING8,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_W            PROP_TAG(PT_MV_UNICODE,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_O            PROP_TAG(PT_OBJECT,       0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_T            PROP_TAG(PT_MV_TSTRING,   0x80B6)
#define PR_EMS_AB_HELP_DATA16                 PROP_TAG(PT_BINARY,       0x803A)
#define PR_EMS_AB_HELP_DATA32                 PROP_TAG(PT_BINARY,       0x8010)
#define PR_EMS_AB_HELP_FILE_NAME              PROP_TAG(PT_TSTRING,      0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_A            PROP_TAG(PT_STRING8,      0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_W            PROP_TAG(PT_UNICODE,      0x803B)
#define PR_EMS_AB_HEURISTICS                  PROP_TAG(PT_LONG,         0x80B7)
#define PR_EMS_AB_HIDE_DL_MEMBERSHIP          PROP_TAG(PT_BOOLEAN,      0x80B8)
#define PR_EMS_AB_HIDE_FROM_ADDRESS_BOOK      PROP_TAG(PT_BOOLEAN,      0x80B9)
#define PR_EMS_AB_HOME_MDB                    PROP_TAG(PT_TSTRING,      0x8006)
#define PR_EMS_AB_HOME_MDB_A                  PROP_TAG(PT_STRING8,      0x8006)
#define PR_EMS_AB_HOME_MDB_W                  PROP_TAG(PT_UNICODE,      0x8006)
#define PR_EMS_AB_HOME_MDB_O                  PROP_TAG(PT_OBJECT,       0x8006)
#define PR_EMS_AB_HOME_MDB_T                  PROP_TAG(PT_TSTRING,      0x8006)
#define PR_EMS_AB_HOME_MDB_BL                 PROP_TAG(PT_MV_TSTRING,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_A               PROP_TAG(PT_MV_STRING8,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_W               PROP_TAG(PT_MV_UNICODE,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_O               PROP_TAG(PT_OBJECT,       0x8014)
#define PR_EMS_AB_HOME_MDB_BL_T               PROP_TAG(PT_MV_TSTRING,   0x8014)
#define PR_EMS_AB_HOME_MTA                    PROP_TAG(PT_TSTRING,      0x8007)
#define PR_EMS_AB_HOME_MTA_A                  PROP_TAG(PT_STRING8,      0x8007)
#define PR_EMS_AB_HOME_MTA_W                  PROP_TAG(PT_UNICODE,      0x8007)
#define PR_EMS_AB_HOME_MTA_O                  PROP_TAG(PT_OBJECT,       0x8007)
#define PR_EMS_AB_HOME_MTA_T                  PROP_TAG(PT_TSTRING,      0x8007)
#define PR_EMS_AB_HOME_PUBLIC_SERVER          PROP_TAG(PT_TSTRING,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_A        PROP_TAG(PT_STRING8,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_W        PROP_TAG(PT_UNICODE,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_O        PROP_TAG(PT_OBJECT,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_T        PROP_TAG(PT_TSTRING,      0x803F)
#define PR_EMS_AB_IMPORT_CONTAINER            PROP_TAG(PT_TSTRING,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_A          PROP_TAG(PT_STRING8,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_W          PROP_TAG(PT_UNICODE,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_O          PROP_TAG(PT_OBJECT,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_T          PROP_TAG(PT_TSTRING,      0x80BA)
#define PR_EMS_AB_IMPORT_SENSITIVITY          PROP_TAG(PT_LONG,         0x80BB)
#define PR_EMS_AB_IMPORTED_FROM               PROP_TAG(PT_TSTRING,      0x8042)
#define PR_EMS_AB_IMPORTED_FROM_A             PROP_TAG(PT_STRING8,      0x8042)
#define PR_EMS_AB_IMPORTED_FROM_W             PROP_TAG(PT_UNICODE,      0x8042)
#define PR_EMS_AB_INBOUND_SITES               PROP_TAG(PT_MV_TSTRING,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_A             PROP_TAG(PT_MV_STRING8,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_W             PROP_TAG(PT_MV_UNICODE,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_O             PROP_TAG(PT_OBJECT,       0x80BC)
#define PR_EMS_AB_INBOUND_SITES_T             PROP_TAG(PT_MV_TSTRING,   0x80BC)
#define PR_EMS_AB_INSTANCE_TYPE               PROP_TAG(PT_LONG,         0x80BD)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER   PROP_TAG(PT_MV_TSTRING,   0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_A PROP_TAG(PT_MV_STRING8,   0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_W PROP_TAG(PT_MV_UNICODE,   0x80BE)
#define PR_EMS_AB_INVOCATION_ID               PROP_TAG(PT_BINARY,       0x80BF)
#define PR_EMS_AB_IS_DELETED                  PROP_TAG(PT_BOOLEAN,      0x80C0)
#define PR_EMS_AB_IS_MEMBER_OF_DL             PROP_TAG(PT_OBJECT,       0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_A           PROP_TAG(PT_MV_STRING8,   0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_W           PROP_TAG(PT_MV_UNICODE,   0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_O           PROP_TAG(PT_OBJECT,       0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_T           PROP_TAG(PT_MV_TSTRING,   0x8008)
#define PR_EMS_AB_IS_SINGLE_VALUED            PROP_TAG(PT_BOOLEAN,      0x80C1)
#define PR_EMS_AB_KCC_STATUS                  PROP_TAG(PT_MV_BINARY,    0x80C2)
#define PR_EMS_AB_KM_SERVER                   PROP_TAG(PT_TSTRING,      0x800D)
#define PR_EMS_AB_KM_SERVER_A                 PROP_TAG(PT_STRING8,      0x800D)
#define PR_EMS_AB_KM_SERVER_W                 PROP_TAG(PT_UNICODE,      0x800D)
#define PR_EMS_AB_KM_SERVER_O                 PROP_TAG(PT_OBJECT,       0x800D)
#define PR_EMS_AB_KM_SERVER_T                 PROP_TAG(PT_TSTRING,      0x800D)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION       PROP_TAG(PT_MV_TSTRING,   0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_A     PROP_TAG(PT_MV_STRING8,   0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_W     PROP_TAG(PT_MV_UNICODE,   0x80C3)
#define PR_EMS_AB_LINE_WRAP                   PROP_TAG(PT_LONG,         0x80C4)
#define PR_EMS_AB_LINK_ID                     PROP_TAG(PT_LONG,         0x80C5)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD           PROP_TAG(PT_TSTRING,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_A         PROP_TAG(PT_STRING8,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_W         PROP_TAG(PT_UNICODE,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS   PROP_TAG(PT_TSTRING,      0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_A PROP_TAG(PT_STRING8,      0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_W PROP_TAG(PT_UNICODE,      0x80C7)
#define PR_EMS_AB_LOCAL_INITIAL_TURN          PROP_TAG(PT_BOOLEAN,      0x80C8)
#define PR_EMS_AB_LOCAL_SCOPE                 PROP_TAG(PT_MV_TSTRING,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_A               PROP_TAG(PT_MV_STRING8,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_W               PROP_TAG(PT_MV_UNICODE,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_O               PROP_TAG(PT_OBJECT,       0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_T               PROP_TAG(PT_MV_TSTRING,   0x80C9)
#define PR_EMS_AB_LOG_FILENAME                PROP_TAG(PT_TSTRING,      0x80CA)
#define PR_EMS_AB_LOG_FILENAME_A              PROP_TAG(PT_STRING8,      0x80CA)
#define PR_EMS_AB_LOG_FILENAME_W              PROP_TAG(PT_UNICODE,      0x80CA)
#define PR_EMS_AB_LOG_ROLLOVER_INTERVAL       PROP_TAG(PT_LONG,         0x80CB)
#define PR_EMS_AB_MAINTAIN_AUTOREPLY_HISTORY  PROP_TAG(PT_BOOLEAN,      0x80CC)
#define PR_EMS_AB_MANAGER                     PROP_TAG(PT_OBJECT,       0x8005)
#define PR_EMS_AB_MANAGER_A                   PROP_TAG(PT_STRING8,      0x8005)
#define PR_EMS_AB_MANAGER_W                   PROP_TAG(PT_UNICODE,      0x8005)
#define PR_EMS_AB_MANAGER_O                   PROP_TAG(PT_OBJECT,       0x8005)
#define PR_EMS_AB_MANAGER_T                   PROP_TAG(PT_TSTRING,      0x8005)
#define PR_EMS_AB_MAPI_DISPLAY_TYPE           PROP_TAG(PT_LONG,         0x80CD)
#define PR_EMS_AB_MAPI_ID                     PROP_TAG(PT_LONG,         0x80CE)
#define PR_EMS_AB_MAXIMUM_OBJECT_ID           PROP_TAG(PT_BINARY,       0x8169)
#define PR_EMS_AB_MDB_BACKOFF_INTERVAL        PROP_TAG(PT_LONG,         0x80CF)
#define PR_EMS_AB_MDB_MSG_TIME_OUT_PERIOD     PROP_TAG(PT_LONG,         0x80D0)
#define PR_EMS_AB_MDB_OVER_QUOTA_LIMIT        PROP_TAG(PT_LONG,         0x80D1)
#define PR_EMS_AB_MDB_STORAGE_QUOTA           PROP_TAG(PT_LONG,         0x80D2)
#define PR_EMS_AB_MDB_UNREAD_LIMIT            PROP_TAG(PT_LONG,         0x80D3)
#define PR_EMS_AB_MDB_USE_DEFAULTS            PROP_TAG(PT_BOOLEAN,      0x80D4)
#define PR_EMS_AB_MEMBER                      PROP_TAG(PT_OBJECT,       0x8009)
#define PR_EMS_AB_MEMBER_A                    PROP_TAG(PT_MV_STRING8,   0x8009)
#define PR_EMS_AB_MEMBER_W                    PROP_TAG(PT_MV_UNICODE,   0x8009)
#define PR_EMS_AB_MEMBER_O                    PROP_TAG(PT_OBJECT,       0x8009)
#define PR_EMS_AB_MEMBER_T                    PROP_TAG(PT_MV_TSTRING,   0x8009)
#define PR_EMS_AB_MESSAGE_TRACKING_ENABLED    PROP_TAG(PT_BOOLEAN,      0x80D5)
#define PR_EMS_AB_MONITOR_CLOCK               PROP_TAG(PT_BOOLEAN,      0x80D6)
#define PR_EMS_AB_MONITOR_SERVERS             PROP_TAG(PT_BOOLEAN,      0x80D7)
#define PR_EMS_AB_MONITOR_SERVICES            PROP_TAG(PT_BOOLEAN,      0x80D8)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS    PROP_TAG(PT_MV_TSTRING,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_A  PROP_TAG(PT_MV_STRING8,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_W  PROP_TAG(PT_MV_UNICODE,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_O  PROP_TAG(PT_OBJECT,       0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_T  PROP_TAG(PT_MV_TSTRING,   0x80D9)
#define PR_EMS_AB_MONITORED_SERVERS           PROP_TAG(PT_MV_TSTRING,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_A         PROP_TAG(PT_MV_STRING8,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_W         PROP_TAG(PT_MV_UNICODE,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_O         PROP_TAG(PT_OBJECT,       0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_T         PROP_TAG(PT_MV_TSTRING,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVICES          PROP_TAG(PT_MV_TSTRING,   0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_A        PROP_TAG(PT_MV_STRING8,   0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_W        PROP_TAG(PT_MV_UNICODE,   0x80DB)
#define PR_EMS_AB_MONITORING_ALERT_DELAY      PROP_TAG(PT_LONG,         0x80DC)
#define PR_EMS_AB_MONITORING_ALERT_UNITS      PROP_TAG(PT_LONG,         0x80DD)
#define PR_EMS_AB_MONITORING_AVAILABILITY_STYLE PROP_TAG(PT_LONG,       0x80DE)
#define PR_EMS_AB_MONITORING_AVAILABILITY_WINDOW PROP_TAG(PT_BINARY,    0x80DF)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL  PROP_TAG(PT_MV_TSTRING,   0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_A PROP_TAG(PT_MV_STRING8,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_W PROP_TAG(PT_MV_UNICODE,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_O PROP_TAG(PT_OBJECT,      0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_T PROP_TAG(PT_MV_TSTRING,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC   PROP_TAG(PT_MV_TSTRING,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_A PROP_TAG(PT_MV_STRING8,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_W PROP_TAG(PT_MV_UNICODE,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_O PROP_TAG(PT_OBJECT,       0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_T PROP_TAG(PT_MV_TSTRING,   0x80E1)
#define PR_EMS_AB_MONITORING_ESCALATION_PROCEDURE PROP_TAG(PT_MV_BINARY,0x80E2)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_INTERVAL PROP_TAG(PT_LONG,    0x80E3)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_UNITS PROP_TAG(PT_LONG,       0x80E4)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_INTERVAL PROP_TAG(PT_LONG,     0x80E5)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_UNITS PROP_TAG(PT_LONG,        0x80E6)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_INTERVAL PROP_TAG(PT_LONG,     0x80E7)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_UNITS PROP_TAG(PT_LONG,        0x80E8)
#define PR_EMS_AB_MONITORING_RECIPIENTS       PROP_TAG(PT_MV_TSTRING,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_A     PROP_TAG(PT_MV_STRING8,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_W     PROP_TAG(PT_MV_UNICODE,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_O     PROP_TAG(PT_OBJECT,       0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_T     PROP_TAG(PT_MV_TSTRING,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR   PROP_TAG(PT_MV_TSTRING,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_A PROP_TAG(PT_MV_STRING8,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_W PROP_TAG(PT_MV_UNICODE,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_O PROP_TAG(PT_OBJECT,       0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_T PROP_TAG(PT_MV_TSTRING,   0x80EA)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_INTERVAL PROP_TAG(PT_LONG,      0x80EB)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_UNITS PROP_TAG(PT_LONG,         0x80EC)
#define PR_EMS_AB_MONITORING_WARNING_DELAY    PROP_TAG(PT_LONG,         0x80ED)
#define PR_EMS_AB_MONITORING_WARNING_UNITS    PROP_TAG(PT_LONG,         0x80EE)
#define PR_EMS_AB_MTA_LOCAL_CRED              PROP_TAG(PT_TSTRING,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_A            PROP_TAG(PT_STRING8,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_W            PROP_TAG(PT_UNICODE,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_DESIG             PROP_TAG(PT_TSTRING,      0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_A           PROP_TAG(PT_STRING8,      0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_W           PROP_TAG(PT_UNICODE,      0x80F0)
#define PR_EMS_AB_N_ADDRESS                   PROP_TAG(PT_BINARY,       0x80F1)
#define PR_EMS_AB_N_ADDRESS_TYPE              PROP_TAG(PT_LONG,         0x80F2)
#define PR_EMS_AB_NETWORK_ADDRESS             PROP_TAG(PT_MV_TSTRING,   0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_A           PROP_TAG(PT_MV_STRING8,   0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_W           PROP_TAG(PT_MV_UNICODE,   0x8170)
#define PR_EMS_AB_NT_MACHINE_NAME             PROP_TAG(PT_TSTRING,      0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_A           PROP_TAG(PT_STRING8,      0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_W           PROP_TAG(PT_UNICODE,      0x80F3)
#define PR_EMS_AB_NT_SECURITY_DESCRIPTOR      PROP_TAG(PT_BINARY,       0x8013)
#define PR_EMS_AB_NUM_OF_OPEN_RETRIES         PROP_TAG(PT_LONG,         0x80F4)
#define PR_EMS_AB_NUM_OF_TRANSFER_RETRIES     PROP_TAG(PT_LONG,         0x80F5)
#define PR_EMS_AB_OBJ_DIST_NAME               PROP_TAG(PT_TSTRING,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_A             PROP_TAG(PT_STRING8,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_W             PROP_TAG(PT_UNICODE,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_O             PROP_TAG(PT_OBJECT,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_T             PROP_TAG(PT_TSTRING,      0x803C)
#define PR_EMS_AB_OBJECT_CLASS_CATEGORY       PROP_TAG(PT_LONG,         0x80F6)
#define PR_EMS_AB_OBJECT_VERSION              PROP_TAG(PT_LONG,         0x80F7)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS      PROP_TAG(PT_MV_TSTRING,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_A    PROP_TAG(PT_MV_STRING8,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_W    PROP_TAG(PT_MV_UNICODE,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_O    PROP_TAG(PT_OBJECT,       0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_T    PROP_TAG(PT_MV_TSTRING,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_SCHEDULE        PROP_TAG(PT_BINARY,       0x80F9)
#define PR_EMS_AB_OFF_LINE_AB_SERVER          PROP_TAG(PT_TSTRING,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_A        PROP_TAG(PT_STRING8,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_W        PROP_TAG(PT_UNICODE,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_O        PROP_TAG(PT_OBJECT,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_T        PROP_TAG(PT_TSTRING,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_STYLE           PROP_TAG(PT_LONG,         0x80FB)
#define PR_EMS_AB_OID_TYPE                    PROP_TAG(PT_LONG,         0x80FC)
#define PR_EMS_AB_OM_OBJECT_CLASS             PROP_TAG(PT_BINARY,       0x80FD)
#define PR_EMS_AB_OM_SYNTAX                   PROP_TAG(PT_LONG,         0x80FE)
#define PR_EMS_AB_OOF_REPLY_TO_ORIGINATOR     PROP_TAG(PT_BOOLEAN,      0x80FF)
#define PR_EMS_AB_OPEN_RETRY_INTERVAL         PROP_TAG(PT_LONG,         0x8100)
#define PR_EMS_AB_ORGANIZATION_NAME           PROP_TAG(PT_MV_TSTRING,   0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_A         PROP_TAG(PT_MV_STRING8,   0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_W         PROP_TAG(PT_MV_UNICODE,   0x8101)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME    PROP_TAG(PT_MV_TSTRING,   0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_A  PROP_TAG(PT_MV_STRING8,   0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_W  PROP_TAG(PT_MV_UNICODE,   0x8102)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE      PROP_TAG(PT_BINARY,       0x8103)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE_MSDOS PROP_TAG(PT_BINARY,      0x8104)
#define PR_EMS_AB_OUTBOUND_SITES              PROP_TAG(PT_MV_TSTRING,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_A            PROP_TAG(PT_MV_STRING8,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_W            PROP_TAG(PT_MV_UNICODE,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_O            PROP_TAG(PT_OBJECT,       0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_T            PROP_TAG(PT_MV_TSTRING,   0x8105)
#define PR_EMS_AB_OWNER                       PROP_TAG(PT_TSTRING,      0x800C)
#define PR_EMS_AB_OWNER_A                     PROP_TAG(PT_STRING8,      0x800C)
#define PR_EMS_AB_OWNER_W                     PROP_TAG(PT_UNICODE,      0x800C)
#define PR_EMS_AB_OWNER_O                     PROP_TAG(PT_OBJECT,       0x800C)
#define PR_EMS_AB_OWNER_T                     PROP_TAG(PT_TSTRING,      0x800C)
#define PR_EMS_AB_OWNER_BL                    PROP_TAG(PT_TSTRING,      0x8024)
#define PR_EMS_AB_OWNER_BL_A                  PROP_TAG(PT_STRING8,      0x8024)
#define PR_EMS_AB_OWNER_BL_W                  PROP_TAG(PT_UNICODE,      0x8024)
#define PR_EMS_AB_OWNER_BL_O                  PROP_TAG(PT_OBJECT,       0x8024)
#define PR_EMS_AB_OWNER_BL_T                  PROP_TAG(PT_TSTRING,      0x8024)
#define PR_EMS_AB_P_SELECTOR                  PROP_TAG(PT_BINARY,       0x8106)
#define PR_EMS_AB_P_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x8107)
#define PR_EMS_AB_PER_MSG_DIALOG_DISPLAY_TABLE PROP_TAG(PT_BINARY,      0x8108)
#define PR_EMS_AB_PER_RECIP_DIALOG_DISPLAY_TABLE PROP_TAG(PT_BINARY,    0x8109)
#define PR_EMS_AB_PERIOD_REP_SYNC_TIMES       PROP_TAG(PT_BINARY,       0x810A)
#define PR_EMS_AB_PERIOD_REPL_STAGGER         PROP_TAG(PT_LONG,         0x810B)
#define PR_EMS_AB_PF_CONTACTS                 PROP_TAG(PT_MV_TSTRING,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_A               PROP_TAG(PT_MV_STRING8,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_W               PROP_TAG(PT_MV_UNICODE,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_O               PROP_TAG(PT_OBJECT,       0x8038)
#define PR_EMS_AB_PF_CONTACTS_T               PROP_TAG(PT_MV_TSTRING,   0x8038)
#define PR_EMS_AB_POSTAL_ADDRESS              PROP_TAG(PT_MV_BINARY,    0x810C)
#define PR_EMS_AB_PREFERRED_DELIVERY_METHOD   PROP_TAG(PT_MV_LONG,      0x810D)
#define PR_EMS_AB_PRMD                        PROP_TAG(PT_TSTRING,      0x810E)
#define PR_EMS_AB_PRMD_A                      PROP_TAG(PT_STRING8,      0x810E)
#define PR_EMS_AB_PRMD_W                      PROP_TAG(PT_UNICODE,      0x810E)
#define PR_EMS_AB_PROXY_ADDRESSES             PROP_TAG(PT_MV_TSTRING,   0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_A           PROP_TAG(PT_MV_STRING8,   0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_W           PROP_TAG(PT_MV_UNICODE,   0x800F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL         PROP_TAG(PT_TSTRING,      0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_A       PROP_TAG(PT_STRING8,      0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_W       PROP_TAG(PT_UNICODE,      0x810F)
#define PR_EMS_AB_PUBLIC_DELEGATES            PROP_TAG(PT_OBJECT,       0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_A          PROP_TAG(PT_MV_STRING8,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_W          PROP_TAG(PT_MV_UNICODE,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_O          PROP_TAG(PT_OBJECT,       0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_T          PROP_TAG(PT_MV_TSTRING,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL         PROP_TAG(PT_MV_TSTRING,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_A       PROP_TAG(PT_MV_STRING8,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_W       PROP_TAG(PT_MV_UNICODE,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_O       PROP_TAG(PT_OBJECT,       0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_T       PROP_TAG(PT_MV_TSTRING,   0x8110)
#define PR_EMS_AB_QUOTA_NOTIFICATION_SCHEDULE PROP_TAG(PT_BINARY,       0x8111)
#define PR_EMS_AB_QUOTA_NOTIFICATION_STYLE    PROP_TAG(PT_LONG,         0x8112)
#define PR_EMS_AB_RANGE_LOWER                 PROP_TAG(PT_LONG,         0x8113)
#define PR_EMS_AB_RANGE_UPPER                 PROP_TAG(PT_LONG,         0x8114)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER         PROP_TAG(PT_TSTRING,      0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_A       PROP_TAG(PT_STRING8,      0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_W       PROP_TAG(PT_UNICODE,      0x8115)
#define PR_EMS_AB_RAS_PHONE_NUMBER            PROP_TAG(PT_TSTRING,      0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_A          PROP_TAG(PT_STRING8,      0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_W          PROP_TAG(PT_UNICODE,      0x8116)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME    PROP_TAG(PT_TSTRING,      0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_A  PROP_TAG(PT_STRING8,      0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_W  PROP_TAG(PT_UNICODE,      0x8117)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME        PROP_TAG(PT_TSTRING,      0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_A      PROP_TAG(PT_STRING8,      0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_W      PROP_TAG(PT_UNICODE,      0x8118)
#define PR_EMS_AB_REGISTERED_ADDRESS          PROP_TAG(PT_MV_BINARY,    0x8119)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD          PROP_TAG(PT_TSTRING,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_A        PROP_TAG(PT_STRING8,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_W        PROP_TAG(PT_UNICODE,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS  PROP_TAG(PT_TSTRING,      0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_A PROP_TAG(PT_STRING8,     0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_W PROP_TAG(PT_UNICODE,     0x811B)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER        PROP_TAG(PT_TSTRING,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_A      PROP_TAG(PT_STRING8,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_W      PROP_TAG(PT_UNICODE,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_O      PROP_TAG(PT_OBJECT,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_T      PROP_TAG(PT_TSTRING,      0x811C)
#define PR_EMS_AB_REMOTE_SITE                 PROP_TAG(PT_TSTRING,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_A               PROP_TAG(PT_STRING8,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_W               PROP_TAG(PT_UNICODE,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_O               PROP_TAG(PT_OBJECT,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_T               PROP_TAG(PT_TSTRING,      0x811D)
#define PR_EMS_AB_REPLICATION_MAIL_MSG_SIZE   PROP_TAG(PT_LONG,         0x8168)
#define PR_EMS_AB_REPLICATION_SENSITIVITY     PROP_TAG(PT_LONG,         0x811E)
#define PR_EMS_AB_REPLICATION_STAGGER         PROP_TAG(PT_LONG,         0x811F)
#define PR_EMS_AB_REPORT_TO_ORIGINATOR        PROP_TAG(PT_BOOLEAN,      0x8120)
#define PR_EMS_AB_REPORT_TO_OWNER             PROP_TAG(PT_BOOLEAN,      0x8121)
#define PR_EMS_AB_REPORTS                     PROP_TAG(PT_OBJECT,       0x800E)
#define PR_EMS_AB_REPORTS_A                   PROP_TAG(PT_MV_STRING8,   0x800E)
#define PR_EMS_AB_REPORTS_W                   PROP_TAG(PT_MV_UNICODE,   0x800E)
#define PR_EMS_AB_REPORTS_O                   PROP_TAG(PT_OBJECT,       0x800E)
#define PR_EMS_AB_REPORTS_T                   PROP_TAG(PT_MV_TSTRING,   0x800E)
#define PR_EMS_AB_REQ_SEQ                     PROP_TAG(PT_LONG,         0x8122)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA       PROP_TAG(PT_TSTRING,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_A     PROP_TAG(PT_STRING8,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_W     PROP_TAG(PT_UNICODE,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_O     PROP_TAG(PT_OBJECT,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_T     PROP_TAG(PT_TSTRING,      0x8123)
#define PR_EMS_AB_RID_SERVER                  PROP_TAG(PT_TSTRING,      0x8124)
#define PR_EMS_AB_RID_SERVER_A                PROP_TAG(PT_STRING8,      0x8124)
#define PR_EMS_AB_RID_SERVER_W                PROP_TAG(PT_UNICODE,      0x8124)
#define PR_EMS_AB_RID_SERVER_O                PROP_TAG(PT_OBJECT,       0x8124)
#define PR_EMS_AB_RID_SERVER_T                PROP_TAG(PT_TSTRING,      0x8124)
#define PR_EMS_AB_ROLE_OCCUPANT               PROP_TAG(PT_MV_TSTRING,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_A             PROP_TAG(PT_MV_STRING8,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_W             PROP_TAG(PT_MV_UNICODE,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_O             PROP_TAG(PT_OBJECT,       0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_T             PROP_TAG(PT_MV_TSTRING,   0x8125)
#define PR_EMS_AB_ROUTING_LIST                PROP_TAG(PT_MV_TSTRING,   0x8126)
#define PR_EMS_AB_ROUTING_LIST_A              PROP_TAG(PT_MV_STRING8,   0x8126)
#define PR_EMS_AB_ROUTING_LIST_W              PROP_TAG(PT_MV_UNICODE,   0x8126)
#define PR_EMS_AB_RTS_CHECKPOINT_SIZE         PROP_TAG(PT_LONG,         0x8127)
#define PR_EMS_AB_RTS_RECOVERY_TIMEOUT        PROP_TAG(PT_LONG,         0x8128)
#define PR_EMS_AB_RTS_WINDOW_SIZE             PROP_TAG(PT_LONG,         0x8129)
#define PR_EMS_AB_RUNS_ON                     PROP_TAG(PT_MV_TSTRING,   0x812A)
#define PR_EMS_AB_RUNS_ON_A                   PROP_TAG(PT_MV_STRING8,   0x812A)
#define PR_EMS_AB_RUNS_ON_W                   PROP_TAG(PT_MV_UNICODE,   0x812A)
#define PR_EMS_AB_RUNS_ON_O                   PROP_TAG(PT_OBJECT,       0x812A)
#define PR_EMS_AB_RUNS_ON_T                   PROP_TAG(PT_MV_TSTRING,   0x812A)
#define PR_EMS_AB_S_SELECTOR                  PROP_TAG(PT_BINARY,       0x812B)
#define PR_EMS_AB_S_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x812C)
#define PR_EMS_AB_SEARCH_FLAGS                PROP_TAG(PT_LONG,         0x812D)
#define PR_EMS_AB_SEARCH_GUIDE                PROP_TAG(PT_MV_BINARY,    0x812E)
#define PR_EMS_AB_SECURITY_PROTOCOL           PROP_TAG(PT_MV_BINARY,    0x8037)
#define PR_EMS_AB_SEE_ALSO                    PROP_TAG(PT_MV_TSTRING,   0x812F)
#define PR_EMS_AB_SEE_ALSO_A                  PROP_TAG(PT_MV_STRING8,   0x812F)
#define PR_EMS_AB_SEE_ALSO_W                  PROP_TAG(PT_MV_UNICODE,   0x812F)
#define PR_EMS_AB_SEE_ALSO_O                  PROP_TAG(PT_OBJECT,       0x812F)
#define PR_EMS_AB_SEE_ALSO_T                  PROP_TAG(PT_MV_TSTRING,   0x812F)
#define PR_EMS_AB_SERIAL_NUMBER               PROP_TAG(PT_MV_TSTRING,   0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_A             PROP_TAG(PT_MV_STRING8,   0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_W             PROP_TAG(PT_MV_UNICODE,   0x8130)
#define PR_EMS_AB_SERVICE_ACTION_FIRST        PROP_TAG(PT_LONG,         0x8131)
#define PR_EMS_AB_SERVICE_ACTION_OTHER        PROP_TAG(PT_LONG,         0x8132)
#define PR_EMS_AB_SERVICE_ACTION_SECOND       PROP_TAG(PT_LONG,         0x8133)
#define PR_EMS_AB_SERVICE_RESTART_DELAY       PROP_TAG(PT_LONG,         0x8134)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE     PROP_TAG(PT_TSTRING,      0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_A   PROP_TAG(PT_STRING8,      0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_W   PROP_TAG(PT_UNICODE,      0x8135)
#define PR_EMS_AB_SESSION_DISCONNECT_TIMER    PROP_TAG(PT_LONG,         0x8136)
#define PR_EMS_AB_SITE_AFFINITY               PROP_TAG(PT_MV_TSTRING,   0x8137)
#define PR_EMS_AB_SITE_AFFINITY_A             PROP_TAG(PT_MV_STRING8,   0x8137)
#define PR_EMS_AB_SITE_AFFINITY_W             PROP_TAG(PT_MV_UNICODE,   0x8137)
#define PR_EMS_AB_SITE_FOLDER_GUID            PROP_TAG(PT_BINARY,       0x8166)
#define PR_EMS_AB_SITE_FOLDER_SERVER          PROP_TAG(PT_TSTRING,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_A        PROP_TAG(PT_STRING8,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_W        PROP_TAG(PT_UNICODE,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_O        PROP_TAG(PT_OBJECT,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_T        PROP_TAG(PT_TSTRING,      0x8167)
#define PR_EMS_AB_SITE_PROXY_SPACE            PROP_TAG(PT_MV_TSTRING,   0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_A          PROP_TAG(PT_MV_STRING8,   0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_W          PROP_TAG(PT_MV_UNICODE,   0x8138)
#define PR_EMS_AB_SPACE_LAST_COMPUTED         PROP_TAG(PT_SYSTIME,      0x8139)
#define PR_EMS_AB_STREET_ADDRESS              PROP_TAG(PT_TSTRING,      0x813A)
#define PR_EMS_AB_STREET_ADDRESS_A            PROP_TAG(PT_STRING8,      0x813A)
#define PR_EMS_AB_STREET_ADDRESS_W            PROP_TAG(PT_UNICODE,      0x813A)
#define PR_EMS_AB_SUB_REFS                    PROP_TAG(PT_MV_TSTRING,   0x813B)
#define PR_EMS_AB_SUB_REFS_A                  PROP_TAG(PT_MV_STRING8,   0x813B)
#define PR_EMS_AB_SUB_REFS_W                  PROP_TAG(PT_MV_UNICODE,   0x813B)
#define PR_EMS_AB_SUB_REFS_O                  PROP_TAG(PT_OBJECT,       0x813B)
#define PR_EMS_AB_SUB_REFS_T                  PROP_TAG(PT_MV_TSTRING,   0x813B)
#define PR_EMS_AB_SUBMISSION_CONT_LENGTH      PROP_TAG(PT_LONG,         0x813C)
#define PR_EMS_AB_SUPPORTED_APPLICATION_CONTEXT PROP_TAG(PT_MV_BINARY,  0x813D)
#define PR_EMS_AB_SUPPORTING_STACK            PROP_TAG(PT_MV_TSTRING,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_A          PROP_TAG(PT_MV_STRING8,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_W          PROP_TAG(PT_MV_UNICODE,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_O          PROP_TAG(PT_OBJECT,       0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_T          PROP_TAG(PT_MV_TSTRING,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_BL         PROP_TAG(PT_MV_TSTRING,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_A       PROP_TAG(PT_MV_STRING8,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_W       PROP_TAG(PT_MV_UNICODE,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_O       PROP_TAG(PT_OBJECT,       0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_T       PROP_TAG(PT_MV_TSTRING,   0x813F)
#define PR_EMS_AB_T_SELECTOR                  PROP_TAG(PT_BINARY,       0x8140)
#define PR_EMS_AB_T_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x8141)
#define PR_EMS_AB_TARGET_ADDRESS              PROP_TAG(PT_TSTRING,      0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_A            PROP_TAG(PT_STRING8,      0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_W            PROP_TAG(PT_UNICODE,      0x8011)
#define PR_EMS_AB_TARGET_MTAS                 PROP_TAG(PT_MV_TSTRING,   0x8142)
#define PR_EMS_AB_TARGET_MTAS_A               PROP_TAG(PT_MV_STRING8,   0x8142)
#define PR_EMS_AB_TARGET_MTAS_W               PROP_TAG(PT_MV_UNICODE,   0x8142)
#define PR_EMS_AB_TELEPHONE_NUMBER            PROP_TAG(PT_MV_TSTRING,   0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_A          PROP_TAG(PT_MV_STRING8,   0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_W          PROP_TAG(PT_MV_UNICODE,   0x8012)
#define PR_EMS_AB_TELETEX_TERMINAL_IDENTIFIER PROP_TAG(PT_MV_BINARY,    0x8143)
#define PR_EMS_AB_TEMP_ASSOC_THRESHOLD        PROP_TAG(PT_LONG,         0x8144)
#define PR_EMS_AB_TOMBSTONE_LIFETIME          PROP_TAG(PT_LONG,         0x8145)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME      PROP_TAG(PT_TSTRING,      0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_A    PROP_TAG(PT_STRING8,      0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_W    PROP_TAG(PT_UNICODE,      0x8146)
#define PR_EMS_AB_TRANS_RETRY_MINS            PROP_TAG(PT_LONG,         0x8147)
#define PR_EMS_AB_TRANS_TIMEOUT_MINS          PROP_TAG(PT_LONG,         0x8148)
#define PR_EMS_AB_TRANSFER_RETRY_INTERVAL     PROP_TAG(PT_LONG,         0x8149)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NON_URGENT PROP_TAG(PT_LONG,         0x814A)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NORMAL     PROP_TAG(PT_LONG,         0x814B)
#define PR_EMS_AB_TRANSFER_TIMEOUT_URGENT     PROP_TAG(PT_LONG,         0x814C)
#define PR_EMS_AB_TRANSLATION_TABLE_USED      PROP_TAG(PT_LONG,         0x814D)
#define PR_EMS_AB_TRANSPORT_EXPEDITED_DATA    PROP_TAG(PT_BOOLEAN,      0x814E)
#define PR_EMS_AB_TRUST_LEVEL                 PROP_TAG(PT_LONG,         0x814F)
#define PR_EMS_AB_TURN_REQUEST_THRESHOLD      PROP_TAG(PT_LONG,         0x8150)
#define PR_EMS_AB_TWO_WAY_ALTERNATE_FACILITY  PROP_TAG(PT_BOOLEAN,      0x8151)
#define PR_EMS_AB_UNAUTH_ORIG_BL              PROP_TAG(PT_MV_TSTRING,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_A            PROP_TAG(PT_MV_STRING8,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_W            PROP_TAG(PT_MV_UNICODE,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_O            PROP_TAG(PT_OBJECT,       0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_T            PROP_TAG(PT_MV_TSTRING,   0x8152)
#define PR_EMS_AB_USER_PASSWORD               PROP_TAG(PT_MV_BINARY,    0x8153)
#define PR_EMS_AB_USN_CHANGED                 PROP_TAG(PT_LONG,         0x8029)
#define PR_EMS_AB_USN_CREATED                 PROP_TAG(PT_LONG,         0x8154)
#define PR_EMS_AB_USN_DSA_LAST_OBJ_REMOVED    PROP_TAG(PT_LONG,         0x8155)
#define PR_EMS_AB_USN_LAST_OBJ_REM            PROP_TAG(PT_LONG,         0x8156)
#define PR_EMS_AB_USN_SOURCE                  PROP_TAG(PT_LONG,         0x8157)
#define PR_EMS_AB_X121_ADDRESS                PROP_TAG(PT_MV_TSTRING,   0x8158)
#define PR_EMS_AB_X121_ADDRESS_A              PROP_TAG(PT_MV_STRING8,   0x8158)
#define PR_EMS_AB_X121_ADDRESS_W              PROP_TAG(PT_MV_UNICODE,   0x8158)
#define PR_EMS_AB_X25_CALL_USER_DATA_INCOMING PROP_TAG(PT_BINARY,       0x8159)
#define PR_EMS_AB_X25_CALL_USER_DATA_OUTGOING PROP_TAG(PT_BINARY,       0x815A)
#define PR_EMS_AB_X25_FACILITIES_DATA_INCOMING PROP_TAG(PT_BINARY,      0x815B)
#define PR_EMS_AB_X25_FACILITIES_DATA_OUTGOING PROP_TAG(PT_BINARY,      0x815C)
#define PR_EMS_AB_X25_LEASED_LINE_PORT        PROP_TAG(PT_BINARY,       0x815D)
#define PR_EMS_AB_X25_LEASED_OR_SWITCHED      PROP_TAG(PT_BOOLEAN,      0x815E)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE        PROP_TAG(PT_TSTRING,      0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_A      PROP_TAG(PT_STRING8,      0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_W      PROP_TAG(PT_UNICODE,      0x815F)
#define PR_EMS_AB_X400_ATTACHMENT_TYPE        PROP_TAG(PT_BINARY,       0x8160)
#define PR_EMS_AB_X400_SELECTOR_SYNTAX        PROP_TAG(PT_LONG,         0x8161)
#define PR_EMS_AB_X500_ACCESS_CONTROL_LIST    PROP_TAG(PT_BINARY,       0x8162)
#define PR_EMS_AB_XMIT_TIMEOUT_NON_URGENT     PROP_TAG(PT_LONG,         0x8163)
#define PR_EMS_AB_XMIT_TIMEOUT_NORMAL         PROP_TAG(PT_LONG,         0x8164)
#define PR_EMS_AB_XMIT_TIMEOUT_URGENT         PROP_TAG(PT_LONG,         0x8165)

#endif /* _EMSABTAG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wabmig\wabguid.c ===
// This builds wabguid.obj, which can be linked into a DLL
// or EXE to provide the MAPI GUIDs. It contains all GUIDs
// defined by WAB.


#define USES_IID_IUnknown
#define USES_IID_IMAPIUnknown
#define USES_IID_IMAPITable
#define USES_IID_INotifObj
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPIStatus
#define USES_IID_IAddrBook
#define USES_IID_IMailUser
#define USES_IID_IMAPIContainer
#define USES_IID_IABContainer
#define USES_IID_IDistList
#define USES_IID_IMAPITableData
#define USES_IID_IMAPIAdviseSink

#define USES_PS_PUBLIC_STRINGS

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#define INITGUID
#include <windows.h>
#include <wab.h>
#include <wabguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wabmig\export.c ===
/*
 *  EXPORT.C
 *
 *  Migrate WAB to PAB
 *
 *  Copyright 1996-1997 Microsoft Corporation.  All Rights Reserved.
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#include "_wabmig.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"


BOOL HandleExportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName, LPTSTR lpEmailAddress);
LPWAB_EXPORT lpfnExport = NULL;


/***************************************************************************

    Name      : ExportFinish

    Purpose   : Clean up after the migration process

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Re-enable the Export button on the UI.

***************************************************************************/
void ExportFinish(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    TCHAR szBufferTitle[MAX_RESOURCE_STRING + 1];


    DebugTrace(">>> Export Finished\n");

    if (! fError) {     // Leave error state displayed
        if (LoadString(hInst, IDS_STATE_EXPORT_COMPLETE, szBuffer, sizeof(szBuffer))) {
            DebugTrace("Status Message: %s\n", szBuffer);
            SetDlgItemText(hwnd, IDC_Message, szBuffer);

            if (! LoadString(hInst, IDS_APP_TITLE, szBufferTitle, sizeof(szBufferTitle))) {
                lstrcpy(szBufferTitle, "");
            }

            // Display a dialog telling user it's over
            MessageBox(hwnd, szBuffer,
              szBufferTitle, MB_ICONINFORMATION | MB_OK);
        }
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);
    }
    fError = FALSE;

    fMigrating = FALSE;

    // Re-enable the Export button here.
    EnableWindow(GetDlgItem(hwnd, IDC_Export), TRUE);
    // Change the Cancel button to Close
    if (LoadString(hInst, IDS_BUTTON_CLOSE, szBuffer, sizeof(szBuffer))) {
        SetDlgItemText(hwnd, IDCANCEL, szBuffer);
    }
}


/***************************************************************************

    Name      : ExportError

    Purpose   : Report fatal error and cleanup.

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Report error and post STATE_EXPORT_FINISH.

***************************************************************************/
void ExportError(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace("Export Error\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_EXPORT_ERROR);

    ExportFinish(hwnd);
}


/***************************************************************************

    Name      : ExportCancel

    Purpose   : Report cancel error and cleanup.

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Report error and post STATE_EXPORT_FINISH.

***************************************************************************/
void ExportCancel(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace("Export Cancelled\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_EXPORT_CANCEL);

    ExportFinish(hwnd);
}


INT_PTR CALLBACK ExportDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    static HWND hwndLB = NULL;
    HRESULT hResult;

    Assert(fExport);

//    DebugTrace("Export MSG: 0x%04x, 0x%04x, 0x%08x\n", message, (WORD)wParam, lParam);
    switch (message) {
        case WM_INITDIALOG:
            {
                SetWindowLongPtr(hwnd, DWLP_USER, lParam);

                InitCommonControls();
                SetDialogMessage(hwnd, IDS_STATE_EXPORT_IDLE);

                // Fill in the Target List box
                hwndLB = GetDlgItem(hwnd, IDC_Target);
                PopulateTargetList(hwndLB, NULL);

                ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);

                return(TRUE);
            }

        case WM_COMMAND :
            switch (LOWORD(wParam)) {
                case IDCANCEL:
                case IDCLOSE:
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDM_EXIT :
                    SendMessage(hwnd, WM_DESTROY, 0, 0L);
                    return(0);

                case IDC_Export:
                    {
                        LPWAB_EXPORT lpfnWABExport = NULL;
                        HINSTANCE hinstExportDll = NULL;
                        DWORD ec;
                        TCHAR szBuffer[MAX_RESOURCE_STRING + 1];

                        if (fMigrating) {
                            return(0);          // ignore if we're already migrating
                        }
                        fMigrating = TRUE;      // lock out

                        // reset options
                        ExportOptions.ReplaceOption = WAB_REPLACE_PROMPT;
                        ExportOptions.fNoErrors = FALSE;

                        // Gray out the button here.
                        EnableWindow(GetDlgItem(hwnd, IDC_Export), FALSE);
                        // Change the Close button to Cancel
                        if (LoadString(hInst, IDS_BUTTON_CANCEL, szBuffer, sizeof(szBuffer))) {
                            SetDlgItemText(hwnd, IDCANCEL, szBuffer);
                        }

                        if (lpExportDll && lpExportFn) {
                            if (! (hinstExportDll = LoadLibrary(lpExportDll))) {
                                DebugTrace("Couldn't load export dll [%s] -> %u\n", lpExportDll, GetLastError());
                                switch (GetLastError()) {
                                    case ERROR_FILE_NOT_FOUND:
                                        if (HandleExportError(hwnd,
                                          IDS_ERROR_DLL_NOT_FOUND,
                                          0,
                                          lpExportDll,
                                          NULL)) {
                                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                            ExportCancel(hwnd);
                                        } else {
                                            ExportError(hwnd);
                                        }
                                        break;

                                    default:
                                        if (HandleExportError(hwnd,
                                          IDS_ERROR_DLL_INVALID,
                                          0,
                                          lpExportDll,
                                          NULL)) {
                                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                            ExportCancel(hwnd);
                                        } else {
                                            ExportError(hwnd);
                                        }
                                        break;
                                }
                            } else {
                                if (! (lpfnWABExport = (LPWAB_EXPORT)GetProcAddress(hinstExportDll,
                                  lpExportFn))) {
                                    DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", lpExportFn, lpExportDll, GetLastError());
                                    switch (GetLastError()) {
                                        default:
                                            if (HandleExportError(hwnd,
                                              IDS_ERROR_DLL_INVALID,
                                              0,
                                              lpExportDll,
                                              NULL)) {
                                                hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                                ExportCancel(hwnd);
                                            } else {
                                                ExportError(hwnd);
                                            }
                                            break;
                                    }
                                } else {
                                    // Do it!
                                    __try
                                    {
                                        HRESULT hResult;
                                        BOOL fFinished = FALSE;
                                        WAB_PARAM wp = {0};
                                        LPWAB_PARAM lpwp = NULL;

                                        {
                                            LPWABMIGDLGPARAM lpwmdp = (LPWABMIGDLGPARAM) GetWindowLongPtr(hwnd, DWLP_USER);
                                            LPTSTR lpszFileName = lpwmdp->szFileName;
                                            wp.cbSize = sizeof(WAB_PARAM);
                                            wp.hwnd = hwnd;
                                            if(lstrlen(lpszFileName))
                                            {
                                                // we have a file name - use it to open the WAB
                                                wp.szFileName = lpszFileName;
                                                wp.ulFlags = 0;
                                            }
                                            else
                                            {
                                                wp.ulFlags = WAB_ENABLE_PROFILES;
                                            }
                                            lpwp = &wp;
                                        }

                                        hResult = lpfnWABOpen(&lpAdrBookWAB, &lpWABObject, lpwp, 0);
                                        if (SUCCEEDED(hResult))
                                        {
                                            if (hResult = lpfnWABExport(hwnd,
                                              lpAdrBookWAB,
                                              lpWABObject,
                                              (LPWAB_PROGRESS_CALLBACK)&ProgressCallback,
                                              &ExportOptions)) {

                                                switch (GetScode(hResult))
                                                {
                                                    case MAPI_E_USER_CANCEL:
                                                        ExportCancel(hwnd);
                                                        break;

                                                    default:
                                                        ExportError(hwnd);
                                                        DebugTrace("Exporter DLL returned %x\n", GetScode(hResult));
                                                        break;
                                                }

                                                fFinished = TRUE;
                                            }

                                            lpAdrBookWAB->lpVtbl->Release(lpAdrBookWAB);
                                            lpAdrBookWAB = NULL;
                                            lpWABObject->lpVtbl->Release(lpWABObject);
                                            lpWABObject = NULL;
                                            if (!fFinished)
                                            {
                                                // Make progress bar full.
                                                SendMessage(GetDlgItem(hwnd, IDC_Progress), PBM_SETRANGE, 0, MAKELPARAM(0, 100));
                                                SendMessage(GetDlgItem(hwnd, IDC_Progress), PBM_SETPOS, (WPARAM)100, 0);
                                                ExportFinish(hwnd);
                                            }
                                        }
                                        else
                                        {
                                            // Report fatal error
                                            TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
                                            TCHAR szBufferTitle[MAX_RESOURCE_STRING + 1];

                                            if (LoadString(hInst, IDS_STATE_EXPORT_ERROR, szBuffer, sizeof(szBuffer)))
                                            {
                                                SetDlgItemText(hwnd, IDC_Message, szBuffer);
                                                if (! LoadString(hInst, IDS_APP_TITLE, szBufferTitle, sizeof(szBufferTitle)))
                                                {
                                                    lstrcpy(szBufferTitle, "");
                                                }

                                                // Display a dialog telling user it's over
                                                MessageBox(hwnd, szBuffer,
                                                  szBufferTitle, MB_ICONINFORMATION | MB_OK);
                                            }

                                            fError = TRUE;
                                            ExportFinish(hwnd);
                                        }
                                    }
                                    __except (ec = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
                                    {
                                        DebugTrace("Exception 0x%08x in %s\n", ec, lpExportDll);
                                        if (HandleExportError(hwnd,
                                          IDS_ERROR_DLL_EXCEPTION,
                                          0,
                                          lpExportDll,
                                          NULL))
                                        {
                                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                            ExportCancel(hwnd);
                                        }
                                        else
                                        {
                                            ExportError(hwnd);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return(0);

                case IDC_Target:
                    switch (HIWORD(wParam)) {   // look for selection change
                        case LBN_SELCHANGE:
                            {
                                ULONG ulSelIndex, ulTableIndex;
                                TCHAR szCurSel[256];

                                // Enable the Export Button if it is disabled. The 'Export' Button is disabled initially.
                                HWND hButton = GetDlgItem(hwnd, IDC_Export);
                                if(hButton)
                                {
                                    if(!IsWindowEnabled(hButton))
                                        EnableWindow(hButton, TRUE);
                                }

                                //
                                // Get the text of the selected item in the listbox...
                                //
                                ulSelIndex = (ULONG) SendMessage((HWND)lParam, LB_GETCURSEL, 0, 0);
                                ulTableIndex = (ULONG) SendMessage((HWND)lParam, LB_GETITEMDATA, (WPARAM)ulSelIndex, 0);

                                SendMessage((HWND)lParam,
                                  LB_GETTEXT,
                                  (WPARAM)ulSelIndex,
                                  (LPARAM)szCurSel);
                                DebugTrace("Current selection is [%s]\n", szCurSel);

                                lpExportDll = rgTargetInfo[ulTableIndex].lpDll;
                                lpExportDesc = rgTargetInfo[ulTableIndex].lpDescription;
                                lpExportFn = rgTargetInfo[ulTableIndex].lpEntry;
                                lpExportName = rgTargetInfo[ulTableIndex].lpRegName;

                                SendMessage(hwnd, WM_SETREDRAW, TRUE, 0L);
                            }
                            break;

                        case LBN_DBLCLK:
                            PostMessage(hwnd, WM_COMMAND, (WPARAM)IDC_Export, 0);
                            break;
                    }
                    break;
                }
            break;

        case WM_CLOSE:
            if (fMigrating) {
                SendMessage(hwnd, WM_COMMAND, ID_STATE_EXPORT_FINISH, 0);
            }
            EndDialog(hwnd, FALSE);
            return(0);

        case WM_DESTROY:
            FreeLBItemData(hwndLB);
            return(DefWindowProc(hwnd, message, wParam, lParam));

        default:
            return(FALSE);
    }

    return(TRUE);
}


/***************************************************************************

    Name      : HandleExportError

    Purpose   : Decides if a dialog needs to be displayed to
                indicate the failure and does so.

    Parameters: hwnd = main dialog window
                ids = String ID (optional: calculated from hResult if 0)
                hResult = Result of action
                lpDisplayName = display name of object that failed
                lpEmailAddress = email address of object that failed (or NULL)

    Returns   : TRUE if user requests ABORT.

    Comment   : Abort is not yet implemented in the dialog, but if you
                ever want to, just make this routine return TRUE;

***************************************************************************/
BOOL HandleExportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName, LPTSTR lpEmailAddress) {
    BOOL fAbort = FALSE;
    ERROR_INFO EI;

    if ((ids || hResult) && ! ExportOptions.fNoErrors) {
        if (ids == 0) {
            switch (GetScode(hResult)) {
                case WAB_W_BAD_EMAIL:
                    ids = lpEmailAddress ? IDS_ERROR_EMAIL_ADDRESS_2 : IDS_ERROR_EMAIL_ADDRESS_1;
                    break;

                case MAPI_E_NO_SUPPORT:
                    // Propbably failed to open contents on a distribution list
                    ids = IDS_ERROR_NO_SUPPORT;
                    break;

                case MAPI_E_USER_CANCEL:
                    return(TRUE);

                default:
                    if (HR_FAILED(hResult)) {
                        DebugTrace("Error Box for Hresult: 0x%08x\n", GetScode(hResult));
                        Assert(FALSE);      // want to know about it.
                        ids = IDS_ERROR_GENERAL;
                    }
                    break;
            }
        }

        EI.lpszDisplayName = lpDisplayName;
        EI.lpszEmailAddress = lpEmailAddress;
        EI.ErrorResult = ERROR_OK;
        EI.ids = ids;

        DialogBoxParam(hInst,
          MAKEINTRESOURCE(IDD_ErrorExport),
          hwnd,
          ErrorDialogProc,
          (LPARAM)&EI);

        fAbort = EI.ErrorResult == ERROR_ABORT;
    }

    return(fAbort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wabmig\wabmig.c ===
/*
 *  WABMIG.C
 *
 *  Migrate PAB to WAB
 *
 *  Copyright 1996-1997 Microsoft Corporation.  All Rights Reserved.
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#define _WABMIG_C   TRUE
#include "_wabmig.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"
#include <shlwapi.h>

#define WinMainT WinMain

const TCHAR szDescription[] = "description";
const TCHAR szDll[] = "dll";
const TCHAR szEntry[] = "entry";
const TCHAR szEXPORT[] = "EXPORT";
const TCHAR szIMPORT[] = "IMPORT";
const TCHAR szPROFILEID[] = "PID:";
const TCHAR szFILE[] = "File:";
const TCHAR szEmpty[] = "";


// Globals
WAB_IMPORT_OPTIONS ImportOptions = {WAB_REPLACE_PROMPT,   // replace option
                                    FALSE};               // No more errors

WAB_EXPORT_OPTIONS ExportOptions = {WAB_REPLACE_PROMPT,   // replace option
                                    FALSE};               // No more errors

const LPTSTR szWABKey = "Software\\Microsoft\\WAB";
LPTARGET_INFO rgTargetInfo = NULL;


HINSTANCE hInst;
HINSTANCE hInstApp;

BOOL fMigrating = FALSE;
BOOL fError = FALSE;
BOOL fExport = FALSE;

LPADRBOOK lpAdrBookWAB = NULL;
LPWABOBJECT lpWABObject = NULL;

LPTSTR lpImportDll = NULL;
LPTSTR lpImportFn = NULL;
LPTSTR lpImportDesc = NULL;
LPTSTR lpImportName = NULL;
LPTSTR lpExportDll = NULL;
LPTSTR lpExportFn = NULL;
LPTSTR lpExportDesc = NULL;
LPTSTR lpExportName = NULL;


//
//  Global WAB Allocator access functions
//
typedef struct _WAB_ALLOCATORS {
    LPWABOBJECT lpWABObject;
    LPWABALLOCATEBUFFER lpAllocateBuffer;
    LPWABALLOCATEMORE lpAllocateMore;
    LPWABFREEBUFFER lpFreeBuffer;
} WAB_ALLOCATORS, *LPWAB_ALLOCATORS;

WAB_ALLOCATORS WABAllocators = {0};


/***************************************************************************

    Name      : SetGlobalBufferFunctions

    Purpose   : Set the global buffer functions based on methods from
                the WAB object.

    Parameters: lpWABObject = the open wab object

    Returns   : none

    Comment   :

***************************************************************************/
void SetGlobalBufferFunctions(LPWABOBJECT lpWABObject) {
    if (lpWABObject && ! WABAllocators.lpWABObject) {
        WABAllocators.lpAllocateBuffer = lpWABObject->lpVtbl->AllocateBuffer;
        WABAllocators.lpAllocateMore = lpWABObject->lpVtbl->AllocateMore;
        WABAllocators.lpFreeBuffer = lpWABObject->lpVtbl->FreeBuffer;
        WABAllocators.lpWABObject = lpWABObject;
    }
}


/***************************************************************************

    Name      : WABAllocateBuffer

    Purpose   : Use the WAB Allocator

    Parameters: cbSize = size to allocate
                lppBuffer = returned buffer

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABAllocateBuffer(ULONG cbSize, LPVOID FAR * lppBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpAllocateBuffer) {
        return(WABAllocators.lpAllocateBuffer(WABAllocators.lpWABObject, cbSize, lppBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
        DebugTrace("WAB Allocators not set up!\n");
        Assert(FALSE);
    }
}


/***************************************************************************

    Name      : WABAllocateMore

    Purpose   : Use the WAB Allocator

    Parameters: cbSize = size to allocate
                lpObject = existing allocation
                lppBuffer = returned buffer

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABAllocateMore(ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpAllocateMore) {
        return(WABAllocators.lpAllocateMore(WABAllocators.lpWABObject, cbSize, lpObject, lppBuffer));
    } else {
        DebugTrace("WAB Allocators not set up!\n");
        Assert(FALSE);
        return(MAPI_E_INVALID_OBJECT);
    }
}


/***************************************************************************

    Name      : WABFreeBuffer

    Purpose   : Use the WAB Allocator

    Parameters: lpBuffer = buffer to free

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABFreeBuffer(LPVOID lpBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpFreeBuffer) {
        return(WABAllocators.lpFreeBuffer(WABAllocators.lpWABObject, lpBuffer));
    } else {
        DebugTrace("WAB Allocators not set up!\n");
        Assert(FALSE);
        return(MAPI_E_INVALID_OBJECT);
    }
}


/***************************************************************************

    Name      : StrICmpN

    Purpose   : Compare strings, ignore case, stop at N characters

    Parameters: szString1 = first string
                szString2 = second string
                N = number of characters to compare

    Returns   : 0 if first N characters of strings are equivalent.

    Comment   :

***************************************************************************/
int StrICmpN(LPTSTR szString1, LPTSTR szString2, ULONG N) {
    int Result = 0;

    if (szString1 && szString2) {
        while (*szString1 && *szString2 && N) 
        {
            N--;

            if (toupper(*szString1) != toupper(*szString2)) {
                Result = 1;
                break;
            }
            szString1++;
            szString2++;
        }
    } else {
        Result = -1;    // arbitrarily non-equal result
    }

    return(Result);
}


/***************************************************************************

    Name      : AllocRegValue

    Purpose   : Allocate space for and query the registry value

    Parameters: hKey = registry key to query
                lpValueName = name of value to query
                lppString -> returned buffer string (caller must LocalFree)

    Returns   : TRUE on success, FALSE on error

    Comment   :

***************************************************************************/
BOOL AllocRegValue(HKEY hKey, LPTSTR lpValueName, LPTSTR * lppString) {
    TCHAR szTemp[1];
    ULONG ulSize = 1;             // Expect ERROR_MORE_DATA
    DWORD dwErr;
    DWORD dwType;

    if (dwErr = RegQueryValueEx(hKey,
      (LPTSTR)lpValueName,    // name of value
      NULL,
      &dwType,
      szTemp,
      &ulSize)) {
        if (dwErr == ERROR_MORE_DATA) {
            if (! (*lppString = LocalAlloc(LPTR, ulSize))) {
                DebugTrace("AllocRegValue can't allocate string -> %u\n", GetLastError());
            } else {
                // Try again with sufficient buffer
                if (! RegQueryValueEx(hKey,
                  lpValueName,
                  NULL,
                  &dwType,
                  *lppString,
                  &ulSize)) {
                    if (dwType != REG_SZ) {
                        LocalFree(*lppString);
                        *lppString = NULL;
                    } else {
                        return(TRUE);
                    }
                }
            }
        }
    }
    return(FALSE);
}


HRESULT ProgressCallback(HWND hwnd, LPWAB_PROGRESS lpProgress) {
    MSG msg;

    if (lpProgress->lpText) {
        DebugTrace("Status Message: %s\n", lpProgress->lpText);
        SetDlgItemText(hwnd, IDC_Message, lpProgress->lpText);
    }

    if (lpProgress->denominator) {
        if (lpProgress->numerator == 0) {
            ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_SHOW);
        }

        SendMessage(GetDlgItem(hwnd, IDC_Progress), PBM_SETRANGE, 0, MAKELPARAM(0, min(lpProgress->denominator, 32767)));
        SendMessage(GetDlgItem(hwnd, IDC_Progress), PBM_SETSTEP, (WPARAM)1, 0);
        SendMessage(GetDlgItem(hwnd, IDC_Progress), PBM_SETPOS, (WPARAM)min(lpProgress->numerator, lpProgress->denominator), 0);
    }

    // msgpump to process user moving window, or pressing cancel... :)
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return(hrSuccess);
}


/***************************************************************************

    Name      : SetDialogMessage

    Purpose   : Sets the message text for the dialog box item IDC_Message

    Parameters: hwnd = window handle of dialog
                ids = stringid of message resource

    Returns   : none

***************************************************************************/
void SetDialogMessage(HWND hwnd, int ids) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];

    if (LoadString(hInst, ids, szBuffer, sizeof(szBuffer))) {
        DebugTrace("Status Message: %s\n", szBuffer);
        if (! SetDlgItemText(hwnd, IDC_Message, szBuffer)) {
            DebugTrace("SetDlgItemText -> %u\n", GetLastError());
        }
    } else {
        DebugTrace("Cannot load resource string %u\n", ids);
        Assert(FALSE);
    }
}


/////////////////////////////////////////////////////////////////////////
// GetWABDllPath - loads the WAB DLL path from the registry
// szPath	- ptr to buffer
// cb		- sizeof buffer
//
void GetWABDllPath(LPTSTR szPath, ULONG cb)
{
    DWORD  dwType = 0;
    HKEY hKey = NULL;
    TCHAR szPathT[MAX_PATH];
    ULONG  cbData = sizeof(szPathT);
    if(szPath)
    {
        *szPath = '\0';
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
        {
            if(ERROR_SUCCESS == RegQueryValueEx( hKey, "", NULL, &dwType, (LPBYTE) szPathT, &cbData))
            {
                if (dwType == REG_EXPAND_SZ)
                    cbData = ExpandEnvironmentStrings(szPathT, szPath, cb / sizeof(TCHAR));
                else
                {
                    if(GetFileAttributes(szPathT) != 0xFFFFFFFF)
                        lstrcpy(szPath, szPathT);
                }
            }
        }
    }
    if(hKey) RegCloseKey(hKey);
	return;
}

///////////////////////////////////////////////////////////////////////////
// LoadLibrary_WABDll() - Load the WAB library based on the WAB DLL path
//
HINSTANCE LoadLibrary_WABDll()
{
    TCHAR  szWABDllPath[MAX_PATH];
    HINSTANCE hinst = NULL;

    GetWABDllPath(szWABDllPath, sizeof(szWABDllPath));

    return(hinst = LoadLibrary( (lstrlen(szWABDllPath)) ? szWABDllPath : WAB_DLL_NAME));
}

/*
-
-   bSearchCmdLine - searches for given arg in given line and returns
*   data after the arg
*/
BOOL bSearchCmdLine(LPTSTR lpCmdLine, LPTSTR szArg, LPTSTR szData)
{
    LPTSTR lpCmd = NULL, lp = NULL, lpTemp = NULL;
    BOOL fRet = FALSE;
    if(!lpCmdLine || !lstrlen(lpCmdLine) || !szArg || !lstrlen(szArg))
        return FALSE;

    if(!(lpCmd = LocalAlloc(LMEM_ZEROINIT, lstrlen(lpCmdLine)+1)))
        return FALSE;

    lstrcpy(lpCmd, lpCmdLine);
    
    lpTemp = lpCmd;
    while(lpTemp && *lpTemp)
    {
        if (! StrICmpN(lpTemp, (LPTSTR)szArg, lstrlen(szArg))) 
        {
            fRet = TRUE;
            lpTemp += lstrlen(szArg);     // move past the switch
            if(szData)
            {
                lp = lpTemp;
                while(lp && *lp && *lp!='\0' && *lp!='+') //delimiter is a '+' so we dont mess up long file names
                    lp++;
                *lp = '\0';
                if(lstrlen(lpTemp))
                    lstrcpy(szData, lpTemp);
            }
            break;
        }
        lpTemp++;
    }

    LocalFree(lpCmd);
    return fRet;
}

typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCTSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);

static const TCHAR c_szShlwapiDll[] = TEXT("shlwapi.dll");
static const char c_szDllGetVersion[] = "DllGetVersion";
static const TCHAR c_szWABResourceDLL[] = TEXT("wab32res.dll");
static const TCHAR c_szWABDLL[] = TEXT("wab32.dll");

HINSTANCE LoadWABResourceDLL(HINSTANCE hInstWAB32)
{
    TCHAR szPath[MAX_PATH];
    HINSTANCE hinstShlwapi;
    PFNMLLOADLIBARY pfn;
    DLLGETVERSIONPROC pfnVersion;
    int iEnd;
    DLLVERSIONINFO info;
    HINSTANCE hInst = NULL;

    hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    if (hinstShlwapi != NULL)
    {
        pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion != NULL)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                {
#ifdef UNICODE
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)378);
#else
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)377);
#endif // UNICODE
                    if (pfn != NULL)
                        hInst = pfn(c_szWABResourceDLL, hInstWAB32, 0);
                }
            }
        }

        FreeLibrary(hinstShlwapi);        
    }

    if (NULL == hInst)
    {
        GetWABDllPath(szPath, sizeof(szPath));
        iEnd = lstrlen(szPath);
        if (iEnd > 0)
        {
            iEnd = iEnd - lstrlen(c_szWABDLL);
            lstrcpyn(&szPath[iEnd], c_szWABResourceDLL, sizeof(szPath)/sizeof(TCHAR)-iEnd);
            hInst = LoadLibrary(szPath);
        }
    }

    AssertSz(hInst, TEXT("Failed to LoadLibrary Lang Dll"));

    return(hInst);
}

/***************************************************************************

    Name      : WinMain

    Purpose   :

    Parameters: Command line parameters
                "" - defaults to import for default wab
                "filename" - defaults to import
                "/import [filename]" - default wab or specified wab
                "/export [filename]" - default wab or specified wab


    Returns   :

***************************************************************************/
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow) {
    MSG msg ;
    int nRetVal;
    LPSTR lpTemp = lpszCmdLine;
    HINSTANCE hinstWAB;

    WABMIGDLGPARAM wmdp = {0};

    hInstApp = hInstance;
    hInst = LoadWABResourceDLL(hInstApp);

    DebugTrace("WABMIG cmdline = %s\n", lpszCmdLine);

    fExport = bSearchCmdLine(lpszCmdLine, (LPTSTR)szEXPORT, NULL);
    bSearchCmdLine(lpszCmdLine, (LPTSTR)szPROFILEID, wmdp.szProfileID);
    bSearchCmdLine(lpszCmdLine, (LPTSTR)szFILE, wmdp.szFileName);

    DebugTrace("%s: id=%s file=%s\n", fExport?szEXPORT:szIMPORT, wmdp.szProfileID, wmdp.szFileName);

    // Load the WABDll and getprocaddress for WABOpen
    hinstWAB = LoadLibrary_WABDll();
    if(hinstWAB)
        lpfnWABOpen = (LPWABOPEN) GetProcAddress(hinstWAB, TEXT("WABOpen"));

    DebugTrace("WABMig got filename: %s\n", wmdp.szFileName);

    if(lpfnWABOpen)
    {
        nRetVal = (int) DialogBoxParam(hInst,
         MAKEINTRESOURCE(fExport ? IDD_ExportDialog : IDD_ImportDialog),
          NULL,
          fExport ? ExportDialogProc : ImportDialogProc,
          (LPARAM) &wmdp);
        switch(nRetVal) {
            case -1: //some error occured
                DebugTrace("Couldn't create import dialog -> %u\n", GetLastError());
            default:
                break;
        }
    }
    else
    {
        TCHAR sz[MAX_PATH];
        TCHAR szTitle[MAX_PATH];
        *szTitle = *sz = '\0';
        LoadString(hInst, IDS_MESSAGE_TITLE, szTitle, sizeof(szTitle));
        LoadString(hInst, IDS_NO_WAB, sz, sizeof(sz));
        MessageBox(NULL, sz, szTitle, MB_OK | MB_ICONSTOP);
    }

    if(hinstWAB)
        FreeLibrary(hinstWAB);
    if(hInst)
        FreeLibrary(hInst);

    return(nRetVal == -1);
}

INT_PTR CALLBACK ErrorDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    LPERROR_INFO lpEI = (LPERROR_INFO)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (message) {
        case WM_INITDIALOG:
            {
                TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
                LPTSTR lpszMessage;

                SetWindowLongPtr(hwnd, DWLP_USER, lParam);  //Save this for future reference
                lpEI = (LPERROR_INFO)lParam;


                if (LoadString(hInst,
                  lpEI->ids,
                  szBuffer, sizeof(szBuffer))) {
                    LPTSTR lpszArg[2] = {lpEI->lpszDisplayName, lpEI->lpszEmailAddress};

                    if (! FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      szBuffer,
                      0, 0, //ignored
                      (LPTSTR)&lpszMessage,
                      0,
                      (va_list *)lpszArg)) {
                        DebugTrace("FormatMessage -> %u\n", GetLastError());
                    } else {
                        DebugTrace("Status Message: %s\n", lpszMessage);
                        if (! SetDlgItemText(hwnd, IDC_ErrorMessage, lpszMessage)) {
                            DebugTrace("SetDlgItemText -> %u\n", GetLastError());
                        }
                        LocalFree(lpszMessage);
                    }
                }
                return(TRUE);
            }

        case WM_COMMAND :
            switch (wParam) {
                case IDCANCEL:
                    lpEI->ErrorResult = ERROR_ABORT;
                    // fall through to close.

                case IDCLOSE:
                    // Ignore the contents of the radio button
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDOK:
                    // Get the contents of the radio button
                    ImportOptions.fNoErrors = (IsDlgButtonChecked(hwnd, IDC_NoMoreError) == 1);
                    ExportOptions.fNoErrors = (IsDlgButtonChecked(hwnd, IDC_NoMoreError) == 1);
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);

                case IDM_EXIT:
                    SendMessage(hwnd, WM_DESTROY, 0, 0L);
                    return(0);
                }
            break ;

        case IDCANCEL:
            // treat it like a close
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case WM_CLOSE:
            EndDialog(hwnd, FALSE);
            return(0);

        default:
            return(FALSE);
    }

    return(TRUE);
}

/***************************************************************************

    bOutlookUsingWAB

    if Outlook is installed on the machine and is setup to use the WAB 
    then there is no PAB on this machine - the PAB is the WAB and the 
    WAB import imports to itself ...
    So we look for this case and if it is true, we drop the PAB importer
    from the UI

****************************************************************************/
BOOL bOutlookUsingWAB()
{
    HKEY hKey = NULL;
    LPTSTR lpReg = "Software\\Microsoft\\Office\\8.0\\Outlook\\Setup";
    LPTSTR lpOMI = "MailSupport";
    BOOL bUsingWAB = FALSE;

    if(ERROR_SUCCESS == RegOpenKeyEx(   HKEY_LOCAL_MACHINE, 
                                        lpReg, 0, KEY_READ, &hKey))
    {
        DWORD dwType = 0, dwSize = sizeof(DWORD), dwData = 0;
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, lpOMI, NULL,
                                            &dwType, (LPBYTE)&dwData, &dwSize))
        {
            if(dwType == REG_DWORD && dwData == 0) // the value must be one ..
                bUsingWAB = TRUE;
        }
    }

    if(hKey)
        RegCloseKey(hKey);

    return bUsingWAB;
}


/***************************************************************************

    Name      : PopulateTargetList

    Purpose   : Fills in the list box with the import/exporters from the
                registry.

    Parameters: hwndLB = handle of Listbox
                lpszSelection = NULL or name to set as default selection

    Returns   : HRESULT

    Comment   : This routine is a MESS!  Should break it up when we get time.

***************************************************************************/
HRESULT PopulateTargetList(HWND hWndLB,
  LPTSTR lpszSelection)
{
    ULONG       ulObjectType = 0;
    ULONG       i=0, j=0;
    TCHAR       szBuf[MAX_PATH];
    ULONG       ulItemCount = 0;
    HRESULT     hr = hrSuccess;
    DWORD       dwErr, cbBuf;
    HKEY        hKeyWAB = NULL;
    HKEY        hKeyImport = NULL;
    HKEY        hKey = NULL;
    ULONG       ulIndex;
    ULONG       ulNumImporters = 0;
    ULONG       ulExternals = 0;
    BOOL        bHidePAB = FALSE;

    //
    // We need to clear out the list list box if it has any entries ...
    //
    FreeLBItemData(hWndLB);

    // If outlook is using the WAB as the PAB then we want to hide
    // the PAB entry from the importer and exporter
    //
    bHidePAB = bOutlookUsingWAB();

    // How big a target list do I need?

    // Load all the entries from the registry
    // Open WAB Import Key
    if (! (dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, //HKEY_CURRENT_USER,
      szWABKey,
      0,
      KEY_READ,
      &hKeyWAB))) {

        // Yes, WAB Key open, get Import or Export Key
        if (! (dwErr = RegOpenKeyEx(hKeyWAB,
          fExport ? "Export" : "Import",
          0,
          KEY_READ,
          &hKeyImport))) {
            // Enumerate Importer/Exporter keys
            // How many keys are there?
            if (! (dwErr = RegQueryInfoKey(hKeyImport,
              NULL, NULL, NULL,
              &ulExternals,  // how many importer/exporter keys are there?
              NULL, NULL, NULL, NULL, NULL, NULL, NULL))) {
            }
        }
    }

    ulNumImporters = ulExternals + ulItemCount;

    if ((rgTargetInfo = LocalAlloc(LPTR, ulNumImporters * sizeof(TARGET_INFO)))) {
        ulIndex = 0;
        cbBuf= sizeof(szBuf);
    } else {
        DebugTrace("LocalAlloc of TargetInfoArray -> %u\n", GetLastError());
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }


    if (ulExternals) {
        // Add external importers/exporters to the list
        while (ulIndex < ulExternals && ! (dwErr = RegEnumKeyEx(hKeyImport,
          ulIndex,
          szBuf,
          &cbBuf,
          NULL, NULL, NULL, NULL))) {
            // Got another one,
            DebugTrace("Found Importer: [%s]\n", szBuf);

            // if we want to hide the pab and this is the pab then
            // skip else add
            //
            if(!(bHidePAB && !lstrcmpi(szBuf, TEXT("PAB"))))
            {
                // Add it to the list
                if (rgTargetInfo[ulItemCount].lpRegName = LocalAlloc(LPTR,
                  lstrlen(szBuf) + 1)) {
                    lstrcpy(rgTargetInfo[ulItemCount].lpRegName, szBuf);

                    // Open the key
                    if (! (dwErr = RegOpenKeyEx(hKeyImport,
                      szBuf,
                      0,
                      KEY_READ,
                      &hKey))) {

                        AllocRegValue(hKey, (LPTSTR)szDescription, &rgTargetInfo[ulItemCount].lpDescription);
                        AllocRegValue(hKey, (LPTSTR)szDll, &rgTargetInfo[ulItemCount].lpDll);
                        AllocRegValue(hKey, (LPTSTR)szEntry, &rgTargetInfo[ulItemCount].lpEntry);

                        RegCloseKey(hKey);

                        if (! rgTargetInfo[ulItemCount].lpDescription) {
                            // No Description, use reg name
                            if (rgTargetInfo[ulItemCount].lpDescription = LocalAlloc(LPTR,
                              lstrlen(szBuf) + 1)) {
                                lstrcpy(rgTargetInfo[ulItemCount].lpDescription, szBuf);
                            }
                        }

                        // Add to the list
                        SendMessage(hWndLB, LB_SETITEMDATA, (WPARAM)
                          SendMessage(hWndLB, LB_ADDSTRING, (WPARAM)0,
                          (LPARAM)rgTargetInfo[ulItemCount].lpDescription),
                          (LPARAM)ulItemCount);

                        if (lpszSelection && !lstrcmpi(rgTargetInfo[ulItemCount].lpDescription, lpszSelection)) {
                            // Set the default selection to Windows Address Book
                            SendMessage(hWndLB, LB_SETCURSEL, (WPARAM)ulIndex, (LPARAM)0);
                        }
                        ulItemCount++;
                    }
                } else {
                    DebugTrace("LocalAlloc of Importer Name -> %u\n", GetLastError());
                }
            }
            cbBuf = sizeof(szBuf);
            ulIndex++;
        }
    }
exit:
    if (hKeyImport) {
        RegCloseKey(hKeyImport);
    }
    if (hKeyWAB) {
        RegCloseKey(hKeyWAB);
    }

    return(hr);
}


/***************************************************************************

    Name      : FreeLBItemData

    Purpose   : Frees the structures associated with the Target List box.

    Parameters: hwndLB = handle of Listbox

    Returns   : none

    Comment

***************************************************************************/
void FreeLBItemData(HWND hWndLB)
{
    ULONG i = 0;
	ULONG ulItemCount = 0;
    LPTARGET_INFO lpTargetInfo = rgTargetInfo;

    if (! hWndLB) {
        return;
    }

    ulItemCount = (ULONG) SendMessage(hWndLB, LB_GETCOUNT, 0, 0);

    if (lpTargetInfo != NULL) {
        if (ulItemCount != 0) {
            for(i = 0; i < ulItemCount; i++) {
                if(lpTargetInfo->lpRegName) {
                    LocalFree(lpTargetInfo->lpRegName);
                }
                if (lpTargetInfo->lpDescription) {
                    LocalFree(lpTargetInfo->lpDescription);
                }
                if (lpTargetInfo->lpDll) {
                    LocalFree(lpTargetInfo->lpDll);
                }
                if (lpTargetInfo->lpEntry) {
                    LocalFree(lpTargetInfo->lpEntry);
                }
                lpTargetInfo++;
            }

            SendMessage(hWndLB, LB_RESETCONTENT, 0, 0);
        }

        // Free global array
        LocalFree(rgTargetInfo);
        rgTargetInfo = NULL;
    }
}


/***************************************************************************

    Name      : ShowMessageBoxParam

    Purpose   : Generic MessageBox displayer

    Parameters: hWndParent - Handle of message box parent
                MsgID      - resource id of message string
                ulFlags    - MessageBox flags
                ...        - format parameters

    Returns   : MessageBox return code

***************************************************************************/
int __cdecl ShowMessageBoxParam(HWND hWndParent, int MsgId, int ulFlags, ...)
{
    TCHAR szBuf[MAX_RESOURCE_STRING + 1] = "";
    TCHAR szCaption[MAX_PATH] = "";
    LPTSTR lpszBuffer = NULL;
    int iRet = 0;
    va_list     vl;

    va_start(vl, ulFlags);

    LoadString(hInst, MsgId, szBuf, sizeof(szBuf));
    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
      szBuf,
      0,0,              // ignored
      (LPTSTR)&lpszBuffer,
      sizeof(szBuf),      // MAX_UI_STR
      (va_list *)&vl)) {
        TCHAR szCaption[MAX_PATH];
        GetWindowText(hWndParent, szCaption, sizeof(szCaption));
        if (! lstrlen(szCaption)) { // if no caption get the parents caption - this is necessary for property sheets
            GetWindowText(GetParent(hWndParent), szCaption, sizeof(szCaption));
            if (! lstrlen(szCaption)) //if still not caption, use empty title
                szCaption[0] = (TCHAR)'\0';
        }
        iRet = MessageBox(hWndParent, lpszBuffer, szCaption, ulFlags);
        LocalFree(lpszBuffer);
    }
    va_end(vl);
    return(iRet);
}


//$$//////////////////////////////////////////////////////////////////////
//
//  LoadAllocString - Loads a string resource and allocates enough
//                    memory to hold it.
//
//  StringID - String identifier to load
//
//  returns the LocalAlloc'd, null terminated string.  Caller is responsible
//  for LocalFree'ing this buffer.  If the string can't be loaded or memory
//  can't be allocated, returns NULL.
//
//////////////////////////////////////////////////////////////////////////
LPTSTR LoadAllocString(int StringID) {
    ULONG ulSize = 0;
    LPTSTR lpBuffer = NULL;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];

    ulSize = LoadString(hInst, StringID, szBuffer, sizeof(szBuffer));

    if (ulSize && (lpBuffer = LocalAlloc(LPTR, ulSize + 1))) {
        lstrcpy(lpBuffer, szBuffer);
    }

    return(lpBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\dbgutil.h ===
/***********************************************************************
 *
 * DBGUTIL.H
 *
 * Debug Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/

#ifdef DEBUG
VOID _DebugObjectProps(BOOL fMAPI, LPMAPIPROP lpObject, LPTSTR Label);
VOID _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject);
void _DebugMapiTable(BOOL fMAPI, LPMAPITABLE lpTable);
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle);

#define WABDebugObjectProps(lpObject, Label) _DebugObjectProps(FALSE, lpObject, Label)
#define WABDebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define WABDebugMapiTable(lpTable) _DebugMapiTable(FALSE, lpTable)
#define WABDebugADRLIST(lpAdrList, lpszTitle) _DebugADRLIST(lpAdrList, lpszTitle)

#define MAPIDebugObjectProps(lpObject, Label) _DebugObjectProps(TRUE, lpObject, Label)
#define MAPIDebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define MAPIDebugMapiTable(lpTable) _DebugMapiTable(TRUE, lpTable)
#define MAPIDebugADRLIST(lpAdrList, lpszTitle) _DebugADRLIST(lpAdrList, lpszTitle)

#else

#define WABDebugObjectProps(lpObject, Label)
#define WABDebugProperties(lpProps, cProps, pszObject)
#define WABDebugMapiTable(lpTable)
#define WABDebugADRLIST(lpAdrList, lpszTitle)

#define MAPIDebugObjectProps(lpObject, Label)
#define MAPIDebugProperties(lpProps, cProps, pszObject)
#define MAPIDebugMapiTable(lpTable)
#define MAPIDebugADRLIST(lpAdrList, lpszTitle)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wabmig\_wabmig.h ===
/*
 *  _WABMIG.H
 *
 *  Internal header for wabmig.exe
 *
 *  Copyright 1996-1997 Microsoft Corporation.  All Rights Reserved.
 */

// Test for PT_ERROR property tag
#define PROP_ERROR(prop) (prop.ulPropTag == PROP_TAG(PT_ERROR, PROP_ID(prop.ulPropTag)))


// Property Tags:
// MSN Address properties
#define PR_MSNINET_ADDRESS                          PROP_TAG(PT_TSTRING,    0x6001)
#define PR_MSNINET_DOMAIN                           PROP_TAG(PT_TSTRING,    0x6002)


// Misc defines
#define MAX_SCHEMA_PROPID   0x3FFF
#define MIN_NAMED_PROPID    0x8000
#define WAB_W_BAD_EMAIL     MAKE_MAPI_S(0x1000)
#define NOT_FOUND           ((ULONG)-1)
#define INDEX_FIRST_MIDDLE_LAST ((ULONG)-2)
#define NUM_EXPORT_WIZARD_PAGES 2
#define NUM_IMPORT_WIZARD_PAGES 2


// Index of icons in the bitmap
enum {
    iiconStateUnchecked,
    iiconStateChecked,
    iiconStMax
};

extern const UCHAR szQuote[];

extern const TCHAR szMSN[];
extern const TCHAR szMSNINET[];
extern const TCHAR szCOMPUSERVE[];
extern const TCHAR szFAX[];
extern const TCHAR szSMTP[];
extern const TCHAR szMS[];
extern const TCHAR szEX[];
extern const TCHAR szX400[];
extern const TCHAR szMSA[];
extern const TCHAR szMAPIPDL[];
extern const TCHAR szEmpty[];
extern const TCHAR szAtSign[];

#define cbAtSign        (2 * sizeof(TCHAR))

extern const TCHAR szMSNpostfix[];
#define cbMSNpostfix    (9 * sizeof(TCHAR))

extern const TCHAR szCOMPUSERVEpostfix[];
#define cbCOMPUSERVEpostfix     (16 * sizeof(TCHAR))


typedef enum {
    INDEX_EXPORT_PAB = 0,
    INDEX_EXPORT_CSV
} INDEX_EXPORT, *LPINDEX_EXPORT;


typedef enum {
    CONFIRM_YES,
    CONFIRM_NO,
    CONFIRM_YES_TO_ALL,
    CONFIRM_NO_TO_ALL,
    CONFIRM_ERROR,
    CONFIRM_ABORT
} CONFIRM_RESULT, *LPCONFIRM_RESULT;


typedef struct _ReplaceInfo {
    LPTSTR lpszDisplayName;         // Conflicting display name
    LPTSTR lpszEmailAddress;        // Conflicting email address
    CONFIRM_RESULT ConfirmResult;   // Results from dialog
} REPLACE_INFO, * LPREPLACE_INFO;

typedef enum {
    ERROR_OK,
    ERROR_ABORT
} ERROR_RESULT, *LPERROR_RESULT;

typedef struct _ErrorInfo {
    LPTSTR lpszDisplayName;         // Problem display name
    LPTSTR lpszEmailAddress;        // Problem email address
    ERROR_RESULT ErrorResult;       // Results from dialog
    ULONG ids;                      // string resource identifier for error message
} ERROR_INFO, * LPERROR_INFO;


typedef struct _EntrySeen {
    SBinary sbinPAB;                // MAPI entry
    SBinary sbinWAB;                // WAB entry
} ENTRY_SEEN, * LPENTRY_SEEN;

typedef struct _TargetInfo {
    LPTSTR lpRegName;
    LPTSTR lpDescription;
    LPTSTR lpDll;
    LPTSTR lpEntry;
    union {
        LPWAB_EXPORT lpfnExport;
        LPWAB_IMPORT lpfnImport;
    };
} TARGET_INFO, *LPTARGET_INFO;

typedef struct _DlgParam
{
    TCHAR szFileName[MAX_PATH];
    TCHAR szProfileID[MAX_PATH];
} WABMIGDLGPARAM, * LPWABMIGDLGPARAM;

enum {
    iconPR_DEF_CREATE_MAILUSER = 0,
    iconPR_DEF_CREATE_DL,
    iconMax
};

enum {
    ieidPR_ENTRYID = 0,
    ieidMax
};

enum {
    iptaColumnsPR_OBJECT_TYPE = 0,
    iptaColumnsPR_ENTRYID,
    iptaColumnsPR_DISPLAY_NAME,
    iptaColumnsPR_EMAIL_ADDRESS,
    iptaColumnsMax
};

typedef struct _PropNames {
    ULONG ulPropTag;        // property tag
    BOOL fChosen;           // use this property tag
    ULONG ids;              // string id
    LPTSTR lpszName;        // string (read in from resources)
    LPTSTR lpszCSVName;     // name of CSV field (from import file)
} PROP_NAME, *LPPROP_NAME;

extern PROP_NAME rgPropNames[];
extern LPPROP_NAME lpImportMapping;

#ifndef _WABMIG_C
#define ExternSizedSPropTagArray(_ctag, _name) \
extern const struct _SPropTagArray_ ## _name \
{ \
    ULONG   cValues; \
    ULONG   aulPropTag[_ctag]; \
} _name

ExternSizedSPropTagArray(iptaColumnsMax, ptaColumns);
ExternSizedSPropTagArray(ieidMax, ptaEid);
ExternSizedSPropTagArray(iconMax, ptaCon);


#endif


extern WAB_IMPORT_OPTIONS ImportOptions;
extern WAB_EXPORT_OPTIONS ExportOptions;
extern LPENTRY_SEEN lpEntriesSeen;
extern ULONG ulEntriesSeen;
extern ULONG ulMaxEntries;
extern const LPTSTR szWABKey;
extern LPTARGET_INFO rgTargetInfo;
extern HINSTANCE hInst;
extern HINSTANCE hInstApp;
extern BOOL fMigrating;
extern BOOL fError;
extern BOOL fExport;
extern LPWABOBJECT lpWABObject;
extern LPMAPISESSION lpMAPISession;
extern LPADRBOOK lpAdrBookWAB;
extern LPADRBOOK lpAdrBookMAPI;
extern LPABCONT lpContainerMAPI;
extern LPABCONT lpContainerWAB;
extern LPMAPITABLE lpContentsTableMAPI;
extern LPMAPITABLE lpContentsTableWAB;
extern LPSPropValue lpCreateEIDsWAB;
extern LPSPropValue lpCreateEIDsMAPI;
extern ULONG ulcEntries;
extern LPTSTR lpImportDll;
extern LPTSTR lpImportFn;
extern LPTSTR lpImportDesc;
extern LPTSTR lpImportName;
extern LPTSTR lpExportDll;
extern LPTSTR lpExportFn;
extern LPTSTR lpExportDesc;
extern LPTSTR lpExportName;


//
// Functions in wabmig.c
//
extern INT_PTR CALLBACK ImportDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
extern INT_PTR CALLBACK ExportDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
#ifdef OLD_STUFF
extern long FAR PASCAL OptionsDialogProc(HWND hwnd, UINT message, UINT wParam, LONG lParam);
#endif // OLD_STUFF
extern INT_PTR CALLBACK ErrorDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
extern INT_PTR CALLBACK ReplaceDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
extern HRESULT PopulateTargetList(HWND hWndLB,
  LPTSTR lpszSelection);
extern void FreeLBItemData(HWND hWndLB);
extern HRESULT ProgressCallback(HWND hwnd, LPWAB_PROGRESS lpProgress);
extern ULONG CountRows(LPMAPITABLE lpTable, BOOL fMAPI);
extern BOOL AllocRegValue(HKEY hKey, LPTSTR lpValueName, LPTSTR * lppString);
extern LPTSTR GetEMSSMTPAddress(LPMAPIPROP lpObject, LPVOID lpBase);
extern int StrICmpN(LPTSTR szString1, LPTSTR szString2, ULONG N);
extern LPTSTR FindStringInProps(LPSPropValue lpspv, ULONG ulcProps, ULONG ulPropTag);
extern LPSBinary FindAdrEntryID(LPADRLIST lpAdrList, ULONG index);
extern void WABFreePadrlist(LPADRLIST lpAdrList);
extern SCODE WABFreeBuffer(LPVOID lpBuffer);
extern SCODE WABAllocateMore(ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer);
extern SCODE WABAllocateBuffer(ULONG cbSize, LPVOID FAR * lppBuffer);
extern void SetGlobalBufferFunctions(LPWABOBJECT lpWABObject);
extern void FreeSeenList(void);
ULONG FindProperty(ULONG cProps, LPSPropValue lpProps, ULONG ulPropTag);
void FreeSeenList(void);
void SetDialogMessage(HWND hwnd, int ids);
void WABFreeProws(LPSRowSet prows);
HRESULT ExportCSV(HWND hwnd,
  LPADRBOOK lpAdrBook,
  LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPWAB_EXPORT_OPTIONS lpOptions);
HRESULT ImportCSV(HWND hwnd,
  LPADRBOOK lpAdrBook,
  LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPWAB_IMPORT_OPTIONS lpOptions);
int __cdecl ShowMessageBoxParam(HWND hWndParent, int MsgId, int ulFlags, ...);
LPTSTR LoadAllocString(int StringID);
LPTSTR FormatAllocFilter(int StringID, const LPTSTR lpFilter);
HRESULT SaveFileDialog(HWND hWnd, LPTSTR szFileName, LPTSTR lpFilter, LPTSTR lpDefExt,
  ULONG ulFlags, HINSTANCE hInst, ULONG idsTitle, ULONG idsFileType, ULONG idsSaveButton);
HRESULT OpenFileDialog(HWND hWnd, LPTSTR szFileName, LPTSTR lpFilter, LPTSTR lpDefExt,
  ULONG ulFlags, HINSTANCE hInst, ULONG idsTitle, ULONG idsFileType, ULONG idsOpenButton);
LPTSTR LoadAllocString(int StringID);
LPTSTR PropStringOrNULL(LPSPropValue lpspv);

//
// Functions in csvpick.c
//
int APIENTRY PickExportProps(LPPROP_NAME rgPropNames);
HRESULT ExportWizard(HWND hWnd, LPTSTR szFileName, LPPROP_NAME rgPropNames);
HRESULT ImportWizard(HWND hWnd, LPTSTR szFileName, LPPROP_NAME rgPropNames,
  LPPROP_NAME * lppImportMapping, LPULONG lpcFields, LPHANDLE lphFile);

//
// Functions in csvparse.c
//
HRESULT ReadCSVLine(HANDLE hFile, ULONG * lpcItems, PUCHAR ** lpprgItems);


LPWABOPEN lpfnWABOpen;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\csv.c ===
/*
 *  CSV.C
 *
 *  Migrate CSV <-> WAB
 *
 *  Copyright 1997 Microsoft Corporation.  All Rights Reserved.
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#include "wabimp.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"


BOOL HandleImportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_IMPORT_OPTIONS lpImportOptions);
BOOL HandleExportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_EXPORT_OPTIONS lpExportOptions);

/***************************************************************************

    Name      : IsDomainName

    Purpose   : Is this domain correctly formatted for an Internet address?

    Parameters: lpDomain -> Domain name to check

    Returns   : TRUE if the domain is a correct format for an Internet
                address.

    Comment   : Valid domain names have this form:
                    bar[.bar]*
                    where bar must have non-empty contents
                    no high bits are allowed on any characters
                    no '@' allowed

***************************************************************************/
BOOL IsDomainName(LPTSTR lpDomain) {
    BOOL fBar = FALSE;

    if (lpDomain) {
        if (*lpDomain == '\0' || *lpDomain == '.') {
            // domain name must have contents and can't start with '.'
            return(FALSE);
        }

        while (*lpDomain) {
            // Internet addresses only allow pure ASCII.  No high bits!
            if (*lpDomain & 0x80 || *lpDomain == '@') {
                return(FALSE);
            }

            if (*lpDomain == '.') {
                // Recursively check this part of the domain name
                return(IsDomainName(CharNext(lpDomain)));
            }
            lpDomain = CharNext(lpDomain);
        }
        return(TRUE);
    }

    return(FALSE);
}


/***************************************************************************

    Name      : IsInternetAddress

    Purpose   : Is this address correctly formatted for an Internet address

    Parameters: lpAddress -> Address to check

    Returns   : TRUE if the address is a correct format for an Internet
                address.

    Comment   : Valid addresses have this form:
                    foo@bar[.bar]*
                    where foo and bar must have non-empty contents


***************************************************************************/
BOOL IsInternetAddress(LPTSTR lpAddress) {
    BOOL fDomain = FALSE;

    // Step through the address looking for '@'.  If there's an at sign in the middle
    // of a string, this is close enough to being an internet address for me.


    if (lpAddress) {
        // Can't start with '@'
        if (*lpAddress == '@') {
            return(FALSE);
        }
        while (*lpAddress) {
            // Internet addresses only allow pure ASCII.  No high bits!
            if (*lpAddress & 0x80) {
                return(FALSE);
            }

            if (*lpAddress == '@') {
                // Found the at sign.  Is there anything following?
                // (Must NOT be another '@')
                return(IsDomainName(CharNext(lpAddress)));
            }
            lpAddress = CharNext(lpAddress);
        }
    }

    return(FALSE);
}


/***************************************************************************

    Name      : OpenCSVFile

    Purpose   : Opens a CSV file for import

    Parameters: hwnd = main dialog window
                lpFileName = filename to create
                lphFile -> returned file handle

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT OpenCSVFile(HWND hwnd, LPTSTR lpFileName, LPHANDLE lphFile) {
    LPTSTR lpFilter;
    TCHAR szFileName[MAX_PATH + 1] = "";
    OPENFILENAME ofn;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HRESULT hResult = hrSuccess;
    DWORD ec;


    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(lpFileName,
      GENERIC_READ,
      0,    // sharing
      NULL,
      CREATE_NEW,
      FILE_FLAG_SEQUENTIAL_SCAN,
      NULL))) {
        ec = GetLastError();
        DebugTrace("CreateFile(%s) -> %u\n", lpFileName, ec);
        switch (ec) {
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
            default:
                ShowMessageBoxParam(hwnd, IDE_CSV_EXPORT_FILE_ERROR, MB_ICONERROR, lpFileName);
                hResult = ResultFromScode(MAPI_E_NOT_FOUND);
                break;
        }
    }

    if (! hResult) {
        *lphFile = hFile;
    }
    return(hResult);
}


/***************************************************************************

    Name      : CountCSVRows

    Purpose   : Counts the rows in the CSV file

    Parameters: hFile = open CSV file
                szSep = list separator
                lpulcEntries -> returned count of rows

    Returns   : HRESULT

    Comment   : File pointer should be positioned past the header row prior
                to calling this function.  This function leaves the file
                pointer where it found it.

***************************************************************************/
HRESULT CountCSVRows(HANDLE hFile, LPTSTR szSep, LPULONG lpulcEntries) {
    HRESULT hResult = hrSuccess;
    PUCHAR * rgItems = NULL;
    ULONG ulStart;
    ULONG cProps, i;

    *lpulcEntries = 0;

    Assert(hFile != INVALID_HANDLE_VALUE);

    if (0xFFFFFFFF == (ulStart = SetFilePointer(hFile, 0, NULL, FILE_CURRENT))) {
        DebugTrace("CountCSVRows SetFilePointer -> %u\n", GetLastError());
        return(ResultFromScode(MAPI_E_CALL_FAILED));
    }


    while (hResult == hrSuccess) {
        // Read the line
        if (ReadCSVLine(hFile, szSep, &cProps, &rgItems)) {
            // End of file
            break;
        }

        (*lpulcEntries)++;

        if (rgItems) {
            for (i = 0; i < cProps; i++) {
                if (rgItems[i]) {
                    LocalFree(rgItems[i]);
                }
            }
            LocalFree(rgItems);
            rgItems = NULL;
        }
    }
    if (0xFFFFFFFF == SetFilePointer(hFile, ulStart, NULL, FILE_BEGIN)) {
        DebugTrace("CountCSVRows SetFilePointer -> %u\n", GetLastError());
    }

    return(hResult);
}


BOOL TestCSVName(ULONG index,
  LPPROP_NAME lpImportMapping,
  ULONG ulcFields,
  PUCHAR * rgItems,
  ULONG cProps,
  BOOL fTryUnchosen) {

    return((index != NOT_FOUND) &&
      index < ulcFields &&
      index < cProps &&
      (fTryUnchosen || lpImportMapping[index].fChosen) &&
      rgItems[index] &&
      rgItems[index][0]);
}


/***************************************************************************

    Name      : MakeDisplayName

    Purpose   : Forms a display name based on the values of various props.

    Parameters: lppDisplayName -> Returned display name.  This should only
                  be used for certain purposes.  It can be used for error
                  dialogs, but if it was generated from first/middle/last,
                  it should not be used for PR_DISPLAY_NAME!
                lpImportMapping = import mapping table
                ulcFields = size of import mapping table
                rgItems = fields for this CSV item
                cProps = number of fields in rgItems
                iDisplayName = indicies of name related props
                iNickname
                iSurname
                iGivenName
                iMiddleName
                iEmailAddress
                iCompanyName

    Returns   : index of attribute forming the display name, or
                if FML, return INDEX_FIRST_MIDDLE_LAST.

    Comment   : Form the display name based on these rules:
                1. If there's already a display name and it's chosen,
                   use it.
                2. if there's a chosen first, middle or last name, add them
                   together and use them.
                3. if there's a chosen nickname, use it
                4. if there's a chosen email-address, use it.
                5. if there's a chosen company name, use it.
                6. look again without regard to whether it was chosen or not.

***************************************************************************/
ULONG MakeDisplayName(LPTSTR * lppDisplayName,
  LPPROP_NAME lpImportMapping,
  ULONG ulcFields,
  PUCHAR * rgItems,
  ULONG cProps,
  ULONG iDisplayName,
  ULONG iNickname,
  ULONG iSurname,
  ULONG iGivenName,
  ULONG iMiddleName,
  ULONG iEmailAddress,
  ULONG iCompanyName) {
    BOOL fTryUnchosen = FALSE;
    BOOL fSurname = FALSE;
    BOOL fGivenName = FALSE;
    BOOL fMiddleName = FALSE;
    ULONG index = NOT_FOUND;
    ULONG ulSize = 0;
    LPTSTR lpDisplayName = NULL;

try_again:

    if (TestCSVName(iDisplayName, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
        index = iDisplayName;
        goto found;
    }

    if (TestCSVName(iSurname, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen) ||
      TestCSVName(iGivenName, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen) ||
      TestCSVName(iMiddleName, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
        index = INDEX_FIRST_MIDDLE_LAST;
        goto found;
    }

    if (TestCSVName(iNickname, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
        index = iNickname;
        goto found;
    }

    if (TestCSVName(iEmailAddress, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
        index = iEmailAddress;
        goto found;
    }

    if (TestCSVName(iCompanyName, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
        index = iCompanyName;
        goto found;
    }
    if (! fTryUnchosen) {
        fTryUnchosen = TRUE;
        goto try_again;
    }

found:
    *lppDisplayName = NULL;
    switch (index) {
        case NOT_FOUND:
            break;

        case INDEX_FIRST_MIDDLE_LAST:
            if (fSurname = TestCSVName(iSurname, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
                ulSize += (lstrlen(rgItems[iSurname]) + 1);
            }
            if (fGivenName = TestCSVName(iGivenName, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
                ulSize += (lstrlen(rgItems[iGivenName]) + 1);
            }
            if (fMiddleName = TestCSVName(iMiddleName, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
                ulSize += (lstrlen(rgItems[iMiddleName]) + 1);
            }
            Assert(ulSize);

            if (lpDisplayName = *lppDisplayName = LocalAlloc(LPTR, ulSize)) {
                // BUGBUG: This does not localize.  The effect is that in the collision/error
                // dialogs, we will get the order of names wrong.  It should not effect the properties
                // actually stored on the object since we won't set PR_DISPLAY_NAME if it was
                // generated by First/Middle/Last.  I can live with this, but we'll see if the
                // testers find it. BruceK
                if (fGivenName) {
                    lstrcat(lpDisplayName, rgItems[iGivenName]);
                }
                if (fMiddleName) {
                    if (*lpDisplayName) {
                        lstrcat(lpDisplayName, " ");
                    }
                    lstrcat(lpDisplayName, rgItems[iMiddleName]);
                }
                if (fSurname) {
                    if (*lpDisplayName) {
                        lstrcat(lpDisplayName, " ");
                    }
                    lstrcat(lpDisplayName, rgItems[iSurname]);
                }
            }
            break;

        default:
            ulSize = lstrlen(rgItems[index]) + 1;
            if (*lppDisplayName = LocalAlloc(LPTR, ulSize)) {
                lstrcpy(*lppDisplayName, rgItems[index]);
            }
            break;
    }

    return(index);
}


#define MAX_SEP 20
void GetListSeparator(LPTSTR szBuf)
{
    // Buffer is assumed to be MAX_SEP chars long
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SLIST, szBuf, MAX_SEP))
    {
        szBuf[0] = TEXT(',');
		szBuf[1] = 0;
    }
}


HRESULT CSVImport(HWND hWnd,
  LPADRBOOK lpAdrBook,
  LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPWAB_EXPORT_OPTIONS lpOptions) {
    HRESULT hResult = hrSuccess;
    register ULONG i;
    ULONG cbWABEID, ulObjType;
    ULONG index;
    ULONG ulLastChosenProp = 0;
    ULONG ulcFields = 0;
    ULONG cProps;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    WAB_PROGRESS Progress;
    LPABCONT lpContainer = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR rgFileName[MAX_PATH + 1] = "";
    PUCHAR * rgItems = NULL;
    REPLACE_INFO RI;
    LPMAPIPROP lpMailUserWAB = NULL;
    SPropValue sPropVal;
    BOOL fSkipSetProps;
    LPTSTR lpDisplayName = NULL, lpEmailAddress = NULL;
    ULONG iEmailAddress = NOT_FOUND, iDisplayName = NOT_FOUND, iSurname = NOT_FOUND,
      iGivenName = NOT_FOUND, iCompanyName = NOT_FOUND, iMiddleName = NOT_FOUND,
      iNickname = NOT_FOUND, iDisplay = NOT_FOUND;
    TCHAR szSep[MAX_SEP];

    SetGlobalBufferFunctions(lpWABObject);

    // Read in the Property Name strings to the PropNames array
    for (i = 0; i < NUM_EXPORT_PROPS; i++) {
        rgPropNames[i].lpszName = LoadAllocString(rgPropNames[i].ids);
        Assert(rgPropNames[i].lpszName);
        DebugTrace("Property 0x%08x name: %s\n", rgPropNames[i].ulPropTag, rgPropNames[i].lpszName);
    }

    GetListSeparator(szSep);

    // Present UI Wizard
    if (hResult = ImportWizard(hWnd, rgFileName, rgPropNames, szSep, &lpImportMapping, &ulcFields, &hFile)) {
        goto exit;
    }

    Assert(hFile != INVALID_HANDLE_VALUE);

    // Find name props and last chosen property
    for (i = 0; i < ulcFields; i++) {
        if (lpImportMapping[i].fChosen) {
            ulLastChosenProp = i;
        }

        switch (lpImportMapping[i].ulPropTag) {
            case PR_EMAIL_ADDRESS:
                iEmailAddress = i;
                break;

            case PR_DISPLAY_NAME:
                iDisplayName = i;
                break;

            case PR_SURNAME:
                iSurname = i;
                break;

            case PR_GIVEN_NAME:
                iGivenName = i;
                break;

            case PR_COMPANY_NAME:
                iCompanyName = i;
                break;

            case PR_MIDDLE_NAME:
                iMiddleName = i;
                break;

            case PR_NICKNAME:
                iNickname = i;
                break;
        }
    }

    //
    // Open the WAB's PAB container: fills global lpCreateEIDsWAB
    //
    if (hResult = LoadWABEIDs(lpAdrBook, &lpContainer)) {
        goto exit;
    }

    //
    // All set... now loop through the file lines, adding each to the WAB
    //

    // How many lines are there?
    if (hResult = CountCSVRows(hFile, szSep, &ulcEntries)) {
        goto exit;
    }
    DebugTrace("CSV file contains %u entries\n", ulcEntries);

    // Initialize the Progress Bar
    Progress.denominator = max(ulcEntries, 1);
    Progress.numerator = 0;
    if (LoadString(hInst, IDS_STATE_IMPORT_MU, szBuffer, sizeof(szBuffer))) {
        DebugTrace("Status Message: %s\n", szBuffer);
        Progress.lpText = szBuffer;
    } else {
        DebugTrace("Cannot load resource string %u\n", IDS_STATE_IMPORT_MU);
        Progress.lpText = NULL;
    }
    lpProgressCB(hWnd, &Progress);


    while (hResult == hrSuccess) {
        // Read the CSV attributes
        if (hResult = ReadCSVLine(hFile, szSep, &cProps, &rgItems)) {
            DebugTrace("ReadCSVLine -> %x\n", GetScode(hResult));
            if (GetScode(hResult) == MAPI_E_NOT_FOUND) {
                // EOF
                hResult = hrSuccess;
            }
            break;      // nothing more to read
        }

        iDisplay = iDisplayName;

        if (TestCSVName(iEmailAddress,
          lpImportMapping,
          ulcFields,
          rgItems,
          cProps,
          TRUE)) {
            lpEmailAddress = rgItems[iEmailAddress];
        }

        switch (index = MakeDisplayName(&lpDisplayName,
          lpImportMapping,
          ulcFields,
          rgItems,
          cProps,
          iDisplayName,
          iNickname,
          iSurname,
          iGivenName,
          iMiddleName,
          iEmailAddress,
          iCompanyName)) {
            case NOT_FOUND:

                // No name props
                // BUGBUG: Should give special error?
                break;

            case INDEX_FIRST_MIDDLE_LAST:

                break;

            default:
                iDisplay = index;
                break;
        }


        // Should be the same number of fields in every entry, but if not,
        // we'll handle it below.
        // Assert(cProps == ulcFields); // Outlook does this!

        ulCreateFlags = CREATE_CHECK_DUP_STRICT;
        if (lpOptions->ReplaceOption ==  WAB_REPLACE_ALWAYS) {
            ulCreateFlags |= CREATE_REPLACE;
        }
retry:

        // Create a new wab mailuser
        if (HR_FAILED(hResult = lpContainer->lpVtbl->CreateEntry(lpContainer,
          lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.cb,
          (LPENTRYID)lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.lpb,
          ulCreateFlags,
          &lpMailUserWAB))) {
            DebugTrace("CreateEntry(WAB MailUser) -> %x\n", GetScode(hResult));
            goto exit;
        }


        for (i = 0; i <= min(ulLastChosenProp, cProps); i++)
        {
            if (lpImportMapping[i].fChosen && lpImportMapping[i].lpszName)
            {
                if (rgItems[i] && *rgItems[i]) {
                    // Look it up in the WAB property names table

                    DebugTrace("Prop %u: <%s> %s\n", i, lpImportMapping[i].lpszName, rgItems[i]);

                    sPropVal.ulPropTag = lpImportMapping[i].ulPropTag;

                    Assert(PROP_TYPE(lpImportMapping[i].ulPropTag) == PT_TSTRING);
                    sPropVal.Value.LPSZ = rgItems[i];

                    fSkipSetProps = FALSE;
                    if (sPropVal.ulPropTag == PR_EMAIL_ADDRESS)
                    {
                        if (! IsInternetAddress(sPropVal.Value.LPSZ))
                        {
                            DebugTrace("Found non-SMTP address %s\n", sPropVal.Value.LPSZ);

                            if (HandleImportError(hWnd,
                              0,
                              WAB_W_BAD_EMAIL,
                              lpDisplayName,
                              lpEmailAddress,
                              lpOptions))
                            {
                                hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                goto exit;
                            }

                            lpEmailAddress = NULL;
                            fSkipSetProps = TRUE;
                        }
                    }

                    if (! fSkipSetProps)
                    {
                        // Set the property on the WAB entry
                        if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
                          1,                        // cValues
                          &sPropVal,                // property array
                          NULL)))
                        {                 // problems array
                            DebugTrace("ImportEntry:SetProps(WAB) -> %x\n", GetScode(hResult));
                            goto exit;
                        }

                        // [PaulHi] 3/4/99  Raid 73637
                        // If we have a valid email address then we need to also add the
                        // PR_ADDRTYPE property set to "SMTP".
                        if (sPropVal.ulPropTag == PR_EMAIL_ADDRESS)
                        {
                            sPropVal.ulPropTag = PR_ADDRTYPE;
                            sPropVal.Value.LPSZ = (LPTSTR)szSMTP;
                            hResult = lpMailUserWAB->lpVtbl->SetProps(
                                                lpMailUserWAB,
                                                1,
                                                &sPropVal,
                                                NULL);
                            if (HR_FAILED(hResult))
                            {
                                DebugTrace("CSV ImportEntry:SetProps(WAB) for PR_ADDRTYPE -> %x\n", GetScode(hResult));
                                goto exit;
                            }

                        }

                    }
                }
            }
        }

        if (index != iDisplayName && index != NOT_FOUND && index != INDEX_FIRST_MIDDLE_LAST) {
            // Set the PR_DISPLAY_NAME
            sPropVal.ulPropTag = PR_DISPLAY_NAME;
            sPropVal.Value.LPSZ = rgItems[index];

            // Set the property on the WAB entry
            if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
              1,                        // cValues
              &sPropVal,                // property array
              NULL))) {                 // problems array
                DebugTrace("ImportEntry:SetProps(WAB) -> %x\n", GetScode(hResult));
                goto exit;
            }
        }


        // Save the new wab mailuser or distlist
        if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
          KEEP_OPEN_READONLY | FORCE_SAVE))) {

            if (GetScode(hResult) == MAPI_E_COLLISION) {
                /*
                // Find the display name
                Assert(lpDisplayName);
                if (! lpDisplayName) {
                    DebugTrace("Collision, but can't find PR_DISPLAY_NAME in entry\n");
                    goto exit;
                }
                */ // WAB replaces no Display Names with Unknown

                // Do we need to prompt?
                if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
                    // Prompt user with dialog.  If they say YES, we should try again


                    RI.lpszDisplayName = lpDisplayName ? lpDisplayName : "";
                    RI.lpszEmailAddress = lpEmailAddress;
                    RI.ConfirmResult = CONFIRM_ERROR;
                    RI.lpImportOptions = lpOptions;

                    DialogBoxParam(hInst,
                      MAKEINTRESOURCE(IDD_ImportReplace),
                      hWnd,
                      ReplaceDialogProc,
                      (LPARAM)&RI);

                    switch (RI.ConfirmResult) {
                        case CONFIRM_YES:
                        case CONFIRM_YES_TO_ALL:
                            // YES
                            // NOTE: recursive Migrate will fill in the SeenList entry
                            // go try again!
                            lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                            lpMailUserWAB = NULL;

                            ulCreateFlags |= CREATE_REPLACE;
                            goto retry;
                            break;

                        case CONFIRM_ABORT:
                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                            goto exit;

                        default:
                            // NO
                            break;
                    }
                }
                hResult = hrSuccess;

            } else {
                DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
            }
        }

        // Clean up
        if (rgItems) {
            for (i = 0; i < cProps; i++) {
                if (rgItems[i]) {
                    LocalFree(rgItems[i]);
                }
            }
            LocalFree(rgItems);
            rgItems = NULL;
        }

        // Update progress bar
        Progress.numerator++;
        // TEST CODE!
        if (Progress.numerator == Progress.denominator) {
            // Done?  Do I need to do anything?
        }

        lpProgressCB(hWnd, &Progress);
        if (lpMailUserWAB) {
            lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
            lpMailUserWAB = NULL;
        }

        if (lpDisplayName) {
            LocalFree(lpDisplayName);
            lpDisplayName = NULL;
        }


//        if (hResult) {
//            if (HandleExportError(hWnd, 0, hResult, lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ)) {
//                hResult = ResultFromScode(MAPI_E_USER_CANCEL);
//            } else {
//                hResult = hrSuccess;
//            }
//        }

    }

exit:
    if (hFile) {
        CloseHandle(hFile);
    }

    if (lpDisplayName) {
        LocalFree(lpDisplayName);
    }

    // Don't free lpEmailAddress!  It's part of the rgItems below.


    // Free the WAB objects
    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
    }
    if (lpContainer) {
        lpContainer->lpVtbl->Release(lpContainer);
    }

    // Free the prop name strings
    for (i = 0; i < NUM_EXPORT_PROPS; i++) {
        if (rgPropNames[i].lpszName) {
            LocalFree(rgPropNames[i].lpszName);
        }
    }

    // Free any CSV attributes left
    if (rgItems) {
        for (i = 0; i < cProps; i++) {
            if (rgItems[i]) {
                LocalFree(rgItems[i]);
            }
        }
        LocalFree(rgItems);
    }

    if (lpCreateEIDsWAB) {
        WABFreeBuffer(lpCreateEIDsWAB);
        lpCreateEIDsWAB = NULL;
    }


    return(hResult);
}



/***************************************************************************

    Name      : CreateCSVFile

    Purpose   : Creates a CSV file for export

    Parameters: hwnd = main dialog window
                lpFileName = filename to create
                lphFile -> returned file handle

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CreateCSVFile(HWND hwnd, LPTSTR lpFileName, LPHANDLE lphFile) {
    LPTSTR lpFilter;
    TCHAR szFileName[MAX_PATH + 1] = "";
    OPENFILENAME ofn;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HRESULT hResult = hrSuccess;


    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(lpFileName,
      GENERIC_WRITE,	
      0,    // sharing
      NULL,
      CREATE_NEW,
      FILE_FLAG_SEQUENTIAL_SCAN,	
      NULL))) {
        if (GetLastError() == ERROR_FILE_EXISTS) {
            // Ask user if they want to overwrite
            switch (ShowMessageBoxParam(hwnd, IDE_CSV_EXPORT_FILE_EXISTS, MB_ICONEXCLAMATION | MB_YESNO | MB_SETFOREGROUND, lpFileName)) {
                case IDYES:
                    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(lpFileName,
                      GENERIC_WRITE,	
                      0,    // sharing
                      NULL,
                      CREATE_ALWAYS,
                      FILE_FLAG_SEQUENTIAL_SCAN,	
                      NULL))) {
                        ShowMessageBoxParam(hwnd, IDE_CSV_EXPORT_FILE_ERROR, MB_ICONERROR, lpFileName);
                        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
                    }
                    break;

                default:
                    DebugTrace("ShowMessageBoxParam gave unknown return\n");

                case IDNO:
                    // nothing to do here
                    hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                    break;
            }
        } else {
            ShowMessageBoxParam(hwnd, IDE_CSV_EXPORT_FILE_ERROR, MB_ICONERROR, lpFileName);
            hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        }
    }

    if (! hResult) {
        *lphFile = hFile;
    }
    return(hResult);
}


/***************************************************************************

    Name      : WriteCSV

    Purpose   : Writes a string to a CSV file with fixups for special characters

    Parameters: hFile = file handle
                fFixup = TRUE if we should check for special characters
                lpString = nul-terminated string to write
                szSep = list separator (only needed if fFixup is TRUE)

    Returns   : HRESULT

    Comment   : CSV special characters are szSep, CR and LF.  If they occur in
                the string, we should wrap the entire string in quotes.

***************************************************************************/
HRESULT WriteCSV(HANDLE hFile, BOOL fFixup, const UCHAR * lpString, LPTSTR szSep) {
    HRESULT hResult = hrSuccess;
    ULONG cWrite = lstrlen((LPTSTR)lpString);
    ULONG cbWritten;
    BOOL fQuote = FALSE;
    register ULONG i;
    ULONG ec;
    LPTSTR szSepT;

    // Is there a szSep, a CR or a LF in the string?
    // If so, enclose the string in quotes.
    if (fFixup) {
        szSepT = szSep;
        for (i = 0; i < cWrite && ! fQuote; i++) {
            if (lpString[i] == (UCHAR)(*szSepT)) {
                szSepT++;
                if (*szSepT == '\0')
                    fQuote = TRUE;
            } else {
                szSepT = szSep;
                if ((lpString[i] == '\n') || (lpString[i] == '\r'))
                    fQuote = TRUE;
            }
        }
    }

    if (fQuote) {
        if (! WriteFile(hFile,
          szQuote,
          1,
          &cbWritten,
          NULL)) {
            ec = GetLastError();

            DebugTrace("WriteCSV:WriteFile -> %u\n", ec);
            if (ec == ERROR_HANDLE_DISK_FULL ||
                ec == ERROR_DISK_FULL) {
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_DISK);
            } else {
                hResult = ResultFromScode(MAPI_E_DISK_ERROR);
            }
            goto exit;
        }
    }

    if (! WriteFile(hFile,
      lpString,
      cWrite,
      &cbWritten,
      NULL)) {
        ec = GetLastError();

        DebugTrace("WriteCSV:WriteFile -> %u\n", ec);
        if (ec == ERROR_HANDLE_DISK_FULL ||
            ec == ERROR_DISK_FULL) {
            hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_DISK);
        } else {
            hResult = ResultFromScode(MAPI_E_DISK_ERROR);
        }
        goto exit;
    }

    if (fQuote) {
        if (! WriteFile(hFile,
          szQuote,
          1,
          &cbWritten,
          NULL)) {
            ec = GetLastError();

            DebugTrace("WriteCSV:WriteFile -> %u\n", ec);
            if (ec == ERROR_HANDLE_DISK_FULL ||
                ec == ERROR_DISK_FULL) {
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_DISK);
            } else {
                hResult = ResultFromScode(MAPI_E_DISK_ERROR);
            }
            goto exit;
        }
    }
exit:
    return(hResult);
}


HRESULT ExportCSVMailUser(HANDLE hFile,
  ULONG ulPropNames,
  ULONG ulLastProp,
  LPPROP_NAME lpPropNames,
  LPSPropTagArray lppta,
  LPTSTR szSep,
  LPADRBOOK lpAdrBook,
  ULONG cbEntryID,
  LPENTRYID lpEntryID) {
    HRESULT hResult = hrSuccess;
    LPMAILUSER lpMailUser = NULL;
    ULONG ulObjType;
    ULONG cProps;
    LPSPropValue lpspv = NULL;
    ULONG i;
    const UCHAR szCRLF[] = "\r\n";
    UCHAR szBuffer[11] = "";


    if (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
       cbEntryID,
       lpEntryID,
       NULL,
       0,
       &ulObjType,
       (LPUNKNOWN *)&lpMailUser)) {
        DebugTrace("WAB OpenEntry(mailuser) -> %x\n", GetScode(hResult));
        goto exit;
    }

    if ((HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
      lppta,
      0,
      &cProps,
      &lpspv)))) {
        DebugTrace("ExportCSVMailUser: GetProps() -> %x\n", GetScode(hResult));
        goto exit;
    }

    for (i = 0; i < ulPropNames; i++) {

        if (rgPropNames[i].fChosen) {
            // Output the value
            switch (PROP_TYPE(lpspv[i].ulPropTag)) {
                case PT_TSTRING:
                    if (hResult = WriteCSV(hFile, TRUE, lpspv[i].Value.LPSZ, szSep)) {
                        goto exit;
                    }
                    break;

                case PT_LONG:
                    wsprintf(szBuffer, "%u", lpspv[i].Value.l);
                    if (hResult = WriteCSV(hFile, TRUE, szBuffer, szSep)) {
                        goto exit;
                    }
                    break;

                default:
                    DebugTrace("CSV export: unsupported property 0x%08x\n", lpspv[i].ulPropTag);
                    Assert(FALSE);
                    // fall through to skip
                case PT_ERROR:
                    // skip it.
                    break;
            }

            if (i != ulLastProp) {
                // Output the seperator
                if (hResult = WriteCSV(hFile, FALSE, szSep, NULL)) {
                    goto exit;
                }
            }
        }
    }

    if (hResult = WriteCSV(hFile, FALSE, szCRLF, NULL)) {
        goto exit;
    }


exit:
    if (lpspv) {
        WABFreeBuffer(lpspv);
    }

    if (lpMailUser) {
        lpMailUser->lpVtbl->Release(lpMailUser);
    }

    return(hResult);
}


HRESULT CSVExport(HWND hWnd,
  LPADRBOOK lpAdrBook,
  LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPWAB_EXPORT_OPTIONS lpOptions) {
    HRESULT hResult = hrSuccess;
    register ULONG i;
    ULONG cbWABEID, ulObjType;
    ULONG ulLastChosenProp = 0;
    WAB_PROGRESS Progress;
    ULONG cRows = 0;
    LPSRowSet lpRow = NULL;
    ULONG ulCount = 0;
    SRestriction restrictObjectType;
    SPropValue spvObjectType;
    LPENTRYID lpWABEID = NULL;
    LPABCONT lpContainer = NULL;
    LPMAPITABLE lpContentsTable = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPSPropTagArray lppta = NULL;
    const UCHAR szCRLF[] = "\r\n";
    TCHAR szSep[MAX_SEP];
    TCHAR rgFileName[MAX_PATH + 1] = "";

    SetGlobalBufferFunctions(lpWABObject);

    // Read in the Property Name strings
    for (i = 0; i < NUM_EXPORT_PROPS; i++) {
        rgPropNames[i].lpszName = LoadAllocString(rgPropNames[i].ids);
        Assert(rgPropNames[i].lpszName);
        DebugTrace("Property 0x%08x name: %s\n", rgPropNames[i].ulPropTag, rgPropNames[i].lpszName);
    }

    // Present UI Wizard
    if (hResult = ExportWizard(hWnd, rgFileName, rgPropNames)) {
        goto exit;
    }

    // Find the last prop name chosen
    for (i = NUM_EXPORT_PROPS - 1; i > 0; i--) {
        if (rgPropNames[i].fChosen) {
            ulLastChosenProp = i;
            break;
        }
    }

    //
    // Open the WAB's PAB container
    //
    if (hResult = lpAdrBook->lpVtbl->GetPAB(lpAdrBook,
      &cbWABEID,
      &lpWABEID)) {
        DebugTrace("WAB GetPAB -> %x\n", GetScode(hResult));
        goto exit;
    } else {
        if (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
          cbWABEID,     // size of EntryID to open
          lpWABEID,     // EntryID to open
          NULL,         // interface
          0,            // flags
          &ulObjType,
          (LPUNKNOWN *)&lpContainer)) {
            DebugTrace("WAB OpenEntry(PAB) -> %x\n", GetScode(hResult));
            goto exit;
        }
    }


    //
    // All set... now loop through the WAB's entries, exporting each one
    //
    if (HR_FAILED(hResult = lpContainer->lpVtbl->GetContentsTable(lpContainer,
      0,    // ulFlags
      &lpContentsTable))) {
        DebugTrace("WAB GetContentsTable(PAB Table) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Set the columns to those we're interested in
    if (hResult = lpContentsTable->lpVtbl->SetColumns(lpContentsTable,
      (LPSPropTagArray)&ptaColumns,
      0)) {
        DebugTrace("WAB SetColumns(PAB Table) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Restrict the table to MAPI_MAILUSERs
    spvObjectType.ulPropTag = PR_OBJECT_TYPE;
    spvObjectType.Value.l = MAPI_MAILUSER;

    restrictObjectType.rt = RES_PROPERTY;
    restrictObjectType.res.resProperty.relop = RELOP_EQ;
    restrictObjectType.res.resProperty.ulPropTag = PR_OBJECT_TYPE;
    restrictObjectType.res.resProperty.lpProp = &spvObjectType;

    if (HR_FAILED(hResult = lpContentsTable->lpVtbl->Restrict(lpContentsTable,
      &restrictObjectType,
      0))) {
        DebugTrace("WAB Restrict (MAPI_MAILUSER) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // How many MailUser entries are there?
    ulcEntries = CountRows(lpContentsTable, FALSE);
    DebugTrace("WAB contains %u MailUser entries\n", ulcEntries);

    if (ulcEntries == 0) {
        DebugTrace("WAB has no entries, nothing to export.\n");
        goto exit;
    }

    // Initialize the Progress Bar
    Progress.denominator = max(ulcEntries, 1);
    Progress.numerator = 0;
    Progress.lpText = NULL;
    lpProgressCB(hWnd, &Progress);


    // Write out the property names
    GetListSeparator(szSep);

    // Create the file (and handle error UI)
    if (hResult = CreateCSVFile(hWnd, rgFileName, &hFile)) {
        goto exit;
    }

    for (i = 0; i < NUM_EXPORT_PROPS; i++) {
        // Output the name
        if (rgPropNames[i].fChosen) {
            if (hResult = WriteCSV(hFile, TRUE, rgPropNames[i].lpszName, szSep)) {
                goto exit;
            }

            if (i != ulLastChosenProp) {
                // Output the seperator
                if (hResult = WriteCSV(hFile, FALSE, szSep, NULL)) {
                    goto exit;
                }
            }
        }
    }
    if (hResult = WriteCSV(hFile, FALSE, szCRLF, NULL)) {
        goto exit;
    }


    // Map the prop name array to a SPropTagArray.
    lppta = LocalAlloc(LPTR, CbNewSPropTagArray(NUM_EXPORT_PROPS));
    lppta->cValues = NUM_EXPORT_PROPS;
    for (i = 0; i < lppta->cValues; i++) {
        lppta->aulPropTag[i] = rgPropNames[i].ulPropTag;
    }


    cRows = 1;

    while (cRows && hResult == hrSuccess) {

        // Get the next WAB entry
        if (hResult = lpContentsTable->lpVtbl->QueryRows(lpContentsTable,
          1,    // one row at a time
          0,    // ulFlags
          &lpRow)) {
            DebugTrace("QueryRows -> %x\n", GetScode(hResult));
            goto exit;
        }

        if (lpRow) {
            if (cRows = lpRow->cRows) { // Yes, single '='
                Assert(lpRow->cRows == 1);
                Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
                Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
                Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

                if (cRows = lpRow->cRows) { // yes, single '='

                    // Export mailuser
                    if (hResult = ExportCSVMailUser(hFile,
                      NUM_EXPORT_PROPS,
                      ulLastChosenProp,
                      rgPropNames,
                      lppta,
                      szSep,
                      lpAdrBook,
                      lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                      (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb)) {

                        goto exit;
                    }


                    // Update progress bar
                    Progress.numerator++;
                    lpProgressCB(hWnd, &Progress);

                    if (hResult) {
                        if (HandleExportError(hWnd,
                          0,
                          hResult,
                          lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ,
                          PropStringOrNULL(&lpRow->aRow[0].lpProps[iptaColumnsPR_EMAIL_ADDRESS]),
                          lpOptions)) {
                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                        } else {
                            hResult = hrSuccess;
                        }
                    }
                } // else, drop out of loop, we're done.
            }
            WABFreeProws(lpRow);
        }
    }

exit:
    if (hFile) {
        CloseHandle(hFile);
    }


    if (lppta) {
        LocalFree(lppta);
    }

    // Free the WAB objects
    WABFreeBuffer(lpWABEID);
    lpWABEID = NULL;
    if (lpContainer) {
        lpContainer->lpVtbl->Release(lpContainer);
        lpContainer = NULL;
    }
    if (lpContentsTable) {
        lpContentsTable->lpVtbl->Release(lpContentsTable);
        lpContentsTable = NULL;
    }


    // Free the prop name strings
    for (i = 0; i < NUM_EXPORT_PROPS; i++) {
        if (rgPropNames[i].lpszName) {
            LocalFree(rgPropNames[i].lpszName);
        }
    }

    return(hResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\csvparse.c ===
/*
 *  CSVParse.C
 *
 *  CSV Parsing functions
 *
 *  Copyright 1997 Microsoft Corporation.  All Rights Reserved.
 */
#include <windows.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include "dbgutil.h"


#define CR_CHAR 0x0d
#define LF_CHAR 0x0a
#define CCH_READ_BUFFER 256
#define NUM_ITEM_SLOTS  32

/***************************************************************************

    Name      : ReadCSVChar

    Purpose   : Reads a single char from a file

    Parameters: hFile = file handle
                pcbBuffer = pointer to size of buffer
                lppBuffer = pointer to pointer to buffer
                lppRead = pointer to pointer to next location to use

    Returns   : -1 = Out of memory
                0 = End of file
                1 = Char successfully read

    Comment   : Dynamically grows *lppBuffer as necessary

***************************************************************************/
int ReadCSVChar(HANDLE hFile, int *pcbBuffer, PUCHAR *lppBuffer, PUCHAR *lppRead)
{
    int cbOffset;
	ULONG cbReadFile;
    PUCHAR lpBuffer;

    cbOffset = (int) (*lppRead - *lppBuffer);
    if (cbOffset >= *pcbBuffer)
    {
        // Buffer is too small.  Reallocate!
        *pcbBuffer += CCH_READ_BUFFER;
        
        if (! (lpBuffer = LocalReAlloc(*lppBuffer, *pcbBuffer, LMEM_MOVEABLE | LMEM_ZEROINIT))) 
        {
            DebugTrace("LocalReAlloc(%u) -> %u\n", *pcbBuffer, GetLastError());
            return(-1);
        }
        *lppBuffer = lpBuffer;
        *lppRead = *lppBuffer + cbOffset;
    }

    // 1 character at a time
    if (ReadFile(hFile, *lppRead, 1, &cbReadFile, NULL) && cbReadFile)
        return(1);
	return(0);
}

/***************************************************************************

    Name      : ReadCSVItem

    Purpose   : Reads an item from a CSV file

    Parameters: hFile = file handle
                pcbBuffer = pointer to size of buffer
                lppBuffer = pointer to pointer to buffer
                szSep = current separator string

    Returns   : -1 = Out of memory
                0 = Item read in, and none left
                1 = Item read in, more items left

    Comment   : CSV special characters are '"', szSep, CR and LF.

                Rules for quotes:
                1. If an item starts with a '"', then the item is quoted
                   and must end with a '"'.
                2. Any '"' characters found in a non-quoted string will not
                   be treated specially.  Technically, there should not be
                   quotes in a non-quoted string, but we have to do
                   something if we find one.
                3. A quoted item ends with:
                   a) quote szSep
                   b) quote newline
                   or, c) quote <EOF>
                4. Two quotes together in a quoted string are translated
                   into a single quote.

***************************************************************************/
int ReadCSVItem(HANDLE hFile, int *pcbBuffer, PUCHAR *lppBuffer, LPTSTR szSep)
{
    BOOL fQuoted, fDone, fFoundSepCh;
    int cbReadFile;
    PUCHAR lpRead, szSepT;

    // This function is always called with one character already read
    lpRead = *lppBuffer;
    if (*lpRead == '"')
    {
        fQuoted = TRUE;
        cbReadFile = ReadCSVChar(hFile, pcbBuffer, lppBuffer, &lpRead);
    }
    else
    {
        fQuoted = FALSE;
        cbReadFile = 1;
    }
    szSepT = szSep;
    fDone = FALSE;
    do
    {
        if (cbReadFile <= 0)
        {
            // End of file means end of item
            if (cbReadFile == 0)
                *lpRead = '\0';
            break;
        }
        fFoundSepCh = FALSE;
        switch (*lpRead)
        {
            case CR_CHAR:
            case LF_CHAR:
                if (!fQuoted)
                {
                    // End of line and item
                    *lpRead = '\0';
                    cbReadFile = 0;
                    fDone = TRUE;
                }
                break;
            case '"':
                if (fQuoted)
                {
                    // See if the next character is a quote, CR, or LF
                    lpRead++;
                    cbReadFile = ReadCSVChar(hFile, pcbBuffer, lppBuffer, &lpRead);
                    if ((cbReadFile <= 0) || (*lpRead == '"') || (*lpRead == CR_CHAR) || (*lpRead == LF_CHAR))
                    {
                        if ((cbReadFile <= 0) || (*lpRead != '"'))
                        {
                            if (cbReadFile >= 0)
                            {
                                // End of file, or CR or LF
                                *(lpRead - 1) = '\0';
                                cbReadFile = 0;
                            }
                            // else out of memory
                            fDone = TRUE;
                        }
                        else
                        {
                            // Embedded quote - get rid of one
                            lpRead--;
                        }
                        break;
                    }
                    // We have read another character, and it is not a quote, CR, or LF
                    // Two possibilities:
                    // 1) Separator
                    // 2) Something else - this is an error condition
                    szSepT = szSep;
                    while ((cbReadFile > 0) && (*szSepT != '\0') && (*lpRead == *szSepT))
                    {
                        szSepT++;
                        if (*szSepT != '\0')
                        {
                            lpRead++;
                            cbReadFile = ReadCSVChar(hFile, pcbBuffer, lppBuffer, &lpRead);
                        }
                    }
                    if ((cbReadFile <= 0) || (*szSepT == '\0'))
                    {
                        if (cbReadFile >= 0)
                        {
                            // If cbReadFile is zero, we hit the end of file
                            // before finding the complete separator.  In this
                            // case, we simply take every character we have
                            // read, including the second quote, and use that
                            // as the item.
                            //
                            // Otherwise, we found the complete separator.
                            if (cbReadFile > 0)
                                lpRead -= lstrlen(szSep);
                            *lpRead = '\0';
                        }
                        fDone = TRUE;
                    }
                    else
                    {
                        // We found a second quote, but it was not followed by a
                        // separator.  In this case, we keep reading as if we are
                        // in an unquoted string.
                        fQuoted = FALSE;
                    }
                }
                break;
            default:
                if (!fQuoted)
                {
                    if (*lpRead == *szSepT)
                    {
                        szSepT++;
                        if (*szSepT == '\0')
                        {
                            // End of separator, thus end of item
                            lpRead -= (lstrlen(szSep) - 1);
                            *lpRead = '\0';
                            fDone = TRUE;
                        }
                        else
                            fFoundSepCh = TRUE;
                    }
                }
                break;
        }
        if (!fDone)
        {
            if (!fFoundSepCh)
                szSepT = szSep;
            lpRead++;
            cbReadFile = ReadCSVChar(hFile, pcbBuffer, lppBuffer, &lpRead);
        }
    }
    while (!fDone);
    return(cbReadFile);
}

/***************************************************************************

    Name      : InsertItem

    Purpose   : Takes an item read from the file and inserts it into the array

    Parameters: iItem = array index to insert
                pcItemSlots = number of currently allocated elements
                cGrow = number of items to grow the array by, if necessary
                prgItemSlots = pointer to the actual array
                lpBuffer = string to insert

    Returns   : TRUE = item successfully inserted
                FALSE = out of memory

***************************************************************************/
BOOL InsertItem(int iItem, int *pcItemSlots, int cGrow, PUCHAR **prgItemSlots, PUCHAR lpBuffer)
{
    PUCHAR *rgItemSlotsNew, lpItem;

    // Make sure there's room, first
    if (iItem >= *pcItemSlots) 
    {
        // Array is too small.  Reallocate!
        *pcItemSlots += cGrow;
        rgItemSlotsNew = LocalReAlloc(*prgItemSlots, *pcItemSlots * sizeof(PUCHAR), LMEM_MOVEABLE | LMEM_ZEROINIT);
        if (!rgItemSlotsNew)
        {
            DebugTrace("LocalReAlloc(%u) -> %u\n", *pcItemSlots * sizeof(PUCHAR), GetLastError());
            return(FALSE);
        }
        *prgItemSlots = rgItemSlotsNew;
    }

    lpItem = LocalAlloc(LPTR, lstrlen(lpBuffer) + 1);
    if (!lpItem)
    {
        DebugTrace("LocalAlloc(%u) -> %u\n", lstrlen(lpBuffer) + 1, GetLastError());
        return(FALSE);
    }

    lstrcpy(lpItem, lpBuffer);
    (*prgItemSlots)[iItem] = lpItem;

    return(TRUE);
}

/***************************************************************************

    Name      : ReadCSVLine                      x

    Purpose   : Reads a line from a CSV file with fixups for special characters

    Parameters: hFile = file handle
                szSep = list separator of the current regional settings
                lpcItems -> Returned number of items
                lprgItems -> Returned array of item strings.  Caller is
                  responsible for LocalFree'ing each string pointer and
                  this array pointer.

    Returns   : HRESULT

    Comment   : Calls the above helper functions to do most of the work.

***************************************************************************/
HRESULT ReadCSVLine(HANDLE hFile, LPTSTR szSep, ULONG * lpcItems, PUCHAR ** lpprgItems) {
    HRESULT hResult = hrSuccess;
    register ULONG i;
    PUCHAR lpBuffer  = NULL, lpRead, lpItem;
    ULONG cbBuffer = 0;
    int cbReadFile = -1;
    UCHAR chLastChar;
    ULONG iItem = 0;
    ULONG cItemSlots = 0;
    PUCHAR * rgItemSlots = NULL;
    LPTSTR szSepT;


    // Start out with 1024 character buffer.  Realloc as necesary.
    cbBuffer = CCH_READ_BUFFER;
    if (! (lpRead = lpBuffer = LocalAlloc(LPTR, cbBuffer))) {
        DebugTrace("LocalAlloc(%u) -> %u\n", cbBuffer, GetLastError());
        goto exit;
    }

    // Start out with 32 item slots.  Realloc as necesary.
    cItemSlots = NUM_ITEM_SLOTS;
    if (! (rgItemSlots = LocalAlloc(LPTR, cItemSlots * sizeof(PUCHAR)))) {
        DebugTrace("LocalAlloc(%u) -> %u\n", cItemSlots * sizeof(PUCHAR), GetLastError());
        goto exit;
    }

    // Skip past leading CR/LF characters
    do
        cbReadFile = ReadCSVChar(hFile, &cbBuffer, &lpBuffer, &lpRead);
    while((cbReadFile > 0) && ((*lpBuffer == CR_CHAR) || (*lpBuffer == LF_CHAR)));
 
    if (cbReadFile == 0)
    {
        // Nothing to return
        DebugTrace("ReadFile -> EOF\n");
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
    }

    // Read items until end of line or EOF
    while (cbReadFile > 0) 
    {
        cbReadFile = ReadCSVItem(hFile, &cbBuffer, &lpBuffer, szSep);
        if (cbReadFile >= 0)
        {
            // Dup the item into the next array slot.
            if (!InsertItem(iItem, &cItemSlots, cbReadFile ? NUM_ITEM_SLOTS : 1, &rgItemSlots, lpBuffer))
                cbReadFile = -1;
            else
                iItem++;

            if (cbReadFile > 0)
            {
                // More data to be read                
                lpRead = lpBuffer;
                cbReadFile = ReadCSVChar(hFile, &cbBuffer, &lpBuffer, &lpRead);
            }
        }
    }

exit:
    if (cbReadFile < 0)
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);

    if (lpBuffer) 
    {
        LocalFree(lpBuffer);
    }

    if (hResult) 
    {
        // Clean up
        if (rgItemSlots) 
        {
            for (i = 0; i < iItem; i++) 
            {
                if (rgItemSlots[i]) 
                {
                    LocalFree(rgItemSlots[i]);
                }
            }
            LocalFree(rgItemSlots);
        }
        *lpcItems = 0;
        *lpprgItems = NULL;
    } 
    else 
    {
        *lpcItems = iItem;  // One based
        *lpprgItems = rgItemSlots;
    }
    return(hResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\csvpick.c ===
/*                                  r
 *  CSVPick.C
 *
 *  Picker wizard for CSV import/export
 *
 *  Copyright 1997 Microsoft Corporation.  All Rights Reserved.
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#include "wabimp.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"


const TCHAR szCSVFilter[] = "*.csv";
const TCHAR szCSVExt[] = "csv";

#define CHECK_BITMAP_WIDTH  16
typedef struct {
    LPPROP_NAME rgPropNames;
    LPPROP_NAME * lppImportMapping;
    LPHANDLE lphFile;
    LPULONG lpcFields;
    LPTSTR szSep;
} PROPSHEET_DATA, * LPPROPSHEET_DATA;


TCHAR szCSVFileName[MAX_PATH + 1] = "";


INT_PTR CALLBACK ExportPickFieldsPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ExportFilePageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ImportFilePageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ImportMapFieldsPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ChangeMappingDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);


/***************************************************************************

    Name      : FillInPropertyPage

    Purpose   : Fills in the given PROPSHEETPAGE structure

    Parameters: psp -> property sheet page structure
                idDlg = dialog id
                pszProc = title for page
                pfnDlgProc -> Dialog procedure
                lParam = application specified data

    Returns   : none

    Comment   : This function fills in a PROPSHEETPAGE structure with the
                information the system needs to create the page.

***************************************************************************/
void FillInPropertyPage(PROPSHEETPAGE* psp, int idDlg, LPSTR pszProc,
  DLGPROC pfnDlgProc, LPARAM lParam) {
    psp->dwSize = sizeof(PROPSHEETPAGE);
    psp->dwFlags = 0;
    psp->hInstance = hInst;
    psp->pszTemplate = MAKEINTRESOURCE(idDlg);
    psp->pszIcon = NULL;
    psp->pfnDlgProc = pfnDlgProc;
    psp->pszTitle = pszProc;
    psp->lParam = lParam;
}


/***************************************************************************

    Name      : HandleCheckMark

    Purpose   : Deals with setting the checkmark for a particular item in
                the listview.

    Parameters: hwndLV = ListView handle
                iItem = index of item to set
                rgTable = PROP_NAME table

    Returns   : none

    Comment   :

***************************************************************************/
void HandleCheckMark(HWND hWndLV, ULONG iItem, LPPROP_NAME rgTable) {
    // Locals
    LV_ITEM lvi;

    // Clear it
    ZeroMemory(&lvi, sizeof(LV_ITEM));
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    ListView_GetItem(hWndLV, &lvi);
    rgTable[lvi.iItem].fChosen =
      ! rgTable[lvi.iItem].fChosen;

    ZeroMemory(&lvi, sizeof(LV_ITEM));
    lvi.mask = LVIF_STATE;
    lvi.iItem = iItem;
    lvi.state = rgTable[iItem].fChosen ?
      INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1) :
      INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1);

    lvi.stateMask = LVIS_STATEIMAGEMASK;
    ListView_SetItem(hWndLV, &lvi);
}


/***************************************************************************

    Name      : HandleMultipleCheckMarks

    Purpose   : Deals with setting the checkmark for a bunch of selected
                items in the list view - basically sets every selected item
                to the toggled state of the first item in the selection

    Parameters: hwndLV = ListView handle
                rgTable = LPPROP_NAME table

    Returns   : none

    Comment   :

***************************************************************************/
void HandleMultipleCheckMarks(HWND hWndLV, LPPROP_NAME rgTable)
{
    // Locals
    LV_ITEM lvi;
    int nIndex = 0;
    BOOL fState = FALSE;

    // get the index of the first item
    nIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);

    // toggle this item
    HandleCheckMark(hWndLV, nIndex, rgTable);

    fState = rgTable[nIndex].fChosen;

    while((nIndex = ListView_GetNextItem(hWndLV, nIndex, LVNI_SELECTED)) >= 0)
    {
        // Set all the other selected items to the same state

        rgTable[nIndex].fChosen = fState;

        ZeroMemory(&lvi, sizeof(LV_ITEM));
        lvi.mask = LVIF_STATE;
        lvi.iItem = nIndex;
        lvi.state = rgTable[nIndex].fChosen ?
          INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1) :
          INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1);

        lvi.stateMask = LVIS_STATEIMAGEMASK;
        ListView_SetItem(hWndLV, &lvi);
    }
    return;
}


/***************************************************************************

    Name      : ExportWizard

    Purpose   : Present the Export Wizard

    Parameters: hwnd = parent window handle
                szFileName -> filename buffer (MAX_PATH + 1, please)
                rgPropNames -> property name list

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT ExportWizard(HWND hWnd, LPTSTR szFileName, LPPROP_NAME rgPropNames) {
    HRESULT hResult = hrSuccess;
    PROPSHEETPAGE psp[NUM_EXPORT_WIZARD_PAGES];
    PROPSHEETHEADER psh;

    FillInPropertyPage(&psp[0], IDD_CSV_EXPORT_WIZARD_FILE, NULL, ExportFilePageProc, 0);
    FillInPropertyPage(&psp[1], IDD_CSV_EXPORT_WIZARD_PICK, NULL, ExportPickFieldsPageProc, 0);

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW | PSH_USEICONID;
    psh.hwndParent = hWnd;
    psh.pszCaption = NULL;
    psh.pszIcon = MAKEINTRESOURCE(IDI_WabMig);
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    psh.hIcon = NULL;
    psh.hInstance = hInst;
    psh.nStartPage = 0;
    psh.pStartPage = NULL;


    switch (PropertySheet(&psh)) {
        case -1:
            hResult = ResultFromScode(MAPI_E_CALL_FAILED);
            DebugTrace("PropertySheet failed -> %u\n", GetLastError());
            Assert(FALSE);
            break;
        case 0:
            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
            DebugTrace("PropertySheet cancelled by user\n");
            break;
        default:
            lstrcpy(szFileName, szCSVFileName);
            break;
    }

    return(hResult);
}


/***************************************************************************

    Name      : ImportWizard

    Purpose   : Present the CSV Import Wizard

    Parameters: hwnd = parent window handle
                szFileName -> filename buffer (MAX_PATH + 1, please)
                rgPropNames -> property name list
                szSep -> list separator
                lppImportMapping -> returned property mapping table
                lpcFields -> returned size of property mapping table
                lphFile -> returned file handle to CSV file with header
                  row already parsed out.

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT ImportWizard(HWND hWnd, LPTSTR szFileName, LPPROP_NAME rgPropNames,
  LPTSTR szSep, LPPROP_NAME * lppImportMapping, LPULONG lpcFields, LPHANDLE lphFile) {
    HRESULT hResult = hrSuccess;
    PROPSHEETPAGE psp[NUM_IMPORT_WIZARD_PAGES];
    PROPSHEETHEADER psh;
    PROPSHEET_DATA pd;

    pd.rgPropNames = rgPropNames;
    pd.lppImportMapping = lppImportMapping;
    pd.lphFile = lphFile;
    pd.lpcFields = lpcFields;
    pd.szSep = szSep;

    FillInPropertyPage(&psp[0], IDD_CSV_IMPORT_WIZARD_FILE, NULL, ImportFilePageProc, (LPARAM)&pd);
    FillInPropertyPage(&psp[1], IDD_CSV_IMPORT_WIZARD_MAP, NULL, ImportMapFieldsPageProc, (LPARAM)&pd);

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW | PSH_USEICONID;
    psh.hwndParent = hWnd;
    psh.pszCaption = NULL;
    psh.pszIcon = MAKEINTRESOURCE(IDI_WabMig);
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    psh.hIcon = NULL;
    psh.hInstance = hInst;
    psh.nStartPage = 0;
    psh.pStartPage = NULL;

    switch (PropertySheet(&psh)) {
        case -1:
            hResult = ResultFromScode(MAPI_E_CALL_FAILED);
            DebugTrace("PropertySheet failed -> %u\n", GetLastError());
            Assert(FALSE);
            break;
        case 0:
            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
            DebugTrace("PropertySheet cancelled by user\n");
            break;
        default:
            lstrcpy(szFileName, szCSVFileName);
            break;
    }

    return(hResult);
}


/***************************************************************************

    Name      : ExportFilePageProc

    Purpose   : Process messages for "Export Filename" page

    Parameters: standard window proc parameters

    Returns   : standard window proc return

    Messages  : WM_INITDIALOG - intializes the page
                WM_NOTIFY - processes the notifications sent to the page

    Comment   :

***************************************************************************/
INT_PTR CALLBACK ExportFilePageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    static TCHAR szTempFileName[MAX_PATH + 1] = "";

    switch (message) {
        case WM_INITDIALOG:
            lstrcpy(szTempFileName, szCSVFileName);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                    case IDC_BROWSE:
                        SendDlgItemMessage(hDlg, IDE_CSV_EXPORT_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szTempFileName);
                        SaveFileDialog(hDlg,
                          szTempFileName,
                          szCSVFilter,
                          IDS_CSV_FILE_SPEC,
                          szTextFilter,
                          IDS_TEXT_FILE_SPEC,
                          szAllFilter,
                          IDS_ALL_FILE_SPEC,
                          szCSVExt,
                          OFN_HIDEREADONLY | OFN_PATHMUSTEXIST,
                          hInst,
                          0,        // idsTitle
                          0);       // idsSaveButton
                        PropSheet_SetWizButtons(GetParent(hDlg), szTempFileName[0] ? PSWIZB_NEXT : 0);
                        SendMessage(GetDlgItem(hDlg, IDE_CSV_EXPORT_NAME), WM_SETTEXT, 0, (LPARAM)szTempFileName);
                    break;

                case IDE_CSV_EXPORT_NAME:
                    switch (HIWORD(wParam)) {   // notification code
                        case EN_CHANGE:
                            SendDlgItemMessage(hDlg, IDE_CSV_EXPORT_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szTempFileName);
                            if ((ULONG)LOWORD(wParam) == IDE_CSV_EXPORT_NAME) {
                                PropSheet_SetWizButtons(GetParent(hDlg), szTempFileName[0] ? PSWIZB_NEXT : 0);
                            }
                            break;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code) {
                case PSN_KILLACTIVE:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return(1);

                case PSN_RESET:
                    // reset to the original values
                    lstrcpy(szTempFileName, szCSVFileName);
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    break;

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), szTempFileName[0] ? PSWIZB_NEXT : 0);
                    SendMessage(GetDlgItem(hDlg, IDE_CSV_EXPORT_NAME), WM_SETTEXT, 0, (LPARAM)szTempFileName);
                    break;

                case PSN_WIZNEXT:
                    // the Next button was pressed
                    SendDlgItemMessage(hDlg, IDE_CSV_EXPORT_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szTempFileName);
                    lstrcpy(szCSVFileName, szTempFileName);
                    break;

                default:
                    return(FALSE);
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}


/***************************************************************************

    Name      : ExportPickFieldsPageProc

    Purpose   : Process messages for "Pick Fields" page

    Parameters: standard window proc parameters

    Returns   : standard window proc return

    Messages  : WM_INITDIALOG - intializes the page
                WM_NOTIFY - processes the notifications sent to the page

    Comment   :

***************************************************************************/
INT_PTR CALLBACK ExportPickFieldsPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    HWND hWndLV;
    HIMAGELIST himl;
    LV_ITEM lvi;
    LV_COLUMN lvm;
    LV_HITTESTINFO lvh;
    POINT point;
    ULONG i, nIndex;
    NMHDR * pnmhdr;
    RECT rect;

    switch (message) {
        case WM_INITDIALOG:
            // Ensure that the common control DLL is loaded.
            InitCommonControls();

            // List view hwnd
            hWndLV = GetDlgItem(hDlg, IDLV_PICKER);

            // Load Image List for list view
            if (himl = ImageList_LoadBitmap(hInst,
              MAKEINTRESOURCE(IDB_CHECKS),
              16,
              0,
              RGB(128, 0, 128))) {
                ListView_SetImageList(hWndLV, himl, LVSIL_STATE);
            }

            // Fill the listview
            ZeroMemory(&lvi, sizeof(LV_ITEM));
            lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;

            for (i = 0; i < NUM_EXPORT_PROPS; i++) {
                lvi.iItem = i;
                lvi.pszText = rgPropNames[i].lpszName;
                lvi.cchTextMax = lstrlen(lvi.pszText);
                lvi.lParam = (LPARAM)&rgPropNames[i];
                lvi.state = rgPropNames[i].fChosen ?
                  INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1) :
                  INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1);
                lvi.stateMask = LVIS_STATEIMAGEMASK;

                if (ListView_InsertItem(hWndLV, &lvi) == -1) {
                    DebugTrace("ListView_InsertItem -> %u\n", GetLastError());
                    Assert(FALSE);
                }
            }

            // Insert a column for the text
            // We don't have a header, so we don't need to set the text.
            ZeroMemory(&lvm, sizeof(LV_COLUMN));
            lvm.mask = LVCF_WIDTH;
            // set the column width to the size of our listbox.
            GetClientRect(hWndLV, &rect);
            lvm.cx = rect.right;
            ListView_InsertColumn(hWndLV, 0, &lvm);

            // Full row selection on listview
            ListView_SetExtendedListViewStyle(hWndLV, LVS_EX_FULLROWSELECT);

            // Select the first item in the list
            ListView_SetItemState(  hWndLV,
                                    0,
                                    LVIS_FOCUSED | LVIS_SELECTED,
                                    LVIS_FOCUSED | LVIS_SELECTED);

            return(1);

        case WM_COMMAND:
            return(TRUE);
            break;

        case WM_NOTIFY:
            pnmhdr = (LPNMHDR)lParam;

            switch (((NMHDR FAR *)lParam)->code) {
                case NM_CLICK:
                case NM_DBLCLK:
                    hWndLV = GetDlgItem(hDlg, IDLV_PICKER);

                    i = GetMessagePos();
                    point.x = LOWORD(i);
                    point.y = HIWORD(i);
                    ScreenToClient(hWndLV, &point);
                    lvh.pt = point;
                    nIndex = ListView_HitTest(hWndLV, &lvh);
                    // if single click on icon or double click anywhere, toggle the checkmark.
                    if (((NMHDR FAR *)lParam)->code == NM_DBLCLK ||
                      ( (lvh.flags & LVHT_ONITEMSTATEICON) && !(lvh.flags & LVHT_ONITEMLABEL))) {
                        HandleCheckMark(hWndLV, nIndex, rgPropNames);
                    }
                    break;

                case LVN_KEYDOWN:
                    hWndLV = GetDlgItem(hDlg, IDLV_PICKER);

                    // toggle checkmark if SPACE key is pressed
                    if (pnmhdr->hwndFrom == hWndLV) {
                        LV_KEYDOWN *pnkd = (LV_KEYDOWN *)lParam;
                        // BUG 25097 allow multiple select
                        if (pnkd->wVKey == VK_SPACE)
                        {
                            nIndex = ListView_GetSelectedCount(hWndLV);
                            if(nIndex == 1)
                            {
                                nIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED | LVNI_ALL);
                                //if (nIndex >= 0) {
                                    HandleCheckMark(hWndLV, nIndex, rgPropNames);
                                //}
                            }
                            else if(nIndex > 1)
                            {
                                //multiple select case ...
                                // Toggle all the selected items to the same state as the
                                // first item ...
                                HandleMultipleCheckMarks(hWndLV, rgPropNames);
                            }
                        }
                    }
                    break;

                case PSN_KILLACTIVE:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return(1);
                    break;

                case PSN_RESET:
                    // rest to the original values
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    break;

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
                    break;

                case PSN_WIZBACK:
                    break;

                case PSN_WIZFINISH:
                    // Here's where we do the export
                    break;

                default:
                    return(FALSE);
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}

//$$/////////////////////////////////////////////////////////////////////////////
//
// my_atoi - personal version of atoi function
//
//  lpsz - string to parse into numbers - non numeral characters are ignored
//
/////////////////////////////////////////////////////////////////////////////////
int my_atoi(LPTSTR lpsz)
{
    int i=0;
    int nValue = 0;

    if(lpsz)
    {
        if (lstrlen(lpsz))
        {
            nValue = 0;
            while((lpsz[i]!='\0')&&(i<=lstrlen(lpsz)))
            {
                int tmp = lpsz[i]-'0';
                if(tmp <= 9)
                    nValue = nValue*10 + tmp;
                i++;
            }
        }
    }

    return nValue;
}


typedef struct {
    LPTSTR lpszName;
    ULONG iPropNamesTable;  // index in rgProp
} SYNONYM, *LPSYNONYM;

/***************************************************************************

    Name      : FindPropName

    Purpose   : Finds a property name in the prop name table

    Parameters: lpName = name to find or NULL to free the static synonym table
                rgPropNames = property name table
                ulcPropNames = size of property name table

    Returns   : index into table or INDEX_NOT_FOUND

    Comment   :

***************************************************************************/
#define INDEX_NOT_FOUND 0xFFFFFFFF
ULONG FindPropName(PUCHAR lpName, LPPROP_NAME rgPropNames, ULONG ulcPropNames) {
    ULONG i;
    static LPSYNONYM lpSynonymTable = NULL;
    static ULONG ulSynonymsSave = 0;
    ULONG ulSynonyms = ulSynonymsSave;      // Keep local copy for compiler bug
    ULONG ulSynonymStrings = 0;

    if (lpName == NULL) {
        goto clean_table;
    }

    for (i = 0; i < ulcPropNames; i++) {
        if (! rgPropNames[i].fChosen) { // Don't re-use props!
            if (! lstrcmpi(lpName, rgPropNames[i].lpszName)) {
                return(i);
            }
        }
    }


    // If it wasn't found, look it up in the synonym table resource
    // First, make sure we have a synonym table loaded
    if (! lpSynonymTable) {
        TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
        LPTSTR lpSynonym, lpName;
        ULONG j;

        // Load the synonym table
        if (LoadString(hInst,
          idsSynonymCount,
          szBuffer, sizeof(szBuffer))) {
            DebugTrace("Loading synonym table, %s synonyms\n", szBuffer);
            ulSynonymStrings = my_atoi(szBuffer);

            if (ulSynonymStrings) {
                // Allocate the synonym table
                if (! (lpSynonymTable = LocalAlloc(LPTR, ulSynonymStrings * sizeof(SYNONYM)))) {
                    DebugTrace("LocalAlloc synonym table -> %u\n", GetLastError());
                    goto clean_table;
                }

                for (i = 0; i < ulSynonymStrings; i++) {
                    if (LoadString(hInst,
                      idsSynonym001 + i,        // ids of synonym string
                      szBuffer,
                      sizeof(szBuffer))) {
                        // Split the string at the '=' character
                        lpSynonym = lpName = szBuffer;
                        while (*lpName) {
                            if (*lpName == '=') {
                                // found equal sign, break the string here
                                *(lpName++) = '\0';
                                break;
                            }
                            lpName = CharNext(lpName);
                        }

                        // Find the name specified
                        for (j = 0; j < ulcPropNames; j++) {
                            if (! lstrcmpi(lpName, rgPropNames[j].lpszName)) {
                                // Found it
                                // Allocate a buffer for the synonym string
                                Assert(ulSynonyms < ulSynonymStrings);
                                if (! (lpSynonymTable[ulSynonyms].lpszName = LocalAlloc(LPTR, lstrlen(lpSynonym) + 1))) {
                                    DebugTrace("LocalAlloc in synonym table -> %u\n", GetLastError());
                                    goto clean_table;
                                }
                                lstrcpy(lpSynonymTable[ulSynonyms].lpszName, lpSynonym);
                                lpSynonymTable[ulSynonyms].iPropNamesTable = j;
                                ulSynonyms++;
                                break;
                            }
                        }
                    }
                }
            }
        }
        ulSynonymsSave = ulSynonyms;
    }

    if (lpSynonymTable) {
        // Find it
        for (i = 0; i < ulSynonyms; i++) {
            if (! lstrcmpi(lpName, lpSynonymTable[i].lpszName)) {
                // Found the name.  Is it already used?
                if (rgPropNames[lpSynonymTable[i].iPropNamesTable].fChosen) {
                    break;  // Found, but already used
                }

                return(lpSynonymTable[i].iPropNamesTable);
            }
        }
    }

exit:
    return(INDEX_NOT_FOUND);

clean_table:
    if (lpSynonymTable) {
        for (i = 0; i < ulSynonyms; i++) {
            if (lpSynonymTable[i].lpszName) {
                LocalFree(lpSynonymTable[i].lpszName);
            }
        }
        LocalFree(lpSynonymTable);
        lpSynonymTable = NULL;
        ulSynonymsSave = 0;
    }
    goto exit;
}


/***************************************************************************

    Name      : BuildCSVTable

    Purpose   : Builds the initial CSV mapping table from the file header.

    Parameters: lpFileName = filename to test
                rgPropnames = property name table
                szSep = separator character
                lppImportMapping -> returned mapping table
                lpcFields -> returned size of import mapping table
                lphFile -> returned file handle for CSV file.  File pointer
                  will be set past the header row.

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT BuildCSVTable(LPTSTR lpFileName, LPPROP_NAME rgPropNames, LPTSTR szSep,
  LPPROP_NAME * lppImportMapping, LPULONG lpcFields, LPHANDLE lphFile) {
    PUCHAR * rgItems = NULL;
    ULONG i, ulcItems = 0;
    LPPROP_NAME rgImportMapping = NULL;
    HRESULT hResult;
    ULONG ulPropIndex;


    // Open the file
    if ((*lphFile = CreateFile(lpFileName,
      GENERIC_READ,
      FILE_SHARE_READ | FILE_SHARE_WRITE,
      NULL,
      OPEN_EXISTING,
      FILE_FLAG_SEQUENTIAL_SCAN,
      NULL)) == INVALID_HANDLE_VALUE) {
        DebugTrace("Couldn't open file %s -> %u\n", lpFileName, GetLastError());
        return(ResultFromScode(MAPI_E_NOT_FOUND));
    }

    // Parse the first row
    if (hResult = ReadCSVLine(*lphFile, szSep, &ulcItems, &rgItems)) {
        DebugTrace("Couldn't read the CSV header\n");
        goto exit;
    }

    // Allocate the table
    if (! (*lppImportMapping = rgImportMapping = LocalAlloc(LPTR, ulcItems * sizeof(PROP_NAME)))) {
        DebugTrace("Allocation of import mapping table -> %u\n", GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Reset flags on WAB property table
    for (i = 0; i < NUM_EXPORT_PROPS; i++) {
        rgPropNames[i].fChosen = FALSE;
    }

    // Fill in the CSV fields
    for (i = 0; i < ulcItems; i++) {
        Assert(rgItems[i]);

        if (rgItems[i] && *rgItems[i]) {
            rgImportMapping[i].lpszCSVName = rgItems[i];

            // Look it up in the WAB property names table
            if (INDEX_NOT_FOUND != (ulPropIndex =  FindPropName(rgItems[i], rgPropNames, NUM_EXPORT_PROPS))) {
                // Found a match
                rgImportMapping[i].lpszName = rgPropNames[ulPropIndex].lpszName;
                rgImportMapping[i].ids = rgPropNames[ulPropIndex].ids;
                rgImportMapping[i].fChosen = TRUE;
                rgImportMapping[i].ulPropTag = rgPropNames[ulPropIndex].ulPropTag;
                rgPropNames[ulPropIndex].fChosen = TRUE;
                DebugTrace("Match   %u: %s\n", i, rgItems[i]);
            } else {
                DebugTrace("Unknown %u: %s\n", i, rgItems[i]);
            }
        } else {
            DebugTrace("Empty   %u: %s\n", i, rgItems[i]);
        }
    }

    *lpcFields = ulcItems;

exit:
    if (hResult) {
        if (*lphFile != INVALID_HANDLE_VALUE) {
            CloseHandle(*lphFile);
            *lphFile = INVALID_HANDLE_VALUE;
        }

        if (rgItems) {
            for (i = 0; i < ulcItems; i++) {
                if (rgItems[i]) {
                    LocalFree(rgItems[i]);
                }
            }
        }

        if (rgImportMapping) {
            LocalFree(rgImportMapping);
            *lppImportMapping = NULL;
        }
    }

    // If no error, leave the item strings since they are part of the mapping table.
    if (rgItems) {
        LocalFree(rgItems);
    }

    // Free the static memory for the synonym table.
    FindPropName(NULL, rgPropNames, NUM_EXPORT_PROPS);
    return(hResult);
}


/***************************************************************************

    Name      : FileExists

    Purpose   : Tests for existence of a file

    Parameters: lpFileName = filename to test

    Returns   : TRUE if the file exists

    Comment   :

***************************************************************************/
BOOL FileExists(LPTSTR lpFileName) {
    DWORD dwRet;

    if ((dwRet = GetFileAttributes(lpFileName)) == 0xFFFFFFFF) {
        return(FALSE);
    } else {
        return(! (dwRet & FILE_ATTRIBUTE_DIRECTORY));   // file was found
    }
}


/***************************************************************************

    Name      : ImportFilePageProc

    Purpose   : Process messages for "Import Filename" page

    Parameters: standard window proc parameters

    Returns   : standard window proc return

    Messages  : WM_INITDIALOG - intializes the page
                WM_NOTIFY - processes the notifications sent to the page

    Comment   :

***************************************************************************/
INT_PTR CALLBACK ImportFilePageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    static TCHAR szTempFileName[MAX_PATH + 1] = "";
    static LPPROPSHEET_DATA lppd = NULL;
    LPPROPSHEETPAGE lppsp;

    switch (message) {
        case WM_INITDIALOG:
            lstrcpy(szTempFileName, szCSVFileName);
            lppsp = (LPPROPSHEETPAGE)lParam;
            lppd = (LPPROPSHEET_DATA)lppsp->lParam;
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDC_BROWSE:
                    SendDlgItemMessage(hDlg, IDE_CSV_IMPORT_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szTempFileName);
                    OpenFileDialog(hDlg,
                      szTempFileName,
                      szCSVFilter,
                      IDS_CSV_FILE_SPEC,
                      szTextFilter,
                      IDS_TEXT_FILE_SPEC,
                      szAllFilter,
                      IDS_ALL_FILE_SPEC,
                      szCSVExt,
                      OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST,
                      hInst,
                      0,        //idsTitle
                      0);       // idsSaveButton
                    PropSheet_SetWizButtons(GetParent(hDlg), FileExists(szTempFileName) ? PSWIZB_NEXT : 0);
                    SendMessage(GetDlgItem(hDlg, IDE_CSV_IMPORT_NAME), WM_SETTEXT, 0, (LPARAM)szTempFileName);
                    break;

                case IDE_CSV_IMPORT_NAME:
                    switch (HIWORD(wParam)) {   // notification code
                        case EN_CHANGE:
                            SendDlgItemMessage(hDlg, IDE_CSV_IMPORT_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szTempFileName);
                            if ((ULONG)LOWORD(wParam) == IDE_CSV_IMPORT_NAME) {
                                PropSheet_SetWizButtons(GetParent(hDlg), FileExists(szTempFileName) ? PSWIZB_NEXT : 0);
                            }
                            break;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code) {
                case PSN_KILLACTIVE:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return(1);

                case PSN_RESET:
                    // reset to the original values
                    lstrcpy(szTempFileName, szCSVFileName);
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    break;

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), szTempFileName[0] ? PSWIZB_NEXT : 0);
                    SendMessage(GetDlgItem(hDlg, IDE_CSV_IMPORT_NAME), WM_SETTEXT, 0, (LPARAM)szTempFileName);
                    break;

                case PSN_WIZNEXT:
                    // the Next button was pressed
                    SendDlgItemMessage(hDlg, IDE_CSV_IMPORT_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szTempFileName);
                    lstrcpy(szCSVFileName, szTempFileName);
                    break;

                default:
                    return(FALSE);
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}


typedef struct {
    LPPROP_NAME lpMapping;
    LPPROP_NAME rgPropNames;
    ULONG ulcPropNames;
    ULONG ulColumn;
} CHANGE_MAPPING_INFO, * LPCHANGE_MAPPING_INFO;


void HandleChangeMapping(HWND hDlg, LPPROPSHEET_DATA lppd) {
    HWND hWndLV = GetDlgItem(hDlg, IDLV_MAPPER);
    ULONG nIndex;
    CHANGE_MAPPING_INFO cmi;
    LV_ITEM lvi;
    ULONG ulPropTagOld, i;
    LPPROP_NAME lpMappingTable;
    ULONG ulcMapping;

    if ((nIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED)) == 0xFFFFFFFF) {
        nIndex = 0;
        ListView_SetItemState(hWndLV, nIndex, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
    }

    lpMappingTable = *(lppd->lppImportMapping);

    cmi.lpMapping = &(lpMappingTable[nIndex]);
    cmi.rgPropNames = lppd->rgPropNames;
    cmi.ulcPropNames = NUM_EXPORT_PROPS;
    cmi.ulColumn = nIndex;

    ulPropTagOld = cmi.lpMapping->ulPropTag;

    DialogBoxParam(hInst,
      MAKEINTRESOURCE(IDD_CSV_CHANGE_MAPPING),
      hDlg,
      ChangeMappingDialogProc,
      (LPARAM)&cmi);

    // Fix the entry in the listbox
    ZeroMemory(&lvi, sizeof(LV_ITEM));

    // If there is no mapping, ensure that the field is unchosen
    if (cmi.lpMapping->ulPropTag == PR_NULL || cmi.lpMapping->ulPropTag == 0 ) {
        cmi.lpMapping->fChosen = FALSE;
    }

    lvi.iItem = nIndex;
    lvi.lParam = (LPARAM)NULL;

    lvi.mask = LVIF_STATE;
    lvi.iSubItem = 0;   // Checkbox is in first column
    lvi.state = cmi.lpMapping->fChosen ?
      INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1) :
      INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1);
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    if (ListView_SetItem(hWndLV, &lvi) == -1) {
        DebugTrace("ListView_SetItem -> %u\n", GetLastError());
        Assert(FALSE);
    }

    lvi.mask = LVIF_TEXT;
    lvi.iSubItem = 1;   // WAB Field
    lvi.pszText = cmi.lpMapping->lpszName ? cmi.lpMapping->lpszName : (LPTSTR)szEmpty;   // new wab field text
    if (ListView_SetItem(hWndLV, &lvi) == -1) {
        DebugTrace("ListView_SetItem -> %u\n", GetLastError());
        Assert(FALSE);
    }

    // if we changed the mapping, make sure there's not a duplicate proptag mapped.
    if (ulPropTagOld != cmi.lpMapping->ulPropTag) {
        ulcMapping = *(lppd->lpcFields);

        for (i = 0; i < ulcMapping; i++) {
            if ((i != nIndex) && cmi.lpMapping->ulPropTag == lpMappingTable[i].ulPropTag) {
                // Found a duplicate, nuke it.
                lpMappingTable[i].ulPropTag = PR_NULL;
                lpMappingTable[i].lpszName = (LPTSTR)szEmpty;
                lpMappingTable[i].ids = 0;
                lpMappingTable[i].fChosen = FALSE;

                // Now, redraw that row in the listview
                lvi.iItem = i;
                lvi.lParam = (LPARAM)NULL;

                // uncheck the box first
                lvi.mask = LVIF_STATE;
                lvi.iSubItem = 0;   // Checkbox is in first column
                lvi.state = INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1);
                lvi.stateMask = LVIS_STATEIMAGEMASK;
                if (ListView_SetItem(hWndLV, &lvi) == -1) {
                    DebugTrace("ListView_SetItem -> %u\n", GetLastError());
                    Assert(FALSE);
                }

                // Now, change the name mapping
                lvi.mask = LVIF_TEXT;
                lvi.iSubItem = 1;   // WAB Field
                lvi.pszText = (LPTSTR)szEmpty;   // new wab field text
                if (ListView_SetItem(hWndLV, &lvi) == -1) {
                    DebugTrace("ListView_SetItem -> %u\n", GetLastError());
                    Assert(FALSE);
                }
            }
        }
    }
}


/***************************************************************************

    Name      : FieldOrColumnName

    Purpose   : If the field name is empty, generate one for it.

    Parameters: lpField -> Field name pointer (may be null)
                index = index of this column
                szBuffer = buffer in which to create new string if
                  needed
                cbBuffer = size of szBuffer

    Returns   : pointer to correct field name

    Comment   :

***************************************************************************/
LPTSTR FieldOrColumnName(LPTSTR lpField, ULONG index, LPTSTR szBuffer, ULONG cbBuffer) {
    LPTSTR lpReturn = (LPTSTR)szEmpty;

    if (lpField && *lpField) {
        return(lpField);
    } else {
        TCHAR szFormat[MAX_RESOURCE_STRING + 1];
        TCHAR szNumber[11];
        LPTSTR lpszArg[1] = {szNumber};

        // Format a "Column 23" type of label
        wsprintf(szNumber, "%u", index);

        if (LoadString(hInst,
          IDS_CSV_COLUMN,
          szFormat,
          sizeof(szFormat))) {

            if (! FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
              szFormat,
              0, 0, //ignored
              szBuffer,
              cbBuffer,
              (va_list *)lpszArg)) {
                DebugTrace("FormatMessage -> %u\n", GetLastError());
            } else {
                lpReturn = szBuffer;
            }
        }
    }
    return(lpReturn);
}


/***************************************************************************

    Name      : ImportMapFieldsPageProc

    Purpose   : Process messages for "Mapi Fields" page

    Parameters: standard window proc parameters

    Returns   : standard window proc return

    Messages  : WM_INITDIALOG - intializes the page
                WM_NOTIFY - processes the notifications sent to the page

    Comment   :

***************************************************************************/
INT_PTR CALLBACK ImportMapFieldsPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    HWND hWndLV;
    HIMAGELIST himl;
    LV_ITEM lvi;
    LV_COLUMN lvm;
    LV_HITTESTINFO lvh;
    POINT point;
    ULONG i, nIndex, nOldIndex;
    NMHDR * pnmhdr;
    RECT rect;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1 + 10];
    ULONG cxTextWidth;
    static LPPROPSHEET_DATA lppd = NULL;
    LPPROPSHEETPAGE lppsp;
    HRESULT hResult;
    CHANGE_MAPPING_INFO cmi;
    LPPROP_NAME lpImportMapping;


    switch (message) {
        case WM_INITDIALOG:
            lppsp = (LPPROPSHEETPAGE)lParam;
            lppd = (LPPROPSHEET_DATA)lppsp->lParam;

            // Ensure that the common control DLL is loaded.
            InitCommonControls();

            // List view hwnd
            hWndLV = GetDlgItem(hDlg, IDLV_MAPPER);

            // How big should the text columns be?
            GetClientRect(hWndLV, &rect);
            cxTextWidth = (rect.right - CHECK_BITMAP_WIDTH) / 2;
            cxTextWidth -= cxTextWidth % 2;

            // Insert a column for the CSV Field Names
            ZeroMemory(&lvm, sizeof(LV_COLUMN));
            lvm.mask = LVCF_TEXT | LVCF_WIDTH;
            lvm.cx = cxTextWidth + 9;       // a touch more room for the bitmap

            // Get the string for the header
            if (LoadString(hInst, IDS_CSV_IMPORT_HEADER_CSV, szBuffer, sizeof(szBuffer))) {
                lvm.pszText = szBuffer;
            } else {
                DebugTrace("Cannot load resource string %u\n", IDS_CSV_IMPORT_HEADER_CSV);
                lvm.pszText = NULL;
                Assert(FALSE);
            }

            ListView_InsertColumn(hWndLV, 0, &lvm);

            // Insert a column for the WAB Field Names
            lvm.mask = LVCF_TEXT | LVCF_WIDTH;
            lvm.cx = cxTextWidth - 4;       // room for second column text

            // Get the string for the header
            if (LoadString(hInst, IDS_CSV_IMPORT_HEADER_WAB, szBuffer, sizeof(szBuffer))) {
                lvm.pszText = szBuffer;
            } else {
                DebugTrace("Cannot load resource string %u\n", IDS_CSV_IMPORT_HEADER_WAB);
                lvm.pszText = NULL;
                Assert(FALSE);
            }

            ListView_InsertColumn(hWndLV, 1, &lvm);

            // Full row selection on listview
            ListView_SetExtendedListViewStyle(hWndLV, LVS_EX_FULLROWSELECT);

            // Load Image List for list view
            if (himl = ImageList_LoadBitmap(hInst,
              MAKEINTRESOURCE(IDB_CHECKS),
              CHECK_BITMAP_WIDTH,
              0,
              RGB(128, 0, 128))) {
                ListView_SetImageList(hWndLV, himl, LVSIL_STATE);
            }

            // Fill the listview
            ZeroMemory(&lvi, sizeof(LV_ITEM));

            // Open the file and parse out the headers line
            if ((! (hResult = BuildCSVTable(szCSVFileName, lppd->rgPropNames,
              lppd->szSep, lppd->lppImportMapping, lppd->lpcFields, lppd->lphFile))) && ((*lppd->lpcFields) > 0)) {
                for (i = 0; i < *lppd->lpcFields; i++) {
                    ULONG index;
                    TCHAR szBuffer[MAX_RESOURCE_STRING + 1 + 10];

                    lpImportMapping = *lppd->lppImportMapping;

                    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
                    lvi.iItem = i;
                    lvi.iSubItem = 0;
                    lvi.pszText = FieldOrColumnName(lpImportMapping[i].lpszCSVName,
                      i,
                      szBuffer,
                      sizeof(szBuffer));
                    lvi.cchTextMax = lstrlen(lvi.pszText);
                    lvi.lParam = (LPARAM)&lpImportMapping[i];
                    lvi.state = lpImportMapping[i].fChosen ?
                      INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1) :
                      INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1);
                    lvi.stateMask = LVIS_STATEIMAGEMASK;

                    if (index = ListView_InsertItem(hWndLV, &lvi) == -1) {
                        DebugTrace("ListView_InsertItem -> %u\n", GetLastError());
                        Assert(FALSE);
                    }


                    lvi.mask = LVIF_TEXT;
                    // lvi.iItem = index;
                    lvi.iSubItem = 1;   // WAB Field
                    lvi.pszText = lpImportMapping[i].lpszName ? lpImportMapping[i].lpszName : (LPTSTR)szEmpty;   // new wab field text
                    lvi.lParam = (LPARAM)NULL;

                    if (ListView_SetItem(hWndLV, &lvi) == -1) {
                        DebugTrace("ListView_SetItem -> %u\n", GetLastError());
                        Assert(FALSE);
                    }
                }
            }
            else
                EnableWindow(GetDlgItem(hDlg,IDC_CHANGE_MAPPING),FALSE);

            // Select the first item in the list
            ListView_SetItemState(  hWndLV,
                                    0,
                                    LVIS_FOCUSED | LVIS_SELECTED,
                                    LVIS_FOCUSED | LVIS_SELECTED);
            return(1);

        case WM_NOTIFY:
            pnmhdr = (LPNMHDR)lParam;

            switch (((NMHDR FAR *)lParam)->code) {
                case NM_CLICK:
                    hWndLV = GetDlgItem(hDlg, IDLV_MAPPER);

                    i = GetMessagePos();
                    point.x = LOWORD(i);
                    point.y = HIWORD(i);
                    ScreenToClient(hWndLV, &point);
                    lvh.pt = point;
                    nIndex = ListView_HitTest(hWndLV, &lvh);
                    // if single click on icon or double click anywhere, toggle the checkmark.
                    if (((NMHDR FAR *)lParam)->code == NM_DBLCLK ||
                      ( (lvh.flags & LVHT_ONITEMSTATEICON) && !(lvh.flags & LVHT_ONITEMLABEL))) {
                        HandleCheckMark(hWndLV, nIndex, *lppd->lppImportMapping);

                        // if the box is now clicked, but there is no mapping, bring up the
                        // mapping dialog
                        if ((*(lppd->lppImportMapping))[nIndex].fChosen &&
                          (! (*(lppd->lppImportMapping))[nIndex].lpszName ||
                           lstrlen((*(lppd->lppImportMapping))[nIndex].lpszName) == 0)) {
                            // Select the row
                            ListView_SetItemState(hWndLV, nIndex, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
                            HandleChangeMapping(hDlg, lppd);
                        }
                    }
                    break;


                case NM_DBLCLK:
                    hWndLV = GetDlgItem(hDlg, IDLV_MAPPER);
                    i = GetMessagePos();
                    point.x = LOWORD(i);
                    point.y = HIWORD(i);
                    ScreenToClient(hWndLV, &point);
                    lvh.pt = point;
                    nIndex = ListView_HitTest(hWndLV, &lvh);
                    ListView_SetItemState(hWndLV, nIndex, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
                    HandleChangeMapping(hDlg, lppd);
                    break;

                case LVN_KEYDOWN:
                    hWndLV = GetDlgItem(hDlg, IDLV_MAPPER);

                    // toggle checkmark if SPACE key is pressed
                    if (pnmhdr->hwndFrom == hWndLV) {
                        LV_KEYDOWN *pnkd = (LV_KEYDOWN *)lParam;
                        if (pnkd->wVKey == VK_SPACE) {
                            nIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED | LVNI_ALL);
                            //if (nIndex >= 0) 
                            {
                                HandleCheckMark(hWndLV, nIndex, *lppd->lppImportMapping);

                                // if the box is now clicked, but there is no mapping, bring up the
                                // mapping dialog
                                if ((*(lppd->lppImportMapping))[nIndex].fChosen &&
                                    (! (*(lppd->lppImportMapping))[nIndex].lpszName ||
                                     lstrlen((*(lppd->lppImportMapping))[nIndex].lpszName) == 0)) {
                                    // Select the row
                                    ListView_SetItemState(hWndLV, nIndex, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
                                    HandleChangeMapping(hDlg, lppd);
                                }
                            }
                        }
                    }
                    break;

                case PSN_KILLACTIVE:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return(1);
                    break;

                case PSN_RESET:
                    // rest to the original values


                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    break;

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
                    break;

                case PSN_WIZBACK:
                    break;

                case PSN_WIZFINISH:
                    // Validate the properties selected to make sure we have
                    // name fields of some kind.
                    lpImportMapping = *lppd->lppImportMapping;

                    for (i = 0; i < *lppd->lpcFields; i++) {
                        ULONG ulPropTag = lpImportMapping[i].ulPropTag;
                        if (lpImportMapping[i].fChosen && (
                          ulPropTag == PR_DISPLAY_NAME ||
                          ulPropTag == PR_SURNAME ||
                          ulPropTag == PR_GIVEN_NAME ||
                          ulPropTag == PR_NICKNAME ||
                          ulPropTag == PR_COMPANY_NAME ||
                          ulPropTag == PR_EMAIL_ADDRESS ||
                          ulPropTag == PR_MIDDLE_NAME)) {
                            return(TRUE);    // OK to go do the import
                        }
                    }

                    ShowMessageBoxParam(hDlg, IDE_CSV_NO_COLUMNS, 0);
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;

                default:
                    return(FALSE);
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDC_CHANGE_MAPPING:
                    HandleChangeMapping(hDlg, lppd);
                    break;
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}


INT_PTR CALLBACK ChangeMappingDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    LPCHANGE_MAPPING_INFO lpcmi = (LPCHANGE_MAPPING_INFO)GetWindowLongPtr(hwnd, DWLP_USER);
    static BOOL fChosenSave = FALSE;
    ULONG iItem;


    switch (message) {
        case WM_INITDIALOG:
            {
                TCHAR szFormat[MAX_RESOURCE_STRING + 1];
                TCHAR szBuffer[MAX_RESOURCE_STRING + 1 + 10];
                LPTSTR lpszMessage = NULL;
                ULONG ids, i, iDefault = 0xFFFFFFFF;
                HWND hwndComboBox = GetDlgItem(hwnd, IDC_CSV_MAPPING_COMBO);

                SetWindowLongPtr(hwnd, DWLP_USER, lParam);  //Save this for future reference
                lpcmi = (LPCHANGE_MAPPING_INFO)lParam;

                fChosenSave = lpcmi->lpMapping->fChosen;

                if (LoadString(hInst,
                  IDS_CSV_CHANGE_MAPPING_TEXT_FIELD,
                  szFormat, sizeof(szFormat))) {
                    LPTSTR lpszArg[1] = {FieldOrColumnName(lpcmi->lpMapping->lpszCSVName,
                      lpcmi->ulColumn,
                      szBuffer,
                      sizeof(szBuffer))};

                    if (! FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      szFormat,
                      0, 0, //ignored
                      (LPTSTR)&lpszMessage,
                      0,
                      (va_list *)lpszArg)) {
                        DebugTrace("FormatMessage -> %u\n", GetLastError());
                    } else {
                        if (! SetDlgItemText(hwnd, IDC_CSV_CHANGE_MAPPING_TEXT_FIELD, lpszMessage)) {
                            DebugTrace("SetDlgItemText -> %u\n", GetLastError());
                        }
                        LocalFree(lpszMessage);
                    }
                }

                // Fill in the combo box
                for (i = 0; i < lpcmi->ulcPropNames; i++) {
                    SendMessage(hwndComboBox, CB_ADDSTRING, 0, (LPARAM)lpcmi->rgPropNames[i].lpszName);
                    if (lpcmi->lpMapping->ids == lpcmi->rgPropNames[i].ids) {
                        SendMessage(hwndComboBox, CB_SETCURSEL, (WPARAM)i, 0);
                    }
                }

                // Add blank line
                SendMessage(hwndComboBox, CB_ADDSTRING, 0, (LPARAM)szEmpty);
                if (lpcmi->lpMapping->ids == 0) {
                    SendMessage(hwndComboBox, CB_SETCURSEL, (WPARAM)(i + 1), 0);
                }

                // Init the checkbox
                CheckDlgButton(hwnd, IDC_CSV_MAPPING_SELECT, fChosenSave ? BST_CHECKED : BST_UNCHECKED);
                return(TRUE);
            }

        case WM_COMMAND :
            switch (LOWORD(wParam)) {
                case IDCANCEL:
                    lpcmi->lpMapping->fChosen = fChosenSave;
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDCLOSE:
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDOK:
                    // Set the state of the parameter
                    // Get the mapping
                    if ((iItem = (ULONG) SendMessage(GetDlgItem(hwnd, IDC_CSV_MAPPING_COMBO), CB_GETCURSEL, 0, 0)) != CB_ERR) {
                        if (iItem >= lpcmi->ulcPropNames) {
                            lpcmi->lpMapping->lpszName = (LPTSTR)szEmpty;
                            lpcmi->lpMapping->ids = 0;
                            lpcmi->lpMapping->ulPropTag = PR_NULL;
                            lpcmi->lpMapping->fChosen = FALSE;
                        } else {
                            lpcmi->lpMapping->lpszName = rgPropNames[iItem].lpszName;
                            lpcmi->lpMapping->ids = rgPropNames[iItem].ids;
                            lpcmi->lpMapping->ulPropTag = rgPropNames[iItem].ulPropTag;
                        }
                    }
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);

                case IDM_EXIT:
                    SendMessage(hwnd, WM_DESTROY, 0, 0L);
                    return(0);

                case IDC_CSV_MAPPING_SELECT:
                    switch (HIWORD(wParam)) {
                        case BN_CLICKED:
                            if ((int)LOWORD(wParam) == IDC_CSV_MAPPING_SELECT) {
                                // toggle the checkbox
                                lpcmi->lpMapping->fChosen = ! lpcmi->lpMapping->fChosen;
                                CheckDlgButton(hwnd, IDC_CSV_MAPPING_SELECT, lpcmi->lpMapping->fChosen ? BST_CHECKED : BST_UNCHECKED);
                            }
                            break;
                    }
                    break;
                }
            break;


        case IDCANCEL:
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case WM_CLOSE:
            EndDialog(hwnd, FALSE);
            return(0);

        default:
            return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\ldif.c ===
/*
 *  LDIF.C
 *
 *  Migrate LDIF <-> WAB
 *
 *  Copyright 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  To Do:
 *      ObjectClass recognition
 *      Attribute mapping
 *      Groups
 *      Base64
 *      URLs
 *      Reject Change List LDIF
 *
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#include "wabimp.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"
#include "initguid.h"

#define CR_CHAR 0x0d
#define LF_CHAR 0x0a
#define CCH_READ_BUFFER 1024
#define NUM_ITEM_SLOTS  32

BOOL decodeBase64(char * bufcoded, char * pbuffdecoded, DWORD  * pcbDecoded);

// for conferencing stuff
#define CHANGE_PROP_TYPE(ulPropTag, ulPropType) \
                        (((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)

HRESULT HrLoadPrivateWABProps(LPADRBOOK );
/*
- The following IDs and tags are for the conferencing named properties
-
-   The GUID for these props is PS_Conferencing
*/

DEFINE_OLEGUID(PS_Conferencing, 0x00062004, 0, 0);

enum _ConferencingTags
{
    prWABConfServers = 0,
    prWABConfMax
};

#define CONF_SERVERS        0x8056

#define OLK_NAMEDPROPS_START CONF_SERVERS

ULONG PR_SERVERS;

SizedSPropTagArray(prWABConfMax, ptaUIDetlsPropsConferencing);
// end conferencing duplication

// Index into LDIF_ATTR_TABLE
//
// IMPORTANT: This is an intentionally ordered list!
// Within synonyms, the earlier attributes listed take precedence over those that follow.  For
// example, if the record contains both "co" and "o" attributes, the value in the "co" attribute
// will be used for PR_COMPANY_NAME.
typedef enum _LDIF_ATTRIBUTES {
    // PR_OBJECT_TYPE
    ela_objectclass = 0,                        // object class (required)

    // PR_COUNTRY
    ela_c,                                      // country
    ela_countryname,

    // PR_DISPLAY_NAME
    ela_display_name,                           // (Microsoft servers use this)
    ela_cn,                                     // common name (display name)
    ela_commonName,                             // (display name)

    // PR_COMPANY_NAME
    ela_co,                                     // company
    ela_organizationName,                       // (company)
    ela_o,                                      // organization (company)

    // PR_MIDDLE_NAME
    ela_initials,

    // PR_SURNAME
    ela_sn,                                     // surname
    ela_surname,

    // PR_GIVEN_NAME
    ela_givenname,
    ela_uid,                                    // (given name) ?

    // PR_DEPARTMENT_NAME
    ela_department,
    ela_ou,                                     // organizational unit (department)
    ela_organizationalUnitName,                 // (department)

    // PR_COMMENT
    ela_comment,
    ela_description,                            // description
    ela_info,                                   // info

    // PR_LOCALITY
    ela_l,                                      // locality (city)
    ela_locality,                               // locality (city)

    // no mapping
    ela_dn,                                     // distinguished name

    // PR_NICKNAME
    ela_xmozillanickname,                       // Netscape nickname

    // no mapping
    ela_conferenceInformation,                  // conference server
    ela_xmozillaconference,                     // Netscape conference server

    // PR_HOME_FAX_NUMBER
    ela_facsimiletelephonenumber,               // home fax number

    // PR_BUSINESS_FAX_NUMBER
    ela_OfficeFax,

    // PR_BUSINESS_TELEPHONE_NUMBER
    ela_telephonenumber,

    // PR_HOME_TELEPHONE_NUMBER
    ela_homephonenumber,

    // PR_MOBILE_TELEPHONE_NUMBER
    ela_mobile,                                 // cellular phone number

    // PR_PAGER_TELEPHONE_NUMBER
    ela_OfficePager,
    ela_pager,

    // PR_OFFICE_LOCATION
    ela_physicalDeliveryOfficeName,             // office location

    // PR_HOME_ADDRESS_STREET
    ela_homePostalAddress,

    // PR_STREET_ADDRESS
    ela_streetAddress,                          // business street address
    ela_street,                                 // business street address
    ela_postalAddress,                          // business street address

    // PR_STATE_OR_PROVINCE
    ela_st,                                     // business address state

    // PR_POST_OFFICE_BOX
    ela_postOfficeBox,                          // business PO Box

    // PR_POSTAL_CODE
    ela_postalcode,                             // business address zip code

    // PR_PERSONAL_HOME_PAGE
    ela_homepage,                               // personal home page

    // PR_BUSINESS_HOME_PAGE
    ela_URL,                                    // business home page

    // PR_EMAIL_ADDRESS
    ela_mail,                                   // email address

    // PR_CONTACT_EMAIL_ADDRESSES
    ela_otherMailbox,                           // secondary email addresses

    // PR_TITLE
    ela_title,                                  // title

    // no mapping
    ela_member,                                 // DL member

    // no mapping
    ela_userCertificate,                        // certificate

    // no mapping
    ela_labeledURI,                             // labelled URI URL

    // no mapping
    ela_xmozillauseconferenceserver,            // Netscape conference info

    // no mapping
    ela_xmozillausehtmlmail,                    // Netscape HTML mail flag

    ela_Max,
} LDIF_ATTRIBUTES, *LPLDIF_ATTRIBUTES;

typedef struct _LDIF_ATTR_TABLE {
    const BYTE * lpName;                        // LDIF attribute name
    ULONG index;                                // attribute index within LDIF record
    ULONG ulPropTag;                            // prop tag mapping
    ULONG ulPropIndex;                          // index in prop array
} LDIF_ATTR_TABLE, *LPLDIF_ATTR_TABLE;


typedef enum _LDIF_PROPERTIES {
    elp_OBJECT_TYPE,
    elp_DISPLAY_NAME,
    elp_EMAIL_ADDRESS,
    elp_SURNAME,
    elp_GIVEN_NAME,
    elp_TITLE,
    elp_COMPANY_NAME,
    elp_OFFICE_LOCATION,
    elp_HOME_ADDRESS_STREET,
    elp_STREET_ADDRESS,
    elp_STATE_OR_PROVINCE,
    elp_POST_OFFICE_BOX,
    elp_POSTAL_CODE,
    elp_LOCALITY,
    elp_COUNTRY,
    elp_MIDDLE_NAME,
    elp_DEPARTMENT_NAME,
    elp_COMMENT,
    elp_NICKNAME,
    elp_HOME_FAX_NUMBER,
    elp_BUSINESS_FAX_NUMBER,
    elp_BUSINESS_TELEPHONE_NUMBER,
    elp_HOME_TELEPHONE_NUMBER,
    elp_MOBILE_TELEPHONE_NUMBER,
    elp_PAGER_TELEPHONE_NUMBER,
    elp_PERSONAL_HOME_PAGE,
    elp_BUSINESS_HOME_PAGE,
    elp_CONTACT_EMAIL_ADDRESSES,
    elp_CONFERENCE_SERVERS,
    elp_Max
} LDIF_ATTRIBUTES, *LPLDIF_ATTRIBUTES;


// Must have
//  PR_DISPLAY_NAME

#define NUM_MUST_HAVE_PROPS 1

typedef enum _LDIF_DATA_TYPE {
    LDIF_ASCII,
    LDIF_BASE64,
    LDIF_URL
} LDIF_DATA_TYPE, *LPLDIF_DATA_TYPE;

typedef struct _LDIF_RECORD_ATTRIBUTE {
    LPBYTE lpName;
    LPBYTE lpData;
    ULONG cbData;
    LDIF_DATA_TYPE Type;
} LDIF_RECORD_ATTRIBUTE, * LPLDIF_RECORD_ATTRIBUTE;

const TCHAR szLDIFFilter[] =                    "*.ldf;*.ldif";
const TCHAR szLDIFExt[] =                       "ldf";


// LDAP attribute names
const BYTE sz_c[] =                             "c";
const BYTE sz_cn[] =                            "cn";
const BYTE sz_co[] =                            "co";
const BYTE sz_comment[] =                       "comment";
const BYTE sz_commonName[] =                    "commonName";
const BYTE sz_conferenceInformation[] =         "conferenceInformation";
const BYTE sz_countryname[] =                   "countryname";
const BYTE sz_department[] =                    "department";
const BYTE sz_description[] =                   "description";
const BYTE sz_display_name[] =                  "display-name";
const BYTE sz_dn[] =                            "dn";
const BYTE sz_facsimiletelephonenumber[] =      "facsimiletelephonenumber";
const BYTE sz_givenname[] =                     "givenname";
const BYTE sz_homePostalAddress[] =             "homePostalAddress";
const BYTE sz_homepage[] =                      "homepage";
const BYTE sz_info[] =                          "info";
const BYTE sz_initials[] =                      "initials";
const BYTE sz_l[] =                             "l";
const BYTE sz_labeledURI[] =                    "labeledURI";
const BYTE sz_locality[] =                      "locality";
const BYTE sz_mail[] =                          "mail";
const BYTE sz_member[] =                        "member";
const BYTE sz_mobile[] =                        "mobile";
const BYTE sz_o[] =                             "o";
const BYTE sz_objectclass[] =                   "objectclass";
const BYTE sz_OfficeFax[] =                     "OfficeFax";
const BYTE sz_OfficePager[] =                   "OfficePager";
const BYTE sz_organizationName[] =              "organizationName";
const BYTE sz_organizationalUnitName[] =        "organizationalUnitName";
const BYTE sz_otherMailbox[] =                  "otherMailbox";
const BYTE sz_ou[] =                            "ou";
const BYTE sz_pager[] =                         "pager";
const BYTE sz_physicalDeliveryOfficeName[] =    "physicalDeliveryOfficeName";
const BYTE sz_postOfficeBox[] =                 "postOfficeBox";
const BYTE sz_postalAddress[] =                 "postalAddress";
const BYTE sz_postalcode[] =                    "postalcode";
const BYTE sz_sn[] =                            "sn";
const BYTE sz_st[] =                            "st";
const BYTE sz_streetAddress[] =                 "streetAddress";
const BYTE sz_street[] =                        "street";
const BYTE sz_surname[] =                       "surname";
const BYTE sz_telephonenumber[] =               "telephonenumber";
const BYTE sz_homephonenumber[] =               "homephone";
const BYTE sz_title[] =                         "title";
const BYTE sz_uid[] =                           "uid";
const BYTE sz_URL[] =                           "URL";
const BYTE sz_userCertificate[] =               "userCertificate";
const BYTE sz_xmozillaconference[] =            "xmozillaconference";
const BYTE sz_xmozillanickname[] =              "xmozillanickname";
const BYTE sz_xmozillauseconferenceserver[] =   "xmozillauseconferenceserver";
const BYTE sz_xmozillausehtmlmail[] =           "xmozillausehtmlmail";


// LDAP objectclass values
const BYTE sz_groupOfNames[] =                  "groupOfNames";
const BYTE sz_person[] =                        "person";
const BYTE sz_organizationalPerson[] =          "organizationalPerson";

// since defs aren't shared -- these are also defined in ui_detls.c
const LPTSTR szCallto = TEXT("callto://"); 
const LPTSTR szFwdSlash = "/";

BOOL HandleImportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_IMPORT_OPTIONS lpImportOptions);
BOOL HandleExportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_EXPORT_OPTIONS lpExportOptions);



/***************************************************************************

    Name      : FreeLDIFRecord

    Purpose   : Frees an LDIF record structure

    Parameters: lpLDIFRecord -> record to clean up
                ulAttributes = number of attributes in lpLDIFRecord

    Returns   : none

    Comment   :

***************************************************************************/
void FreeLDIFRecord(LPLDIF_RECORD_ATTRIBUTE lpLDIFRecord, ULONG ulAttributes) {
    ULONG i;

    if (lpLDIFRecord) {
        for (i = 0; i < ulAttributes; i++) {
            if (lpLDIFRecord[i].lpName) {
                LocalFree(lpLDIFRecord[i].lpName);
                lpLDIFRecord[i].lpName = NULL;
            }
            if (lpLDIFRecord[i].lpData) {
                LocalFree(lpLDIFRecord[i].lpData);
                lpLDIFRecord[i].lpData = NULL;
            }
        }
        LocalFree(lpLDIFRecord);
    }
}


/***************************************************************************

    Name      : OpenLDIFFile

    Purpose   : Opens a LDIF file for import

    Parameters: hwnd = main dialog window
                lpFileName = filename to create
                lphFile -> returned file handle

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT OpenLDIFFile(HWND hwnd, LPTSTR lpFileName, LPHANDLE lphFile) {
    LPTSTR lpFilter;
    TCHAR szFileName[MAX_PATH + 1] = "";
    OPENFILENAME ofn;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HRESULT hResult = hrSuccess;
    DWORD ec;


    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(lpFileName,
      GENERIC_READ,
      0,    // sharing
      NULL,
      CREATE_NEW,
      FILE_FLAG_SEQUENTIAL_SCAN,
      NULL))) {
        ec = GetLastError();
        DebugTrace("CreateFile(%s) -> %u\n", lpFileName, ec);
        switch (ec) {
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
            default:
                ShowMessageBoxParam(hwnd, IDE_LDIF_IMPORT_FILE_ERROR, MB_ICONERROR, lpFileName);
                hResult = ResultFromScode(MAPI_E_NOT_FOUND);
                break;
        }
    }

    if (! hResult) {
        *lphFile = hFile;
    }
    return(hResult);
}


/***************************************************************************

    Name      : ReadLDIFLine

    Purpose   : Reads a line from and LDIF file

    Parameters: hFile = File handle
                lppBuffer -> In/Out start of read buffer (return line data here)
                lpcbBuffer = In/Out size of buffer

    Returns   : number of bytes read from file

    Comment   :

***************************************************************************/
ULONG ReadLDIFLine(HANDLE hFile, LPBYTE * lppBuffer, LPULONG lpcbBuffer) {
    ULONG cbRead = 0;
    ULONG cbReadFile = 0;
    BOOL fDone = FALSE;
    BOOL fColumn1 = TRUE;
    BOOL fComment = FALSE;
    BOOL fComent = FALSE;
    ULONG ulSavePosition = 0;
    LPBYTE lpRead = *lppBuffer;     // current read pointer
    LPBYTE lpT;

    while (! fDone) {
        if (cbRead >= (*lpcbBuffer - 1)) {     // leave room for null
            ULONG cbOffset = (ULONG) (lpRead - *lppBuffer);

            // Buffer is too small.  Reallocate!
            *lpcbBuffer += CCH_READ_BUFFER;
            if (! (lpT = LocalReAlloc(*lppBuffer, *lpcbBuffer, LMEM_MOVEABLE | LMEM_ZEROINIT))) {
                DebugTrace("LocalReAlloc(%u) -> %u\n", *lpcbBuffer, GetLastError());
                break;
            }
            *lppBuffer = lpT;
            lpRead = *lppBuffer + cbOffset;
        }

        if ((! ReadFile(hFile,
          lpRead,
          1,        // 1 character at a time
          &cbReadFile,
          NULL)) || cbReadFile == 0) {
            DebugTrace("ReadFile -> EOF\n");
            fDone = TRUE;
        } else {
            cbReadFile++;

            // Got a character
            // Is it interesting?
            switch (*lpRead) {
                case '#':   // Comment line
                    if (fColumn1) {
                        // This is a comment line.  Dump the whole line
                        fComment = TRUE;
                    } else {
                        cbRead++;
                        lpRead++;
                    }
                    fColumn1 = FALSE;
                    break;

                case ' ':
                    if (fColumn1 || fComment) {
                        // This is a continuation or a comment, eat this space.
                    } else {
                        cbRead++;
                        lpRead++;
                    }
                    fColumn1 = FALSE;
                    break;

                case '\n':      // LDIF SEP character
                    if (fColumn1) {
                        // This is not a continuation, we've gone too far.  Back up!
                        if (ulSavePosition) {
                            if (0xFFFFFFFF == (SetFilePointer(hFile, ulSavePosition, NULL, FILE_BEGIN))) {
                                DebugTrace("CountCSVRows SetFilePointer -> %u\n", GetLastError());
                                return(ResultFromScode(MAPI_E_CALL_FAILED));
                            }
                        }
                        fDone = TRUE;
                    } else {
                        fColumn1 = TRUE;
                        fComment = FALSE;
                        // Should check if next line starts with continuation character (space)
                        // Save the current position in case it isn't.
                        if (0xFFFFFFFF == (ulSavePosition = SetFilePointer(hFile, 0, NULL, FILE_CURRENT))) {
                            DebugTrace("CountCSVRows SetFilePointer -> %u\n", GetLastError());
                        }
                    }
                    break;

                case '\r':      // Eat the Carriage Return character
                    break;

                default:
                    if (! fComment) {
                        if (cbRead && fColumn1) {
                            // This is not a continuation, we've gone too far.  Back up!
                            Assert(ulSavePosition);
                            if (ulSavePosition) {
                                if (0xFFFFFFFF == (SetFilePointer(hFile, ulSavePosition, NULL, FILE_BEGIN))) {
                                    DebugTrace("CountCSVRows SetFilePointer -> %u\n", GetLastError());
                                    return(ResultFromScode(MAPI_E_CALL_FAILED));
                                }
                            }
                            fDone = TRUE;
                        } else {
                            cbRead++;
                            lpRead++;
                        }
                    }
                    fColumn1 = FALSE;
                    break;
            }
        }
    }

    *lpRead = '\0';    // Terminate the string
    //DebugTrace("LDIF Line: %s\n", *lppBuffer);
    return(cbReadFile);
}


/***************************************************************************

    Name      : ParseLDIFLine

    Purpose   : Parse the LDIF input line into Name and Data

    Parameters: lpBuffer -> input buffer
                lppName -> returned name pointer (pointer into lpBuffer)
                lppData -> returned data pointer (pointer into lpBuffer)
                lpcbData -> returned data size
                lpType -> returned LDIF data type

    Returns   : HRESULT

    Comment   : Caller should not free the *lppName and *lppData pointers
                since they are just pointers into the input buffer.

                Assume that lpBuffer is NULL terminated.

                LDIF attrval is formed like this:
                attrname ((":") / (":" *SPACE value) /
                  ("::" *SPACE base64-value) /
                  (":<" *SPACE url))

***************************************************************************/
HRESULT ParseLDIFLine(LPBYTE lpBuffer, PUCHAR * lppName, PUCHAR * lppData,
  LPULONG lpcbData, LPLDIF_DATA_TYPE lpType) {
    HRESULT hResult = hrSuccess;
    LPBYTE lpTemp = lpBuffer;

    // Strip of leading white space
    while (*lpTemp == ' ' || *lpTemp == '\r' || *lpTemp == '\n') {
        lpTemp++;
    }

    if (*lpTemp) {
        *lppName = lpTemp;

        // Look for the end of the name
        while (lpTemp && *lpTemp && *lpTemp != ':') {
            lpTemp++;
        }

        if (*lpTemp != ':') {
            // Hmm, this isn't very good LDIF.  Error out.
            hResult = ResultFromScode(MAPI_E_BAD_VALUE);
            goto exit;
        }

        // now pointing to the ':', put a NULL there to terminate the name
        *lpTemp = '\0';

        // What type of encoding is it?
        lpTemp++;

        switch (*lpTemp) {
            case ':':
                *lpType = LDIF_BASE64;
                lpTemp++;
                break;

            case '<':
                *lpType = LDIF_URL;
                lpTemp++;
                break;

            case '\0':
                // No data.  This is legitimate.
                // Fall through to default.

            default:    // anything else implies ASCII value
                *lpType = LDIF_ASCII;
                break;
        }

        // Strip of spaces leading the data
        while (*lpTemp == ' ') {
            lpTemp++;
        }

        // Now pointing at data
        *lppData = lpTemp;

        // Count bytes of data
        *lpcbData = lstrlen(lpTemp) + 1;
    }

exit:
    return(hResult);
}


/***************************************************************************

    Name      : ReadLDIFRecord

    Purpose   : Reads a record from an LDIF file with fixups for special characters

    Parameters: hFile = file handle
                lpcItems -> Returned number of items
                lprgItems -> Returned array of item strings.  Caller is
                  responsible for LocalFree'ing each string pointer and
                  this array pointer.

    Returns   : HRESULT

    Comment   : LDIF special characters are '#', ' ', CR and LF.
                Rules:
                    1) A line which starts with '#' is a comment
                    2) A line which starts with a ' ' is a continuation

***************************************************************************/
HRESULT ReadLDIFRecord(HANDLE hFile, ULONG * lpcItems, LPLDIF_RECORD_ATTRIBUTE * lppLDIFRecord) {
    HRESULT hResult = hrSuccess;
    PUCHAR lpBuffer  = NULL;
    ULONG cbBuffer = 0;
    ULONG cbReadFile = 1;
    ULONG iItem = 0;
    ULONG cAttributes = 0;
    BOOL fEOR = FALSE;
    LPLDIF_RECORD_ATTRIBUTE lpLDIFRecord = NULL;
    LDIF_DATA_TYPE Type;
    LPBYTE lpData = NULL;
    LPTSTR lpName = NULL;
    ULONG cbData = 0;
    TCHAR szTemp[2048]; // 2k limit
    LPLDIF_RECORD_ATTRIBUTE lpLDIFRecordT;



    // Start out with 1024 character buffer.  Realloc as necesary.
    cbBuffer = CCH_READ_BUFFER;
    if (! (lpBuffer = LocalAlloc(LPTR, cbBuffer))) {
        DebugTrace("LocalAlloc(%u) -> %u\n", cbBuffer, GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Start out with 32 item slots.  Realloc as necesary.
    cAttributes = NUM_ITEM_SLOTS;
    if (! (lpLDIFRecord = LocalAlloc(LPTR, cAttributes * sizeof(LDIF_RECORD_ATTRIBUTE)))) {
        DebugTrace("LocalAlloc(%u) -> %u\n", cAttributes * sizeof(PUCHAR), GetLastError());
        LocalFree(lpBuffer);
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Read attributes lines until you get end of record or EOF
    while (! fEOR) {
        // Read the next line (merges continuation)
        if (cbReadFile = ReadLDIFLine(hFile, &lpBuffer, &cbBuffer)) 
        {
            // Got another attribute, parse it
            if (hResult = ParseLDIFLine(lpBuffer, &lpName, &lpData, &cbData, &Type)) {
                goto exit;
            }

            // End of record?
            if (! lpName || ! lstrlen(lpName)) {
                fEOR = TRUE;
                break;
            }

            // Make sure there's room in the returned table for this attribute
            if (iItem >= cAttributes) {
                // Array is too small.  Reallocate!
                cAttributes += 1;   // NUM_ITEM_SLOTS;      // Allocate another batch
                if (! (lpLDIFRecordT = LocalReAlloc(lpLDIFRecord, cAttributes * sizeof(LDIF_RECORD_ATTRIBUTE), LMEM_MOVEABLE | LMEM_ZEROINIT))) 
                {
                    DebugTrace("LocalReAlloc(%u) -> %u\n", cAttributes * sizeof(PUCHAR), GetLastError());
                    hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                    goto exit;
                }
                lpLDIFRecord = lpLDIFRecordT;
            }

            // Fill in the attribute in the structure

            // BUGBUG: Here's where we should decode BASE64

            if(Type == LDIF_BASE64)
            {
                ULONG cb = sizeof(szTemp);
                *szTemp = '\0';
                decodeBase64(  lpData, szTemp, &cb);
                if(szTemp && lstrlen(szTemp))
                {
                    lpData = szTemp;
                    cbData = cb;
                    szTemp[cb] = '\0';
                }
            }

            lpLDIFRecord[iItem].Type = Type;
            lpLDIFRecord[iItem].cbData = cbData;

            if (! (lpLDIFRecord[iItem].lpData = LocalAlloc(LPTR, cbData))) 
            {
                DebugTrace("LocalAlloc(%u) -> %u\n", cbData, GetLastError());
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            memcpy(lpLDIFRecord[iItem].lpData, lpData, cbData);

            if (! (lpLDIFRecord[iItem].lpName = LocalAlloc(LPTR, lstrlen(lpName) + 1))) 
            {
                DebugTrace("LocalAlloc(%u) -> %u\n", lstrlen(lpName) + 1, GetLastError());
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            lstrcpy(lpLDIFRecord[iItem].lpName, lpName);
        } else {
            fEOR = TRUE;
            hResult = ResultFromScode(WAB_W_END_OF_FILE);
        }

        iItem++;
    }

exit:
    if (lpBuffer) {
        LocalFree(lpBuffer);
    }

    if (hResult) {
        if (lpLDIFRecord) {
            FreeLDIFRecord(lpLDIFRecord, iItem);
            lpLDIFRecord = NULL;
        }
    }

    *lppLDIFRecord = lpLDIFRecord;
    *lpcItems = iItem;

    return(hResult);
}


/***************************************************************************

    Name      : CountLDIFRows

    Purpose   : Counts the rows in the LDIF file

    Parameters: hFile = open LDIF file
                lpulcEntries -> returned count of rows

    Returns   : HRESULT

    Comment   : File pointer should be positioned past the version string prior
                to calling this function.  This function leaves the file
                pointer where it found it.

***************************************************************************/
HRESULT CountLDIFRecords(HANDLE hFile, LPULONG lpulcEntries) {
    HRESULT hResult = hrSuccess;
    PUCHAR * rgItems = NULL;
    ULONG ulStart;
    ULONG cProps, i;
    LPLDIF_RECORD_ATTRIBUTE lpLDIFRecord = NULL;

    *lpulcEntries = 0;

    Assert(hFile != INVALID_HANDLE_VALUE);

    if (0xFFFFFFFF == (ulStart = SetFilePointer(hFile, 0, NULL, FILE_CURRENT))) {
        DebugTrace("CountCSVRows SetFilePointer -> %u\n", GetLastError());
        return(ResultFromScode(MAPI_E_CALL_FAILED));
    }


    while (hResult == hrSuccess) {
        // Read the line
        if (ReadLDIFRecord(hFile, &cProps, &lpLDIFRecord)) {
            // End of file
            break;
        }

        (*lpulcEntries)++;

        if (lpLDIFRecord) {
            FreeLDIFRecord(lpLDIFRecord, cProps);
            lpLDIFRecord = NULL;
        }
    }
    if (0xFFFFFFFF == SetFilePointer(hFile, ulStart, NULL, FILE_BEGIN)) {
        DebugTrace("CountCSVRows SetFilePointer -> %u\n", GetLastError());
    }

    DebugTrace("LDIF file contains %u entries\n", ulcEntries);
    return(hResult);
}


/***************************************************************************

    Name      : InitLDIFAttrTable

    Purpose   : Initialize the LDIF attribute table

    Parameters: LDIFAttrTable = table of attribute mappings

    Returns   : none

***************************************************************************/
void InitLDIFAttrTable(LPLDIF_ATTR_TABLE LDIFAttrTable) {
    ULONG i;

    for (i = 0; i < ela_Max; i++) {
        LDIFAttrTable[i].index = NOT_FOUND;
        LDIFAttrTable[i].ulPropTag = PR_NULL;
    }
    LDIFAttrTable[ela_c].lpName = sz_c;
    LDIFAttrTable[ela_cn].lpName = sz_cn;
    LDIFAttrTable[ela_co].lpName = sz_co;
    LDIFAttrTable[ela_comment].lpName = sz_comment;
    LDIFAttrTable[ela_commonName].lpName = sz_commonName;
    LDIFAttrTable[ela_conferenceInformation].lpName = sz_conferenceInformation;
    LDIFAttrTable[ela_countryname].lpName = sz_countryname;
    LDIFAttrTable[ela_department].lpName = sz_department;
    LDIFAttrTable[ela_description].lpName = sz_description;
    LDIFAttrTable[ela_display_name].lpName = sz_display_name;
    LDIFAttrTable[ela_dn].lpName = sz_dn;
    LDIFAttrTable[ela_facsimiletelephonenumber].lpName = sz_facsimiletelephonenumber;
    LDIFAttrTable[ela_givenname].lpName = sz_givenname;
    LDIFAttrTable[ela_homePostalAddress].lpName = sz_homePostalAddress;
    LDIFAttrTable[ela_homepage].lpName = sz_homepage;
    LDIFAttrTable[ela_info].lpName = sz_info;
    LDIFAttrTable[ela_initials].lpName = sz_initials;
    LDIFAttrTable[ela_l].lpName = sz_l;
    LDIFAttrTable[ela_labeledURI].lpName = sz_labeledURI;
    LDIFAttrTable[ela_locality].lpName = sz_locality;
    LDIFAttrTable[ela_mail].lpName = sz_mail;
    LDIFAttrTable[ela_member].lpName = sz_member;
    LDIFAttrTable[ela_mobile].lpName = sz_mobile;
    LDIFAttrTable[ela_o].lpName = sz_o;
    LDIFAttrTable[ela_objectclass].lpName = sz_objectclass;
    LDIFAttrTable[ela_OfficeFax].lpName = sz_OfficeFax;
    LDIFAttrTable[ela_OfficePager].lpName = sz_OfficePager;
    LDIFAttrTable[ela_organizationName].lpName = sz_organizationName;
    LDIFAttrTable[ela_organizationalUnitName].lpName = sz_organizationalUnitName;
    LDIFAttrTable[ela_otherMailbox].lpName = sz_otherMailbox;
    LDIFAttrTable[ela_ou].lpName = sz_ou;
    LDIFAttrTable[ela_pager].lpName = sz_pager;
    LDIFAttrTable[ela_physicalDeliveryOfficeName].lpName = sz_physicalDeliveryOfficeName;
    LDIFAttrTable[ela_postOfficeBox].lpName = sz_postOfficeBox;
    LDIFAttrTable[ela_postalAddress].lpName = sz_postalAddress;
    LDIFAttrTable[ela_postalcode].lpName = sz_postalcode;
    LDIFAttrTable[ela_sn].lpName = sz_sn;
    LDIFAttrTable[ela_st].lpName = sz_st;
    LDIFAttrTable[ela_streetAddress].lpName = sz_streetAddress;
    LDIFAttrTable[ela_street].lpName = sz_street;
    LDIFAttrTable[ela_surname].lpName = sz_surname;
    LDIFAttrTable[ela_telephonenumber].lpName = sz_telephonenumber;
    LDIFAttrTable[ela_homephonenumber].lpName = sz_homephonenumber;
    LDIFAttrTable[ela_title].lpName = sz_title;
    LDIFAttrTable[ela_uid].lpName = sz_uid;
    LDIFAttrTable[ela_URL].lpName = sz_URL;
    LDIFAttrTable[ela_userCertificate].lpName = sz_userCertificate;
    LDIFAttrTable[ela_xmozillaconference].lpName = sz_xmozillaconference;
    LDIFAttrTable[ela_xmozillanickname].lpName = sz_xmozillanickname;
    LDIFAttrTable[ela_xmozillauseconferenceserver].lpName = sz_xmozillauseconferenceserver;
    LDIFAttrTable[ela_xmozillausehtmlmail].lpName = sz_xmozillausehtmlmail;


    LDIFAttrTable[ela_c].ulPropTag = PR_COUNTRY;
    LDIFAttrTable[ela_c].ulPropIndex = elp_COUNTRY;
    LDIFAttrTable[ela_cn].ulPropTag = PR_DISPLAY_NAME;
    LDIFAttrTable[ela_cn].ulPropIndex = elp_DISPLAY_NAME;
    LDIFAttrTable[ela_co].ulPropTag = PR_COMPANY_NAME;
    LDIFAttrTable[ela_co].ulPropIndex = elp_COMPANY_NAME;
    LDIFAttrTable[ela_comment].ulPropTag = PR_COMMENT;
    LDIFAttrTable[ela_comment].ulPropIndex = elp_COMMENT;
    LDIFAttrTable[ela_commonName].ulPropTag = PR_DISPLAY_NAME;
    LDIFAttrTable[ela_commonName].ulPropIndex = elp_DISPLAY_NAME;
    LDIFAttrTable[ela_conferenceInformation].ulPropTag = PR_NULL; // bugbug?
    LDIFAttrTable[ela_conferenceInformation].ulPropIndex = NOT_FOUND;
    LDIFAttrTable[ela_countryname].ulPropTag = PR_COUNTRY;
    LDIFAttrTable[ela_countryname].ulPropIndex = elp_COUNTRY;
    LDIFAttrTable[ela_department].ulPropTag = PR_DEPARTMENT_NAME;
    LDIFAttrTable[ela_department].ulPropIndex = elp_DEPARTMENT_NAME;
    LDIFAttrTable[ela_description].ulPropTag = PR_COMMENT;
    LDIFAttrTable[ela_description].ulPropIndex = elp_COMMENT;
    LDIFAttrTable[ela_display_name].ulPropTag = PR_DISPLAY_NAME;
    LDIFAttrTable[ela_display_name].ulPropIndex = elp_DISPLAY_NAME;
    LDIFAttrTable[ela_dn].ulPropTag = PR_DISPLAY_NAME;
    LDIFAttrTable[ela_dn].ulPropIndex = elp_DISPLAY_NAME;
    LDIFAttrTable[ela_facsimiletelephonenumber].ulPropTag = PR_HOME_FAX_NUMBER;
    LDIFAttrTable[ela_facsimiletelephonenumber].ulPropIndex = elp_HOME_FAX_NUMBER;
    LDIFAttrTable[ela_givenname].ulPropTag = PR_GIVEN_NAME;
    LDIFAttrTable[ela_givenname].ulPropIndex = elp_GIVEN_NAME;
    LDIFAttrTable[ela_homePostalAddress].ulPropTag = PR_HOME_ADDRESS_STREET;
    LDIFAttrTable[ela_homePostalAddress].ulPropIndex = elp_HOME_ADDRESS_STREET;
    LDIFAttrTable[ela_homepage].ulPropTag = PR_PERSONAL_HOME_PAGE;
    LDIFAttrTable[ela_homepage].ulPropIndex = elp_PERSONAL_HOME_PAGE;
    LDIFAttrTable[ela_info].ulPropTag = PR_COMMENT;
    LDIFAttrTable[ela_info].ulPropIndex = elp_COMMENT;
    LDIFAttrTable[ela_initials].ulPropTag = PR_MIDDLE_NAME;
    LDIFAttrTable[ela_initials].ulPropIndex = elp_MIDDLE_NAME;
    LDIFAttrTable[ela_l].ulPropTag = PR_LOCALITY;
    LDIFAttrTable[ela_l].ulPropIndex = elp_LOCALITY;
    LDIFAttrTable[ela_labeledURI].ulPropTag = PR_NULL;                      // Labeled URI.  Don't save now.
    LDIFAttrTable[ela_labeledURI].ulPropIndex = NOT_FOUND;
    LDIFAttrTable[ela_locality].ulPropTag = PR_LOCALITY;
    LDIFAttrTable[ela_locality].ulPropIndex = elp_LOCALITY;
    LDIFAttrTable[ela_mail].ulPropTag = PR_EMAIL_ADDRESS;
    LDIFAttrTable[ela_mail].ulPropIndex = elp_EMAIL_ADDRESS;
    LDIFAttrTable[ela_member].ulPropTag = PR_NULL;                          // member of DL
    LDIFAttrTable[ela_member].ulPropIndex = NOT_FOUND;
    LDIFAttrTable[ela_mobile].ulPropTag = PR_MOBILE_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_mobile].ulPropIndex = elp_MOBILE_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_o].ulPropTag = PR_COMPANY_NAME;
    LDIFAttrTable[ela_o].ulPropIndex = elp_COMPANY_NAME;
    LDIFAttrTable[ela_objectclass].ulPropTag = PR_NULL;                     // special case object class
    LDIFAttrTable[ela_objectclass].ulPropIndex = NOT_FOUND;
    LDIFAttrTable[ela_OfficeFax].ulPropTag = PR_BUSINESS_FAX_NUMBER;
    LDIFAttrTable[ela_OfficeFax].ulPropIndex = elp_BUSINESS_FAX_NUMBER;
    LDIFAttrTable[ela_OfficePager].ulPropTag = PR_PAGER_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_OfficePager].ulPropIndex = elp_PAGER_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_organizationName].ulPropTag = PR_COMPANY_NAME;
    LDIFAttrTable[ela_organizationName].ulPropIndex = elp_COMPANY_NAME;
    LDIFAttrTable[ela_organizationalUnitName].ulPropTag = PR_DEPARTMENT_NAME;
    LDIFAttrTable[ela_organizationalUnitName].ulPropIndex = elp_DEPARTMENT_NAME;
    LDIFAttrTable[ela_otherMailbox].ulPropTag = PR_NULL;                    // BUGBUG
    LDIFAttrTable[ela_otherMailbox].ulPropIndex = NOT_FOUND;
    LDIFAttrTable[ela_ou].ulPropTag = PR_DEPARTMENT_NAME;
    LDIFAttrTable[ela_ou].ulPropIndex = elp_DEPARTMENT_NAME;
    LDIFAttrTable[ela_pager].ulPropTag = PR_PAGER_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_pager].ulPropIndex = elp_PAGER_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_physicalDeliveryOfficeName].ulPropTag = PR_OFFICE_LOCATION;
    LDIFAttrTable[ela_physicalDeliveryOfficeName].ulPropIndex = elp_OFFICE_LOCATION;
    LDIFAttrTable[ela_postOfficeBox].ulPropTag = PR_POST_OFFICE_BOX;
    LDIFAttrTable[ela_postOfficeBox].ulPropIndex = elp_POST_OFFICE_BOX;
    LDIFAttrTable[ela_postalAddress].ulPropTag = PR_STREET_ADDRESS;
    LDIFAttrTable[ela_postalAddress].ulPropIndex = elp_STREET_ADDRESS;
    LDIFAttrTable[ela_postalcode].ulPropTag = PR_POSTAL_CODE;
    LDIFAttrTable[ela_postalcode].ulPropIndex = elp_POSTAL_CODE;
    LDIFAttrTable[ela_sn].ulPropTag = PR_SURNAME;
    LDIFAttrTable[ela_sn].ulPropIndex = elp_SURNAME;
    LDIFAttrTable[ela_st].ulPropTag = PR_STATE_OR_PROVINCE;
    LDIFAttrTable[ela_st].ulPropIndex = elp_STATE_OR_PROVINCE;
    LDIFAttrTable[ela_streetAddress].ulPropTag = PR_STREET_ADDRESS;
    LDIFAttrTable[ela_streetAddress].ulPropIndex = elp_STREET_ADDRESS;
    LDIFAttrTable[ela_street].ulPropTag = PR_STREET_ADDRESS;
    LDIFAttrTable[ela_street].ulPropIndex = elp_STREET_ADDRESS;
    LDIFAttrTable[ela_surname].ulPropTag = PR_SURNAME;
    LDIFAttrTable[ela_surname].ulPropIndex = elp_SURNAME;
    LDIFAttrTable[ela_telephonenumber].ulPropTag = PR_BUSINESS_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_telephonenumber].ulPropIndex = elp_BUSINESS_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_homephonenumber].ulPropTag = PR_HOME_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_homephonenumber].ulPropIndex = elp_HOME_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_title].ulPropTag = PR_TITLE;
    LDIFAttrTable[ela_title].ulPropIndex = elp_TITLE;
    LDIFAttrTable[ela_uid].ulPropTag = PR_GIVEN_NAME;                         // ?? Matches in LDIF spec
    LDIFAttrTable[ela_uid].ulPropIndex = elp_GIVEN_NAME;
    LDIFAttrTable[ela_URL].ulPropTag = PR_BUSINESS_HOME_PAGE;
    LDIFAttrTable[ela_URL].ulPropIndex = elp_BUSINESS_HOME_PAGE;
    LDIFAttrTable[ela_userCertificate].ulPropTag = PR_NULL;                 // BUGBUG
    LDIFAttrTable[ela_userCertificate].ulPropIndex = NOT_FOUND;
    LDIFAttrTable[ela_xmozillaconference].ulPropTag =  PR_SERVERS; //PR_NULL;              // BUGBUG?
    LDIFAttrTable[ela_xmozillaconference].ulPropIndex = elp_CONFERENCE_SERVERS;
    LDIFAttrTable[ela_xmozillanickname].ulPropTag = PR_NICKNAME;
    LDIFAttrTable[ela_xmozillanickname].ulPropIndex = elp_NICKNAME;
    LDIFAttrTable[ela_xmozillauseconferenceserver].ulPropTag = PR_NULL;     // BUGBUG
    LDIFAttrTable[ela_xmozillauseconferenceserver].ulPropIndex = NOT_FOUND;
    LDIFAttrTable[ela_xmozillausehtmlmail].ulPropTag = PR_NULL;             // BUGBUG
    LDIFAttrTable[ela_xmozillausehtmlmail].ulPropIndex = NOT_FOUND;
}


/***************************************************************************

    Name      : FindAttributeName

    Purpose   : Find the attribute mapping in the LDIF attribute table

    Parameters: lpName = name of attribute to find
                LDIFAttrTable = table of LDIF attribute mappings

    Returns   : index in LDIFAttrTable (or NOT_FOUND)

    Comment   : Could perhaps benefit from a binary search algorithm.

***************************************************************************/
ULONG FindAttributeName(LPBYTE lpName, LPLDIF_ATTR_TABLE LDIFAttrTable) {
    ULONG i;
    ULONG ulIndex = NOT_FOUND;

    for (i = 0; i < ela_Max; i++) {
        if (lpName && LDIFAttrTable[i].lpName && ! lstrcmpi(lpName, LDIFAttrTable[i].lpName)) {
            ulIndex = i;
            break;
        }
    }

    return(ulIndex);
}


/***************************************************************************

    Name      : MapLDIFtoProps

    Purpose   : Map the LDIF record attributes to WAB properties

    Parameters: lpLDIFRecord -> LDIF record
                cAttributes = number of attributes in LDIF record
                lpspv -> prop value array (pre-allocated)
                lpcProps -> returned number of properties
                lppDisplayName -> returned display name
                lppEmailAddress -> returned email address (or NULL)

    Returns   : HRESULT

***************************************************************************/
HRESULT MapLDIFtoProps(LPLDIF_RECORD_ATTRIBUTE lpLDIFRecord, ULONG cAttributes,
  LPSPropValue * lppspv, LPULONG lpcProps, LPTSTR * lppDisplayName, LPTSTR *lppEmailAddress,
  ULONG * lpulObjType) {
    HRESULT hResult = hrSuccess;
    ULONG cPropVals = cPropVals = cAttributes + NUM_MUST_HAVE_PROPS;
    ULONG iProp = 0;
    ULONG i;
    LDIF_ATTR_TABLE LDIFAttrTable[ela_Max];
    ULONG iTable;
    ULONG cProps = elp_Max;
    SCODE sc;
    LONG iEmailAddr = -1;
    LONG iServers   = -1;
    LPSPropValue lpspv = NULL;
    ULONG ulIndex = 0;

    *lpulObjType = MAPI_MAILUSER;

    // Allocate prop value array
    if (hResult = ResultFromScode(WABAllocateBuffer(cProps * sizeof(SPropValue), &lpspv))) {
        DebugTrace("WABAllocateBuffer -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Fill with PR_NULL
    for (i = 0; i < cProps; i++) {
        lpspv[i].ulPropTag = PR_NULL;
    }

    InitLDIFAttrTable(LDIFAttrTable);

    // Loop through attributes, looking for interesting stuff
    for (i = 0; i < cAttributes; i++) {
        iTable = NOT_FOUND;
        if ((iTable = FindAttributeName(lpLDIFRecord[i].lpName, LDIFAttrTable)) != NOT_FOUND) {
            // Found the attribute name
            // mark the data index in the table
            LDIFAttrTable[iTable].index = i;
        }

        // Some special cases need to be examined now.
        switch (iTable) {
            case ela_cn:
            case ela_dn:
                // if we have both cn and dn, cn takes precedence
                if(LDIFAttrTable[ela_cn].index != NOT_FOUND && LDIFAttrTable[ela_dn].index != NOT_FOUND)
                    LDIFAttrTable[ela_dn].index = NOT_FOUND;
                break;

            case ela_objectclass:
                // objectclass may appear multiple times.  It is up to us to decide which
                // one is meaningful.
                // We recognize several different types:
                // objectclass: person
                // objectclass: organizationalPerson
                // objectclass: groupofnames
                // What objectclass is it?
                if(lpLDIFRecord[i].lpData)
                {
                    if (! lstrcmpi(lpLDIFRecord[i].lpData, sz_person) ||
                       ! lstrcmpi(lpLDIFRecord[i].lpData, sz_organizationalPerson)) {
                        *lpulObjType = MAPI_MAILUSER;
                    } else if (! lstrcmpi(lpLDIFRecord[i].lpData, sz_groupOfNames)) {
                        *lpulObjType = MAPI_DISTLIST;
                    } else {
                        // Ignore this objectclass
                    }
                }
                break;

            case ela_member:    // DL member name or address
                Assert(*lpulObjType == MAPI_DISTLIST);
                // BUGBUG: NYI
                break;
        }
    }

    // look through the attr table for props to use
    for (i = 0; i < ela_Max; i++) 
    {
        if (LDIFAttrTable[i].ulPropTag != PR_NULL &&
            lpspv[ulIndex].ulPropTag == PR_NULL &&
            LDIFAttrTable[i].index != NOT_FOUND) 
        {
            
            if( LDIFAttrTable[i].ulPropTag == PR_SERVERS )
            {
                ULONG cchData;
                ULONG cStrToAdd = 2;
                LPTSTR * lppszServers;
                ULONG index = (iServers >= 0 ? iServers : ulIndex); //LDIFAttrTable[i].ulPropIndex;
                LONG cCurrentStrs = (iServers >= 0 ? lpspv[index].Value.MVSZ.cValues : 0);
                LPTSTR lpEmailAddress = NULL;
                lpspv[index].ulPropTag = PR_SERVERS;

                if( cCurrentStrs >= (LONG)cStrToAdd )
                {
                    // will not handle more than 2 netmtgs addresses
                    lpspv[index].ulPropTag = PR_NULL;
                }
                else 
                {                                       
                    if( cCurrentStrs <= 0 )
                    {
                        sc = WABAllocateMore(sizeof(LPTSTR), lpspv, 
                                            (LPVOID *)&(lpspv[index].Value.MVSZ.LPPSZ));
                        
                        if (sc)
                        {
                            hResult = ResultFromScode(sc);
                            goto exit;
                        }
                        
                        cCurrentStrs = 0;
                    }
                    cchData = 2 + lstrlen(szCallto) + lstrlen( lpLDIFRecord[LDIFAttrTable[i].index].lpData );
                    if ( iEmailAddr >= 0 ){
                        lpEmailAddress = lpspv[iEmailAddr].Value.LPSZ;
                        cchData += lstrlen( lpEmailAddress) + 2;
                    }
                            
                    // allocate enough space for two Server names
                    lppszServers = lpspv[index].Value.MVSZ.LPPSZ;
                    
                    //  Allocate more space for the email address and copy it.
                    sc = WABAllocateMore( sizeof(TCHAR) * cchData, lpspv,
                                        (LPVOID *)&(lppszServers[cCurrentStrs]));
                    if( sc  )
                    {
                        hResult = ResultFromScode(sc);
                        goto exit;
                    }
                    lstrcpy(lppszServers[cCurrentStrs], szCallto);
                    lstrcat(lppszServers[cCurrentStrs], lpLDIFRecord[LDIFAttrTable[i].index].lpData);

                    // now we need to check if email address has already been set
                    if ( iEmailAddr >= 0 )
                    {
                        lstrcat(lppszServers[cCurrentStrs], szFwdSlash);
                        lstrcat(lppszServers[cCurrentStrs], lpEmailAddress);
                    }
                    else
                        iServers = index;
                    
                    lpspv[index].Value.MVSZ.cValues = ++cCurrentStrs;
                }
            }
            else
            {
                int index = LDIFAttrTable[i].index;
                LPTSTR lp = lpLDIFRecord[index].lpData;
                if(lp && lstrlen(lp))
                {
                    lpspv[ulIndex].ulPropTag = LDIFAttrTable[i].ulPropTag;
                    // BUGBUG: assumes string data            
                        //  Allocate more space for the email address and copy it.
                    sc = WABAllocateMore( lstrlen(lp)+1, lpspv, (LPVOID *)&(lpspv[ulIndex].Value.LPSZ));
                    if( sc  )
                    {
                        hResult = ResultFromScode(sc);
                        goto exit;
                    }
                    lstrcpy(lpspv[ulIndex].Value.LPSZ, lp);
                }
            }
            // Get the special display strings to return
            switch (LDIFAttrTable[i].ulPropTag) {
                case PR_DISPLAY_NAME:
                    *lppDisplayName = lpspv[ulIndex].Value.LPSZ;
                    break;
                case PR_EMAIL_ADDRESS:
                    {
                        LPTSTR * lppszServerStr, lpszOldServerStr;
                        LONG     cNumStrs;
                        ULONG cchData;
                        *lppEmailAddress = lpspv[ulIndex].Value.LPSZ;
                        // if servers has has already been set, append email address
                        if ( iServers >= 0 )
                        {
                            if( lpspv[iServers].ulPropTag != PR_SERVERS )
                                break;

                            cNumStrs = lpspv[iServers].Value.MVSZ.cValues - 1;
                    
                            if( cNumStrs >= 0 && cNumStrs < 3)
                            {
                                lppszServerStr = lpspv[iServers].Value.MVSZ.LPPSZ;
                                lpszOldServerStr = lppszServerStr[cNumStrs];
                                cchData = lstrlen(*lppszServerStr) + lstrlen(*lppEmailAddress) + 2;
                                sc = WABAllocateMore( sizeof(TCHAR) * cchData, lpspv,
                                    (LPVOID *)&(lppszServerStr[cNumStrs]));
                                
                                if( sc  )
                                {
                                    hResult = ResultFromScode(sc);
                                    goto exit;
                                }
                                lstrcpy(lppszServerStr[cNumStrs],lpszOldServerStr); 
                                lstrcat(lppszServerStr[cNumStrs], szFwdSlash);
                                lstrcat(lppszServerStr[cNumStrs], *lppEmailAddress);
                            }
                        }
                        else
                            iEmailAddr = ulIndex;
                    }
                    break;
            }
            ulIndex++;
        }
    }
/*
    // Get rid of PR_NULL props
    for (i = 0; i < cProps; i++) {
        if (lpspv[i].ulPropTag == PR_NULL) {
            // Slide the props down.
            if (i + 1 < cProps) {       // Are there any higher props to copy?
                CopyMemory(&(lpspv[i]),
                 &(lpspv[i + 1]),
                 ((cProps - i) - 1) * sizeof(*lppspv[i]));
            }
            // decrement count
            cProps--;
            i--;    // You overwrote the current propval.  Look at it again.
        }
    }
*/
    *lpcProps = ulIndex;
    *lppspv = lpspv;
exit:
    return(hResult);
}


/*********************************************************
    
    HraddLDIFMailUser - adds a mailuser to the WAB

**********************************************************/
HRESULT HrAddLDIFMailUser(HWND hWnd,
                        LPABCONT lpContainer, 
                        LPTSTR lpDisplayName, 
                        LPTSTR lpEmailAddress,
                        ULONG cProps,
                        LPSPropValue lpspv,
                        LPWAB_PROGRESS_CALLBACK lpProgressCB,
                        LPWAB_EXPORT_OPTIONS lpOptions) 
{
    HRESULT hResult = S_OK;
    LPMAPIPROP lpMailUserWAB = NULL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    REPLACE_INFO RI;

    if (lpOptions->ReplaceOption ==  WAB_REPLACE_ALWAYS) 
    {
        ulCreateFlags |= CREATE_REPLACE;
    }


retry:

    // Create a new wab mailuser
    if (HR_FAILED(hResult = lpContainer->lpVtbl->CreateEntry(   
                        lpContainer,
                        lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.cb,
                        (LPENTRYID) lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.lpb,
                        ulCreateFlags,
                        &lpMailUserWAB))) 
    {
        DebugTrace("CreateEntry(WAB MailUser) -> %x\n", GetScode(hResult));
        goto exit;
    }

    {
        ULONG i,k;
        for(i=0;i<cProps;i++)
        {
            if(PROP_TYPE(lpspv[i].ulPropTag)==PT_MV_TSTRING)
            {
                DebugTrace("\t0x%.8x = %d\n",lpspv[i].ulPropTag, lpspv[i].Value.MVSZ.cValues);
                for(k=0;k<lpspv[i].Value.MVSZ.cValues;k++)
                    DebugTrace("\t%s\n",lpspv[i].Value.MVSZ.LPPSZ[k]);
            }
            else
                DebugTrace("0x%.8x = %s\n",lpspv[i].ulPropTag,lpspv[i].Value.LPSZ);
        }
    }
    // Set the properties on the new WAB entry
    if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SetProps(    lpMailUserWAB,
                                                                cProps,                   // cValues
                                                                lpspv,                    // property array
                                                                NULL)))                   // problems array
    {
        DebugTrace("LDIFImport:SetProps(WAB) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Save the new wab mailuser or distlist
    if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
                                                              KEEP_OPEN_READONLY | FORCE_SAVE))) 
    {
        if (GetScode(hResult) == MAPI_E_COLLISION) 
        {
            // Find the display name
            Assert(lpDisplayName);

            if (! lpDisplayName) 
            {
                DebugTrace("Collision, but can't find PR_DISPLAY_NAME in entry\n");
                goto exit;
            }

            // Do we need to prompt?
            if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) 
            {
                // Prompt user with dialog.  If they say YES, we should try again


                RI.lpszDisplayName = lpDisplayName;
                RI.lpszEmailAddress = lpEmailAddress;
                RI.ConfirmResult = CONFIRM_ERROR;
                RI.lpImportOptions = lpOptions;

                DialogBoxParam(hInst,
                  MAKEINTRESOURCE(IDD_ImportReplace),
                  hWnd,
                  ReplaceDialogProc,
                  (LPARAM)&RI);

                switch (RI.ConfirmResult) 
                {
                    case CONFIRM_YES:
                    case CONFIRM_YES_TO_ALL:
                        // YES
                        // NOTE: recursive Migrate will fill in the SeenList entry
                        // go try again!
                        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                        lpMailUserWAB = NULL;

                        ulCreateFlags |= CREATE_REPLACE;
                        goto retry;
                        break;

                    case CONFIRM_ABORT:
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                        goto exit;

                    default:
                        // NO
                        break;
                }
            }
            hResult = hrSuccess;

        } else 
        {
            DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
        }
    }

exit:
    if(lpMailUserWAB)
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);

    return hResult;
}






/*****************************************************************
    
    HrCreateAdrListFromLDIFRecord
    
    Scans an LDIF record and turns all the "members" into an 
    unresolved AdrList

******************************************************************/
HRESULT HrCreateAdrListFromLDIFRecord(ULONG cAttributes,
                                      LPLDIF_RECORD_ATTRIBUTE lpLDIFRecord, 
                                      LPADRLIST * lppAdrList)
{
    HRESULT hr = S_OK;
    ULONG nMembers = 0, i;
    LPADRLIST lpAdrList = NULL;

    *lppAdrList = NULL;

    // Count the members in this group
    for(i=0;i<cAttributes;i++)
    {
        if(lpLDIFRecord[i].cbData && lpLDIFRecord[i].lpName && !lstrcmpi(lpLDIFRecord[i].lpName, sz_member))
        {
            nMembers++;
        }
    }

    if(!nMembers)
        goto exit;

    // Now create a adrlist from these members

    // Allocate prop value array
    if (hr = ResultFromScode(WABAllocateBuffer(sizeof(ADRLIST) + nMembers * sizeof(ADRENTRY), &lpAdrList))) 
        goto exit;

    lpAdrList->cEntries = nMembers;

    nMembers = 0;
    for(i=0;i<cAttributes;i++)
    {
        if(lpLDIFRecord[i].cbData && lpLDIFRecord[i].lpData 
            && !lstrcmpi(lpLDIFRecord[i].lpName, sz_member))
        {
            // This is a member .. break out its lpData into
            // Name and Email
            LPTSTR lpName = NULL;
            LPTSTR lpEmail = NULL;
            
            lpName = LocalAlloc(LMEM_ZEROINIT, lpLDIFRecord[i].cbData + 1);
            lpEmail = LocalAlloc(LMEM_ZEROINIT, lpLDIFRecord[i].cbData + 1);
            if(lpName && lpEmail)
            {
                LPTSTR lp = NULL;
                lstrcpy(lpName, lpLDIFRecord[i].lpData);
                lstrcpy(lpEmail, lpName);

                lp = lpName;

                // BUGBUG - we are looking for two pieces of data Name and Email
                // this code is assuming it will get 'cn=' first and then 'mail='
                // second .. this is all a poor hack assuming too many things

                if(*lp == 'c' && *(lp+1) == 'n' && *(lp+2) == '=')
                    lp += 3;
                lstrcpy(lpName, lp);
                
                while (lp && *lp && *lp!=',')
                    lp++;

                if(!*lp) // there is a comma, sometimes there isnt
                {
                    LocalFree(lpEmail);
                    lpEmail = NULL;
                }
                else
                {
                    *lp = '\0';
                    lp++;
                    lstrcpy(lpEmail, lp);

                    lp = lpEmail;
                    if(*lp == 'm' && *(lp+1) == 'a' && *(lp+2) == 'i' && *(lp+3) == 'l' && *(lp+4) == '=')
                        lp += 5;
                    lstrcpy(lpEmail, lp);
                    while (lp && *lp && *lp!=',')
                        lp++;
                    if(*lp)
                    {
                        // terminate on this 
                        *lp = '\0';
                    }
                }                
                
                if(lpName)// && lpEmail)
                {
                    LPSPropValue lpProp = NULL;
                    ULONG ulcProps = 2;
        
                    if (hr = ResultFromScode(WABAllocateBuffer(2 * sizeof(SPropValue), &lpProp))) 
                        goto exit;

                    lpProp[0].ulPropTag = PR_DISPLAY_NAME;

                    if (hr = ResultFromScode(WABAllocateMore(lstrlen(lpName)+1, lpProp, &(lpProp[0].Value.lpszA)))) 
                        goto exit;

                    lstrcpy(lpProp[0].Value.lpszA, lpName);

                    if(lpEmail)
                    {
                        lpProp[1].ulPropTag = PR_EMAIL_ADDRESS;

                        if (hr = ResultFromScode(WABAllocateMore(lstrlen(lpEmail)+1, lpProp, &(lpProp[1].Value.lpszA)))) 
                            goto exit;

                        lstrcpy(lpProp[1].Value.lpszA, lpEmail);
                    }
                    lpAdrList->aEntries[nMembers].cValues = (lpEmail ? 2 : 1);
                    lpAdrList->aEntries[nMembers].rgPropVals = lpProp;
                    nMembers++;

                }

                if(lpName)
                    LocalFree(lpName);
                if(lpEmail)
                    LocalFree(lpEmail);
                    
            }


        }
    }

    *lppAdrList = lpAdrList;

exit:

    if(HR_FAILED(hr) && lpAdrList)
        WABFreePadrlist(lpAdrList);

    return hr;
}


/*****************************************************************
    
    HraddLDIFDistList - adds a distlist and its members to the WAB

    Sequence of events will be:

    - Create a DistList object
    - Set the properties on the DistList object
    - Scan the list of members for the given dist list object
    - Add each member to the wab .. if member already exists,
        prompt to replace etc ...if it doesnt exist, create new
        

******************************************************************/
HRESULT HrAddLDIFDistList(HWND hWnd,
                        LPABCONT lpContainer, 
                        ULONG cAttributes,
                        LPLDIF_RECORD_ATTRIBUTE lpLDIFRecord,
                        LPTSTR lpDisplayName, 
                        LPTSTR lpEmailAddress,
                        ULONG cProps,
                        LPSPropValue lpspv,
                        LPWAB_PROGRESS_CALLBACK lpProgressCB,
                        LPWAB_EXPORT_OPTIONS lpOptions) 
{
    HRESULT hResult = S_OK;
    LPMAPIPROP lpDistListWAB = NULL;
    LPDISTLIST lpDLWAB = NULL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    REPLACE_INFO RI;
    LPADRLIST lpAdrList = NULL;
    LPFlagList lpfl = NULL;
    ULONG ulcValues = 0;
    LPSPropValue lpPropEID = NULL;
    ULONG i, cbEIDNew;
    LPENTRYID lpEIDNew;
    ULONG ulObjectTypeOpen;


    if (lpOptions->ReplaceOption ==  WAB_REPLACE_ALWAYS) 
    {
        ulCreateFlags |= CREATE_REPLACE;
    }


retry:
    // Create a new wab distlist
    if (HR_FAILED(hResult = lpContainer->lpVtbl->CreateEntry(   
                    lpContainer,
                    lpCreateEIDsWAB[iconPR_DEF_CREATE_DL].Value.bin.cb,
                    (LPENTRYID) lpCreateEIDsWAB[iconPR_DEF_CREATE_DL].Value.bin.lpb,
                    ulCreateFlags,
                    (LPMAPIPROP *) &lpDistListWAB))) 
    {
        DebugTrace("CreateEntry(WAB MailUser) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Set the properties on the new WAB entry
    if (HR_FAILED(hResult = lpDistListWAB->lpVtbl->SetProps(    lpDistListWAB,
                                                                cProps,                   // cValues
                                                                lpspv,                    // property array
                                                                NULL)))                   // problems array
    {
        DebugTrace("LDIFImport:SetProps(WAB) -> %x\n", GetScode(hResult));
        goto exit;
    }


    // Save the new wab mailuser or distlist
    if (HR_FAILED(hResult = lpDistListWAB->lpVtbl->SaveChanges(lpDistListWAB,
                                                              KEEP_OPEN_READWRITE | FORCE_SAVE))) 
    {
        if (GetScode(hResult) == MAPI_E_COLLISION) 
        {
            // Find the display name
            Assert(lpDisplayName);

            if (! lpDisplayName) 
            {
                DebugTrace("Collision, but can't find PR_DISPLAY_NAME in entry\n");
                goto exit;
            }

            // Do we need to prompt?
            if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) 
            {
                // Prompt user with dialog.  If they say YES, we should try again


                RI.lpszDisplayName = lpDisplayName;
                RI.lpszEmailAddress = NULL; //lpEmailAddress;
                RI.ConfirmResult = CONFIRM_ERROR;
                RI.lpImportOptions = lpOptions;

                DialogBoxParam(hInst,
                  MAKEINTRESOURCE(IDD_ImportReplace),
                  hWnd,
                  ReplaceDialogProc,
                  (LPARAM)&RI);

                switch (RI.ConfirmResult) 
                {
                    case CONFIRM_YES:
                    case CONFIRM_YES_TO_ALL:
                        // YES
                        // NOTE: recursive Migrate will fill in the SeenList entry
                        // go try again!
                        lpDistListWAB->lpVtbl->Release(lpDistListWAB);
                        lpDistListWAB = NULL;

                        ulCreateFlags |= CREATE_REPLACE;
                        goto retry;
                        break;

                    case CONFIRM_ABORT:
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                        goto exit;

                    default:
                        // NO
                        break;
                }
            }
            hResult = hrSuccess;

        } else 
        {
            DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
        }
    }


    // Now we've created the Distribution List object .. we need to add members to it ..
    //
    // What is the ENTRYID of our new entry?
    if ((hResult = lpDistListWAB->lpVtbl->GetProps(lpDistListWAB,
                                                  (LPSPropTagArray)&ptaEid,
                                                  0,
                                                  &ulcValues,
                                                  &lpPropEID))) 
    {
        goto exit;
    }

    cbEIDNew = lpPropEID->Value.bin.cb;
    lpEIDNew = (LPENTRYID) lpPropEID->Value.bin.lpb;

    if(!cbEIDNew || !lpEIDNew)
        goto exit;

     // Open the new WAB DL as a DISTLIST object
    if (HR_FAILED(hResult = lpContainer->lpVtbl->OpenEntry(lpContainer,
                                                          cbEIDNew,
                                                          lpEIDNew,
                                                          (LPIID)&IID_IDistList,
                                                          MAPI_MODIFY,
                                                          &ulObjectTypeOpen,
                                                          (LPUNKNOWN*)&lpDLWAB))) 
    {
        goto exit;
    }



    // First we create a lpAdrList with all the members of this dist list and try to resolve
    // the members against the container .. entries that already exist in the WAB will come
    // back as resolved .. entries that dont exist in the container will come back as unresolved
    // We can then add the unresolved entries as fresh entries to the wab (since they are 
    // unresolved, there will be no collision) .. and then we can do another resolvenames to
    // resolve everything and get a lpAdrList full of EntryIDs .. we can then take this list of
    // entryids and call CreateEntry or CopyEntry on the DistList object to copy the entryid into
    // the distlist ...

    hResult = HrCreateAdrListFromLDIFRecord(cAttributes, lpLDIFRecord, &lpAdrList);

    if(HR_FAILED(hResult))
        goto exit;

    if(!lpAdrList || !(lpAdrList->cEntries))
        goto exit;

    // Create a corresponding flaglist
    lpfl = LocalAlloc(LMEM_ZEROINIT, sizeof(FlagList) + (lpAdrList->cEntries)*sizeof(ULONG));
    if(!lpfl)
    {
        hResult = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpfl->cFlags = lpAdrList->cEntries;

    // set all the flags to unresolved
    for(i=0;i<lpAdrList->cEntries;i++)
        lpfl->ulFlag[i] = MAPI_UNRESOLVED;

    hResult = lpContainer->lpVtbl->ResolveNames(lpContainer, NULL, 0, lpAdrList, lpfl);

    if(HR_FAILED(hResult))
        goto exit;

    // All the entries in the list that are resolved, already exist in the address book.

    // The ones that are not resolved need to be added silently to the address book ..
    for(i=0;i<lpAdrList->cEntries;i++)
    {
        if(lpfl->ulFlag[i] == MAPI_UNRESOLVED)
        {
            LPMAPIPROP lpMailUser = NULL;

            if (HR_FAILED(hResult = lpContainer->lpVtbl->CreateEntry(   
                                lpContainer,
                                lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.cb,
                                (LPENTRYID) lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.lpb,
                                0,
                                &lpMailUser))) 
            {
                continue;
                //goto exit;
            }

            if(lpMailUser)
            {
                // Set the properties on the new WAB entry
                if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
                                                                    lpAdrList->aEntries[i].cValues,
                                                                    lpAdrList->aEntries[i].rgPropVals,
                                                                    NULL)))                   
                {
                    goto exit;
                }

                // Save the new wab mailuser or distlist
                if (HR_FAILED(hResult = lpMailUser->lpVtbl->SaveChanges(lpMailUser,
                                                                        KEEP_OPEN_READONLY | FORCE_SAVE))) 
                {
                    goto exit;
                }

                lpMailUser->lpVtbl->Release(lpMailUser);
            }
        }
    }


    // now that we've added all the unresolved members to the WAB, we call ResolveNames
    // again .. as a result, every member in this list will be resolved and we will
    // have entryids for all of them 
    // We will then take these entryids and add them to the DistList object

    hResult = lpContainer->lpVtbl->ResolveNames(lpContainer, NULL, 0, lpAdrList, lpfl);

    if(HR_FAILED(hResult))
        goto exit;

    for(i=0;i<lpAdrList->cEntries;i++)
    {
        if(lpfl->ulFlag[i] == MAPI_RESOLVED)
        {
            ULONG j = 0;
            LPSPropValue lpProp = lpAdrList->aEntries[i].rgPropVals;
            
            for(j=0; j<lpAdrList->aEntries[i].cValues; j++)
            {
                if(lpProp[j].ulPropTag == PR_ENTRYID)
                {
                    LPMAPIPROP lpMapiProp = NULL;

                    //ignore errors
                    lpDLWAB->lpVtbl->CreateEntry(lpDLWAB,
                                                lpProp[j].Value.bin.cb,
                                                (LPENTRYID) lpProp[j].Value.bin.lpb,
                                                0, 
                                                &lpMapiProp);

                    if(lpMapiProp)
                    {
                        lpMapiProp->lpVtbl->SaveChanges(lpMapiProp, KEEP_OPEN_READWRITE | FORCE_SAVE);
                        lpMapiProp->lpVtbl->Release(lpMapiProp);
                    }

                    break;

                }
            }
        }
    }

exit:

    if (lpPropEID)
        WABFreeBuffer(lpPropEID);

    if (lpDLWAB)
        lpDLWAB->lpVtbl->Release(lpDLWAB);

    if(lpDistListWAB)
        lpDistListWAB->lpVtbl->Release(lpDistListWAB);

    if(lpAdrList)
        WABFreePadrlist(lpAdrList);

    if(lpfl)
        LocalFree(lpfl);

    return hResult;
}

HRESULT LDIFImport(HWND hWnd,
    LPADRBOOK lpAdrBook,
    LPWABOBJECT lpWABObject,
    LPWAB_PROGRESS_CALLBACK lpProgressCB,
    LPWAB_EXPORT_OPTIONS lpOptions) {
    HRESULT hResult = hrSuccess;
    TCHAR szFileName[MAX_PATH + 1] = "";
    register ULONG i;
    ULONG ulObjType;
    ULONG index;
    ULONG ulLastChosenProp = 0;
    ULONG ulcFields = 0;
    ULONG cAttributes = 0;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    WAB_PROGRESS Progress;
    LPABCONT lpContainer = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPLDIF_RECORD_ATTRIBUTE lpLDIFRecord = NULL;
    LPSPropValue lpspv = NULL;
    ULONG cProps;
    BOOL fSkipSetProps;
    LPTSTR lpDisplayName = NULL, lpEmailAddress = NULL;
    BOOL fDoDistLists = FALSE;

    SetGlobalBufferFunctions(lpWABObject);

    // Get LDIF file name
    OpenFileDialog(hWnd,
      szFileName,
      szLDIFFilter,
      IDS_LDIF_FILE_SPEC,
      szAllFilter,
      IDS_ALL_FILE_SPEC,
      NULL,
      0,
      szLDIFExt,
      OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST,
      hInst,
      0,        //idsTitle
      0);       // idsSaveButton

    // Open the file
    if ((hFile = CreateFile(szFileName,
      GENERIC_READ,
      FILE_SHARE_READ | FILE_SHARE_WRITE,
      NULL,
      OPEN_EXISTING,
      FILE_FLAG_SEQUENTIAL_SCAN,
      NULL)) == INVALID_HANDLE_VALUE) {
        DebugTrace("Couldn't open file %s -> %u\n", szFileName, GetLastError());
        return(ResultFromScode(MAPI_E_NOT_FOUND));
    }

    Assert(hFile != INVALID_HANDLE_VALUE);

    // Read in the LDIF version if there is one
    // BUGBUG: NYI



    //
    // Open the WAB's PAB container: fills global lpCreateEIDsWAB
    //
    if (hResult = LoadWABEIDs(lpAdrBook, &lpContainer)) {
        goto exit;
    }

    if( HR_FAILED(hResult = HrLoadPrivateWABProps(lpAdrBook) ))
    {
        goto exit;
    }

    //
    // All set... now loop through the records, adding each to the WAB
    //

    // How many records are there?
    if (hResult = CountLDIFRecords(hFile, &ulcEntries)) {
        goto exit;
    }

    // Initialize the Progress Bar
    Progress.denominator = max(ulcEntries, 1);
    Progress.numerator = 0;
    if (LoadString(hInst, IDS_STATE_IMPORT_MU, szBuffer, sizeof(szBuffer))) {
        DebugTrace("Status Message: %s\n", szBuffer);
        Progress.lpText = szBuffer;
    } else {
        DebugTrace("Cannot load resource string %u\n", IDS_STATE_IMPORT_MU);
        Progress.lpText = NULL;
    }
    lpProgressCB(hWnd, &Progress);

    
    // We will make 2 passes over the file - in the first pass we will import all the
    // contacts. In the second pass we will import all the distribution lists .. the
    // advantage of doing 2 passes is that when importing contacts, we will prompt on
    // conflict and then when importing distlists, we will assume all contacts in the 
    // WAB are correct and just point to the relevant ones

    fDoDistLists = FALSE;

DoDistLists:

    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

    while (HR_SUCCEEDED(hResult)) 
    {
        lpDisplayName = NULL;
        lpEmailAddress = NULL;
        lpspv = NULL;
        cAttributes = cProps = 0;
        lpLDIFRecord = NULL;

        // Read the LDIF attributes
        if (hResult = ReadLDIFRecord(hFile, &cAttributes, &lpLDIFRecord)) {
            DebugTrace("ReadLDIFRecord -> %x\n", GetScode(hResult));
            if (GetScode(hResult) == MAPI_E_NOT_FOUND) {
                // EOF
                hResult = hrSuccess;
            }
            break;      // nothing more to read
        }

        // Map the LDIF attributes to WAB properties
        if (hResult = MapLDIFtoProps(lpLDIFRecord, cAttributes, &lpspv, &cProps,
          &lpDisplayName, &lpEmailAddress, &ulObjType)) {
            goto exit;
        }

        DebugTrace("..Importing..%s..%s..\n",lpDisplayName?lpDisplayName:"",lpEmailAddress?lpEmailAddress:"");

        if(ulObjType == MAPI_MAILUSER && !fDoDistLists)
        {
            hResult = HrAddLDIFMailUser(hWnd, lpContainer, 
                        lpDisplayName, lpEmailAddress,
                        cProps, lpspv,
                        lpProgressCB, lpOptions);
            // Update progress bar
            Progress.numerator++;
        }
        else if(ulObjType == MAPI_DISTLIST && fDoDistLists)
        {
            hResult = HrAddLDIFDistList(hWnd, lpContainer, 
                        cAttributes, lpLDIFRecord,
                        lpDisplayName, lpEmailAddress,
                        cProps, lpspv,
                        lpProgressCB, lpOptions);
            // Update progress bar
            Progress.numerator++;
        }

        if(HR_FAILED(hResult))
            goto exit;

        // Clean up
        if (lpLDIFRecord) 
        {
            FreeLDIFRecord(lpLDIFRecord, cAttributes);
            lpLDIFRecord = NULL;
        }

        Assert(Progress.numerator <= Progress.denominator);

        if (lpspv) 
        {
            WABFreeBuffer(lpspv);
            lpspv = NULL;
        }

        lpProgressCB(hWnd, &Progress);
    }

    if(!fDoDistLists)
    {
        // Make a second pass doing only distlists this time
        fDoDistLists = TRUE;
        goto DoDistLists;
    }

    if (! HR_FAILED(hResult)) {
        hResult = hrSuccess;
    }

exit:
    if (hFile) {
        CloseHandle(hFile);
    }

    if (lpspv) {
        WABFreeBuffer(lpspv);
        lpspv = NULL;
    }

    if (lpLDIFRecord) {
        FreeLDIFRecord(lpLDIFRecord, cAttributes);
        lpLDIFRecord = NULL;
    }

    if (lpContainer) {
        lpContainer->lpVtbl->Release(lpContainer);
        lpContainer = NULL;
    }

    if (lpCreateEIDsWAB) {
        WABFreeBuffer(lpCreateEIDsWAB);
        lpCreateEIDsWAB = NULL;
    }


    return(hResult);
}



const int base642six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

//-------------------------------------------------------------------------------------------
// Function:  decode()
//-------------------------------------------------------------------------------------------
BOOL decodeBase64(  char   * bufcoded,       // in
                    char   * pbuffdecoded,   // out
                    DWORD  * pcbDecoded)     // in out
{
    int            nbytesdecoded;
    char          *bufin;
    unsigned char *bufout;
    int            nprbytes;
    const int     *rgiDict = base642six;

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(rgiDict[*(bufin++)] <= 63);
    nprbytes = (int) (bufin - bufcoded - 1);
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    bufout = (unsigned char *)pbuffdecoded;

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (rgiDict[*bufin] << 2 | rgiDict[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (rgiDict[bufin[1]] << 4 | rgiDict[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (rgiDict[bufin[2]] << 6 | rgiDict[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(rgiDict[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((CHAR *)pbuffdecoded)[nbytesdecoded] = '\0';

    return TRUE;
}



/*
 - HrLoadPrivateWABProps
 -
*    Private function to load Conferencing Named properties
*    as globals up front
*
*
*/
HRESULT HrLoadPrivateWABProps(LPADRBOOK lpIAB)
{
    HRESULT hr = E_FAIL;
    LPSPropTagArray lpta = NULL;
    SCODE sc = 0;
    ULONG i, uMax = prWABConfMax, nStartIndex = OLK_NAMEDPROPS_START;
    LPMAPINAMEID  *lppConfPropNames = NULL;

    sc = WABAllocateBuffer(sizeof(LPMAPINAMEID) * uMax, (LPVOID *) &lppConfPropNames);
    //sc = WABAllocateBuffer(sizeof(LPMAPINAMEID) * uMax, (LPVOID *) &lppConfPropNames);
    if( (HR_FAILED(hr = ResultFromScode(sc))) )
        goto err;    

    for(i=0;i< uMax;i++)
    {
        //sc = WABAllocateMore(sizeof(MAPINAMEID), lppConfPropNames, &(lppConfPropNames[i]));
        sc = WABAllocateMore(  sizeof(MAPINAMEID), lppConfPropNames, &(lppConfPropNames[i]));
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto err;
        }
        lppConfPropNames[i]->lpguid = (LPGUID) &PS_Conferencing;
        lppConfPropNames[i]->ulKind = MNID_ID;
        lppConfPropNames[i]->Kind.lID = nStartIndex + i;
    }
    // Load the set of conferencing named props
    //
    if( HR_FAILED(hr = (lpIAB)->lpVtbl->GetIDsFromNames(lpIAB, uMax, lppConfPropNames,
        MAPI_CREATE, &lpta) ))
        goto err;
    
    if(lpta)
        // Set the property types on the returned props
        PR_SERVERS                  = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABConfServers],        PT_MV_TSTRING);
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].ulPropTag = PR_SERVERS;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].fChosen   = FALSE;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].ids       = ids_ExportConfServer;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].lpszName  = NULL;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].lpszCSVName = NULL;

err:
    if(lpta)
        WABFreeBuffer( lpta );
    if( lppConfPropNames )
        WABFreeBuffer( lppConfPropNames );
        //WABFreeBuffer(lpta);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\dbgutil.c ===
/***********************************************************************
 *
 * DBGUTIL.C
 *
 * Debug utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/
#ifdef DEBUG
#include <windows.h>
//#include <mapix.h>
#include <wab.h>
#include <wabdbg.h>

#include "dbgutil.h"

#define _WAB_DBGUTIL_C

PUCHAR PropTagName(ULONG ulPropTag);
const TCHAR szNULL[] = "";

extern SCODE WABFreeBuffer(LPVOID lpBuffer);
VOID FAR CDECL _DebugTrace(LPSTR lpszFmt, ...);



/***************************************************************************

    Name      : FreeBufferAndNull

    Purpose   : Frees a MAPI buffer and NULLs the pointer

    Parameters: lppv = pointer to buffer pointer to free

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall FreeBufferAndNull(BOOL fMAPI, LPVOID * lppv) {
    if (lppv) {
        if (*lppv) {
            SCODE sc;
            if (fMAPI) {
#ifdef OLD_STUFF
                if (sc = MAPIFreeBuffer(*lppv)) {
                    DebugTrace("MAPIFreeBuffer(%x) -> 0x%08x\n", *lppv, sc);
                }
#endif // OLD_STUFF
            } else {
                if (sc = WABFreeBuffer(*lppv)) {
                    DebugTrace("WABFreeBuffer(%x) -> 0x%08x\n", *lppv, sc);
                }
            }
            *lppv = NULL;
        }
    }
}


/***************************************************************************

    Name      : ReleaseAndNull

    Purpose   : Releases an object and NULLs the pointer

    Parameters: lppv = pointer to pointer to object to release

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall ReleaseAndNull(LPVOID * lppv) {
    LPUNKNOWN * lppunk = (LPUNKNOWN *)lppv;

    if (lppunk) {
        if (*lppunk) {
            HRESULT hResult;

            if (hResult = (*lppunk)->lpVtbl->Release(*lppunk)) {
                DebugTrace("Release(%x) -> 0x%08x\n", *lppunk, GetScode(hResult));
            }
            *lppunk = NULL;
        }
    }
}


/***************************************************************************

    Name      : PropTypeString

    Purpose   : Map a proptype to a string

    Parameters: ulPropType = property type to map

    Returns   : string pointer to name of prop type

    Comment   :

***************************************************************************/
LPTSTR PropTypeString(ULONG ulPropType) {
    switch (ulPropType) {
        case PT_UNSPECIFIED:
            return("PT_UNSPECIFIED");
        case PT_NULL:
            return("PT_NULL       ");
        case PT_I2:
            return("PT_I2         ");
        case PT_LONG:
            return("PT_LONG       ");
        case PT_R4:
            return("PT_R4         ");
        case PT_DOUBLE:
            return("PT_DOUBLE     ");
        case PT_CURRENCY:
            return("PT_CURRENCY   ");
        case PT_APPTIME:
            return("PT_APPTIME    ");
        case PT_ERROR:
            return("PT_ERROR      ");
        case PT_BOOLEAN:
            return("PT_BOOLEAN    ");
        case PT_OBJECT:
            return("PT_OBJECT     ");
        case PT_I8:
            return("PT_I8         ");
        case PT_STRING8:
            return("PT_STRING8    ");
        case PT_UNICODE:
            return("PT_UNICODE    ");
        case PT_SYSTIME:
            return("PT_SYSTIME    ");
        case PT_CLSID:
            return("PT_CLSID      ");
        case PT_BINARY:
            return("PT_BINARY     ");
        case PT_MV_I2:
            return("PT_MV_I2      ");
        case PT_MV_LONG:
            return("PT_MV_LONG    ");
        case PT_MV_R4:
            return("PT_MV_R4      ");
        case PT_MV_DOUBLE:
            return("PT_MV_DOUBLE  ");
        case PT_MV_CURRENCY:
            return("PT_MV_CURRENCY");
        case PT_MV_APPTIME:
            return("PT_MV_APPTIME ");
        case PT_MV_SYSTIME:
            return("PT_MV_SYSTIME ");
        case PT_MV_STRING8:
            return("PT_MV_STRING8 ");
        case PT_MV_BINARY:
            return("PT_MV_BINARY  ");
        case PT_MV_UNICODE:
            return("PT_MV_UNICODE ");
        case PT_MV_CLSID:
            return("PT_MV_CLSID   ");
        case PT_MV_I8:
            return("PT_MV_I8      ");
        default:
            return("   <unknown>  ");
    }
}


/***************************************************************************

    Name      : TraceMVPStrings

    Purpose   : Debug trace a multivalued string property value

    Parameters: lpszCaption = caption string
                PropValue = property value to dump

    Returns   : none

    Comment   :

***************************************************************************/
void _TraceMVPStrings(LPTSTR lpszCaption, SPropValue PropValue) {
    ULONG i;

    DebugTrace("-----------------------------------------------------\n");
    DebugTrace("%s", lpszCaption);
    switch (PROP_TYPE(PropValue.ulPropTag)) {

        case PT_ERROR:
            DebugTrace("Error value 0x%08x\n", PropValue.Value.err);
            break;

        case PT_MV_TSTRING:
            DebugTrace("%u values\n", PropValue.Value.MVSZ.cValues);

            if (PropValue.Value.MVSZ.cValues) {
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
                for (i = 0; i < PropValue.Value.MVSZ.cValues; i++) {
                    DebugTrace("%u: \"%s\"\n", i, PropValue.Value.MVSZ.LPPSZ[i]);
                }
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
            }
            break;

        default:
            DebugTrace("TraceMVPStrings got incorrect property type %u for tag %x\n",
              PROP_TYPE(PropValue.ulPropTag), PropValue.ulPropTag);
            break;
    }
}


/***************************************************************************

    Name      : DebugBinary

    Purpose   : Debug dump an array of bytes

    Parameters: cb = number of bytes to dump
                lpb -> bytes to dump

    Returns   : none

    Comment   :

***************************************************************************/
#define DEBUG_NUM_BINARY_LINES  2
VOID DebugBinary(UINT cb, LPBYTE lpb) {
    UINT cbLines = 0;

#if (DEBUG_NUM_BINARY_LINES != 0)
    UINT cbi;

    while (cb && cbLines < DEBUG_NUM_BINARY_LINES) {
        cbi = min(cb, 16);
        cb -= cbi;

        switch (cbi) {
            case 16:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14],
                  lpb[15]);
                break;
            case 1:
                DebugTrace("%02x\n", lpb[0]);
                break;
            case 2:
                DebugTrace("%02x %02x\n", lpb[0], lpb[1]);
                break;
            case 3:
                DebugTrace("%02x %02x %02x\n", lpb[0], lpb[1], lpb[2]);
                break;
            case 4:
                DebugTrace("%02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3]);
                break;
            case 5:
                DebugTrace("%02x %02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3],
                  lpb[4]);
                break;
            case 6:
                DebugTrace("%02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5]);
                break;
            case 7:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6]);
                break;
            case 8:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7]);
                break;
            case 9:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8]);
                break;
            case 10:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9]);
                break;
            case 11:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10]);
                break;
            case 12:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11]);
                break;
            case 13:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12]);
                break;
            case 14:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13]);
                break;
            case 15:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14]);
                break;
        }
        lpb += cbi;
        cbLines++;
    }
    if (cb) {
        DebugTrace("<etc.>");    //
    }
#endif
}


#define RETURN_PROP_CASE(pt) case PROP_ID(pt): return(#pt)

/***************************************************************************

    Name      : PropTagName

    Purpose   : Associate a name with a property tag

    Parameters: ulPropTag = property tag

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
PUCHAR PropTagName(ULONG ulPropTag) {
    static UCHAR szPropTag[35]; // see string on default

    switch (PROP_ID(ulPropTag)) {

        RETURN_PROP_CASE(PR_INITIALS);
        RETURN_PROP_CASE(PR_SURNAME);
        RETURN_PROP_CASE(PR_TITLE);
        RETURN_PROP_CASE(PR_TELEX_NUMBER);
        RETURN_PROP_CASE(PR_GIVEN_NAME);
        RETURN_PROP_CASE(PR_PRIMARY_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PRIMARY_FAX_NUMBER);
        RETURN_PROP_CASE(PR_POSTAL_CODE);
        RETURN_PROP_CASE(PR_POSTAL_ADDRESS);
        RETURN_PROP_CASE(PR_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_PAGER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_OTHER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ORGANIZATIONAL_ID_NUMBER);
        RETURN_PROP_CASE(PR_OFFICE_LOCATION);
        RETURN_PROP_CASE(PR_LOCATION);
        RETURN_PROP_CASE(PR_LOCALITY);
        RETURN_PROP_CASE(PR_ISDN_NUMBER);
        RETURN_PROP_CASE(PR_GOVERNMENT_ID_NUMBER);
        RETURN_PROP_CASE(PR_GENERATION);
        RETURN_PROP_CASE(PR_DEPARTMENT_NAME);
        RETURN_PROP_CASE(PR_COUNTRY);
        RETURN_PROP_CASE(PR_COMPANY_NAME);
        RETURN_PROP_CASE(PR_COMMENT);
        RETURN_PROP_CASE(PR_CELLULAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CALLBACK_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS2_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_FAX_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT);
        RETURN_PROP_CASE(PR_ACCOUNT);
        RETURN_PROP_CASE(PR_TEMPLATEID);
        RETURN_PROP_CASE(PR_DETAILS_TABLE);
        RETURN_PROP_CASE(PR_SEARCH_KEY);
        RETURN_PROP_CASE(PR_LAST_MODIFICATION_TIME);
        RETURN_PROP_CASE(PR_CREATION_TIME);
        RETURN_PROP_CASE(PR_ENTRYID);
        RETURN_PROP_CASE(PR_RECORD_KEY);
        RETURN_PROP_CASE(PR_MAPPING_SIGNATURE);
        RETURN_PROP_CASE(PR_OBJECT_TYPE);
        RETURN_PROP_CASE(PR_ROWID);
        RETURN_PROP_CASE(PR_ADDRTYPE);
        RETURN_PROP_CASE(PR_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_EMAIL_ADDRESS);
        RETURN_PROP_CASE(PR_DEPTH);
        RETURN_PROP_CASE(PR_ROW_TYPE);
        RETURN_PROP_CASE(PR_RADIO_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_HOME_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_INSTANCE_KEY);
        RETURN_PROP_CASE(PR_DISPLAY_TYPE);
        RETURN_PROP_CASE(PR_RECIPIENT_TYPE);
        RETURN_PROP_CASE(PR_CONTAINER_FLAGS);
        RETURN_PROP_CASE(PR_DEF_CREATE_DL);
        RETURN_PROP_CASE(PR_DEF_CREATE_MAILUSER);
        RETURN_PROP_CASE(PR_CONTACT_ADDRTYPES);
        RETURN_PROP_CASE(PR_CONTACT_DEFAULT_ADDRESS_INDEX);
        RETURN_PROP_CASE(PR_CONTACT_EMAIL_ADDRESSES);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_CITY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_COUNTRY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POSTAL_CODE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STREET);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_MIDDLE_NAME);
        RETURN_PROP_CASE(PR_NICKNAME);
        RETURN_PROP_CASE(PR_PERSONAL_HOME_PAGE);
        RETURN_PROP_CASE(PR_BUSINESS_HOME_PAGE);
        RETURN_PROP_CASE(PR_MHS_COMMON_NAME);
        RETURN_PROP_CASE(PR_SEND_RICH_INFO);
        RETURN_PROP_CASE(PR_TRANSMITABLE_DISPLAY_NAME);

        default:
            wsprintf(szPropTag, "Unknown property tag 0x%x",
              PROP_ID(ulPropTag));
            return(szPropTag);
    }
}


/***************************************************************************

    Name      : DebugPropTagArray

    Purpose   : Displays MAPI property tags from a counted array

    Parameters: lpPropArray -> property array
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugPropTagArray(LPSPropTagArray lpPropArray, PUCHAR pszObject) {
    DWORD i;
    PUCHAR lpType;

    if (lpPropArray == NULL) {
        DebugTrace("Empty %s property tag array.\n", pszObject ? pszObject : szNULL);
        return;
    }

    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s property tags:\n", lpPropArray->cValues,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < lpPropArray->cValues ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpPropArray->aulPropTag[i],
          lpPropArray->aulPropTag[i] >> 16,
          lpPropArray->aulPropTag[i] & 0xffff);
#endif
        switch (lpPropArray->aulPropTag[i] & 0xffff) {
            case PT_STRING8:
                lpType = "STRING8";
                break;
            case PT_LONG:
                lpType = "LONG";
                break;
            case PT_I2:
                lpType = "I2";
                break;
            case PT_ERROR:
                lpType = "ERROR";
                break;
            case PT_BOOLEAN:
                lpType = "BOOLEAN";
                break;
            case PT_R4:
                lpType = "R4";
                break;
            case PT_DOUBLE:
                lpType = "DOUBLE";
                break;
            case PT_CURRENCY:
                lpType = "CURRENCY";
                break;
            case PT_APPTIME:
                lpType = "APPTIME";
                break;
            case PT_SYSTIME:
                lpType = "SYSTIME";
                break;
            case PT_UNICODE:
                lpType = "UNICODE";
                break;
            case PT_CLSID:
                lpType = "CLSID";
                break;
            case PT_BINARY:
                lpType = "BINARY";
                break;
            case PT_I8:
                lpType = "PT_I8";
                break;
            case PT_MV_I2:
                lpType = "MV_I2";
                break;
            case PT_MV_LONG:
                lpType = "MV_LONG";
                break;
            case PT_MV_R4:
                lpType = "MV_R4";
                break;
            case PT_MV_DOUBLE:
                lpType = "MV_DOUBLE";
                break;
            case PT_MV_CURRENCY:
                lpType = "MV_CURRENCY";
                break;
            case PT_MV_APPTIME:
                lpType = "MV_APPTIME";
                break;
            case PT_MV_SYSTIME:
                lpType = "MV_SYSTIME";
                break;
            case PT_MV_BINARY:
                lpType = "MV_BINARY";
                break;
            case PT_MV_STRING8:
                lpType = "MV_STRING8";
                break;
            case PT_MV_UNICODE:
                lpType = "MV_UNICODE";
                break;
            case PT_MV_CLSID:
                lpType = "MV_CLSID";
                break;
            case PT_MV_I8:
                lpType = "MV_I8";
                break;
            case PT_NULL:
                lpType = "NULL";
                break;
            case PT_OBJECT:
                lpType = "OBJECT";
                break;
            default:
                DebugTrace("<Unknown Property Type>");
                break;
        }
        DebugTrace("%s\t%s\n", PropTagName(lpPropArray->aulPropTag[i]), lpType);
    }
}


/***************************************************************************

    Name      : DebugProperties

    Purpose   : Displays MAPI properties in a property list

    Parameters: lpProps -> property list
                cProps = count of properties
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
void _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject) {
    DWORD i, j;


    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s properties:\n", cProps,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < cProps ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpProps[i].ulPropTag,
          lpProps[i].ulPropTag >> 16,
          lpProps[i].ulPropTag & 0xffff);
#endif
        DebugTrace("%s\n", PropTagName(lpProps[i].ulPropTag));

        switch (lpProps[i].ulPropTag & 0xffff) {
            case PT_STRING8:
                if (lstrlen(lpProps[i].Value.lpszA) < 1024) {
                    DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.lpszA);
                } else {
                    DebugTrace("STRING8 Value is too long to display\n");
                }
                break;
            case PT_LONG:
                DebugTrace("LONG Value:%u\n", lpProps[i].Value.l);
                break;
            case PT_I2:
                DebugTrace("I2 Value:%u\n", lpProps[i].Value.i);
                break;
            case PT_ERROR:
                DebugTrace("ERROR Value: 0x%08x\n", lpProps[i].Value.err);
                break;
            case PT_BOOLEAN:
                DebugTrace("BOOLEAN Value:%s\n", lpProps[i].Value.b ?
                  "TRUE" : "FALSE");
                break;
            case PT_R4:
                DebugTrace("R4 Value\n");
                break;
            case PT_DOUBLE:
                DebugTrace("DOUBLE Value\n");
                break;
            case PT_CURRENCY:
                DebugTrace("CURRENCY Value\n");
                break;
            case PT_APPTIME:
                DebugTrace("APPTIME Value\n");
                break;
            case PT_SYSTIME:
//                DebugTime(lpProps[i].Value.ft, "SYSTIME Value:%s\n");
                break;
            case PT_UNICODE:
                DebugTrace("UNICODE Value\n");
                break;
            case PT_CLSID:
                DebugTrace("CLSID Value\n");
                break;
            case PT_BINARY:
                DebugTrace("BINARY Value %u bytes:\n", lpProps[i].Value.bin.cb);
                DebugBinary(lpProps[i].Value.bin.cb, lpProps[i].Value.bin.lpb);
                break;
            case PT_I8:
                DebugTrace("LARGE_INTEGER Value\n");
                break;
            case PT_MV_I2:
                DebugTrace("MV_I2 Value\n");
                break;
            case PT_MV_LONG:
                DebugTrace("MV_LONG Value\n");
                break;
            case PT_MV_R4:
                DebugTrace("MV_R4 Value\n");
                break;
            case PT_MV_DOUBLE:
                DebugTrace("MV_DOUBLE Value\n");
                break;
            case PT_MV_CURRENCY:
                DebugTrace("MV_CURRENCY Value\n");
                break;
            case PT_MV_APPTIME:
                DebugTrace("MV_APPTIME Value\n");
                break;
            case PT_MV_SYSTIME:
                DebugTrace("MV_SYSTIME Value\n");
                break;
            case PT_MV_BINARY:
                DebugTrace("MV_BINARY with %u values\n", lpProps[i].Value.MVbin.cValues);
                for (j = 0; j < lpProps[i].Value.MVbin.cValues; j++) {
                    DebugTrace("BINARY Value %u: %u bytes\n", j, lpProps[i].Value.MVbin.lpbin[j].cb);
                    DebugBinary(lpProps[i].Value.MVbin.lpbin[j].cb, lpProps[i].Value.MVbin.lpbin[j].lpb);
                }
                break;
            case PT_MV_STRING8:
                DebugTrace("MV_STRING8 with %u values\n", lpProps[i].Value.MVszA.cValues);
                for (j = 0; j < lpProps[i].Value.MVszA.cValues; j++) {
                    if (lstrlen(lpProps[i].Value.MVszA.lppszA[j]) < 1024) {
                        DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.MVszA.lppszA[j]);
                    } else {
                        DebugTrace("STRING8 Value is too long to display\n");
                    }
                }
                break;
            case PT_MV_UNICODE:
                DebugTrace("MV_UNICODE Value\n");
                break;
            case PT_MV_CLSID:
                DebugTrace("MV_CLSID Value\n");
                break;
            case PT_MV_I8:
                DebugTrace("MV_I8 Value\n");
                break;
            case PT_NULL:
                DebugTrace("NULL Value\n");
                break;
            case PT_OBJECT:
                DebugTrace("OBJECT Value\n");
                break;
            default:
                DebugTrace("Unknown Property Type\n");
                break;
        }
    }
}


/***************************************************************************

    Name      : DebugADRLIST

    Purpose   : Displays structure of an ADRLIST including properties

    Parameters: lpAdrList -> ADRLSIT to show
                lpszTitle = string to identify this dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle) {
     ULONG i;
     TCHAR szTitle[250];

     for (i = 0; i < lpAdrList->cEntries; i++) {

         wsprintf(szTitle, "%s : Entry %u", lpszTitle, i);
         _DebugProperties(lpAdrList->aEntries[i].rgPropVals,
           lpAdrList->aEntries[i].cValues, szTitle);
     }
}


/***************************************************************************

    Name      : DebugObjectProps

    Purpose   : Displays MAPI properties of an object

    Parameters: fMAPI = TRUE if this is a MAPI object, FALSE if WAB
                lpObject -> object to dump
                Label = string to identify this prop dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugObjectProps(BOOL fMAPI, LPMAPIPROP lpObject, LPTSTR Label) {
    DWORD cProps = 0;
    LPSPropValue lpProps = NULL;
    HRESULT hr = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;


    hr = lpObject->lpVtbl->GetProps(lpObject, NULL, 0, &cProps, &lpProps);
    switch (sc = GetScode(hr)) {
        case SUCCESS_SUCCESS:
            break;

        case MAPI_W_ERRORS_RETURNED:
            DebugTrace("GetProps -> Errors Returned\n");
            break;

        default:
            DebugTrace("GetProps -> Error 0x%x\n", sc);
            return;
    }

    _DebugProperties(lpProps, cProps, Label);

    FreeBufferAndNull(fMAPI, &lpProps);
}


/*
 *	Destroys an SRowSet structure.
 */
STDAPI_(void)
MyFreeProws(BOOL fMAPI, LPSRowSet prows)
{
	ULONG		irow;

	if (!prows)
		return;

	for (irow = 0; irow < prows->cRows; ++irow)
		FreeBufferAndNull(fMAPI, &(prows->aRow[irow].lpProps));
	FreeBufferAndNull(fMAPI, &prows);
}


/***************************************************************************

    Name      : DebugMapiTable

    Purpose   : Displays structure of a MAPITABLE including properties

    Parameters: fMAPI = TRUE if this is a MAPI object, FALSE if WAB
                lpTable -> MAPITABLE to display

    Returns   : none

    Comment   : Don't sort the columns or rows here.  This routine should
                not produce side effects in the table.

***************************************************************************/
void _DebugMapiTable(BOOL fMAPI, LPMAPITABLE lpTable) {
    UCHAR szTemp[30];   // plenty for "ROW %u"
    ULONG ulCount;
    WORD wIndex;
    LPSRowSet lpsRow = NULL;
    ULONG ulCurrentRow = (ULONG)-1;
    ULONG ulNum, ulDen, lRowsSeeked;

    DebugTrace("=======================================\n");
    DebugTrace("+  Dump of MAPITABLE at 0x%x:\n", lpTable);
    DebugTrace("---------------------------------------\n");

    // How big is the table?
    lpTable->lpVtbl->GetRowCount(lpTable, 0, &ulCount);
    DebugTrace("Table contains %u rows\n", ulCount);

    // Save the current position in the table
    lpTable->lpVtbl->QueryPosition(lpTable, &ulCurrentRow, &ulNum, &ulDen);

    // Display the properties for each row in the table
    for (wIndex = 0; wIndex < ulCount; wIndex++) {
        // Get the next row
        lpTable->lpVtbl->QueryRows(lpTable, 1, 0, &lpsRow);

        if (lpsRow) {
//            Assert(lpsRow->cRows == 1); // should have exactly one row

            wsprintf(szTemp, "ROW %u", wIndex);

            _DebugProperties(lpsRow->aRow[0].lpProps,
              lpsRow->aRow[0].cValues, szTemp);

            MyFreeProws(fMAPI, lpsRow);
        }
    }

    // Restore the current position for the table
    if (ulCurrentRow != (ULONG)-1) {
        lpTable->lpVtbl->SeekRow(lpTable, BOOKMARK_BEGINNING, ulCurrentRow,
          &lRowsSeeked);
    }
}


/*
 * DebugTrace -- printf to the debugger console or debug output file
 * Takes printf style arguments.
 * Expects newline characters at the end of the string.
 */
VOID FAR CDECL _DebugTrace(LPSTR lpszFmt, ...) {
    va_list marker;
    TCHAR String[1100];

    va_start(marker, lpszFmt);
    wvsprintf(String, lpszFmt, marker);
        OutputDebugString(String);
}

int EXPORTDBG __cdecl DebugTraceFn(char *pszFormat, ...) {
    va_list marker;
    TCHAR String[1100];

    va_start(marker, pszFormat);
    wvsprintf(String, pszFormat, marker);
    OutputDebugString(String);
    return(0);
}


/*
 * DebugAssert
 *
 * From MAPI 1.0 SDK sample code
 */
int __cdecl DebugAssert(int fFatal, char *pszFile, int iLine,
  char *pszFormat, ...) {
    char    sz[512];
    va_list vl;
    int     id;

    lstrcpy(sz, "++++ WAB Debug Trap (");
    OutputDebugString(sz);

    va_start(vl, pszFormat);
    wvsprintf(sz, pszFormat, vl);
    va_end(vl);

    wsprintf(sz + lstrlen(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

    OutputDebugString(sz);

    // Hold down control key to prevent MessageBox
    if (GetAsyncKeyState(VK_CONTROL) >= 0) {
        id = MessageBox(NULL,
          sz,
          "Microsoft Windows Address Book Debug Trap",
          MB_ABORTRETRYIGNORE | MB_ICONHAND | MB_SYSTEMMODAL |
          (fFatal ? MB_DEFBUTTON1 : MB_DEFBUTTON3) );

        if (id == IDABORT)
            *((LPBYTE)NULL) = 0;
        else if (id == IDRETRY)
            DebugBreak();
    }

    return(0);
}


int EXPORTDBG __cdecl DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...) {
    char    sz[512];
    va_list vl;
    int     id;

    lstrcpy(sz, "++++ WAB Debug Trap (");
    OutputDebugString(sz);

    va_start(vl, pszFormat);
    wvsprintf(sz, pszFormat, vl);
    va_end(vl);

    wsprintf(sz + lstrlen(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

    OutputDebugString(sz);

    // Hold down control key to prevent MessageBox
    if (GetAsyncKeyState(VK_CONTROL) >= 0) {
        id = MessageBox(NULL,
          sz,
          "Microsoft Windows Address Book Debug Trap",
          MB_ABORTRETRYIGNORE | MB_ICONHAND | MB_SYSTEMMODAL |
          (fFatal ? MB_DEFBUTTON1 : MB_DEFBUTTON3) );

        if (id == IDABORT)
            *((LPBYTE)NULL) = 0;
        else if (id == IDRETRY)
            DebugBreak();
    }

    return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\makefile.inc ===
$O\globals.obj : globals.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\globals.c
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP

$O\wabguid.obj : wabguid.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\wabguid.c
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP

$(O)\wabimp.res : $(O)\selfreg.inf

selfreg.src : reg.src strings.src

$(O)\selfreg.inx : selfreg.src
	cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\messengr.c ===
/*
 *  Messengr.C
 *
 *  Migrate Communicator Messenger NAB <-> WAB
 *
 *  Copyright 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  To Do:
 *      ObjectClass recognition
 *      Attribute mapping
 *      Groups
 *      Base64
 *      URLs
 *      Reject Change List MESS
 *
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#include "wabimp.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"

#define CR_CHAR 0x0d
#define LF_CHAR 0x0a
#define CCH_READ_BUFFER 1024
#define NUM_ITEM_SLOTS  32

/* Messenger address header
8-Display Name.
8-Nickname.
2-?
8-First Name.
8-?
8-last Name
8-Organization
8- City
8-State
8-e-mail
8- Notes
1- FF
8-Title
8-Address1
8-Zip
8-Work Phone
8-Fax
8- House phone.
18-?
8-Address
8-Country.
*/

typedef enum _MESS_ATTRIBUTES {
    // PR_DISPLAY_NAME
    m_DisplayName,
    // PR_NICKNAME
    m_Nickname,                       // Netscape nickname
    //PR_GIVEN_NAME
    m_FirstName,
    //PR_SURNAME
    m_LastName,
    //PR_COMPANY_NAME
    m_Organization,
    // PR_LOCALITY
    m_City,                               // locality (city)
    // PR_STATE_OR_PROVINCE
    m_State,                                     // business address state
    // PR_EMAIL_ADDRESS
    m_Email,                                   // email address
    // PR_COMMENT
    m_Notes,
    //PR_TITLE,
    m_Title,
    // PR_STREET_ADDRESS
    m_StreetAddress2, 
    // PR_POSTAL_CODE
    m_Zip,                             // business address zip code
    // PR_BUSINESS_TELEPHONE_NUMBER
    m_WorkPhone,
    // PR_BUSINESS_FAX_NUMBER
    m_Fax,
    // PR_HOME_TELEPHONE_NUMBER
    m_HomePhone,
    // PR_STREET_ADDRESS
    m_StreetAddress1, 
    // PR_COUNTRY
    m_Country,                                      // country
    m_Max,
} MESS_ATTRIBUTES, *LPMESS_ATTRIBUTES;

ULONG ulDefPropTags[] =
{
    PR_DISPLAY_NAME,
    PR_NICKNAME,
    PR_GIVEN_NAME,
    PR_SURNAME,
    PR_COMPANY_NAME,
    PR_LOCALITY,
    PR_STATE_OR_PROVINCE,
    PR_EMAIL_ADDRESS,
    PR_COMMENT,
    PR_TITLE,
    PR_STREET_ADDRESS,
    PR_POSTAL_CODE,
    PR_BUSINESS_TELEPHONE_NUMBER,
    PR_BUSINESS_FAX_NUMBER,
    PR_HOME_TELEPHONE_NUMBER,
    PR_STREET_ADDRESS,
    PR_COUNTRY,
};

// All props are string props
typedef struct _MESS_RECORD {
    LPTSTR lpData[m_Max];
    ULONG  ulObjectType;
} MESS_RECORD, *LPMESS_RECORD;

typedef struct _MESS_HEADER_ATTRIBUTES {
    ULONG ulOffSet;
    ULONG ulSize;
} MH_ATTR, * LPMH_ATTR;

typedef struct _MESS_BASIC_PROPS {
    LPTSTR lpName;
    LPTSTR lpEmail;
    LPTSTR lpComment;
} MP_BASIC, * LPMP_BASIC;

typedef struct _MESS_STUFF {
    ULONG ulOffSet;
    ULONG ulNum;
    MP_BASIC bp;
} MH_STUFF, * LPMH_STUFF;

typedef struct _MESS_ADDRESS_HEADER {
    MH_ATTR prop[m_Max];
} MESS_HEADER, * LPMESS_HEADER;

// Must have
//  PR_DISPLAY_NAME
#define NUM_MUST_HAVE_PROPS 1

const TCHAR szMESSFilter[] = "*.nab";
const TCHAR szMESSExt[] =    "nab";



/*****************************************************************
    
    HrCreateAdrListFromMESSRecord
    
    Scans an MESS record and turns all the "members" into an 
    unresolved AdrList

******************************************************************/
HRESULT HrCreateAdrListFromMESSRecord(ULONG nMembers,
                                      LPMP_BASIC lpmp, 
                                      LPADRLIST * lppAdrList)
{
    HRESULT hr = S_OK;
    ULONG i;
    LPADRLIST lpAdrList = NULL;
    ULONG ulCount = 0;

    *lppAdrList = NULL;

    if(!nMembers)
        goto exit;

    // Now create a adrlist from these members

    // Allocate prop value array
    if (hr = ResultFromScode(WABAllocateBuffer(sizeof(ADRLIST) + nMembers * sizeof(ADRENTRY), &lpAdrList))) 
        goto exit;

    ulCount = nMembers;

    nMembers = 0;
    
    for(i=0;i<ulCount;i++)
    {
        LPTSTR lpName = lpmp[i].lpName;
        LPTSTR lpEmail = lpmp[i].lpEmail;

        if(lpName)
        {
            LPSPropValue lpProp = NULL;
            ULONG ulcProps = 2;

            if (hr = ResultFromScode(WABAllocateBuffer(2 * sizeof(SPropValue), &lpProp))) 
                goto exit;

            lpProp[0].ulPropTag = PR_DISPLAY_NAME;

            if (hr = ResultFromScode(WABAllocateMore(lstrlen(lpName)+1, lpProp, &(lpProp[0].Value.lpszA)))) 
                goto exit;

            lstrcpy(lpProp[0].Value.lpszA, lpName);

            if(lpEmail)
            {
                lpProp[1].ulPropTag = PR_EMAIL_ADDRESS;

                if (hr = ResultFromScode(WABAllocateMore(lstrlen(lpEmail)+1, lpProp, &(lpProp[1].Value.lpszA)))) 
                    goto exit;

                lstrcpy(lpProp[1].Value.lpszA, lpEmail);
            }
            lpAdrList->aEntries[nMembers].cValues = (lpEmail ? 2 : 1);
            lpAdrList->aEntries[nMembers].rgPropVals = lpProp;
            nMembers++;

        }

    }

    lpAdrList->cEntries = nMembers;

    *lppAdrList = lpAdrList;

exit:

    if(HR_FAILED(hr) && lpAdrList)
        WABFreePadrlist(lpAdrList);
    return hr;
}



/*****************************************************************
    
    HraddMESSDistList - adds a distlist and its members to the WAB

    Sequence of events will be:

    - Create a DistList object
    - Set the properties on the DistList object
    - Scan the list of members for the given dist list object
    - Add each member to the wab .. if member already exists,
        prompt to replace etc ...if it doesnt exist, create new
        

******************************************************************/
HRESULT HrAddMESSDistList(HWND hWnd,
                        LPABCONT lpContainer, 
                        MH_STUFF HeadDL,
                        ULONG ulcNumDLMembers, 
                        LPMP_BASIC lpmp,
                        LPWAB_PROGRESS_CALLBACK lpProgressCB,
                        LPWAB_EXPORT_OPTIONS lpOptions) 
{
    HRESULT hResult = S_OK;
    LPMAPIPROP lpDistListWAB = NULL;
    LPDISTLIST lpDLWAB = NULL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    REPLACE_INFO RI;
    LPADRLIST lpAdrList = NULL;
    LPFlagList lpfl = NULL;
    ULONG ulcValues = 0;
    LPSPropValue lpPropEID = NULL;
    ULONG i, cbEIDNew;
    LPENTRYID lpEIDNew;
    ULONG ulObjectTypeOpen;
    SPropValue Prop[3];
    ULONG cProps = 0;
    LPTSTR lpDisplayName = HeadDL.bp.lpName;

    Prop[cProps].ulPropTag = PR_DISPLAY_NAME;
    Prop[cProps].Value.LPSZ = HeadDL.bp.lpName;

    if(!HeadDL.bp.lpName)
        return MAPI_E_INVALID_PARAMETER;

    cProps++;

    Prop[cProps].ulPropTag = PR_OBJECT_TYPE;
    Prop[cProps].Value.l = MAPI_DISTLIST;

    cProps++;

    if(HeadDL.bp.lpComment)
    {
        Prop[cProps].ulPropTag = PR_COMMENT;
        Prop[cProps].Value.LPSZ = HeadDL.bp.lpComment;
        cProps++;
    }

    //if (lpOptions->ReplaceOption ==  WAB_REPLACE_ALWAYS) 
    // Force a replace - collision will only be for groups and we dont care really
    {
        ulCreateFlags |= CREATE_REPLACE;
    }

retry:
    // Create a new wab distlist
    if (HR_FAILED(hResult = lpContainer->lpVtbl->CreateEntry(   
                    lpContainer,
                    lpCreateEIDsWAB[iconPR_DEF_CREATE_DL].Value.bin.cb,
                    (LPENTRYID) lpCreateEIDsWAB[iconPR_DEF_CREATE_DL].Value.bin.lpb,
                    ulCreateFlags,
                    (LPMAPIPROP *) &lpDistListWAB))) 
    {
        DebugTrace("CreateEntry(WAB MailUser) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Set the properties on the new WAB entry
    if (HR_FAILED(hResult = lpDistListWAB->lpVtbl->SetProps(    lpDistListWAB,
                                                                cProps,                   // cValues
                                                                (LPSPropValue) &Prop,                    // property array
                                                                NULL)))                   // problems array
    {
        goto exit;
    }


    // Save the new wab mailuser or distlist
    if (HR_FAILED(hResult = lpDistListWAB->lpVtbl->SaveChanges(lpDistListWAB,
                                                              KEEP_OPEN_READWRITE | FORCE_SAVE))) 
    {
        if (GetScode(hResult) == MAPI_E_COLLISION) 
        {
            // Find the display name
            Assert(lpDisplayName);

            if (! lpDisplayName) 
            {
                DebugTrace("Collision, but can't find PR_DISPLAY_NAME in entry\n");
                goto exit;
            }

            // Do we need to prompt?
            if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) 
            {
                // Prompt user with dialog.  If they say YES, we should try again


                RI.lpszDisplayName = lpDisplayName;
                RI.lpszEmailAddress = NULL; //lpEmailAddress;
                RI.ConfirmResult = CONFIRM_ERROR;
                RI.lpImportOptions = lpOptions;

                DialogBoxParam(hInst,
                  MAKEINTRESOURCE(IDD_ImportReplace),
                  hWnd,
                  ReplaceDialogProc,
                  (LPARAM)&RI);

                switch (RI.ConfirmResult) 
                {
                    case CONFIRM_YES:
                    case CONFIRM_YES_TO_ALL:
                        // YES
                        // NOTE: recursive Migrate will fill in the SeenList entry
                        // go try again!
                        lpDistListWAB->lpVtbl->Release(lpDistListWAB);
                        lpDistListWAB = NULL;

                        ulCreateFlags |= CREATE_REPLACE;
                        goto retry;
                        break;

                    case CONFIRM_ABORT:
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                        goto exit;

                    default:
                        // NO
                        break;
                }
            }
            hResult = hrSuccess;

        } else 
        {
            DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
        }
    }


    // Now we've created the Distribution List object .. we need to add members to it ..
    //
    // What is the ENTRYID of our new entry?
    if ((hResult = lpDistListWAB->lpVtbl->GetProps(lpDistListWAB,
                                                  (LPSPropTagArray)&ptaEid,
                                                  0,
                                                  &ulcValues,
                                                  &lpPropEID))) 
    {
        goto exit;
    }

    cbEIDNew = lpPropEID->Value.bin.cb;
    lpEIDNew = (LPENTRYID) lpPropEID->Value.bin.lpb;

    if(!cbEIDNew || !lpEIDNew)
        goto exit;

     // Open the new WAB DL as a DISTLIST object
    if (HR_FAILED(hResult = lpContainer->lpVtbl->OpenEntry(lpContainer,
                                                          cbEIDNew,
                                                          lpEIDNew,
                                                          (LPIID)&IID_IDistList,
                                                          MAPI_MODIFY,
                                                          &ulObjectTypeOpen,
                                                          (LPUNKNOWN*)&lpDLWAB))) 
    {
        goto exit;
    }


    if(!ulcNumDLMembers)
    {
        hResult = S_OK;
        goto exit;
    }

    // First we create a lpAdrList with all the members of this dist list and try to resolve
    // the members against the container .. entries that already exist in the WAB will come
    // back as resolved .. entries that dont exist in the container will come back as unresolved
    // We can then add the unresolved entries as fresh entries to the wab (since they are 
    // unresolved, there will be no collision) .. and then we can do another resolvenames to
    // resolve everything and get a lpAdrList full of EntryIDs .. we can then take this list of
    // entryids and call CreateEntry or CopyEntry on the DistList object to copy the entryid into
    // the distlist ...

    hResult = HrCreateAdrListFromMESSRecord(ulcNumDLMembers, lpmp, &lpAdrList);

    if(HR_FAILED(hResult))
        goto exit;

    if(!lpAdrList || !(lpAdrList->cEntries))
        goto exit;

    // Create a corresponding flaglist
    lpfl = LocalAlloc(LMEM_ZEROINIT, sizeof(FlagList) + (lpAdrList->cEntries)*sizeof(ULONG));
    if(!lpfl)
    {
        hResult = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpfl->cFlags = lpAdrList->cEntries;

    // set all the flags to unresolved
    for(i=0;i<lpAdrList->cEntries;i++)
        lpfl->ulFlag[i] = MAPI_UNRESOLVED;

    hResult = lpContainer->lpVtbl->ResolveNames(lpContainer, NULL, 0, lpAdrList, lpfl);

    if(HR_FAILED(hResult))
        goto exit;

    // All the entries in the list that are resolved, already exist in the address book.

    // The ones that are not resolved need to be added silently to the address book ..
    for(i=0;i<lpAdrList->cEntries;i++)
    {
        if(lpfl->ulFlag[i] == MAPI_UNRESOLVED)
        {
            LPMAPIPROP lpMailUser = NULL;

            if (HR_FAILED(hResult = lpContainer->lpVtbl->CreateEntry(   
                                lpContainer,
                                lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.cb,
                                (LPENTRYID) lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.lpb,
                                0,
                                &lpMailUser))) 
            {
                continue;
                //goto exit;
            }

            if(lpMailUser)
            {
                // Set the properties on the new WAB entry
                if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
                                                                    lpAdrList->aEntries[i].cValues,
                                                                    lpAdrList->aEntries[i].rgPropVals,
                                                                    NULL)))                   
                {
                    goto exit;
                }

                // Save the new wab mailuser or distlist
                if (HR_FAILED(hResult = lpMailUser->lpVtbl->SaveChanges(lpMailUser,
                                                                        KEEP_OPEN_READONLY | FORCE_SAVE))) 
                {
                    goto exit;
                }

                lpMailUser->lpVtbl->Release(lpMailUser);
            }
        }
    }


    // now that we've added all the unresolved members to the WAB, we call ResolveNames
    // again .. as a result, every member in this list will be resolved and we will
    // have entryids for all of them 
    // We will then take these entryids and add them to the DistList object

    hResult = lpContainer->lpVtbl->ResolveNames(lpContainer, NULL, 0, lpAdrList, lpfl);

    if(hResult==MAPI_E_AMBIGUOUS_RECIP)
        hResult = S_OK;

    if(HR_FAILED(hResult))
        goto exit;

    for(i=0;i<lpAdrList->cEntries;i++)
    {
        if(lpfl->ulFlag[i] == MAPI_RESOLVED)
        {
            ULONG j = 0;
            LPSPropValue lpProp = lpAdrList->aEntries[i].rgPropVals;
            
            for(j=0; j<lpAdrList->aEntries[i].cValues; j++)
            {
                if(lpProp[j].ulPropTag == PR_ENTRYID)
                {
                    LPMAPIPROP lpMapiProp = NULL;

                    //ignore errors
                    lpDLWAB->lpVtbl->CreateEntry(lpDLWAB,
                                                lpProp[j].Value.bin.cb,
                                                (LPENTRYID) lpProp[j].Value.bin.lpb,
                                                0, 
                                                &lpMapiProp);

                    if(lpMapiProp)
                    {
                        lpMapiProp->lpVtbl->SaveChanges(lpMapiProp, KEEP_OPEN_READWRITE | FORCE_SAVE);
                        lpMapiProp->lpVtbl->Release(lpMapiProp);
                    }

                    break;
                }
            }
        }
    }

exit:

    if (lpPropEID)
        WABFreeBuffer(lpPropEID);

    if (lpDLWAB)
        lpDLWAB->lpVtbl->Release(lpDLWAB);

    if(lpDistListWAB)
        lpDistListWAB->lpVtbl->Release(lpDistListWAB);

    if(lpAdrList)
        WABFreePadrlist(lpAdrList);

    if(lpfl)
        LocalFree(lpfl);

    return hResult;
}



/*********************************************************
    
    HraddMESSMailUser - adds a mailuser to the WAB

**********************************************************/
HRESULT HrAddMESSMailUser(HWND hWnd,
                        LPABCONT lpContainer, 
                        LPTSTR lpDisplayName, 
                        LPTSTR lpEmailAddress,
                        ULONG cProps,
                        LPSPropValue lpspv,
                        LPWAB_PROGRESS_CALLBACK lpProgressCB,
                        LPWAB_EXPORT_OPTIONS lpOptions) 
{
    HRESULT hResult = S_OK;
    LPMAPIPROP lpMailUserWAB = NULL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    REPLACE_INFO RI;


    if (lpOptions->ReplaceOption ==  WAB_REPLACE_ALWAYS) 
    {
        ulCreateFlags |= CREATE_REPLACE;
    }


retry:
    // Create a new wab mailuser
    if (HR_FAILED(hResult = lpContainer->lpVtbl->CreateEntry(   
                        lpContainer,
                        lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.cb,
                        (LPENTRYID) lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.lpb,
                        ulCreateFlags,
                        &lpMailUserWAB))) 
    {
        DebugTrace("CreateEntry(WAB MailUser) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Set the properties on the new WAB entry
    if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SetProps(    lpMailUserWAB,
                                                                cProps,                   // cValues
                                                                lpspv,                    // property array
                                                                NULL)))                   // problems array
    {
        goto exit;
    }


    // Save the new wab mailuser or distlist
    if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
                                                              KEEP_OPEN_READONLY | FORCE_SAVE))) 
    {
        if (GetScode(hResult) == MAPI_E_COLLISION) 
        {
            // Find the display name
            Assert(lpDisplayName);

            if (! lpDisplayName) 
            {
                DebugTrace("Collision, but can't find PR_DISPLAY_NAME in entry\n");
                goto exit;
            }

            // Do we need to prompt?
            if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) 
            {
                // Prompt user with dialog.  If they say YES, we should try again


                RI.lpszDisplayName = lpDisplayName;
                RI.lpszEmailAddress = lpEmailAddress;
                RI.ConfirmResult = CONFIRM_ERROR;
                RI.lpImportOptions = lpOptions;

                DialogBoxParam(hInst,
                  MAKEINTRESOURCE(IDD_ImportReplace),
                  hWnd,
                  ReplaceDialogProc,
                  (LPARAM)&RI);

                switch (RI.ConfirmResult) 
                {
                    case CONFIRM_YES:
                    case CONFIRM_YES_TO_ALL:
                        // YES
                        // NOTE: recursive Migrate will fill in the SeenList entry
                        // go try again!
                        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                        lpMailUserWAB = NULL;

                        ulCreateFlags |= CREATE_REPLACE;
                        goto retry;
                        break;

                    case CONFIRM_ABORT:
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                        goto exit;

                    default:
                        // NO
                        break;
                }
            }
            hResult = hrSuccess;

        } else 
        {
            DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
        }
    }

exit:
    if(lpMailUserWAB)
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);


    return hResult;
}







/***************************************************************************

    Name      : MapMESSRecordtoProps

    Purpose   : Map the MESS record attributes to WAB properties

    Parameters: lpMESSRecord -> MESS record
                lpspv -> prop value array (pre-allocated)
                lpcProps -> returned number of properties
                lppDisplayName -> returned display name
                lppEmailAddress -> returned email address (or NULL)

    Returns   : HRESULT

***************************************************************************/
HRESULT MapMESSRecordtoProps( LPMESS_RECORD lpMESSRecord, 
                        LPSPropValue * lppspv, LPULONG lpcProps, 
                        LPTSTR * lppDisplayName, LPTSTR *lppEmailAddress) 
{
    HRESULT hResult = hrSuccess;
    ULONG cPropVals = m_Max + 1; // PR_OBJECT_TYPE
    ULONG iProp = 0;
    ULONG i;
    ULONG iTable;
    ULONG cProps = cPropVals;
    
    // Allocate prop value array
    if (hResult = ResultFromScode(WABAllocateBuffer(cProps * sizeof(SPropValue), lppspv))) {
        DebugTrace("WABAllocateBuffer -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Fill with PR_NULL
    for (i = 0; i < cProps; i++) {
        (*lppspv)[i].ulPropTag = PR_NULL;
    }

    iProp = 0;

    for(i=0; i<m_Max; i++)
    {
        if(lpMESSRecord->lpData[i] && lstrlen(lpMESSRecord->lpData[i]))
        {
            (*lppspv)[iProp].ulPropTag = ulDefPropTags[i];
            (*lppspv)[iProp].Value.LPSZ = lpMESSRecord->lpData[i];
            switch((*lppspv)[iProp].ulPropTag)
            {
            case PR_DISPLAY_NAME:
                *lppDisplayName = (*lppspv)[iProp].Value.LPSZ;
                break;
            case PR_EMAIL_ADDRESS:
                *lppEmailAddress = (*lppspv)[iProp].Value.LPSZ;
                break;
            }
            iProp++;
        }
    }
    (*lppspv)[iProp].ulPropTag = PR_OBJECT_TYPE;
    (*lppspv)[iProp].Value.l = lpMESSRecord->ulObjectType;

    *lpcProps = iProp;

exit:
    return(hResult);
}

/***************************************************************************

    Name      : FreeMESSRecord

    Purpose   : Frees an MESS record structure

    Parameters: lpMESSRecord -> record to clean up
                ulAttributes = number of attributes in lpMESSRecord

    Returns   : none

    Comment   :

***************************************************************************/
void FreeMESSRecord(LPMESS_RECORD lpMESSRecord) 
{
    ULONG i;

    if (lpMESSRecord) 
    {
        for (i = 0; i < m_Max; i++) 
        {
            if (lpMESSRecord->lpData[i]) 
                LocalFree(lpMESSRecord->lpData[i]);
        }
        LocalFree(lpMESSRecord);
    }
}

/***************************************************************************

	FunctionName:  GetOffSet
    Purpose		:  Gets 4 bytes from the offset specified.
    Parameters	:  hFile -pointer to the file
				   Offset-Offset of the 
				   OffSetValue -the returned 4 bytes.
    Returns		: 
    Note		:
***************************************************************************/
BOOL GetOffSet(HANDLE hFile, DWORD Offset, ULONG* lpOffSetValue)
{
	BYTE Value[4];

    DWORD dwRead = 0;

    SetFilePointer(hFile, Offset, NULL, FILE_BEGIN);

    ReadFile(hFile, Value, 4, &dwRead, NULL);

	*(lpOffSetValue)=	(ULONG)Value[0]*16777216 + (ULONG)Value[1]*65536 + (ULONG)Value[2]*256 + (ULONG)Value[3];

	return TRUE;
}




/******************************************************************************
 *  FUNCTION NAME:GetMESSFileName
 *
 *  PURPOSE:    Gets the Messenger Address book file name
 *
 *  PARAMETERS: szFileName = buffer containing the installation path
// Messenger abook is generally abook.nab
// Location can be found under
// HKLM\Software\Netscape\Netscape Navigator\Users\defaultuser
//  Look for "DirRoot"
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT GetNABPath(LPTSTR szFileName, DWORD cbFileName)
{
    HKEY phkResult = NULL;
    LONG Registry;
    BOOL bResult;
    TCHAR *lpData = NULL, *RegPath = NULL, *path = NULL;
    DWORD dwSize = cbFileName;
    
    LPTSTR lpRegMess = TEXT("Software\\Netscape\\Netscape Navigator\\Users");
    LPTSTR lpRegUser = TEXT("CurrentUser");
    LPTSTR lpRegKey = TEXT("DirRoot");
    LPTSTR lpNABFile = TEXT("\\abook.nab");

    HRESULT hResult = S_OK;
    TCHAR szUser[MAX_PATH];
    TCHAR szUserPath[2*MAX_PATH];

    *szFileName = '\0';
    *szUser ='\0';

    // Open the Netscape..Users key
    Registry = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpRegMess, 0, KEY_QUERY_VALUE, &phkResult);
    if (Registry != ERROR_SUCCESS) 
    {
        hResult = E_FAIL;
        goto error;
    }

    // Look for the CurrentUser
    dwSize = sizeof(szUser);
    Registry = RegQueryValueEx(phkResult, lpRegUser, NULL, NULL, (LPBYTE)szUser, &dwSize);
    if (Registry != ERROR_SUCCESS) 
    {
        hResult = E_FAIL;
        goto error;
    }

    if(!lstrlen(szUser))
    {
        hResult = E_FAIL;
        goto error;
    }

    if (phkResult) {
        RegCloseKey(phkResult);
    }

    //Now concatenate the currentuser to the end of the Netscape key and reopen
    lstrcpy(szUserPath, lpRegMess);
    lstrcat(szUserPath, TEXT("\\"));
    lstrcat(szUserPath, szUser);

    // Open the Netscape..Users key
    Registry = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szUserPath, 0, KEY_QUERY_VALUE, &phkResult);
    if (Registry != ERROR_SUCCESS) 
    {
        hResult = E_FAIL;
        goto error;
    }

    dwSize = cbFileName;
    Registry = RegQueryValueEx(phkResult, lpRegKey, NULL, NULL, (LPBYTE)szFileName, &dwSize);
    if (Registry != ERROR_SUCCESS) 
    {
        hResult = E_FAIL;
        goto error;
    }

    // concatenate the file name to this directory path
    lstrcat(szFileName,lpNABFile);

error:

    if (phkResult) {
        RegCloseKey(phkResult);
    }

    return(hResult);

}

HRESULT ReadMESSHeader(HANDLE hFile, LPMESS_HEADER lpmh, ULONG ulOffSet)
{
    ULONG ulMagicNumber = 0;
    HRESULT hr = E_FAIL;
    DWORD dwRead;
    ULONG i = 0;

    // Skip 2 bytes
    SetFilePointer(hFile, 2, NULL, FILE_CURRENT);
    ulOffSet += 2;

    GetOffSet(hFile, ulOffSet, &ulMagicNumber);

    if(ulMagicNumber != 0x00000001 ) 
        goto exit;

    ulOffSet += 4;

    for(i=0;i<m_Max;i++)
    {
        switch(i)
        {
        case m_FirstName:
            ulOffSet += 2;
            break;
        case m_LastName:
            ulOffSet += 8;
            break;
        case m_Title:
            ulOffSet += 1;
            break;
        case m_StreetAddress1:
            ulOffSet += 18;
            break;
        }

        GetOffSet(hFile, ulOffSet, &(lpmh->prop[i].ulOffSet));
        ulOffSet += 4;
        GetOffSet(hFile, ulOffSet, &(lpmh->prop[i].ulSize));
        ulOffSet += 4;
    }

    hr = S_OK;

exit:
    return hr;
}

		
/***************************************************************************

	FunctionName:  GetHeaders

    Purpose		:Reads the binary trees ( address binary tree or Dls binary tree) into an array.

    Parameters	:  nLayer= Number of layers in the binary tree.
				   Offset= Primary offset of the binary tree.
				   pHeaders= Array in which the Address entry header offsets and their numbers are to be stored.
				   bflag = 1 should be passed when this recursive function is called for the first time.
	Returns		: 

    Note		: //This function is a recursive function which reads the binary tree and stores the Offset values 
                    and the address numbers in a  Array.

***************************************************************************/
BOOL GetHeaders(HANDLE pFile, int nLayer, ULONG Offset, LPMH_STUFF pHeaders, BOOL bflag)
{
	static ULONG ulCount =0; //keeps trecat of the number of element 
	ULONG	nLoops =0;
	ULONG	ulNewOffset =0;
    ULONG ulElement = 0;

	if(bflag==1)
		ulCount =0;

    //get the number of elements in this header
	if(Offset==0)
		nLoops=32;
	else
	{
		GetOffSet( pFile, Offset+4,&nLoops);
		nLoops &=  0x0000FFFF;
	}


	for(ulElement = 0; ulElement < nLoops; ulElement++)
	{
		if(nLayer > 0)
		{
			ulNewOffset=0;
			if(Offset!=0)
			{
				GetOffSet(pFile, Offset+8+(ulElement*4), &ulNewOffset);
                {
	                ULONG ulMagicNumber=0;
	                GetOffSet(pFile,ulNewOffset+2,&ulMagicNumber);
	                if(ulMagicNumber != 1)
                        ulNewOffset = 0;
                }
			}
				 
			//call this function recursively
			GetHeaders( pFile, nLayer-1, ulNewOffset, pHeaders, 0);
			
		}
		else
		{
			//fill the array here (offset)
			pHeaders[ulCount].ulOffSet=pHeaders[ulCount].ulNum=0;

			if(Offset!=0)
			{
				GetOffSet(pFile, Offset+8+(ulElement*8),& (pHeaders[ulCount].ulOffSet));

				//fill the array element here (address number in case of addresses and size in case of messages)
				if(!GetOffSet(pFile, Offset+12+(ulElement*8), &(pHeaders[ulCount].ulNum)))
				{
					pHeaders[ulCount].ulNum=0;
				}
			}

			ulCount++; //increment the count
	
		}
	}

    return TRUE;
}

/***************************************************************************

    Name      : ReadMESSRecord

    Purpose   : Reads a record from an MESS file with fixups for special characters

    Parameters: hFile = file handle

    Returns   : HRESULT

***************************************************************************/
HRESULT ReadMESSRecord(HANDLE hFile, LPMESS_RECORD * lppMESSRecord, ULONG ulContactOffset) 
{
    HRESULT hResult = hrSuccess;
    PUCHAR lpBuffer  = NULL;
    ULONG cbBuffer = 0;
    ULONG cbReadFile = 1;
    ULONG iItem = 0;
    ULONG cAttributes = 0;
    BOOL fEOR = FALSE;
    LPMESS_RECORD lpMESSRecord = NULL;
    LPBYTE lpData = NULL;
    LPTSTR lpName = NULL;
    ULONG cbData;
    TCHAR szTemp[2048]; // 2k limit
    ULONG i = 0;
    DWORD dwRead = 0;

    MESS_HEADER mh = {0};

    // The Contact Offset gives us the offset of the header for this record - the
    // header contains the offset and the size of each property for that address
    if(hResult = ReadMESSHeader(hFile, &mh, ulContactOffset))
        goto exit;
 
    lpMESSRecord = LocalAlloc(LMEM_ZEROINIT, sizeof(MESS_RECORD));
    if(!lpMESSRecord)
    {
        hResult = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpMESSRecord->ulObjectType = MAPI_MAILUSER;

    for(i=0;i<m_Max;i++)
    {
        if(mh.prop[i].ulSize)
        {
            if(i == m_StreetAddress1)
                lpMESSRecord->lpData[i] = LocalAlloc(LMEM_ZEROINIT, mh.prop[i].ulSize + mh.prop[m_StreetAddress2].ulSize + 8);
            else
                lpMESSRecord->lpData[i] = LocalAlloc(LMEM_ZEROINIT, mh.prop[i].ulSize);
            if(lpMESSRecord->lpData[i])
            {
                SetFilePointer(hFile, mh.prop[i].ulOffSet, NULL, FILE_BEGIN);
                ReadFile(hFile, (LPVOID) lpMESSRecord->lpData[i], mh.prop[i].ulSize, &dwRead, NULL);
                lpMESSRecord->lpData[i][mh.prop[i].ulSize-1] = '\0';
            }
        }
    }

    //Fix the fact that the street address is split into street1 and street2
    if(lpMESSRecord->lpData[m_StreetAddress1] && lpMESSRecord->lpData[m_StreetAddress2] &&
       lstrlen(lpMESSRecord->lpData[m_StreetAddress1]) && lstrlen(lpMESSRecord->lpData[m_StreetAddress2]))
    {
        lstrcat(lpMESSRecord->lpData[m_StreetAddress1], TEXT("\r\n"));
        lstrcat(lpMESSRecord->lpData[m_StreetAddress1], lpMESSRecord->lpData[m_StreetAddress2]);
        LocalFree(lpMESSRecord->lpData[m_StreetAddress2]);
        lpMESSRecord->lpData[m_StreetAddress2] = NULL;
    }

    *lppMESSRecord = lpMESSRecord;
exit:


    return(hResult);
}



/***************************************************************************
    GetAllDLNames
    
    Purpose		: Gets the Names of all the DLs.

    Note		: 

***************************************************************************/
BOOL GetAllDLNames(HANDLE pFile, ULONG nDLs, LPMH_STUFF pHeadersDL)
{

    ULONG i = 0;

    for(i=0;i<nDLs;i++)
    {
	    ULONG ulDLDispNameOffset=0;
	    ULONG ulDLDispNameSize=0;
        ULONG ulDLCommentOffSet = 0;
        ULONG ulDLCommentSize = 0;

        DWORD dwRead = 0;
        LPTSTR szComment = 0;
        LPTSTR szSubject = NULL;

        ULONG ulDLOffset = pHeadersDL[i].ulOffSet;

	    //get the diplay name of the DL.
	    if(FALSE==GetOffSet(pFile, ulDLOffset+6,&ulDLDispNameOffset))
		    return FALSE;

	    if(FALSE==GetOffSet(pFile,ulDLOffset+10,&ulDLDispNameSize))
		    return FALSE;

        if(ulDLDispNameSize)
        {
	        if((szSubject= LocalAlloc(LMEM_ZEROINIT, ulDLDispNameSize))==NULL)
		        return FALSE;

            SetFilePointer(pFile, ulDLDispNameOffset, NULL, FILE_BEGIN);

            ReadFile(pFile, (LPVOID) szSubject, ulDLDispNameSize, &dwRead, NULL); 

            szSubject[ulDLDispNameSize-1] = '\0';

            pHeadersDL[i].bp.lpName = szSubject;
        }

        // Get the Comment for the DL
       if(FALSE==GetOffSet(pFile,ulDLOffset+44,&ulDLCommentOffSet))
            return FALSE;
        if(FALSE==GetOffSet(pFile,ulDLOffset+48,&ulDLCommentSize))
            return FALSE;

        if(ulDLCommentSize)
        {
            if((szComment= LocalAlloc(LMEM_ZEROINIT, ulDLCommentSize))==NULL)
		        return FALSE;

            SetFilePointer(pFile, ulDLCommentOffSet, NULL, FILE_BEGIN);

            ReadFile(pFile, (LPVOID) szComment, ulDLCommentSize, &dwRead, NULL); 

            szComment[ulDLCommentSize-1] = '\0';

            pHeadersDL[i].bp.lpComment = szComment;
        }
 
    }

    return TRUE;
}


/***************************************************************************

  GetDLEntryNumbers - reads the DL member numbers (ids) from the binary tree
    in the NAB file

/***************************************************************************/
BOOL GetDLEntryNumbers(HANDLE pFile, int nLayer, ULONG POffset,ULONG* ulNumOfEntries,ULONG *pEntryNumbers,BOOL bflag)
{
	static ULONG ulCount =0; //keeps trecat of the number of element 
	ULONG	nLoops =0;
	ULONG	ulNewOffset =0;
    ULONG ulElement = 0;

	if(bflag==1)
		ulCount =0;

	if(POffset==0)
		nLoops=32;
	else
	{
		GetOffSet(pFile,POffset+4,&nLoops);
		nLoops &=  0x0000FFFF;
	}


	for(ulElement = 0; ulElement < nLoops; ulElement++)
	{
		if(nLayer > 0)
		{
			ulNewOffset=0;
			if(POffset!=0)
				GetOffSet(pFile, POffset+8+(ulElement*4), &ulNewOffset);
				 
			//call this function recursively
			GetDLEntryNumbers(pFile,nLayer-1, ulNewOffset,ulNumOfEntries,pEntryNumbers,0);					
		}
		else
		{
			//fill the array here (offset)
			pEntryNumbers[ulCount]=0;

			if(POffset!=0)
				GetOffSet(pFile, POffset+8+(ulElement*4),&(pEntryNumbers[ulCount]));

			ulCount++; //increment the count
			if(ulCount>(*ulNumOfEntries))
			{
				*ulNumOfEntries=ulCount;
				return TRUE;
			}
		}
	}
	return TRUE;
}

/***************************************************************************

	FunctionName:  GetDLEntries

    Purpose		: Gets the entries of a DL.

    Note		: 

***************************************************************************/
BOOL GetDLEntries(HANDLE pFile, 
                  LPMH_STUFF pHeadAdd,  ULONG ulAddCount, 
                  LPMH_STUFF pHeadDL,   ULONG ulDLCount, 
                  ULONG ulDLOffset, ULONG nIndex,
                  ULONG * lpulDLNum, LPMP_BASIC * lppmp)
{
	ULONG ulDLEntHeaderOffSet=0;//offset of the header of DL entries(Header which has the entry numbers
	ULONG ulDLEntriesCount=0;

	ULONG ulDLEntryOffSet=0;  //offset of the Dl entry              
	ULONG ulDLEntryNumber=0;  //Number of DL entry
	ULONG ulDLEntryNameOffSet=0; 
	ULONG ulDLEntryNameSize=0;

    ULONG * lpulDLEntryNumbers = NULL;
	int nLevelCount=0;
	int utemp=32;

    DWORD dwRead = 0;
    ULONG i, j;

    LPMP_BASIC lpmp = NULL; 

	if(FALSE==GetOffSet(pFile,ulDLOffset+24,&ulDLEntriesCount))
		return FALSE;

    if(!ulDLEntriesCount) // no members
        return TRUE;

	*lpulDLNum = ulDLEntriesCount;

	//alocate the array of string pointers which hold the names of the DL entries.
	lpmp = LocalAlloc(LMEM_ZEROINIT, sizeof(MP_BASIC) * ulDLEntriesCount);

	//get the entries here
	//first get the offset of the header which has the DL entry numbers.

	if(FALSE==GetOffSet(pFile,ulDLOffset+28,&ulDLEntHeaderOffSet))
		return FALSE;

    lpulDLEntryNumbers = LocalAlloc(LMEM_ZEROINIT, sizeof(ULONG) * ulDLEntriesCount);
    if(!lpulDLEntryNumbers)
        return FALSE;

	nLevelCount=0;
	utemp=32;

	while(utemp <(int) ulDLEntriesCount)
	{
		utemp *= 32;
		nLevelCount++;
	}

	if(!(GetDLEntryNumbers(pFile, nLevelCount, ulDLEntHeaderOffSet, &ulDLEntriesCount, lpulDLEntryNumbers, 1)))
	{
		return FALSE;
	}

	for(i=0;i<ulDLEntriesCount;i++)
	{	
		ULONG j=0;
        LPTSTR lp = NULL;
        LPTSTR lpE = NULL;

		ulDLEntryOffSet=0;
		lpmp[i].lpName=NULL;
		lpmp[i].lpEmail=NULL;
    	lpmp[i].lpComment=NULL;

		//get the entry number ulDLentryNumber
        ulDLEntryNumber = lpulDLEntryNumbers[i];
	
		//search out address array to get the display name....
		for(j=0;j<ulAddCount;j++)
		{
			if(pHeadAdd[j].ulNum == ulDLEntryNumber)
			{
				lpmp[i].lpName = pHeadAdd[j].bp.lpName;
                lpmp[i].lpEmail = pHeadAdd[j].bp.lpEmail;
				break;
			}
		}

		//search the DL array now...
		if(!lpmp[i].lpName)
		{
            ULONG k;
			for(k=0;k<ulDLCount;k++)
			{
				if(pHeadDL[k].ulNum == ulDLEntryNumber)
				{
				    lpmp[i].lpName = pHeadDL[k].bp.lpName;
                    lpmp[i].lpEmail = NULL; // DLs dont have emails
					break;
				}
			}
		}
	}

    *lppmp = lpmp;

	return TRUE;
}




/****************************************************************
*
*
*
*****************************************************************/
HRESULT MessengerImport( HWND hWnd,
                    LPADRBOOK lpAdrBook,
                    LPWABOBJECT lpWABObject,
                    LPWAB_PROGRESS_CALLBACK lpProgressCB,
                    LPWAB_EXPORT_OPTIONS lpOptions) 
{
    HRESULT hResult = hrSuccess;
    TCHAR szFileName[MAX_PATH + 1];
    register ULONG i;
    ULONG ulObjType, j;
    ULONG index;
    ULONG ulLastChosenProp = 0;
    ULONG ulcFields = 0;
    ULONG cAttributes = 0;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    WAB_PROGRESS Progress;
    LPABCONT lpContainer = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPMESS_RECORD lpMESSRecord = NULL;
    LPSPropValue lpspv = NULL;
    ULONG cProps;
    BOOL fSkipSetProps;
    LPTSTR lpDisplayName = NULL, lpEmailAddress = NULL;
    BOOL fDoDistLists = FALSE;

    ULONG nEntries = 0;
    ULONG nDLs = 0;
    ULONG nContactOffset = 0;
    ULONG nDLOffset = 0;

    int utemp=32;
    LPMH_STUFF pHeadersAdd = NULL;
    LPMH_STUFF pHeadersDL = NULL;

	int nLevelCountAdd=0;

    SetGlobalBufferFunctions(lpWABObject);

    *szFileName = '\0';

    hResult = GetNABPath(szFileName, sizeof(szFileName));

    if( hResult != S_OK || !lstrlen(szFileName) ||
        GetFileAttributes(szFileName) == 0xFFFFFFFF)
    {
        // The file was not correctly detected
        // Prompt to find it manually ...
        lstrcpy(szFileName, LoadStringToGlobalBuffer(IDS_STRING_SELECTPATH));
        if (IDNO == MessageBox( hWnd,
                        szFileName, //temporarily overloaded
                        LoadStringToGlobalBuffer(IDS_MESSAGE),
                        MB_YESNO)) 
        {
            return(ResultFromScode(MAPI_E_USER_CANCEL));
        }
        else
        {
            *szFileName = '\0';
            // Get MESS file name
            OpenFileDialog(hWnd,
                          szFileName,
                          szMESSFilter,
                          IDS_MESS_FILE_SPEC,
                          szAllFilter,
                          IDS_ALL_FILE_SPEC,
                          NULL,
                          0,
                          szMESSExt,
                          OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST,
                          hInst,
                          0,        //idsTitle
                          0);       // idsSaveButton
            if(!lstrlen(szFileName))
                return(ResultFromScode(E_FAIL));
        }
    }


    // Open the file
    if ((hFile = CreateFile(szFileName,
                              GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL)) == INVALID_HANDLE_VALUE) 
    {
        DWORD err =  GetLastError();
        DebugTrace("Couldn't open file %s -> %u\n", szFileName, err);
        // BEGIN DELTA for BUG 1804
        // if the file is locked (e.g. netscape AB in use)
        if( err == ERROR_SHARING_VIOLATION )
            return(ResultFromScode(MAPI_E_BUSY));
        // else return a generic error for generic msg            
        return(ResultFromScode(MAPI_E_NOT_FOUND));        
        // END   DELTA for BUG 1804
    }

    Assert(hFile != INVALID_HANDLE_VALUE);

    //
    // Open the WAB's PAB container: fills global lpCreateEIDsWAB
    //
    if (hResult = LoadWABEIDs(lpAdrBook, &lpContainer)) {
        goto exit;
    }

    //
    // All set... now loop through the records, adding each to the WAB
    //

	GetOffSet(hFile,0x185,&nEntries);
    GetOffSet(hFile,0x1d8,&nDLs);
    GetOffSet(hFile,0x195,&nContactOffset);
    GetOffSet(hFile,0x1e8,&nDLOffset);

    ulcEntries = nEntries + nDLs;

    if(!ulcEntries)
    {
        hResult = S_OK;
        goto exit;
    }

    // Initialize the Progress Bar
    Progress.denominator = max(ulcEntries, 1);
    Progress.numerator = 0;

    if (LoadString(hInst, IDS_STATE_IMPORT_MU, szBuffer, sizeof(szBuffer))) {
        DebugTrace("Status Message: %s\n", szBuffer);
        Progress.lpText = szBuffer;
    } else {
        DebugTrace("Cannot load resource string %u\n", IDS_STATE_IMPORT_MU);
        Progress.lpText = NULL;
    }
    lpProgressCB(hWnd, &Progress);

    
    // We will make 2 passes over the file - in the first pass we will import all the
    // contacts. In the second pass we will import all the distribution lists .. the
    // advantage of doing 2 passes is that when importing contacts, we will prompt on
    // conflict and then when importing distlists, we will assume all contacts in the 
    // WAB are correct and just point to the relevant ones


    if(nEntries)
    {
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

        pHeadersAdd = LocalAlloc(LMEM_ZEROINIT, nEntries * sizeof(MH_STUFF));
        if(!pHeadersAdd)
        {
            hResult = MAPI_E_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        utemp = 32;
        nLevelCountAdd = 0;
        while(utemp <(int) nEntries)
        {
	        utemp *= 32;
	        nLevelCountAdd++;
        }

        if(!GetHeaders(hFile ,nLevelCountAdd, nContactOffset, pHeadersAdd, 1))
        {
	        goto exit;
        }

        for(i=0;i<nEntries;i++)
        {
            if (hResult = ReadMESSRecord(hFile, &lpMESSRecord, pHeadersAdd[i].ulOffSet)) 
            {
                DebugTrace("ReadMESSRecord -> %x\n", GetScode(hResult));
                continue;
            }

            if (hResult = MapMESSRecordtoProps(   lpMESSRecord, 
                                            &lpspv, &cProps,
                                            &lpDisplayName, &lpEmailAddress)) 
            {
                DebugTrace("MapMESSRecordtoProps -> %x\n", GetScode(hResult));
                continue;
            }

            hResult = HrAddMESSMailUser(hWnd, 
                                        lpContainer, 
                                        lpDisplayName, 
                                        lpEmailAddress,
                                        cProps, lpspv,
                                        lpProgressCB, lpOptions);
            //if(HR_FAILED(hResult))
            if(hResult == MAPI_E_USER_CANCEL)
                goto exit;

            // Update progress bar
            Progress.numerator++;

            Assert(Progress.numerator <= Progress.denominator);

            if(lpDisplayName && lstrlen(lpDisplayName))
            {
                pHeadersAdd[i].bp.lpName = LocalAlloc(LMEM_ZEROINIT, lstrlen(lpDisplayName)+1);
                if(pHeadersAdd[i].bp.lpName)
                    lstrcpy(pHeadersAdd[i].bp.lpName, lpDisplayName);
            }

            if(lpEmailAddress && lstrlen(lpEmailAddress))
            {
                pHeadersAdd[i].bp.lpEmail = LocalAlloc(LMEM_ZEROINIT, lstrlen(lpEmailAddress)+1);
                if(pHeadersAdd[i].bp.lpEmail)
                    lstrcpy(pHeadersAdd[i].bp.lpEmail, lpEmailAddress);
            }

            if (lpMESSRecord) 
            {
                FreeMESSRecord(lpMESSRecord);
                lpMESSRecord = NULL;
            }

            if (lpspv) 
            {
                int j;
                for(j=0;j<m_Max;j++)
                {
                    lpspv[j].ulPropTag = PR_NULL;
                    lpspv[j].Value.LPSZ = NULL;
                }
                WABFreeBuffer(lpspv);
                lpspv = NULL;
            }

            lpProgressCB(hWnd, &Progress);

        }
    }



    // NOW do the DISTLISTS

    if(nDLs)
    {
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

        pHeadersDL = LocalAlloc(LMEM_ZEROINIT, nDLs * sizeof(MH_STUFF));
        if(!pHeadersDL)
        {
            hResult = MAPI_E_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        utemp = 32;
        nLevelCountAdd = 0;
	    while(utemp <(int) nDLs)
	    {
		    utemp *= 32;
		    nLevelCountAdd++;
	    }

	    if(!GetHeaders(hFile ,nLevelCountAdd, nDLOffset, pHeadersDL, 1))
	    {
		    goto exit;
	    }

        // read all the names of the DLs upfront ... this makes it easier to 
        // associate member DLs with the DL
        if(!GetAllDLNames(hFile, nDLs, pHeadersDL))
        {
            goto exit;
        }

        // 54263: Theres some kind of bug in the NAB file where we get nDLs == 1 even when there are no DLs
        // Need to skip over that case
        if(nDLs == 1 && !pHeadersDL[0].bp.lpName)
        {
            hResult = S_OK;
            goto exit;
        }

        for(i=0;i<nDLs;i++)
        {
            ULONG ulcNumDLEntries = 0;
            LPMP_BASIC lpmp = NULL;

            GetDLEntries(hFile, 
                        pHeadersAdd, nEntries, 
                        pHeadersDL, nDLs,
                        pHeadersDL[i].ulOffSet, i,
                        &ulcNumDLEntries, &lpmp);

            hResult = HrAddMESSDistList(hWnd, lpContainer, 
                                        pHeadersDL[i],
                                        ulcNumDLEntries, lpmp,
                                        lpProgressCB, lpOptions);

            //if(HR_FAILED(hResult))
            //    goto exit;

            // Update progress bar
            Progress.numerator++;

            Assert(Progress.numerator <= Progress.denominator);

            lpProgressCB(hWnd, &Progress);

            // Dont need to free lpmp since it only contains pointers and not allocated memory
            if(lpmp)
                LocalFree(lpmp);
        }
    }


    if (! HR_FAILED(hResult)) 
        hResult = hrSuccess;
 
exit:

    if(pHeadersAdd)
    {
        for(i=0;i<nEntries;i++)
        {
            if(pHeadersAdd[i].bp.lpName)
                LocalFree(pHeadersAdd[i].bp.lpName);
            if(pHeadersAdd[i].bp.lpEmail)
                LocalFree(pHeadersAdd[i].bp.lpEmail);
        }
        LocalFree(pHeadersAdd);
    }

    
    if(pHeadersDL)
    {
        for(i=0;i<nDLs;i++)
        {
            if(pHeadersDL[i].bp.lpName)
                LocalFree(pHeadersDL[i].bp.lpName);
            if(pHeadersDL[i].bp.lpComment)
                LocalFree(pHeadersDL[i].bp.lpComment);
        }
        LocalFree(pHeadersDL);
    }

    if (hFile) {
        CloseHandle(hFile);
    }

    if (lpspv) {
        WABFreeBuffer(lpspv);
        lpspv = NULL;
    }

    if (lpMESSRecord) {
        FreeMESSRecord(lpMESSRecord);
        lpMESSRecord = NULL;
    }

    if (lpContainer) {
        lpContainer->lpVtbl->Release(lpContainer);
        lpContainer = NULL;
    }

    if (lpCreateEIDsWAB) {
        WABFreeBuffer(lpCreateEIDsWAB);
        lpCreateEIDsWAB = NULL;
    }


    return(hResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\pab.c ===
/*
 *  PAB.C
 *
 *  Migrate PAB <-> WAB
 *
 *  Copyright 1996-1997 Microsoft Corporation.  All Rights Reserved.
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"
#include "wabimp.h"


void StateImportNextMU(HWND hwnd);
void StateImportDL(HWND hwnd);
void StateImportNextDL(HWND hwnd);
void StateImportFinish(HWND hwnd);
//void StateImportMU(HWND hwnd);
void StateImportMU(HWND hwnd);
void StateImportError(HWND hwnd);
void StateImportCancel(HWND hwnd);
BOOL HandleImportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_IMPORT_OPTIONS lpImportOptions);

HRESULT ImportEntry(HWND hwnd,
  LPADRBOOK lpAdrBookMAPI,
  LPABCONT lpContainerWAB,
  LPSPropValue lpCreateEIDsWAB,
  ULONG ulObjectType,
  LPENTRYID lpEID,
  ULONG cbEID,
  LPENTRYID * lppEIDWAB,
  LPULONG lpcbEIDWAB,
  BOOL fInDL,
  BOOL fForceReplace);

const UCHAR szQuote[] = "\"";
LPPROP_NAME lpImportMapping = NULL;

BOOL fError = FALSE;
LPWABOBJECT lpWABObject = NULL;
LPMAPISESSION lpMAPISession = NULL;
LPADRBOOK lpAdrBookWAB = NULL, lpAdrBookMAPI = NULL;
LPSPropValue lpCreateEIDsWAB = NULL, lpCreateEIDsMAPI = NULL;
LPABCONT  lpContainerWAB = NULL, lpContainerMAPI = NULL;
LPMAPITABLE lpContentsTableWAB = NULL, lpContentsTableMAPI = NULL;
ULONG ulcEntries = 0, ulcDone = 0;


PAB_STATE State = STATE_IMPORT_FINISH;
LPTSTR lpszWABFileName = NULL;
LPWAB_PROGRESS_CALLBACK lpfnProgressCB = NULL;
LPWAB_IMPORT_OPTIONS lpImportOptions = NULL;
LPWAB_EXPORT_OPTIONS lpExportOptions = NULL;



/*
- The following IDs and tags are for the conferencing named properties
-
-   The GUID for these props is PS_Conferencing
*/

DEFINE_OLEGUID(PS_Conferencing, 0x00062004, 0, 0);

#define CONF_SERVERS        0x8056

#define OLK_NAMEDPROPS_START CONF_SERVERS

ULONG PR_SERVERS;

enum _ConferencingTags
{
    prWABConfServers = 0,
    prWABConfMax
};
SizedSPropTagArray(prWABConfMax, ptaUIDetlsPropsConferencing);

HRESULT HrLoadPrivateWABPropsForCSV(LPADRBOOK );
// end conferencing duplication

/***************************************************************************

    Name      : NewState

    Purpose   :

    Parameters: hwnd = window handle of Dialog (currently unused)
                NewState = new state to set

    Returns   : none

    Comment   :

***************************************************************************/
 __inline void NewState(HWND hwnd, PAB_STATE NewState) {
    // Old version
    // PostMessage(hwnd, WM_COMMAND, NewState, 0);
    State = NewState;
    UNREFERENCED_PARAMETER(hwnd);
}


/***************************************************************************

    Name      : SetDialogMessage

    Purpose   : Sets the message text for the dialog box item IDC_Message

    Parameters: hwnd = window handle of dialog
                ids = stringid of message resource

    Returns   : none

***************************************************************************/
void SetDialogMessage(HWND hwnd, int ids) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    WAB_PROGRESS Progress = {0};

    Assert(lpfnProgressCB);

    if (lpfnProgressCB && LoadString(hInst, ids, szBuffer, sizeof(szBuffer))) {
        DebugTrace("Status Message: %s\n", szBuffer);

        Progress.lpText = szBuffer;
        lpfnProgressCB(hwnd, &Progress);
    } else {
        DebugTrace("Cannot load resource string %u\n", ids);
        Assert(FALSE);
    }
}


/***************************************************************************

    Name      : SetDialogProgress

    Purpose   : Sets progress bar

    Parameters: hwnd = window handle of dialog
                ulTotal = total entries
                ulDone = finished entries

    Returns   : none

***************************************************************************/
void SetDialogProgress(HWND hwnd, ULONG ulTotal, ULONG ulDone) {
    WAB_PROGRESS Progress = {0};

    Assert(lpfnProgressCB);

    if (lpfnProgressCB) {
        Progress.denominator = ulTotal;
        Progress.numerator = ulDone;
        lpfnProgressCB(hwnd, &Progress);
    }
}


/***************************************************************************

    Name      : AddEntryToImportList

    Purpose   : Checks this entry against our "seen" list and adds it.

    Parameters: cbEID = size of lpEID
                lpEID -> EntryID of entry
                lplIndex -> returned list index (or -1 on error)

    Returns   : TRUE if entry already exists

    Comment   : Caller must mark the WAB entry!

***************************************************************************/
#define GROW_SIZE   10
BOOL AddEntryToImportList(ULONG cbEID, LPENTRYID lpEID, LPLONG lplIndex) {
    ULONG i;
    LPENTRY_SEEN lpEntrySeen;

    if (cbEID && lpEID) {
        for (i = 0; i < ulEntriesSeen; i++) {
            if (cbEID == lpEntriesSeen[i].sbinPAB.cb  && (! memcmp(lpEID, lpEntriesSeen[i].sbinPAB.lpb, cbEID))) {
                // This one's in the list
                *lplIndex = i;
                // If cb 0, we must have recursed and are replacing, so this one is not a dup.
                return(lpEntriesSeen[i].sbinWAB.cb != 0);
            }
        }

        // Add to the end of the list
        if (++ulEntriesSeen > ulMaxEntries) {
            // Grow the array.

            ulMaxEntries += GROW_SIZE;

            if (lpEntriesSeen) {
                if (! (lpEntrySeen = LocalReAlloc(lpEntriesSeen, ulMaxEntries * sizeof(ENTRY_SEEN), LMEM_MOVEABLE | LMEM_ZEROINIT))) {
                    DebugTrace("LocalReAlloc(%u) -> %u\n", ulMaxEntries * sizeof(ENTRY_SEEN), GetLastError());
                    goto error;
                }
                lpEntriesSeen = lpEntrySeen;
            } else {
                if (! (lpEntriesSeen = LocalAlloc(LPTR, ulMaxEntries * sizeof(ENTRY_SEEN)))) {
                    DebugTrace("LocalAlloc(%u) -> %u\n", ulMaxEntries * sizeof(ENTRY_SEEN), GetLastError());
                    goto error;
                }
            }
        }

        lpEntrySeen = &lpEntriesSeen[ulEntriesSeen - 1];

        // Allocate space for data
        lpEntrySeen->sbinPAB.cb = cbEID;
        if (! (lpEntrySeen->sbinPAB.lpb = LocalAlloc(LPTR, cbEID))) {
            DebugTrace("LocalAlloc(%u) -> %u\n", cbEID, GetLastError());
            goto error;
        }

        // Mark as unknown WAB entry
        lpEntrySeen->sbinWAB.cb = 0;
        lpEntrySeen->sbinWAB.lpb = 0;

        // Copy in the data
        CopyMemory(lpEntrySeen->sbinPAB.lpb, lpEID, cbEID);
        *lplIndex = i;
    }

    return(FALSE);

error:
    // undo the damage...
    --ulEntriesSeen;
    ulMaxEntries -= GROW_SIZE;
    *lplIndex = -1;     // error
    if (! lpEntriesSeen) {
        ulEntriesSeen = 0;  // pointer is null now, back to square one.
        ulMaxEntries = 0;
    }
    return(FALSE);
}


/***************************************************************************

    Name      : MarkWABEntryInList

    Purpose   : Marks the WAB entry fields in the list node

    Parameters: cbEID = size of lpEID
                lpEID -> EntryID of entry
                lIndex = list index (or -1 on error)

    Returns   : none

    Comment   :

***************************************************************************/
void MarkWABEntryInList(ULONG cbEID, LPENTRYID lpEID, LONG lIndex) {
    if (lIndex != -1 && cbEID) {
       if (! (lpEntriesSeen[lIndex].sbinWAB.lpb = LocalAlloc(LPTR, cbEID))) {
           DebugTrace("LocalAlloc(%u) -> %u\n", cbEID, GetLastError());
           // leave it null
       } else {
           lpEntriesSeen[lIndex].sbinWAB.cb = cbEID;

           // Copy in the data
           CopyMemory(lpEntriesSeen[lIndex].sbinWAB.lpb, lpEID, cbEID);
       }
    }
}


/***************************************************************************

    Name      : StateImportMU

    Purpose   : Start the migration of MailUsers

    Parameters: hwnd = window handle of Import Dialog
                lpszFileName - FileName of WAB File to open

    Returns   : none

    Comment   : Login to MAPI
                Open the WAB
                Open the MAPI AB
                Open the WAB container
                Get the MAPI PAB contents table
                Restrict it to PR_OBJECTTYPE == MAPI_MAILUSER
                Post new state(STATE_NEXT_MU)

***************************************************************************/
void StateImportMU(HWND hwnd) {
    HRESULT hResult;
    ULONG ulFlags;
    ULONG cbPABEID, cbWABEID;
    LPENTRYID lpPABEID = NULL;
    ULONG ulObjType;
    ULONG_PTR ulUIParam = (ULONG_PTR)(void *)hwnd;
    SRestriction restrictObjectType;
    SPropValue spvObjectType;
    ULONG cProps;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];

    WAB_PARAM wp = {0};
    LPWAB_PARAM lpwp = NULL;


    //
    // Logon to MAPI and open the MAPI Address book, if one exists
    //
    DebugTrace(">>> STATE_IMPORT_MU\n");

    SetDialogMessage(hwnd, IDS_STATE_LOGGING_IN);

    if (FAILED(hResult = MAPIInitialize(NULL))) {
        DebugTrace("MAPIInitialize -> %x\n", GetScode(hResult));
        switch (GetScode(hResult)) {
            case MAPI_E_NOT_ENOUGH_MEMORY:
                SetDialogMessage(hwnd, IDS_ERROR_NOT_ENOUGH_MEMORY);
                break;
            case MAPI_E_NOT_ENOUGH_DISK:
                SetDialogMessage(hwnd, IDS_ERROR_NOT_ENOUGH_DISK);
                break;

            default:
            case MAPI_E_NOT_FOUND:
            case MAPI_E_NOT_INITIALIZED:
                SetDialogMessage(hwnd, IDS_ERROR_MAPI_DLL_NOT_FOUND);
                break;
        }
#ifdef OLD_STUFF
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);    // hide progress bar
#endif // OLD_STUFF
        fError = TRUE;
        hResult = hrSuccess;
        goto exit;
    }

    ulFlags = MAPI_LOGON_UI | MAPI_NO_MAIL | MAPI_EXTENDED;

    if (FAILED(hResult = MAPILogonEx(ulUIParam,
      NULL,
      NULL,
      ulFlags,
      (LPMAPISESSION FAR *)&lpMAPISession))) {
        DebugTrace("MAPILogonEx -> %x\n", GetScode(hResult));
        switch (GetScode(hResult)) {
            case MAPI_E_USER_CANCEL:
                SetDialogMessage(hwnd, IDS_STATE_IMPORT_IDLE);
                break;
            case MAPI_E_NOT_INITIALIZED:
                SetDialogMessage(hwnd, IDS_ERROR_MAPI_DLL_NOT_FOUND);
                break;
            default:
                SetDialogMessage(hwnd, IDS_ERROR_MAPI_LOGON);
                break;
        }
#ifdef OLD_STUFF
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);    // hide progress bar
#endif // OLD_STUFF
        fError = TRUE;
        hResult = hrSuccess;
        goto exit;
    }

    if (hResult = lpMAPISession->lpVtbl->OpenAddressBook(lpMAPISession, (ULONG_PTR)(void *)hwnd,
      NULL,
      0,
      &lpAdrBookMAPI)) {
        DebugTrace("OpenAddressBook(MAPI) -> %x", GetScode(hResult));
        if(FAILED(hResult)) {
            goto exit;
        }
    }

    if (! lpAdrBookMAPI) {
        DebugTrace("MAPILogonEx didn't return a valid AdrBook object\n");
        goto exit;
    }

    //
    // Open the MAPI PAB container
    //
    // [PaulHi] Raid #63578 1/7/98
    // Correctly check return code and provide user error message if
    // Exchange PAB cannot be opened.
    //
    hResult = lpAdrBookMAPI->lpVtbl->GetPAB(lpAdrBookMAPI,
      &cbPABEID,
      &lpPABEID);
    if (HR_FAILED(hResult))
    {
        DebugTrace("MAPI GetPAB -> %x\n", GetScode(hResult));
        goto exit;
    }
    hResult = lpAdrBookMAPI->lpVtbl->OpenEntry(lpAdrBookMAPI,
        cbPABEID,     // size of EntryID to open
        lpPABEID,     // EntryID to open
        NULL,         // interface
        0,            // flags
        &ulObjType,
        (LPUNKNOWN *)&lpContainerMAPI);
    if (HR_FAILED(hResult))
    {
        DebugTrace("MAPI OpenEntry(PAB) -> %x\n", GetScode(hResult));
        goto exit;
    }

    Assert(lpAdrBookWAB);

    //
    // Open the WAB's PAB container: fills global lpCreateEIDsWAB
    //
    if (hResult = LoadWABEIDs(lpAdrBookWAB, &lpContainerWAB)) {
        goto exit;
    }
    HrLoadPrivateWABPropsForCSV(lpAdrBookWAB);

    //
    // All set... now loop through the PAB's entries, copying them to WAB
    //
    if (HR_FAILED(hResult = lpContainerMAPI->lpVtbl->GetContentsTable(lpContainerMAPI,
      0,    // ulFlags
      &lpContentsTableMAPI))) {
        DebugTrace("MAPI GetContentsTable(PAB Table) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Set the columns to those we're interested in
    if (hResult = lpContentsTableMAPI->lpVtbl->SetColumns(lpContentsTableMAPI,
      (LPSPropTagArray)&ptaColumns,
      0)) {
        DebugTrace("MAPI SetColumns(PAB Table) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Restrict the table to MAPI_MAILUSERs
    // If the convenient depth flag was not specified we restrict on
    // PR_DEPTH == 1.
    spvObjectType.ulPropTag = PR_OBJECT_TYPE;
    spvObjectType.Value.l = MAPI_MAILUSER;

    restrictObjectType.rt = RES_PROPERTY;
    restrictObjectType.res.resProperty.relop = RELOP_EQ;
    restrictObjectType.res.resProperty.ulPropTag = PR_OBJECT_TYPE;
    restrictObjectType.res.resProperty.lpProp = &spvObjectType;

    if (HR_FAILED(hResult = lpContentsTableMAPI->lpVtbl->Restrict(lpContentsTableMAPI,
      &restrictObjectType,
      0))) {
        DebugTrace("MAPI Restrict (MAPI_MAILUSER) -> %x\n", GetScode(hResult));
        goto exit;
    }
    SetDialogMessage(hwnd, IDS_STATE_IMPORT_MU);


    // Initialize the Progress Bar
    // How many MailUser entries are there?
    ulcEntries = CountRows(lpContentsTableMAPI, TRUE);
    ulcDone = 0;

    DebugTrace("PAB contains %u MailUser entries\n", ulcEntries);

    SetDialogProgress(hwnd, ulcEntries, 0);

exit:
    if (lpPABEID) {
        MAPIFreeBuffer(lpPABEID);
    }

    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult))
    {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL)
        {
            NewState(hwnd, STATE_IMPORT_CANCEL);
        }
        else
        {
            // [PaulHi] 1/7/98  Error reporting is hosed
            // Display error message here to the user to ensure they
            // get it.
            {
                TCHAR   tszBuffer[MAX_RESOURCE_STRING];
                TCHAR   tszBufferTitle[MAX_RESOURCE_STRING];

                if ( !LoadString(hInst, IDS_STATE_IMPORT_ERROR_NOPAB, tszBuffer, MAX_RESOURCE_STRING-1) )
                {
                    Assert(0);
                    tszBuffer[0] = '\0';
                }

                if ( !LoadString(hInst, IDS_APP_TITLE, tszBufferTitle, MAX_RESOURCE_STRING-1) )
                {
                    Assert(0);
                    tszBufferTitle[0] = '\0';
                }
                MessageBox(hwnd, tszBuffer, tszBufferTitle, MB_ICONEXCLAMATION | MB_OK);
            }
            
            NewState(hwnd, STATE_IMPORT_ERROR);
        }
    }
    else if (fError)
    {
        NewState(hwnd, STATE_IMPORT_FINISH);      // must be logon error
    }
    else
    {
        NewState(hwnd, STATE_IMPORT_NEXT_MU);
    }
}


/***************************************************************************

    Name      : StateImportNextMU

    Purpose   : Migrate the next MailUser object

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : QueryRows on the global MAPI contents table
                if there was a row
                    Migrate the entry to the WAB
                    Re-post STATE_NEXT_MU
                else
                    Post STATE_IMPORT_DL

***************************************************************************/
void StateImportNextMU(HWND hwnd) {
    ULONG cRows = 0;
    HRESULT hResult;
    LPSRowSet lpRow = NULL;


    DebugTrace(">>> STATE_NEXT_MU\n");

    // Get the next PAB entry
    if (hResult = lpContentsTableMAPI->lpVtbl->QueryRows(lpContentsTableMAPI,
      1,    // one row at a time
      0,    // ulFlags
      &lpRow)) {
        DebugTrace("QueryRows -> %x\n", GetScode(hResult));
        goto exit;
    }

    if (lpRow) {
        if (cRows = lpRow->cRows) { // Yes, single '='
            Assert(lpRow->cRows == 1);
            Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

            if (cRows = lpRow->cRows) { // yes, single '='
                hResult = ImportEntry(hwnd,
                  lpAdrBookMAPI,
                  lpContainerWAB,
                  lpCreateEIDsWAB,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].Value.l,
                  (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                  NULL,
                  NULL,
                  FALSE,
                  FALSE);
                // Update Progress Bar
                // ignore errors!

                SetDialogProgress(hwnd, ulcEntries, ++ulcDone);

                if (hResult) {
                    if (HandleImportError(hwnd,
                      0,
                      hResult,
                      lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ,
                      PropStringOrNULL(&lpRow->aRow[0].lpProps[iptaColumnsPR_EMAIL_ADDRESS]),
                      lpImportOptions)) {
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                    } else {
                        hResult = hrSuccess;
                    }
                }
            } // else, drop out of loop, we're done.
        }
        FreeProws(lpRow);
    }

exit:
    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult)) {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL) {
            NewState(hwnd, STATE_IMPORT_CANCEL);
        } else {
            NewState(hwnd, STATE_IMPORT_ERROR);
        }
    } else {
        if (cRows) {
            NewState(hwnd, STATE_IMPORT_NEXT_MU);
        } else {
            NewState(hwnd, STATE_IMPORT_DL);
        }
    }
}


/***************************************************************************

    Name      : StateImportDL

    Purpose   : Start migration of DISTLIST objects

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Set a new restriction on the contents table, selecting
                DISTLIST objects only.
                Post STATE_NEXT_DL

***************************************************************************/
void StateImportDL(HWND hwnd) {
    HRESULT hResult;
    SRestriction restrictObjectType;
    SPropValue spvObjectType;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];


    DebugTrace(">>> STATE_IMPORT_DL\n");

    // Restrict the table to MAPI_MAILUSERs
    // If the convenient depth flag was not specified we restrict on
    // PR_DEPTH == 1.
    spvObjectType.ulPropTag = PR_OBJECT_TYPE;
    spvObjectType.Value.l = MAPI_DISTLIST;

    restrictObjectType.rt = RES_PROPERTY;
    restrictObjectType.res.resProperty.relop = RELOP_EQ;
    restrictObjectType.res.resProperty.ulPropTag = PR_OBJECT_TYPE;
    restrictObjectType.res.resProperty.lpProp = &spvObjectType;

    if (HR_FAILED(hResult = lpContentsTableMAPI->lpVtbl->Restrict(lpContentsTableMAPI,
      &restrictObjectType,
      0))) {
        DebugTrace("MAPI Restrict (MAPI_DISTLIST) -> %x\n", GetScode(hResult));
        goto exit;
    }
    // Restrict resets the current position to the beginning of the table, by definition.

    SetDialogMessage(hwnd, IDS_STATE_IMPORT_DL);

    // Initialize the Progress Bar
    // How many entries are there?

    ulcEntries = CountRows(lpContentsTableMAPI, TRUE);
    ulcDone = 0;

    DebugTrace("PAB contains %u Distribution List entries\n", ulcEntries);
    if (ulcEntries) {
        SetDialogProgress(hwnd, ulcEntries, 0);
    }
exit:
    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult)) {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL) {
            NewState(hwnd, STATE_IMPORT_CANCEL);
        } else {
            NewState(hwnd, STATE_IMPORT_ERROR);
        }
    } else {
        NewState(hwnd, STATE_IMPORT_NEXT_DL);
    }
}


/***************************************************************************

    Name      : StateImportNextDL

    Purpose   : Migrate the next DISTLIST object

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : QueryRows on the global MAPI contents table
                if there was a row
                    Migrate the DistList to the WAB
                    Re-post STATE_NEXT_DL
                else
                    Post STATE_FINISH

***************************************************************************/
void StateImportNextDL(HWND hwnd) {
    ULONG cRows = 0;
    HRESULT hResult;
    LPSRowSet lpRow = NULL;


    DebugTrace(">>> STATE_NEXT_DL\n");

    // Get the next PAB entry
    if (hResult = lpContentsTableMAPI->lpVtbl->QueryRows(lpContentsTableMAPI,
      1,    // one row at a time
      0,    // ulFlags
      &lpRow)) {
        DebugTrace("QueryRows -> %x\n", GetScode(hResult));
        goto exit;
    }

    if (lpRow) {
        if (cRows = lpRow->cRows) { // Yes, single '='
            Assert(lpRow->cRows == 1);
            Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

            if (cRows = lpRow->cRows) { // yes, single '='
                hResult = ImportEntry(hwnd,
                  lpAdrBookMAPI,
                  lpContainerWAB,
                  lpCreateEIDsWAB,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].Value.l,
                  (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                  NULL,
                  NULL,
                  FALSE,
                  FALSE);

                // Update Progress Bar
                SetDialogProgress(hwnd, ulcEntries, ++ulcDone);

                if (hResult) {
                    if (HandleImportError(hwnd,
                      0,
                      hResult,
                      lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ,
                      PropStringOrNULL(&lpRow->aRow[0].lpProps[iptaColumnsPR_EMAIL_ADDRESS]),
                      lpImportOptions)) {
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                    } else {
                        hResult = hrSuccess;
                    }
                }
            } // else, drop out of loop, we're done.
        }
        FreeProws(lpRow);
    }

exit:
    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult)) {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL) {
            NewState(hwnd, STATE_IMPORT_CANCEL);
        } else {
            NewState(hwnd, STATE_IMPORT_ERROR);
        }
    } else {
        if (cRows) {
            NewState(hwnd, STATE_IMPORT_NEXT_DL);
        } else {
            // Update Progress Bar to indicate completion
            SetDialogProgress(hwnd, ulcEntries, ulcEntries);
            NewState(hwnd, STATE_IMPORT_FINISH);
        }
    }
}


/***************************************************************************

    Name      : StateImportFinish

    Purpose   : Clean up after the migration process

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Clean up the global MAPI objects and buffers
                Clean up the global WAB objects and buffers.
                Re-enable the Import button on the UI.

***************************************************************************/
void StateImportFinish(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    TCHAR szBufferTitle[MAX_RESOURCE_STRING + 1];


    DebugTrace(">>> STATE_FINISH\n");

    //
    // Cleanup MAPI
    //
    if (lpContentsTableMAPI) {
        lpContentsTableMAPI->lpVtbl->Release(lpContentsTableMAPI);
        lpContentsTableMAPI = NULL;
    }

    if (lpContainerMAPI) {
        lpContainerMAPI->lpVtbl->Release(lpContainerMAPI);
        lpContainerMAPI = NULL;
    }

    if (lpAdrBookMAPI) {
        lpAdrBookMAPI->lpVtbl->Release(lpAdrBookMAPI);
        lpAdrBookMAPI = NULL;
    }

    if(lpMAPISession){
        lpMAPISession->lpVtbl->Logoff(lpMAPISession, (ULONG_PTR)(void *)hwnd,
          MAPI_LOGOFF_UI,
          0);

        lpMAPISession->lpVtbl->Release(lpMAPISession);
        lpMAPISession = NULL;
    }

    //
    // Cleanup the WAB
    //
    if (lpCreateEIDsWAB) {
        WABFreeBuffer(lpCreateEIDsWAB);
        lpCreateEIDsWAB = NULL;
    }

    if (lpContainerWAB) {
        lpContainerWAB->lpVtbl->Release(lpContainerWAB);
        lpContainerWAB = NULL;
    }

#ifdef OLD_STUFF        // Don't release the WABObject or AdrBook object.  They
                        // were passed in.
    if (lpAdrBookWAB) {
        lpAdrBookWAB->lpVtbl->Release(lpAdrBookWAB);
        lpAdrBookWAB = NULL;
    }

    if (lpWABObject) {
        lpWABObject->lpVtbl->Release(lpWABObject);
        lpWABObject = NULL;
    }
#endif // OLD_STUFF

    // Cleanup the cache
    FreeSeenList();

    if (! fError) {     // Leave error state displayed
        if (LoadString(hInst, IDS_STATE_IMPORT_COMPLETE, szBuffer, sizeof(szBuffer))) {
            DebugTrace("Status Message: %s\n", szBuffer);
            SetDlgItemText(hwnd, IDC_Message, szBuffer);

            if (! LoadString(hInst, IDS_APP_TITLE, szBufferTitle, sizeof(szBufferTitle))) {
                lstrcpy(szBufferTitle, "");
            }

#ifdef OLD_STUFF
            // Display a dialog telling user it's over
            MessageBox(hwnd, szBuffer,
              szBufferTitle, MB_ICONINFORMATION | MB_OK);
#endif // OLD_STUFF
        }
#ifdef OLD_STUFF
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);
#endif // OLD_STUFF
    }
    fError = FALSE;

    // Re-enable the Import button here.
    EnableWindow(GetDlgItem(hwnd, IDC_Import), TRUE);
    // Change the Cancel button to Close
    if (LoadString(hInst, IDS_BUTTON_CLOSE, szBuffer, sizeof(szBuffer))) {
        SetDlgItemText(hwnd, IDCANCEL, szBuffer);
    }
}


/***************************************************************************

    Name      : StateImportError

    Purpose   : Report fatal error and cleanup.

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Report error and post STATE_FINISH.

***************************************************************************/
void StateImportError(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace(">>> STATE_ERROR\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_IMPORT_ERROR);

    NewState(hwnd, STATE_IMPORT_FINISH);
}


/***************************************************************************

    Name      : StateImportCancel

    Purpose   : Report cancel error and cleanup.

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Report error and post STATE_FINISH.

***************************************************************************/
void StateImportCancel(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace(">>> STATE_CANCEL\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_IMPORT_CANCEL);

    NewState(hwnd, STATE_IMPORT_FINISH);
}


/***************************************************************************

    Name      : HrFilterImportMailUserProps

    Purpose   : Filters out undesirable properties from the property array.
                Converts known email address types to SMTP.
                Moves FAX address to PR_BUSINESS_FAX_NUMBER.

    Parameters: lpcProps -> IN: Input number of properties
                            OUT: Output number of properties
                lppProps -> IN: Input property array (MAPI allocation)
                            OUT: Output property array (WAB allocation)
                lpObjectMAPI -> MAPI object (used to get extra props)
                lpfDL -> flag to set FALSE if we change a DL to a MAILUSER
                         (ie, for an EXchange DL)

    Returns   : HRESULT

    Comment   : Setting the property tag in the array to PR_NULL effectively
                nulls this property out.  We can re-use these in the second
                pass.

                Caller should use WABFreeBuffer to free *lppProps.
                This routine will free the input value of *lppProps.

***************************************************************************/
HRESULT HrFilterImportMailUserProps(LPULONG lpcProps, LPSPropValue * lppProps,
  LPMAPIPROP lpObjectMAPI, LPBOOL lpfDL) {
    HRESULT hResult = hrSuccess;
    ULONG i;
    LPSPropValue lpPropsMAPI = *lppProps, lpPropsWAB = NULL;
    ULONG cbProps;
    SCODE sc;
    ULONG cProps = *lpcProps;
    ULONG iPR_ADDRTYPE = NOT_FOUND;
    ULONG iPR_EMAIL_ADDRESS = NOT_FOUND;
    ULONG iPR_PRIMARY_FAX_NUMBER = NOT_FOUND;
    ULONG iPR_BUSINESS_FAX_NUMBER = NOT_FOUND;
    ULONG iPR_MSNINET_DOMAIN = NOT_FOUND;
    ULONG iPR_MSNINET_ADDRESS = NOT_FOUND;
    ULONG iPR_DISPLAY_NAME = NOT_FOUND;
    ULONG iPR_OBJECT_TYPE = NOT_FOUND;
    LPSBinary lpEntryID = NULL;
    LPTSTR lpTemp;
    BOOL fBadAddress = FALSE;
    ULONG cbDisplayName;
    LPTSTR lpDisplayName = NULL;


//    MAPIDebugProperties(lpPropsMAPI, *lpcProps, "MailUser BEFORE");

    // First pass: Remove the junk
    for (i = 0; i < cProps; i++) {
        // Error value
        if (PROP_ERROR(lpPropsMAPI[i])) {
            lpPropsMAPI[i].ulPropTag = PR_NULL;
            continue;
        }

        // Named property
        if (PROP_ID(lpPropsMAPI[i].ulPropTag) >= MIN_NAMED_PROPID) {
            lpPropsMAPI[i].ulPropTag = PR_NULL;
            continue;
        }

        // Object property
        if (PROP_TYPE(lpPropsMAPI[i].ulPropTag) == PT_OBJECT) {
            lpPropsMAPI[i].ulPropTag = PR_NULL;
            continue;
        }
        switch (lpPropsMAPI[i].ulPropTag) {
            case PR_ENTRYID:
                lpEntryID = &lpPropsMAPI[i].Value.bin;
                // fall through

            case PR_PRIMARY_CAPABILITY:
            case PR_TEMPLATEID:
            case PR_SEARCH_KEY:
            case PR_INITIAL_DETAILS_PANE:
            case PR_RECORD_KEY:
            case PR_MAPPING_SIGNATURE:
                lpPropsMAPI[i].ulPropTag = PR_NULL;
                break;

            case PR_COMMENT:
                // Don't save PR_COMMENT if it is empty
                if (lstrlen(lpPropsMAPI[i].Value.LPSZ) == 0) {
                    lpPropsMAPI[i].ulPropTag = PR_NULL;
                }
                break;

            // Keep track of the position of these for later
            case PR_ADDRTYPE:
                iPR_ADDRTYPE = i;
                break;
            case PR_OBJECT_TYPE:
                iPR_OBJECT_TYPE = i;
                break;
            case PR_EMAIL_ADDRESS:
                iPR_EMAIL_ADDRESS = i;
                break;
            case PR_PRIMARY_FAX_NUMBER:
                iPR_PRIMARY_FAX_NUMBER = i;
                break;
            case PR_BUSINESS_FAX_NUMBER:
                iPR_BUSINESS_FAX_NUMBER = i;
                break;
            case PR_MSNINET_ADDRESS:
                iPR_MSNINET_ADDRESS = i;
                break;
            case PR_MSNINET_DOMAIN:
                iPR_MSNINET_DOMAIN = i;
                break;
            case PR_DISPLAY_NAME:
                iPR_DISPLAY_NAME = i;

                // Make sure it isn't quoted.
                lpDisplayName = lpPropsMAPI[i].Value.LPSZ;
                if (lpDisplayName[0] == '\'') {
                    cbDisplayName = lstrlen(lpDisplayName);
                    if ((cbDisplayName > 1) && lpDisplayName[cbDisplayName - 1] == '\'') {
                        // String is surrounded by apostrophes.  Strip them.
                        lpDisplayName[cbDisplayName - 1] = '\0';
                        lpDisplayName++;
                        lpPropsMAPI[i].Value.LPSZ = lpDisplayName;
                    }
                } else {
                    if (lpDisplayName[0] == '"') {
                        cbDisplayName = lstrlen(lpDisplayName);
                        if ((cbDisplayName > 1) && lpDisplayName[cbDisplayName - 1] == '"') {
                            // String is surrounded by quotes.  Strip them.
                            lpDisplayName[cbDisplayName - 1] = '\0';
                            lpDisplayName++;
                            lpPropsMAPI[i].Value.LPSZ = lpDisplayName;
                        }
                    }
                }
                break;
        }

        // Put this after the switch since we do want to track a few props which fall in
        // the 0x6000 range but don't want to transfer them to the wab.
        if (PROP_ID(lpPropsMAPI[i].ulPropTag) >= MAX_SCHEMA_PROPID) {
            lpPropsMAPI[i].ulPropTag = PR_NULL;
            continue;
        }
    }


    // Second pass: Fix up the addresses
    if (iPR_ADDRTYPE != NOT_FOUND) {
        if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szFAX)) {
            DebugTrace("FAX address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);

            //
            // Handle MS-FAX Address conversion
            //
            if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                // Rename the PR_EMAIL_ADDRESS to PR_BUSINESS_FAX_NUMBER
                lpPropsMAPI[iPR_EMAIL_ADDRESS].ulPropTag = PR_BUSINESS_FAX_NUMBER;

                // Get rid of any existing PR_BUSINESS_FAX_NUMBER
                if (iPR_BUSINESS_FAX_NUMBER != NOT_FOUND) {
                    lpPropsMAPI[iPR_BUSINESS_FAX_NUMBER].ulPropTag = PR_NULL;
                    iPR_BUSINESS_FAX_NUMBER = NOT_FOUND;
                }
            }
            // Nuke ADDRTYPE
            lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;

        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szMSN)) {
            DebugTrace("MSN address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
            //
            // Handle MSN Address conversion
            //
            if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                // Allocate a new, longer string
                if (FAILED(sc = MAPIAllocateMore(
                  lstrlen(lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ) + 1 + cbMSNpostfix,
                  lpPropsMAPI,
                  &lpTemp))) {

                    DebugTrace("HrFilterImportMailUserProps:MAPIAllocateMore -> %x\n", sc);
                    hResult = ResultFromScode(sc);
                    goto exit;
                }

                // append the msn site
                lstrcpy(lpTemp, lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ);
                lstrcat(lpTemp, szMSNpostfix);
                lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ = lpTemp;

                // Convert MSN addrtype to SMTP
                lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ = (LPTSTR)szSMTP;

            } else {
                // No address, nuke ADDRTYPE
                lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;
            }

        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szCOMPUSERVE)) {
            DebugTrace("COMPUSERVE address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
            //
            // Handle COMPUSERVE Address conversion
            //
            if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                // Allocate a new, longer string
                if (FAILED(sc = MAPIAllocateMore(
                  lstrlen(lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ) + 1 + cbCOMPUSERVEpostfix,
                  lpPropsMAPI,
                  &lpTemp))) {

                    DebugTrace("HrFilterImportMailUserProps:MAPIAllocateMore -> %x\n", sc);
                    hResult = ResultFromScode(sc);
                    goto exit;
                }

                // append the Compuserve site
                lstrcpy(lpTemp, lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ);
                lstrcat(lpTemp, szCOMPUSERVEpostfix);
                lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ = lpTemp;

                // I need to convert the ',' to a '.'
                while (*lpTemp) {
                    if (*lpTemp == ',') {
                        *lpTemp = '.';
                        break;          // should only be one comma
                    }
                    lpTemp = CharNext(lpTemp);
                }

                // Convert COMPUSERVE addrtype to SMTP
                lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ = (LPTSTR)szSMTP;

            } else {
                // No address, nuke ADDRTYPE
                lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;
            }

        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szMSNINET)) {
            DebugTrace("MSINET address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
            //
            // Handle MSN Internet address conversion.  These are weird.
            // They often don't fill in the PR_EMAIL_ADDRESS at all, but do fill
            // in some private properties: 6001 and 6002 with the name and domain,
            // respectively.  We should take these and append them with the '@' to
            // get our PR_EMAIL_ADDRESS.  We will toss out any existing
            // PR_EMAIL_ADDRESS in favor of these values.
            //
            // Allocate a new string
            //
            if ((iPR_MSNINET_ADDRESS  != NOT_FOUND) && (iPR_MSNINET_DOMAIN != NOT_FOUND)) {
                if (FAILED(sc = MAPIAllocateMore(
                  lstrlen(lpPropsMAPI[iPR_MSNINET_ADDRESS].Value.LPSZ) + cbAtSign +
                  lstrlen(lpPropsMAPI[iPR_MSNINET_DOMAIN].Value.LPSZ) + 1,
                  lpPropsMAPI,
                  &lpTemp))) {
                    DebugTrace("HrFilterImportMailUserProps:MAPIAllocateMore -> %x\n", sc);
                    hResult = ResultFromScode(sc);
                    goto exit;
                }

                // Build the address
                lstrcpy(lpTemp, lpPropsMAPI[iPR_MSNINET_ADDRESS].Value.LPSZ);
                lstrcat(lpTemp, szAtSign);
                lstrcat(lpTemp, lpPropsMAPI[iPR_MSNINET_DOMAIN].Value.LPSZ);
                lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ = lpTemp;

                // Convert addrtype to SMTP
                lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ = (LPTSTR)szSMTP;
            } else if (iPR_EMAIL_ADDRESS && lstrlen(lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ)) {
                // keep existing PR_EMAIL_ADDRES and assume it's ok
                lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ = (LPTSTR)szSMTP;
            } else {
                // No address, nuke ADDRTYPE
                lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;
            }

        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szMS)) {
            DebugTrace("MS address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
            // No SMTP form of a MSMail address.  destroy it.
            if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                lpPropsMAPI[iPR_EMAIL_ADDRESS].ulPropTag = PR_NULL;
                fBadAddress = TRUE;
            }
            lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;

        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szX400)) {
            DebugTrace("X400 address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
            // No SMTP form of a X400 address.  destroy it.
            if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                lpPropsMAPI[iPR_EMAIL_ADDRESS].ulPropTag = PR_NULL;
                fBadAddress = TRUE;
            }
            lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;

        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szMSA)) {
            DebugTrace("MacMail address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
            //  No SMTP form of a MacMail address. destroy it.
            if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                lpPropsMAPI[iPR_EMAIL_ADDRESS].ulPropTag = PR_NULL;
                fBadAddress = TRUE;
            }
            lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;

        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szEX)) {
            DebugTrace("EX address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);

            if (lpTemp = GetEMSSMTPAddress(lpObjectMAPI, lpPropsMAPI)) {

                lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ = lpTemp;

                // Convert addrtype to SMTP
                lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ = (LPTSTR)szSMTP;

                // Make sure that caller doesn't think this is a Personal DL.
                *lpfDL = FALSE;
                if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                    lpPropsMAPI[iPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
                    lpPropsMAPI[iPR_OBJECT_TYPE].Value.l = MAPI_MAILUSER;
                }

            } else {
                if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                    lpPropsMAPI[iPR_EMAIL_ADDRESS].ulPropTag = PR_NULL;
                    fBadAddress = TRUE;
                }
                lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;
            }


        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szSMTP)) {
            DebugTrace("SMTP address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szMAPIPDL)) {
            DebugTrace("MAPIPDL %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
            // Distribution list, ignore it.
        } else {
            MAPIDebugProperties(lpPropsMAPI, cProps, "Unknown address type");
            DebugTrace("Found unknown PR_ADDRTYPE: %s\n", lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ);
            Assert(FALSE);
        }
    }


    // PR_BUSINESS_FAX_NUMBER?
    // The PAB puts the Fax number in PR_PRIMARY_FAX_NUMBER, but the WAB UI splits it
    // into PR_BUSINESS_FAX_NUMBER and PR_HOME_FAX_NUMBER.  We always assume that the
    // Primary fax number is business.
    if ((iPR_PRIMARY_FAX_NUMBER != NOT_FOUND) && (iPR_BUSINESS_FAX_NUMBER == NOT_FOUND)) {
        // We need to also have a PR_BUSINESS_FAX_NUMBER
        // Find the next PR_NULL spot.
        iPR_BUSINESS_FAX_NUMBER = iPR_PRIMARY_FAX_NUMBER;   // overwrite this one if there isn't
                                                            // an available slot in the prop array.
        for (i = 0; i < cProps; i++) {
            if (lpPropsMAPI[i].ulPropTag == PR_NULL) {
                iPR_BUSINESS_FAX_NUMBER = i;
                lpPropsMAPI[iPR_BUSINESS_FAX_NUMBER].Value.LPSZ =
                  lpPropsMAPI[iPR_PRIMARY_FAX_NUMBER].Value.LPSZ;
                break;
            }
        }

        lpPropsMAPI[iPR_BUSINESS_FAX_NUMBER].ulPropTag = PR_BUSINESS_FAX_NUMBER;
    }


    // Get rid of PR_NULL props
    for (i = 0; i < cProps; i++) {
        if (lpPropsMAPI[i].ulPropTag == PR_NULL) {
            // Slide the props down.
            if (i + 1 < cProps) {       // Are there any higher props to copy?
                CopyMemory(&lpPropsMAPI[i], &lpPropsMAPI[i + 1], ((cProps - i) - 1) * sizeof(lpPropsMAPI[i]));
            }
            // decrement count
            cProps--;
            i--;    // You overwrote the current propval.  Look at it again.
        }
    }


    // Reallocate as WAB memory.
    if (sc = ScCountProps(cProps, lpPropsMAPI, &cbProps)) {
        hResult = ResultFromScode(sc);
        DebugTrace("ScCountProps -> %x\n", sc);
        goto exit;
    }

    if (sc = WABAllocateBuffer(cbProps, &lpPropsWAB)) {
        hResult = ResultFromScode(sc);
        DebugTrace("WABAllocateBuffer -> %x\n", sc);
        goto exit;
    }

    if (sc = ScCopyProps(cProps,
      lpPropsMAPI,
      lpPropsWAB,
      NULL)) {
        hResult = ResultFromScode(sc);
        DebugTrace("ScCopyProps -> %x\n", sc);
        goto exit;
    }

exit:
    if (lpPropsMAPI) {
        MAPIFreeBuffer(lpPropsMAPI);
    }

    if (HR_FAILED(hResult)) {
        if (lpPropsWAB) {
            WABFreeBuffer(lpPropsWAB);
            lpPropsWAB = NULL;
        }
        cProps = 0;
    } else if (fBadAddress) {
        hResult = ResultFromScode(WAB_W_BAD_EMAIL);
    }

    *lppProps = lpPropsWAB;
    *lpcProps = cProps;

    return(hResult);
}


/***************************************************************************

    Name      : HandleImportError

    Purpose   : Decides if a dialog needs to be displayed to
                indicate the failure and does so.

    Parameters: hwnd = main dialog window
                ids = String ID (optional: calculated from hResult if 0)
                hResult = Result of action
                lpDisplayName = display name of object that failed
                lpEmailAddress = email address of object that failed or NULL
                lpImportOptions -> import options structure

    Returns   : TRUE if user requests ABORT.

    Comment   : Abort is not yet implemented in the dialog, but if you
                ever want to, just make this routine return TRUE;

***************************************************************************/
BOOL HandleImportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_IMPORT_OPTIONS lpImportOptions) {
    BOOL fAbort = FALSE;
    ERROR_INFO EI;

    if ((ids || hResult) && ! lpImportOptions->fNoErrors) {
        if (ids == 0) {
            switch (GetScode(hResult)) {
                case WAB_W_BAD_EMAIL:
                    ids = lpEmailAddress ? IDS_ERROR_EMAIL_ADDRESS_2 : IDS_ERROR_EMAIL_ADDRESS_1;
                    break;

                case MAPI_E_NO_SUPPORT:
                    // Propbably failed to open contents on a distribution list
                    ids = IDS_ERROR_NO_SUPPORT;
                    break;

                case MAPI_E_USER_CANCEL:
                    return(TRUE);

                default:
                    if (HR_FAILED(hResult)) {
                        DebugTrace("Error Box for Hresult: 0x%08x\n", GetScode(hResult));
                        Assert(FALSE);      // want to know about it.
                        ids = IDS_ERROR_GENERAL;
                    }
                    break;
            }
        }

        EI.lpszDisplayName = lpDisplayName;
        EI.lpszEmailAddress = lpEmailAddress;
        EI.ErrorResult = ERROR_OK;
        EI.ids = ids;
        EI.fExport = FALSE;
        EI.lpImportOptions = lpImportOptions;

        DialogBoxParam(hInst,
          MAKEINTRESOURCE(IDD_ErrorImport),
          hwnd,
          ErrorDialogProc,
          (LPARAM)&EI);

        fAbort = EI.ErrorResult == ERROR_ABORT;
    }

    return(fAbort);
}


/***************************************************************************

    Name      : FindExistingWABEntry

    Purpose   : Finds an existing entry in the WAB

    Parameters: lpProps -> PropArray of MAPI entry
                cProps = number of props in lpProps
                lpContainerWAB -> WAB Container object
                lppEIDWAB -> returned EntryID (caller must WABFreeBuffer)
                lpcbEIDWAB -> returned size of lppEID

    Returns   : HRESULT

    Comment   : At this point, we expect to find a match since
                SaveChanges said we had a duplicate.

***************************************************************************/
HRESULT FindExistingWABEntry(LPSPropValue lpProps,
  ULONG cProps,
  LPABCONT lpContainerWAB,
  LPENTRYID * lppEIDWAB,
  LPULONG lpcbEIDWAB) {
    ULONG rgFlagList[2];
    LPFlagList lpFlagList = (LPFlagList)rgFlagList;
    LPADRLIST lpAdrListWAB = NULL;
    SCODE sc;
    HRESULT hResult = hrSuccess;
    LPSBinary lpsbEntryID = NULL;
    ULONG cbEID = 0;


    *lpcbEIDWAB = 0;
    *lppEIDWAB = NULL;


    // find the existing WAB entry.
    // Setup for ResolveNames on the WAB container.
    if (sc = WABAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), &lpAdrListWAB)) {
        DebugTrace("WAB Allocation(ADRLIST) failed -> %x\n", sc);
        hResult = ResultFromScode(sc);
        goto exit;
    }
    lpAdrListWAB->cEntries = 1;
    lpAdrListWAB->aEntries[0].ulReserved1 = 0;
    lpAdrListWAB->aEntries[0].cValues = 1;

    if (sc = WABAllocateBuffer(sizeof(SPropValue), &lpAdrListWAB->aEntries[0].rgPropVals)) {
        DebugTrace("WAB Allocation(ADRENTRY propval) failed -> %x\n", sc);
        hResult = ResultFromScode(sc);
        goto exit;
    }
    lpAdrListWAB->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    if (! (lpAdrListWAB->aEntries[0].rgPropVals[0].Value.LPSZ =
      FindStringInProps(lpProps, cProps, PR_DISPLAY_NAME))) {
        DebugTrace("Can't find PR_DISPLAY_NAME in entry\n");
        // pretty weird if this caused a collision...
        goto exit;
    }

    lpFlagList->cFlags = 1;
    lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

    if (HR_FAILED(hResult = lpContainerWAB->lpVtbl->ResolveNames(lpContainerWAB,
      NULL,            // tag set
      0,               // ulFlags
      lpAdrListWAB,
      lpFlagList))) {
        DebugTrace("WAB ResolveNames -> %x\n", GetScode(hResult));
        goto exit;
    }

    switch (lpFlagList->ulFlag[0]) {
        case MAPI_UNRESOLVED:
            DebugTrace("WAB ResolveNames didn't find the entry\n");
            hResult = ResultFromScode(MAPI_E_NOT_FOUND);
            goto exit;
        case MAPI_AMBIGUOUS:
#ifdef NEW_STUFF
            // Do it the hard way.  Open a table, restrict, take the first match.
            lpContainerWAB->lpVtbl->GetContentsTable(lpContainerWAB,

            if (HR_FAILED(hResult = lpContainerWAB->lpVtbl->GetContentsTable(lpContainerWAB,
              0,    // ulFlags
              &lpTableWAB))) {
                DebugTrace("ImportEntry:GetContentsTable(WAB) -> %x\n", GetScode(hResult));
                goto exit;
            }

            lpTableWAB->lpVtbl->Restrict....... // just the ones that match our entry...

            cRows = 1;
            while (cRows) {
                // Get the next DL entry
                if (hResult = lpTableWAB->lpVtbl->QueryRows(lpTableWAB,
                  1,    // one row at a time
                  0,    // ulFlags
                  &lpRow)) {
                    DebugTrace("DL: QueryRows -> %x\n", GetScode(hResult));
                    goto exit;
                }

                if (lpRow && lpRow->cRows) {
                    Assert(lpRow->cRows == 1);
                    Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
                    Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
                    Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

                } else {
                    break;  // done
                }
            }
#endif // NEW_STUFF
            break;
    }

    // Find the PR_ENTRYID
    if (! (lpsbEntryID = FindAdrEntryID(lpAdrListWAB, 0))) {
        DebugTrace("WAB ResolveNames didn't give us an EntryID\n");
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }

    *lpcbEIDWAB = lpsbEntryID->cb;

    if (FAILED(sc = WABAllocateBuffer(*lpcbEIDWAB, lppEIDWAB))) {
        DebugTrace("ImportEntry: WABAllocateBuffer(WAB ENTRYID) -> %x\n", sc);
        hResult = ResultFromScode(sc);
        *lpcbEIDWAB = 0;
        goto exit;
    }

    // Copy the new EntryID into the buffer
    CopyMemory(*lppEIDWAB, lpsbEntryID->lpb, *lpcbEIDWAB);
exit:
    if (lpAdrListWAB) {
        WABFreePadrlist(lpAdrListWAB);
    }

    return(hResult);
}


/****************************************************************************
*
* CheckReversedDisplayName(lpDisplayName);
*
* PAB and outlook display names are "LastName, FirstName"
* We need to reverse this for the WAB to handle it correctly ...
*
*
*****************************************************************************/
void CheckReversedDisplayName(LPTSTR lpDisplayName)
{
    TCHAR szTemp[MAX_PATH * 3];
    LPTSTR lp1=NULL, lp2=NULL;

    if(!lpDisplayName)
        return;

    lp1 = lp2 = lpDisplayName;

    while(lp1 && *lp1)
    {
        if(*lp1 == ',')
        {
            // A comma means this is Last, First
            // We will make an assumption here that "L, F" or "L,F" is longer than or equal to "F L" and so
            // we can reverse the name in place without any problems
            //
            lp2 = CharNext(lp1);
            //skip spaces
            while (IsSpace(lp2)) {
                lp2 = CharNext(lp2);
            }
            *lp1 = '\0';
            lstrcpy(szTemp, lpDisplayName);
            lstrcpy(lpDisplayName, lp2);
            lstrcat(lpDisplayName, TEXT(" "));
            lstrcat(lpDisplayName, szTemp);
            break;
        }
        lp1 = CharNext(lp1);
    }
    return;
}


/***************************************************************************

    Name      : ImportEntry

    Purpose   : Migrates the entry from the PAB to the WAB

    Parameters: hwnd = main dialog window
                lpAdrBookMAPI -> MAPI AdrBook object
                lpContainerWAB -> WAB PAB container
                lpCreateEIDsWAB -> SPropValue of default object creation EIDs
                ulObjectType = {MAPI_MAILUSER, MAPI_DISTLIST}
                lpEID -> ENTYRID of the PAB entry
                cbEID = sizeof lpEID
                lppEIDWAB -> returned WAB ENTRYID: Caller must WABFreeBuffer.
                  May be NULL.
                lpcbEIDWAB -> returned size of lppEIDWAB (ignored if lppEIDWAB
                  is NULL.
                fInDL = TRUE if this entry is for creation in a Distribution List
                fForceReplace = TRUE if this entry should replace any duplicate.

    Returns   : HRESULT

    Comment   : This routine is a MESS!  Should break it up when we get time.

***************************************************************************/
HRESULT ImportEntry(HWND hwnd,
  LPADRBOOK lpAdrBookMAPI,
  LPABCONT lpContainerWAB,
  LPSPropValue lpCreateEIDsWAB,
  ULONG ulObjectType,
  LPENTRYID lpEID,
  ULONG cbEID,
  LPENTRYID * lppEIDWAB,
  LPULONG lpcbEIDWAB,
  BOOL fInDL,
  BOOL fForceReplace) {
    HRESULT hResult = hrSuccess;
    SCODE sc;
    BOOL fDistList = FALSE;
    BOOL fDuplicate = FALSE;
    BOOL fDuplicateEID;
    BOOL fReturnEID = FALSE;
    ULONG ulObjectTypeOpen;
    LPDISTLIST lpDistListMAPI = NULL, lpDistListWAB = NULL;
    LPMAPIPROP lpMailUserMAPI = NULL, lpMailUserWAB = NULL;
    LPSPropValue lpProps = NULL;
    ULONG cProps, cEIDPropWAB;
    LPMAPITABLE lpDLTableMAPI = NULL;
    ULONG cRows;
    LPSRowSet lpRow = NULL;
    LPENTRYID lpeidDLWAB = NULL;
    ULONG cbeidDLWAB;
    LPSPropValue lpEIDPropWAB = NULL;
    LPMAPIPROP lpEntryWAB = NULL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    REPLACE_INFO RI;
    LPTSTR lpDisplayName = NULL, lpEmailAddress = NULL;
    static TCHAR szBufferDLMessage[MAX_RESOURCE_STRING + 1] = "";
    LPTSTR lpszMessage;
    LONG lListIndex = -1;
    LPENTRYID lpEIDNew = NULL;
    DWORD cbEIDNew = 0;
    LPIID lpIIDOpen;
    ULONG iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;


    // Check the entry against our "seen" list
    fDuplicateEID = AddEntryToImportList(cbEID, lpEID, &lListIndex);

    if (! fDuplicateEID) {
        if ((fForceReplace || (lpImportOptions->ReplaceOption == WAB_REPLACE_ALWAYS)) && ! fInDL) {
            ulCreateFlags |= CREATE_REPLACE;
        }

        // Set up some object type specific variables
        switch (ulObjectType) {
            default:
                DebugTrace("ImportEntry got unknown object type %u, assuming MailUser\n", ulObjectType);
                Assert(FALSE);

            case MAPI_MAILUSER:
                iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
                lpIIDOpen = NULL;
                fDistList = FALSE;
                break;

            case MAPI_DISTLIST:
                iCreateTemplate = iconPR_DEF_CREATE_DL;
                lpIIDOpen = (LPIID)&IID_IDistList;
                fDistList = TRUE;

                break;
        }


        // Open the entry
        if (HR_FAILED(hResult = lpAdrBookMAPI->lpVtbl->OpenEntry(lpAdrBookMAPI,
          cbEID,
          lpEID,
          lpIIDOpen,
          0,
          &ulObjectTypeOpen,
          (LPUNKNOWN *)&lpMailUserMAPI))) {
            DebugTrace("OpenEntry(MAPI MailUser) -> %x\n", GetScode(hResult));
            goto exit;
        }
        // If DISTLIST, assume we got lpMailUser until we need lpDistList.

        Assert(lpMailUserMAPI);
        Assert(ulObjectType == ulObjectTypeOpen);

        // Get the properties from this entry
        if (HR_FAILED(hResult = lpMailUserMAPI->lpVtbl->GetProps(lpMailUserMAPI,
          NULL,
          0,
          &cProps,
          &lpProps))) {
            DebugTrace("ImportEntry:GetProps(MAPI) -> %x\n", GetScode(hResult));
            goto exit;
        }

        //
        // NOTE: Must not fail between here and HrFilterImportMailUserProps because
        // we will end up freeing lpProps with WABFreeBuffer.
        //

        // Filter the property array here
        if (hResult = HrFilterImportMailUserProps(&cProps, &lpProps, lpMailUserMAPI, &fDistList)) {
            lpDisplayName = FindStringInProps(lpProps, cProps, PR_DISPLAY_NAME);
            lpEmailAddress = FindStringInProps(lpProps, cProps, PR_EMAIL_ADDRESS);

            if (HandleImportError(hwnd,
              0,
              hResult,
              lpDisplayName,
              lpEmailAddress,
              lpImportOptions)) {
                hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                goto exit;
            }
        }
        lpDisplayName = FindStringInProps(lpProps, cProps, PR_DISPLAY_NAME);
        lpEmailAddress = FindStringInProps(lpProps, cProps, PR_EMAIL_ADDRESS);

        CheckReversedDisplayName(lpDisplayName);

        if (ulObjectType == MAPI_DISTLIST && ! fDistList) {
            // Filter must have changed this to a mailuser.
            ulObjectType = MAPI_MAILUSER;
            iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
            lpIIDOpen = NULL;
        }

        //
        // NOTE: lpProps after this point is WAB Allocated rather than MAPI allocated.
        //

        if (HR_FAILED(hResult = lpContainerWAB->lpVtbl->CreateEntry(lpContainerWAB,
          lpCreateEIDsWAB[iCreateTemplate].Value.bin.cb,
          (LPENTRYID)lpCreateEIDsWAB[iCreateTemplate].Value.bin.lpb,
          ulCreateFlags,
          &lpMailUserWAB))) {
            DebugTrace("CreateEntry(WAB MailUser) -> %x\n", GetScode(hResult));
            goto exit;
        }

        if (fDistList) {
            // Update status message
            if (*szBufferDLMessage == '\0') {   // only load once, then keep it.
                LoadString(hInst, IDS_MESSAGE_IMPORTING_DL, szBufferDLMessage, sizeof(szBufferDLMessage));
            }
            if (lpDisplayName) {
                if (lpszMessage = LocalAlloc(LMEM_FIXED, lstrlen(szBufferDLMessage) + 1 + lstrlen(lpDisplayName))) {
                    wsprintf(lpszMessage, szBufferDLMessage, lpDisplayName);
                    DebugTrace("Status Message: %s\n", lpszMessage);
                    if (! SetDlgItemText(hwnd, IDC_Message, lpszMessage)) {
                        DebugTrace("SetDlgItemText -> %u\n", GetLastError());
                    }
                    LocalFree(lpszMessage);
                }
            }
        }


        // Set the properties on the WAB entry
        if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
          cProps,                   // cValues
          lpProps,                  // property array
          NULL))) {                 // problems array
            DebugTrace("ImportEntry:SetProps(WAB) -> %x\n", GetScode(hResult));
            goto exit;
        }


        // Save the new wab mailuser or distlist
        if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
          KEEP_OPEN_READONLY | FORCE_SAVE))) {

            if (GetScode(hResult) == MAPI_E_COLLISION) {
                // Find the display name
                if (! lpDisplayName) {
                    DebugTrace("Collision, but can't find PR_DISPLAY_NAME in entry\n");
                    goto exit;
                }

                // Do we need to prompt?
//                if (! fInDL && lpImportOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
                if (lpImportOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
                    // Prompt user with dialog.  If they say YES, we should
                    // recurse with the FORCE flag set.

                    RI.lpszDisplayName = lpDisplayName;
                    RI.lpszEmailAddress = lpEmailAddress;
                    RI.ConfirmResult = CONFIRM_ERROR;
                    RI.fExport = FALSE;
                    RI.lpImportOptions = lpImportOptions;

                    DialogBoxParam(hInst,
                      MAKEINTRESOURCE(IDD_ImportReplace),
                      hwnd,
                      ReplaceDialogProc,
                      (LPARAM)&RI);

                    switch(RI.ConfirmResult) {
                        case CONFIRM_YES:
                        case CONFIRM_YES_TO_ALL:
                            // YES
                            // NOTE: recursive Migrate will fill in the SeenList entry
                            hResult = ImportEntry(hwnd,
                              lpAdrBookMAPI,
                              lpContainerWAB,
                              lpCreateEIDsWAB,
                              ulObjectType,
                              lpEID,
                              cbEID,
                              &lpEIDNew,    // Need this for later
                              &cbEIDNew,
                              FALSE,
                              TRUE);
                            if (hResult) {
                                if (HandleImportError(hwnd,
                                  0,
                                  hResult,
                                  lpDisplayName,
                                  lpEmailAddress,
                                  lpImportOptions)) {
                                    hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                } else {
                                    hResult = hrSuccess;
                                }
                            }
                            break;

                        case CONFIRM_ABORT:
                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                            goto exit;

                        default:
                            // NO
                            fDuplicate = TRUE;
                            break;
                    }
                } else {
                        fDuplicate = TRUE;
                }

                hResult = hrSuccess;

            } else {
                DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
            }
        } else {
            // What is the ENTRYID of our new entry?
            if ((hResult = lpMailUserWAB->lpVtbl->GetProps(lpMailUserWAB,
              (LPSPropTagArray)&ptaEid,
              0,
              &cEIDPropWAB,
              &lpEIDPropWAB))) {
                DebugTrace("ImportEntry: GetProps(WAB ENTRYID) -> %x\n", GetScode(hResult));
                goto exit;
            }

            Assert(cEIDPropWAB);
            Assert(lpEIDPropWAB[ieidPR_ENTRYID].ulPropTag == PR_ENTRYID);

            cbEIDNew = lpEIDPropWAB[0].Value.bin.cb;

            if (FAILED(sc = WABAllocateBuffer(cbEIDNew, &lpEIDNew))) {
                DebugTrace("ImportEntry: WABAllocateBuffer(WAB ENTRYID) -> %x\n", sc);
                hResult = ResultFromScode(sc);
                goto exit;
            }

            // Copy the new EntryID into the buffer
            CopyMemory(lpEIDNew, lpEIDPropWAB[0].Value.bin.lpb, cbEIDNew);
        }


        //
        // If this is a DISTLIST, fill it in.
        //
        if (fDistList && ! fDuplicate && cbEIDNew) {
            lpDistListMAPI = (LPDISTLIST)lpMailUserMAPI;    // This is REALLY a DISTLIST object
            // DO NOT Release this!

            // Open the new WAB DL as a DISTLIST object
            if (HR_FAILED(hResult = lpContainerWAB->lpVtbl->OpenEntry(lpContainerWAB,
              cbEIDNew,
              lpEIDNew,
              (LPIID)&IID_IDistList,
              MAPI_MODIFY,
              &ulObjectTypeOpen,
              (LPUNKNOWN*)&lpDistListWAB))) {
                DebugTrace("ImportEntry: WAB OpenEntry(IID_DistList) -> %x\n", GetScode(hResult));
                goto exit;
            }
            Assert(lpDistListWAB);


            // For each entry in the DL:
            //  Migrate the entry (MailUser or DL) recursively
            //  Add new entryid to DL contents
            if (HR_FAILED(hResult = lpDistListMAPI->lpVtbl->GetContentsTable(lpDistListMAPI,
              0,    // ulFlags
              &lpDLTableMAPI ))) {
                DebugTrace("ImportEntry:GetContentsTable(MAPI) -> %x\n", GetScode(hResult));
                goto exit;
            }


            // Set the columns to those we're interested in
            if (hResult = lpDLTableMAPI->lpVtbl->SetColumns(lpDLTableMAPI,
              (LPSPropTagArray)&ptaColumns,
              0)) {
                DebugTrace("MAPI SetColumns(DL Table) -> %x\n", GetScode(hResult));
                goto exit;
            }

            cRows = 1;
            while (cRows) {
                // Get the next DL entry
                if (hResult = lpDLTableMAPI->lpVtbl->QueryRows(lpDLTableMAPI,
                  1,    // one row at a time
                  0,    // ulFlags
                  &lpRow)) {
                    DebugTrace("DL: QueryRows -> %x\n", GetScode(hResult));
                    goto exit;
                }

                if (lpRow && lpRow->cRows) {
                    Assert(lpRow->cRows == 1);
                    Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
                    Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
                    Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

                    if (lpRow) {
                        if (cRows = lpRow->cRows) { // yes, single '='
                            hResult = ImportEntry(hwnd,
                              lpAdrBookMAPI,
                              lpContainerWAB,
                              lpCreateEIDsWAB,
                              lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].Value.l,
                              (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb,
                              lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                              &lpeidDLWAB,        // returned new or existing entry
                              &cbeidDLWAB,
                              TRUE,
                              FALSE);
                            if (hResult) {
                                if (HandleImportError(hwnd,
                                  0,
                                  hResult,
                                  lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ,
                                  PropStringOrNULL(&lpRow->aRow[0].lpProps[iptaColumnsPR_EMAIL_ADDRESS]),
                                  lpImportOptions)) {
                                    hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                    break;  // out of loop
                                } else {
                                    hResult = hrSuccess;
                                }
                            }
                        } // else, drop out of loop, we're done.
                        FreeProws(lpRow);
                        lpRow = NULL;

                        if (HR_FAILED(hResult)) {
                            // This entry couldn't be created.  Ignore it.
                            DebugTrace("Coudln't create DL entry -> %x\n", GetScode(hResult));
                            hResult = hrSuccess;
                            continue;
                        }

                        // Add the Entry to the DL using the new entry's EntryID
                        if (cbeidDLWAB && lpeidDLWAB) {
                            // BUGBUG: Don't bother with this one if this is a duplicate entry.
                            if (HR_FAILED(hResult = lpDistListWAB->lpVtbl->CreateEntry(lpDistListWAB,
                              cbeidDLWAB,
                              lpeidDLWAB,
                              0,                // allow duplicates here
                              &lpEntryWAB))) {
                                DebugTrace("Couldn't create new entry in DL -> %x\n", GetScode(hResult));
                                break;
                            }

                            hResult = lpEntryWAB->lpVtbl->SaveChanges(lpEntryWAB, FORCE_SAVE);

                            if (lpEntryWAB) {
                                lpEntryWAB->lpVtbl->Release(lpEntryWAB);
                                lpEntryWAB = NULL;
                            }
                        }

                        if (lpeidDLWAB) {
                            WABFreeBuffer(lpeidDLWAB);
                            lpeidDLWAB = NULL;
                        }
                    }
                } else {
                    break;  // done
                }
            }
        }
    } else {
        DebugTrace("Found a duplicate EntryID\n");
    }

    //
    // Save the entryid to the list and return a buffer with it
    //
    if (cbEIDNew && lpEIDNew) {                         // We created one?
        // created one
    } else if (fDuplicateEID && lListIndex != -1) {     // Was it in the list?
        cbEIDNew  = lpEntriesSeen[lListIndex].sbinWAB.cb;
        if (FAILED(sc = WABAllocateBuffer(cbEIDNew, &lpEIDNew))) {
            DebugTrace("ImportEntry: WABAllocateBuffer(WAB ENTRYID) -> %x\n", sc);
            // ignore
            cbEIDNew = 0;
        } else {
            // Copy the EntryID from the list into the buffer
            CopyMemory(lpEIDNew, lpEntriesSeen[lListIndex].sbinWAB.lpb, cbEIDNew);
        }

    } else if (fDuplicate) {                            // Was it a duplicate
        FindExistingWABEntry(lpProps, cProps, lpContainerWAB, &lpEIDNew, &cbEIDNew);
        // ignore errors since the lpEIDNew and cbEIDNew will be nulled out
    }

    // Update the seen list
    if (! fDuplicateEID) {
        MarkWABEntryInList(cbEIDNew, lpEIDNew, lListIndex);
    }

    // If caller requested the entryid's, return them
    if (lpcbEIDWAB && lppEIDWAB) {
        *lpcbEIDWAB = cbEIDNew;
        *lppEIDWAB = lpEIDNew;
        fReturnEID = TRUE;          // don't free it
    }

exit:
    //
    // Cleanup WAB stuff
    //
    if (lpProps) {
        WABFreeBuffer(lpProps);
    }

    if (lpEIDPropWAB) {
        WABFreeBuffer(lpEIDPropWAB);
    }

    if (lpEIDNew && ! fReturnEID) {
        WABFreeBuffer(lpEIDNew);
    }

    if (lpeidDLWAB) {
        WABFreeBuffer(lpeidDLWAB);
    }

    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
    }

    if (lpDistListWAB) {
        lpDistListWAB->lpVtbl->Release(lpDistListWAB);
    }

    //
    // Cleanup MAPI stuff
    //
    if (lpRow) {
        FreeProws(lpRow);
    }

    if (lpDLTableMAPI) {
        lpDLTableMAPI->lpVtbl->Release(lpDLTableMAPI);
    }

    if (lpMailUserMAPI) {
        lpMailUserMAPI->lpVtbl->Release(lpMailUserMAPI);
    }

// Do not release this... It is the same object as lpMailUserMAPI!
//    if (lpDistListMAPI) {
//        lpDistListMAPI->lpVtbl->Release(lpDistListMAPI);
//    }

    if (! HR_FAILED(hResult)) {
        hResult = hrSuccess;
    }

    return(hResult);
}


/*
 *  PAB EXPORT
 *
 *  Migrate WAB to PAB
 */

BOOL HandleExportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_EXPORT_OPTIONS lpExportOptions);
void StateExportNextMU(HWND hwnd);
void StateExportDL(HWND hwnd);
void StateExportNextDL(HWND hwnd);
void StateExportFinish(HWND hwnd);
void StateExportMU(HWND hwnd);
void StateExportError(HWND hwnd);
void StateExportCancel(HWND hwnd);
HRESULT ExportEntry(HWND hwnd,
  LPADRBOOK lpAdrBookMAPI,
  LPABCONT lpContainerWAB,
  LPSPropValue lpCreateEIDsWAB,
  ULONG ulObjectType,
  LPENTRYID lpEID,
  ULONG cbEID,
  LPENTRYID * lppEIDWAB,
  LPULONG lpcbEIDWAB,
  BOOL fInDL,
  BOOL fForceReplace);

LPSPropTagArray lpspta = NULL;  // List of tags to export
LPTSTR * lppNames = NULL;       // List of names of tags


//
// Map property tags to strings
//

PROP_NAME rgPropNames[NUM_MORE_EXPORT_PROPS] = {
    //  ulPropTag,                          fChosen, ids,                                       lpszName    lpszName
    // Personal Pane
    PR_GIVEN_NAME,                          FALSE,  ids_ExportGivenName,                        NULL,       NULL,
    PR_SURNAME,                             FALSE,  ids_ExportSurname,                          NULL,       NULL,
    PR_MIDDLE_NAME,                         FALSE,  ids_ExportMiddleName,                       NULL,       NULL,
    PR_DISPLAY_NAME,                        TRUE,   ids_ExportDisplayName,                      NULL,       NULL,
    PR_NICKNAME,                            FALSE,  ids_ExportNickname,                         NULL,       NULL,
    PR_EMAIL_ADDRESS,                       TRUE,   ids_ExportEmailAddress,                     NULL,       NULL,

    // Home Pane
    PR_HOME_ADDRESS_STREET,                 TRUE,   ids_ExportHomeAddressStreet,                NULL,       NULL,
    PR_HOME_ADDRESS_CITY,                   TRUE,   ids_ExportHomeAddressCity,                  NULL,       NULL,
    PR_HOME_ADDRESS_POSTAL_CODE,            TRUE,   ids_ExportHomeAddressPostalCode,            NULL,       NULL,
    PR_HOME_ADDRESS_STATE_OR_PROVINCE,      TRUE,   ids_ExportHomeAddressState,                 NULL,       NULL,
    PR_HOME_ADDRESS_COUNTRY,                TRUE,   ids_ExportHomeAddressCountry,               NULL,       NULL,
    PR_HOME_TELEPHONE_NUMBER,               TRUE,   ids_ExportHomeTelephoneNumber,              NULL,       NULL,
    PR_HOME_FAX_NUMBER,                     FALSE,  ids_ExportHomeFaxNumber,                    NULL,       NULL,
    PR_CELLULAR_TELEPHONE_NUMBER,           FALSE,  ids_ExportCellularTelephoneNumber,          NULL,       NULL,
    PR_PERSONAL_HOME_PAGE,                  FALSE,  ids_ExportPersonalHomePage,                 NULL,       NULL,

    // Business Pane
    PR_BUSINESS_ADDRESS_STREET,             TRUE,   ids_ExportBusinessAddressStreet,            NULL,       NULL,
    PR_BUSINESS_ADDRESS_CITY,               TRUE,   ids_ExportBusinessAddressCity,              NULL,       NULL,
    PR_BUSINESS_ADDRESS_POSTAL_CODE,        TRUE,   ids_ExportBusinessAddressPostalCode,        NULL,       NULL,
    PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,  TRUE,   ids_ExportBusinessAddressStateOrProvince,   NULL,       NULL,
    PR_BUSINESS_ADDRESS_COUNTRY,            TRUE,   ids_ExportBusinessAddressCountry,           NULL,       NULL,
    PR_BUSINESS_HOME_PAGE,                  FALSE,  ids_ExportBusinessHomePage,                 NULL,       NULL,
    PR_BUSINESS_TELEPHONE_NUMBER,           TRUE,   ids_ExportBusinessTelephoneNumber,          NULL,       NULL,
    PR_BUSINESS_FAX_NUMBER,                 FALSE,  ids_ExportBusinessFaxNumber,                NULL,       NULL,
    PR_PAGER_TELEPHONE_NUMBER,              FALSE,  ids_ExportPagerTelephoneNumber,             NULL,       NULL,
    PR_COMPANY_NAME,                        TRUE,   ids_ExportCompanyName,                      NULL,       NULL,
    PR_TITLE,                               TRUE,   ids_ExportTitle,                            NULL,       NULL,
    PR_DEPARTMENT_NAME,                     FALSE,  ids_ExportDepartmentName,                   NULL,       NULL,
    PR_OFFICE_LOCATION,                     FALSE,  ids_ExportOfficeLocation,                   NULL,       NULL,

    // Notes Pane
    PR_COMMENT,                             FALSE,  ids_ExportComment,                          NULL,       NULL,
};


/***************************************************************************

    Name      : StateExportMU

    Purpose   : Start the migration of MailUsers

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Login to MAPI
                Open the WAB
                Open the MAPI AB
                Open the WAB container
                Get the WAB contents table
                Restrict it to PR_OBJECTTYPE == MAPI_MAILUSER
                Post new state(STATE_NEXT_MU)

***************************************************************************/
void StateExportMU(HWND hwnd) {
    HRESULT hResult;
    ULONG ulFlags;
    ULONG cbPABEID, cbWABEID;
    LPENTRYID lpPABEID = NULL, lpWABEID = NULL;
    ULONG ulObjType;
    ULONG_PTR ulUIParam = (ULONG_PTR)(void *)hwnd;
    SRestriction restrictObjectType;
    SPropValue spvObjectType;
    ULONG cProps;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    WAB_PARAM wp = {0};
    LPWAB_PARAM lpwp = NULL;

    //
    // Logon to MAPI and open the MAPI Address book, if one exists
    //
    DebugTrace(">>> STATE_EXPORT_MU\n");

    SetDialogMessage(hwnd, IDS_STATE_LOGGING_IN);

    if (FAILED(hResult = MAPIInitialize(NULL))) {
        DebugTrace("MAPIInitialize -> %x\n", GetScode(hResult));
        switch (GetScode(hResult)) {
            case MAPI_E_NOT_ENOUGH_MEMORY:
                SetDialogMessage(hwnd, IDS_ERROR_NOT_ENOUGH_MEMORY);
                break;
            case MAPI_E_NOT_ENOUGH_DISK:
                SetDialogMessage(hwnd, IDS_ERROR_NOT_ENOUGH_DISK);
                break;

            default:
            case MAPI_E_NOT_FOUND:
            case MAPI_E_NOT_INITIALIZED:
                SetDialogMessage(hwnd, IDS_ERROR_MAPI_DLL_NOT_FOUND);
                break;
        }
#ifdef OLD_STUFF
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);    // hide progress bar
#endif // OLD_STUFF
        fError = TRUE;
        hResult = hrSuccess;
        goto exit;
    }


    ulFlags = MAPI_LOGON_UI | MAPI_NO_MAIL | MAPI_EXTENDED;

    if (FAILED(hResult = MAPILogonEx(ulUIParam,
      NULL,
      NULL,
      ulFlags,
      (LPMAPISESSION FAR *)&lpMAPISession))) {
        DebugTrace("MAPILogonEx -> %x\n", GetScode(hResult));
        switch (GetScode(hResult)) {
            case MAPI_E_USER_CANCEL:
                SetDialogMessage(hwnd, IDS_STATE_EXPORT_IDLE);
                break;
            case MAPI_E_NOT_INITIALIZED:
                SetDialogMessage(hwnd, IDS_ERROR_MAPI_DLL_NOT_FOUND);
                break;
            default:
                SetDialogMessage(hwnd, IDS_ERROR_MAPI_LOGON);
                break;
        }
#ifdef OLD_STUFF
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);    // hide progress bar
#endif // OLD_STUFF
        fError = TRUE;
        hResult = hrSuccess;
        goto exit;
    }

    if (hResult = lpMAPISession->lpVtbl->OpenAddressBook(lpMAPISession, (ULONG_PTR)(void *)hwnd,
      NULL,
      0,
      &lpAdrBookMAPI)) {
        DebugTrace("OpenAddressBook(MAPI) -> %x", GetScode(hResult));
        if(FAILED(hResult)) {
            goto exit;
        }
    }

    if (! lpAdrBookMAPI) {
        DebugTrace("MAPILogonEx didn't return a valid AdrBook object\n");
        goto exit;
    }

    //
    // Open the MAPI PAB container
    //
    // [PaulHi] Raid #63578 1/7/98
    // Correctly check return code and provide user error message if
    // Exchange PAB cannot be opened.
    //
    hResult = lpAdrBookMAPI->lpVtbl->GetPAB(lpAdrBookMAPI,
        &cbPABEID,
        &lpPABEID);
    if (HR_FAILED(hResult))
    {
        DebugTrace("MAPI GetPAB -> %x\n", GetScode(hResult));
        goto exit;
    }
    else
    {
        hResult = lpAdrBookMAPI->lpVtbl->OpenEntry(lpAdrBookMAPI,
            cbPABEID,     // size of EntryID to open
            lpPABEID,     // EntryID to open
            NULL,         // interface
            MAPI_MODIFY,  // flags
            &ulObjType,
            (LPUNKNOWN *)&lpContainerMAPI);
        if (HR_FAILED(hResult))
        {
            DebugTrace("MAPI OpenEntry(PAB) -> %x\n", GetScode(hResult));
            goto exit;
        }
    }

    Assert(lpAdrBookWAB);

    //
    // Open the WAB's PAB container
    //
    if (hResult = lpAdrBookWAB->lpVtbl->GetPAB(lpAdrBookWAB,
      &cbWABEID,
      &lpWABEID)) {
        DebugTrace("WAB GetPAB -> %x\n", GetScode(hResult));
        goto exit;
    } else {
        if (hResult = lpAdrBookWAB->lpVtbl->OpenEntry(lpAdrBookWAB,
          cbWABEID,     // size of EntryID to open
          lpWABEID,     // EntryID to open
          NULL,         // interface
          0,            // flags
          &ulObjType,
          (LPUNKNOWN *)&lpContainerWAB)) {
            DebugTrace("WAB OpenEntry(PAB) -> %x\n", GetScode(hResult));
            goto exit;
        }
    }


    // Get the PAB's creation entryids
    hResult = lpContainerMAPI->lpVtbl->GetProps(lpContainerMAPI,
        (LPSPropTagArray)&ptaCon,
        0,
        &cProps,
        &lpCreateEIDsMAPI);
    if (HR_FAILED(hResult))
    {
        DebugTrace("Can't get container properties for PAB\n");
        // Bad stuff here!
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }

    // Validate the properites
    if (lpCreateEIDsMAPI[iconPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
      lpCreateEIDsMAPI[iconPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL)
    {
        DebugTrace("MAPI: Container property errors\n");
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }


    //
    // All set... now loop through the WAB's entries, copying them to PAB
    //
    if (HR_FAILED(hResult = lpContainerWAB->lpVtbl->GetContentsTable(lpContainerWAB,
      0,    // ulFlags
      &lpContentsTableWAB))) {
        DebugTrace("WAB GetContentsTable(PAB Table) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Set the columns to those we're interested in
    if (hResult = lpContentsTableWAB->lpVtbl->SetColumns(lpContentsTableWAB,
      (LPSPropTagArray)&ptaColumns,
      0)) {
        DebugTrace("WAB SetColumns(PAB Table) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Restrict the table to MAPI_MAILUSERs
    // If the convenient depth flag was not specified we restrict on
    // PR_DEPTH == 1.
    spvObjectType.ulPropTag = PR_OBJECT_TYPE;
    spvObjectType.Value.l = MAPI_MAILUSER;

    restrictObjectType.rt = RES_PROPERTY;
    restrictObjectType.res.resProperty.relop = RELOP_EQ;
    restrictObjectType.res.resProperty.ulPropTag = PR_OBJECT_TYPE;
    restrictObjectType.res.resProperty.lpProp = &spvObjectType;

    if (HR_FAILED(hResult = lpContentsTableWAB->lpVtbl->Restrict(lpContentsTableWAB,
      &restrictObjectType,
      0))) {
        DebugTrace("WAB Restrict (MAPI_MAILUSER) -> %x\n", GetScode(hResult));
        goto exit;
    }
    SetDialogMessage(hwnd, IDS_STATE_EXPORT_MU);


    // Initialize the Progress Bar
    // How many MailUser entries are there?
    ulcEntries = CountRows(lpContentsTableWAB, FALSE);

    DebugTrace("WAB contains %u MailUser entries\n", ulcEntries);

    SetDialogProgress(hwnd, ulcEntries, 0);
exit:
    if (lpWABEID) {
        WABFreeBuffer(lpWABEID);
    }

    if (lpPABEID) {
        MAPIFreeBuffer(lpPABEID);
    }

    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult))
    {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL)
        {
            NewState(hwnd, STATE_EXPORT_CANCEL);
        }
        else
        {
            // [PaulHi] 1/7/98  Error reporting is hosed
            // Display error message here to the user to ensure they
            // get it.
            {
                TCHAR   tszBuffer[MAX_RESOURCE_STRING];
                TCHAR   tszBufferTitle[MAX_RESOURCE_STRING];

                if ( !LoadString(hInst, IDS_STATE_EXPORT_ERROR_NOPAB, tszBuffer, MAX_RESOURCE_STRING-1) )
                {
                    Assert(0);
                    tszBuffer[0] = '\0';
                }

                if ( !LoadString(hInst, IDS_APP_TITLE, tszBufferTitle, MAX_RESOURCE_STRING-1) )
                {
                    Assert(0);
                    tszBufferTitle[0] = '\0';
                }
                MessageBox(hwnd, tszBuffer, tszBufferTitle, MB_ICONEXCLAMATION | MB_OK);
            }

            NewState(hwnd, STATE_EXPORT_ERROR);
        }
    }
    else if (fError)
    {
        NewState(hwnd, STATE_EXPORT_FINISH);      // must be logon error
    }
    else
    {
        NewState(hwnd, STATE_EXPORT_NEXT_MU);
    }
}


/***************************************************************************

    Name      : StateExportNextMU

    Purpose   : Migrate the next MailUser object

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : QueryRows on the global WAB contents table
                if there was a row
                    Migrate the entry to the PAB
                    Re-post STATE_EXPORT_NEXT_MU
                else
                    Post STATE_EXPORT_DL

***************************************************************************/
void StateExportNextMU(HWND hwnd) {
    ULONG cRows = 0;
    HRESULT hResult;
    LPSRowSet lpRow = NULL;


    DebugTrace(">>> STATE_EXPORT_NEXT_MU\n");
    Assert(lpContentsTableWAB);

    // Get the next WAB entry
    if (hResult = lpContentsTableWAB->lpVtbl->QueryRows(lpContentsTableWAB,
      1,    // one row at a time
      0,    // ulFlags
      &lpRow)) {
        DebugTrace("QueryRows -> %x\n", GetScode(hResult));
        goto exit;
    }

    if (lpRow) {
        if (cRows = lpRow->cRows) { // Yes, single '='
            Assert(lpRow->cRows == 1);
            Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

            if (cRows = lpRow->cRows) { // yes, single '='
                hResult = ExportEntry(hwnd,
                  lpAdrBookWAB,
                  lpContainerMAPI,
                  lpCreateEIDsMAPI,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].Value.l,
                  (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                  NULL,
                  NULL,
                  FALSE,
                  FALSE);
                // Update Progress Bar
                // ignore errors!

                SetDialogProgress(hwnd, ulcEntries, ++ulcDone);

                if (hResult) {
                    if (HandleExportError(hwnd,
                      0,
                      hResult,
                      lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ,
                      PropStringOrNULL(&lpRow->aRow[0].lpProps[iptaColumnsPR_EMAIL_ADDRESS]),
                      lpExportOptions)) {
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                    } else {
                        hResult = hrSuccess;
                    }
                }
            } // else, drop out of loop, we're done.
        }
        WABFreeProws(lpRow);
    }

exit:
    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult)) {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL) {
            NewState(hwnd, STATE_EXPORT_CANCEL);
        } else {
            NewState(hwnd, STATE_EXPORT_ERROR);
        }
    } else {
        if (cRows) {
            NewState(hwnd, STATE_EXPORT_NEXT_MU);
        } else {
            NewState(hwnd, STATE_EXPORT_DL);
        }
    }
}


/***************************************************************************

    Name      : StateExportDL

    Purpose   : Start migration of DISTLIST objects

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Set a new restriction on the contents table, selecting
                DISTLIST objects only.
                Post STATE_EXPORT_NEXT_DL

***************************************************************************/
void StateExportDL(HWND hwnd) {
    HRESULT hResult;
    SRestriction restrictObjectType;
    SPropValue spvObjectType;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];


    DebugTrace(">>> STATE_EXPORT_DL\n");

    // Restrict the table to MAPI_MAILUSERs
    // If the convenient depth flag was not specified we restrict on
    // PR_DEPTH == 1.
    spvObjectType.ulPropTag = PR_OBJECT_TYPE;
    spvObjectType.Value.l = MAPI_DISTLIST;

    restrictObjectType.rt = RES_PROPERTY;
    restrictObjectType.res.resProperty.relop = RELOP_EQ;
    restrictObjectType.res.resProperty.ulPropTag = PR_OBJECT_TYPE;
    restrictObjectType.res.resProperty.lpProp = &spvObjectType;

    if (HR_FAILED(hResult = lpContentsTableWAB->lpVtbl->Restrict(lpContentsTableWAB,
      &restrictObjectType,
      0))) {
        DebugTrace("WAB Restrict (MAPI_DISTLIST) -> %x\n", GetScode(hResult));
        goto exit;
    }
    // Restrict resets the current position to the beginning of the table, by definition.

    SetDialogMessage(hwnd, IDS_STATE_EXPORT_DL);

    // Initialize the Progress Bar
    // How many entries are there?

    ulcEntries = CountRows(lpContentsTableWAB, FALSE);

    DebugTrace("WAB contains %u Distribution List entries\n", ulcEntries);
    if (ulcEntries) {
        SetDialogProgress(hwnd, ulcEntries, 0);
    }
exit:
    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult)) {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL) {
            NewState(hwnd, STATE_EXPORT_CANCEL);
        } else {
            NewState(hwnd, STATE_EXPORT_ERROR);
        }
    } else {
        NewState(hwnd, STATE_EXPORT_NEXT_DL);
    }
}


/***************************************************************************

    Name      : StateExportNextDL

    Purpose   : Migrate the next DISTLIST object

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : QueryRows on the global WAB contents table
                if there was a row
                    Migrate the DistList to the PAB
                    Re-post STATE_EXPORT_NEXT_DL
                else
                    Post STATE_EXPORT_FINISH

***************************************************************************/
void StateExportNextDL(HWND hwnd) {
    ULONG cRows = 0;
    HRESULT hResult;
    LPSRowSet lpRow = NULL;


    DebugTrace(">>> STATE_EXPORT_NEXT_DL\n");

    // Get the next WAB entry
    if (hResult = lpContentsTableWAB->lpVtbl->QueryRows(lpContentsTableWAB,
      1,    // one row at a time
      0,    // ulFlags
      &lpRow)) {
        DebugTrace("QueryRows -> %x\n", GetScode(hResult));
        goto exit;
    }

    if (lpRow) {
        if (cRows = lpRow->cRows) { // Yes, single '='
            Assert(lpRow->cRows == 1);
            Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

            if (cRows = lpRow->cRows) { // yes, single '='
                hResult = ExportEntry(hwnd,
                  lpAdrBookWAB,
                  lpContainerMAPI,
                  lpCreateEIDsMAPI,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].Value.l,
                  (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                  NULL,
                  NULL,
                  FALSE,
                  FALSE);

                // Update Progress Bar
                SetDialogProgress(hwnd, ulcEntries, ++ulcDone);

                if (hResult) {
                    if (HandleExportError(hwnd,
                      0,
                      hResult,
                      lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ,
                      PropStringOrNULL(&lpRow->aRow[0].lpProps[iptaColumnsPR_EMAIL_ADDRESS]),
                      lpExportOptions)) {
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                    } else {
                        hResult = hrSuccess;
                    }
                }
            } // else, drop out of loop, we're done.
        }
        WABFreeProws(lpRow);
    }

exit:
    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult)) {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL) {
            NewState(hwnd, STATE_EXPORT_CANCEL);
        } else {
            NewState(hwnd, STATE_EXPORT_ERROR);
        }
    } else {
        if (cRows) {
            NewState(hwnd, STATE_EXPORT_NEXT_DL);
        } else {
            // Update Progress Bar to indicate completion
            SetDialogProgress(hwnd, ulcEntries, ulcEntries);
            NewState(hwnd, STATE_EXPORT_FINISH);
        }
    }
}


/***************************************************************************

    Name      : StateExportFinish

    Purpose   : Clean up after the migration process

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Clean up the global MAPI objects and buffers
                Clean up the global WAB objects and buffers.
                Re-enable the Export button on the UI.

***************************************************************************/
void StateExportFinish(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    TCHAR szBufferTitle[MAX_RESOURCE_STRING + 1];


    DebugTrace(">>> STATE_EXPORT_FINISH\n");

    //
    // Cleanup MAPI
    //
    if (lpContainerMAPI) {
        lpContainerMAPI->lpVtbl->Release(lpContainerMAPI);
        lpContainerMAPI = NULL;
    }

    if (lpAdrBookMAPI) {
        lpAdrBookMAPI->lpVtbl->Release(lpAdrBookMAPI);
        lpAdrBookMAPI = NULL;
    }
    if(lpMAPISession){
        lpMAPISession->lpVtbl->Logoff(lpMAPISession, (ULONG_PTR)(void *)hwnd,
          MAPI_LOGOFF_UI,
          0);

        lpMAPISession->lpVtbl->Release(lpMAPISession);
        lpMAPISession = NULL;
    }

    //
    // Cleanup the WAB
    //
    if (lpContentsTableWAB) {
        lpContentsTableWAB->lpVtbl->Release(lpContentsTableWAB);
        lpContentsTableWAB = NULL;
    }

    if (lpCreateEIDsWAB) {
        WABFreeBuffer(lpCreateEIDsWAB);
        lpCreateEIDsWAB = NULL;
    }

    if (lpContainerWAB) {
        lpContainerWAB->lpVtbl->Release(lpContainerWAB);
        lpContainerWAB = NULL;
    }

#ifdef OLD_STUFF        // Don't release AdrBookWAB or WABObject
    if (lpAdrBookWAB) {
        lpAdrBookWAB->lpVtbl->Release(lpAdrBookWAB);
        lpAdrBookWAB = NULL;
    }

    if (lpWABObject) {
        lpWABObject->lpVtbl->Release(lpWABObject);
        lpWABObject = NULL;
    }
#endif // OLD_STUFF

    // Cleanup the cache
    FreeSeenList();

    if (! fError) {     // Leave error state displayed
        if (LoadString(hInst, IDS_STATE_EXPORT_COMPLETE, szBuffer, sizeof(szBuffer))) {
            DebugTrace("Status Message: %s\n", szBuffer);
            SetDlgItemText(hwnd, IDC_Message, szBuffer);

            if (! LoadString(hInst, IDS_APP_TITLE, szBufferTitle, sizeof(szBufferTitle))) {
                lstrcpy(szBufferTitle, "");
            }

#ifdef OLD_STUFF
            // Display a dialog telling user it's over
            MessageBox(hwnd, szBuffer,
              szBufferTitle, MB_ICONINFORMATION | MB_OK);
#endif // OLD_STUFF
        }
#ifdef OLD_STUFF
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);
#endif // OLD_STUFF
    }
    fError = FALSE;

    // Re-enable the Export button here.
    EnableWindow(GetDlgItem(hwnd, IDC_Export), TRUE);
    // Change the Cancel button to Close
    if (LoadString(hInst, IDS_BUTTON_CLOSE, szBuffer, sizeof(szBuffer))) {
        SetDlgItemText(hwnd, IDCANCEL, szBuffer);
    }
}


/***************************************************************************

    Name      : StateExportError

    Purpose   : Report fatal error and cleanup.

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Report error and post STATE_EXPORT_FINISH.

***************************************************************************/
void StateExportError(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace(">>> STATE_EXPORT_ERROR\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_EXPORT_ERROR);

    NewState(hwnd, STATE_EXPORT_FINISH);
}


/***************************************************************************

    Name      : StateExportCancel

    Purpose   : Report cancel error and cleanup.

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Report error and post STATE_EXPORT_FINISH.

***************************************************************************/
void StateExportCancel(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace(">>> STATE_EXPORT_CANCEL\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_EXPORT_CANCEL);

    NewState(hwnd, STATE_EXPORT_FINISH);
}


/***************************************************************************

    Name      : HrFilterExportMailUserProps

    Purpose   : Filters out undesirable properties from the property array.
                Converts known email address types to SMTP.
                Moves FAX address to PR_BUSINESS_FAX_NUMBER.

    Parameters: lpcProps -> IN: Input number of properties
                            OUT: Output number of properties
                lppProps -> IN: Input property array (MAPI allocation)
                            OUT: Output property array (WAB allocation)
                lpObjectWAB -> WAB object (used to get extra props)
                lpfDL -> flag to set FALSE if we change a DL to a MAILUSER
                         (ie, for an EXchange DL)

    Returns   : HRESULT

    Comment   : Setting the property tag in the array to PR_NULL effectively
                nulls this property out.  We can re-use these in the second
                pass.

                Caller should use MAPIFreeBuffer to free *lppProps.
                This routine will free the input value of *lppProps.

                WARNING: This routine will add dummy properties to the
                input WAB object, so don't go doing SaveChanges on it!

***************************************************************************/
#define MAX_ADD_PROPS   2
#define PR_DUMMY_1      PROP_TAG(PT_LONG,      0xF000)
#define PR_DUMMY_2      PROP_TAG(PT_LONG,      0xF001)

HRESULT HrFilterExportMailUserProps(LPULONG lpcProps, LPSPropValue * lppProps,
  LPMAPIPROP lpObjectWAB, LPBOOL lpfDL) {
    HRESULT hResult = hrSuccess;
    ULONG i;
    LPSPropValue lpPropsWAB, lpPropsMAPI = NULL;
    ULONG cbProps;
    SCODE sc;
    ULONG cProps;
    ULONG iPR_ADDRTYPE = NOT_FOUND;
    ULONG iPR_EMAIL_ADDRESS = NOT_FOUND;
    ULONG iPR_PRIMARY_FAX_NUMBER = NOT_FOUND;
    ULONG iPR_BUSINESS_FAX_NUMBER = NOT_FOUND;
    ULONG iPR_MSNINET_DOMAIN = NOT_FOUND;
    ULONG iPR_MSNINET_ADDRESS = NOT_FOUND;
    ULONG iPR_DISPLAY_NAME = NOT_FOUND;
    ULONG iPR_OBJECT_TYPE = NOT_FOUND;
    ULONG iPR_SEND_RICH_INFO = NOT_FOUND;
    LPSBinary lpEntryID = NULL;
    LPTSTR lpTemp;
    BOOL fBadAddress = FALSE;
    SPropValue rgPropsDummy[MAX_ADD_PROPS] = {
        PR_DUMMY_1, 0, 1,
        PR_DUMMY_2, 0, 2,
    };


    // Set extra bogus props on the object in case we need to add more props
    // to the array later.  These will be PR_NULL'ed out by the first pass.
    if (HR_FAILED(hResult = lpObjectWAB->lpVtbl->SetProps(lpObjectWAB,
      MAX_ADD_PROPS,
      rgPropsDummy,
      NULL))) {
        DebugTrace("HrFilterExportMailUserProps:SetProps dummy props -> %x\n", GetScode(hResult));
        // ignore the error
    }


    // Get the properties from this entry
    if (HR_FAILED(hResult = lpObjectWAB->lpVtbl->GetProps(lpObjectWAB,
      NULL,
      0,
      &cProps,
      &lpPropsWAB))) {
        DebugTrace("HrFilterExportMailUserProps:GetProps(WAB) -> %x\n", GetScode(hResult));
        return(hResult);
    }

//    WABDebugProperties(lpPropsWAB, *lpcProps, "MailUser BEFORE");


    // First pass: Remove the junk
    for (i = 0; i < cProps; i++) {
        // Error value
        if (PROP_ERROR(lpPropsWAB[i])) {
            lpPropsWAB[i].ulPropTag = PR_NULL;
            continue;
        }

        // Named property
        if (PROP_ID(lpPropsWAB[i].ulPropTag) >= MIN_NAMED_PROPID) {
            lpPropsWAB[i].ulPropTag = PR_NULL;
            continue;
        }

        // Object property
        if (PROP_TYPE(lpPropsWAB[i].ulPropTag) == PT_OBJECT) {
            lpPropsWAB[i].ulPropTag = PR_NULL;
            continue;
        }
        switch (lpPropsWAB[i].ulPropTag) {
            case PR_ENTRYID:
                lpEntryID = &lpPropsWAB[i].Value.bin;
                // fall through

            case PR_PRIMARY_CAPABILITY:
            case PR_TEMPLATEID:
            case PR_SEARCH_KEY:
            case PR_INITIAL_DETAILS_PANE:
            case PR_RECORD_KEY:
            case PR_MAPPING_SIGNATURE:
                lpPropsWAB[i].ulPropTag = PR_NULL;
                break;

            case PR_COMMENT:
                // Don't save PR_COMMENT if it is empty
                if (lstrlen(lpPropsWAB[i].Value.LPSZ) == 0) {
                    lpPropsWAB[i].ulPropTag = PR_NULL;
                }
                break;

            // Keep track of the position of these for later
            case PR_ADDRTYPE:
                iPR_ADDRTYPE = i;
                break;
            case PR_OBJECT_TYPE:
                iPR_OBJECT_TYPE = i;
                break;
            case PR_EMAIL_ADDRESS:
                iPR_EMAIL_ADDRESS = i;
                break;
            case PR_PRIMARY_FAX_NUMBER:
                iPR_PRIMARY_FAX_NUMBER = i;
                break;
            case PR_BUSINESS_FAX_NUMBER:
                iPR_BUSINESS_FAX_NUMBER = i;
                break;
            case PR_MSNINET_ADDRESS:
                iPR_MSNINET_ADDRESS = i;
                break;
            case PR_MSNINET_DOMAIN:
                iPR_MSNINET_DOMAIN = i;
                break;
            case PR_DISPLAY_NAME:
                iPR_DISPLAY_NAME = i;
                break;
            case PR_SEND_RICH_INFO:
                iPR_SEND_RICH_INFO = i;
                break;
        }

        // Put this after the switch since we do want to track a few props which fall in
        // the 0x6000 range but don't want to transfer them to the wab.
        if (PROP_ID(lpPropsWAB[i].ulPropTag) >= MAX_SCHEMA_PROPID) {
            lpPropsWAB[i].ulPropTag = PR_NULL;
            continue;
        }
    }


    // Second pass: Fix up the addresses
    if (iPR_ADDRTYPE != NOT_FOUND) {
        if (! lstrcmpi(lpPropsWAB[iPR_ADDRTYPE].Value.LPSZ, szSMTP)) {
            DebugTrace("SMTP address for %s\n", lpPropsWAB[iPR_DISPLAY_NAME].Value.LPSZ);
        } else if (! lstrcmpi(lpPropsWAB[iPR_ADDRTYPE].Value.LPSZ, szMAPIPDL)) {
            DebugTrace("MAPIPDL %s\n", lpPropsWAB[iPR_DISPLAY_NAME].Value.LPSZ);
            // Distribution list, ignore it.
        } else {
            WABDebugProperties(lpPropsWAB, cProps, "Unknown address type");
            DebugTrace("Found unknown PR_ADDRTYPE: %s\n", lpPropsWAB[iPR_ADDRTYPE].Value.LPSZ);
            Assert(FALSE);
        }
    }

    // PR_BUSINESS_FAX_NUMBER?
    // The PAB puts the Fax number in PR_PRIMARY_FAX_NUMBER, but the WAB UI splits it
    // into PR_BUSINESS_FAX_NUMBER and PR_HOME_FAX_NUMBER.  We always map business to
    // Primary fax number and ignore home fax number.
    if ((iPR_BUSINESS_FAX_NUMBER != NOT_FOUND) && (iPR_PRIMARY_FAX_NUMBER == NOT_FOUND)) {
        // We need to also have a PR_PRIMARY_FAX_NUMBER
        // Find the next PR_NULL spot.
        iPR_PRIMARY_FAX_NUMBER = iPR_BUSINESS_FAX_NUMBER;   // overwrite this one if there isn't
                                                             // an available slot in the prop array.
        for (i = 0; i < cProps; i++) {
            if (lpPropsWAB[i].ulPropTag == PR_NULL) {
                iPR_PRIMARY_FAX_NUMBER = i;
                lpPropsWAB[iPR_PRIMARY_FAX_NUMBER].Value.LPSZ =
                  lpPropsWAB[iPR_BUSINESS_FAX_NUMBER].Value.LPSZ;
                break;
            }
        }

        lpPropsWAB[iPR_PRIMARY_FAX_NUMBER].ulPropTag = PR_PRIMARY_FAX_NUMBER;
    }

    // If there is no PR_SEND_RICH_INFO, make one and set it FALSE
    if (iPR_SEND_RICH_INFO == NOT_FOUND) {
        // Find the next PR_NULL and put it there.
        for (i = 0; i < cProps; i++) {
            if (lpPropsWAB[i].ulPropTag == PR_NULL) {
                iPR_SEND_RICH_INFO = i;
                lpPropsWAB[iPR_SEND_RICH_INFO].Value.b = FALSE;
                lpPropsWAB[iPR_SEND_RICH_INFO].ulPropTag = PR_SEND_RICH_INFO;
                break;
            }
        }
        Assert(iPR_SEND_RICH_INFO != NOT_FOUND);
    }

    // Get rid of PR_NULL props
    for (i = 0; i < cProps; i++) {
        if (lpPropsWAB[i].ulPropTag == PR_NULL) {
            // Slide the props down.
            if (i + 1 < cProps) {       // Are there any higher props to copy?
                CopyMemory(&lpPropsWAB[i], &lpPropsWAB[i + 1], ((cProps - i) - 1) * sizeof(lpPropsWAB[i]));
            }
            // decrement count
            cProps--;
            i--;    // You overwrote the current propval.  Look at it again.
        }
    }

    // Reallocate as MAPI memory.

    if (sc = ScCountProps(cProps, lpPropsWAB, &cbProps)) {
        hResult = ResultFromScode(sc);
        DebugTrace("ScCountProps -> %x\n", sc);
        goto exit;
    }

    if (sc = MAPIAllocateBuffer(cbProps, &lpPropsMAPI)) {
        hResult = ResultFromScode(sc);
        DebugTrace("WABAllocateBuffer -> %x\n", sc);
        goto exit;
    }

    if (sc = ScCopyProps(cProps,
      lpPropsWAB,
      lpPropsMAPI,
      NULL)) {
        hResult = ResultFromScode(sc);
        DebugTrace("ScCopyProps -> %x\n", sc);
        goto exit;
    }

exit:
    if (lpPropsWAB) {
        WABFreeBuffer(lpPropsWAB);
    }

    if (HR_FAILED(hResult)) {
        if (lpPropsMAPI) {
            MAPIFreeBuffer(lpPropsMAPI);
            lpPropsMAPI = NULL;
        }
        cProps = 0;
    } else if (fBadAddress) {
        hResult = ResultFromScode(WAB_W_BAD_EMAIL);
    }

    *lppProps = lpPropsMAPI;
    *lpcProps = cProps;

    return(hResult);
}


/***************************************************************************

    Name      : HandleExportError

    Purpose   : Decides if a dialog needs to be displayed to
                indicate the failure and does so.

    Parameters: hwnd = main dialog window
                ids = String ID (optional: calculated from hResult if 0)
                hResult = Result of action
                lpDisplayName = display name of object that failed
                lpEmailAddress = email address of object that failed (or NULL)

    Returns   : TRUE if user requests ABORT.

    Comment   : Abort is not yet implemented in the dialog, but if you
                ever want to, just make this routine return TRUE;

***************************************************************************/
BOOL HandleExportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_EXPORT_OPTIONS lpExportOptions) {
    BOOL fAbort = FALSE;
    ERROR_INFO EI;

    if ((ids || hResult) && ! lpExportOptions->fNoErrors) {
        if (ids == 0) {
            switch (GetScode(hResult)) {
                case WAB_W_BAD_EMAIL:
                    ids = lpEmailAddress ? IDS_ERROR_EMAIL_ADDRESS_2 : IDS_ERROR_EMAIL_ADDRESS_1;
                    break;

                case MAPI_E_NO_SUPPORT:
                    // Propbably failed to open contents on a distribution list
                    ids = IDS_ERROR_NO_SUPPORT;
                    break;

                case MAPI_E_USER_CANCEL:
                    return(TRUE);

                default:
                    if (HR_FAILED(hResult)) {
                        DebugTrace("Error Box for Hresult: 0x%08x\n", GetScode(hResult));
                        Assert(FALSE);      // want to know about it.
                        ids = IDS_ERROR_GENERAL;
                    }
                    break;
            }
        }

        EI.lpszDisplayName = lpDisplayName;
        EI.lpszEmailAddress = lpEmailAddress;
        EI.ErrorResult = ERROR_OK;
        EI.ids = ids;
        EI.fExport = TRUE;
        EI.lpImportOptions = lpExportOptions;

        DialogBoxParam(hInst,
          MAKEINTRESOURCE(IDD_ErrorExport),
          hwnd,
          ErrorDialogProc,
          (LPARAM)&EI);

        fAbort = EI.ErrorResult == ERROR_ABORT;
    }

    return(fAbort);
}


/***************************************************************************

    Name      : AddEntryToExportList

    Purpose   : Checks this entry against our "seen" list and adds it.

    Parameters: cbEID = size of lpEID
                lpEID -> EntryID of entry
                lplIndex -> returned list index (or -1 on error)

    Returns   : TRUE if entry already exists

    Comment   : Caller must mark the WAB entry!

***************************************************************************/
#define GROW_SIZE   10
BOOL AddEntryToExportList(ULONG cbEID, LPENTRYID lpEID, LPLONG lplIndex) {
    ULONG i;
    LPENTRY_SEEN lpEntrySeen;

    if (cbEID && lpEID) {
        for (i = 0; i < ulEntriesSeen; i++) {
            if (cbEID == lpEntriesSeen[i].sbinPAB.cb  && (! memcmp(lpEID, lpEntriesSeen[i].sbinPAB.lpb, cbEID))) {
                // This one's in the list
                *lplIndex = i;
                // If cb 0, we must have recursed and are replacing, so this one is not a dup.
                return(lpEntriesSeen[i].sbinWAB.cb != 0);
            }
        }

        // Add to the end of the list
        if (++ulEntriesSeen > ulMaxEntries) {
            // Grow the array.

            ulMaxEntries += GROW_SIZE;

            if (lpEntriesSeen) {
                if (! (lpEntrySeen = LocalReAlloc(lpEntriesSeen, ulMaxEntries * sizeof(ENTRY_SEEN), LMEM_MOVEABLE | LMEM_ZEROINIT))) {
                    DebugTrace("LocalReAlloc(%u) -> %u\n", ulMaxEntries * sizeof(ENTRY_SEEN), GetLastError());
                    goto error;
                }
                lpEntriesSeen = lpEntrySeen;
            } else {
                if (! (lpEntriesSeen = LocalAlloc(LPTR, ulMaxEntries * sizeof(ENTRY_SEEN)))) {
                    DebugTrace("LocalAlloc(%u) -> %u\n", ulMaxEntries * sizeof(ENTRY_SEEN), GetLastError());
                    goto error;
                }
            }
        }

        lpEntrySeen = &lpEntriesSeen[ulEntriesSeen - 1];

        // Allocate space for data
        lpEntrySeen->sbinPAB.cb = cbEID;
        if (! (lpEntrySeen->sbinPAB.lpb = LocalAlloc(LPTR, cbEID))) {
            DebugTrace("LocalAlloc(%u) -> %u\n", cbEID, GetLastError());
            goto error;
        }

        // Mark as unknown WAB entry
        lpEntrySeen->sbinWAB.cb = 0;
        lpEntrySeen->sbinWAB.lpb = 0;

        // Copy in the data
        CopyMemory(lpEntrySeen->sbinPAB.lpb, lpEID, cbEID);
        *lplIndex = i;
    }

    return(FALSE);

error:
    // undo the damage...
    --ulEntriesSeen;
    ulMaxEntries -= GROW_SIZE;
    *lplIndex = -1;     // error
    if (! lpEntriesSeen) {
        ulEntriesSeen = 0;  // pointer is null now, back to square one.
        ulMaxEntries = 0;
    }
    return(FALSE);
}


/***************************************************************************

    Name      : MarkPABEntryInList

    Purpose   : Marks the PAB entry fields in the list node

    Parameters: cbEID = size of lpEID
                lpEID -> EntryID of entry
                lIndex = list index (or -1 on error)

    Returns   : none

    Comment   :

***************************************************************************/
void MarkPABEntryInList(ULONG cbEID, LPENTRYID lpEID, LONG lIndex) {
    if (lIndex != -1 && cbEID) {
       if (! (lpEntriesSeen[lIndex].sbinWAB.lpb = LocalAlloc(LPTR, cbEID))) {
           DebugTrace("LocalAlloc(%u) -> %u\n", cbEID, GetLastError());
           // leave it null
       } else {
           lpEntriesSeen[lIndex].sbinWAB.cb = cbEID;

           // Copy in the data
           CopyMemory(lpEntriesSeen[lIndex].sbinWAB.lpb, lpEID, cbEID);
       }
    }
}


//
// Properties to get from the PAB Entry
//
enum {
    ifePR_OBJECT_TYPE = 0,
    ifePR_ENTRYID,
    ifePR_DISPLAY_NAME,
    ifePR_EMAIL_ADDRESS,
    ifeMax
};
static const SizedSPropTagArray(ifeMax, ptaFind) =
{
    ifeMax,
    {
        PR_OBJECT_TYPE,
        PR_ENTRYID,
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS
    }
};
/***************************************************************************

    Name      : FindPABEntry

    Purpose   : Finds the named entry in the PAB

    Parameters: lpContainerPAB -> MAPI PAB container
                ulObjectType = {MAPI_MAILUSER, MAPI_DISTLIST}
                lpDisplayName = name of entry
                lpEmailAddress = email address or NULL if none
                lppEIDMAPI -> returned MAPI ENTRYID: Caller must MAPIFreeBuffer.
                lpcbEIDMAPI -> returned size of lppEIDMAPI

    Returns   : HRESULT

    Comment   : At this point, we expect to find a match since
                SaveChanges said we had a duplicate.

***************************************************************************/
HRESULT FindPABEntry(LPABCONT lpContainerPAB,
  ULONG ulObjectType,
  LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress,
  LPULONG lpcbEIDDup,
  LPENTRYID * lppEIDDup) {
    HRESULT hResult = hrSuccess;
    SCODE sc;
    SRestriction resAnd[3]; // 0 = object type, 1 = displayname, 2 = emailaddress
    SRestriction resFind;
    SPropValue spvObjectType, spvDisplayName, spvEmailAddress;
    LPSRowSet lpRow = NULL;
    LPMAPITABLE lpTable = NULL;
    ULONG rgFlagList[2];
    LPFlagList lpFlagList = (LPFlagList)rgFlagList;
    LPADRLIST lpAdrListMAPI = NULL;
    LPSBinary lpsbEntryID;
    ULONG i;


    // init return values
    *lppEIDDup = NULL;
    *lpcbEIDDup = 0;


    // find the existing PAB entry.
    // Setup for ResolveNames on the PAB container.
    if (sc = MAPIAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), &lpAdrListMAPI)) {
        DebugTrace("MAPI Allocation(ADRLIST) failed -> %x\n", sc);
        hResult = ResultFromScode(sc);
        goto restrict;
    }
    lpAdrListMAPI->cEntries = 1;
    lpAdrListMAPI->aEntries[0].ulReserved1 = 0;
    lpAdrListMAPI->aEntries[0].cValues = 1;

    if (sc = MAPIAllocateBuffer(sizeof(SPropValue), &lpAdrListMAPI->aEntries[0].rgPropVals)) {
        DebugTrace("MAPI Allocation(ADRENTRY propval) failed -> %x\n", sc);
        hResult = ResultFromScode(sc);
        goto restrict;
    }

    lpFlagList->cFlags = 1;

    for (i = 0; i <= 1; i++) {
        switch (i) {
            case 0:     // pass 0
                lpAdrListMAPI->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
                lpAdrListMAPI->aEntries[0].rgPropVals[0].Value.LPSZ = lpDisplayName;
                break;
            case 1:
                if (lpEmailAddress) {
                    lpAdrListMAPI->aEntries[0].rgPropVals[0].ulPropTag = PR_EMAIL_ADDRESS;
                    lpAdrListMAPI->aEntries[0].rgPropVals[0].Value.LPSZ = lpEmailAddress;
                } else {
                    continue;   // no email address, don't bother with second pass
                }
                break;
            default:
                Assert(FALSE);
        }
        lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

        if (HR_FAILED(hResult = lpContainerPAB->lpVtbl->ResolveNames(lpContainerPAB,
          NULL,            // tag set
          0,               // ulFlags
          lpAdrListMAPI,
          lpFlagList))) {
            DebugTrace("MAPI ResolveNames -> %x\n", GetScode(hResult));
            continue;
        }

        switch (lpFlagList->ulFlag[0]) {
            case MAPI_UNRESOLVED:
                DebugTrace("WAB ResolveNames didn't find the entry %s\n", lpDisplayName);
                continue;
            case MAPI_AMBIGUOUS:
                DebugTrace("WAB ResolveNames find ambiguous entry %s\n", lpDisplayName);
                continue;
            case MAPI_RESOLVED:
                i = 2;  // Found it, exit the loop
        }
    }

    if (lpFlagList->ulFlag[0] == MAPI_RESOLVED) {
        // Found one, find its PR_ENTRYID
        if (! (lpsbEntryID = FindAdrEntryID(lpAdrListMAPI, 0))) {
            DebugTrace("MAPI ResolveNames didn't give us an EntryID\n");
            Assert(lpsbEntryID);
            goto restrict;
        }

        *lpcbEIDDup = lpsbEntryID->cb;
        if (FAILED(sc = MAPIAllocateBuffer(*lpcbEIDDup, lppEIDDup))) {
            hResult = ResultFromScode(sc);
            DebugTrace("FindPABEntry couldn't allocate duplicate entryid %x\n", sc);
            goto exit;
        }
        memcpy(*lppEIDDup, lpsbEntryID->lpb, *lpcbEIDDup);
    }


restrict:
    if (! *lppEIDDup) {
        //
        // Last ditch effort... use a table restriction to try to find this entry.
        //

        // Get the contents table
        if (HR_FAILED(hResult = lpContainerPAB->lpVtbl->GetContentsTable(lpContainerPAB,
          0,    // ulFlags
          &lpTable))) {
            DebugTrace("PAB GetContentsTable -> %x\n", GetScode(hResult));
            goto exit;
        }

        // Set the columns
        if (HR_FAILED(hResult = lpTable->lpVtbl->SetColumns(lpTable,
          (LPSPropTagArray)&ptaFind,
          0))) {
            DebugTrace("PAB SetColumns-> %x\n", GetScode(hResult));
            goto exit;
        }

        // Restrict to the object we care about
        resAnd[0].rt = RES_PROPERTY;    // Restriction type Property
        resAnd[0].res.resProperty.relop = RELOP_EQ;
        resAnd[0].res.resProperty.ulPropTag = PR_OBJECT_TYPE;
        resAnd[0].res.resProperty.lpProp = &spvObjectType;
        spvObjectType.ulPropTag = PR_OBJECT_TYPE;
        spvObjectType.Value.ul = ulObjectType;

        // Restrict to get correct display name
        resAnd[1].rt = RES_PROPERTY;    // Restriction type Property
        resAnd[1].res.resProperty.relop = RELOP_EQ;
        resAnd[1].res.resProperty.ulPropTag = PR_DISPLAY_NAME;
        resAnd[1].res.resProperty.lpProp = &spvDisplayName;
        spvDisplayName.ulPropTag = PR_DISPLAY_NAME;
        spvDisplayName.Value.LPSZ = lpDisplayName;

        if (lpEmailAddress) {
            // Restrict to get correct email address
            resAnd[2].rt = RES_PROPERTY;    // Restriction type Property
            resAnd[2].res.resProperty.relop = RELOP_EQ;
            resAnd[2].res.resProperty.ulPropTag = PR_EMAIL_ADDRESS;
            resAnd[2].res.resProperty.lpProp = &spvEmailAddress;
            spvEmailAddress.ulPropTag = PR_EMAIL_ADDRESS;
            spvEmailAddress.Value.LPSZ = lpEmailAddress;
        }

        resFind.rt = RES_AND;
        resFind.res.resAnd.cRes = lpEmailAddress ? 3 : 2;
        resFind.res.resAnd.lpRes = resAnd;

        if (HR_FAILED(hResult = lpTable->lpVtbl->Restrict(lpTable,
          &resFind,
          0))) {
            DebugTrace("FindPABEntry: Restrict -> %x", hResult);
            goto exit;
        }

        if (hResult = lpTable->lpVtbl->QueryRows(lpTable,
          1,    // First row only
          0,    // ulFlags
          &lpRow)) {
            DebugTrace("FindPABEntry: QueryRows -> %x\n", GetScode(hResult));
        } else {
            // Found it, copy entryid to new allocation
            if (lpRow->cRows) {
                *lpcbEIDDup = lpRow->aRow[0].lpProps[ifePR_ENTRYID].Value.bin.cb;
                if (FAILED(sc = MAPIAllocateBuffer(*lpcbEIDDup, lppEIDDup))) {
                    hResult = ResultFromScode(sc);
                    DebugTrace("FindPABEntry couldn't allocate duplicate entryid %x\n", sc);
                    goto exit;
                }
                memcpy(*lppEIDDup, lpRow->aRow[0].lpProps[ifePR_ENTRYID].Value.bin.lpb, *lpcbEIDDup);
            } else {
                hResult = ResultFromScode(MAPI_E_NOT_FOUND);
            }
        }

        // Still not found?!!  Maybe the PAB has a different idea of what the Display name is.
        // Search just by email address.
        if (hResult && lpEmailAddress) {
            resAnd[1] = resAnd[2];  // copy the email address res over the display name res.
            resFind.res.resAnd.cRes = 2;

            if (HR_FAILED(hResult = lpTable->lpVtbl->Restrict(lpTable,
              &resFind,
              0))) {
                DebugTrace("FindPABEntry: Restrict -> %x", hResult);
                goto exit;
            }

            if (hResult = lpTable->lpVtbl->QueryRows(lpTable,
              1,    // First row only
              0,    // ulFlags
              &lpRow)) {
                DebugTrace("FindPABEntry: QueryRows -> %x\n", GetScode(hResult));
            } else {
                // Found it, copy entryid to new allocation
                if (lpRow->cRows) {
                    *lpcbEIDDup = lpRow->aRow[0].lpProps[ifePR_ENTRYID].Value.bin.cb;
                    if (FAILED(sc = MAPIAllocateBuffer(*lpcbEIDDup, lppEIDDup))) {
                        hResult = ResultFromScode(sc);
                        DebugTrace("FindPABEntry couldn't allocate duplicate entryid %x\n", sc);
                        goto exit;
                    }
                    memcpy(*lppEIDDup, lpRow->aRow[0].lpProps[ifePR_ENTRYID].Value.bin.lpb, *lpcbEIDDup);
                } else {
                    hResult = ResultFromScode(MAPI_E_NOT_FOUND);
                    DebugTrace("FindPABEntry coudln't find %s %s <%s>\n",
                      ulObjectType == MAPI_MAILUSER ? "Mail User" : "Distribution List",
                      lpDisplayName,
                      lpEmailAddress ? lpEmailAddress : "");
                }
            }
        }
    }

exit:
    if (lpAdrListMAPI) {
        FreePadrlist(lpAdrListMAPI);
    }
    if (lpRow) {
        FreeProws(lpRow);
    }
    if (lpTable) {
        lpTable->lpVtbl->Release(lpTable);
    }
    if (HR_FAILED(hResult) && *lppEIDDup) {
        MAPIFreeBuffer(*lppEIDDup);
        *lpcbEIDDup = 0;
        *lppEIDDup = NULL;
    }
    if (hResult) {
        DebugTrace("FindPABEntry coudln't find %s %s <%s>\n",
          ulObjectType == MAPI_MAILUSER ? "Mail User" : "Distribution List",
          lpDisplayName,
          lpEmailAddress ? lpEmailAddress : "");
    }

    return(hResult);
}


// enum for setting the created properties
enum {
    irnPR_DISPLAY_NAME = 0,
    irnPR_RECIPIENT_TYPE,
    irnPR_ENTRYID,
    irnPR_EMAIL_ADDRESS,
    irnMax
};

/***************************************************************************

    Name      : ExportEntry

    Purpose   : Migrates the entry from the WAB to the PAB

    Parameters: hwnd = main dialog window
                lpAdrBookWAB -> WAB AdrBook object
                lpContainerMAPI -> MAPI PAB container
                lpCreateEIDsMAPI -> SPropValue of default object creation EIDs
                ulObjectType = {MAPI_MAILUSER, MAPI_DISTLIST}
                lpEID -> ENTYRID of the WAB entry
                cbEID = sizeof lpEID
                lppEIDMAPI -> returned MAPI ENTRYID: Caller must MAPIFreeBuffer.
                  May be NULL.
                lpcbEIDMAPI -> returned size of lppEIDMAPI (ignored if lppEIDMAPI
                  is NULL.
                fInDL = TRUE if this entry is for creation in a Distribution List
                fForceReplace = TRUE if this entry should replace any duplicate.

    Returns   : HRESULT

    Comment   : This routine is a MESS!  Should break it up when we get time.

***************************************************************************/
HRESULT ExportEntry(HWND hwnd,
  LPADRBOOK lpAdrBookWAB,
  LPABCONT lpContainerMAPI,
  LPSPropValue lpCreateEIDsMAPI,
  ULONG ulObjectType,
  LPENTRYID lpEID,
  ULONG cbEID,
  LPENTRYID * lppEIDMAPI,
  LPULONG lpcbEIDMAPI,
  BOOL fInDL,
  BOOL fForceReplace) {
    HRESULT hResult = hrSuccess;
    SCODE sc;
    BOOL fDistList = FALSE;
    BOOL fDuplicate = FALSE;
    BOOL fDuplicateEID;
    BOOL fReturnEID = FALSE;
    ULONG ulObjectTypeOpen;
    LPDISTLIST lpDistListMAPI = NULL, lpDistListWAB = NULL;
    LPMAPIPROP lpMailUserMAPI = NULL, lpMailUserWAB = NULL;
    LPSPropValue lpProps = NULL;
    ULONG cProps, cEIDPropMAPI;
    LPMAPITABLE lpDLTableWAB = NULL;
    ULONG cRows;
    LPSRowSet lpRow = NULL;
    LPENTRYID lpeidDLMAPI = NULL;
    ULONG cbeidDLMAPI;
    LPSPropValue lpEIDPropMAPI = NULL;
    LPMAPIPROP lpEntryMAPI = NULL;
    ULONG ulCreateFlags;
    REPLACE_INFO RI;
    LPTSTR lpDisplayName = NULL, lpEmailAddress = NULL;
    static TCHAR szBufferDLMessage[MAX_RESOURCE_STRING + 1] = "";
    LPTSTR lpszMessage;
    LONG lListIndex = -1;
    LPENTRYID lpEIDNew = NULL;
    DWORD cbEIDNew = 0;
    LPIID lpIIDOpen;
    ULONG iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
    BOOL fCreatedNew = FALSE;
    LPENTRYID lpEIDDup = NULL;
    ULONG cbEIDDup;


    // Check the entry against our "seen" list
    fDuplicateEID = AddEntryToExportList(cbEID, lpEID, &lListIndex);

    if (! fDuplicateEID) {
        // Set up some object type specific variables
        switch (ulObjectType) {
            default:
                DebugTrace("ExportEntry got unknown object type %u, assuming MailUser\n", ulObjectType);
                Assert(FALSE);

            case MAPI_MAILUSER:
                iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
                lpIIDOpen = NULL;
                fDistList = FALSE;
                break;

            case MAPI_DISTLIST:
                iCreateTemplate = iconPR_DEF_CREATE_DL;
                lpIIDOpen = (LPIID)&IID_IDistList;
                fDistList = TRUE;

                break;
        }


        // Open the entry
        if (HR_FAILED(hResult = lpAdrBookWAB->lpVtbl->OpenEntry(lpAdrBookWAB,
          cbEID,
          lpEID,
          lpIIDOpen,
          MAPI_MODIFY,      // need to do SetProps inside Filter routine, but won't save them.
          &ulObjectTypeOpen,
          (LPUNKNOWN *)&lpMailUserWAB))) {
            DebugTrace("OpenEntry(WAB MailUser) -> %x\n", GetScode(hResult));
            goto exit;
        }
        // If DISTLIST, assume we got lpMailUser until we need lpDistList.

        Assert(lpMailUserWAB);
        Assert(ulObjectType == ulObjectTypeOpen);

        //
        // NOTE: Must not fail between here and HrFilterExportMailUserProps because
        // we will end up freeing lpProps with MAPIFreeBuffer.
        //
        // Get and filter the property array here
        if (hResult = HrFilterExportMailUserProps(&cProps, &lpProps, lpMailUserWAB, &fDistList)) {
            lpDisplayName = FindStringInProps(lpProps, cProps, PR_DISPLAY_NAME);
            lpEmailAddress = FindStringInProps(lpProps, cProps, PR_EMAIL_ADDRESS);

            if (HandleExportError(hwnd,
              0,
              hResult,
              lpDisplayName,
              lpEmailAddress,
              lpExportOptions)) {
                hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                goto exit;
            }
        }

        // Find some interesting property values here
        lpDisplayName = FindStringInProps(lpProps, cProps, PR_DISPLAY_NAME);
        lpEmailAddress = FindStringInProps(lpProps, cProps, PR_EMAIL_ADDRESS);


        if (ulObjectType == MAPI_DISTLIST && ! fDistList) {
            // Filter must have changed this to a mailuser.
            ulObjectType = MAPI_MAILUSER;
            iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
            lpIIDOpen = NULL;
        }

        if (fDistList) {
            ulCreateFlags = CREATE_CHECK_DUP_LOOSE;

            // PAB can't detect collisions on DL SaveChanges.
            // See if this is a duplicate:
            if (! HR_FAILED(hResult = FindPABEntry(lpContainerMAPI,
              MAPI_DISTLIST,
              lpDisplayName,
              NULL,
              &cbEIDDup,
              &lpEIDDup))) {

                // Found a duplicate.  Keep track of it!
            }
        } else {
            ulCreateFlags = CREATE_CHECK_DUP_STRICT;
        }

        //
        // NOTE: lpProps after this point is MAPI Allocated rather than WAB allocated.
        //

        if (HR_FAILED(hResult = lpContainerMAPI->lpVtbl->CreateEntry(lpContainerMAPI,
          lpCreateEIDsMAPI[iCreateTemplate].Value.bin.cb,
          (LPENTRYID)lpCreateEIDsMAPI[iCreateTemplate].Value.bin.lpb,
          ulCreateFlags,
          &lpMailUserMAPI))) {
            DebugTrace("CreateEntry(MAPI MailUser) -> %x\n", GetScode(hResult));
            goto exit;
        }

        if (fDistList) {
            // Update status message
            if (*szBufferDLMessage == '\0') {   // only load once, then keep it.
                LoadString(hInst, IDS_MESSAGE_EXPORTING_DL, szBufferDLMessage, sizeof(szBufferDLMessage));
            }
            if (lpDisplayName) {
                if (lpszMessage = LocalAlloc(LMEM_FIXED, lstrlen(szBufferDLMessage) + 1 + lstrlen(lpDisplayName))) {
                    wsprintf(lpszMessage, szBufferDLMessage, lpDisplayName);
                    DebugTrace("Status Message: %s\n", lpszMessage);
                    if (! SetDlgItemText(hwnd, IDC_Message, lpszMessage)) {
                        DebugTrace("SetDlgItemText -> %u\n", GetLastError());
                    }
                    LocalFree(lpszMessage);
                }
            }
        }

        if (! lpEIDDup) {
            // If this was a DL which we know already exists, don't even bother writing it,
            // just fall through to the collision pass.  Otherwise, try to set the props
            // and save it... if it fails, we'll get an hResult=MAPI_E_COLLISION.

            // Set the properties on the PAB entry
            if (HR_FAILED(hResult = lpMailUserMAPI->lpVtbl->SetProps(lpMailUserMAPI,
              cProps,                   // cValues
              lpProps,                  // property array
              NULL))) {                 // problems array
                DebugTrace("ExportEntry:SetProps(MAPI) -> %x\n", GetScode(hResult));
                goto exit;
            }


            // Save the new wab mailuser or distlist
            if (HR_FAILED(hResult = lpMailUserMAPI->lpVtbl->SaveChanges(lpMailUserMAPI,
              KEEP_OPEN_READONLY | FORCE_SAVE))) {
                DebugTrace("SaveChanges -> %x\n", GetScode(hResult));
            } else {
                fCreatedNew = TRUE;
            }
        }

        //
        // Handle Collisions
        //
        if (lpEIDDup || GetScode(hResult) == MAPI_E_COLLISION) {
            // Find the display name
            if (! lpDisplayName) {
                DebugTrace("Collision, but can't find PR_DISPLAY_NAME in entry\n");
                goto exit;
            }

            // Do we need to prompt?
            switch (lpExportOptions->ReplaceOption) {
                case WAB_REPLACE_PROMPT:
                    // Prompt user with dialog.  If they say YES, we should
                    // recurse with the FORCE flag set.

                    RI.lpszDisplayName = lpDisplayName;
                    RI.lpszEmailAddress = lpEmailAddress;
                    RI.ConfirmResult = CONFIRM_ERROR;
                    RI.fExport = TRUE;
                    RI.lpImportOptions = lpExportOptions;

                    DialogBoxParam(hInst,
                      MAKEINTRESOURCE(IDD_ExportReplace),
                      hwnd,
                      ReplaceDialogProc,
                      (LPARAM)&RI);

                    switch (RI.ConfirmResult) {
                        case CONFIRM_YES:
                        case CONFIRM_YES_TO_ALL:
                            fForceReplace = TRUE;
                            break;

                        case CONFIRM_ABORT:
                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                            goto exit;

                        default:
                            // NO
                            break;
                    }
                    break;

                case WAB_REPLACE_ALWAYS:
                    fForceReplace = TRUE;
                    break;
            }

            if (fForceReplace) {
                SBinary sbEntry;
                ENTRYLIST EntryList = {1, &sbEntry};

                // Find the existing PAB entry and delete it.
                if (! lpDisplayName) {
                    lpDisplayName = (LPTSTR)szEmpty;
                }

                if (! lpEIDDup) {
                    if (HR_FAILED(hResult = FindPABEntry(lpContainerMAPI,
                      ulObjectType,
                      lpDisplayName,
                      lpEmailAddress,
                      &cbEIDDup,
                      &lpEIDDup))) {
                        // Hey, couldn't find it.  Just pretend it isn't there,
                        // go on and create the new one anyway.
                    }
                }
                if (lpEIDDup) {
                    // Delete this entry.
                    sbEntry.cb = cbEIDDup;
                    sbEntry.lpb = (LPBYTE)lpEIDDup;

                    if (HR_FAILED(hResult = lpContainerMAPI->lpVtbl->DeleteEntries(lpContainerMAPI,
                      &EntryList,
                      0))) {
                        DebugTrace("PAB DeleteEntries(%s) -> %x\n", lpDisplayName);
                    }

                    if (lpEIDDup) {
                        MAPIFreeBuffer(lpEIDDup);
                    }
                }

                lpMailUserMAPI->lpVtbl->Release(lpMailUserMAPI);
                lpMailUserMAPI = NULL;

                // Create a new entry without the collision flags
                if (HR_FAILED(hResult = lpContainerMAPI->lpVtbl->CreateEntry(lpContainerMAPI,
                  lpCreateEIDsMAPI[iCreateTemplate].Value.bin.cb,
                  (LPENTRYID)lpCreateEIDsMAPI[iCreateTemplate].Value.bin.lpb,
                  0,
                  &lpMailUserMAPI))) {
                    DebugTrace("CreateEntry(MAPI MailUser) -> %x\n", GetScode(hResult));
                    goto exit;
                }

                // Set the properties on the PAB entry
                if (HR_FAILED(hResult = lpMailUserMAPI->lpVtbl->SetProps(lpMailUserMAPI,
                  cProps,                   // cValues
                  lpProps,                  // property array
                  NULL))) {                 // problems array
                    DebugTrace("ExportEntry:SetProps(MAPI) -> %x\n", GetScode(hResult));
                    goto exit;
                }

                // Save the new wab mailuser or distlist
                if (HR_FAILED(hResult = lpMailUserMAPI->lpVtbl->SaveChanges(lpMailUserMAPI,
                  KEEP_OPEN_READONLY | FORCE_SAVE))) {
                    DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
                } else {
                    fCreatedNew = TRUE;
                }
            } else {
                fDuplicate = TRUE;
            }

            hResult = hrSuccess;
        }

        if (fCreatedNew) {
            // What is the ENTRYID of our new entry?
            if ((hResult = lpMailUserMAPI->lpVtbl->GetProps(lpMailUserMAPI,
              (LPSPropTagArray)&ptaEid,
              0,
              &cEIDPropMAPI,
              &lpEIDPropMAPI))) {
                DebugTrace("ExportEntry: GetProps(MAPI ENTRYID) -> %x\n", GetScode(hResult));
                goto exit;
            }

            Assert(cEIDPropMAPI);
            Assert(lpEIDPropMAPI[ieidPR_ENTRYID].ulPropTag == PR_ENTRYID);

            cbEIDNew = lpEIDPropMAPI[0].Value.bin.cb;

            if (FAILED(sc = MAPIAllocateBuffer(cbEIDNew, &lpEIDNew))) {
                DebugTrace("ExportEntry: MAPIAllocateBuffer(MAPI ENTRYID) -> %x\n", sc);
                hResult = ResultFromScode(sc);
                goto exit;
            }

            // Copy the new EntryID into the buffer
            CopyMemory(lpEIDNew, lpEIDPropMAPI[0].Value.bin.lpb, cbEIDNew);
        }


        //
        // If this is a DISTLIST, fill it in.
        //
        if (fDistList && ! fDuplicate && cbEIDNew) {
            lpDistListWAB = (LPDISTLIST)lpMailUserWAB;    // This is REALLY a DISTLIST object
            // DO NOT Release this!

            // Open the new WAB DL as a DISTLIST object
            if (HR_FAILED(hResult = lpContainerMAPI->lpVtbl->OpenEntry(lpContainerMAPI,
              cbEIDNew,
              lpEIDNew,
              (LPIID)&IID_IDistList,
              MAPI_MODIFY,
              &ulObjectTypeOpen,
              (LPUNKNOWN*)&lpDistListMAPI))) {
                DebugTrace("ExportEntry: MAPI OpenEntry(IID_DistList) -> %x\n", GetScode(hResult));
                goto exit;
            }
            Assert(lpDistListMAPI);


            // For each entry in the DL:
            //  Migrate the entry (MailUser or DL) recursively
            //  Add new entryid to DL contents
            if (HR_FAILED(hResult = lpDistListWAB->lpVtbl->GetContentsTable(lpDistListWAB,
              0,    // ulFlags
              &lpDLTableWAB))) {
                DebugTrace("ExportEntry:GetContentsTable(WAB) -> %x\n", GetScode(hResult));
                goto exit;
            }


            // Set the columns to those we're interested in
            if (hResult = lpDLTableWAB->lpVtbl->SetColumns(lpDLTableWAB,
              (LPSPropTagArray)&ptaColumns,
              0)) {
                DebugTrace("WAB SetColumns(DL Table) -> %x\n", GetScode(hResult));
                goto exit;
            }

            cRows = 1;
            while (cRows) {
                // Get the next DL entry
                if (hResult = lpDLTableWAB->lpVtbl->QueryRows(lpDLTableWAB,
                  1,    // one row at a time
                  0,    // ulFlags
                  &lpRow)) {
                    DebugTrace("DL: QueryRows -> %x\n", GetScode(hResult));
                    goto exit;
                }

                if (lpRow && lpRow->cRows) {
                    Assert(lpRow->cRows == 1);
                    Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
                    Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
                    Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

                    if (lpRow) {
                        if (cRows = lpRow->cRows) { // yes, single '='
                            hResult = ExportEntry(hwnd,
                              lpAdrBookWAB,
                              lpContainerMAPI,
                              lpCreateEIDsMAPI,
                              lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].Value.l,
                              (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb,
                              lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                              &lpeidDLMAPI,        // returned new or existing entry
                              &cbeidDLMAPI,
                              TRUE,
                              FALSE);
                            if (hResult) {
                                if (HandleExportError(hwnd,
                                  0,
                                  hResult,
                                  lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ,
                                  PropStringOrNULL(&lpRow->aRow[0].lpProps[iptaColumnsPR_EMAIL_ADDRESS]),
                                  lpExportOptions)) {
                                    hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                    break;  // out of loop
                                } else {
                                    hResult = hrSuccess;
                                }
                            }
                        } // else, drop out of loop, we're done.
                        WABFreeProws(lpRow);
                        lpRow = NULL;

                        if (HR_FAILED(hResult)) {
                            // This entry couldn't be created.  Ignore it.
                            DebugTrace("Coudln't create DL entry -> %x\n", GetScode(hResult));
                            hResult = hrSuccess;
                            continue;
                        }

                        // Add the Entry to the DL using the new entry's EntryID
                        if (cbeidDLMAPI && lpeidDLMAPI) {
                            // BUGBUG: Don't bother with this one if this is a duplicate entry.
                            if (HR_FAILED(hResult = lpDistListMAPI->lpVtbl->CreateEntry(lpDistListMAPI,
                              cbeidDLMAPI,
                              lpeidDLMAPI,
                              0,                // allow duplicates here
                              &lpEntryMAPI))) {
                                DebugTrace("Couldn't create new entry in DL -> %x\n", GetScode(hResult));
                                break;
                            }

                            hResult = lpEntryMAPI->lpVtbl->SaveChanges(lpEntryMAPI, FORCE_SAVE);

                            if (lpEntryMAPI) {
                                lpEntryMAPI->lpVtbl->Release(lpEntryMAPI);
                                lpEntryMAPI = NULL;
                            }
                        }

                        if (lpeidDLMAPI) {
                            MAPIFreeBuffer(lpeidDLMAPI);
                            lpeidDLMAPI = NULL;
                        }
                    }
                } else {
                    break;  // done
                }
            }
        }
    } else {
        DebugTrace("Found a duplicate EntryID\n");
    }

    //
    // Save the entryid to the list and return a buffer with it
    //
    if (cbEIDNew && lpEIDNew) {                         // We created one?
        // created one
    } else if (fDuplicateEID && lListIndex != -1) {     // Was it in the list?
        cbEIDNew  = lpEntriesSeen[lListIndex].sbinWAB.cb;
        if (FAILED(sc = MAPIAllocateBuffer(cbEIDNew, &lpEIDNew))) {
            DebugTrace("ExportEntry: WABAllocateBuffer(WAB ENTRYID) -> %x\n", sc);
            // ignore
            cbEIDNew = 0;
        } else {
            // Copy the EntryID from the list into the buffer
            CopyMemory(lpEIDNew, lpEntriesSeen[lListIndex].sbinWAB.lpb, cbEIDNew);
        }

    } else if (fDuplicate) {                            // Was it a duplicate
        FindPABEntry(lpContainerMAPI,
          ulObjectType,
          lpDisplayName,
          lpEmailAddress,
          &cbEIDNew,
          &lpEIDNew);

#ifdef OLD_STUFF
        FindExistingPABEntry(lpProps, cProps, lpContainerMAPI, &lpEIDNew, &cbEIDNew);
#endif // OLD_STUFF
        // ignore errors since the lpEIDNew and cbEIDNew will be nulled out
    }

    // Update the seen list
    if (! fDuplicateEID) {
        MarkPABEntryInList(cbEIDNew, lpEIDNew, lListIndex);
    }

    // If caller requested the entryid's, return them
    if (lpcbEIDMAPI && lppEIDMAPI) {
        *lpcbEIDMAPI = cbEIDNew;
        *lppEIDMAPI = lpEIDNew;
        fReturnEID = TRUE;          // don't free it
    }

exit:
    //
    // Cleanup MAPI stuff
    //
    if (lpProps) {
        MAPIFreeBuffer(lpProps);
    }

    if (lpEIDPropMAPI) {
        MAPIFreeBuffer(lpEIDPropMAPI);
    }

    if (lpEIDNew && ! fReturnEID) {
        MAPIFreeBuffer(lpEIDNew);
    }

    if (lpeidDLMAPI) {
        MAPIFreeBuffer(lpeidDLMAPI);
    }

    if (lpMailUserMAPI) {
        lpMailUserMAPI->lpVtbl->Release(lpMailUserMAPI);
    }

    if (lpDistListMAPI) {
        lpDistListMAPI->lpVtbl->Release(lpDistListMAPI);
    }

    //
    // Cleanup WAB stuff
    //
    if (lpRow) {
        WABFreeProws(lpRow);
    }

    if (lpDLTableWAB) {
        lpDLTableWAB->lpVtbl->Release(lpDLTableWAB);
    }

    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
    }

// Do not release this... It is the same object as lpMailUserWAB!
//    if (lpDistListWAB) {
//        lpDistListWAB->lpVtbl->Release(lpDistListWAB);
//    }

    if (! HR_FAILED(hResult)) {
        hResult = hrSuccess;
    }

    return(hResult);
}


HRESULT PABExport(HWND hWnd,
  LPADRBOOK lpAdrBook,
  LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPWAB_EXPORT_OPTIONS lpOptions) {
    BOOL fDone = FALSE;
    HRESULT hResult = hrSuccess;

    lpAdrBookWAB = lpAdrBook;
    lpfnProgressCB = lpProgressCB;
   lpExportOptions = lpOptions;

    // Setup memory allocators
    SetGlobalBufferFunctions(lpWABObject);


    // Prime the state machine
    State = STATE_EXPORT_MU;


    while (! fDone) {
        switch (State) {
            case STATE_EXPORT_MU:
                StateExportMU(hWnd);
                break;

            case STATE_EXPORT_NEXT_MU:
                StateExportNextMU(hWnd);
                break;

            case STATE_EXPORT_DL:
                StateExportDL(hWnd);
                break;

            case STATE_EXPORT_NEXT_DL:
                StateExportNextDL(hWnd);
                break;

            case STATE_EXPORT_FINISH:
                StateExportFinish(hWnd);
                fDone = TRUE;
                break;

            case STATE_EXPORT_ERROR:
                StateExportError(hWnd);
                // BUGBUG: Should set hResult to something
                break;

            case STATE_EXPORT_CANCEL:
                StateExportCancel(hWnd);
                break;

            default:
                DebugTrace("Unknown state %u in PABExport\n", State);
                Assert(FALSE);
                break;
        }
    }

    return(hResult);
}


HRESULT PABImport(HWND hWnd,
  LPADRBOOK lpAdrBook,
  LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPWAB_IMPORT_OPTIONS lpOptions) {

    BOOL fDone = FALSE;
    HRESULT hResult = hrSuccess;

    lpAdrBookWAB = lpAdrBook;
    lpfnProgressCB = lpProgressCB;
    lpImportOptions = lpOptions;

    // Setup memory allocators
    SetGlobalBufferFunctions(lpWABObject);


    // Prime the state machine
    State = STATE_IMPORT_MU;


    while (! fDone) {
        switch (State) {
            case STATE_IMPORT_MU:
                StateImportMU(hWnd);
                break;

            case STATE_IMPORT_NEXT_MU:
                StateImportNextMU(hWnd);
                break;

            case STATE_IMPORT_DL:
                StateImportDL(hWnd);
                break;

            case STATE_IMPORT_NEXT_DL:
                StateImportNextDL(hWnd);
                break;

            case STATE_IMPORT_FINISH:
                StateImportFinish(hWnd);
                fDone = TRUE;
                break;

            case STATE_IMPORT_ERROR:
                StateImportError(hWnd);
                // BUGBUG: Should set hResult to something
                break;

            case STATE_IMPORT_CANCEL:
                StateImportCancel(hWnd);
                break;

            default:
                DebugTrace("Unknown state %u in PABImport\n", State);
                Assert(FALSE);
                break;
        }
    }

    return(hResult);
}

/*
 - HrLoadPrivateWABProps
 -
*    Private function to load Conferencing Named properties
*    as globals up front
*
*
*/
HRESULT HrLoadPrivateWABPropsForCSV(LPADRBOOK lpIAB)
{
    HRESULT hr = E_FAIL;
    LPSPropTagArray lpta = NULL;
    SCODE sc = 0;
    ULONG i, uMax = prWABConfMax, nStartIndex = OLK_NAMEDPROPS_START;
    LPMAPINAMEID  *lppConfPropNames = NULL;
    sc = WABAllocateBuffer(sizeof(LPMAPINAMEID) * uMax, (LPVOID *) &lppConfPropNames);
    //sc = WABAllocateBuffer(sizeof(LPMAPINAMEID) * uMax, (LPVOID *) &lppConfPropNames);
    if( (HR_FAILED(hr = ResultFromScode(sc))) )
        goto err;    

    for(i=0;i< uMax;i++)
    {
        //sc = WABAllocateMore(sizeof(MAPINAMEID), lppConfPropNames, &(lppConfPropNames[i]));
        sc = WABAllocateMore(  sizeof(MAPINAMEID), lppConfPropNames, &(lppConfPropNames[i]));
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto err;
        }
        lppConfPropNames[i]->lpguid = (LPGUID) &PS_Conferencing;
        lppConfPropNames[i]->ulKind = MNID_ID;
        lppConfPropNames[i]->Kind.lID = nStartIndex + i;
    }
    // Load the set of conferencing named props
    //
    if( HR_FAILED(hr = (lpIAB)->lpVtbl->GetIDsFromNames(lpIAB, uMax, lppConfPropNames,
        MAPI_CREATE, &lpta) ))
        goto err;
    
    if(lpta)
    {
        // Set the property types on the returned props
        PR_SERVERS                  = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABConfServers],        PT_MV_TSTRING);
    }
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].ulPropTag = PR_SERVERS;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].fChosen   = FALSE;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].ids       = ids_ExportConfServer;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].lpszName  = NULL;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].lpszCSVName = NULL;

err:
    if(lpta)
        WABFreeBuffer( lpta );
    if( lppConfPropNames )
        WABFreeBuffer( lppConfPropNames );
        //WABFreeBuffer(lpta);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\mapilayr.c ===
/*
 * MAPILAYR.C
 *
 * Layer on top of MAPI calls
 *
 * Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * History:
 *      11/14/96    BruceK  First version to allow wab migration without mapi32.dll
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include "wabimp.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"


typedef SCODE (STDMETHODCALLTYPE FREEPROWS)(
    LPSRowSet lpRows
);
typedef FREEPROWS *LPFREEPROWS;

typedef SCODE (STDMETHODCALLTYPE FREEPADRLIST)(
    LPADRLIST lpAdrList
);
typedef FREEPADRLIST *LPFREEPADRLIST;

typedef SCODE (STDMETHODCALLTYPE SCCOPYPROPS)(
    int cValues,
    LPSPropValue lpPropArray,
    LPVOID lpvDst,
    ULONG FAR *lpcb	
);
typedef SCCOPYPROPS *LPSCCOPYPROPS;

typedef SCODE (STDMETHODCALLTYPE SCCOUNTPROPS)(
    int cValues,
    LPSPropValue lpPropArray,
    ULONG FAR *lpcb
);
typedef SCCOUNTPROPS *LPSCCOUNTPROPS;


static LPMAPIINITIALIZE lpfnMAPIInitialize = NULL;
static LPMAPILOGONEX lpfnMAPILogonEx = NULL;
static LPMAPIALLOCATEBUFFER lpfnMAPIAllocateBuffer = NULL;
static LPMAPIALLOCATEMORE lpfnMAPIAllocateMore = NULL;
static LPMAPIFREEBUFFER lpfnMAPIFreeBuffer = NULL;
static LPFREEPROWS lpfnFreeProws = NULL;
static LPFREEPADRLIST lpfnFreePadrlist = NULL;
static LPSCCOPYPROPS lpfnScCopyProps = NULL;
static LPSCCOUNTPROPS lpfnScCountProps = NULL;


static HINSTANCE hinstMAPIDll = NULL;

// Constant strings
const TCHAR szMapiDll[] = TEXT("MAPI32.DLL");
const TCHAR szMAPIAllocateBuffer[] = TEXT("MAPIAllocateBuffer");
const TCHAR szMAPIAllocateMore[] = TEXT("MAPIAllocateMore");
const TCHAR szMAPIFreeBuffer[] = TEXT("MAPIFreeBuffer");
const TCHAR szMAPIInitialize[] = TEXT("MAPIInitialize");
const TCHAR szMAPILogonEx[] = TEXT("MAPILogonEx");

#if defined (_ALPHA_) || defined (ALPHA) // Bug:63053
const TCHAR szFreeProws[] = TEXT("FreeProws");
const TCHAR szFreePadrlist[] = TEXT("FreePadrlist");
const TCHAR szScCopyProps[] = TEXT("ScCopyProps");
const TCHAR szScCountProps[] = TEXT("ScCountProps");
#else
const TCHAR szFreeProws[] = TEXT("FreeProws@4");
const TCHAR szFreePadrlist[] = TEXT("FreePadrlist@4");
const TCHAR szScCopyProps[] = TEXT("ScCopyProps@16");
const TCHAR szScCountProps[] = TEXT("ScCountProps@12");
#endif


HRESULT MAPIInitialize(LPVOID lpMapiInit) {
    HRESULT hResult = hrSuccess;

    // If MAPI DLL is not loaded, do so now.
    if (! hinstMAPIDll) {

        if (! (hinstMAPIDll = LoadLibrary(szMapiDll))) {
            DWORD dwErr = GetLastError();
            DebugTrace("Couldn't load MAPI dll [%s] -> %u\n", szMapiDll, dwErr);
            switch (dwErr) {
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_OUTOFMEMORY:
                    hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                    break;

                case ERROR_HANDLE_DISK_FULL:
                case ERROR_DISK_FULL:
                    hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_DISK);
                    break;

                default:
                case ERROR_FILE_NOT_FOUND:
                case ERROR_PATH_NOT_FOUND:
                    hResult = ResultFromScode(MAPI_E_NOT_FOUND);
                    break;
            }
            goto exit;
        } else {
            // Get the function pointers
            if (! (lpfnMAPIInitialize = (LPMAPIINITIALIZE)GetProcAddress(hinstMAPIDll,
              szMAPIInitialize))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIInitialize, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPILogonEx = (LPMAPILOGONEX)GetProcAddress(hinstMAPIDll,
              szMAPILogonEx))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPILogonEx, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPIAllocateBuffer = (LPMAPIALLOCATEBUFFER)GetProcAddress(hinstMAPIDll,
              szMAPIAllocateBuffer))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIAllocateBuffer, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPIAllocateMore= (LPMAPIALLOCATEMORE)GetProcAddress(hinstMAPIDll,
              szMAPIAllocateMore))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIAllocateMore, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPIFreeBuffer = (LPMAPIFREEBUFFER)GetProcAddress(hinstMAPIDll,
              szMAPIFreeBuffer))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIFreeBuffer, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnFreeProws= (LPFREEPROWS)GetProcAddress(hinstMAPIDll,
              szFreeProws))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szFreeProws, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnFreePadrlist= (LPFREEPADRLIST)GetProcAddress(hinstMAPIDll,
              szFreePadrlist))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szFreePadrlist, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnScCopyProps= (LPSCCOPYPROPS)GetProcAddress(hinstMAPIDll,
              szScCopyProps))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szScCopyProps, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnScCountProps = (LPSCCOUNTPROPS)GetProcAddress(hinstMAPIDll,
              szScCountProps))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szScCountProps, szMapiDll, GetLastError());
                goto exit;
            }
        }
    }

exit:
    if (! lpfnMAPIInitialize ||
      ! lpfnMAPILogonEx ||
      ! lpfnMAPIAllocateMore ||
      ! lpfnMAPIAllocateBuffer ||
      ! lpfnMAPIFreeBuffer ||
      ! lpfnFreeProws ||
      ! lpfnFreePadrlist ||
      ! lpfnScCopyProps ||
      ! lpfnScCountProps) {
        // Bad news.  Clean up and fail.
        if (hinstMAPIDll) {
            // unload the dll
            FreeLibrary(hinstMAPIDll);
            hinstMAPIDll = NULL;
            lpfnMAPIInitialize = NULL;
            lpfnMAPILogonEx = NULL;
            lpfnMAPIAllocateMore = NULL;
            lpfnMAPIAllocateBuffer = NULL;
            lpfnMAPIFreeBuffer = NULL;
            lpfnFreeProws = NULL;
            lpfnFreePadrlist = NULL;
            lpfnScCopyProps = NULL;
            lpfnScCountProps = NULL;
        }
        if (hResult == hrSuccess) {
            hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        }

        return(hResult);
    }

    return(lpfnMAPIInitialize(lpMapiInit));
}


HRESULT MAPILogonEx(
  ULONG_PTR ulUIParam,
  LPTSTR lpszProfileName,
  LPTSTR lpszPassword,
  ULONG ulFlags,
  LPMAPISESSION FAR * lppSession
) {
    Assert(lpfnMAPILogonEx);
    if (lpfnMAPILogonEx) {
        return(lpfnMAPILogonEx(ulUIParam,
          lpszProfileName,
          lpszPassword,
          ulFlags,
          lppSession));
    } else {
        return(ResultFromScode(MAPI_E_NOT_INITIALIZED));
    }
}

SCODE MAPIAllocateBuffer(
  ULONG cbSize,
  LPVOID FAR * lppBuffer
) {
    Assert(lpfnMAPIAllocateBuffer);
    if (lpfnMAPIAllocateBuffer) {
        return(lpfnMAPIAllocateBuffer(cbSize,
          lppBuffer));
    } else {
        return(MAPI_E_NOT_INITIALIZED);
    }
}

SCODE MAPIAllocateMore(
  ULONG cbSize,
  LPVOID lpObject,
  LPVOID FAR * lppBuffer
) {
    Assert(lpfnMAPIAllocateMore);
    if (lpfnMAPIAllocateMore) {
        return(lpfnMAPIAllocateMore(cbSize,
          lpObject,
          lppBuffer));
    } else {
        return(MAPI_E_NOT_INITIALIZED);
    }
}

ULONG MAPIFreeBuffer(LPVOID lpBuffer) {
    Assert(lpfnMAPIFreeBuffer);
    if (lpfnMAPIFreeBuffer) {
        return(lpfnMAPIFreeBuffer(lpBuffer));
    } else {
        return((ULONG)MAPI_E_NOT_INITIALIZED);
    }
}

STDAPI_(SCODE)ScCountProps(int cValues, LPSPropValue lpPropArray, ULONG FAR *lpcb) {
    Assert(lpfnScCountProps);
    if (lpfnScCountProps) {
        return(lpfnScCountProps(cValues, lpPropArray, lpcb));
    } else {
        return((ULONG)MAPI_E_NOT_INITIALIZED);
    }
}

STDAPI_(SCODE)ScCopyProps(int cValues, LPSPropValue lpPropArray, LPVOID lpvDst,
  ULONG FAR *lpcb) {
    Assert(lpfnScCopyProps);
    if (lpfnScCopyProps) {
        return(lpfnScCopyProps(cValues, lpPropArray, lpvDst, lpcb));
    } else {
        return((ULONG)MAPI_E_NOT_INITIALIZED);
    }

}

STDAPI_(void)FreeProws(LPSRowSet lpRows) {
    Assert(lpfnFreeProws);
    if (lpfnFreeProws) {
        lpfnFreeProws(lpRows);
    }
}

STDAPI_(void)FreePadrlist(LPADRLIST lpadrlist) {
    Assert(lpfnFreePadrlist);
    if (lpfnFreePadrlist) {
        lpfnFreePadrlist(lpadrlist);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\wabguid.c ===
// This builds wabguid.obj, which can be linked into a DLL
// or EXE to provide the MAPI GUIDs. It contains all GUIDs
// defined by WAB.


#define USES_IID_IUnknown
#define USES_IID_IMAPIUnknown
#define USES_IID_IMAPITable
#define USES_IID_INotifObj
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPIStatus
#define USES_IID_IAddrBook
#define USES_IID_IMailUser
#define USES_IID_IMAPIContainer
#define USES_IID_IABContainer
#define USES_IID_IDistList
#define USES_IID_IMAPITableData
#define USES_IID_IMAPIAdviseSink


#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#define INITGUID
#include <windows.h>
#include <wab.h>
#include <wabguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\_comctl.h ===
/*

	_comctl.h

*/

// This commctrl flag enables us to be compiled with the new commctrl headers
// yet work with the old commctrl dlls
#ifdef _WIN32_IE
#undef _WIN32_IE
#endif
#define _WIN32_IE 0x0300
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\emsabtag.h ===
/*
** --emsabtag.h---------------------------------------------------------------
**
**  Property tag definitions for standard properties of Exchange Address
**  Book objects.
**
**  Note: These proptags are only valid when talking directly to the
**  Exchange Server Address Book. They are specifically NOT valid when
**  trying to read properties from an object copied into another address
**  book provider (the Personal Address Book, for example).
**
**  Copyright (c) Microsoft Corp. 1986-1996. All rights reserved.
** ---------------------------------------------------------------------------
*/

#ifndef _EMSABTAG_H
#define _EMSABTAG_H

/*    
 * Flags for ulInterfaceOptions on OpenProperty   
 */
#define AB_SHOW_PHANTOMS                      2
#define AB_SHOW_OTHERS                            4

/*    
 * Flags for ulFlag on ResolveNames               
 */
#define EMS_AB_ADDRESS_LOOKUP                 0x01

/* 
 * Constructed, but externally visible. 
 */
#define PR_EMS_AB_SERVER                      PROP_TAG(PT_TSTRING,      0xFFFE)
#define PR_EMS_AB_SERVER_A                    PROP_TAG(PT_STRING8,      0xFFFE)
#define PR_EMS_AB_SERVER_W                    PROP_TAG(PT_UNICODE,      0xFFFE)
#define PR_EMS_AB_CONTAINERID                 PROP_TAG(PT_LONG,         0xFFFD)
#define PR_EMS_AB_DOS_ENTRYID                 PR_EMS_AB_CONTAINERID
#define PR_EMS_AB_PARENT_ENTRYID              PROP_TAG(PT_BINARY,       0xFFFC)
#define PR_EMS_AB_IS_MASTER                   PROP_TAG(PT_BOOLEAN,      0xFFFB)
#define PR_EMS_AB_OBJECT_OID                  PROP_TAG(PT_BINARY,       0xFFFA)
#define PR_EMS_AB_HIERARCHY_PATH              PROP_TAG(PT_TSTRING,      0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_A            PROP_TAG(PT_STRING8,      0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_W            PROP_TAG(PT_UNICODE,      0xFFF9)
#define PR_EMS_AB_CHILD_RDNS                  PROP_TAG(PT_MV_STRING8,   0xFFF8)

#define MIN_EMS_AB_CONSTRUCTED_PROP_ID        0xFFF8

#define PR_EMS_AB_OTHER_RECIPS                PROP_TAG(PT_OBJECT,       0xF000)

/* 
 * Prop tags defined in the schema. 
 */
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE      PROP_TAG(PT_TSTRING,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A    PROP_TAG(PT_STRING8,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W    PROP_TAG(PT_UNICODE,      0x39FF)

#define PR_EMS_AB_ACCESS_CATEGORY             PROP_TAG(PT_LONG,         0x8044)
#define PR_EMS_AB_ACTIVATION_SCHEDULE         PROP_TAG(PT_BINARY,       0x8045)
#define PR_EMS_AB_ACTIVATION_STYLE            PROP_TAG(PT_LONG,         0x8046)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE PROP_TAG(PT_BINARY,       0x8017)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS PROP_TAG(PT_BINARY, 0x8047)
#define PR_EMS_AB_ADDRESS_SYNTAX              PROP_TAG(PT_BINARY,       0x8018)
#define PR_EMS_AB_ADDRESS_TYPE                PROP_TAG(PT_TSTRING,      0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_A              PROP_TAG(PT_STRING8,      0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_W              PROP_TAG(PT_UNICODE,      0x8048)
#define PR_EMS_AB_ADMD                        PROP_TAG(PT_TSTRING,      0x8049)
#define PR_EMS_AB_ADMD_A                      PROP_TAG(PT_STRING8,      0x8049)
#define PR_EMS_AB_ADMD_W                      PROP_TAG(PT_UNICODE,      0x8049)
#define PR_EMS_AB_ADMIN_DESCRIPTION           PROP_TAG(PT_TSTRING,      0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_A         PROP_TAG(PT_STRING8,      0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_W         PROP_TAG(PT_UNICODE,      0x804A)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME          PROP_TAG(PT_TSTRING,      0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_A        PROP_TAG(PT_STRING8,      0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_W        PROP_TAG(PT_UNICODE,      0x804B)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL         PROP_TAG(PT_TSTRING,      0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_A       PROP_TAG(PT_STRING8,      0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_W       PROP_TAG(PT_UNICODE,      0x804C)
#define PR_EMS_AB_ALIASED_OBJECT_NAME         PROP_TAG(PT_TSTRING,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_A       PROP_TAG(PT_STRING8,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_W       PROP_TAG(PT_UNICODE,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_O       PROP_TAG(PT_OBJECT,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_T       PROP_TAG(PT_TSTRING,      0x804D)
#define PR_EMS_AB_ALT_RECIPIENT               PROP_TAG(PT_TSTRING,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_A             PROP_TAG(PT_STRING8,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_W             PROP_TAG(PT_UNICODE,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_O             PROP_TAG(PT_OBJECT,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_T             PROP_TAG(PT_TSTRING,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_BL            PROP_TAG(PT_MV_TSTRING,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_A          PROP_TAG(PT_MV_STRING8,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_W          PROP_TAG(PT_MV_UNICODE,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_O          PROP_TAG(PT_OBJECT,       0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_T          PROP_TAG(PT_MV_TSTRING,   0x804F)
#define PR_EMS_AB_ANCESTOR_ID                 PROP_TAG(PT_BINARY,       0x8050)
#define PR_EMS_AB_ASSOC_NT_ACCOUNT            PROP_TAG(PT_BINARY,       0x8027)
#define PR_EMS_AB_ASSOC_REMOTE_DXA            PROP_TAG(PT_MV_TSTRING,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_A          PROP_TAG(PT_MV_STRING8,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_W          PROP_TAG(PT_MV_UNICODE,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_O          PROP_TAG(PT_OBJECT,       0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_T          PROP_TAG(PT_MV_TSTRING,   0x8051)
#define PR_EMS_AB_ASSOCIATION_LIFETIME        PROP_TAG(PT_LONG,         0x8052)
#define PR_EMS_AB_AUTH_ORIG_BL                PROP_TAG(PT_MV_TSTRING,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_A              PROP_TAG(PT_MV_STRING8,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_W              PROP_TAG(PT_MV_UNICODE,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_O              PROP_TAG(PT_OBJECT,       0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_T              PROP_TAG(PT_MV_TSTRING,   0x8053)
#define PR_EMS_AB_AUTHORITY_REVOCATION_LIST   PROP_TAG(PT_MV_BINARY,    0x8026)
#define PR_EMS_AB_AUTHORIZED_DOMAIN           PROP_TAG(PT_TSTRING,      0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_A         PROP_TAG(PT_STRING8,      0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_W         PROP_TAG(PT_UNICODE,      0x8054)
#define PR_EMS_AB_AUTHORIZED_PASSWORD         PROP_TAG(PT_BINARY,       0x8055)
#define PR_EMS_AB_AUTHORIZED_USER             PROP_TAG(PT_TSTRING,      0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_A           PROP_TAG(PT_STRING8,      0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_W           PROP_TAG(PT_UNICODE,      0x8056)
#define PR_EMS_AB_AUTOREPLY                   PROP_TAG(PT_BOOLEAN,      0x800B)
#define PR_EMS_AB_AUTOREPLY_MESSAGE           PROP_TAG(PT_TSTRING,      0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_A         PROP_TAG(PT_STRING8,      0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_W         PROP_TAG(PT_UNICODE,      0x800A)
#define PR_EMS_AB_AUTOREPLY_SUBJECT           PROP_TAG(PT_TSTRING,      0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_A         PROP_TAG(PT_STRING8,      0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_W         PROP_TAG(PT_UNICODE,      0x803E)
#define PR_EMS_AB_BUSINESS_CATEGORY           PROP_TAG(PT_MV_TSTRING,   0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_A         PROP_TAG(PT_MV_STRING8,   0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_W         PROP_TAG(PT_MV_UNICODE,   0x8057)
#define PR_EMS_AB_BUSINESS_ROLES              PROP_TAG(PT_BINARY,       0x8023)
#define PR_EMS_AB_CA_CERTIFICATE              PROP_TAG(PT_MV_BINARY,    0x8003)
#define PR_EMS_AB_CAN_CREATE_PF               PROP_TAG(PT_MV_TSTRING,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_A             PROP_TAG(PT_MV_STRING8,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_W             PROP_TAG(PT_MV_UNICODE,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_O             PROP_TAG(PT_OBJECT,       0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_T             PROP_TAG(PT_MV_TSTRING,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_BL            PROP_TAG(PT_MV_TSTRING,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_A          PROP_TAG(PT_MV_STRING8,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_W          PROP_TAG(PT_MV_UNICODE,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_O          PROP_TAG(PT_OBJECT,       0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_T          PROP_TAG(PT_MV_TSTRING,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_DL            PROP_TAG(PT_MV_TSTRING,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_A          PROP_TAG(PT_MV_STRING8,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_W          PROP_TAG(PT_MV_UNICODE,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_O          PROP_TAG(PT_OBJECT,       0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_T          PROP_TAG(PT_MV_TSTRING,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL         PROP_TAG(PT_MV_TSTRING,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_A       PROP_TAG(PT_MV_STRING8,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_W       PROP_TAG(PT_MV_UNICODE,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_O       PROP_TAG(PT_OBJECT,       0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_T       PROP_TAG(PT_MV_TSTRING,   0x805B)
#define PR_EMS_AB_CAN_NOT_CREATE_PF           PROP_TAG(PT_MV_TSTRING,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_A         PROP_TAG(PT_MV_STRING8,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_W         PROP_TAG(PT_MV_UNICODE,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_O         PROP_TAG(PT_OBJECT,       0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_T         PROP_TAG(PT_MV_TSTRING,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL        PROP_TAG(PT_MV_TSTRING,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_A      PROP_TAG(PT_MV_STRING8,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_W      PROP_TAG(PT_MV_UNICODE,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_O      PROP_TAG(PT_OBJECT,       0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_T      PROP_TAG(PT_MV_TSTRING,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL        PROP_TAG(PT_MV_TSTRING,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_A      PROP_TAG(PT_MV_STRING8,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_W      PROP_TAG(PT_MV_UNICODE,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_O      PROP_TAG(PT_OBJECT,       0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_T      PROP_TAG(PT_MV_TSTRING,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL     PROP_TAG(PT_MV_TSTRING,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_A   PROP_TAG(PT_MV_STRING8,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_W   PROP_TAG(PT_MV_UNICODE,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_O   PROP_TAG(PT_OBJECT,       0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_T   PROP_TAG(PT_MV_TSTRING,   0x805F)
#define PR_EMS_AB_CAN_PRESERVE_DNS            PROP_TAG(PT_BOOLEAN,      0x8060)
#define PR_EMS_AB_CERTIFICATE_REVOCATION_LIST PROP_TAG(PT_BINARY,       0x8016)
#define PR_EMS_AB_CLOCK_ALERT_OFFSET          PROP_TAG(PT_LONG,         0x8061)
#define PR_EMS_AB_CLOCK_ALERT_REPAIR          PROP_TAG(PT_BOOLEAN,      0x8062)
#define PR_EMS_AB_CLOCK_WARNING_OFFSET        PROP_TAG(PT_LONG,         0x8063)
#define PR_EMS_AB_CLOCK_WARNING_REPAIR        PROP_TAG(PT_BOOLEAN,      0x8064)
#define PR_EMS_AB_COMPUTER_NAME               PROP_TAG(PT_TSTRING,      0x8065)
#define PR_EMS_AB_COMPUTER_NAME_A             PROP_TAG(PT_STRING8,      0x8065)
#define PR_EMS_AB_COMPUTER_NAME_W             PROP_TAG(PT_UNICODE,      0x8065)
#define PR_EMS_AB_CONNECTED_DOMAINS           PROP_TAG(PT_MV_TSTRING,   0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_A         PROP_TAG(PT_MV_STRING8,   0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_W         PROP_TAG(PT_MV_UNICODE,   0x8066)
#define PR_EMS_AB_CONTAINER_INFO              PROP_TAG(PT_LONG,         0x8067)
#define PR_EMS_AB_COST                        PROP_TAG(PT_LONG,         0x8068)
#define PR_EMS_AB_COUNTRY_NAME                PROP_TAG(PT_TSTRING,      0x8069)
#define PR_EMS_AB_COUNTRY_NAME_A              PROP_TAG(PT_STRING8,      0x8069)
#define PR_EMS_AB_COUNTRY_NAME_W              PROP_TAG(PT_UNICODE,      0x8069)
#define PR_EMS_AB_CROSS_CERTIFICATE_PAIR      PROP_TAG(PT_MV_BINARY,    0x8025)
#define PR_EMS_AB_DELIV_CONT_LENGTH           PROP_TAG(PT_LONG,         0x806A)
#define PR_EMS_AB_DELIV_EITS                  PROP_TAG(PT_MV_BINARY,    0x806B)
#define PR_EMS_AB_DELIV_EXT_CONT_TYPES        PROP_TAG(PT_MV_BINARY,    0x806C)
#define PR_EMS_AB_DELIVER_AND_REDIRECT        PROP_TAG(PT_BOOLEAN,      0x806D)
#define PR_EMS_AB_DELIVERY_MECHANISM          PROP_TAG(PT_LONG,         0x806E)
#define PR_EMS_AB_DESCRIPTION                 PROP_TAG(PT_MV_TSTRING,   0x806F)
#define PR_EMS_AB_DESCRIPTION_A               PROP_TAG(PT_MV_STRING8,   0x806F)
#define PR_EMS_AB_DESCRIPTION_W               PROP_TAG(PT_MV_UNICODE,   0x806F)
#define PR_EMS_AB_DESTINATION_INDICATOR       PROP_TAG(PT_MV_TSTRING,   0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_A     PROP_TAG(PT_MV_STRING8,   0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_W     PROP_TAG(PT_MV_UNICODE,   0x8070)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY          PROP_TAG(PT_TSTRING,      0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_A        PROP_TAG(PT_STRING8,      0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_W        PROP_TAG(PT_UNICODE,      0x8071)
#define PR_EMS_AB_DISPLAY_NAME_OVERRIDE       PROP_TAG(PT_BOOLEAN,      0x8001)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL      PROP_TAG(PT_MV_TSTRING,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_A    PROP_TAG(PT_MV_STRING8,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_W    PROP_TAG(PT_MV_UNICODE,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_O    PROP_TAG(PT_OBJECT,       0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_T    PROP_TAG(PT_MV_TSTRING,   0x8072)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL      PROP_TAG(PT_MV_TSTRING,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_A    PROP_TAG(PT_MV_STRING8,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_W    PROP_TAG(PT_MV_UNICODE,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_O    PROP_TAG(PT_OBJECT,       0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_T    PROP_TAG(PT_MV_TSTRING,   0x8073)
#define PR_EMS_AB_DL_MEMBER_RULE              PROP_TAG(PT_MV_BINARY,    0x8074)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP        PROP_TAG(PT_TSTRING,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_A      PROP_TAG(PT_STRING8,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_W      PROP_TAG(PT_UNICODE,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_O      PROP_TAG(PT_OBJECT,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_T      PROP_TAG(PT_TSTRING,      0x8075)
#define PR_EMS_AB_DOMAIN_NAME                 PROP_TAG(PT_TSTRING,      0x8076)
#define PR_EMS_AB_DOMAIN_NAME_A               PROP_TAG(PT_STRING8,      0x8076)
#define PR_EMS_AB_DOMAIN_NAME_W               PROP_TAG(PT_UNICODE,      0x8076)
#define PR_EMS_AB_DSA_SIGNATURE               PROP_TAG(PT_BINARY,       0x8077)
#define PR_EMS_AB_DXA_ADMIN_COPY              PROP_TAG(PT_BOOLEAN,      0x8078)
#define PR_EMS_AB_DXA_ADMIN_FORWARD           PROP_TAG(PT_BOOLEAN,      0x8079)
#define PR_EMS_AB_DXA_ADMIN_UPDATE            PROP_TAG(PT_LONG,         0x807A)
#define PR_EMS_AB_DXA_APPEND_REQCN            PROP_TAG(PT_BOOLEAN,      0x807B)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST     PROP_TAG(PT_MV_TSTRING,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_A   PROP_TAG(PT_MV_STRING8,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_W   PROP_TAG(PT_MV_UNICODE,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_O   PROP_TAG(PT_OBJECT,       0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_T   PROP_TAG(PT_MV_TSTRING,   0x807C)
#define PR_EMS_AB_DXA_CONF_REQ_TIME           PROP_TAG(PT_SYSTIME,      0x807D)
#define PR_EMS_AB_DXA_CONF_SEQ                PROP_TAG(PT_TSTRING,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_A              PROP_TAG(PT_STRING8,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_W              PROP_TAG(PT_UNICODE,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_USN            PROP_TAG(PT_LONG,         0x807F)
#define PR_EMS_AB_DXA_EXCHANGE_OPTIONS        PROP_TAG(PT_LONG,         0x8080)
#define PR_EMS_AB_DXA_EXPORT_NOW              PROP_TAG(PT_BOOLEAN,      0x8081)
#define PR_EMS_AB_DXA_FLAGS                   PROP_TAG(PT_LONG,         0x8082)
#define PR_EMS_AB_DXA_IMP_SEQ                 PROP_TAG(PT_TSTRING,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_A               PROP_TAG(PT_STRING8,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_W               PROP_TAG(PT_UNICODE,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x8084)
#define PR_EMS_AB_DXA_IMP_SEQ_USN             PROP_TAG(PT_LONG,         0x8085)
#define PR_EMS_AB_DXA_IMPORT_NOW              PROP_TAG(PT_BOOLEAN,      0x8086)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP         PROP_TAG(PT_MV_TSTRING,   0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_A       PROP_TAG(PT_MV_STRING8,   0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_W       PROP_TAG(PT_MV_UNICODE,   0x8087)
#define PR_EMS_AB_DXA_LOCAL_ADMIN             PROP_TAG(PT_TSTRING,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_A           PROP_TAG(PT_STRING8,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_W           PROP_TAG(PT_UNICODE,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_O           PROP_TAG(PT_OBJECT,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_T           PROP_TAG(PT_TSTRING,      0x8088)
#define PR_EMS_AB_DXA_LOGGING_LEVEL           PROP_TAG(PT_LONG,         0x8089)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE     PROP_TAG(PT_TSTRING,      0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_A   PROP_TAG(PT_STRING8,      0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_W   PROP_TAG(PT_UNICODE,      0x808A)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP        PROP_TAG(PT_MV_TSTRING,   0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_A      PROP_TAG(PT_MV_STRING8,   0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_W      PROP_TAG(PT_MV_UNICODE,   0x808B)
#define PR_EMS_AB_DXA_PASSWORD                PROP_TAG(PT_TSTRING,      0x808C)
#define PR_EMS_AB_DXA_PASSWORD_A              PROP_TAG(PT_STRING8,      0x808C)
#define PR_EMS_AB_DXA_PASSWORD_W              PROP_TAG(PT_UNICODE,      0x808C)
#define PR_EMS_AB_DXA_PREV_EXCHANGE_OPTIONS   PROP_TAG(PT_LONG,         0x808D)
#define PR_EMS_AB_DXA_PREV_EXPORT_NATIVE_ONLY PROP_TAG(PT_BOOLEAN,      0x808E)
#define PR_EMS_AB_DXA_PREV_IN_EXCHANGE_SENSITIVITY PROP_TAG(PT_LONG,    0x808F)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES     PROP_TAG(PT_TSTRING,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_A   PROP_TAG(PT_STRING8,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_W   PROP_TAG(PT_UNICODE,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_O   PROP_TAG(PT_OBJECT,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_T   PROP_TAG(PT_TSTRING,      0x8090)
#define PR_EMS_AB_DXA_PREV_REPLICATION_SENSITIVITY PROP_TAG(PT_LONG,    0x8091)
#define PR_EMS_AB_DXA_PREV_TEMPLATE_OPTIONS   PROP_TAG(PT_LONG,         0x8092)
#define PR_EMS_AB_DXA_PREV_TYPES              PROP_TAG(PT_LONG,         0x8093)
#define PR_EMS_AB_DXA_RECIPIENT_CP            PROP_TAG(PT_TSTRING,      0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_A          PROP_TAG(PT_STRING8,      0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_W          PROP_TAG(PT_UNICODE,      0x8094)
#define PR_EMS_AB_DXA_REMOTE_CLIENT           PROP_TAG(PT_TSTRING,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_A         PROP_TAG(PT_STRING8,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_W         PROP_TAG(PT_UNICODE,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_O         PROP_TAG(PT_OBJECT,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_T         PROP_TAG(PT_TSTRING,      0x8095)
#define PR_EMS_AB_DXA_REQ_SEQ                 PROP_TAG(PT_TSTRING,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_A               PROP_TAG(PT_STRING8,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_W               PROP_TAG(PT_UNICODE,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x8097)
#define PR_EMS_AB_DXA_REQ_SEQ_USN             PROP_TAG(PT_LONG,         0x8098)
#define PR_EMS_AB_DXA_REQNAME                 PROP_TAG(PT_TSTRING,      0x8099)
#define PR_EMS_AB_DXA_REQNAME_A               PROP_TAG(PT_STRING8,      0x8099)
#define PR_EMS_AB_DXA_REQNAME_W               PROP_TAG(PT_UNICODE,      0x8099)
#define PR_EMS_AB_DXA_SVR_SEQ                 PROP_TAG(PT_TSTRING,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_A               PROP_TAG(PT_STRING8,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_W               PROP_TAG(PT_UNICODE,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x809B)
#define PR_EMS_AB_DXA_SVR_SEQ_USN             PROP_TAG(PT_LONG,         0x809C)
#define PR_EMS_AB_DXA_TASK                    PROP_TAG(PT_LONG,         0x809D)
#define PR_EMS_AB_DXA_TEMPLATE_OPTIONS        PROP_TAG(PT_LONG,         0x809E)
#define PR_EMS_AB_DXA_TEMPLATE_TIMESTAMP      PROP_TAG(PT_SYSTIME,      0x809F)
#define PR_EMS_AB_DXA_TYPES                   PROP_TAG(PT_LONG,         0x80A0)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST   PROP_TAG(PT_MV_TSTRING,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_A PROP_TAG(PT_MV_STRING8,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_W PROP_TAG(PT_MV_UNICODE,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_O PROP_TAG(PT_OBJECT,       0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_T PROP_TAG(PT_MV_TSTRING,   0x80A1)
#define PR_EMS_AB_ENCAPSULATION_METHOD        PROP_TAG(PT_LONG,         0x80A2)
#define PR_EMS_AB_ENCRYPT                     PROP_TAG(PT_BOOLEAN,      0x80A3)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA         PROP_TAG(PT_MV_TSTRING,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_A       PROP_TAG(PT_MV_STRING8,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_W       PROP_TAG(PT_MV_UNICODE,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER      PROP_TAG(PT_MV_TSTRING,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_A    PROP_TAG(PT_MV_STRING8,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_W    PROP_TAG(PT_MV_UNICODE,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA     PROP_TAG(PT_TSTRING,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_A   PROP_TAG(PT_STRING8,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_W   PROP_TAG(PT_UNICODE,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER  PROP_TAG(PT_TSTRING,      0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_A PROP_TAG(PT_STRING8,     0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_W PROP_TAG(PT_UNICODE,     0x803D)
#define PR_EMS_AB_EXPAND_DLS_LOCALLY          PROP_TAG(PT_BOOLEAN,      0x80A4)
#define PR_EMS_AB_EXPIRATION_TIME             PROP_TAG(PT_SYSTIME,      0x8028)
#define PR_EMS_AB_EXPORT_CONTAINERS           PROP_TAG(PT_MV_TSTRING,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_A         PROP_TAG(PT_MV_STRING8,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_W         PROP_TAG(PT_MV_UNICODE,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_O         PROP_TAG(PT_OBJECT,       0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_T         PROP_TAG(PT_MV_TSTRING,   0x80A5)
#define PR_EMS_AB_EXPORT_CUSTOM_RECIPIENTS    PROP_TAG(PT_BOOLEAN,      0x80A6)
#define PR_EMS_AB_EXTENDED_CHARS_ALLOWED      PROP_TAG(PT_BOOLEAN,      0x80A7)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1       PROP_TAG(PT_TSTRING,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_A     PROP_TAG(PT_STRING8,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_W     PROP_TAG(PT_UNICODE,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10      PROP_TAG(PT_TSTRING,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_A    PROP_TAG(PT_STRING8,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_W    PROP_TAG(PT_UNICODE,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2       PROP_TAG(PT_TSTRING,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_A     PROP_TAG(PT_STRING8,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_W     PROP_TAG(PT_UNICODE,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3       PROP_TAG(PT_TSTRING,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_A     PROP_TAG(PT_STRING8,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_W     PROP_TAG(PT_UNICODE,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4       PROP_TAG(PT_TSTRING,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_A     PROP_TAG(PT_STRING8,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_W     PROP_TAG(PT_UNICODE,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5       PROP_TAG(PT_TSTRING,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_A     PROP_TAG(PT_STRING8,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_W     PROP_TAG(PT_UNICODE,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6       PROP_TAG(PT_TSTRING,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_A     PROP_TAG(PT_STRING8,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_W     PROP_TAG(PT_UNICODE,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7       PROP_TAG(PT_TSTRING,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_A     PROP_TAG(PT_STRING8,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_W     PROP_TAG(PT_UNICODE,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8       PROP_TAG(PT_TSTRING,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_A     PROP_TAG(PT_STRING8,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_W     PROP_TAG(PT_UNICODE,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9       PROP_TAG(PT_TSTRING,      0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_A     PROP_TAG(PT_STRING8,      0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_W     PROP_TAG(PT_UNICODE,      0x8035)
#define PR_EMS_AB_EXTENSION_DATA              PROP_TAG(PT_MV_BINARY,    0x80A8)
#define PR_EMS_AB_EXTENSION_NAME              PROP_TAG(PT_MV_TSTRING,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_A            PROP_TAG(PT_MV_STRING8,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_W            PROP_TAG(PT_MV_UNICODE,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED    PROP_TAG(PT_MV_TSTRING,   0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_A  PROP_TAG(PT_MV_STRING8,   0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_W  PROP_TAG(PT_MV_UNICODE,   0x80AA)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER  PROP_TAG(PT_MV_BINARY,    0x80AB)
#define PR_EMS_AB_FILE_VERSION                PROP_TAG(PT_BINARY,       0x80AC)
#define PR_EMS_AB_FILTER_LOCAL_ADDRESSES      PROP_TAG(PT_BOOLEAN,      0x80AD)
#define PR_EMS_AB_FOLDER_PATHNAME             PROP_TAG(PT_TSTRING,      0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_A           PROP_TAG(PT_STRING8,      0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_W           PROP_TAG(PT_UNICODE,      0x8004)
#define PR_EMS_AB_FOLDERS_CONTAINER           PROP_TAG(PT_TSTRING,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_A         PROP_TAG(PT_STRING8,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_W         PROP_TAG(PT_UNICODE,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_O         PROP_TAG(PT_OBJECT,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_T         PROP_TAG(PT_TSTRING,      0x80AE)
#define PR_EMS_AB_GARBAGE_COLL_PERIOD         PROP_TAG(PT_LONG,         0x80AF)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED          PROP_TAG(PT_TSTRING,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_A        PROP_TAG(PT_STRING8,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_W        PROP_TAG(PT_UNICODE,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG         PROP_TAG(PT_TSTRING,      0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_A       PROP_TAG(PT_STRING8,      0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_W       PROP_TAG(PT_UNICODE,      0x80B1)
#define PR_EMS_AB_GATEWAY_PROXY               PROP_TAG(PT_MV_TSTRING,   0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_A             PROP_TAG(PT_MV_STRING8,   0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_W             PROP_TAG(PT_MV_UNICODE,   0x80B2)
#define PR_EMS_AB_GATEWAY_ROUTING_TREE        PROP_TAG(PT_BINARY,       0x80B3)
#define PR_EMS_AB_GWART_LAST_MODIFIED         PROP_TAG(PT_SYSTIME,      0x80B4)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS        PROP_TAG(PT_MV_TSTRING,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_A      PROP_TAG(PT_MV_STRING8,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_W      PROP_TAG(PT_MV_UNICODE,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_O      PROP_TAG(PT_OBJECT,       0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_T      PROP_TAG(PT_MV_TSTRING,   0x80B5)
#define PR_EMS_AB_HAS_MASTER_NCS              PROP_TAG(PT_MV_TSTRING,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_A            PROP_TAG(PT_MV_STRING8,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_W            PROP_TAG(PT_MV_UNICODE,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_O            PROP_TAG(PT_OBJECT,       0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_T            PROP_TAG(PT_MV_TSTRING,   0x80B6)
#define PR_EMS_AB_HELP_DATA16                 PROP_TAG(PT_BINARY,       0x803A)
#define PR_EMS_AB_HELP_DATA32                 PROP_TAG(PT_BINARY,       0x8010)
#define PR_EMS_AB_HELP_FILE_NAME              PROP_TAG(PT_TSTRING,      0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_A            PROP_TAG(PT_STRING8,      0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_W            PROP_TAG(PT_UNICODE,      0x803B)
#define PR_EMS_AB_HEURISTICS                  PROP_TAG(PT_LONG,         0x80B7)
#define PR_EMS_AB_HIDE_DL_MEMBERSHIP          PROP_TAG(PT_BOOLEAN,      0x80B8)
#define PR_EMS_AB_HIDE_FROM_ADDRESS_BOOK      PROP_TAG(PT_BOOLEAN,      0x80B9)
#define PR_EMS_AB_HOME_MDB                    PROP_TAG(PT_TSTRING,      0x8006)
#define PR_EMS_AB_HOME_MDB_A                  PROP_TAG(PT_STRING8,      0x8006)
#define PR_EMS_AB_HOME_MDB_W                  PROP_TAG(PT_UNICODE,      0x8006)
#define PR_EMS_AB_HOME_MDB_O                  PROP_TAG(PT_OBJECT,       0x8006)
#define PR_EMS_AB_HOME_MDB_T                  PROP_TAG(PT_TSTRING,      0x8006)
#define PR_EMS_AB_HOME_MDB_BL                 PROP_TAG(PT_MV_TSTRING,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_A               PROP_TAG(PT_MV_STRING8,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_W               PROP_TAG(PT_MV_UNICODE,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_O               PROP_TAG(PT_OBJECT,       0x8014)
#define PR_EMS_AB_HOME_MDB_BL_T               PROP_TAG(PT_MV_TSTRING,   0x8014)
#define PR_EMS_AB_HOME_MTA                    PROP_TAG(PT_TSTRING,      0x8007)
#define PR_EMS_AB_HOME_MTA_A                  PROP_TAG(PT_STRING8,      0x8007)
#define PR_EMS_AB_HOME_MTA_W                  PROP_TAG(PT_UNICODE,      0x8007)
#define PR_EMS_AB_HOME_MTA_O                  PROP_TAG(PT_OBJECT,       0x8007)
#define PR_EMS_AB_HOME_MTA_T                  PROP_TAG(PT_TSTRING,      0x8007)
#define PR_EMS_AB_HOME_PUBLIC_SERVER          PROP_TAG(PT_TSTRING,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_A        PROP_TAG(PT_STRING8,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_W        PROP_TAG(PT_UNICODE,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_O        PROP_TAG(PT_OBJECT,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_T        PROP_TAG(PT_TSTRING,      0x803F)
#define PR_EMS_AB_IMPORT_CONTAINER            PROP_TAG(PT_TSTRING,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_A          PROP_TAG(PT_STRING8,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_W          PROP_TAG(PT_UNICODE,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_O          PROP_TAG(PT_OBJECT,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_T          PROP_TAG(PT_TSTRING,      0x80BA)
#define PR_EMS_AB_IMPORT_SENSITIVITY          PROP_TAG(PT_LONG,         0x80BB)
#define PR_EMS_AB_IMPORTED_FROM               PROP_TAG(PT_TSTRING,      0x8042)
#define PR_EMS_AB_IMPORTED_FROM_A             PROP_TAG(PT_STRING8,      0x8042)
#define PR_EMS_AB_IMPORTED_FROM_W             PROP_TAG(PT_UNICODE,      0x8042)
#define PR_EMS_AB_INBOUND_SITES               PROP_TAG(PT_MV_TSTRING,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_A             PROP_TAG(PT_MV_STRING8,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_W             PROP_TAG(PT_MV_UNICODE,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_O             PROP_TAG(PT_OBJECT,       0x80BC)
#define PR_EMS_AB_INBOUND_SITES_T             PROP_TAG(PT_MV_TSTRING,   0x80BC)
#define PR_EMS_AB_INSTANCE_TYPE               PROP_TAG(PT_LONG,         0x80BD)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER   PROP_TAG(PT_MV_TSTRING,   0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_A PROP_TAG(PT_MV_STRING8,   0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_W PROP_TAG(PT_MV_UNICODE,   0x80BE)
#define PR_EMS_AB_INVOCATION_ID               PROP_TAG(PT_BINARY,       0x80BF)
#define PR_EMS_AB_IS_DELETED                  PROP_TAG(PT_BOOLEAN,      0x80C0)
#define PR_EMS_AB_IS_MEMBER_OF_DL             PROP_TAG(PT_OBJECT,       0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_A           PROP_TAG(PT_MV_STRING8,   0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_W           PROP_TAG(PT_MV_UNICODE,   0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_O           PROP_TAG(PT_OBJECT,       0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_T           PROP_TAG(PT_MV_TSTRING,   0x8008)
#define PR_EMS_AB_IS_SINGLE_VALUED            PROP_TAG(PT_BOOLEAN,      0x80C1)
#define PR_EMS_AB_KCC_STATUS                  PROP_TAG(PT_MV_BINARY,    0x80C2)
#define PR_EMS_AB_KM_SERVER                   PROP_TAG(PT_TSTRING,      0x800D)
#define PR_EMS_AB_KM_SERVER_A                 PROP_TAG(PT_STRING8,      0x800D)
#define PR_EMS_AB_KM_SERVER_W                 PROP_TAG(PT_UNICODE,      0x800D)
#define PR_EMS_AB_KM_SERVER_O                 PROP_TAG(PT_OBJECT,       0x800D)
#define PR_EMS_AB_KM_SERVER_T                 PROP_TAG(PT_TSTRING,      0x800D)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION       PROP_TAG(PT_MV_TSTRING,   0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_A     PROP_TAG(PT_MV_STRING8,   0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_W     PROP_TAG(PT_MV_UNICODE,   0x80C3)
#define PR_EMS_AB_LINE_WRAP                   PROP_TAG(PT_LONG,         0x80C4)
#define PR_EMS_AB_LINK_ID                     PROP_TAG(PT_LONG,         0x80C5)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD           PROP_TAG(PT_TSTRING,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_A         PROP_TAG(PT_STRING8,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_W         PROP_TAG(PT_UNICODE,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS   PROP_TAG(PT_TSTRING,      0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_A PROP_TAG(PT_STRING8,      0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_W PROP_TAG(PT_UNICODE,      0x80C7)
#define PR_EMS_AB_LOCAL_INITIAL_TURN          PROP_TAG(PT_BOOLEAN,      0x80C8)
#define PR_EMS_AB_LOCAL_SCOPE                 PROP_TAG(PT_MV_TSTRING,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_A               PROP_TAG(PT_MV_STRING8,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_W               PROP_TAG(PT_MV_UNICODE,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_O               PROP_TAG(PT_OBJECT,       0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_T               PROP_TAG(PT_MV_TSTRING,   0x80C9)
#define PR_EMS_AB_LOG_FILENAME                PROP_TAG(PT_TSTRING,      0x80CA)
#define PR_EMS_AB_LOG_FILENAME_A              PROP_TAG(PT_STRING8,      0x80CA)
#define PR_EMS_AB_LOG_FILENAME_W              PROP_TAG(PT_UNICODE,      0x80CA)
#define PR_EMS_AB_LOG_ROLLOVER_INTERVAL       PROP_TAG(PT_LONG,         0x80CB)
#define PR_EMS_AB_MAINTAIN_AUTOREPLY_HISTORY  PROP_TAG(PT_BOOLEAN,      0x80CC)
#define PR_EMS_AB_MANAGER                     PROP_TAG(PT_OBJECT,       0x8005)
#define PR_EMS_AB_MANAGER_A                   PROP_TAG(PT_STRING8,      0x8005)
#define PR_EMS_AB_MANAGER_W                   PROP_TAG(PT_UNICODE,      0x8005)
#define PR_EMS_AB_MANAGER_O                   PROP_TAG(PT_OBJECT,       0x8005)
#define PR_EMS_AB_MANAGER_T                   PROP_TAG(PT_TSTRING,      0x8005)
#define PR_EMS_AB_MAPI_DISPLAY_TYPE           PROP_TAG(PT_LONG,         0x80CD)
#define PR_EMS_AB_MAPI_ID                     PROP_TAG(PT_LONG,         0x80CE)
#define PR_EMS_AB_MAXIMUM_OBJECT_ID           PROP_TAG(PT_BINARY,       0x8169)
#define PR_EMS_AB_MDB_BACKOFF_INTERVAL        PROP_TAG(PT_LONG,         0x80CF)
#define PR_EMS_AB_MDB_MSG_TIME_OUT_PERIOD     PROP_TAG(PT_LONG,         0x80D0)
#define PR_EMS_AB_MDB_OVER_QUOTA_LIMIT        PROP_TAG(PT_LONG,         0x80D1)
#define PR_EMS_AB_MDB_STORAGE_QUOTA           PROP_TAG(PT_LONG,         0x80D2)
#define PR_EMS_AB_MDB_UNREAD_LIMIT            PROP_TAG(PT_LONG,         0x80D3)
#define PR_EMS_AB_MDB_USE_DEFAULTS            PROP_TAG(PT_BOOLEAN,      0x80D4)
#define PR_EMS_AB_MEMBER                      PROP_TAG(PT_OBJECT,       0x8009)
#define PR_EMS_AB_MEMBER_A                    PROP_TAG(PT_MV_STRING8,   0x8009)
#define PR_EMS_AB_MEMBER_W                    PROP_TAG(PT_MV_UNICODE,   0x8009)
#define PR_EMS_AB_MEMBER_O                    PROP_TAG(PT_OBJECT,       0x8009)
#define PR_EMS_AB_MEMBER_T                    PROP_TAG(PT_MV_TSTRING,   0x8009)
#define PR_EMS_AB_MESSAGE_TRACKING_ENABLED    PROP_TAG(PT_BOOLEAN,      0x80D5)
#define PR_EMS_AB_MONITOR_CLOCK               PROP_TAG(PT_BOOLEAN,      0x80D6)
#define PR_EMS_AB_MONITOR_SERVERS             PROP_TAG(PT_BOOLEAN,      0x80D7)
#define PR_EMS_AB_MONITOR_SERVICES            PROP_TAG(PT_BOOLEAN,      0x80D8)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS    PROP_TAG(PT_MV_TSTRING,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_A  PROP_TAG(PT_MV_STRING8,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_W  PROP_TAG(PT_MV_UNICODE,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_O  PROP_TAG(PT_OBJECT,       0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_T  PROP_TAG(PT_MV_TSTRING,   0x80D9)
#define PR_EMS_AB_MONITORED_SERVERS           PROP_TAG(PT_MV_TSTRING,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_A         PROP_TAG(PT_MV_STRING8,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_W         PROP_TAG(PT_MV_UNICODE,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_O         PROP_TAG(PT_OBJECT,       0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_T         PROP_TAG(PT_MV_TSTRING,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVICES          PROP_TAG(PT_MV_TSTRING,   0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_A        PROP_TAG(PT_MV_STRING8,   0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_W        PROP_TAG(PT_MV_UNICODE,   0x80DB)
#define PR_EMS_AB_MONITORING_ALERT_DELAY      PROP_TAG(PT_LONG,         0x80DC)
#define PR_EMS_AB_MONITORING_ALERT_UNITS      PROP_TAG(PT_LONG,         0x80DD)
#define PR_EMS_AB_MONITORING_AVAILABILITY_STYLE PROP_TAG(PT_LONG,       0x80DE)
#define PR_EMS_AB_MONITORING_AVAILABILITY_WINDOW PROP_TAG(PT_BINARY,    0x80DF)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL  PROP_TAG(PT_MV_TSTRING,   0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_A PROP_TAG(PT_MV_STRING8,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_W PROP_TAG(PT_MV_UNICODE,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_O PROP_TAG(PT_OBJECT,      0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_T PROP_TAG(PT_MV_TSTRING,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC   PROP_TAG(PT_MV_TSTRING,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_A PROP_TAG(PT_MV_STRING8,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_W PROP_TAG(PT_MV_UNICODE,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_O PROP_TAG(PT_OBJECT,       0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_T PROP_TAG(PT_MV_TSTRING,   0x80E1)
#define PR_EMS_AB_MONITORING_ESCALATION_PROCEDURE PROP_TAG(PT_MV_BINARY,0x80E2)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_INTERVAL PROP_TAG(PT_LONG,    0x80E3)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_UNITS PROP_TAG(PT_LONG,       0x80E4)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_INTERVAL PROP_TAG(PT_LONG,     0x80E5)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_UNITS PROP_TAG(PT_LONG,        0x80E6)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_INTERVAL PROP_TAG(PT_LONG,     0x80E7)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_UNITS PROP_TAG(PT_LONG,        0x80E8)
#define PR_EMS_AB_MONITORING_RECIPIENTS       PROP_TAG(PT_MV_TSTRING,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_A     PROP_TAG(PT_MV_STRING8,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_W     PROP_TAG(PT_MV_UNICODE,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_O     PROP_TAG(PT_OBJECT,       0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_T     PROP_TAG(PT_MV_TSTRING,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR   PROP_TAG(PT_MV_TSTRING,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_A PROP_TAG(PT_MV_STRING8,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_W PROP_TAG(PT_MV_UNICODE,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_O PROP_TAG(PT_OBJECT,       0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_T PROP_TAG(PT_MV_TSTRING,   0x80EA)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_INTERVAL PROP_TAG(PT_LONG,      0x80EB)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_UNITS PROP_TAG(PT_LONG,         0x80EC)
#define PR_EMS_AB_MONITORING_WARNING_DELAY    PROP_TAG(PT_LONG,         0x80ED)
#define PR_EMS_AB_MONITORING_WARNING_UNITS    PROP_TAG(PT_LONG,         0x80EE)
#define PR_EMS_AB_MTA_LOCAL_CRED              PROP_TAG(PT_TSTRING,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_A            PROP_TAG(PT_STRING8,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_W            PROP_TAG(PT_UNICODE,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_DESIG             PROP_TAG(PT_TSTRING,      0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_A           PROP_TAG(PT_STRING8,      0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_W           PROP_TAG(PT_UNICODE,      0x80F0)
#define PR_EMS_AB_N_ADDRESS                   PROP_TAG(PT_BINARY,       0x80F1)
#define PR_EMS_AB_N_ADDRESS_TYPE              PROP_TAG(PT_LONG,         0x80F2)
#define PR_EMS_AB_NETWORK_ADDRESS             PROP_TAG(PT_MV_TSTRING,   0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_A           PROP_TAG(PT_MV_STRING8,   0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_W           PROP_TAG(PT_MV_UNICODE,   0x8170)
#define PR_EMS_AB_NT_MACHINE_NAME             PROP_TAG(PT_TSTRING,      0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_A           PROP_TAG(PT_STRING8,      0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_W           PROP_TAG(PT_UNICODE,      0x80F3)
#define PR_EMS_AB_NT_SECURITY_DESCRIPTOR      PROP_TAG(PT_BINARY,       0x8013)
#define PR_EMS_AB_NUM_OF_OPEN_RETRIES         PROP_TAG(PT_LONG,         0x80F4)
#define PR_EMS_AB_NUM_OF_TRANSFER_RETRIES     PROP_TAG(PT_LONG,         0x80F5)
#define PR_EMS_AB_OBJ_DIST_NAME               PROP_TAG(PT_TSTRING,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_A             PROP_TAG(PT_STRING8,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_W             PROP_TAG(PT_UNICODE,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_O             PROP_TAG(PT_OBJECT,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_T             PROP_TAG(PT_TSTRING,      0x803C)
#define PR_EMS_AB_OBJECT_CLASS_CATEGORY       PROP_TAG(PT_LONG,         0x80F6)
#define PR_EMS_AB_OBJECT_VERSION              PROP_TAG(PT_LONG,         0x80F7)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS      PROP_TAG(PT_MV_TSTRING,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_A    PROP_TAG(PT_MV_STRING8,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_W    PROP_TAG(PT_MV_UNICODE,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_O    PROP_TAG(PT_OBJECT,       0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_T    PROP_TAG(PT_MV_TSTRING,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_SCHEDULE        PROP_TAG(PT_BINARY,       0x80F9)
#define PR_EMS_AB_OFF_LINE_AB_SERVER          PROP_TAG(PT_TSTRING,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_A        PROP_TAG(PT_STRING8,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_W        PROP_TAG(PT_UNICODE,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_O        PROP_TAG(PT_OBJECT,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_T        PROP_TAG(PT_TSTRING,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_STYLE           PROP_TAG(PT_LONG,         0x80FB)
#define PR_EMS_AB_OID_TYPE                    PROP_TAG(PT_LONG,         0x80FC)
#define PR_EMS_AB_OM_OBJECT_CLASS             PROP_TAG(PT_BINARY,       0x80FD)
#define PR_EMS_AB_OM_SYNTAX                   PROP_TAG(PT_LONG,         0x80FE)
#define PR_EMS_AB_OOF_REPLY_TO_ORIGINATOR     PROP_TAG(PT_BOOLEAN,      0x80FF)
#define PR_EMS_AB_OPEN_RETRY_INTERVAL         PROP_TAG(PT_LONG,         0x8100)
#define PR_EMS_AB_ORGANIZATION_NAME           PROP_TAG(PT_MV_TSTRING,   0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_A         PROP_TAG(PT_MV_STRING8,   0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_W         PROP_TAG(PT_MV_UNICODE,   0x8101)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME    PROP_TAG(PT_MV_TSTRING,   0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_A  PROP_TAG(PT_MV_STRING8,   0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_W  PROP_TAG(PT_MV_UNICODE,   0x8102)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE      PROP_TAG(PT_BINARY,       0x8103)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE_MSDOS PROP_TAG(PT_BINARY,      0x8104)
#define PR_EMS_AB_OUTBOUND_SITES              PROP_TAG(PT_MV_TSTRING,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_A            PROP_TAG(PT_MV_STRING8,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_W            PROP_TAG(PT_MV_UNICODE,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_O            PROP_TAG(PT_OBJECT,       0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_T            PROP_TAG(PT_MV_TSTRING,   0x8105)
#define PR_EMS_AB_OWNER                       PROP_TAG(PT_TSTRING,      0x800C)
#define PR_EMS_AB_OWNER_A                     PROP_TAG(PT_STRING8,      0x800C)
#define PR_EMS_AB_OWNER_W                     PROP_TAG(PT_UNICODE,      0x800C)
#define PR_EMS_AB_OWNER_O                     PROP_TAG(PT_OBJECT,       0x800C)
#define PR_EMS_AB_OWNER_T                     PROP_TAG(PT_TSTRING,      0x800C)
#define PR_EMS_AB_OWNER_BL                    PROP_TAG(PT_TSTRING,      0x8024)
#define PR_EMS_AB_OWNER_BL_A                  PROP_TAG(PT_STRING8,      0x8024)
#define PR_EMS_AB_OWNER_BL_W                  PROP_TAG(PT_UNICODE,      0x8024)
#define PR_EMS_AB_OWNER_BL_O                  PROP_TAG(PT_OBJECT,       0x8024)
#define PR_EMS_AB_OWNER_BL_T                  PROP_TAG(PT_TSTRING,      0x8024)
#define PR_EMS_AB_P_SELECTOR                  PROP_TAG(PT_BINARY,       0x8106)
#define PR_EMS_AB_P_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x8107)
#define PR_EMS_AB_PER_MSG_DIALOG_DISPLAY_TABLE PROP_TAG(PT_BINARY,      0x8108)
#define PR_EMS_AB_PER_RECIP_DIALOG_DISPLAY_TABLE PROP_TAG(PT_BINARY,    0x8109)
#define PR_EMS_AB_PERIOD_REP_SYNC_TIMES       PROP_TAG(PT_BINARY,       0x810A)
#define PR_EMS_AB_PERIOD_REPL_STAGGER         PROP_TAG(PT_LONG,         0x810B)
#define PR_EMS_AB_PF_CONTACTS                 PROP_TAG(PT_MV_TSTRING,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_A               PROP_TAG(PT_MV_STRING8,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_W               PROP_TAG(PT_MV_UNICODE,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_O               PROP_TAG(PT_OBJECT,       0x8038)
#define PR_EMS_AB_PF_CONTACTS_T               PROP_TAG(PT_MV_TSTRING,   0x8038)
#define PR_EMS_AB_POSTAL_ADDRESS              PROP_TAG(PT_MV_BINARY,    0x810C)
#define PR_EMS_AB_PREFERRED_DELIVERY_METHOD   PROP_TAG(PT_MV_LONG,      0x810D)
#define PR_EMS_AB_PRMD                        PROP_TAG(PT_TSTRING,      0x810E)
#define PR_EMS_AB_PRMD_A                      PROP_TAG(PT_STRING8,      0x810E)
#define PR_EMS_AB_PRMD_W                      PROP_TAG(PT_UNICODE,      0x810E)
#define PR_EMS_AB_PROXY_ADDRESSES             PROP_TAG(PT_MV_TSTRING,   0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_A           PROP_TAG(PT_MV_STRING8,   0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_W           PROP_TAG(PT_MV_UNICODE,   0x800F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL         PROP_TAG(PT_TSTRING,      0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_A       PROP_TAG(PT_STRING8,      0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_W       PROP_TAG(PT_UNICODE,      0x810F)
#define PR_EMS_AB_PUBLIC_DELEGATES            PROP_TAG(PT_OBJECT,       0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_A          PROP_TAG(PT_MV_STRING8,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_W          PROP_TAG(PT_MV_UNICODE,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_O          PROP_TAG(PT_OBJECT,       0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_T          PROP_TAG(PT_MV_TSTRING,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL         PROP_TAG(PT_MV_TSTRING,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_A       PROP_TAG(PT_MV_STRING8,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_W       PROP_TAG(PT_MV_UNICODE,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_O       PROP_TAG(PT_OBJECT,       0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_T       PROP_TAG(PT_MV_TSTRING,   0x8110)
#define PR_EMS_AB_QUOTA_NOTIFICATION_SCHEDULE PROP_TAG(PT_BINARY,       0x8111)
#define PR_EMS_AB_QUOTA_NOTIFICATION_STYLE    PROP_TAG(PT_LONG,         0x8112)
#define PR_EMS_AB_RANGE_LOWER                 PROP_TAG(PT_LONG,         0x8113)
#define PR_EMS_AB_RANGE_UPPER                 PROP_TAG(PT_LONG,         0x8114)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER         PROP_TAG(PT_TSTRING,      0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_A       PROP_TAG(PT_STRING8,      0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_W       PROP_TAG(PT_UNICODE,      0x8115)
#define PR_EMS_AB_RAS_PHONE_NUMBER            PROP_TAG(PT_TSTRING,      0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_A          PROP_TAG(PT_STRING8,      0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_W          PROP_TAG(PT_UNICODE,      0x8116)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME    PROP_TAG(PT_TSTRING,      0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_A  PROP_TAG(PT_STRING8,      0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_W  PROP_TAG(PT_UNICODE,      0x8117)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME        PROP_TAG(PT_TSTRING,      0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_A      PROP_TAG(PT_STRING8,      0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_W      PROP_TAG(PT_UNICODE,      0x8118)
#define PR_EMS_AB_REGISTERED_ADDRESS          PROP_TAG(PT_MV_BINARY,    0x8119)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD          PROP_TAG(PT_TSTRING,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_A        PROP_TAG(PT_STRING8,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_W        PROP_TAG(PT_UNICODE,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS  PROP_TAG(PT_TSTRING,      0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_A PROP_TAG(PT_STRING8,     0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_W PROP_TAG(PT_UNICODE,     0x811B)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER        PROP_TAG(PT_TSTRING,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_A      PROP_TAG(PT_STRING8,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_W      PROP_TAG(PT_UNICODE,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_O      PROP_TAG(PT_OBJECT,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_T      PROP_TAG(PT_TSTRING,      0x811C)
#define PR_EMS_AB_REMOTE_SITE                 PROP_TAG(PT_TSTRING,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_A               PROP_TAG(PT_STRING8,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_W               PROP_TAG(PT_UNICODE,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_O               PROP_TAG(PT_OBJECT,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_T               PROP_TAG(PT_TSTRING,      0x811D)
#define PR_EMS_AB_REPLICATION_MAIL_MSG_SIZE   PROP_TAG(PT_LONG,         0x8168)
#define PR_EMS_AB_REPLICATION_SENSITIVITY     PROP_TAG(PT_LONG,         0x811E)
#define PR_EMS_AB_REPLICATION_STAGGER         PROP_TAG(PT_LONG,         0x811F)
#define PR_EMS_AB_REPORT_TO_ORIGINATOR        PROP_TAG(PT_BOOLEAN,      0x8120)
#define PR_EMS_AB_REPORT_TO_OWNER             PROP_TAG(PT_BOOLEAN,      0x8121)
#define PR_EMS_AB_REPORTS                     PROP_TAG(PT_OBJECT,       0x800E)
#define PR_EMS_AB_REPORTS_A                   PROP_TAG(PT_MV_STRING8,   0x800E)
#define PR_EMS_AB_REPORTS_W                   PROP_TAG(PT_MV_UNICODE,   0x800E)
#define PR_EMS_AB_REPORTS_O                   PROP_TAG(PT_OBJECT,       0x800E)
#define PR_EMS_AB_REPORTS_T                   PROP_TAG(PT_MV_TSTRING,   0x800E)
#define PR_EMS_AB_REQ_SEQ                     PROP_TAG(PT_LONG,         0x8122)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA       PROP_TAG(PT_TSTRING,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_A     PROP_TAG(PT_STRING8,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_W     PROP_TAG(PT_UNICODE,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_O     PROP_TAG(PT_OBJECT,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_T     PROP_TAG(PT_TSTRING,      0x8123)
#define PR_EMS_AB_RID_SERVER                  PROP_TAG(PT_TSTRING,      0x8124)
#define PR_EMS_AB_RID_SERVER_A                PROP_TAG(PT_STRING8,      0x8124)
#define PR_EMS_AB_RID_SERVER_W                PROP_TAG(PT_UNICODE,      0x8124)
#define PR_EMS_AB_RID_SERVER_O                PROP_TAG(PT_OBJECT,       0x8124)
#define PR_EMS_AB_RID_SERVER_T                PROP_TAG(PT_TSTRING,      0x8124)
#define PR_EMS_AB_ROLE_OCCUPANT               PROP_TAG(PT_MV_TSTRING,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_A             PROP_TAG(PT_MV_STRING8,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_W             PROP_TAG(PT_MV_UNICODE,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_O             PROP_TAG(PT_OBJECT,       0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_T             PROP_TAG(PT_MV_TSTRING,   0x8125)
#define PR_EMS_AB_ROUTING_LIST                PROP_TAG(PT_MV_TSTRING,   0x8126)
#define PR_EMS_AB_ROUTING_LIST_A              PROP_TAG(PT_MV_STRING8,   0x8126)
#define PR_EMS_AB_ROUTING_LIST_W              PROP_TAG(PT_MV_UNICODE,   0x8126)
#define PR_EMS_AB_RTS_CHECKPOINT_SIZE         PROP_TAG(PT_LONG,         0x8127)
#define PR_EMS_AB_RTS_RECOVERY_TIMEOUT        PROP_TAG(PT_LONG,         0x8128)
#define PR_EMS_AB_RTS_WINDOW_SIZE             PROP_TAG(PT_LONG,         0x8129)
#define PR_EMS_AB_RUNS_ON                     PROP_TAG(PT_MV_TSTRING,   0x812A)
#define PR_EMS_AB_RUNS_ON_A                   PROP_TAG(PT_MV_STRING8,   0x812A)
#define PR_EMS_AB_RUNS_ON_W                   PROP_TAG(PT_MV_UNICODE,   0x812A)
#define PR_EMS_AB_RUNS_ON_O                   PROP_TAG(PT_OBJECT,       0x812A)
#define PR_EMS_AB_RUNS_ON_T                   PROP_TAG(PT_MV_TSTRING,   0x812A)
#define PR_EMS_AB_S_SELECTOR                  PROP_TAG(PT_BINARY,       0x812B)
#define PR_EMS_AB_S_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x812C)
#define PR_EMS_AB_SEARCH_FLAGS                PROP_TAG(PT_LONG,         0x812D)
#define PR_EMS_AB_SEARCH_GUIDE                PROP_TAG(PT_MV_BINARY,    0x812E)
#define PR_EMS_AB_SECURITY_PROTOCOL           PROP_TAG(PT_MV_BINARY,    0x8037)
#define PR_EMS_AB_SEE_ALSO                    PROP_TAG(PT_MV_TSTRING,   0x812F)
#define PR_EMS_AB_SEE_ALSO_A                  PROP_TAG(PT_MV_STRING8,   0x812F)
#define PR_EMS_AB_SEE_ALSO_W                  PROP_TAG(PT_MV_UNICODE,   0x812F)
#define PR_EMS_AB_SEE_ALSO_O                  PROP_TAG(PT_OBJECT,       0x812F)
#define PR_EMS_AB_SEE_ALSO_T                  PROP_TAG(PT_MV_TSTRING,   0x812F)
#define PR_EMS_AB_SERIAL_NUMBER               PROP_TAG(PT_MV_TSTRING,   0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_A             PROP_TAG(PT_MV_STRING8,   0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_W             PROP_TAG(PT_MV_UNICODE,   0x8130)
#define PR_EMS_AB_SERVICE_ACTION_FIRST        PROP_TAG(PT_LONG,         0x8131)
#define PR_EMS_AB_SERVICE_ACTION_OTHER        PROP_TAG(PT_LONG,         0x8132)
#define PR_EMS_AB_SERVICE_ACTION_SECOND       PROP_TAG(PT_LONG,         0x8133)
#define PR_EMS_AB_SERVICE_RESTART_DELAY       PROP_TAG(PT_LONG,         0x8134)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE     PROP_TAG(PT_TSTRING,      0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_A   PROP_TAG(PT_STRING8,      0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_W   PROP_TAG(PT_UNICODE,      0x8135)
#define PR_EMS_AB_SESSION_DISCONNECT_TIMER    PROP_TAG(PT_LONG,         0x8136)
#define PR_EMS_AB_SITE_AFFINITY               PROP_TAG(PT_MV_TSTRING,   0x8137)
#define PR_EMS_AB_SITE_AFFINITY_A             PROP_TAG(PT_MV_STRING8,   0x8137)
#define PR_EMS_AB_SITE_AFFINITY_W             PROP_TAG(PT_MV_UNICODE,   0x8137)
#define PR_EMS_AB_SITE_FOLDER_GUID            PROP_TAG(PT_BINARY,       0x8166)
#define PR_EMS_AB_SITE_FOLDER_SERVER          PROP_TAG(PT_TSTRING,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_A        PROP_TAG(PT_STRING8,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_W        PROP_TAG(PT_UNICODE,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_O        PROP_TAG(PT_OBJECT,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_T        PROP_TAG(PT_TSTRING,      0x8167)
#define PR_EMS_AB_SITE_PROXY_SPACE            PROP_TAG(PT_MV_TSTRING,   0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_A          PROP_TAG(PT_MV_STRING8,   0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_W          PROP_TAG(PT_MV_UNICODE,   0x8138)
#define PR_EMS_AB_SPACE_LAST_COMPUTED         PROP_TAG(PT_SYSTIME,      0x8139)
#define PR_EMS_AB_STREET_ADDRESS              PROP_TAG(PT_TSTRING,      0x813A)
#define PR_EMS_AB_STREET_ADDRESS_A            PROP_TAG(PT_STRING8,      0x813A)
#define PR_EMS_AB_STREET_ADDRESS_W            PROP_TAG(PT_UNICODE,      0x813A)
#define PR_EMS_AB_SUB_REFS                    PROP_TAG(PT_MV_TSTRING,   0x813B)
#define PR_EMS_AB_SUB_REFS_A                  PROP_TAG(PT_MV_STRING8,   0x813B)
#define PR_EMS_AB_SUB_REFS_W                  PROP_TAG(PT_MV_UNICODE,   0x813B)
#define PR_EMS_AB_SUB_REFS_O                  PROP_TAG(PT_OBJECT,       0x813B)
#define PR_EMS_AB_SUB_REFS_T                  PROP_TAG(PT_MV_TSTRING,   0x813B)
#define PR_EMS_AB_SUBMISSION_CONT_LENGTH      PROP_TAG(PT_LONG,         0x813C)
#define PR_EMS_AB_SUPPORTED_APPLICATION_CONTEXT PROP_TAG(PT_MV_BINARY,  0x813D)
#define PR_EMS_AB_SUPPORTING_STACK            PROP_TAG(PT_MV_TSTRING,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_A          PROP_TAG(PT_MV_STRING8,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_W          PROP_TAG(PT_MV_UNICODE,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_O          PROP_TAG(PT_OBJECT,       0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_T          PROP_TAG(PT_MV_TSTRING,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_BL         PROP_TAG(PT_MV_TSTRING,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_A       PROP_TAG(PT_MV_STRING8,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_W       PROP_TAG(PT_MV_UNICODE,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_O       PROP_TAG(PT_OBJECT,       0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_T       PROP_TAG(PT_MV_TSTRING,   0x813F)
#define PR_EMS_AB_T_SELECTOR                  PROP_TAG(PT_BINARY,       0x8140)
#define PR_EMS_AB_T_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x8141)
#define PR_EMS_AB_TARGET_ADDRESS              PROP_TAG(PT_TSTRING,      0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_A            PROP_TAG(PT_STRING8,      0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_W            PROP_TAG(PT_UNICODE,      0x8011)
#define PR_EMS_AB_TARGET_MTAS                 PROP_TAG(PT_MV_TSTRING,   0x8142)
#define PR_EMS_AB_TARGET_MTAS_A               PROP_TAG(PT_MV_STRING8,   0x8142)
#define PR_EMS_AB_TARGET_MTAS_W               PROP_TAG(PT_MV_UNICODE,   0x8142)
#define PR_EMS_AB_TELEPHONE_NUMBER            PROP_TAG(PT_MV_TSTRING,   0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_A          PROP_TAG(PT_MV_STRING8,   0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_W          PROP_TAG(PT_MV_UNICODE,   0x8012)
#define PR_EMS_AB_TELETEX_TERMINAL_IDENTIFIER PROP_TAG(PT_MV_BINARY,    0x8143)
#define PR_EMS_AB_TEMP_ASSOC_THRESHOLD        PROP_TAG(PT_LONG,         0x8144)
#define PR_EMS_AB_TOMBSTONE_LIFETIME          PROP_TAG(PT_LONG,         0x8145)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME      PROP_TAG(PT_TSTRING,      0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_A    PROP_TAG(PT_STRING8,      0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_W    PROP_TAG(PT_UNICODE,      0x8146)
#define PR_EMS_AB_TRANS_RETRY_MINS            PROP_TAG(PT_LONG,         0x8147)
#define PR_EMS_AB_TRANS_TIMEOUT_MINS          PROP_TAG(PT_LONG,         0x8148)
#define PR_EMS_AB_TRANSFER_RETRY_INTERVAL     PROP_TAG(PT_LONG,         0x8149)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NON_URGENT PROP_TAG(PT_LONG,         0x814A)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NORMAL     PROP_TAG(PT_LONG,         0x814B)
#define PR_EMS_AB_TRANSFER_TIMEOUT_URGENT     PROP_TAG(PT_LONG,         0x814C)
#define PR_EMS_AB_TRANSLATION_TABLE_USED      PROP_TAG(PT_LONG,         0x814D)
#define PR_EMS_AB_TRANSPORT_EXPEDITED_DATA    PROP_TAG(PT_BOOLEAN,      0x814E)
#define PR_EMS_AB_TRUST_LEVEL                 PROP_TAG(PT_LONG,         0x814F)
#define PR_EMS_AB_TURN_REQUEST_THRESHOLD      PROP_TAG(PT_LONG,         0x8150)
#define PR_EMS_AB_TWO_WAY_ALTERNATE_FACILITY  PROP_TAG(PT_BOOLEAN,      0x8151)
#define PR_EMS_AB_UNAUTH_ORIG_BL              PROP_TAG(PT_MV_TSTRING,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_A            PROP_TAG(PT_MV_STRING8,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_W            PROP_TAG(PT_MV_UNICODE,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_O            PROP_TAG(PT_OBJECT,       0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_T            PROP_TAG(PT_MV_TSTRING,   0x8152)
#define PR_EMS_AB_USER_PASSWORD               PROP_TAG(PT_MV_BINARY,    0x8153)
#define PR_EMS_AB_USN_CHANGED                 PROP_TAG(PT_LONG,         0x8029)
#define PR_EMS_AB_USN_CREATED                 PROP_TAG(PT_LONG,         0x8154)
#define PR_EMS_AB_USN_DSA_LAST_OBJ_REMOVED    PROP_TAG(PT_LONG,         0x8155)
#define PR_EMS_AB_USN_LAST_OBJ_REM            PROP_TAG(PT_LONG,         0x8156)
#define PR_EMS_AB_USN_SOURCE                  PROP_TAG(PT_LONG,         0x8157)
#define PR_EMS_AB_X121_ADDRESS                PROP_TAG(PT_MV_TSTRING,   0x8158)
#define PR_EMS_AB_X121_ADDRESS_A              PROP_TAG(PT_MV_STRING8,   0x8158)
#define PR_EMS_AB_X121_ADDRESS_W              PROP_TAG(PT_MV_UNICODE,   0x8158)
#define PR_EMS_AB_X25_CALL_USER_DATA_INCOMING PROP_TAG(PT_BINARY,       0x8159)
#define PR_EMS_AB_X25_CALL_USER_DATA_OUTGOING PROP_TAG(PT_BINARY,       0x815A)
#define PR_EMS_AB_X25_FACILITIES_DATA_INCOMING PROP_TAG(PT_BINARY,      0x815B)
#define PR_EMS_AB_X25_FACILITIES_DATA_OUTGOING PROP_TAG(PT_BINARY,      0x815C)
#define PR_EMS_AB_X25_LEASED_LINE_PORT        PROP_TAG(PT_BINARY,       0x815D)
#define PR_EMS_AB_X25_LEASED_OR_SWITCHED      PROP_TAG(PT_BOOLEAN,      0x815E)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE        PROP_TAG(PT_TSTRING,      0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_A      PROP_TAG(PT_STRING8,      0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_W      PROP_TAG(PT_UNICODE,      0x815F)
#define PR_EMS_AB_X400_ATTACHMENT_TYPE        PROP_TAG(PT_BINARY,       0x8160)
#define PR_EMS_AB_X400_SELECTOR_SYNTAX        PROP_TAG(PT_LONG,         0x8161)
#define PR_EMS_AB_X500_ACCESS_CONTROL_LIST    PROP_TAG(PT_BINARY,       0x8162)
#define PR_EMS_AB_XMIT_TIMEOUT_NON_URGENT     PROP_TAG(PT_LONG,         0x8163)
#define PR_EMS_AB_XMIT_TIMEOUT_NORMAL         PROP_TAG(PT_LONG,         0x8164)
#define PR_EMS_AB_XMIT_TIMEOUT_URGENT         PROP_TAG(PT_LONG,         0x8165)

#endif /* _EMSABTAG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\wabimp.h ===
/*
 *  wabimp.h
 *
 *  Internal header for wabimp.dll
 *
 *  Copyright 1996-1997 Microsoft Corporation.  All Rights Reserved.
 */

//
// MACROS
//

// Test for PT_ERROR property tag
#define PROP_ERROR(prop) (prop.ulPropTag == PROP_TAG(PT_ERROR, PROP_ID(prop.ulPropTag)))
#define ToUpper(c) (c >= 'a' && c <= 'z') ? ('A' + c - 'a') : c

//
// Property Tags:
//

#define MAX_SCHEMA_PROPID           0x3FFF
#define MIN_NAMED_PROPID            0x8000

// MSN Address properties
#define PR_MSNINET_ADDRESS          PROP_TAG(PT_TSTRING,    0x6001)
#define PR_MSNINET_DOMAIN           PROP_TAG(PT_TSTRING,    0x6002)

//
// Error values
//
#define WAB_W_BAD_EMAIL             MAKE_MAPI_S(0x1000)
#define WAB_W_END_OF_FILE           MAKE_MAPI_S(0x1001)

// Misc defines
#define NOT_FOUND                   ((ULONG)-1)
#define INDEX_FIRST_MIDDLE_LAST     ((ULONG)-2)
#define NUM_EXPORT_WIZARD_PAGES     2
#define NUM_IMPORT_WIZARD_PAGES     2

// Netscape, Eudora, Athena16 importer defines
#define NETSCAPE                    500
#define EUDORA                      501
#define ATHENA16                    502
#define MAX_FILE_NAME               500         // BUGBUG: Should be MAX_PATH?
#define MAX_STRING_SIZE             30          // BUGBUG: Should be larger?
#define MAX_MESSAGE                 500
#define ATHENASTRUCTURE             190
#define ATHENAADROFFSET             28
#define EUDORA_STRUCT               16

// Athena
#define MAX_NAME_SIZE               80
#define MAX_EMA_SIZE                80

#define hrINVALIDFILE               600         // BUGBUG: Should use MAKE_MAPI_E
#define hrMemory	                 601         // BUGBUG: Should use MAPI_E_NOT_ENOUGH_MEMORY



//
// Types
//

// Index of icons in the bitmap
enum {
    iiconStateUnchecked,
    iiconStateChecked,
    iiconStMax
};

typedef enum {
    INDEX_EXPORT_PAB = 0,
    INDEX_EXPORT_CSV
} INDEX_EXPORT, *LPINDEX_EXPORT;


typedef enum {
    CONFIRM_YES,
    CONFIRM_NO,
    CONFIRM_YES_TO_ALL,
    CONFIRM_NO_TO_ALL,
    CONFIRM_ERROR,
    CONFIRM_ABORT
} CONFIRM_RESULT, *LPCONFIRM_RESULT;


typedef struct _ReplaceInfo {
    LPTSTR lpszDisplayName;         // Conflicting display name
    LPTSTR lpszEmailAddress;        // Conflicting email address
    CONFIRM_RESULT ConfirmResult;   // Results from dialog
    BOOL fExport;                   // TRUE if this is an export operation
    union {
        LPWAB_IMPORT_OPTIONS lpImportOptions;
        LPWAB_EXPORT_OPTIONS lpExportOptions;
    };
} REPLACE_INFO, * LPREPLACE_INFO;

typedef enum {
    ERROR_OK,
    ERROR_ABORT
} ERROR_RESULT, *LPERROR_RESULT;

typedef struct _ErrorInfo {
    LPTSTR lpszDisplayName;         // Problem display name
    LPTSTR lpszEmailAddress;        // Problem email address
    ERROR_RESULT ErrorResult;       // Results from dialog
    ULONG ids;                      // string resource identifier for error message
    BOOL fExport;                   // TRUE if this is an export operation
    union {
        LPWAB_IMPORT_OPTIONS lpImportOptions;
        LPWAB_EXPORT_OPTIONS lpExportOptions;
    };
} ERROR_INFO, * LPERROR_INFO;


typedef struct _EntrySeen {
    SBinary sbinPAB;                // MAPI entry
    SBinary sbinWAB;                // WAB entry
} ENTRY_SEEN, * LPENTRY_SEEN;

typedef struct _TargetInfo {
    LPTSTR lpRegName;
    LPTSTR lpDescription;
    LPTSTR lpDll;
    LPTSTR lpEntry;
    union {
        LPWAB_EXPORT lpfnExport;
        LPWAB_IMPORT lpfnImport;
    };
} TARGET_INFO, *LPTARGET_INFO;


enum {
    iconPR_DEF_CREATE_MAILUSER = 0,
    iconPR_DEF_CREATE_DL,
    iconMax
};

enum {
    ieidPR_ENTRYID = 0,
    ieidMax
};

enum {
    iptaColumnsPR_OBJECT_TYPE = 0,
    iptaColumnsPR_ENTRYID,
    iptaColumnsPR_DISPLAY_NAME,
    iptaColumnsPR_EMAIL_ADDRESS,
    iptaColumnsMax
};

typedef struct _PropNames {
    ULONG ulPropTag;        // property tag
    BOOL fChosen;           // use this property tag
    ULONG ids;              // string id
    LPTSTR lpszName;        // string (read in from resources)
    LPTSTR lpszCSVName;     // name of CSV field (from import file)
} PROP_NAME, *LPPROP_NAME;


// PAB

// State Identifiers
typedef enum {
    STATE_IMPORT_MU,
    STATE_IMPORT_NEXT_MU,
    STATE_IMPORT_DL,
    STATE_IMPORT_NEXT_DL,
    STATE_IMPORT_FINISH,
    STATE_IMPORT_ERROR,
    STATE_IMPORT_CANCEL,
    STATE_EXPORT_MU,
    STATE_EXPORT_NEXT_MU,
    STATE_EXPORT_DL,
    STATE_EXPORT_NEXT_DL,
    STATE_EXPORT_FINISH,
    STATE_EXPORT_ERROR,
    STATE_EXPORT_CANCEL
} PAB_STATE, *LPPAB_STATE;


// NetScape
typedef struct tagDistList {
    int AliasID;
    struct tagDistList *lpDist;
} NSDistList, NSDISTLIST, *LPNSDISTLIST;


typedef struct tagAdrBook {
    ULONG   AliasID;            // The AliasID value
    BOOL    Sbinary;
    BOOL    DistList;
    TCHAR   *Address;
    TCHAR   *NickName;
    TCHAR   *Entry;
    TCHAR   *Description;
    LPNSDISTLIST  lpDist;
} NSAdrBook, NSADRBOOK, *LPNSADRBOOK;

// Eudora
typedef struct tagEudDistList {
    BOOL    flag;			     // To check whether it is a alias or a simple address
    TCHAR   *NickName;
    TCHAR   *Address;
    TCHAR   *Description;
    int     AliasID;            // ID of the member if it is a simple address
    struct tagEudDistList *lpDist;  //pointer to the next entry of DL.
} EudDistList, EUDDISTLIST, *LPEUDDISTLIST;

typedef struct tagEUDAdrBook {
    TCHAR *Address;
    TCHAR *NickName;
    TCHAR *Description;
    LPEUDDISTLIST lpDist;
} EudAdrBook, EUDADRBOOK, *LPEUDADRBOOK;


// Athena16
typedef struct tagABCREC {
    TCHAR DisplayName[MAX_NAME_SIZE + 1];
    TCHAR EmailAddress[MAX_EMA_SIZE + 1];
} ABCREC, *LPABCREC;

#define CBABCREC sizeof(ABCREC)


extern const TCHAR szTextFilter[];
extern const TCHAR szAllFilter[];

extern const UCHAR szQuote[];
extern const TCHAR szMSN[];
extern const TCHAR szMSNINET[];
extern const TCHAR szCOMPUSERVE[];
extern const TCHAR szFAX[];
extern const TCHAR szSMTP[];
extern const TCHAR szMS[];
extern const TCHAR szEX[];
extern const TCHAR szX400[];
extern const TCHAR szMSA[];
extern const TCHAR szMAPIPDL[];
extern const TCHAR szEmpty[];
extern const TCHAR szAtSign[];
#define cbAtSign        (2 * sizeof(TCHAR))

extern const TCHAR szMSNpostfix[];
#define cbMSNpostfix    (9 * sizeof(TCHAR))

extern const TCHAR szCOMPUSERVEpostfix[];
#define cbCOMPUSERVEpostfix     (16 * sizeof(TCHAR))

extern PROP_NAME rgPropNames[];
extern LPPROP_NAME lpImportMapping;
extern HINSTANCE hInst;
extern HINSTANCE hInstApp;

extern LPENTRY_SEEN lpEntriesSeen;
extern ULONG ulEntriesSeen;
extern ULONG ulMaxEntries;

extern LPSPropValue lpCreateEIDsWAB;
extern LPSPropValue lpCreateEIDsMAPI;

extern ULONG ulcEntries;

#ifndef _WABIMP_C
#define ExternSizedSPropTagArray(_ctag, _name) \
extern const struct _SPropTagArray_ ## _name \
{ \
    ULONG   cValues; \
    ULONG   aulPropTag[_ctag]; \
} _name

ExternSizedSPropTagArray(iptaColumnsMax, ptaColumns);
ExternSizedSPropTagArray(ieidMax, ptaEid);
ExternSizedSPropTagArray(iconMax, ptaCon);


#endif


//
// WABIMP.C
//
HRESULT OpenWabContainer(LPABCONT *lppWabContainer, LPADRBOOK lpAdrBook);
BOOL GetFileToImport(HWND hwnd, LPTSTR szFileName, int type);
INT_PTR CALLBACK ReplaceDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ErrorDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
HRESULT GetRegistryPath(LPTSTR szFileName, int type);
HRESULT GetExistEntry(LPABCONT lpWabContainer, LPSBinary lpsbinary, ULONG ucount,
  LPTSTR szDisplayName, LPTSTR szNickName);
void FreeRowSet(LPSRowSet lpRows);
LPTSTR LoadAllocString(int StringID);
LPTSTR LoadStringToGlobalBuffer(int StringID);
ULONG SizeLoadStringToGlobalBuffer(int StringID);
HRESULT FillMailUser(HWND hwnd, LPABCONT lpWabContainer, LPSPropValue sProp,
  LPWAB_IMPORT_OPTIONS lpOptions, void *lpeudAdrBook, LPSBinary lpsbinary,
  ULONG ul,int type);
INT_PTR CALLBACK ComDlg32DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void WABFreeProws(LPSRowSet prows);
LPTSTR PropStringOrNULL(LPSPropValue lpspv);
LPTSTR GetEMSSMTPAddress(LPMAPIPROP lpObject, LPVOID lpBase);
void FreeSeenList(void);
extern ULONG CountRows(LPMAPITABLE lpTable, BOOL fMAPI);
extern void WABFreePadrlist(LPADRLIST lpAdrList);
extern SCODE WABFreeBuffer(LPVOID lpBuffer);
extern SCODE WABAllocateMore(ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer);
extern SCODE WABAllocateBuffer(ULONG cbSize, LPVOID FAR * lppBuffer);
extern INT_PTR CALLBACK ErrorDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
extern LPTSTR FindStringInProps(LPSPropValue lpspv, ULONG ulcProps, ULONG ulPropTag);
extern LPSBinary FindAdrEntryID(LPADRLIST lpAdrList, ULONG index);
extern void SetGlobalBufferFunctions(LPWABOBJECT lpWABObject);
BOOL IsSpace(LPTSTR lpChar);
HRESULT SaveFileDialog(HWND hWnd,
  LPTSTR szFileName,
  LPCTSTR lpFilter1,
  ULONG idsFileType1,
  LPCTSTR lpFilter2,
  ULONG idsFileType2,
  LPCTSTR lpFilter3,
  ULONG idsFileType3,
  LPCTSTR lpDefExt,
  ULONG ulFlags,
  HINSTANCE hInst,
  ULONG idsTitle,
  ULONG idsSaveButton);
HRESULT OpenFileDialog(HWND hWnd,
  LPTSTR szFileName,
  LPCTSTR lpFilter1,
  ULONG idsFileType1,
  LPCTSTR lpFilter2,
  ULONG idsFileType2,
  LPCTSTR lpFilter3,
  ULONG idsFileType3,
  LPCTSTR lpDefExt,
  ULONG ulFlags,
  HINSTANCE hInst,
  ULONG idsTitle,
  ULONG idsOpenButton);
int __cdecl ShowMessageBoxParam(HWND hWndParent, int MsgId, int ulFlags, ...);
extern void WABFreePadrlist(LPADRLIST lpAdrList);
extern SCODE WABFreeBuffer(LPVOID lpBuffer);
extern SCODE WABAllocateMore(ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer);
extern SCODE WABAllocateBuffer(ULONG cbSize, LPVOID FAR * lppBuffer);
extern void SetGlobalBufferFunctions(LPWABOBJECT lpWABObject);
HRESULT LoadWABEIDs(LPADRBOOK lpAdrBook, LPABCONT * lppContainer);


//
// NetScape
//
HRESULT MigrateUser(HWND hwnd,  LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook);
HRESULT  ParseAddressBook(HWND hwnd, LPTSTR szFileName, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook);
HRESULT ParseAddress(HWND hwnd, LPTSTR szBuffer, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook);
HRESULT GetAdrBuffer(LPTSTR *szBuffer, LPTSTR *szAdrBuffer);
HRESULT ProcessAdrBuffer(HWND hwnd,LPTSTR AdrBuffer, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook);
BOOL GetAdrLine(LPTSTR *szCurPointer, LPTSTR *szBuffer, LPTSTR *szDesc);
HRESULT ProcessLn(LPTSTR *szL, LPTSTR *szDesc, NSADRBOOK *nsAdrBook, LPTSTR *szBuffer);
ULONG GetAddressCount(LPTSTR AdrBuffer);
LPTSTR  GetAdrStart(LPTSTR szBuffer);
LPTSTR GetDLNext(LPTSTR szBuffer);
LPTSTR  GetAdrEnd(LPTSTR szBuffer);
ULONG GetAddrCount(LPTSTR AdrBuffer);
HRESULT FillDistList(HWND hwnd, LPABCONT lpWabContainer, LPSPropValue sProp,
  LPWAB_IMPORT_OPTIONS lpOptions, LPNSADRBOOK lpnAdrBook, LPSBinary lpsbinary,
  LPADRBOOK lpAdrBook);
HRESULT FillWABStruct(LPSPropValue rgProps, NSADRBOOK *nsAdrBook);
HRESULT CreateDistEntry(LPABCONT lpWabContainer, LPSPropValue sProp,
  ULONG ulCreateEntries, LPMAPIPROP *lppMailUserWab);
LPNSDISTLIST FreeNSdistlist(LPNSDISTLIST lpDist);

//
// Eudora
//
HRESULT MigrateEudoraUser(HWND hwnd, LPABCONT lpWabContainer,
  LPWAB_IMPORT_OPTIONS lpOptions, LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPADRBOOK lpAdrBook);
ULONG ParseEudAddress(LPTSTR szFileName,LPEUDADRBOOK *lpeudAdrBook);
HRESULT ParseAddressTokens(LPTSTR szBuffer,LPTSTR szAdrBuffer, UINT ulCount,
  LPTSTR *szAliaspt, EUDADRBOOK *EudAdrBook);
HRESULT CreateAdrLineBuffer(LPTSTR *szAdrline, LPTSTR szAdrBuffer, ULONG ulAdrOffset,
  ULONG ulAdrSize);
HRESULT ParseAdrLineBuffer(LPTSTR szAdrLine, LPTSTR *szAliasptr, ULONG uToken,
  EUDADRBOOK *EudAdrBook);
BOOL SearchAdrName(LPTSTR szAdrCur);
INT SearchName(LPTSTR *szAliasptr, LPTSTR szAdrCur);
HRESULT ImportEudUsers(HWND hwnd,LPTSTR szFileName, LPABCONT lpWabContainer,
  LPSPropValue sProp, LPEUDADRBOOK lpeudAdrBook, ULONG ulCount,
  LPWAB_IMPORT_OPTIONS lpOptions, LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPADRBOOK lpAdrBook);
HRESULT FillEudDistList(HWND hWnd, LPABCONT lpWabContainer, LPSPropValue sProp,
   LPWAB_IMPORT_OPTIONS lpOptions, LPEUDADRBOOK lpeudAdrBook, LPSBinary lpsbinary,
   LPADRBOOK lpAdrBook, ULONG ul);
HRESULT FillEudWABStruct(LPSPropValue rgProps, EUDADRBOOK *eudAdrBook);
void FillEudDiststruct(LPSPropValue rgProps, EUDADRBOOK *eudAdrBook);
LPEUDDISTLIST FreeEuddistlist(LPEUDDISTLIST lpDist);
char* Getstr(char* szSource, char* szToken);
ULONG ShiftAdd(int offset, TCHAR *szBuffer);

//
// Athena16
//
HRESULT MigrateAthUser(HWND hwnd,  LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook) ;
HRESULT  ParseAthAddressBook(HWND hwnd, LPTSTR szFileName,
  LPWAB_IMPORT_OPTIONS lpOptions, LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPADRBOOK lpAdrBook);
HRESULT FillAthenaUser(HWND hwnd, LPABCONT lpWabContainer, LPSPropValue sProp,
  LPWAB_IMPORT_OPTIONS lpOptions, LPABCREC lpabcrec);

//
// Functions in csvpick.c
//
int APIENTRY PickExportProps(LPPROP_NAME rgPropNames);
HRESULT ExportWizard(HWND hWnd, LPTSTR szFileName, LPPROP_NAME rgPropNames);
HRESULT ImportWizard(HWND hWnd, LPTSTR szFileName, LPPROP_NAME rgPropNames,
  LPTSTR szSep, LPPROP_NAME * lppImportMapping, LPULONG lpcFields, LPHANDLE lphFile);

//
// Functions in csvparse.c
//
HRESULT ReadCSVLine(HANDLE hFile, LPTSTR szSep, ULONG * lpcItems, PUCHAR ** lpprgItems);

// Functions in pab.c
HRESULT HrLoadPrivateWABPropsForCSV(LPADRBOOK );

LPWABOPEN lpfnWABOpen;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\convert\wmnets\wabimp.c ===
/******************************************************************************
    FILENAME:       wabimp.c
    MODULE:         DLL for PAB, CSV, NetScape, Eudora and Athena16 address book
                    conversions.
    PURPOSE:        Contains modules which will implement importing
                    MAPI PAB, CSV, NetScape, Eudora and Athena16
                    address book to Athena32 (WAB).

    EXPORTED FUNCTIONS: STDMETHODIMP NetscapeImport(HWND hwnd, LPADRBOOK lpAdrBook,
                            LPWABOBJECT lpWABObject,
                            LPWAB_PROGRESS_CALLBACK lpProgressCB,
                            LPWAB_IMPORT_OPTIONS lpOptions)
                        STDMETHODIMP Athena16Import(HWND hwnd,LPADRBOOK lpAdrBook,
                            LPWABOBJECT lpWABObject,
                            LPWAB_PROGRESS_CALLBACK lpProgressCB,
                            LPWAB_IMPORT_OPTIONS lpOptions)
                        STDMETHODIMP EudoraImport(HWND hwnd,LPADRBOOK lpAdrBook,
                            LPWABOBJECT lpWABObject,
                            LPWAB_PROGRESS_CALLBACK lpProgressCB,
                            LPWAB_IMPORT_OPTIONS lpOptions)

    Programmer(s): Arathi (NetQuest)
                   Radhika (NetQuest)
                   Krishnamoorthy SeethaRaman(NetQuest)


    Revision History:

    4/7/97 - vikramm    Fix Bugs: Netscape Display Names not being imported.
                        "Replace Import" dialog has no parent.
    4/8/97 - vikramm    Fix Bugs: Handle Leak.
                        Add code to look for additional Eudora address books
                          that may be in subdirectories ...
    4/9/97 - vikramm    Change the Eudora registry search path ...
                        Fix Bugs: Looking in wrong reg Key for Netscape on NT
                          and wrongly assuming key exists for pre netscape 3.0
                        Change dialog messages.
*******************************************************************************/

//Includes
#define _WABIMP_C

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabmig.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <dbgutil.h>
#include "..\..\wab32res\resrc2.h"
#include <wabimp.h>
#include <string.h>
#include <advpub.h>
#include <shlwapi.h>

// Per-process Globals
TCHAR szGlobalAlloc[MAX_MESSAGE];                  // Buffer used for LoadString
TCHAR szGlobalTempAlloc[MAX_MESSAGE];

const TCHAR szTextFilter[] = "*.txt";
const TCHAR szAllFilter[] = "*.*";

const TCHAR szMSN[] = "MSN";
const TCHAR szMSNINET[] = "MSNINET";
const TCHAR szCOMPUSERVE[] = "COMPUSERVE";
const TCHAR szFAX[] = "FAX";
const TCHAR szSMTP[] = "SMTP";
const TCHAR szMS[] = "MS";
const TCHAR szEX[] = "EX";
const TCHAR szX400[] = "X400";
const TCHAR szMSA[] = "MSA";
const TCHAR szMAPIPDL[] = "MAPIPDL";
const TCHAR szEmpty[] = "";
const TCHAR szDescription[] = "description";
const TCHAR szDll[] = "dll";
const TCHAR szEntry[] = "entry";
const TCHAR szEXPORT[] = "EXPORT";
const TCHAR szIMPORT[] = "IMPORT";

const TCHAR szAtSign[] = "@";
const TCHAR szMSNpostfix[] = "@msn.com";
const TCHAR szCOMPUSERVEpostfix[] = "@compuserve.com";
LPENTRY_SEEN lpEntriesSeen = NULL;
ULONG ulEntriesSeen = 0;
ULONG ulMaxEntries = 0;
const LPTSTR szWABKey = "Software\\Microsoft\\WAB";
LPTARGET_INFO rgTargetInfo = NULL;


HINSTANCE hInst = NULL;
HINSTANCE hInstApp = NULL;

//
// Properties to get for each row of the contents table
//
const SizedSPropTagArray(iptaColumnsMax, ptaColumns) =
{
    iptaColumnsMax,
    {
        PR_OBJECT_TYPE,
        PR_ENTRYID,
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
    }
};


const SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_ENTRYID,
    }
};

const SizedSPropTagArray(iconMax, ptaCon)=
{
    iconMax,
    {
        PR_DEF_CREATE_MAILUSER,
        PR_DEF_CREATE_DL,
    }
};



//  Global WAB Allocator access functions
//

typedef struct _WAB_ALLOCATORS {
    LPWABOBJECT lpWABObject;
    LPWABALLOCATEBUFFER lpAllocateBuffer;
    LPWABALLOCATEMORE lpAllocateMore;
    LPWABFREEBUFFER lpFreeBuffer;
} WAB_ALLOCATORS, *LPWAB_ALLOCATORS;

WAB_ALLOCATORS WABAllocators = {0};


/******************************************************************************

    Name      : SetGlobalBufferFunctions

    Purpose   : Set the global buffer functions based on methods from
                the WAB object.

    Parameters: lpWABObject = the open wab object

    Returns   : none

    Comment   :

******************************************************************************/
void SetGlobalBufferFunctions(LPWABOBJECT lpWABObject)
{
    if (lpWABObject && ! WABAllocators.lpWABObject) {
        WABAllocators.lpAllocateBuffer = lpWABObject->lpVtbl->AllocateBuffer;
        WABAllocators.lpAllocateMore = lpWABObject->lpVtbl->AllocateMore;
        WABAllocators.lpFreeBuffer = lpWABObject->lpVtbl->FreeBuffer;
        WABAllocators.lpWABObject = lpWABObject;
    }
}


/******************************************************************************

    Name      : WABAllocateBuffer

    Purpose   : Use the WAB Allocator

    Parameters: cbSize = size to allocate
                lppBuffer = returned buffer

    Returns   : SCODE

    Comment   :

*******************************************************************************/
SCODE WABAllocateBuffer(ULONG cbSize, LPVOID FAR * lppBuffer)
{
    if (WABAllocators.lpWABObject && WABAllocators.lpAllocateBuffer) {
        return(WABAllocators.lpAllocateBuffer(WABAllocators. lpWABObject, cbSize,
          lppBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


/******************************************************************************

    Name      : WABAllocateMore

    Purpose   : Use the WAB Allocator

    Parameters: cbSize = size to allocate
                lpObject = existing allocation
                lppBuffer = returned buffer

    Returns   : SCODE

    Comment   :

*******************************************************************************/
SCODE WABAllocateMore(ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer)
{
    if (WABAllocators.lpWABObject && WABAllocators.lpAllocateMore) {
        return(WABAllocators.lpAllocateMore(WABAllocators. lpWABObject, cbSize,
          lpObject, lppBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


/******************************************************************************

    Name      : WABFreeBuffer

    Purpose   : Use the WAB Allocator

    Parameters: lpBuffer = buffer to free

    Returns   : SCODE

    Comment   :

*******************************************************************************/
SCODE WABFreeBuffer(LPVOID lpBuffer)
{
    if (WABAllocators.lpWABObject && WABAllocators.lpFreeBuffer) {
        return(WABAllocators.lpFreeBuffer(WABAllocators.lpWABObject, lpBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


/***************************************************************************

    Name      : IsSpace

    Purpose   : Does the single or DBCS character represent a space?

    Parameters: lpChar -> SBCS or DBCS character

    Returns   : TRUE if this character is a space

    Comment   :

***************************************************************************/
BOOL IsSpace(LPTSTR lpChar) {
    Assert(lpChar);
    if (*lpChar) {
        if (IsDBCSLeadByte(*lpChar)) {
            WORD CharType[2] = {0};

            GetStringTypeA(LOCALE_USER_DEFAULT,
              CT_CTYPE1,
              lpChar,
              2,    // Double-Byte
              CharType);
            return(CharType[0] & C1_SPACE);
        } else {
            return(*lpChar == ' ');
        }
    } else {
        return(FALSE);  // end of string
    }
}


/******************************************************************************

    Name      : NetscapeImport

    Purpose   : Entry Point for NetScape Addressbook import

    Parameters: hwnd = Handle to the parent Window
                lpAdrBook = pointer to the IADRBOOK interface
                lpWABObject = pointer to IWABOBJECT interface
                lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
                lpOptions = pointer to WAB_IMPORT_OPTIONS structure

    Returns   :

    Comment   :

/******************************************************************************/
STDMETHODIMP NetscapeImport(HWND hwnd, LPADRBOOK lpAdrBook,
  LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPWAB_IMPORT_OPTIONS lpOptions)
{
    HRESULT hResult = S_OK;

    SetGlobalBufferFunctions(lpWABObject);

    hResult = MigrateUser(hwnd, lpOptions, lpProgressCB, lpAdrBook);
    if (hResult == hrMemory) {
        lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MEMORY));
        MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE),MB_OK);
    }

    return(hResult);
}


/******************************************************************************

    Name      : Athena16Import

    Purpose   : Entry Point for Athena 16 Addressbook import

    Parameters: hwnd = Handle to the parent Window
                lpAdrBook = pointer to the IADRBOOK interface
                lpWABObject = poiinter to IWABOBJECT interface
                lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
                lpOptions = pointer to WAB_IMPORT_OPTIONS structure

    Returns   :

    Comment   :

/******************************************************************************/
STDMETHODIMP Athena16Import(HWND hwnd, LPADRBOOK lpAdrBook, LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPWAB_IMPORT_OPTIONS lpOptions)
{
    HRESULT hResult = S_OK;

    SetGlobalBufferFunctions(lpWABObject);

    hResult = MigrateAthUser(hwnd, lpOptions, lpProgressCB,lpAdrBook);

    return(hResult);
}


/******************************************************************************

    Name      : EudoraImport

    Purpose   : Entry Point for Eudora Addressbook import

    Parameters: hwnd = Handle to the parent Window
                lpAdrBook = pointer to the IADRBOOK interface
                lpWABObject = poiinter to IWABOBJECT interface
                lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
                lpOptions = pointer to WAB_IMPORT_OPTIONS structure

    Returns   :

    Comment   :

/******************************************************************************/
STDMETHODIMP EudoraImport(HWND hwnd,LPADRBOOK lpAdrBook, LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPWAB_IMPORT_OPTIONS lpOptions)
{

    LPABCONT lpWabContainer = NULL;
    HRESULT hResult = S_OK;

    SetGlobalBufferFunctions(lpWABObject);

    if (FAILED(hResult = OpenWabContainer(&lpWabContainer, lpAdrBook))) {
        goto Error;
    }

    hResult = MigrateEudoraUser(hwnd,lpWabContainer,lpOptions,lpProgressCB,lpAdrBook);

    if (hResult == hrMemory) {
        lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MEMORY));
        MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE),MB_OK);
    }

    if (lpWabContainer) {
        lpWabContainer->lpVtbl->Release(lpWabContainer);
    }

Error:
    return(hResult);
}


STDMETHODIMP NetscapeExport(HWND hwnd, LPADRBOOK lpAdrBook, LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPWAB_IMPORT_OPTIONS lpOptions)
{
    SCODE sc = SUCCESS_SUCCESS;
    HRESULT hResult = hrSuccess;

    SetGlobalBufferFunctions(lpWABObject);

    return(hResult);
}


STDMETHODIMP Athena16Export(HWND hwnd, LPADRBOOK lpAdrBook, LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPWAB_IMPORT_OPTIONS lpOptions)
{
    SCODE sc = SUCCESS_SUCCESS;
    HRESULT hResult = hrSuccess;

    SetGlobalBufferFunctions(lpWABObject);

    return(hResult);
}


STDMETHODIMP EudoraExport(HWND hwnd, LPADRBOOK lpAdrBook, LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPWAB_IMPORT_OPTIONS lpOptions)
{
    SCODE sc = SUCCESS_SUCCESS;
    HRESULT hResult = hrSuccess;

    SetGlobalBufferFunctions(lpWABObject);

    return(hResult);
}


/******************************************************************************
 *********************NetScape Functions***************************************
 ******************************************************************************
 *  FUNCTION NAME:MigrateUser
 *
 *  PURPOSE:    Get the installation path of the address book and starts processing
 *              the NetScape address book
 *
 *  PARAMETERS: hwnd = Handle to the parent Window
 *              lpAdrBook = pointer to the IADRBOOK interface
 *              lpWABObject = poiinter to IWABOBJECT interface
 *              lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT MigrateUser(HWND hwnd, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook)
{
    TCHAR szFileName[MAX_FILE_NAME];
    HRESULT hResult;
    HANDLE h1 = NULL;
    WIN32_FIND_DATA    lpFindFileData;


    if (0 != (hResult= GetRegistryPath(szFileName, NETSCAPE))) {
        lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_STRING_SELECTPATH));
        if (IDNO ==MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE),MB_YESNO)) {
            return(ResultFromScode(MAPI_E_USER_CANCEL));
        }

        if (FALSE ==GetFileToImport(hwnd, szFileName, NETSCAPE)) {
            return(ResultFromScode(MAPI_E_USER_CANCEL));
        }
    } else {
        lstrcat(szFileName, LoadStringToGlobalBuffer(IDS_NETSCAPE_ADDRESSBOOK));
        h1 =FindFirstFile(szFileName,&lpFindFileData);
        if (h1 == INVALID_HANDLE_VALUE) {
            lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ADDRESS_HTM));
            if (IDNO==MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ERROR),MB_YESNO)) {
                h1=NULL;
                return(ResultFromScode(MAPI_E_USER_CANCEL));

            }
            if (FALSE ==GetFileToImport(hwnd, szFileName,NETSCAPE)) {
                h1=NULL;
                return(ResultFromScode(MAPI_E_USER_CANCEL));
            }
        }
        FindClose(h1);
    }

    hResult = ParseAddressBook(hwnd,szFileName,lpOptions,lpProgressCB,lpAdrBook);
    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:ParseAddressBook
 *
 *  PURPOSE:    Open the address book file ,put the data in a buffer and call
 *              the ParseAddress function to do the parsing
 *
 *  PARAMETERS: hwnd = Handle to the parent Window
 *              lpAdrBook = pointer to the IADRBOOK interface
 *              lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *              szFileName = Filename of the address book
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT ParseAddressBook(HWND hwnd, LPTSTR szFileName, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook)
{
    ULONG ulRead = 0;
    HANDLE hFile = NULL;
    ULONG ulFileSize = 0;
    LPTSTR szBuffer = NULL;
    HRESULT hResult;

    hFile = CreateFile(szFileName,
      GENERIC_READ,
      FILE_SHARE_READ,
      NULL,
      OPEN_EXISTING,
      FILE_FLAG_SEQUENTIAL_SCAN,
      NULL);

    if (INVALID_HANDLE_VALUE == hFile) {
        return(ResultFromScode(MAPI_E_NOT_FOUND));
    }

    ulFileSize = GetFileSize(hFile,NULL);

    szBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulFileSize+1));

    if (!szBuffer) {
        hResult = hrMemory;
        goto Error;
    }

    if (! ReadFile(hFile, szBuffer, ulFileSize, &ulRead, NULL)) {
        goto Error;
    }

    hResult = ParseAddress(hwnd,szBuffer,lpOptions,lpProgressCB,lpAdrBook);

Error:
    if (szBuffer) {
        LocalFree((HLOCAL)szBuffer);
    }
    if (hFile) {
        CloseHandle(hFile);
    }

    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:ParseAddress
 *
 *  PURPOSE: Gets the address portion of the address book in a buffer and calls
 *           ProcessAdrBuffer for further processing
 *
 *  PARAMETERS: hwnd = Handle to the parent Window
 *              lpAdrBook = pointer to the IADRBOOK interface
 *              lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *              szBuffer = Address book in a buffer
 *
 *  RETURNS: HRESULT
 ******************************************************************************/

HRESULT ParseAddress(HWND hwnd, LPTSTR szBuffer, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook)
{
    LPTSTR AdrBuffer = NULL;        //address starting <DL> to ending </DL>
    HRESULT hResult = S_OK;

    hResult = GetAdrBuffer(&szBuffer, &AdrBuffer);
    if (hrMemory == hResult)
        goto Error;
    if (hrINVALIDFILE == hResult) {
        lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_INVALID_FILE));
        MessageBox(hwnd,szGlobalTempAlloc,LoadStringToGlobalBuffer(IDS_ERROR), MB_OK);
        hResult = ResultFromScode(MAPI_E_CALL_FAILED);
        goto Error;
    }

    hResult = ProcessAdrBuffer(hwnd,AdrBuffer,lpOptions,lpProgressCB,lpAdrBook);

Error:
    if (AdrBuffer)
        LocalFree((HLOCAL)AdrBuffer);
    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME: GetAdrBuffer
 *
 *  PURPOSE: Gets the address portion of the address book in a buffer
 *
 *  PARAMETERS: szBuffer = points to the complete address book
 *              szAdrBuffer = output buffer which gets filled up
 *
 *  RETURNS: HRESULT
 ******************************************************************************/
HRESULT GetAdrBuffer(LPTSTR *szBuffer, LPTSTR *szAdrBuffer)
{
    LPTSTR szAdrStart = NULL, szAdrBufStart = NULL, szAdrBufEnd = NULL;
    ULONG ulSize = 0;


    // Get Adr Start
    szAdrBufStart = GetAdrStart((*szBuffer));

    szAdrBufEnd = GetAdrEnd((*szBuffer));

    if (NULL == szAdrBufStart || NULL == szAdrBufEnd) {
        return(hrINVALIDFILE);
    }

    if (szAdrBufEnd - szAdrBufStart) {
        ulSize = (ULONG) (szAdrBufEnd - szAdrBufStart);
    }

    if (ulSize) {

        *szAdrBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulSize+1));

        if (!*szAdrBuffer) {
            return(hrMemory);
        }
        lstrcpyn(*szAdrBuffer, szAdrBufStart, ulSize);
        *szBuffer= szAdrBufEnd;
    }

    return(S_OK);

}

/******************************************************************************
 *  FUNCTION NAME:ProcessAdrBuffer
 *
 *  PURPOSE:    Gets the individual address and then fills up the WAB by calling
                appropriate functions.
 *
 *  PARAMETERS: hwnd = Handle to the parent Window
 *              lpAdrBook = pointer to the IADRBOOK interface
 *              lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *              AdrBuffer = all the addresses in a buffer
 *
 *  RETURNS: HRESULT
 ******************************************************************************/
HRESULT ProcessAdrBuffer(HWND hwnd, LPTSTR AdrBuffer, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook)
{
    LPTSTR szL = NULL, szDesc = NULL, szLine = NULL, szDescription = NULL;
    ULONG ulCount = 0;
    NSADRBOOK nsAdrBook;
    ULONG cCurrent = 0;
    LPSBinary lpsbinary = NULL;
    LPABCONT lpWabContainer = NULL;
    ULONG cProps;
    HRESULT hResult = S_OK;
    static LPSPropValue sProp = NULL;
    WAB_PROGRESS Progress;
    ULONG ul = 0;


    ul = GetAddressCount(AdrBuffer);
    if (0 == ul) {
        lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_NO_ENTRY));
        MessageBox(hwnd,szGlobalTempAlloc,LoadStringToGlobalBuffer(IDS_MESSAGE),MB_OK);
        return(S_OK);
    }

    ulCount=GetAddrCount((AdrBuffer));

    if (ulCount) {
        lpsbinary = (LPSBinary)LocalAlloc(LMEM_FIXED,((ulCount+1)*sizeof(SBinary)));
        if (! lpsbinary) {
            return(hrMemory);
        }
        memset(lpsbinary,0,((ulCount+1) * sizeof(SBinary)));
    }

    if (0 != (hResult = OpenWabContainer(&lpWabContainer, lpAdrBook))) {
        return(hResult);
    }
    if (0 != (hResult = lpWabContainer->lpVtbl->GetProps(lpWabContainer,
      (LPSPropTagArray)&ptaCon, 0, &cProps, (LPSPropValue *)&sProp))) {
        if (hResult == MAPI_W_ERRORS_RETURNED) {
            WABFreeBuffer(sProp);
            sProp = NULL;
        }
        goto Error;
    }
    Progress.denominator = ul;
    Progress.numerator = 0;
    Progress.lpText = NULL;
    ul = 0;
    while (GetAdrLine(&AdrBuffer, &szL, &szDesc)) {
        szLine = szL;
        szDescription = szDesc;

        Progress.numerator = ul++;
        lpProgressCB(hwnd,&Progress);


        if (0 == (hResult = ProcessLn(&szLine, &szDescription,&nsAdrBook,&AdrBuffer))) {
            if (nsAdrBook.DistList) {
                hResult=FillDistList(hwnd, lpWabContainer,sProp,lpOptions,&nsAdrBook,
                  lpsbinary,lpAdrBook);
            } else {
                hResult = FillMailUser(hwnd, lpWabContainer,sProp, lpOptions,(void *)&nsAdrBook,
                  lpsbinary,0,NETSCAPE);
            }
        }


        if (szL) {
            LocalFree((HLOCAL)szL);
            szL = NULL;
        }
        if (szDesc) {
            LocalFree(szDesc);
            szDesc = NULL;
        }
        if (nsAdrBook.Description) {
            LocalFree((HLOCAL)nsAdrBook.Description);
        }
        nsAdrBook.Description = NULL;
        if (nsAdrBook.NickName) {
            LocalFree((HLOCAL)nsAdrBook.NickName);
        }
        nsAdrBook.NickName = NULL;
        if (nsAdrBook.Address) {
            LocalFree((HLOCAL)nsAdrBook.Address);
        }
        nsAdrBook.Address = NULL;
        if (nsAdrBook.Entry) {
            LocalFree((HLOCAL)nsAdrBook.Entry);
        }
        nsAdrBook.Entry = NULL;
        if (hrMemory == hResult) {
            break;
        }


    }

    if (sProp) {
        WABFreeBuffer(sProp);
        sProp = NULL;
    }

Error:
    if (NULL != lpsbinary) {
        for (ul=0; ul < ulCount + 1; ul++) {
            if (lpsbinary[ul].lpb) {
                LocalFree((HLOCAL)lpsbinary[ul].lpb);
                lpsbinary[ul].lpb=NULL;
            }
        }

        LocalFree((HLOCAL)lpsbinary);
        lpsbinary = NULL;
    }
    if (lpWabContainer) {
        lpWabContainer->lpVtbl->Release(lpWabContainer);
        lpWabContainer = NULL;
    }
    return(S_OK);
}


/******************************************************************************
 *  FUNCTION NAME:GetAdrLine
 *
 *  PURPOSE:    To get an address line and description of the address in a buffer
 *              from NetScape address book.
 *
 *  PARAMETERS: szCurPointer = pointer to the buffer containing the entire
 *                addresses.
 *              szBuffer = pointer to the address line buffer
 *              szDesc = pointer to the description buffeer.
 *
 *  RETURNS:    BOOL
 ******************************************************************************/
BOOL GetAdrLine(LPTSTR *szCurPointer, LPTSTR *szBuffer, LPTSTR *szDesc)
{
    static TCHAR szAdrStart[] = "<DT>";
    static TCHAR szAdrEnd[] = "</A>";
    static TCHAR szDescStart[] = "<DD>";
    static TCHAR szDistListEnd[] = "</H3>";
    LPTSTR  temp = NULL;
    BOOL flag = TRUE;

    ULONG ulSize = 0;
    LPTSTR szS = NULL, szE = NULL, szD = NULL, szDE = NULL ,szH = NULL;

    szS = strstr(*szCurPointer, szAdrStart);
    szE = strstr(*szCurPointer, szAdrEnd);
    szH = strstr(*szCurPointer, szDistListEnd);


    if (szS) {
        szS += lstrlen(szAdrStart);
    } else {
        return(FALSE);
    }

    if (szE != NULL) {
        if (szH != NULL  && szE <szH) {
            ulSize = (ULONG) (szE - szS + 1);
            flag = TRUE;
        } else {
            if (szH != NULL) {
                ulSize = (ULONG) (szH - szS + 1);
                flag = FALSE;
            } else {
                ulSize = (ULONG) (szE - szS + 1);
                flag = TRUE;
            }
        }
    } else {
        if (szH != NULL) {
            ulSize = (ULONG) (szH - szS + 1);
            flag = FALSE;
        }
    }

    if (ulSize) {
        *szBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulSize + 1));
        if (! *szBuffer) {
            lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MEMORY));
            MessageBox(NULL,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE),MB_OK);
            return(FALSE);
        }

        lstrcpyn(*szBuffer, szS,ulSize);
    }

    szD = strstr(*szCurPointer, szDescStart);

    // check if DT flag comes before DD. that means DD is not for this address

    temp = strstr((szS + 4), "<DT>");
    if ((temp != NULL && temp < szD) || (szD == NULL)) {
        *szDesc = NULL;
        if (flag) {
            *szCurPointer = szE + lstrlen(szAdrEnd);
        } else {
            *szCurPointer = szH + lstrlen(szDistListEnd);
        }
        return(TRUE);
    }
    temp = NULL;

    // Description will be uptil next \r\n

    if (szD) {
        szD += lstrlen(szDescStart);
        szDE = strstr(szD, LoadStringToGlobalBuffer(IDS_EOL));

        if (szDE) {
            szDE -= 1;
        }

        ulSize = (ULONG) (szDE - szD + 1);
    }

    if (ulSize) {
        *szDesc = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulSize+1));
        if (! *szDesc) {
            lstrcpy(szGlobalTempAlloc,LoadStringToGlobalBuffer(IDS_MEMORY));
            MessageBox(NULL,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE),MB_OK);
            return(FALSE);
        }

        lstrcpyn(*szDesc, szD, ulSize);
        *szCurPointer = szDE + 2;
    } else {
        *szDesc = NULL;
        *szCurPointer  = szDE + 2;
    }

    return(TRUE);
}

/******************************************************************************
 *  FUNCTION NAME:ProcessLn
 *
 *  PURPOSE:    Process an address line and fill the NSADRBOOK structure.
 *
 *  PARAMETERS: szL = pointer to the address line buffer
 *              szDesc = pointer to the description buffer
 *              nsAdrBook = pointer to the NSADRBOOK structure.
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT ProcessLn(LPTSTR *szL, LPTSTR *szDesc, NSADRBOOK *nsAdrBook, LPTSTR *szBuffer)
{
    LPTSTR szPrmStart = NULL, szPrmEnd = NULL;
    TCHAR cMailto[MAX_STRING_SIZE];
    TCHAR cAliasId[MAX_STRING_SIZE];
    TCHAR cNickname[MAX_STRING_SIZE];
    BOOL flag = FALSE;              //To check for distribution list
    LPNSDISTLIST present=NULL, previous=NULL;
    TCHAR *tmpStr = NULL;
    ULONG ulSize = 0;
    LPTSTR szDistStart = NULL, szDistEnd = NULL, szDistBuffer = NULL, szName = NULL;

    LPTSTR temp = NULL;
    BOOL NoNickName = FALSE;
    HRESULT hResult = S_OK;

    lstrcpy(cMailto, LoadStringToGlobalBuffer(IDS_MAILTO));
    lstrcpy(cAliasId, LoadStringToGlobalBuffer(IDS_ALIAS_ID));
    lstrcpy(cNickname, LoadStringToGlobalBuffer(IDS_NICKNAME));

    memset(nsAdrBook,0, sizeof(NSADRBOOK));
    nsAdrBook->DistList = TRUE;
    /* Get Mailto entry */
    szPrmStart = strstr(*szL, cMailto);
    if (! szPrmStart) {
        flag = TRUE;
        nsAdrBook->DistList = TRUE;
        szName = strchr(*szL,'>');
        goto AliasID;
    }

    nsAdrBook->DistList = FALSE;
    szPrmStart += lstrlen(cMailto);

    // search for quotes

    szPrmEnd = szPrmStart;
    if (! szPrmEnd) {
        goto AliasID;
    }

    while (*szPrmEnd != 34) {
        szPrmEnd = szPrmEnd + 1;  // What if there is no end quote

        if (szPrmEnd > (*szL + lstrlen(*szL))) {
            goto Down;
        }
    }
    ulSize = (ULONG) (szPrmEnd - szPrmStart);
    if (ulSize) {
        nsAdrBook->Address = (TCHAR *)LocalAlloc(LMEM_FIXED, (ulSize + 1));
        if (!nsAdrBook->Address) {
            return(hrMemory);
        }
        lstrcpyn(nsAdrBook->Address, szPrmStart, ulSize+1);
    }

    *szL = szPrmEnd + 1;

    /* Get the AliasID */
    if (szPrmEnd) {
        szName = strchr(szPrmEnd, '>');
    }
AliasID:
    szPrmStart = strstr(*szL, cAliasId);
    if (!szPrmStart) {
        nsAdrBook->Sbinary=FALSE;
        goto Nickname;
    }
    nsAdrBook->Sbinary=TRUE;
    szPrmStart += lstrlen(cAliasId);
    szPrmEnd = szPrmStart;


    while (*szPrmEnd != 34) {
        szPrmEnd++;

        if (szPrmEnd > (*szL + strlen(*szL))) {
            goto Down;
        }
    }
    ulSize = (ULONG) (szPrmEnd - szPrmStart + 1);
    tmpStr = (TCHAR *)LocalAlloc(LMEM_FIXED,ulSize);
    if (!tmpStr) {
        return(hrMemory);
    }
    lstrcpyn(tmpStr, szPrmStart, ulSize);

    nsAdrBook->AliasID = atoi(tmpStr);
    if (tmpStr) {
        LocalFree((HLOCAL)tmpStr);
    }

    *szL = szPrmEnd + 1;


Nickname:
    szPrmStart = strstr(*szL, cNickname);
    if (!szPrmStart) {
        NoNickName = TRUE;
        goto Entry;
    }
    if (szName && szName < szPrmStart) {
        NoNickName = TRUE;
        goto Entry;
    }
    szPrmStart += lstrlen(cNickname);
    szPrmStart += 1;
    szPrmEnd = szPrmStart;
    while (*szPrmEnd != 34) {
        szPrmEnd++;
        if (szPrmEnd > (*szL + strlen(*szL))) {
            goto Down;
        }
    }
    ulSize = (ULONG) (szPrmEnd - szPrmStart);
    if (0 == ulSize) {
        NoNickName = TRUE;
    } else {
        NoNickName = FALSE;
        nsAdrBook->NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, (ulSize + 1));
        if (!nsAdrBook->NickName) {
            return(hrMemory);
        }
        lstrcpyn(nsAdrBook->NickName, szPrmStart, ulSize + 1);
    }

    *szL = szPrmEnd +1;

Entry:
    szPrmStart = szName;
    if (szPrmStart) {
        szPrmStart++;
        ulSize = (ULONG) ((*szL + lstrlen(*szL)) - szPrmStart);
        if (ulSize) {
            nsAdrBook->Entry = (TCHAR *)LocalAlloc(LMEM_FIXED, (ulSize + 1));
            if (!nsAdrBook->Entry) {
                return(hrMemory);
            }
            lstrcpyn(nsAdrBook->Entry, szPrmStart, ulSize + 1);

            /** Bug - dont make the nickname the same as the entry
            if(NoNickName)
            {
                nsAdrBook->NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, (ulSize + 1));
                if(!nsAdrBook->NickName)
                {
                     return(hrMemory);
                }
                lstrcpy(nsAdrBook->NickName, nsAdrBook->Entry);
            }
            NoNickName = FALSE;
            **/
        }
        if (/*NoNickName && */!nsAdrBook->Entry && nsAdrBook->Address) {
            ulSize = lstrlen(nsAdrBook->Address) + 1;
            nsAdrBook->Entry = (TCHAR *)LocalAlloc(LMEM_FIXED,ulSize);
            if (!nsAdrBook->Entry) {
                return(hrMemory);
            }
            lstrcpy(nsAdrBook->Entry, nsAdrBook->Address);
        }
    }

    if (*szDesc) {
        ulSize = lstrlen(*szDesc) + 1;
        nsAdrBook->Description = (TCHAR *)LocalAlloc(LMEM_FIXED, ulSize);
        if (! nsAdrBook->Description) {
            return(hrMemory);
        }
        lstrcpyn(nsAdrBook->Description, *szDesc,ulSize);
    } else {
        nsAdrBook->Description = NULL;
    }

    if (flag == TRUE) {
        ulSize = 0;
        szDistStart = GetAdrStart(*szBuffer);
        szDistEnd = GetDLNext(*szBuffer);

        if (szDistEnd - szDistStart) {
            ulSize = (ULONG) (szDistEnd-szDistStart);
        }
        if (ulSize) {
            szDistBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulSize + 1));
            if (!szDistBuffer) {
                return(hrMemory);
            }
            lstrcpyn(szDistBuffer, szDistStart, ulSize + 1);
            *szBuffer=szDistEnd;
        } else {
            return(S_OK);
        }
        szPrmStart=szDistBuffer;

        if ((temp = strstr(szPrmStart, LoadStringToGlobalBuffer(IDS_ALIASOF))) == NULL) {
            if (szDistBuffer) {
                LocalFree((HLOCAL)szDistBuffer);
            }
            return(S_OK);
        }

        while ((szPrmEnd=strstr(szPrmStart, LoadStringToGlobalBuffer(IDS_ALIASOF)))!=NULL) {

            present = (LPNSDISTLIST)LocalAlloc(LMEM_FIXED,sizeof(NSDISTLIST));
            if (! present) {
                if (szDistBuffer) {
                    LocalFree((HLOCAL)szDistBuffer);
                }
                return(hrMemory);
            }
            szPrmEnd += strlen(LoadStringToGlobalBuffer(IDS_ALIASOF));
            szPrmStart = strchr(szPrmEnd,'"');

            ulSize = (ULONG) (szPrmStart - szPrmEnd + 1);
            tmpStr = (TCHAR *)LocalAlloc(LMEM_FIXED,ulSize);
            if (! tmpStr) {
                return(hrMemory);
            }
            lstrcpyn(tmpStr, szPrmEnd, ulSize);

            present->AliasID = atoi(tmpStr);
            if (tmpStr) {
                LocalFree((HLOCAL)tmpStr);
            }

            if (previous != NULL) {
                previous->lpDist = present;
            } else {
                nsAdrBook->lpDist = present;
            }
            previous=present;

        }
        present->lpDist=NULL;

        if (szDistBuffer) {
            LocalFree((HLOCAL)szDistBuffer);
        }

    } else {
        nsAdrBook->lpDist=NULL;
    }

Down:
    return(S_OK);
}


/******************************************************************************
 *  FUNCTION NAME:GetAddressCount
 *
 *  PURPOSE:    To get the count of number of <DT> in the buffer containing the
 *              addresses.
 *
 *  PARAMETERS: AdrBuffer = Buffer containing the addresses.
 *
 *  RETURNS:ULONG , count of <DT>
 ******************************************************************************/
ULONG GetAddressCount(LPTSTR AdrBuffer)
{
    TCHAR szToken[] = "<DT>";
    LPTSTR szTemp = AdrBuffer;
    LPTSTR szP = NULL;
    ULONG ulCount = 0;

    while ((szP = strstr(szTemp, szToken)) != NULL) {
        ulCount++;
        szTemp = szP + lstrlen(szToken);
    }

    return(ulCount);
}


/******************************************************************************
 *  FUNCTION NAME:GetAdrStart
 *
 *  PURPOSE:    To get a pointer to the starting of addresses in the NetScape
 *              address book.
 *
 *  PARAMETERS: szBuffer = pointer to the buffer containing the address book.
 *
 *  RETURNS:    LPTSTR, pointer to the starting of addresses (<DL><p>).
 ******************************************************************************/
LPTSTR  GetAdrStart(LPTSTR szBuffer)
{
    TCHAR szAdrStart[] = "<DL><p>";
    LPTSTR szS=NULL;

    szS = strstr(szBuffer, szAdrStart);
    if (szS) {
        szS += lstrlen(szAdrStart);
    }

    return(szS);
}


/******************************************************************************
 *  FUNCTION NAME:GetDLNext
 *
 *  PURPOSE:    To get a pointer to the </DL><p> in the address buffer.
 *
 *  PARAMETERS: szBuffer = address buffer
 *
 *  RETURNS:    LPTSTR, pointer to the </DL><p>
 ******************************************************************************/
LPTSTR GetDLNext(LPTSTR szBuffer)
{
    TCHAR szAdrStart[] = "</DL><p>";
    LPTSTR szS = NULL;

    szS = strstr(szBuffer, szAdrStart);
    if (szS) {
        szS += lstrlen(szAdrStart) + 1;
    }
    return(szS);
}


/******************************************************************************
 *  FUNCTION NAME:GetAdrEnd
 *
 *  PURPOSE:    To get a pointer to the last occurance of </DL><p> in the address
 *              buffer.
 *
 *  PARAMETERS: szBuffer = address buffer
 *
 *  RETURNS:    LPTSTR, pointer to the last </DL><p>
 ******************************************************************************/
LPTSTR  GetAdrEnd(LPTSTR szBuffer)
{
    TCHAR szAdrEnd[] = "</DL><p>";
    LPTSTR szE = NULL, szT = NULL;
    LPTSTR szTemp = szBuffer;

    while ((szE = strstr(szTemp, szAdrEnd)) != NULL) {
        szT=szE;
        szTemp = szE + lstrlen(szAdrEnd);
    }

    szE = szT;

    if (szE) {
        szE += lstrlen(szAdrEnd);
    }

    return(szE);
}


/******************************************************************************
 *  FUNCTION NAME:GetAddrCount
 *
 *  PURPOSE:    To get a count of number of ALIASID in the address buffer.
 *
 *  PARAMETERS: AdrBuffer = address buffer
 *
 *  RETURNS:    ULONG, count of total ALIASID in the address buffer
 ******************************************************************************/
ULONG GetAddrCount(LPTSTR AdrBuffer)
{
    TCHAR szToken[MAX_STRING_SIZE];
    LPTSTR szTemp=AdrBuffer;
    LPTSTR szP=NULL;
    ULONG ulCount=0;

    lstrcpy(szToken, LoadStringToGlobalBuffer(IDS_ALIAS_ID));

    while ((szP=strstr(szTemp,szToken))!=NULL) {
        ulCount++;
        szTemp =szP+lstrlen(szToken);
    }

    return(ulCount);
}


/******************************************************************************
 *  FUNCTION NAME:FillDistList
 *
 *  PURPOSE:    To create a Distribution list in the WAB.
 *
 *  PARAMETERS: hwnd - hwnd of parent
 *              lpWabContainer = pointer to the IABCONT interface
 *              sProp = pointer to SPropValue
 *              lpAdrBook = pointer to the IADRBOOK interface
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *              lpsbinary = pointer to the SBinary array.
 *              lpnAdrBook = pointer to the NSADRBOOK structure
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT FillDistList(HWND hwnd, LPABCONT lpWabContainer, LPSPropValue sProp,
  LPWAB_IMPORT_OPTIONS lpOptions, LPNSADRBOOK lpnAdrBook,
  LPSBinary lpsbinary, LPADRBOOK lpAdrBook)
{

    LPNSDISTLIST lptemp=lpnAdrBook->lpDist;
    LPSPropValue lpNewDLProps = NULL;
    LPDISTLIST lpDistList = NULL;
    ULONG cProps;
    ULONG  ulObjType;
    int i;
    HRESULT hResult;
    static LPMAPIPROP lpMailUserWAB =NULL;
    SPropValue rgProps[4];
    LPMAPIPROP lpDlWAB = NULL;
    ULONG iCreateTemplatedl = iconPR_DEF_CREATE_DL;

    BOOL flag = FALSE;
    REPLACE_INFO RI = {0};
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;

retry:

    if (lpnAdrBook->Sbinary == FALSE) {
        if (0 != (hResult=CreateDistEntry(lpWabContainer,sProp,ulCreateFlags,
          &lpMailUserWAB))) {
            goto error1;
        }
    } else {
        if (lpsbinary[lpnAdrBook->AliasID].lpb == NULL) {
            if (0 != (hResult=CreateDistEntry(lpWabContainer,sProp,ulCreateFlags,
              &lpMailUserWAB))) {
                goto error1;
            }
        } else {
            if (0 != (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
              lpsbinary[lpnAdrBook->AliasID].cb,
              (LPENTRYID)lpsbinary[lpnAdrBook->AliasID].lpb,
              (LPIID)&IID_IMAPIProp,
              MAPI_DEFERRED_ERRORS|MAPI_MODIFY,
              &ulObjType,
              (LPUNKNOWN *)&lpMailUserWAB))) {
                goto error1;
            }
            flag = TRUE;
        }
    }


    if (lpnAdrBook->Entry) {
        rgProps[0].Value.lpszA = lpnAdrBook->Entry;
        rgProps[0].ulPropTag = PR_DISPLAY_NAME;
    } else if (lpnAdrBook->NickName) {
        rgProps[0].Value.lpszA = lpnAdrBook->NickName;
        rgProps[0].ulPropTag = PR_DISPLAY_NAME;
    } else {
        rgProps[0].Value.lpszA = NULL;
        rgProps[0].ulPropTag = PR_NULL;
    }

    rgProps[1].Value.lpszA = lpnAdrBook->Description;
    if (lpnAdrBook->Description) {
        rgProps[1].ulPropTag = PR_COMMENT;
    } else {
        rgProps[1].ulPropTag = PR_NULL;
    }



    if (0 != (hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
      2, rgProps, NULL))) {
        goto error1;
    }

    if (0 != (hResult=lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
      FORCE_SAVE|KEEP_OPEN_READWRITE))) {
        if (GetScode(hResult) == MAPI_E_COLLISION) {
            if (lpOptions->ReplaceOption == WAB_REPLACE_ALWAYS) {
                if (lpMailUserWAB) {
                    lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                }
                lpMailUserWAB = NULL;
                ulCreateFlags |= CREATE_REPLACE;
                goto retry;
            }

            if (lpOptions->ReplaceOption == WAB_REPLACE_NEVER) {
                hResult = S_OK;
                goto error1;
            }

            if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
                if (lpnAdrBook->Entry) {
                    RI.lpszDisplayName = lpnAdrBook->Entry;
                    RI.lpszEmailAddress = lpnAdrBook->Address;
                } else if (lpnAdrBook->NickName) {
                    RI.lpszDisplayName = lpnAdrBook->NickName;
                    RI.lpszEmailAddress = lpnAdrBook->Address;
                } else if (lpnAdrBook->Address) {
                    RI.lpszDisplayName = lpnAdrBook->Address;
                    RI.lpszEmailAddress = NULL;
                } else if (lpnAdrBook->Description) {
                    RI.lpszDisplayName = lpnAdrBook->Description;
                    RI.lpszEmailAddress = NULL;
                } else {
                    RI.lpszDisplayName = "";
                    RI.lpszEmailAddress = NULL;
                }
                RI.ConfirmResult = CONFIRM_ERROR;
                RI.fExport = FALSE;
                RI.lpImportOptions = lpOptions;

                DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_ImportReplace), hwnd,
                  ReplaceDialogProc, (LPARAM)&RI);

                switch (RI.ConfirmResult) {
                    case CONFIRM_YES:
                    case CONFIRM_YES_TO_ALL:
                        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                        lpMailUserWAB = NULL;
                        ulCreateFlags |= CREATE_REPLACE;
                        goto retry;
                        break;

                    case CONFIRM_NO:
                        if (lpnAdrBook->Sbinary == TRUE) {
                            hResult = GetExistEntry(lpWabContainer,lpsbinary,
                                                    lpnAdrBook->AliasID,
                                                    lpnAdrBook->Entry,
                                                    lpnAdrBook->NickName);
                        }
                        goto error1;

                    case CONFIRM_ABORT:
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                        goto error1;

                    default:

                        break;
                }
            }
        }
    }

    if (0 != (hResult = lpMailUserWAB->lpVtbl->GetProps(lpMailUserWAB,
      (LPSPropTagArray)&ptaEid, 0, &cProps, (LPSPropValue *)&lpNewDLProps))) {
        if (hResult == MAPI_W_ERRORS_RETURNED) {
            WABFreeBuffer(lpNewDLProps);
            lpNewDLProps = NULL;
        }
        goto error1;
    }

    if (lpnAdrBook->Sbinary == TRUE) {
        if (flag == FALSE) {
            lpsbinary[lpnAdrBook->AliasID].lpb=(LPBYTE)LocalAlloc(LMEM_FIXED,
              lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
            if (! lpsbinary[lpnAdrBook->AliasID].lpb) {
                hResult = hrMemory;
                goto error1;
            }
            CopyMemory(lpsbinary[lpnAdrBook->AliasID].lpb,
              (LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,
              lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
            lpsbinary[lpnAdrBook->AliasID].cb=lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb;
        }
    }


    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
        lpMailUserWAB = NULL;
    }


    if (0 != (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
      lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb,
      (LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,
      (LPIID)&IID_IDistList,
      MAPI_DEFERRED_ERRORS|MAPI_MODIFY,
      &ulObjType,
      (LPUNKNOWN *)&lpDistList))) {
        goto error1;
    }

    if (lpNewDLProps) {
        WABFreeBuffer(lpNewDLProps);
        lpNewDLProps = NULL;
    }
    if (NULL == lpnAdrBook->lpDist) {
        goto error1;
    }
    do {
        i = lpnAdrBook->lpDist->AliasID;

        if ((LPENTRYID)lpsbinary[i].lpb == NULL) {
            if (0 != (hResult=CreateDistEntry(lpWabContainer,sProp,ulCreateFlags,
              &lpMailUserWAB))) {
                goto error2;
            }

            rgProps[0].ulPropTag = PR_DISPLAY_NAME;
            rgProps[0].Value.lpszA = LoadStringToGlobalBuffer(IDS_DUMMY);

            if (0 != (hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
              1, rgProps, NULL))) {
                goto error2;
            }
            if (0 != (hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
              FORCE_SAVE|KEEP_OPEN_READONLY))) {
                goto error2;
            }

            if (0 != (hResult = lpMailUserWAB->lpVtbl->GetProps(lpMailUserWAB,
              (LPSPropTagArray)&ptaEid, 0, &cProps, (LPSPropValue *)&lpNewDLProps))) {
                if (hResult == MAPI_W_ERRORS_RETURNED) {
                    WABFreeBuffer(lpNewDLProps);
                    lpNewDLProps = NULL;
                }
                goto error2;
            }

            lpsbinary[i].lpb=(LPBYTE)LocalAlloc(LMEM_FIXED,lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
            if (!lpsbinary[i].lpb) {
                hResult = hrMemory;
                goto error1;
            }
            CopyMemory(lpsbinary[i].lpb,
              (LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
            lpsbinary[i].cb=lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb;

            if (lpNewDLProps) {
                WABFreeBuffer(lpNewDLProps);
                lpNewDLProps = NULL;
            }
error2:

            if (lpMailUserWAB) {
                lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                lpMailUserWAB = NULL;
            }
        }

        if (0 != (hResult = lpDistList->lpVtbl->CreateEntry(lpDistList,
          lpsbinary[i].cb,
          (LPENTRYID)lpsbinary[i].lpb,
          CREATE_CHECK_DUP_STRICT|CREATE_REPLACE,
          &lpDlWAB))) {
            goto error3;
        }

        if (0 != (hResult = lpDlWAB->lpVtbl->SaveChanges(lpDlWAB, FORCE_SAVE))) {
            if (MAPI_E_FOLDER_CYCLE ==hResult) {
                lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_LOOPING));
                MessageBox(NULL,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ENTRY_NOIMPORT),MB_OK);
            }
            hResult = S_OK;
            goto error3;
        }
error3:
        if (lpDlWAB) {
            lpDlWAB->lpVtbl->Release(lpDlWAB);
            lpDlWAB = NULL;
        }

        lpnAdrBook->lpDist = FreeNSdistlist(lpnAdrBook->lpDist);
    } while (lpnAdrBook->lpDist!=NULL);

error1:

    if (lpDistList) {
        lpDistList->lpVtbl->Release(lpDistList);
        lpDistList = NULL;
    }

    if (lpDlWAB) {
        lpDlWAB->lpVtbl->Release(lpDlWAB);
        lpDlWAB = NULL;
    }

    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
        lpMailUserWAB = NULL;
    }
    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:  FillWABStruct
 *
 *  PURPOSE:    To fill the SpropValue array.
 *
 *  PARAMETERS: nsAdrBook = pointer to the NSADRBOOK structure.
 *              rgProps = pointer to the SpropValue array.
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT FillWABStruct(LPSPropValue rgProps, NSADRBOOK *nsAdrBook)
{
    HRESULT hr = S_OK;

    rgProps[1].ulPropTag = PR_DISPLAY_NAME;
    if (nsAdrBook->Entry) {
        rgProps[1].Value.lpszA = nsAdrBook->Entry;
    } else if (nsAdrBook->NickName) {
        rgProps[1].Value.lpszA = nsAdrBook->NickName;
    } else {
        lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_NONAME));
        rgProps[1].Value.lpszA  = szGlobalTempAlloc;
    }

    rgProps[0].Value.lpszA = nsAdrBook->Address;
    if (nsAdrBook->Address) {
        rgProps[0].ulPropTag = PR_EMAIL_ADDRESS;
        rgProps[2].ulPropTag = PR_ADDRTYPE;
        rgProps[2].Value.lpszA = LoadStringToGlobalBuffer(IDS_SMTP);
    } else {
        rgProps[0].ulPropTag = PR_NULL;
        rgProps[2].ulPropTag = PR_NULL;
        rgProps[2].Value.lpszA = NULL;
    }

    rgProps[3].Value.lpszA = nsAdrBook->Description;
    if (nsAdrBook->Description) {
        rgProps[3].ulPropTag = PR_COMMENT;
    } else {
        rgProps[3].ulPropTag = PR_NULL;
    }

    rgProps[4].Value.lpszA = nsAdrBook->NickName;
    if (nsAdrBook->NickName) {
        rgProps[4].ulPropTag = PR_NICKNAME;
    } else {
        rgProps[4].ulPropTag = PR_NULL;
    }

    return(hr);
}


/******************************************************************************
 *  FUNCTION NAME:CreateDistEntry
 *
 *  PURPOSE:    To create an entry in the WAB for a Distribution List
 *
 *  PARAMETERS: lpWabContainer = pointer to the WAB container.
 *              sProp = pointer to SPropValue
 *              ulCreateFlags = Flags
 *              lppMailUserWab = pointer to the IMAPIPROP interface
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT CreateDistEntry(LPABCONT lpWabContainer,LPSPropValue sProp,
  ULONG ulCreateFlags,LPMAPIPROP *lppMailUserWab)
{
    HRESULT hResult;
    ULONG iCreateTemplatedl = iconPR_DEF_CREATE_DL;


    hResult = lpWabContainer->lpVtbl->CreateEntry(lpWabContainer,
      sProp[iCreateTemplatedl].Value.bin.cb,
      (LPENTRYID)sProp[iCreateTemplatedl].Value.bin.lpb,
      ulCreateFlags,
      lppMailUserWab);
    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:FreeNSdistlist
 *
 *  PURPOSE:    To free one node from NSDISTLIST(linked list)
 *
 *  PARAMETERS: lpDist = pointer to the NSDISTLIST structure.
 *
 *  RETURNS:    LPNSDISTLIST , pointer to the next link.
 ******************************************************************************/
LPNSDISTLIST FreeNSdistlist(LPNSDISTLIST lpDist)
{
    LPNSDISTLIST lpTemp = NULL;

    if (lpDist==NULL) {
        return(NULL);
    }

    lpTemp = lpDist->lpDist;
    LocalFree((HLOCAL)lpDist);
    lpDist = NULL;
    return(lpTemp);
}


/******************************************************************************
  *********************Eudora Functions*****************************************/


HRESULT ImportEudoraAddressBookFile(HWND hwnd, LPTSTR szFileName, LPABCONT lpWabContainer,
  LPWAB_IMPORT_OPTIONS lpOptions, LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook)
{
    HRESULT hResult = E_FAIL;
    ULONG cProps;
    LPEUDADRBOOK lpeudAdrBook = NULL;
    ULONG ulCount = 0, uCounter = 0;
    LPSPropValue sProp = NULL;

    if (! (ulCount = ParseEudAddress(szFileName,&lpeudAdrBook))) {
        goto Error;
    }

    if (0 != (hResult = lpWabContainer->lpVtbl->GetProps(lpWabContainer,
      (LPSPropTagArray)&ptaCon, 0, &cProps, (LPSPropValue *)&sProp))) {
        if (hResult == MAPI_W_ERRORS_RETURNED) {
            WABFreeBuffer(sProp);
            sProp = NULL;
        }
        goto Error;
    }

    hResult = ImportEudUsers(hwnd, szFileName, lpWabContainer, sProp, lpeudAdrBook,ulCount,
      lpOptions,lpProgressCB,lpAdrBook);
    if (sProp) {
        WABFreeBuffer(sProp);
    }
Error:
    if (lpeudAdrBook) {

        for (; uCounter < ulCount ; uCounter++) {
            if (lpeudAdrBook[uCounter].Description) {
                LocalFree((HLOCAL)lpeudAdrBook[uCounter].Description);
            }
            lpeudAdrBook[uCounter].Description = NULL;
            if (lpeudAdrBook[uCounter].NickName) {
                LocalFree((HLOCAL)lpeudAdrBook[uCounter].NickName);
            }
            lpeudAdrBook[uCounter].NickName = NULL;
            if (lpeudAdrBook[uCounter].Address) {
                LocalFree((HLOCAL)lpeudAdrBook[uCounter].Address);
            }
            lpeudAdrBook[uCounter].Address = NULL;
        }
        LocalFree((HLOCAL)lpeudAdrBook);
        lpeudAdrBook=NULL;
    }

    return(hResult);
}


/******************************************************************************
*  FUNCTION NAME:MigrateEudoraUser
*
*  PURPOSE:     Get the installation path of the address book and starts processing
*               the Eudora address book
*
*  PARAMETERS:  hwnd = Handle to the parent Window
*               lpAdrBook = pointer to the IADRBOOK interface
*               lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
*               lpOptions = pointer to WAB_IMPORT_OPTIONS structure
*               lpWabContainer = pointer to the IABCONT interface
*
*  RETURNS:     HRESULT
******************************************************************************/
HRESULT MigrateEudoraUser(HWND hwnd,  LPABCONT lpWabContainer,
  LPWAB_IMPORT_OPTIONS lpOptions, LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPADRBOOK lpAdrBook)
{

    TCHAR szFileName[MAX_FILE_NAME];
    TCHAR szFilePath[MAX_FILE_NAME];
    TCHAR szFileSubPath[MAX_FILE_NAME];
    HRESULT hResult = S_OK;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = NULL;


    szFilePath[0] = szFileName[0] = '\0';

    hResult= GetRegistryPath(szFileName,EUDORA);
    if (hResult == hrMemory) {
        return(hrMemory);
    }

    if (0 != hResult) {
        // Didnt find the registry setting .. look for "c:\eudora"
        lstrcpy(szFileName, LoadStringToGlobalBuffer(IDS_EUDORA_DEFAULT_INSTALL));

        if (0xFFFFFFFF != GetFileAttributes(szFileName)) {
            // This directory exists .. reset the error value
            hResult = S_OK;
        }
    }

    if (0 != hResult) {
        lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_STRING_SELECTPATH));
        if (IDNO ==MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE),
          MB_YESNO)) {
            return(ResultFromScode(MAPI_E_USER_CANCEL));
        }
        if (!GetFileToImport(hwnd, szFileName,EUDORA)) {
            return(ResultFromScode(MAPI_E_USER_CANCEL));
        }
    } else {
        lstrcat(szFileName, LoadStringToGlobalBuffer(IDS_EUDORA_ADDRESS));
        hFile = FindFirstFile(szFileName,&FindFileData);
        if (INVALID_HANDLE_VALUE == hFile) {
            lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ADDRESS_HTM));
            if (IDNO == MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ERROR),MB_YESNO)) {
                return(ResultFromScode(MAPI_E_USER_CANCEL));
            }
            if (FALSE ==GetFileToImport(hwnd, szFileName,EUDORA)) {
                return(ResultFromScode(MAPI_E_USER_CANCEL));
            }

        } else {
            FindClose(hFile);
        }
    }

    // Extract the file directory from the file name
    if (lstrlen(szFileName) && !lstrlen(szFilePath)) {
        LPTSTR lp1 = NULL, lp2 = NULL;
        lstrcpy(szFilePath,szFileName);
        lp1 = szFilePath;
        // Find the last '\' and terminate the path at that char
        while (lp1 && *lp1) {
            if (*lp1 == '\\') {
                lp2 = lp1;
            }
            lp1 = CharNext(lp1);
        }
        if (lp2 && (*lp2 == '\\')) {
            *lp2 = '\0';
        }
    }

    /*** Bug - no need to restrict file name to a particular name
    /***
    if(NULL == Getstr(szFileName, LoadStringToGlobalBuffer(IDS_EUDORA_NAME)))
    {
        lstrcpy(szGlobalTempAlloc,LoadStringToGlobalBuffer(IDS_INVALID_FILE));
        MessageBox(hwnd,szGlobalTempAlloc,LoadStringToGlobalBuffer(IDS_ERROR),MB_OK);
        return(ResultFromScode(MAPI_E_CALL_FAILED));
    }
    ***/

    // import the basic file ...
    //
    hResult = ImportEudoraAddressBookFile(hwnd,
      szFileName, lpWabContainer, lpOptions, lpProgressCB, lpAdrBook);

    szFileName[0]='\0';

    // Now look for files in the nicknames subdirectory
    //
    lstrcat(szFilePath, LoadStringToGlobalBuffer(IDS_EUDORA_SUBDIR_NAME));

    if (0xFFFFFFFF != GetFileAttributes(szFilePath)) {
        BOOL bRet = TRUE;

        // Yes this directory exists ...
        // Now scan all the *.txt files in this subdir and try to import them
        lstrcpy(szFileSubPath, szFilePath);
        lstrcat(szFileSubPath, LoadStringToGlobalBuffer(IDS_EUDORA_GENERIC_SUFFIX));

        hFile = FindFirstFile(szFileSubPath, &FindFileData);

        while (bRet && hFile != INVALID_HANDLE_VALUE) {
            lstrcpy(szFileName, szFilePath);
            lstrcat(szFileName, TEXT("\\"));
            lstrcat(szFileName, FindFileData.cFileName);
            hResult = ImportEudoraAddressBookFile(hwnd,
              szFileName, lpWabContainer, lpOptions, lpProgressCB, lpAdrBook);
            hResult = S_OK;

            // Dont report errors .. just continue ...
            bRet = FindNextFile(hFile, &FindFileData);
        }

        if (hFile) {
            FindClose(hFile);
        }
    }

    return(hResult);
}

/******************************************************************************
*  FUNCTION NAME:ParseEudAddress
*
*  PURPOSE:     To open the nndbase.txt and toc files and starts processing the
*               address book.
*
*  PARAMETERS:  szFileName = contains the path of the address book.
*               lppeudAdrBook = pointer to the EUDADRBOOK structure.
*
*  RETURNS:     ULONG, number of addresses in the address book.
******************************************************************************/
ULONG ParseEudAddress(LPTSTR szFileName, LPEUDADRBOOK *lppeudAdrBook)
{
    HANDLE htoc,htxt;
    TCHAR cNndbasetoc[_MAX_PATH];
    ULONG ucount=0;
    ULONG ulAdrcount=0;
    UINT i,j;
    LPTSTR szBuffer=NULL;
    LPTSTR szAdrBuffer=NULL;
    LPTSTR *szAliaspt=NULL;
    ULONG ulRead=0;
    ULONG ulFileSize,ulTxtSize;
    LPEUDADRBOOK lpeudAdrBook;


    lstrcpy(cNndbasetoc,szFileName);
    cNndbasetoc[strlen(cNndbasetoc)-3] = '\0';
    strcat(cNndbasetoc, LoadStringToGlobalBuffer(IDS_EUDORA_TOC));

    /* Eudora address book has two files,nndbase.txt and nndbase.toc.
    nndbase.toc format:
    Nicknames start from byte 3. Every Nickname will be delimited by /r/n.
    After this there will 4 byte address offset,4 byte address size,
    4 byte description offset and 4 byte description size. The address offset
    and size constitute all the addresses in the NickName.(A NickName can
    be a distribution list or a single mail user */

    htoc = CreateFile(cNndbasetoc, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
      FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (INVALID_HANDLE_VALUE == htoc) {
        return(0);
    }

    htxt = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
      FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (INVALID_HANDLE_VALUE == htxt) {
        return(0);
    }

    //get toc file in a buffer
    ulFileSize = GetFileSize(htoc, NULL);
    szBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulFileSize+1));

    if (! szBuffer) {
        goto NoMemory;
    }
    if (! ReadFile(htoc, szBuffer, ulFileSize, &ulRead, NULL)) {
        goto Error;
    }

    szBuffer[ulFileSize] = '\0';

    //get address file in a buffer

    ulTxtSize = GetFileSize(htxt, NULL);

    szAdrBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulTxtSize+1));

    if (!szAdrBuffer) {
        goto NoMemory;
    }

    if (! ReadFile(htxt, szAdrBuffer, ulTxtSize, &ulRead, NULL)) {
        goto Error;
    }
    szAdrBuffer[ulTxtSize] = '\0';
            
    // BUG 2120: to deal with only LF's and not CR/LF's 
    for (i = 2; i < (UINT)ulFileSize; i++) {
        if (! (/*szBuffer[i] == '\r' && */szBuffer[i+1] == '\n') ) {
            continue;
        }
        ulAdrcount++ ; //to get count of number of address
    }

    if (ulAdrcount) {
        lpeudAdrBook = (LPEUDADRBOOK)LocalAlloc(LMEM_FIXED,
          ((ulAdrcount) * sizeof(EUDADRBOOK)));
        if (!lpeudAdrBook) {
            goto NoMemory;
        }

        memset(lpeudAdrBook,0,((ulAdrcount) * sizeof(EUDADRBOOK)));

        szAliaspt = (LPTSTR *)LocalAlloc(LMEM_FIXED,(sizeof(LPTSTR))*(ulAdrcount+1));
        if (! szAliaspt) {
            goto NoMemory;
        }

        for (i = 0; i < ulAdrcount; i++) {
            szAliaspt[i] = (LPTSTR)LocalAlloc(LMEM_FIXED,256);
            if (!szAliaspt[i]) {
                goto NoMemory;
            }
        }

        szAliaspt[i]=NULL; //to know it is the end.

        j=0;

        for (i = 2; i < (UINT)ulFileSize; i++) {
            // BUG 2120: to deal with only LF's and not CR/LF's 
            if ((/*szBuffer[i] == '\r' &&*/ szBuffer[i+1] == '\n')) {
                i += (EUDORA_STRUCT + 1);
                //16 bytes structure +1 for 10
                szAliaspt[ucount][j] = '\0';
                ucount++;
                j=0;
                continue;
            }
            szAliaspt[ucount][j++]=szBuffer[i];
        }

        if (hrMemory == ParseAddressTokens(szBuffer,szAdrBuffer,ulAdrcount,szAliaspt,lpeudAdrBook)) {
            goto NoMemory;
        }
        *lppeudAdrBook = lpeudAdrBook;
    }

Error:
    if (szBuffer) {
        LocalFree((HLOCAL)szBuffer);
    }
    if (szAdrBuffer) {
        LocalFree((HLOCAL)szAdrBuffer);
    }
    if (htxt) {
        CloseHandle(htxt);
    }
    if (htoc) {
        CloseHandle(htoc);
    }
    if (szAliaspt) {
        for (i = 0; i < ulAdrcount; i++) {
            if (szAliaspt[i]) {
                LocalFree((HLOCAL)szAliaspt[i]);
            }
            szAliaspt[i] = NULL;
        }
        LocalFree((HLOCAL)szAliaspt);
        szAliaspt = NULL;
    }

    return(ulAdrcount);

NoMemory:
    lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MEMORY));
    MessageBox(NULL,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE),MB_OK);
    if (szBuffer) {
        LocalFree((HLOCAL)szBuffer);
    }
    if (szAdrBuffer) {
        LocalFree((HLOCAL)szAdrBuffer);
    }
    if (htxt) {
        CloseHandle(htxt);
    }
    if (htoc) {
        CloseHandle(htoc);
    }
    if (szAliaspt) {
        for (i = 0; i < ulAdrcount; i++) {
            if (szAliaspt[i]) {
                LocalFree((HLOCAL)szAliaspt[i]);
            }
            szAliaspt[i] = NULL;
        }
        LocalFree((HLOCAL)szAliaspt);
        szAliaspt = NULL;
    }
    return(0);
}


/******************************************************************************
 *  FUNCTION NAME:ParseAddressTokens
 *
 *  PURPOSE:    To fill the EUDADRBOOK array structure after processing all the
 *              addresses from Eudora address book.
 *
 *  PARAMETERS: szBuffer = buffer containing the nndbase.toc file.
 *              szAdrBuffer = buffer containing the nndbase.txt file.
 *              ulCount = number of addresses in the eudora address book.
 *              szAliaspt = pointer to a two dimensional array containing
 *                all the nicknames.
 *              EudAdrBook = pointer to the EUDADRBOOK structure.
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT ParseAddressTokens(LPTSTR szBuffer,LPTSTR szAdrBuffer,UINT ulCount,
  LPTSTR *szAliaspt,EUDADRBOOK *EudAdrBook)
{

    ULONG ulAdrSize = 0, ulAdrOffset = 0, i = 0, uDescription = 0, uOffset = 0;
    int iCounter =0;
    LPTSTR szAdrLine = NULL, szAdrEnd = NULL, szAdrStart=NULL, szAdrCur=NULL;

    HRESULT hr = S_OK;

    szAdrStart=&szBuffer[2];

    do {
        if (szAliaspt[i] == NULL) {
            break;
        }
        szAdrCur = Getstr(szAdrStart, szAliaspt[i]);
        if (szAdrCur == NULL) {
            hr = hrMemory;
            goto Error;
        }
        szAdrCur+=strlen(szAliaspt[i])+2;
        ulAdrOffset = ShiftAdd(0,szAdrCur);
        ulAdrSize = ShiftAdd(4,szAdrCur);

        szAdrStart=szAdrCur+16;
        EudAdrBook[i].lpDist=NULL;
        if (hrMemory == (hr = CreateAdrLineBuffer(&szAdrLine,szAdrBuffer,ulAdrOffset,ulAdrSize))) {
            goto Error;
        }
        if (hrMemory == (hr = ParseAdrLineBuffer(szAdrLine,szAliaspt,i,EudAdrBook))) {
            goto Error;
        }
        ulAdrOffset = ShiftAdd(8,szAdrCur);
        ulAdrSize = ShiftAdd(12,szAdrCur);

        if (! (ulAdrSize == 0xFFFFFFFF && ulAdrOffset == 0xFFFFFFFF)) {
            EudAdrBook[i].Description = (TCHAR *)LocalAlloc(LMEM_FIXED, (ulAdrSize+1));
            if (! EudAdrBook[i].Description) {
                hr = hrMemory;
                goto Error;
            }
            for (uDescription = 0, uOffset = 0; uDescription < ulAdrSize; uDescription++,uOffset++) {
                if (szAdrBuffer[ulAdrOffset + uOffset] != 03) { //delimitor for next line in nndbase.txt file
                    EudAdrBook[i].Description[uDescription] = szAdrBuffer[ulAdrOffset + uOffset];
                } else {
                    EudAdrBook[i].Description[uDescription++] = '\r';
                    EudAdrBook[i].Description[uDescription] = '\n';
                }
            }
            // Bug 29803 - this line is not being terminated - has garrbage at end ...
            EudAdrBook[i].Description[uDescription] = '\0';
        } else {
            EudAdrBook[i].Description = NULL;
        }

        i++;
        if (szAdrLine) {
            LocalFree((HLOCAL)szAdrLine);
        }
        szAdrLine = NULL;


    } while (szAdrStart[0]!='\0');

Error:
    if (szAdrLine) {
        LocalFree((HLOCAL)szAdrLine);
    }
    szAdrLine = NULL;

    return(hr);
}


/*******************************************************************************
 *  FUNCTION NAME:CreateAdrLineBuffer
 *
 *  PURPOSE:    To get an address line in a buufer from the buffer conatining
 *              the addressbook.
 *
 *  PARAMETERS: szAdrline = pointer to the address line buffer.
 *              szAdrBuffer = pointer to the buffer containing the address book.
 *              ulAdrOffset = offset of the address line in the szAdrBuffer
 *              ulAdrSize = size of the address line in the szAdrBuffer
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT CreateAdrLineBuffer(LPTSTR *szAdrline, LPTSTR szAdrBuffer, ULONG ulAdrOffset,
  ULONG ulAdrSize)
{
    LPTSTR Temp = NULL;
    ULONG ucount;
    Temp = &szAdrBuffer[ulAdrOffset];

    *szAdrline = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulAdrSize + 2));

    if (! (*szAdrline)) {
        return(hrMemory);
    }
            
    // BUG 2120: to deal with only LF's and not CR/LF's 
    for (ucount = 0; ucount < ulAdrSize + 2; ucount++) {
        // want to stop when get to LF and will check later if
        // it was preceded by a CR
        if (/*Temp[ucount] == '\r' && */Temp[ucount/*+1*/] == '\n') {
            break;
        }
        (*szAdrline)[ucount] = Temp[ucount];
    }
// if there was a CR before the LF remove it
    if( (*szAdrline)[ucount-1] == '\r' )
        (*szAdrline)[ucount-1] = '\0';
    
    (*szAdrline)[ucount] = '\0';

    return(S_OK);
}


/******************************************************************************
 *  FUNCTION NAME:ParseAdrLineBuffer
 *
 *  PURPOSE:    To parse each address line and fill the EUDADRBOOK structure.
 *
 *  PARAMETERS: szAdrLine = pointer to the buffer containing an address line.
 *              szAliaspt = pointer to a two dimensional array containing
 *                all the nicknames.
 *              uToken = position of this address in the address book.
 *              EudAdrBook = pointer to the EUDADRBOOK structure.
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT ParseAdrLineBuffer(LPTSTR szAdrLine,LPTSTR *szAliasptr,ULONG uToken,
  EUDADRBOOK *EudAdrBook)
{
    LPTSTR szAdrEnd = NULL, szAdrStart = NULL, szAdrDummy = NULL;
    LPTSTR szAdrCur = NULL;
    INT uCount = 0;
    LPEUDDISTLIST present = NULL, previous = NULL;
    BOOL flag = TRUE;
    UINT Parse = 0;
    HRESULT hResult = S_OK;
    szAdrStart = szAdrLine;

    // Bug 44576 - this code below is assuming that a ',' in a string implies a group
    // However, there can be "...text, text..." as one item in the input in which case
    // this code really barfs ...
    // The code also assumes that <spaces> are delimiters which also wont work with 
    // the strings as above ..
    // 
    // Try changing ',' inside quoted strings to ';' so this code wont trip on them
    // Looks like this code is also throwing away the info in quotes if the string is of
    // the form alias XXX "YYY" zz@zz .. the part in ".." is discarded ??? Fix that as a
    // seperate bug ...
    {
        LPTSTR lp = szAdrStart;
        BOOL bWithinQuotes = FALSE;
        while(lp && *lp)
        {
            if(*lp == '"')
                bWithinQuotes = !bWithinQuotes;
            if(*lp == ',' && bWithinQuotes)
                *lp = ';';
            lp = CharNext(lp);
        }
    }

    //To check whether it is a dl or a simple address??

    if ((szAdrDummy=strstr(szAdrStart,","))==NULL)  {
        flag=FALSE;
    } else {
        if ('\0'==szAdrDummy[1]) {
            flag=FALSE;
        }
    }


    szAdrCur=strtok(szAdrStart,", ");
    if (NULL == szAdrCur) {
        EudAdrBook[uToken].NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAliasptr[uToken])+1);
        if (! EudAdrBook[uToken].NickName) {
            hResult = hrMemory;
            goto Error;
        }
        lstrcpy(EudAdrBook[uToken].NickName,szAliasptr[uToken]);
        EudAdrBook[uToken].lpDist=NULL;
        EudAdrBook[uToken].Address = NULL;
        return(S_OK);
    }
    while (szAdrCur!=NULL) {
        if (SearchAdrName(szAdrCur)) {
            if (flag) {
                present = (LPEUDDISTLIST)LocalAlloc(LMEM_FIXED, sizeof(EUDDISTLIST));
                if (! present) {
                    return(hrMemory);
                }
                memset(present,0,sizeof(EUDDISTLIST));
                if (previous == NULL) {
                    EudAdrBook[uToken].NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAliasptr[uToken])+1);
                    if (! EudAdrBook[uToken].NickName) {
                        hResult = hrMemory;
                        goto Error;
                    }
                    lstrcpy(EudAdrBook[uToken].NickName,szAliasptr[uToken]);
                    EudAdrBook[uToken].Address = NULL;
                }
                present->AliasID=uCount;
                present->flag=TRUE;
                present->Address = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAdrCur)+1);
                if (! present->Address) {
                    hResult = hrMemory;
                    goto Error;
                }
                lstrcpy(present->Address,szAdrCur);

                present->NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAdrCur)+1);
                if (! present->NickName) {
                    hResult = hrMemory;
                    goto Error;
                }
                lstrcpy(present->NickName,szAdrCur);
                if (previous!=NULL) {
                    previous->lpDist=present;
                } else {
                    EudAdrBook[uToken].lpDist = present;
                }
                previous=present;
            } else {
                EudAdrBook[uToken].Address = (TCHAR *)LocalAlloc(LMEM_FIXED,
                  lstrlen(szAdrCur)+1);
                if (! EudAdrBook[uToken].Address) {
                    hResult = hrMemory;
                    goto Error;
                }
                lstrcpy(EudAdrBook[uToken].Address,szAdrCur);
                EudAdrBook[uToken].NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAliasptr[uToken])+1);
                if (! EudAdrBook[uToken].NickName) {
                    hResult = hrMemory;
                    goto Error;
                }
                lstrcpy(EudAdrBook[uToken].NickName,szAliasptr[uToken]);
                EudAdrBook[uToken].lpDist=NULL;
            }

        } else {
            if ((uCount=SearchName(szAliasptr,szAdrCur))>=0) {
                if (flag) {
                    present = (LPEUDDISTLIST)LocalAlloc(LMEM_FIXED, sizeof(EUDDISTLIST));
                    if (! present) {
                        return(hrMemory);
                    }
                    memset(present,0,sizeof(EUDDISTLIST));

                    if (previous == NULL) {
                        EudAdrBook[uToken].NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAliasptr[uToken])+1);
                        if (!EudAdrBook[uToken].NickName) {
                            hResult = hrMemory;
                            goto Error;
                        }
                        lstrcpy(EudAdrBook[uToken].NickName,szAliasptr[uToken]);
                        EudAdrBook[uToken].Address = NULL;
                    }
                    present->AliasID=uCount;
                    present->flag=FALSE;
                    if (previous!=NULL) {
                        previous->lpDist=present;
                    } else {
                        EudAdrBook[uToken].lpDist = present;
                    }
                    previous=present;
                } else {
                    EudAdrBook[uToken].lpDist = (LPEUDDISTLIST)LocalAlloc(LMEM_FIXED,
                      sizeof(EUDDISTLIST));
                    if (! EudAdrBook[uToken].lpDist) {
                        return(hrMemory);
                    }
                    //memset(present,0,sizeof(EUDDISTLIST));
                    EudAdrBook[uToken].NickName = (TCHAR *)LocalAlloc(LMEM_FIXED,
                      lstrlen(szAliasptr[uToken])+1);
                    if (! EudAdrBook[uToken].NickName) {
                        hResult = hrMemory;
                        goto Error;
                    }
                    lstrcpy(EudAdrBook[uToken].NickName, szAliasptr[uToken]);
                    EudAdrBook[uToken].Address = NULL;
                    EudAdrBook[uToken].lpDist->AliasID=uCount;
                    EudAdrBook[uToken].lpDist->flag=FALSE;
                    EudAdrBook[uToken].lpDist->lpDist=NULL;
                }
            } else {
                //not a valid email address or a valid nickname
                if (FALSE==flag) {
                    if (! EudAdrBook[uToken].Address && SearchAdrName(szAdrCur)) {
                        EudAdrBook[uToken].Address = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAdrCur)+1);
                        if (! EudAdrBook[uToken].Address) {
                            hResult = hrMemory;
                            goto Error;
                        }
                        lstrcpy(EudAdrBook[uToken].Address, szAdrCur);
                    }
                    if (! EudAdrBook[uToken].NickName) {
                        EudAdrBook[uToken].NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAliasptr[uToken])+1);
                        if (! EudAdrBook[uToken].NickName) {
                            hResult = hrMemory;
                            goto Error;
                        }
                        lstrcpy(EudAdrBook[uToken].NickName, szAliasptr[uToken]);
                    }
                    EudAdrBook[uToken].lpDist=NULL;
                }
            }



        }
        szAdrCur=strtok(NULL,", ");
    }

    if (present!=NULL) {
        present->lpDist=NULL;
    }
    return(hResult);

Error:
    while (EudAdrBook[uToken].lpDist != NULL) {
        EudAdrBook[uToken].lpDist = FreeEuddistlist(EudAdrBook[uToken].lpDist);
    }
    return(hResult);


}


/******************************************************************************
 *  FUNCTION NAME:SearchAdrName
 *
 *  PURPOSE:    To search if the token is an address or a name(whether it contains
 *              a @ or not).
 *
 *  PARAMETERS: szAdrCur = pointer to the token.
 *
 *  RETURNS:    BOOL, TRUE if it contains @
 ******************************************************************************/
BOOL SearchAdrName(LPTSTR szAdrCur)
{
    if (strchr(szAdrCur, '@') == NULL) {
        return(FALSE);
    }

    return(TRUE);
}


/******************************************************************************
 *  FUNCTION NAME:SearchName
 *
 *  PURPOSE:    To search for the token in the szAliasptr which conatins all
 *              the nick names.
 *
 *  PARAMETERS: szAdrCur = pointer to the token to be searched.
 *              szAliaspt = pointer to a two dimensional array containing
 *                all the nicknames.
 *
 *  RETURNS:    INT, position of the token in the szAliaspt
 ******************************************************************************/
INT SearchName(LPTSTR *szAliasptr, LPTSTR szAdrCur)
{
    INT uCount=0;

    while (szAliasptr[uCount]!=NULL) {
        if (lstrcmpi(szAliasptr[uCount],szAdrCur) == 0) {
            return(uCount);
        }
        uCount++;
    }
    return(-1);
}


/******************************************************************************
*  FUNCTION NAME:ImportEudUsers
*
*  PURPOSE:
*
*  PARAMETERS:  hwnd = Handle to the parent Window
*               lpAdrBook = pointer to the IADRBOOK interface
*               lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
*               lpOptions = pointer to WAB_IMPORT_OPTIONS structure
*               lpWabContainer = pointer to the IABCONT interface
*               lpeudAdrBook = pointer to the EUDADRBOOK structure
*               ulCount = counter value which holds the position of this address
*                 in the Eudora address book.
*               sProp = pointer to SPropValue
*
*  RETURNS:     hresult
******************************************************************************/
HRESULT ImportEudUsers(HWND hwnd, LPTSTR szFileName, LPABCONT lpWabContainer, LPSPropValue sProp,
  LPEUDADRBOOK lpeudAdrBook, ULONG ulCount, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook)
{

    HRESULT hResult = S_OK;
    ULONG ul;
    LPSBinary lpsbinary;
    WAB_PROGRESS Progress;


    lpsbinary = (LPSBinary)LocalAlloc(LMEM_FIXED, ((ulCount+1) * sizeof(SBinary)));
    if (! lpsbinary) {
        hResult = hrMemory;
        goto Error;
    }
    memset(lpsbinary, 0, ((ulCount + 1) * sizeof(SBinary)));

    Progress.denominator = ulCount;
    Progress.numerator = 0;
    Progress.lpText = szFileName; //NULL;

    lpOptions->ReplaceOption = WAB_REPLACE_PROMPT;

    for (ul = 0; ul < ulCount; ul++) {
        if (lpeudAdrBook[ul].NickName == NULL) {
            continue;
        }

        Progress.numerator = ul;
        lpProgressCB(hwnd,&Progress);
        if (lpeudAdrBook[ul].lpDist !=NULL) {
            hResult = FillEudDistList(hwnd, lpWabContainer, sProp, lpOptions, lpeudAdrBook,
              lpsbinary, lpAdrBook, ul);
            switch (GetScode(hResult)) {
                case MAPI_E_USER_CANCEL:
                case MAPI_E_NOT_ENOUGH_MEMORY:
                    goto Error;
            }
        } else {
            hResult = FillMailUser(hwnd, lpWabContainer, sProp, lpOptions,
              (void *)lpeudAdrBook, lpsbinary, ul,EUDORA);
            switch (GetScode(hResult)) {
                case MAPI_E_USER_CANCEL:
                case MAPI_E_NOT_ENOUGH_MEMORY:
                    goto Error;
            }
        }
    }

Error:
    if (lpsbinary) {
        for (ul = 0; ul < ulCount; ul++) {
            if (lpsbinary[ul].lpb) {
                LocalFree((HLOCAL)lpsbinary[ul].lpb);
                lpsbinary[ul].lpb = NULL;
            }
        }

        LocalFree((HLOCAL)lpsbinary);
        lpsbinary = NULL;
    }

    return(hResult);
}



/******************************************************************************
 *  FUNCTION NAME:FillEudDistList
 *
 *  PURPOSE: To create a distribution list in the WAB.
 *
 *  PARAMETERS: hWnd - hWnd of parent
 *              pAdrBook = pointer to the IADRBOOK interface
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *              lpWabContainer = pointer to the IABCONT interface
 *              lpeudAdrBook = pointer to the EUDADRBOOK structure
 *              ul = counter value which holds the position of this address
 *                in the Eudora address book.
 *              sProp = pointer to SPropValue
 *              lpsbinary = pointer to the SBinary array.
 *
 *  RETURNS: HRESULT
 ******************************************************************************/
HRESULT FillEudDistList(HWND hwnd, LPABCONT lpWabContainer,LPSPropValue sProp,
  LPWAB_IMPORT_OPTIONS lpOptions,
  LPEUDADRBOOK lpeudAdrBook,LPSBinary lpsbinary,
  LPADRBOOK lpAdrBook,ULONG ul)
{
    LPSPropValue lpNewDLProps = NULL;
    LPDISTLIST lpDistList = NULL;
    ULONG cProps, ulObjType;
    ULONG iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
    ULONG iCreateTemplatedl = iconPR_DEF_CREATE_DL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    int i;
    HRESULT hResult;
    static LPMAPIPROP lpMailUserWAB = NULL;
    SPropValue rgProps[4];
    LPMAPIPROP lpDlWAB = NULL;
    LPSBinary lpsbEntry;
    SBinary sbTemp;

    BOOL flag = FALSE;
    REPLACE_INFO RI = {0};
    LPEUDDISTLIST lpTemp = lpeudAdrBook[ul].lpDist;

retry:
    if (lpsbinary[ul].lpb == NULL) {
        hResult = CreateDistEntry(lpWabContainer,sProp,ulCreateFlags,&lpMailUserWAB);
        if (hResult != S_OK) {
            goto error1;
        }
    }

    else {
        hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
          lpsbinary[ul].cb, (LPENTRYID)lpsbinary[ul].lpb, (LPIID)&IID_IMAPIProp,
           MAPI_DEFERRED_ERRORS|MAPI_MODIFY, &ulObjType, (LPUNKNOWN *)&lpMailUserWAB);
        if (hResult != S_OK) {
            goto error1;
        }
    }

    rgProps[0].ulPropTag = PR_DISPLAY_NAME;
    rgProps[0].Value.lpszA = lpeudAdrBook[ul].NickName;
    rgProps[1].Value.lpszA = lpeudAdrBook[ul].Description;
    if (lpeudAdrBook[ul].Description) {
        rgProps[1].ulPropTag = PR_COMMENT;
    } else {
        rgProps[1].ulPropTag = PR_NULL;
    }

    if (0 != (hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
      2, rgProps, NULL))) {
        goto error1;
    }

    if (0 != (hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
       FORCE_SAVE|KEEP_OPEN_READWRITE)))

        if (GetScode(hResult) == MAPI_E_COLLISION) {
            if (lpOptions->ReplaceOption == WAB_REPLACE_ALWAYS) {
                if (lpMailUserWAB) {
                    lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                }
                lpMailUserWAB = NULL;
                ulCreateFlags |= CREATE_REPLACE;
                goto retry;

            }
            if (lpOptions->ReplaceOption == WAB_REPLACE_NEVER) {
                hResult = S_OK;
                goto error1;
            }

            RI.lpszEmailAddress = NULL;
            if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
                if (lpeudAdrBook[ul].NickName) {
                    RI.lpszDisplayName = lpeudAdrBook[ul].NickName;
                    RI.lpszEmailAddress = lpeudAdrBook[ul].Address;
                } else if (lpeudAdrBook[ul].Address) {
                    RI.lpszDisplayName = lpeudAdrBook[ul].Address;
                } else if (lpeudAdrBook[ul].Description) {
                    RI.lpszDisplayName = lpeudAdrBook[ul].Description;
                } else {
                    RI.lpszDisplayName = "";
                }

                RI.ConfirmResult = CONFIRM_ERROR;
                RI.fExport = FALSE;
                RI.lpImportOptions = lpOptions;

                DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_ImportReplace), hwnd,
                  ReplaceDialogProc, (LPARAM)&RI);

                switch (RI.ConfirmResult) {
                    case CONFIRM_YES:
                    case CONFIRM_YES_TO_ALL:
                        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                        lpMailUserWAB = NULL;
                        ulCreateFlags |= CREATE_REPLACE;
                        goto retry;
                        break;

                    case CONFIRM_NO:
                        hResult = GetExistEntry(lpWabContainer,lpsbinary, ul,
                          lpeudAdrBook[ul].NickName,
                          NULL);
                        goto error1;


                    case CONFIRM_ABORT:
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                        goto error1;

                    default:
                        break;
                }
            }
        }

    if (0!= (hResult = lpMailUserWAB->lpVtbl->GetProps(lpMailUserWAB,
      (LPSPropTagArray)&ptaEid,
      0,
      &cProps,
      (LPSPropValue *)&lpNewDLProps))) {
        if (hResult == MAPI_W_ERRORS_RETURNED) {
            WABFreeBuffer(lpNewDLProps);
            lpNewDLProps = NULL;
        }
        goto error1;
    }

    lpsbinary[ul].lpb = (LPBYTE)LocalAlloc(LMEM_FIXED,
      lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
    if (! lpsbinary[ul].lpb) {
        hResult = hrMemory;
        goto error1;
    }

    CopyMemory(lpsbinary[ul].lpb,
      (LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,
      lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
    lpsbinary[ul].cb=lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb;

    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
        lpMailUserWAB = NULL;
    }

    hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
      lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb,
      (LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,
      (LPIID)&IID_IDistList,
      MAPI_DEFERRED_ERRORS|MAPI_MODIFY,
      &ulObjType,
      (LPUNKNOWN *)&lpDistList);

    if (hResult != S_OK) {
        goto error1;
    }

    if (lpNewDLProps) {
        WABFreeBuffer(lpNewDLProps);
        lpNewDLProps = NULL;
    }

    do {
        i = lpeudAdrBook[ul].lpDist->AliasID;
        if (lpeudAdrBook[ul].lpDist->flag == TRUE) {

            hResult = lpWabContainer->lpVtbl->CreateEntry(lpWabContainer,
              sProp[iCreateTemplate].Value.bin.cb,
              (LPENTRYID)sProp[iCreateTemplate].Value.bin.lpb,
              ulCreateFlags,
              &lpMailUserWAB);

            if (FAILED(hResult)) {
                goto error1;
            }

            FillEudDiststruct(rgProps,&lpeudAdrBook[ul]);

            if (0 != (hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
              3, rgProps, NULL))) {
                goto error1;
            }

            if (hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
              KEEP_OPEN_READONLY | FORCE_SAVE)) {

                if (GetScode(hResult) == MAPI_E_COLLISION) {
                    if (hResult = GetExistEntry(lpWabContainer,
                      &sbTemp,
                      0,
                      lpeudAdrBook[ul].lpDist->NickName,
                      NULL)) {
                        goto error1;
                    } else {
                        lpsbEntry = &sbTemp;
                    }
                } else {
                    goto error1;
                }
            } else {
                if (0 != (hResult = lpMailUserWAB->lpVtbl->GetProps(lpMailUserWAB,
                  (LPSPropTagArray)&ptaEid, 0, &cProps, (LPSPropValue *)&lpNewDLProps))) {
                    if (hResult == MAPI_W_ERRORS_RETURNED) {
                        WABFreeBuffer(lpNewDLProps);
                        lpNewDLProps = NULL;
                    }
                    goto error1;
                } else {
                    lpsbEntry = &(lpNewDLProps[ieidPR_ENTRYID].Value.bin);
                }
            }

            if (lpMailUserWAB) {
                // Done with this one
                lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                lpMailUserWAB = NULL;
            }

            if (0 != (hResult = lpDistList->lpVtbl->CreateEntry(lpDistList,
              lpsbEntry->cb,
              (LPENTRYID)lpsbEntry->lpb,
              CREATE_CHECK_DUP_STRICT,
              &lpDlWAB))) {
                goto error1;
            }

            hResult = lpDlWAB->lpVtbl->SaveChanges(lpDlWAB, FORCE_SAVE);
            goto disc;
        }

        if ((LPENTRYID)lpsbinary[i].lpb == NULL && lpeudAdrBook[i].lpDist!=NULL) {
            FillEudDistList(hwnd, lpWabContainer, sProp, lpOptions, lpeudAdrBook,
              lpsbinary, lpAdrBook, i);
        } else {
            FillMailUser(hwnd, lpWabContainer, sProp, lpOptions,
             (void *)lpeudAdrBook, lpsbinary, i, EUDORA);
        }

        if (0 != (hResult = lpDistList->lpVtbl->CreateEntry(lpDistList,
          lpsbinary[i].cb, (LPENTRYID)lpsbinary[i].lpb, CREATE_CHECK_DUP_STRICT,
          &lpDlWAB))) {
            goto error1;
        }

        if (0 != (hResult = lpDlWAB->lpVtbl->SaveChanges(lpDlWAB, FORCE_SAVE))) {
            if (MAPI_E_FOLDER_CYCLE ==hResult) {
                lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_LOOPING));
                MessageBox(NULL,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ENTRY_NOIMPORT),MB_OK);
            }
            hResult = S_OK;
            goto error1;
        }

disc:
        if (lpNewDLProps) {
            WABFreeBuffer(lpNewDLProps);
            lpNewDLProps = NULL;
        }

        if (lpDlWAB) {
            lpDlWAB->lpVtbl->Release(lpDlWAB);
            lpDlWAB = NULL;
        }

        lpeudAdrBook[ul].lpDist=FreeEuddistlist(lpeudAdrBook[ul].lpDist);
    } while (lpeudAdrBook[ul].lpDist != NULL);

error1:
    if (lpNewDLProps) {
        WABFreeBuffer(lpNewDLProps);
    }
    if (lpDistList) {
        lpDistList->lpVtbl->Release(lpDistList);
        lpDistList = NULL;
    }

    if (lpDlWAB) {
        lpDlWAB->lpVtbl->Release(lpDlWAB);
        lpDlWAB = NULL;
    }

    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
        lpMailUserWAB = NULL;
    }

    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:FillEudWABStruct
 *
 *  PURPOSE:    To fill the SpropValue array.
 *
 *  PARAMETERS: eudAdrBook = pointer to the EUDADRBOOK structure.
 *              rgProps = pointer to the SpropValue array.
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT FillEudWABStruct(LPSPropValue rgProps, EUDADRBOOK *eudAdrBook)
{
    HRESULT hr = S_OK;

    rgProps[1].Value.lpszA = eudAdrBook->NickName;

    if (eudAdrBook->NickName) {
        rgProps[1].ulPropTag = PR_DISPLAY_NAME;
    } else {
        rgProps[1].ulPropTag = PR_NULL;
    }

    rgProps[0].Value.lpszA = eudAdrBook->Address;
    if (eudAdrBook->Address) {
        rgProps[0].ulPropTag = PR_EMAIL_ADDRESS;
        rgProps[2].ulPropTag = PR_ADDRTYPE;
        rgProps[2].Value.lpszA = LoadStringToGlobalBuffer(IDS_SMTP);
    } else {
        rgProps[0].ulPropTag = PR_NULL;
        rgProps[2].ulPropTag = PR_NULL;
        rgProps[2].Value.lpszA = NULL;
    }

    rgProps[3].Value.lpszA = eudAdrBook->Description;
    if (eudAdrBook->Description) {
        rgProps[3].ulPropTag = PR_COMMENT;
    } else {
        rgProps[3].ulPropTag = PR_NULL;
    }

    rgProps[4].Value.lpszA = eudAdrBook->NickName;
    if (eudAdrBook->NickName) {
        rgProps[4].ulPropTag = PR_NICKNAME;
    } else {
        rgProps[4].ulPropTag = PR_NULL;
    }

    return(hr);
}


/******************************************************************************
 *  FUNCTION NAME:FillEudDiststruct
 *
 *  PURPOSE:    To fill the SpropValue array.
 *
 *  PARAMETERS: eudAdrBook = pointer to the EUDADRBOOK structure.
 *              rgProps = pointer to the SpropValue array.
 *
 *  RETURNS:    none
 ******************************************************************************/
void FillEudDiststruct(LPSPropValue rgProps, EUDADRBOOK *eudAdrBook)
{
    rgProps[1].Value.lpszA = eudAdrBook->lpDist->NickName;

    if (eudAdrBook->lpDist->NickName) {
        rgProps[1].ulPropTag = PR_DISPLAY_NAME;
    } else {
        rgProps[1].ulPropTag = PR_NULL;
    }

    rgProps[0].Value.lpszA = eudAdrBook->lpDist->Address;
    if (eudAdrBook->lpDist->Address) {
        rgProps[0].ulPropTag = PR_EMAIL_ADDRESS;
        rgProps[2].ulPropTag = PR_ADDRTYPE;
        rgProps[2].Value.lpszA = LoadStringToGlobalBuffer(IDS_SMTP);
    } else {
        rgProps[0].ulPropTag = PR_NULL;
        rgProps[2].ulPropTag = PR_NULL;
        rgProps[2].Value.lpszA = NULL;
    }
}


/******************************************************************************
 *  FUNCTION NAME:FreeEuddistlist
 *
 *  PURPOSE:    To free one node from EUDDISTLIST(linked list)
 *
 *  PARAMETERS: lpDist = pointer to the EUDDISTLIST structure.
 *
 *  RETURNS:    LPEUDDISTLIST , pointer to the next link.
 ******************************************************************************/
LPEUDDISTLIST FreeEuddistlist(LPEUDDISTLIST lpDist)
{
    LPEUDDISTLIST lpTemp = NULL;

    if (lpDist == NULL) {
        return(NULL);
    }

    lpTemp = lpDist->lpDist;

    if (lpDist->NickName) {
        LocalFree((HLOCAL)lpDist->NickName);
    }
    lpDist->NickName = NULL;

    if (lpDist->Description) {
        LocalFree((HLOCAL)lpDist->Description);
    }
    lpDist->Description = NULL;

    if (lpDist->Address) {
        LocalFree((HLOCAL)lpDist->Address);
    }
    lpDist->Address = NULL;

    LocalFree((HLOCAL)lpDist);
    lpDist = NULL;
    return(lpTemp);
}


/******************************************************************************
 *  FUNCTION NAME:Getstr
 *
 *  PURPOSE:    Case insensitive equivalent of strstr
 *
 *  PARAMETERS: szSource = string to search
 *              szToken = string to search for
 *
 *  RETURNS:    pointer to the first occurrence of szToken in szSource
 ******************************************************************************/
TCHAR* Getstr(TCHAR* szSource, TCHAR* szToken)
{

    int i,
    nLength;
    LPTSTR szdummy = NULL;

    szdummy = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szToken)+1));
    if (!szdummy)
        return(NULL);
    lstrcpy(szdummy,szToken);
    _strupr(szdummy) ;
    nLength = lstrlen (szdummy) ;

    while (*szSource && *(szSource + nLength-1)) {
        for (i = 0 ;i < nLength ; i++) {
            TCHAR k = ToUpper(szSource[i]) ;
            if (szdummy[i] != k)
                break ;
            if (i == (nLength - 1)) {
                LocalFree(szdummy);
                return(szSource);
            }
        }
        szSource ++ ;
    }

    LocalFree(szdummy);
    return(NULL);
}

/******************************************************************************
*  FUNCTION NAME:ShiftAdd
*
*  PURPOSE:     To get the address size from a binary file by reading four bytes.
*               This function reads four consecutive bytes from a buffer and
*               converts it to a ULONG value.
*
*  PARAMETERS:  offset = position in the buffer from where to read
*               szBuffer = buffer
*
*  RETURNS:     ULONG, size
******************************************************************************/
ULONG ShiftAdd(int offset, TCHAR *szBuffer)
{
    ULONG ulSize = 0;
    int iCounter = 0;

    for (iCounter = 3; iCounter > 0; iCounter--) {
        ulSize |= (unsigned long)((unsigned char)szBuffer[iCounter + offset]);
        ulSize <<= 8;
    }
    ulSize |= (unsigned long)((unsigned char)szBuffer[iCounter + offset]);

    return(ulSize);
}


/******************************************************************************
 *********************Athena Functions*****************************************
 ******************************************************************************
 *  FUNCTION NAME:MigrateAthUser
 *
 *  PURPOSE:    To get the installation path of the address book and starts
 *              processing the Athena address book
 *
 *  PARAMETERS: hwnd = Handle to the parent Window
 *              lpAdrBook = pointer to the IADRBOOK interface
 *              lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT MigrateAthUser(HWND hwnd, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook)
{
    TCHAR szFileName[MAX_FILE_NAME];
    HRESULT hResult;

    if (FALSE == GetFileToImport(hwnd, szFileName, ATHENA16)) {
        return(ResultFromScode(MAPI_E_USER_CANCEL));
    }

    hResult = ParseAthAddressBook(hwnd, szFileName, lpOptions, lpProgressCB,
      lpAdrBook);

    return(hResult);
}


/*****************************************************************************
*  FUNCTION NAME:ParseAthAddressBook
*
*  PURPOSE:     To get the address book in a file, process addresses and fill WAB.
*
*  PARAMETERS:  hwnd = Handle to the parent Window
*               szFileName = path of the address book.
*               lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
*               lpOptions = pointer to WAB_IMPORT_OPTIONS structure
*               lpAdrBook = pointer to the IADRBOOK interface
*
*  RETURNS:     HRESULT
******************************************************************************/
HRESULT  ParseAthAddressBook(HWND hwnd,LPTSTR szFileName,
  LPWAB_IMPORT_OPTIONS lpOptions, LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPADRBOOK lpAdrBook)
{
    ULONG ulCount=0, ulRead=0, ulFileSize, i, cProps, cError=0;
    HANDLE hFile = NULL;
    ABCREC abcrec;
    TCHAR Buffer[ATHENASTRUCTURE];
    LPABCONT lpWabContainer = NULL;
    HRESULT hResult;
    static LPSPropValue sProp;
    WAB_PROGRESS Progress;

    lpOptions->ReplaceOption = WAB_REPLACE_PROMPT;

    /* Description of athena16 addressbook
       Size of each recipient list - 190 bytes
         Display Name : 81 bytes
         Address      : 81 bytes
         starting from 28 bytes.
    */

    hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
      OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (INVALID_HANDLE_VALUE == hFile) {
        return(ResultFromScode(MAPI_E_NOT_FOUND));
    }

    ulFileSize = GetFileSize(hFile, NULL);

    if ((ulFileSize % ATHENASTRUCTURE) != 0) {
        lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ERROR_ADDRESSBOOK));
        MessageBox(hwnd, szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ERROR), MB_OK);
        goto Error;
    }


    if (! ulFileSize) {
        lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_NO_ENTRY));
        MessageBox(hwnd, szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE), MB_OK);
        return(ResultFromScode(MAPI_E_CALL_FAILED));
    }


    ulCount = ulFileSize / ATHENASTRUCTURE;
    Progress.denominator = ulCount;
    Progress.numerator = 0;
    Progress.lpText = NULL;


    if (0 != (hResult = OpenWabContainer(&lpWabContainer, lpAdrBook))) {
        lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_WAB_ERROR));
        MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ERROR),MB_OK);
        return(hResult);
    }

    if (0 != (hResult = lpWabContainer->lpVtbl->GetProps(lpWabContainer,
      (LPSPropTagArray)&ptaCon, 0, &cProps, (LPSPropValue *)&sProp))) {
        if (hResult == MAPI_W_ERRORS_RETURNED) {
            WABFreeBuffer(sProp);
            sProp = NULL;
        }
        lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_WAB_ERROR));
        MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ERROR),MB_OK);
        return(hResult);
    }

    for (i = 0; i < ulFileSize / ATHENASTRUCTURE; i++) {
        Progress.numerator = i;
        lpProgressCB(hwnd, &Progress);
        if (! ReadFile(hFile, Buffer, ATHENASTRUCTURE, &ulRead, NULL)) {
            goto Error;
        }
        if (NULL == lstrcpyn(abcrec.DisplayName, Buffer + ATHENAADROFFSET,
          MAX_NAME_SIZE + 1)) {
            goto Error;
        }
        if (NULL == lstrcpyn(abcrec.EmailAddress,
          Buffer + ATHENAADROFFSET + MAX_NAME_SIZE + 1, MAX_EMA_SIZE + 1)) {
            goto Error;
        }
        if (strlen(abcrec.DisplayName) == 0 || lstrlen(abcrec.EmailAddress) == 0) {
            continue;
        }
        if (0 != FillAthenaUser(hwnd, lpWabContainer,sProp,lpOptions,&abcrec)) {
            cError++;
        }

    }


Error:
    if (sProp) {
        WABFreeBuffer(sProp);
        sProp = NULL;
    }
    if (lpWabContainer) {
        lpWabContainer->lpVtbl->Release(lpWabContainer);
        lpWabContainer = NULL;
    }
    if (hFile) {
        CloseHandle(hFile);
    }

    if (cError) {
        lstrcpy(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_GERNERIC_ERROR));
        MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ERROR),MB_OK);
    }
    return(hResult);
}


/*****************************************************************************
*  FUNCTION NAME:FillAthenaUser
*
*  PURPOSE:     To create an entry for the athena16 mail user in the wab.
*
*  PARAMETERS:  hwnd - hwnd of parent
*               lpWabContainer = pointer to the IABCONT interface
*               sProp = pointer to SPropValue
*               lpOptions = pointer to WAB_IMPORT_OPTIONS structure
*               lpabcrec = pointer to the ABCREC structure.
*
*  RETURNS:     HRESULT
******************************************************************************/
HRESULT FillAthenaUser(HWND hwnd, LPABCONT lpWabContainer, LPSPropValue sProp,
  LPWAB_IMPORT_OPTIONS lpOptions, LPABCREC lpabcrec)
{
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    ULONG iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
    LPMAPIPROP lpMailUserWAB = NULL;
    HRESULT hResult;
    REPLACE_INFO RI = {0};
    SPropValue rgProps[3];

retry:
    hResult = lpWabContainer->lpVtbl->CreateEntry(lpWabContainer,
      sProp[   iCreateTemplate].Value.bin.cb,
      (LPENTRYID)sProp[iCreateTemplate].Value.bin.lpb,
      ulCreateFlags,
      &lpMailUserWAB);
    if (FAILED(hResult)) {
        goto Error;
    }

    rgProps[1].ulPropTag = PR_DISPLAY_NAME;
    rgProps[1].Value.lpszA = lpabcrec->DisplayName;

    rgProps[0].Value.lpszA = lpabcrec->EmailAddress;
    if (lpabcrec->EmailAddress) {
        rgProps[0].ulPropTag = PR_EMAIL_ADDRESS;
        rgProps[2].ulPropTag = PR_ADDRTYPE;
        rgProps[2].Value.lpszA = LoadStringToGlobalBuffer(IDS_SMTP);
    } else {
        rgProps[0].ulPropTag = PR_NULL;
        rgProps[2].ulPropTag = PR_NULL;
        rgProps[2].Value.lpszA = NULL;
    }

    if (0 != (hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB, 3,
        rgProps, NULL))) {
        goto Error;
    }

    hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
      KEEP_OPEN_READONLY | FORCE_SAVE);


    if (GetScode(hResult) == MAPI_E_COLLISION) {
        if (lpOptions->ReplaceOption == WAB_REPLACE_ALWAYS) {
            if (lpMailUserWAB) {
                lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
            }
            lpMailUserWAB = NULL;
            ulCreateFlags |= CREATE_REPLACE;
            goto retry;
        }

        if (lpOptions->ReplaceOption == WAB_REPLACE_NEVER) {
            hResult = S_OK;
            goto Error;
        }

        if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
            RI.lpszDisplayName = lpabcrec->DisplayName;
            RI.lpszEmailAddress = lpabcrec->EmailAddress;
            RI.ConfirmResult = CONFIRM_ERROR;
            RI.fExport = FALSE;
            RI.lpImportOptions = lpOptions;

            DialogBoxParam(hInst,MAKEINTRESOURCE(IDD_ImportReplace), hwnd,
              ReplaceDialogProc, (LPARAM)&RI);

            switch (RI.ConfirmResult) {
                case CONFIRM_YES:
                case CONFIRM_YES_TO_ALL:
                    lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                    lpMailUserWAB = NULL;
                    ulCreateFlags |= CREATE_REPLACE;
                    goto retry;
                    break;

                case CONFIRM_NO_TO_ALL:
                case CONFIRM_NO:
                    hResult = hrSuccess;
                    break;

                case CONFIRM_ABORT:
                    hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                    goto Error;

                default:
                    break;
            }
        }
    }

Error:

    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
        lpMailUserWAB = NULL;
    }

    return(hResult);
}


/******************************************************************************
*********************Common Functions*****************************************
******************************************************************************
*  FUNCTION NAME:OpenWabContainer
*
*  PURPOSE:     To get the pointer to the IABCCONT interface using the
*               IADRBOOK interface.
*
*  PARAMETERS:  lpAdrBook = pointer to the IADRBOOK interface.
*               lppWabContainer = pointer to the IABCONT interface.
*
*
*  RETURNS:     HRESULT
******************************************************************************/
HRESULT OpenWabContainer(LPABCONT *lppWabContainer, LPADRBOOK lpAdrBook)
{
    LPENTRYID lpEntryID = NULL;
    ULONG     cbEntryID;
    ULONG     ulObjType;
    HRESULT hResult;

    hResult = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &cbEntryID, &lpEntryID);

    if (FAILED(hResult)) {
        goto Err;
    }

    hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook, cbEntryID, lpEntryID,
      NULL, 0, &ulObjType, (LPUNKNOWN *)lppWabContainer);

Err:
    if (lpEntryID) {
        WABFreeBuffer(lpEntryID);
    }
    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:GetFileToImport
 *
 *  PURPOSE:    To get the path of the address book file using the GetOpenFileName
 *
 *  PARAMETERS: hwnd = Handle to the parent Window
 *              szFileName = path of the address book
 *              type =  containing the value indicating whether it is a EUDORA or
 *                NETSCAPE or ATHENA16
 *
 *  RETURNS:    BOOL
 ******************************************************************************/
BOOL GetFileToImport(HWND hwnd, LPTSTR szFileName, int type)
{
    OPENFILENAME ofn;
    BOOL ret;
    TCHAR szFile[MAX_FILE_NAME];
    TCHAR szFilter[MAX_FILE_NAME];
    ULONG ulSize = 0;

    switch (type) {
        case NETSCAPE:
            lstrcpy(szFile, LoadStringToGlobalBuffer(IDS_NETSCAPE_PATH));
            // Bug 17928
            //lstrcpy(szFilter,LoadStringToGlobalBuffer(IDS_NETSCAPE_FILE));
            ulSize = SizeLoadStringToGlobalBuffer(IDS_NETSCAPE_FILE);
            CopyMemory(szFilter, szGlobalAlloc, ulSize);
            szFilter[ulSize]=szFilter[ulSize+1]='\0';

            ofn.lpstrTitle = LoadStringToGlobalBuffer(IDS_NETSCAPE_TITLE);
            break;

        case ATHENA16:
            lstrcpy(szFile, LoadStringToGlobalBuffer(IDS_ATHENA16_PATH));
            // Bug 17928
            //lstrcpy(szFilter, LoadStringToGlobalBuffer(IDS_ATHENA16_FILE));
            ulSize = SizeLoadStringToGlobalBuffer(IDS_ATHENA16_FILE);
            CopyMemory(szFilter, szGlobalAlloc, ulSize);
            szFilter[ulSize]=szFilter[ulSize+1]='\0';

            ofn.lpstrTitle = LoadStringToGlobalBuffer(IDS_ATHENA16_TITLE);
            break;

        case EUDORA:
            lstrcpy(szFile, LoadStringToGlobalBuffer(IDS_EUDORA_PATH));
            // Bug 17928
            //lstrcpy(szFilter, LoadStringToGlobalBuffer(IDS_EUDORA_FILE));
            ulSize = SizeLoadStringToGlobalBuffer(IDS_EUDORA_FILE);
            CopyMemory(szFilter, szGlobalAlloc, ulSize);
            szFilter[ulSize]=szFilter[ulSize+1]='\0';

            ofn.lpstrTitle = LoadStringToGlobalBuffer(IDS_EUDORA_TITLE);
            break;
    }

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_EXPLORER | OFN_ENABLEHOOK | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.lCustData = 0;
    ofn.lpfnHook = ComDlg32DlgProc;
    ofn.lpTemplateName = NULL;

    ret = GetOpenFileName(&ofn);

    if (ret) {
        lstrcpy(szFileName, szFile);
    }

    return(ret);
}


INT_PTR CALLBACK ReplaceDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    LPREPLACE_INFO lpRI = (LPREPLACE_INFO)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (message) {
        case WM_INITDIALOG:
            {
                TCHAR szFormat[MAX_RESOURCE_STRING + 1];
                LPTSTR lpszMessage = NULL;
                ULONG ids;

                SetWindowLongPtr(hwnd, DWLP_USER, lParam);  //Save this for future reference
                lpRI = (LPREPLACE_INFO)lParam;

                if (lpRI->fExport) {
                    ids = lpRI->lpszEmailAddress ?
                      IDS_REPLACE_MESSAGE_EXPORT_2 : IDS_REPLACE_MESSAGE_EXPORT_1;
                } else {
                    ids = lpRI->lpszEmailAddress ?
                      IDS_REPLACE_MESSAGE_IMPORT_2 : IDS_REPLACE_MESSAGE_IMPORT_1;
                }

                if (LoadString(hInst,
                  ids,
                  szFormat, sizeof(szFormat))) {
                    LPTSTR lpszArg[2] = {lpRI->lpszDisplayName, lpRI->lpszEmailAddress};

                    if (! FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      szFormat,
                      0, 0, //ignored
                      (LPTSTR)&lpszMessage,
                      0,
                      (va_list *)lpszArg)) {
                        DebugTrace("FormatMessage -> %u\n", GetLastError());
                    } else {
                        DebugTrace("Status Message: %s\n", lpszMessage);
                        if (! SetDlgItemText(hwnd, IDC_Replace_Message, lpszMessage)) {
                            DebugTrace("SetDlgItemText -> %u\n", GetLastError());
                        }
                        LocalFree(lpszMessage);
                    }
                }
                return(TRUE);
            }

        case WM_COMMAND :
            switch (wParam) {
                case IDCANCEL:
                    lpRI->ConfirmResult = CONFIRM_ABORT;
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDCLOSE:
                case IDNO:
                    lpRI->ConfirmResult = CONFIRM_NO;
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDOK:
                case IDYES:
                    // Set the state of the parameter
                    lpRI->ConfirmResult = CONFIRM_YES;
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);


                case IDC_NoToAll:
                    lpRI->ConfirmResult = CONFIRM_NO_TO_ALL;
                    if (lpRI->fExport) {
                        lpRI->lpExportOptions->ReplaceOption = WAB_REPLACE_NEVER;
                    } else {
                        lpRI->lpImportOptions->ReplaceOption = WAB_REPLACE_NEVER;
                    }
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);

                case IDC_YesToAll:
                    lpRI->ConfirmResult = CONFIRM_YES_TO_ALL;
                    if (lpRI->fExport) {
                        lpRI->lpImportOptions->ReplaceOption = WAB_REPLACE_ALWAYS;
                    } else {
                        lpRI->lpExportOptions->ReplaceOption = WAB_REPLACE_ALWAYS;
                    }
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);

                case IDM_EXIT:
                    SendMessage(hwnd, WM_DESTROY, 0, 0L);
                    return(0);
                }
            break ;

        case IDCANCEL:
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case WM_CLOSE:
            EndDialog(hwnd, FALSE);
            return(0);

        default:
            return(FALSE);
    }

    return(TRUE);
}


INT_PTR CALLBACK ErrorDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    LPERROR_INFO lpEI = (LPERROR_INFO)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (message) {
        case WM_INITDIALOG:
            {
                TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
                LPTSTR lpszMessage;

                SetWindowLongPtr(hwnd, DWLP_USER, lParam);  // Save this for future reference
                lpEI = (LPERROR_INFO)lParam;

                if (LoadString(hInst,
                  lpEI->ids,
                  szBuffer, sizeof(szBuffer))) {
                    LPTSTR lpszArg[2] = {lpEI->lpszDisplayName, lpEI->lpszEmailAddress};

                    if (! FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      szBuffer,
                      0, 0, //ignored
                      (LPTSTR)&lpszMessage,
                      0,
                      (va_list *)lpszArg)) {
                        DebugTrace("FormatMessage -> %u\n", GetLastError());
                    } else {
                        DebugTrace("Status Message: %s\n", lpszMessage);
                        if (! SetDlgItemText(hwnd, IDC_ErrorMessage, lpszMessage)) {
                            DebugTrace("SetDlgItemText -> %u\n", GetLastError());
                        }
                        LocalFree(lpszMessage);
                    }
                }
                return(TRUE);
            }

        case WM_COMMAND :
            switch (wParam) {
                case IDCANCEL:
                    lpEI->ErrorResult = ERROR_ABORT;
                    // fall through to close.

                case IDCLOSE:
                    // Ignore the contents of the radio button
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDOK:
                    // Get the contents of the radio button
                    lpEI->lpImportOptions->fNoErrors = (IsDlgButtonChecked(hwnd, IDC_NoMoreError) == 1);
                    lpEI->lpExportOptions->fNoErrors = (IsDlgButtonChecked(hwnd, IDC_NoMoreError) == 1);
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);

                case IDM_EXIT:
                    SendMessage(hwnd, WM_DESTROY, 0, 0L);
                    return(0);
                }
            break ;

        case IDCANCEL:
            // treat it like a close
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case WM_CLOSE:
            EndDialog(hwnd, FALSE);
            return(0);

        default:
            return(FALSE);
    }

    return(TRUE);
}


/******************************************************************************
 *  FUNCTION NAME:GetRegistryPath
 *
 *  PURPOSE:    To Get path for eudora and netscape installation
 *
 *  PARAMETERS: szFileName = buffer containing the installation path
 *              type =  containing the value indicating whether it is a EUDORA or
 *                NETSCAPE.
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT GetRegistryPath(LPTSTR szFileName, int type)
{
    HKEY phkResult = NULL;
    LONG Registry;
    BOOL bResult;
    LPOSVERSIONINFO lpVersionInformation ;
    TCHAR *lpData = NULL, *RegPath = NULL, *path = NULL;
    unsigned long  size = MAX_FILE_NAME;
    HKEY hKey = (type == NETSCAPE ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER);
    HRESULT hResult = S_OK;


    lpData = (TCHAR *)LocalAlloc(LMEM_FIXED, 3*MAX_FILE_NAME);
    if (!lpData) {
        hResult = hrMemory;
        goto error;
    }

    RegPath = (TCHAR *)LocalAlloc(LMEM_FIXED, MAX_FILE_NAME);
    if (! RegPath) {
        hResult = hrMemory;
        goto error;
    }

    path = (TCHAR *)LocalAlloc(LMEM_FIXED, MAX_STRING_SIZE);
    if (! path) {
        hResult = hrMemory;
        goto error;
    }

    switch (type) {
        case(NETSCAPE):
            lstrcpy(RegPath, LoadStringToGlobalBuffer(IDS_NETSCAPE_REGKEY));
            lstrcpy(path, LoadStringToGlobalBuffer(IDS_NETSCAPE_ADDRESS_PATH));
            break;

        case(EUDORA):
            lstrcpy(RegPath, LoadStringToGlobalBuffer(IDS_EUDORA_32_REGKEY));
            lstrcpy(path, LoadStringToGlobalBuffer(IDS_EUDORA_ADDRESS_PATH));
            break;
    }

    lpVersionInformation = (LPOSVERSIONINFO)LocalAlloc(LMEM_FIXED, sizeof(OSVERSIONINFO));

    if (!lpVersionInformation) {
        hResult = hrMemory;
        goto error;
    }

    lpVersionInformation->dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ((bResult = GetVersionEx(lpVersionInformation)) == FALSE) {
        hResult = E_FAIL;
        goto error;
    }

    switch (lpVersionInformation->dwPlatformId) {

        case (VER_PLATFORM_WIN32s):
            hResult = E_FAIL;
            goto error;
            break;

        case (VER_PLATFORM_WIN32_WINDOWS):
        case  (VER_PLATFORM_WIN32_NT):
            Registry = RegOpenKeyEx(hKey,RegPath, 0, KEY_QUERY_VALUE, &phkResult);
            // bug 35949 - not finding the correct key under HKLM for Netscape
            // Try again under HKCU
            if (type == NETSCAPE && Registry != ERROR_SUCCESS) {
                Registry = RegOpenKeyEx(HKEY_CURRENT_USER, RegPath, 0, KEY_QUERY_VALUE,
                  &phkResult);
            }
            if (Registry != ERROR_SUCCESS) {
                hResult = E_FAIL;
                goto error;
            }
            break;
    }


    Registry = RegQueryValueEx(phkResult, path, NULL, NULL, (LPBYTE)lpData, &size);
    if (Registry != ERROR_SUCCESS) {
        hResult = E_FAIL;
        goto error;
    }

    lstrcpy(szFileName,lpData);

    if (type == EUDORA) {
        // this key value contains three items:
        // Path-to-Eudora,exe<space>Path-to-Eudora-Dir<space>Path-to-ini-file
        // We want the middle entry only
        LPTSTR lp = szFileName;
        while (*lp && ! IsSpace(lp)) {
            lp = CharNext(lp);
        }
        if (IsSpace(lp)) {
            // overwrite everything upto the first space
            lp = CharNext(lp);
            lstrcpy(szFileName, lp);

            // Find the next space and terminate the filename string there
            lp = szFileName;
            while (*lp && ! IsSpace(lp)) {
                lp = CharNext(lp);
            }
            if (IsSpace(lp)) {
                *lp = '\0';
            }
        }
    }

error:
    if (phkResult) {
        RegCloseKey(phkResult);
    }
    if (hKey) {
        RegCloseKey(hKey);
    }
    if (lpVersionInformation) {
        LocalFree((HLOCAL)lpVersionInformation);
    }
    if (lpData) {
        LocalFree((HLOCAL)lpData);
    }
    if (RegPath) {
        LocalFree((HLOCAL)RegPath);
    }
    if (path) {
        LocalFree((HLOCAL)path);
    }

    return(hResult);

}


/******************************************************************************
 *  FUNCTION NAME:GetExistEntry
 *
 *  PURPOSE:    To fill the Sbinary array for an already existig entry in the WAB
 *              for which user has selected NO as replace option.
 *
 *  PARAMETERS: lpWabContainer = pointer to the IABCONT interface.
 *              lpsbinary = pointer to SBinary array.
 *              ucount = position in the SBinary array where the ENTRY_ID has
 *                to be filled.
 *              szDisplayName = display nmae of the user that has to be searched.
 *              szNickName = if no DisplayName, use NickName
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT GetExistEntry(LPABCONT lpWabContainer, LPSBinary lpsbinary, ULONG ucount,
  LPTSTR szDisplayName, LPTSTR szNickName)
{
    HRESULT hResult;
    LPMAPITABLE lpMapiTable = NULL;
    SRestriction Restriction;
    SPropValue pProp;
    LPSRowSet lpsrowset=NULL;
    SPropertyRestriction PropertyRestriction;
    BOOKMARK bkmark;

    bkmark = BOOKMARK_BEGINNING;
    pProp.ulPropTag = PR_DISPLAY_NAME;
    if (szDisplayName && lstrlen(szDisplayName)) {
        pProp.Value.lpszA = szDisplayName;
    } else if (szNickName && lstrlen(szNickName)) {
        pProp.Value.lpszA = szNickName;
    }

    PropertyRestriction.relop=RELOP_EQ;
    PropertyRestriction.ulPropTag=PR_DISPLAY_NAME;
    PropertyRestriction.lpProp=&pProp;

    Restriction.rt=RES_PROPERTY;
    Restriction.res.resProperty=PropertyRestriction;

    if (0 != (hResult = lpWabContainer->lpVtbl->GetContentsTable(lpWabContainer,
      MAPI_DEFERRED_ERRORS, &lpMapiTable))) {
        goto error;
    }

    if (0 != (hResult = lpMapiTable->lpVtbl->FindRow(lpMapiTable, &Restriction, bkmark, 0))) {
        goto error;
    }

    if (0 != (hResult = lpMapiTable->lpVtbl->SetColumns(lpMapiTable,
      (LPSPropTagArray)&ptaEid, 0))) {
        goto error;
    }

    if (0 != (hResult = lpMapiTable->lpVtbl->QueryRows(lpMapiTable, 1, 0, &lpsrowset))) {
        goto error;
    }

    if (! (lpsbinary[ucount].lpb = (LPBYTE)LocalAlloc(LMEM_FIXED,
      lpsrowset->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb))) {
        hResult = hrMemory;
        goto error;
    }
    CopyMemory(lpsbinary[ucount].lpb, lpsrowset->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb,
      lpsrowset->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb);
    lpsbinary[ucount].cb = lpsrowset->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;

error:
    if (lpsrowset) {
        FreeRowSet(lpsrowset);
    }
    if (lpMapiTable) {
        lpMapiTable->lpVtbl->Release(lpMapiTable);
        lpMapiTable = NULL;
    }

    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:FreeRowSet
 *
 *  PURPOSE:    To free the srowset structure.
 *
 *  RETURNS:    none.
 ******************************************************************************/
void FreeRowSet(LPSRowSet lpRows)
{
    ULONG cRows;

    if (! lpRows) {
        return;
    }

    for (cRows = 0; cRows < lpRows->cRows; ++cRows) {
        WABFreeBuffer(lpRows->aRow[cRows].lpProps);
    }

    WABFreeBuffer(lpRows);
}


/******************************************************************************
*  FUNCTION NAME:SizeLoadStringToGlobalBuffer
*
*  PURPOSE:     Loads a string resource into the globall alloc buffer
*               and returns the size, not the string
*
*  PARAMETERS:  StringID - String identifier to load
*
*  RETURNS:     ULONG number of characters loaded
*
*  created:     Vikramm 02/04/97
*               Bug: 17928 - trash in OpenFileDialog dropdown
*               caused because lstrcpy cant copy strings with
*               \0 in them. Need to do a copy memory
******************************************************************************/
ULONG SizeLoadStringToGlobalBuffer(int StringID)
{
    ULONG ulSize = 0;
    ulSize = LoadString(hInst, StringID, szGlobalAlloc, sizeof(szGlobalAlloc));
    return(ulSize);
}


/******************************************************************************
*  FUNCTION NAME:LoadStringToGlobalBuffer
*
*  PURPOSE:     Loads a string resource
*
*  PARAMETERS:  StringID - String identifier to load
*
*  RETURNS:     LPTSTR, string that is loaded.
******************************************************************************/
LPTSTR LoadStringToGlobalBuffer(int StringID)
{
    ULONG ulSize = 0;

    ulSize = LoadString(hInst, StringID, szGlobalAlloc, sizeof(szGlobalAlloc));
    return(szGlobalAlloc);
}


/******************************************************************************
 *  FUNCTION NAME:FillMailUser
 *
 *  PURPOSE:    To create a mail user in the WAB for NetScape/Eudora .
 *
 *  PARAMETERS: hwnd - hwnd of parent
 *              lpWabContainer = pointer to the IABCONT interface.
 *              sProp = pointer to SPropValue which contains ENTRY_ID.
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *              lpadrbook = pointer to NSADRBOOK/EUDADRBOOK typecasted to void*
 *              lpsbinary = pointer to an array of SBinary structure.
 *              type =  containing the value indicating whether it is a EUDORA or
 *                NETSCAPE.
 *              ul = offset for Eudora in EUDADRBOOK array.
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT FillMailUser(HWND hwnd, LPABCONT lpWabContainer, LPSPropValue sProp,
  LPWAB_IMPORT_OPTIONS lpOptions, void *lpadrbook, LPSBinary lpsbinary, ULONG ul, int type)
{
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    ULONG iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
    LPSPropValue lpNewDLProps = NULL;
    LPMAPIPROP lpMailUserWAB = NULL;
    ULONG cProps;
    HRESULT hResult;
    REPLACE_INFO RI;
    SPropValue rgProps[5];
    LPEUDADRBOOK lpEudAdrBook = NULL;
    LPNSADRBOOK lpNsAdrBook = NULL;


    if (NETSCAPE == type) {
        lpNsAdrBook = (LPNSADRBOOK)lpadrbook;
    } else {
        lpEudAdrBook = (LPEUDADRBOOK)lpadrbook;
    }

retry:
    if (EUDORA == type) {
        if (lpsbinary[ul].lpb != NULL) {
            return(S_OK);
        }
    }

    hResult = lpWabContainer->lpVtbl->CreateEntry(lpWabContainer,
      sProp[iCreateTemplate].Value.bin.cb,
      (LPENTRYID)sProp[iCreateTemplate].Value.bin.lpb,
      ulCreateFlags,
      &lpMailUserWAB);

    if (FAILED(hResult)) {
        goto Error;
    }

    if (NETSCAPE == type) {
        FillWABStruct(rgProps,lpNsAdrBook);
        if (0 != (hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB, 5,
          rgProps, NULL)))
            goto Error;
    } else {
        FillEudWABStruct(rgProps,&lpEudAdrBook[ul]);
        if (0 != (hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB, 4,
          rgProps, NULL)))
            goto Error;
    }

    hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
      KEEP_OPEN_READONLY | FORCE_SAVE);


    if (GetScode(hResult) == MAPI_E_COLLISION) {
        if (lpOptions->ReplaceOption == WAB_REPLACE_ALWAYS) {
            if (lpMailUserWAB) {
                lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
            }
            lpMailUserWAB = NULL;
            ulCreateFlags |= CREATE_REPLACE;
            goto retry;
        }

        if (lpOptions->ReplaceOption == WAB_REPLACE_NEVER) {
            hResult = S_OK;
            goto Error;
        }

        if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
            RI.lpszEmailAddress = NULL;
            if (NETSCAPE == type) {
                if (lpNsAdrBook->Entry) {
                    RI.lpszDisplayName = lpNsAdrBook->Entry;
                    RI.lpszEmailAddress = lpNsAdrBook->Address;
                } else if (lpNsAdrBook->NickName) {
                    RI.lpszDisplayName = lpNsAdrBook->NickName;
                    RI.lpszEmailAddress = lpNsAdrBook->Address;
                } else if (lpNsAdrBook->Address) {
                    RI.lpszDisplayName = lpNsAdrBook->Address;
                } else if (lpNsAdrBook->Description) {
                    RI.lpszDisplayName = lpNsAdrBook->Description;
                } else {
                    RI.lpszDisplayName = "";
                }
            } else {
                RI.lpszDisplayName = lpEudAdrBook[ul].NickName;
                RI.lpszEmailAddress = lpEudAdrBook[ul].Address;
            }
            RI.ConfirmResult = CONFIRM_ERROR;
            RI.lpImportOptions = lpOptions;

            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_ImportReplace), hwnd,
              ReplaceDialogProc, (LPARAM)&RI);

            switch (RI.ConfirmResult) {
                case CONFIRM_YES:
                case CONFIRM_YES_TO_ALL:
                    lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                    lpMailUserWAB = NULL;
                    ulCreateFlags |= CREATE_REPLACE;
                    goto retry;
                    break;

                case CONFIRM_ABORT:
                    hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                    goto Error;

                case CONFIRM_NO:
                    if (NETSCAPE == type) {
                        if (lpNsAdrBook->Sbinary == TRUE)
                            GetExistEntry(lpWabContainer,
                              lpsbinary,
                              lpNsAdrBook->AliasID,
                              lpNsAdrBook->Entry,
                              lpNsAdrBook->NickName);
                    } else
                        hResult = GetExistEntry(lpWabContainer,lpsbinary,ul,
                          lpEudAdrBook[ul].NickName,
                          NULL);
                    goto Error;

                default:
                    break;
            }
        }
    }

    if (0 != (hResult = lpMailUserWAB->lpVtbl->GetProps(lpMailUserWAB,
      (LPSPropTagArray)&ptaEid,
      0,
      &cProps,
      (LPSPropValue *)&lpNewDLProps))) {
        if (hResult == MAPI_W_ERRORS_RETURNED) {
            WABFreeBuffer(lpNewDLProps);
            lpNewDLProps = NULL;
        }
        goto Error;
    }

    if (NETSCAPE == type) {
        if (lpNsAdrBook->Sbinary == TRUE) {
            lpsbinary[lpNsAdrBook->AliasID].lpb=(LPBYTE)LocalAlloc(LMEM_FIXED,lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
            if (!lpsbinary[lpNsAdrBook->AliasID].lpb) {
                hResult = hrMemory;
                goto Error;
            }
            CopyMemory(lpsbinary[lpNsAdrBook->AliasID].lpb,
                       (LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
            lpsbinary[lpNsAdrBook->AliasID].cb=lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb;
        }
    } else {
        lpsbinary[ul].lpb=(LPBYTE)LocalAlloc(LMEM_FIXED,lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
        if (!lpsbinary[ul].lpb) {
            hResult = hrMemory;
            goto Error;
        }
        CopyMemory(lpsbinary[ul].lpb,(LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
        lpsbinary[ul].cb=lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb;
    }


Error:

    if (lpNewDLProps) {
        WABFreeBuffer(lpNewDLProps);
        lpNewDLProps = NULL;
    }

    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
        lpMailUserWAB = NULL;
    }

    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:ComDlg32DlgProc
 *
 *  PURPOSE:    Change the title of open button to Import.
 *
 *  PARAMETERS:
 *
 *  RETURNS:    BOOL
 ******************************************************************************/
INT_PTR CALLBACK ComDlg32DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
        case WM_INITDIALOG:
            {
                TCHAR szBuffer[MAX_RESOURCE_STRING + 1];

                if (LoadString(hInst, IDS_IMPORT_BUTTON, szBuffer, sizeof(szBuffer))) {
                    SetDlgItemText(GetParent(hDlg), 1, szBuffer);
                }
                break;
            }

        default:
            return(FALSE);
    }
    return(TRUE);
}


const static char c_szReg[] = "Reg";
const static char c_szUnReg[] = "UnReg";
const static char c_szAdvPackDll[] = "ADVPACK.DLL";

static char c_szWABIMP[] = "WABIMP";

HRESULT CallRegInstall(LPCSTR szSection)
{
    HRESULT     hr;
    HINSTANCE   hAdvPack;
    REGINSTALL  pfnri;
    char        szWabimpDll[MAX_PATH];
    STRENTRY    seReg;
    STRTABLE    stReg;

    hr = E_FAIL;

    hAdvPack = LoadLibraryA(c_szAdvPackDll);
    if (hAdvPack != NULL) {
        // Get Proc Address for registration util
        pfnri = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
        if (pfnri != NULL) {

            GetModuleFileName(hInstApp, szWabimpDll, sizeof(szWabimpDll));
            seReg.pszName = c_szWABIMP;
            seReg.pszValue = szWabimpDll;
            stReg.cEntries = 1;
            stReg.pse = &seReg;

            // Call the self-reg routine
            hr = pfnri(hInstApp, szSection, &stReg);
        }

        FreeLibrary(hAdvPack);
    }

    return(hr);
}


STDAPI DllRegisterServer(void)
{
    return(CallRegInstall(c_szReg));
}


STDAPI DllUnregisterServer(void)
{
    return(CallRegInstall(c_szUnReg));
}


/***************************************************************************

    Name      : ShowMessageBoxParam

    Purpose   : Generic MessageBox displayer

    Parameters: hWndParent - Handle of message box parent
                MsgID      - resource id of message string
                ulFlags    - MessageBox flags
                ...        - format parameters

    Returns   : MessageBox return code

***************************************************************************/
int __cdecl ShowMessageBoxParam(HWND hWndParent, int MsgId, int ulFlags, ...)
{
    TCHAR szBuf[MAX_RESOURCE_STRING + 1] = "";
    TCHAR szCaption[MAX_PATH] = "";
    LPTSTR lpszBuffer = NULL;
    int iRet = 0;
    va_list     vl;

    va_start(vl, ulFlags);

    LoadString(hInst, MsgId, szBuf, sizeof(szBuf));
    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
      szBuf,
      0,0,              // ignored
      (LPTSTR)&lpszBuffer,
      sizeof(szBuf),      // MAX_UI_STR
      (va_list *)&vl)) {
        TCHAR szCaption[MAX_PATH];

        GetWindowText(hWndParent, szCaption, sizeof(szCaption));
        if (! lstrlen(szCaption)) { // if no caption get the parents caption - this is necessary for property sheets
            GetWindowText(GetParent(hWndParent), szCaption, sizeof(szCaption));
            if (! lstrlen(szCaption)) //if still not caption, use empty title
                szCaption[0] = (TCHAR)'\0';
        }
        iRet = MessageBox(hWndParent, lpszBuffer, szCaption, ulFlags);
        LocalFree(lpszBuffer);
    }
    va_end(vl);
    return(iRet);
}


//$$//////////////////////////////////////////////////////////////////////
//
//  LoadAllocString - Loads a string resource and allocates enough
//                    memory to hold it.
//
//  StringID - String identifier to load
//
//  returns the LocalAlloc'd, null terminated string.  Caller is responsible
//  for LocalFree'ing this buffer.  If the string can't be loaded or memory
//  can't be allocated, returns NULL.
//
//////////////////////////////////////////////////////////////////////////
LPTSTR LoadAllocString(int StringID) {
    ULONG ulSize = 0;
    LPTSTR lpBuffer = NULL;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];

    ulSize = LoadString(hInst, StringID, szBuffer, sizeof(szBuffer));

    if (ulSize && (lpBuffer = LocalAlloc(LPTR, ulSize + 1))) {
        lstrcpy(lpBuffer, szBuffer);
    }

    return(lpBuffer);
}


/***************************************************************************

    Name      : FormatAllocFilter

    Purpose   : Loads file filter name string resources and
                formats them with their file extension filters

    Parameters: StringID1 - String identifier to load       (required)
                szFilter1 - file name filter, ie, "*.vcf"   (required)
                StringID2 - String identifier               (optional)
                szFilter2 - file name filter                (optional)
                StringID3 - String identifier               (optional)
                szFilter3 - file name filter                (optional)

    Returns   : LocalAlloc'd, Double null terminated string.  Caller is
                responsible for LocalFree'ing this buffer.  If the string
                can't be loaded or memory can't be allocated, returns NULL.

***************************************************************************/
LPTSTR FormatAllocFilter(int StringID1, LPCTSTR lpFilter1,
  int StringID2, LPCTSTR lpFilter2,
  int StringID3, LPCTSTR lpFilter3) {
    LPTSTR lpFileType1 = NULL, lpFileType2 = NULL, lpFileType3 = NULL;
    LPTSTR lpTemp;
    LPTSTR lpBuffer = NULL;
    // All string sizes include null
    ULONG cbFileType1 = 0, cbFileType2 = 0, cbFileType3 = 0;
    ULONG cbFilter1 = 0, cbFilter2 = 0, cbFilter3 = 0;
    ULONG cbBuffer;

    cbBuffer = cbFilter1 = lstrlen(lpFilter1) + 1;
    if (! (lpFileType1 = LoadAllocString(StringID1))) {
        DebugTrace("LoadAllocString(%u) failed\n", StringID1);
        return(NULL);
    }
    cbBuffer += (cbFileType1 = lstrlen(lpFileType1) + 1);
    if (lpFilter2 && StringID2) {
        cbBuffer += (cbFilter2 = lstrlen(lpFilter2) + 1);
        if (! (lpFileType2 = LoadAllocString(StringID2))) {
            DebugTrace("LoadAllocString(%u) failed\n", StringID2);
        } else {
            cbBuffer += (cbFileType2 = lstrlen(lpFileType2) + 1);
        }
    }
    if (lpFilter3 && StringID3) {
        cbBuffer += (cbFilter3 = lstrlen(lpFilter3) + 1);
        if (! (lpFileType3 = LoadAllocString(StringID3))) {
            DebugTrace("LoadAllocString(%u) failed\n", StringID3);
        } else {
            cbBuffer += (cbFileType3 = lstrlen(lpFileType3) + 1);
        }
    }
    cbBuffer++;

    Assert(cbBuffer == cbFilter1 + cbFilter2 + cbFilter3 + cbFileType1 + cbFileType2 + cbFileType3 + 1);

    if (lpBuffer = LocalAlloc(LPTR, cbBuffer)) {
        lpTemp = lpBuffer;
        lstrcpy(lpTemp, lpFileType1);
        lpTemp += cbFileType1;
        lstrcpy(lpTemp, lpFilter1);
        lpTemp += cbFilter1;
        LocalFree(lpFileType1);
        if (cbFileType2 && cbFilter2) {
            lstrcpy(lpTemp, lpFileType2);
            lpTemp += cbFileType2;
            lstrcpy(lpTemp, lpFilter2);
            lpTemp += cbFilter2;
            LocalFree(lpFileType2);
        }
        if (cbFileType3 && cbFilter3) {
            lstrcpy(lpTemp, lpFileType3);
            lpTemp += cbFileType3;
            lstrcpy(lpTemp, lpFilter3);
            lpTemp += cbFilter3;
            LocalFree(lpFileType3);
        }

        *lpTemp = '\0';
    }


    return(lpBuffer);
}


/***************************************************************************

    Name      : SaveFileDialog

    Purpose   : Presents a Save filename dialog

    Parameters: hWnd = parent window handle
                szFileName = in/out filename buffer (must be MAX_PATH + 1)
                lpFilter1 = First filename filter string
                idsFileType1 = First filename type string id
                lpFilter2 = Second filename filter string (or NULL)
                idsFileType2 = Second filename type string id
                lpFilter3 = Third filename filter string (or NULL)
                idsFileType3 = Third filename type string id
                lpDefExt = default extension string
                ulFlags = GetSaveFileName flags
                hInst = instance handle
                idsTitle = dialog title string id
                idsSaveButton = Save button string id (0 = default)

    Returns   : HRESULT

***************************************************************************/
HRESULT SaveFileDialog(HWND hWnd,
  LPTSTR szFileName,
  LPCTSTR lpFilter1,
  ULONG idsFileType1,
  LPCTSTR lpFilter2,
  ULONG idsFileType2,
  LPCTSTR lpFilter3,
  ULONG idsFileType3,
  LPCTSTR lpDefExt,
  ULONG ulFlags,
  HINSTANCE hInst,
  ULONG idsTitle,
  ULONG idsSaveButton) {
    LPTSTR lpFilterName;
    OPENFILENAME ofn;
    HRESULT hResult = hrSuccess;


    if (! (lpFilterName = FormatAllocFilter(idsFileType1, lpFilter1,
        idsFileType2, lpFilter2, idsFileType3, lpFilter3))) {
        return(ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY));
    }

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = hInst;
    ofn.lpstrFilter = lpFilterName;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = NULL;              // lpTitle;
    ofn.Flags = ulFlags;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = lpDefExt;
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    if (! GetSaveFileName(&ofn)) {
        DebugTrace("GetSaveFileName cancelled\n");
        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
    }

    if(lpFilterName)
        LocalFree(lpFilterName);

    return(hResult);
}


/***************************************************************************

    Name      : OpenFileDialog

    Purpose   : Presents a open filename dialog

    Parameters: hWnd = parent window handle
                szFileName = in/out filename buffer (must be MAX_PATH + 1)
                lpFilter1 = First filename filter string
                idsFileType1 = First filename type string id
                lpFilter2 = Second filename filter string (or NULL)
                idsFileType2 = Second filename type string id
                lpFilter3 = Third filename filter string (or NULL)
                idsFileType3 = Third filename type string id
                lpDefExt = default extension string
                ulFlags = GetOpenFileName flags
                hInst = instance handle
                idsTitle = dialog title string id
                idsSaveButton = Save button string id (0 = default)

    Returns   : HRESULT

***************************************************************************/
HRESULT OpenFileDialog(HWND hWnd,
  LPTSTR szFileName,
  LPCTSTR lpFilter1,
  ULONG idsFileType1,
  LPCTSTR lpFilter2,
  ULONG idsFileType2,
  LPCTSTR lpFilter3,
  ULONG idsFileType3,
  LPCTSTR lpDefExt,
  ULONG ulFlags,
  HINSTANCE hInst,
  ULONG idsTitle,
  ULONG idsOpenButton) {
    LPTSTR lpFilterName;
    OPENFILENAME ofn;
    HRESULT hResult = hrSuccess;


    if (! (lpFilterName = FormatAllocFilter(idsFileType1, lpFilter1,
        idsFileType2, lpFilter2, idsFileType3, lpFilter3))) {
        return(ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY));
    }

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = hInst;
    ofn.lpstrFilter = lpFilterName;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = NULL;              // lpTitle;
    ofn.Flags = ulFlags;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = lpDefExt;
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    if (! GetOpenFileName(&ofn)) {
        DebugTrace("GetOpenFileName cancelled\n");
        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
    }

    if(lpFilterName)
        LocalFree(lpFilterName);

    return(hResult);
}



/***************************************************************************

    Name      : CountRows

    Purpose   : Count the rows in a table (restriction aware)

    Parameters: lpTable = table object
                fMAPI = TRUE if MAPI table, FALSE if WAB table

    Returns   : returns number of rows in the restricted table

    Comment   : Leaves the table pointer at the beginning.
                I'd use GetRowCount, but it is not aware of restrictions.

***************************************************************************/
#define COUNT_BATCH 50
ULONG CountRows(LPMAPITABLE lpTable, BOOL fMAPI) {
    ULONG cRows;
    ULONG cTotal = 0;
    HRESULT hResult;
    LPSRowSet lpRow = NULL;

#ifdef DEBUG
    DWORD dwTickCount = GetTickCount();
    DebugTrace(">>>>> Counting Table Rows...\n");
#endif // DEBUG

    cRows = 1;
    while (cRows) {
        if (hResult = lpTable->lpVtbl->QueryRows(lpTable,
          COUNT_BATCH,          // 50 row's at a time
          0,                    // ulFlags
          &lpRow)) {
            DebugTrace("CountRows:QueryRows -> %x\n", GetScode(hResult));
            break;
        }

        if (lpRow) {
            if (cRows = lpRow->cRows) { // yes, single '='
                cTotal += cRows;
            } // else, drop out of loop, we're done.
            if (fMAPI) {
                FreeProws(lpRow);
            } else {
                WABFreeProws(lpRow);
            }
            lpRow = NULL;
        } else {
            cRows = 0;      // done
        }
    }

    if (HR_FAILED(hResult = lpTable->lpVtbl->SeekRow(lpTable,
                                                     BOOKMARK_BEGINNING,
                                                     0,
                                                     NULL))) {
        DebugTrace("CountRows:SeekRow -> %x\n", GetScode(hResult));
    }

#ifdef DEBUG
    DebugTrace(">>>>> Done Counting Table Rows... %u milliseconds\n", GetTickCount() - dwTickCount);
#endif
    return(cTotal);
}


/***************************************************************************

    Name      : WABFreePadrlist

    Purpose   : Free an adrlist and it's property arrays

    Parameters: lpBuffer = buffer to free

    Returns   : SCODE

    Comment   :

***************************************************************************/
void WABFreePadrlist(LPADRLIST lpAdrList) {
    ULONG           iEntry;

    if (lpAdrList) {
        for (iEntry = 0; iEntry < lpAdrList->cEntries; ++iEntry) {
            if (lpAdrList->aEntries[iEntry].rgPropVals) {
                WABFreeBuffer(lpAdrList->aEntries[iEntry].rgPropVals);
            }
        }
        WABFreeBuffer(lpAdrList);
    }
}


/***************************************************************************

    Name      : WABFreeProws

    Purpose   : Destroys an SRowSet structure.

    Parameters: prows -> SRowSet to free

    Returns   : none

    Comment   :

***************************************************************************/
void WABFreeProws(LPSRowSet prows) {
    register ULONG irow;

    if (! prows) {
        return;
    }

    for (irow = 0; irow < prows->cRows; ++irow) {
        WABFreeBuffer(prows->aRow[irow].lpProps);
    }
    WABFreeBuffer(prows);
}


/***************************************************************************

    Name      : FindAdrEntryID

    Purpose   : Find the PR_ENTRYID in the Nth ADRENTRY of an ADRLIST

    Parameters: lpAdrList -> AdrList
                index = which ADRENTRY to look at

    Returns   : return pointer to the SBinary structure of the ENTRYID value

    Comment   :

***************************************************************************/
LPSBinary FindAdrEntryID(LPADRLIST lpAdrList, ULONG index) {
    LPADRENTRY lpAdrEntry;
    ULONG i;

    if (lpAdrList && index < lpAdrList->cEntries) {

        lpAdrEntry = &(lpAdrList->aEntries[index]);

        for (i = 0; i < lpAdrEntry->cValues; i++) {
            if (lpAdrEntry->rgPropVals[i].ulPropTag == PR_ENTRYID) {
                return((LPSBinary)&lpAdrEntry->rgPropVals[i].Value);
            }
        }
    }
    return(NULL);
}


/***************************************************************************

    Name      : FindProperty

    Purpose   : Finds a property in a proparray

    Parameters: cProps = number of props in the array
                lpProps = proparray
                ulPropTag = property tag to look for

    Returns   : array index of property or NOT_FOUND

    Comment   :

***************************************************************************/
ULONG FindProperty(ULONG cProps, LPSPropValue lpProps, ULONG ulPropTag) {
    register ULONG i;

    for (i = 0; i < cProps; i++) {
        if (lpProps[i].ulPropTag == ulPropTag) {
            return(i);
        }
    }

    return(NOT_FOUND);
}


/***************************************************************************

    Name      : FindStringInProps

    Purpose   : Find the string property in the property value array

    Parameters: lpspv -> property value array
                ulcProps = size of array
                ulPropTag

    Returns   : return pointer to the string pointer in the array.  If
                the property doesn't exist or has error value, return NULL.

    Comment   :

***************************************************************************/
LPTSTR FindStringInProps(LPSPropValue lpspv, ULONG ulcProps, ULONG ulPropTag) {
    ULONG i;

    if (lpspv) {
        for (i = 0; i < ulcProps; i++) {
            if (lpspv[i].ulPropTag == ulPropTag) {
                return(lpspv[i].Value.LPSZ);
            }
        }
    }
    return(NULL);
}


/***************************************************************************

    Name      : PropStringOrNULL

    Purpose   : Returns the value of a property or NULL if it is an error

    Parameters: lpspv -> property value to check and return

    Returns   : pointer to value string or NULL

***************************************************************************/
LPTSTR PropStringOrNULL(LPSPropValue lpspv) {
    return(PROP_ERROR((*lpspv)) ? NULL : lpspv->Value.LPSZ);
}


/***************************************************************************

    Name      : FreeSeenList

    Purpose   : Frees the SeenList

    Parameters: none

    Returns   : none

    Comment   :

***************************************************************************/
void FreeSeenList(void) {
    ULONG i;

    Assert((lpEntriesSeen && ulEntriesSeen) || (! lpEntriesSeen && ! ulEntriesSeen));

    for (i = 0; i < ulEntriesSeen; i++) {
        if (lpEntriesSeen[i].sbinPAB.lpb) {
            LocalFree(lpEntriesSeen[i].sbinPAB.lpb);
        }
        if (lpEntriesSeen[i].sbinWAB.lpb) {
            LocalFree(lpEntriesSeen[i].sbinWAB.lpb);
        }
    }

    if (lpEntriesSeen) {
        LocalFree(lpEntriesSeen);
    }
    lpEntriesSeen = NULL;
    ulEntriesSeen = 0;
    ulMaxEntries = 0;
}


/***************************************************************************

    Name      : GetEMSSMTPAddress

    Purpose   : Get the Exchange SMTP address for this object

    Parameters: lpObject -> Object

    Returns   : lpSMTP -> returned buffer containing SMTP address (must be MAPIFree'd
                    by caller.)
                lpBase = base allocation to alloc more onto

    Comment   : What a mess!  EMS changed their name id's and guids between 4.0 and 4.5.
                They also added a fixed ID property containing just the SMTP address in 4.5.

***************************************************************************/
const GUID guidEMS_AB_40 = {   // GUID for EMS 4.0 addresses
    0x48862a09,
    0xf786,
    0x0114,
    {0x02, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
};
const GUID guidEMS_AB_45 = {   // GUID for EMS 4.5 addresses
    0x48862a08,
    0xf786,
    0x0114,
    {0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
};
#define ID_EMS_AB_PROXY_ADDRESSES_40   0x10052
#define ID_EMS_AB_PROXY_ADDRESSES_45   0x25281
// New MAPI property, found on EX 4.5 and later
#define PR_PRIMARY_SMTP_ADDRESS        PROP_TAG(PT_TSTRING, 0x39FE)

LPTSTR GetEMSSMTPAddress(LPMAPIPROP lpObject, LPVOID lpBase) {
    ULONG ulPropTag40 = 0, ulPropTag45 = 0;
    MAPINAMEID mnidT[2];
    LPMAPINAMEID lpmnid = (LPMAPINAMEID)&mnidT;
    LPSPropTagArray lptaga = NULL;
    HRESULT hResult;
    LPTSTR lpSMTP = NULL, lpAddr;
    LPSPropValue lpspv = NULL;
    ULONG i, i40 = 0, i45 = 0;
    SLPSTRArray MVString;
    SizedSPropTagArray(3, spta);
    ULONG cValues;
    SCODE sc;


#ifdef TEST_STUFF
    MAPIDebugNamedProps(lpObject, "Exchange Address");
#endif

    mnidT[0].lpguid = (LPGUID)&guidEMS_AB_40;
    mnidT[0].ulKind = MNID_ID;
    mnidT[0].Kind.lID = ID_EMS_AB_PROXY_ADDRESSES_40;


    if (HR_FAILED(hResult = lpObject->lpVtbl->GetIDsFromNames(lpObject,
      1,            // Just one name
      &lpmnid,      // &-of because this is an array
      0,            // This is where MAPI_CREATE might go
      &lptaga))) {
        DebugTrace("GetEMSNamedPropTag:GetIDsFromNames -> %x", GetScode(hResult));
    }

    if (lptaga) {
        if (lptaga->cValues >= 1 && (PROP_TYPE(lptaga->aulPropTag[0]) != PT_ERROR)) {
            ulPropTag40 = lptaga->aulPropTag[0];
        }
        MAPIFreeBuffer(lptaga);
    }

    // Yes, I should be doing them both at once, but the PAB fails if you call
    // GetIDsFromNames with ulCount > 1!
    mnidT[0].lpguid = (LPGUID)&guidEMS_AB_45;
    mnidT[0].ulKind = MNID_ID;
    mnidT[0].Kind.lID = ID_EMS_AB_PROXY_ADDRESSES_45;

    if (HR_FAILED(hResult = lpObject->lpVtbl->GetIDsFromNames(lpObject,
      1,            // Just one name
      &lpmnid,      // &-of because this is an array
      0,            // This is where MAPI_CREATE might go
      &lptaga))) {
        DebugTrace("GetEMSNamedPropTag:GetIDsFromNames -> %x", GetScode(hResult));
    }

    if (lptaga) {
        if (lptaga->cValues >= 1 && (PROP_TYPE(lptaga->aulPropTag[0]) != PT_ERROR)) {
            ulPropTag45 = lptaga->aulPropTag[0];
        }
        MAPIFreeBuffer(lptaga);
    }


    spta.aulPropTag[0] = PR_PRIMARY_SMTP_ADDRESS;
    i = 1;
    if (ulPropTag40) {
        i40 = i++;
        spta.aulPropTag[i40] = CHANGE_PROP_TYPE(ulPropTag40, PT_MV_TSTRING);
    }
    if (ulPropTag45) {
        i45 = i++;
        spta.aulPropTag[i45] = CHANGE_PROP_TYPE(ulPropTag45, PT_MV_TSTRING);
    }
    spta.cValues = i;

    // Now, get the props from the object
    if (! HR_FAILED(hResult = lpObject->lpVtbl->GetProps(lpObject,
      (LPSPropTagArray)&spta, 0, &cValues, &lpspv))) {
        // Found one or more of the properties.  Look up the SMTP address.

        if (! PROP_ERROR(lpspv[0])) {
            if (sc = MAPIAllocateMore(lstrlen(lpspv[0].Value.LPSZ) + 1, lpBase, &lpSMTP)) {
                DebugTrace("GetEMSSMTPAddress:MAPIAllocateMore -> %x\n", sc);
                hResult = ResultFromScode(sc);
                goto done;
            }
            lstrcpy(lpSMTP, lpspv[0].Value.LPSZ);
            goto done;
        } else if (i40 && ! PROP_ERROR(lpspv[i40])) {    // 4.0 version
            MVString = lpspv[i40].Value.MVSZ;
        } else if (i45 && ! PROP_ERROR(lpspv[i45])) {    // 4.5 version
            MVString = lpspv[i45].Value.MVSZ;
        } else {
            goto done;
        }

        for (i = 0; i < MVString.cValues; i++) {
            lpAddr = MVString.LPPSZ[i];
            if ((lpAddr[0] == 'S') &&
                (lpAddr[1] == 'M') &&
                (lpAddr[2] == 'T') &&
                (lpAddr[3] == 'P') &&
                (lpAddr[4] == ':')) {
                // This is IT!
                lpAddr += 5;    // point to the string

                // Allocate string
                if (FAILED(sc = MAPIAllocateMore(lstrlen(lpAddr) + 1, lpBase, (&lpSMTP)))) {
                    DebugTrace("GetEMSSMTPAddress:MAPIAllocateMore -> %x\n", sc);
                    hResult = ResultFromScode(sc);
                    goto done;
                }

                lstrcpy(lpSMTP, lpAddr);
                break;
            }
        }
done:
        if (lpspv) {
            MAPIFreeBuffer(lpspv);
        }
    }
    return(lpSMTP);
}


/***************************************************************************

    Name      : LoadWABEIDs

    Purpose   : Load the WAB's PAB create EIDs

    Parameters: lpAdrBook -> lpAdrBook object
                lppContainer -> returned PAB container, caller must Release

    Returns   : HRESULT

    Comment   : Allocates global lpCreateEIDsWAB.  Caller should WABFreeBuffer.

***************************************************************************/
HRESULT LoadWABEIDs(LPADRBOOK lpAdrBook, LPABCONT * lppContainer) {
    LPENTRYID lpWABEID = NULL;
    ULONG cbWABEID;
    HRESULT hResult;
    ULONG ulObjType;
    ULONG cProps;

    if (hResult = lpAdrBook->lpVtbl->GetPAB(lpAdrBook,
      &cbWABEID,
      &lpWABEID)) {
        DebugTrace("WAB GetPAB -> %x\n", GetScode(hResult));
        goto exit;
    } else {
        if (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
          cbWABEID,     // size of EntryID to open
          lpWABEID,     // EntryID to open
          NULL,         // interface
          0,            // flags
          &ulObjType,
          (LPUNKNOWN *)lppContainer)) {
            DebugTrace("WAB OpenEntry(PAB) -> %x\n", GetScode(hResult));
            goto exit;
        }
    }

    // Get the WAB's creation entryids
    if ((hResult = (*lppContainer)->lpVtbl->GetProps(*lppContainer,
      (LPSPropTagArray)&ptaCon,
      0,
      &cProps,
      &lpCreateEIDsWAB))) {
        DebugTrace("Can't get container properties for WAB\n");
        // Bad stuff here!
        goto exit;
    }

    // Validate the properites
    if (lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
      lpCreateEIDsWAB[iconPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL) {
        DebugTrace("WAB: Container property errors\n");
        goto exit;
    }

exit:
    if (hResult) {
        if (lpCreateEIDsWAB) {
            WABFreeBuffer(lpCreateEIDsWAB);
            lpCreateEIDsWAB = NULL;
        }
    }
    if (lpWABEID) {
        WABFreeBuffer(lpWABEID);  // bad object?
    }
    return(hResult);
}

/////////////////////////////////////////////////////////////////////////
// GetWABDllPath - loads the WAB DLL path from the registry
// szPath	- ptr to buffer
// cb		- sizeof buffer
//
void GetWABDllPath(LPTSTR szPath, ULONG cb)
{
    DWORD  dwType = 0;
    HKEY hKey = NULL;
    TCHAR szPathT[MAX_PATH];
    ULONG  cbData = sizeof(szPathT);
    if(szPath)
    {
        *szPath = '\0';
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
        {
            if(ERROR_SUCCESS == RegQueryValueEx( hKey, "", NULL, &dwType, (LPBYTE) szPathT, &cbData))
            {
                if (dwType == REG_EXPAND_SZ)
                    cbData = ExpandEnvironmentStrings(szPathT, szPath, cb / sizeof(TCHAR));
                else
                {
                    if(GetFileAttributes(szPathT) != 0xFFFFFFFF)
                        lstrcpy(szPath, szPathT);
                }
            }
        }
    }
    if(hKey) RegCloseKey(hKey);
	return;
}

typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCTSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);

static const TCHAR c_szShlwapiDll[] = TEXT("shlwapi.dll");
static const char c_szDllGetVersion[] = "DllGetVersion";
static const TCHAR c_szWABResourceDLL[] = TEXT("wab32res.dll");
static const TCHAR c_szWABDLL[] = TEXT("wab32.dll");

HINSTANCE LoadWABResourceDLL(HINSTANCE hInstWAB32)
{
    TCHAR szPath[MAX_PATH];
    HINSTANCE hinstShlwapi;
    PFNMLLOADLIBARY pfn;
    DLLGETVERSIONPROC pfnVersion;
    int iEnd;
    DLLVERSIONINFO info;
    HINSTANCE hInst = NULL;

    hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    if (hinstShlwapi != NULL)
    {
        pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion != NULL)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                {
#ifdef UNICODE
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)378);
#else
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)377);
#endif // UNICODE
                    if (pfn != NULL)
                        hInst = pfn(c_szWABResourceDLL, hInstWAB32, 0);
                }
            }
        }

        FreeLibrary(hinstShlwapi);        
    }

    if (NULL == hInst)
    {
        GetWABDllPath(szPath, sizeof(szPath));
        iEnd = lstrlen(szPath);
        if (iEnd > 0)
        {
            iEnd = iEnd - lstrlen(c_szWABDLL);
            lstrcpyn(&szPath[iEnd], c_szWABResourceDLL, sizeof(szPath)/sizeof(TCHAR)-iEnd);
            hInst = LoadLibrary(szPath);
        }
    }

    AssertSz(hInst, TEXT("Failed to LoadLibrary Lang Dll"));

    return(hInst);
}

/*
 *  DLL entry point for Win32
 */
BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved) {

    switch ((short)dwReason) {

        case DLL_PROCESS_ATTACH:
            hInstApp = hInstance;  // set global DLL instance
            hInst = LoadWABResourceDLL(hInstApp);

            //  We don't need these, so tell the OS to stop 'em
            DisableThreadLibraryCalls(hInstApp);
            break;

        case DLL_PROCESS_DETACH:
            if( hInst )
                FreeLibrary(hInst);
            hInst = NULL;

            break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\cldbg.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Normandy client debug defines
//
//	History:
//		davidsan	05/01/96	Created
//
//--------------------------------------------------------------------------------------------

#ifndef _CLDBG_H
#define _CLDBG_H

#ifdef DEBUG

#define ASSERT_GLE 0x00000001

extern void AssertProc(LPCSTR szMsg, LPCSTR szFile, UINT iLine, DWORD grf);

#define Assert(f) (void)((f) || (AssertProc(#f, __FILE__, __LINE__, 0), 0))
#define AssertGLE(f) (void)((f) || (AssertProc(#f, __FILE__, __LINE__, ASSERT_GLE), 0))
#define AssertSz(f,sz) (void)((f) || (AssertProc(sz, __FILE__, __LINE__, 0), 0))

#else

#define Assert(f)
#define AssertGLE(f)
#define AssertSz(f,sz)

#endif

#endif  // _CLDBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\lclilist.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client Xaction List
//
//
//	History
//		davidsan	04-26-96	Created
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// INCLUDES
//
//--------------------------------------------------------------------------------------------
#include "ldappch.h"
#include "lclilist.h"
#include "lclixd.h"

//--------------------------------------------------------------------------------------------
//
// PROTOTYPES
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// GLOBALS
//
//--------------------------------------------------------------------------------------------
XID g_xid = 1;

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// CLASSES
//
//--------------------------------------------------------------------------------------------

CXactionList::CXactionList()
{
	::InitializeCriticalSection(&m_cs);
	m_pxdHead = NULL;
}

CXactionList::~CXactionList()
{
	this->DeletePxdChain(m_pxdHead);
	::DeleteCriticalSection(&m_cs);
}

PXD
CXactionList::PxdNewXaction(DWORD xtype)
{
	PXD pxd;
	XID xid;
	
	pxd = new XD;
	if (!pxd)
		return NULL;

	::EnterCriticalSection(&m_cs);
	xid = g_xid++;
	::LeaveCriticalSection(&m_cs);
	
	if (!pxd->FInit(xid, xtype))
		{
		delete pxd;
		return NULL;
		}
	
	this->AddPxdToList(pxd);
	return pxd;
}

PXD
CXactionList::PxdForXid(XID xid)
{
	PXD pxd;
	
	::EnterCriticalSection(&m_cs);
	pxd = m_pxdHead;
	while (pxd)
		{
		if (pxd->Xid() == xid)
			break;
			
		pxd = pxd->PxdNext();
		}
	::LeaveCriticalSection(&m_cs);
	return pxd;
}

// destroys pxd
void
CXactionList::RemovePxd(PXD pxd)
{
	PXD pxdT;

	::EnterCriticalSection(&m_cs);
	
	if (pxd == m_pxdHead)
		m_pxdHead = pxd->PxdNext();
	else
		{
		pxdT = m_pxdHead;
		while (pxdT->PxdNext())
			{
			if (pxdT->PxdNext() == pxd)
				{
				pxdT->SetPxdNext(pxd->PxdNext());
				break;
				}
			pxdT = pxdT->PxdNext();
			}
		}
	::LeaveCriticalSection(&m_cs);
	delete pxd;
}

void
CXactionList::AddPxdToList(PXD pxd)
{
	Assert(!pxd->PxdNext());

	::EnterCriticalSection(&m_cs);
	pxd->SetPxdNext(m_pxdHead);
	m_pxdHead = pxd;
	::LeaveCriticalSection(&m_cs);
}

void
CXactionList::DeletePxdChain(PXD pxd)
{
	PXD pxdT;
	
	while (pxd)
		{
		pxdT = pxd->PxdNext();
		delete pxd;
		pxd = pxdT;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\at.cpp ===
/*--------------------------------------------------------------------------
	at.cpp
	
		ldap add/modify/etc test

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

	Authors:
		davidsan	Dave Sanderman

	History:
		04/25/96	davidsan	Created.
  --------------------------------------------------------------------------*/

#include "at.h"

PLCLI g_plcli = NULL;

BOOL
FInit()
{
	return TRUE;
}

BOOL
FConnect(char *szServer)
{
	HRESULT hr;
	XID xid;
	
	hr = HrCreateLdapClient(LDAP_VER_CURRENT, INTERFACE_VER_CURRENT, &g_plcli);
	if (FAILED(hr))
		{
		printf("HrCreateLdapClient returned %08X\n", hr);
		return FALSE;
		}
	hr = g_plcli->HrConnect(szServer);
	if (FAILED(hr))
		{
		printf("HrConnect returned %08X\n", hr);
		return FALSE;
		}

	//$ figure out bind name
	hr = g_plcli->HrBindSimple("cn=davidsan2@microsoft.com, c=us", NULL, &xid);
	if (FAILED(hr))
		{
		printf("HrBindSimple returned %08X\n", hr);
		return FALSE;
		}
	hr = g_plcli->HrGetBindResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrBindSimple returned %08X\n", hr);
		return FALSE;
		}
	return TRUE;	
}

char *g_rgszAttrib[] = {"title", "cn", "sn", "objectClass"};

BOOL
FSearch()
{
	HRESULT hr;
	XID xid;
	POBJ pobj;
	POBJ pobjT;
	PATTR pattr;
	PVAL pval;
	SP sp;
	FILTER filter;
	FILTER filterS1;
	FILTER filterS2;
	FILTER filterSS1;
	FILTER filterSS2;
	FILTER filterSS3;

#ifdef OLDSEARCH	
	filter.type = LDAP_FILTER_AND;
	filter.pfilterSub = &filterS1;

		filterS1.type = LDAP_FILTER_OR;
		filterS1.pfilterSub = &filterSS1;
		filterS1.pfilterNext = &filterS2;
	
			filterSS1.type = LDAP_FILTER_EQUALITY;
			filterSS1.ava.szAttrib = "cn";
			filterSS1.ava.szValue = "sander";
			filterSS1.pfilterNext = &filterSS2;

			filterSS2.type = LDAP_FILTER_EQUALITY;
			filterSS2.ava.szAttrib = "sn";
			filterSS2.ava.szValue = "sander";
			filterSS2.pfilterNext = &filterSS3;

			filterSS3.type = LDAP_FILTER_EQUALITY;
			filterSS3.ava.szAttrib = "uid";
			filterSS3.ava.szValue = "sander";
			filterSS3.pfilterNext = NULL;

		filterS2.type = LDAP_FILTER_EQUALITY;
		filterS2.ava.szAttrib = "objectClass";
		filterS2.ava.szValue = "Person";
		filterS2.pfilterNext = NULL;
	
#else
//	filter.type = LDAP_FILTER_SUBSTRINGS;
//	filter.sub.szAttrib = "cn";
//	filter.sub.szInitial = NULL;
//	filter.sub.szAny = "alex";
//	filter.sub.szFinal = NULL;

	filter.type = LDAP_FILTER_EQUALITY;
	filter.ava.szAttrib = "cn";
	filter.ava.szValue = "davidsan2";
#endif

	sp.szDNBase = "c=US";
	sp.scope = LDAP_SCOPE_WHOLESUBTREE;
	sp.deref = LDAP_DEREF_ALWAYS;
	sp.cRecordsMax = 0;
	sp.cSecondsMax = 0;
	sp.fAttrsOnly = FALSE;
	sp.pfilter = &filter;
	sp.cAttrib = 4;
	sp.rgszAttrib = g_rgszAttrib;
	hr = g_plcli->HrSearch(&sp, &xid);
	if (FAILED(hr))
		{
		printf("HrSearch returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetSearchResponse(xid, INFINITE, &pobj);
	if (FAILED(hr))
		{
		printf("HrGetSearchResponse returned %08X\n", hr);
		return FALSE;
		}
	pobjT = pobj;
	while (pobjT)
		{
		printf("OBJ: %s\n", pobjT->szDN);
		pattr = pobjT->pattrFirst;
		while (pattr)
			{
			printf("  ATTR: %s\n", pattr->szAttrib);
			pval = pattr->pvalFirst;
			while (pval)
				{
				printf("    VAL: %s\n", pval->szVal);
				pval = pval->pvalNext;
				}
			pattr = pattr->pattrNext;
			}
		pobjT = pobjT->pobjNext;
		}
	g_plcli->HrFreePobjList(pobj);
		
	return TRUE;
}

void
SetPattr(PATTR pattr, PATTR pattrNext, char *szAttrib, PVAL pval)
{
	pattr->pattrNext = pattrNext;
	pattr->szAttrib = szAttrib;
	pattr->pvalFirst = pval;
}

void
SetPval(PVAL pval, PVAL pvalNext, char *szVal)
{
	pval->pvalNext = pvalNext;
	pval->szVal = szVal;
}

BOOL
FTestOtherStuff()
{
	HRESULT hr;
	XID xid;

#ifdef TEST_MODIFY
	MOD mod;
	ATTR attr;
	VAL val;
	
	mod.pmodNext = NULL;
	mod.modop = LDAP_MODIFY_REPLACE;
	mod.pattrFirst = &attr;
	
	attr.pattrNext = NULL;
	attr.szAttrib = "URL";
	attr.pvalFirst = &val;
	
	val.pvalNext = NULL;
	val.szVal = "http://bite.me.com/";
	
	hr = g_plcli->HrModify("c=us, cn=davidsan2@microsoft.com", &mod, &xid);
	if (FAILED(hr))
		{
		printf("HrModify returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetModifyResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetModifyResponse returned %08X\n", hr);
		}
#endif // TEST_MODIFY

#define TEST_ADD
#ifdef TEST_ADD
	
	ATTR attr1;
	ATTR attr2;
	ATTR attr3;
	ATTR attr4;
	ATTR attr5;
	VAL val1;
	VAL val2;
	VAL val3;
	VAL val4;
	VAL val5;
	attr1.pattrNext = &attr2;
	attr1.szAttrib = "c";
	attr1.pvalFirst = &val1;

	attr2.pattrNext = &attr3;
	attr2.szAttrib = "sn";
	attr2.pvalFirst = &val2;

	attr3.pattrNext = &attr4;
	attr3.szAttrib = "givenName";
	attr3.pvalFirst = &val3;

	attr4.pattrNext = &attr5;
	attr4.szAttrib = "rfc822Mailbox";
	attr4.pvalFirst = &val4;

	attr5.pattrNext = NULL;
	attr5.szAttrib = "objectClass";
	attr5.pvalFirst = &val5;
		
	val1.pvalNext = NULL;
	val1.szVal = "us";
	
	val2.pvalNext = NULL;
	val2.szVal = "sanderman";
	
	val3.pvalNext = NULL;
	val3.szVal = "david";
	
	val4.pvalNext = NULL;
	val4.szVal = "davidsan3@microsoft.com";
	
	val5.pvalNext = NULL;
	val5.szVal = "Person";
	
	hr = g_plcli->HrAdd("c=us, cn=davidsan3@microsoft.com", &attr1, &xid);
	if (FAILED(hr))
		{
		printf("HrAdd returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetAddResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetAddResponse returned %08X\n", hr);
		}
#endif
	return TRUE;		
}

BOOL
FTerm()
{
	if (g_plcli)
		{
		g_plcli->HrUnbind();
		if (g_plcli->HrIsConnected() == NOERROR)
			g_plcli->HrDisconnect();
		g_plcli->Release();
		}
	return TRUE;
}

void
usage()
{
	printf("usage:	lt <server>\n");
	exit(1);
}

void __cdecl
main(int argc, char **argv)
{
	if (argc < 2)
		usage();

	if (!FInit())
		exit(1);

	if (!FConnect(argv[1]))
		exit(1);

	FSearch();
		
	FTestOtherStuff();

	FTerm();
	exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\cldbg.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Normandy client debug code
//
//	History:
//		davidsan	05/01/96	Created
//
//--------------------------------------------------------------------------------------------

#ifdef DEBUG

#include <windows.h>
#include <cldbg.h>

void
AssertProc(LPCSTR szMsg, LPCSTR szFile, UINT iLine, DWORD grf)
{
    char szAssert[MAX_PATH * 2];
	char *szFormatGLE = NULL;
	char szGLE[MAX_PATH];
	LONG lErr;
	DWORD dwRet;

	wsprintf(szAssert, "Assert failed: %s\n%s line %d.", szMsg, szFile, iLine);

	if (grf & ASSERT_GLE)
		{
		lErr = GetLastError();
		if (0 == FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER, 
							   NULL, lErr, 0, (PSTR) &szFormatGLE, 0, NULL))
			{
			wsprintf(szGLE, "\nLast error: %d", lErr);
			}
		else
			{
			wsprintf(szGLE, "\nLast error: '%s'", szFormatGLE);
			LocalFree((HLOCAL)szFormatGLE);
			}
		lstrcat(szAssert, szGLE);
		}
	dwRet = MessageBox(NULL, szAssert, "Assertion failure", MB_ABORTRETRYIGNORE);

	switch (dwRet)
		{
		case IDRETRY:
			DebugBreak();
			break;

		case IDIGNORE:
			break;

		case IDABORT:
			ExitProcess(0);
			break;
		}
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\lclityp.h ===
/*--------------------------------------------------------------------------
    lclityp.h
        
        Hungarian type definitions specific to the LDAP client.

		NOTE:  All the WP libraries and DLLs have a corresponding xxxxxTYP.H
		file that defines the hungarian abbreviations of the types/classes 
		defined in the LIB or DLL.  

    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        robertc     Rob Carney

    History:
        04-17-96    robertc     Created.
  --------------------------------------------------------------------------*/
#ifndef _LCLITYP_H
#define _LCLITYP_H

//
//  Simple types.
//
class		CLdapBer;
interface	ILdapClient;
class		CLdapWinsock;
class		CXactionList;
class		CXactionData;

typedef CLdapBer			LBER, *PLBER;
typedef ILdapClient			LCLI, *PLCLI;
typedef CLdapWinsock		SOCK, *PSOCK;
typedef CXactionList		XL,   *PXL;
typedef CXactionData		XD,   *PXD;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\lcli1823.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client RFC 1823 API
//
//
//	History
//		davidsan	06/17/96	Created
//
//--------------------------------------------------------------------------------------------

// note: this is ugly code.  all i'm doing is mapping things to my API in as painless a way
// as i can.

//--------------------------------------------------------------------------------------------
//
// INCLUDES
//
//--------------------------------------------------------------------------------------------
#include "ldappch.h"

//--------------------------------------------------------------------------------------------
//
// PROTOTYPES
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// GLOBALS
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS
//
//--------------------------------------------------------------------------------------------

int
LdapResFromHr(HRESULT hr)
{
	switch (hr)
		{
		default:
			return LDAP_LOCAL_ERROR;

		case NOERROR:
			return LDAP_SUCCESS;
			
		case LDAP_E_OPERATIONS:
			return LDAP_OPERATIONS_ERROR;
			
		case LDAP_E_PROTOCOL:
			return LDAP_PROTOCOL_ERROR;
			
		case LDAP_S_TIMEEXCEEDED:
			return LDAP_TIMELIMIT_EXCEEDED;
			
		case LDAP_S_SIZEEXCEEDED:
			return LDAP_SIZELIMIT_EXCEEDED;

		case S_FALSE:
			return LDAP_COMPARE_FALSE;

		case LDAP_E_AUTHMETHOD:
			return LDAP_AUTH_METHOD_NOT_SUPPORTED;
			
		case LDAP_E_STRONGAUTHREQUIRED:
			return LDAP_STRONG_AUTH_REQUIRED;
			
		case LDAP_E_NOSUCHATTRIBUTE:
			return LDAP_NO_SUCH_ATTRIBUTE;
			
		case LDAP_E_UNDEFINEDTYPE:
			return LDAP_UNDEFINED_TYPE;
		
		case LDAP_E_MATCHING:
			return LDAP_INAPPROPRIATE_MATCHING;
			
		case LDAP_E_CONSTRAINT:
			return LDAP_CONSTRAINT_VIOLATION;
			
		case LDAP_E_ATTRIBORVALEXISTS:
			return LDAP_ATTRIBUTE_OR_VALUE_EXISTS;
		
		case LDAP_E_SYNTAX:
			return LDAP_INVALID_SYNTAX;
		
		case LDAP_E_NOSUCHOBJECT:
			return LDAP_NO_SUCH_OBJECT;
		
		case LDAP_E_ALIAS:
			return LDAP_ALIAS_PROBLEM;
		
		case LDAP_E_DNSYNTAX:
			return LDAP_INVALID_DN_SYNTAX;

		case LDAP_E_ISLEAF:
			return LDAP_IS_LEAF;
			
		case LDAP_E_ALIASDEREF:
			return LDAP_ALIAS_DEREF_PROBLEM;
		
		case LDAP_E_AUTH:
			return LDAP_INAPPROPRIATE_AUTH;

		case LDAP_E_CREDENTIALS:
			return LDAP_INVALID_CREDENTIALS;
		
		case LDAP_E_RIGHTS:
			return LDAP_INSUFFICIENT_RIGHTS;
			
		case LDAP_E_BUSY:
			return LDAP_BUSY;
			
		case LDAP_E_UNAVAILABLE:
			return LDAP_UNAVAILABLE;
			
		case LDAP_E_UNWILLING:
			return LDAP_UNWILLING_TO_PERFORM;
			
		case LDAP_E_LOOP:
			return LDAP_LOOP_DETECT;
			
		case LDAP_E_NAMING:
			return LDAP_NAMING_VIOLATION;
			
		case LDAP_E_OBJECTCLASS:
			return LDAP_OBJECT_CLASS_VIOLATION;
			
		case LDAP_E_NOTALLOWEDONNONLEAF:
			return LDAP_NOT_ALLOWED_ON_NONLEAF;
			
		case LDAP_E_NOTALLOWEDONRDN:
			return LDAP_NOT_ALLOWED_ON_RDN;
			
		case LDAP_E_ALREADYEXISTS:
			return LDAP_ALREADY_EXISTS;
			
		case LDAP_E_NOOBJECTCLASSMODS:
			return LDAP_NO_OBJECT_CLASS_MODS;
			
		case LDAP_E_RESULTSTOOLARGE:
			return LDAP_RESULTS_TOO_LARGE;
		
		case LDAP_E_OTHER:
			return LDAP_OTHER;
		
		case LDAP_E_SERVERDOWN:
			return LDAP_SERVER_DOWN;
			
		case LDAP_E_LOCAL:
			return LDAP_LOCAL_ERROR;
			
		case LDAP_E_ENCODING:
			return LDAP_ENCODING_ERROR;
			
		case LDAP_E_DECODING:
			return LDAP_DECODING_ERROR;

		case LDAP_E_TIMEOUT:
			return LDAP_TIMEOUT;
			
		case LDAP_E_AUTHUNKNOWN:
			return LDAP_AUTH_UNKNOWN;
			
		case LDAP_E_FILTER:
			return LDAP_FILTER_ERROR;
			
		case LDAP_E_USERCANCELLED:
			return LDAP_USER_CANCELLED;

		case E_INVALIDARG:
			return LDAP_PARAM_ERROR;

		case E_OUTOFMEMORY:
			return LDAP_NO_MEMORY;
		}
}

DWORD
TimeoutFromTimeval(struct timeval *ptv)
{
	if (!ptv->tv_usec && !ptv->tv_sec)
		return INFINITE;
	return (ptv->tv_usec / 1000) + (ptv->tv_sec * 1000);
}

char *
SzMatchingParen(char *sz)
{
	int cLev = 0;

	if (sz[0] != '(')
		return NULL;
	
	while (*sz)
		{
		if (*sz == '(')
			cLev++;
		else if (*sz == ')')
			{
			cLev--;
			if (!cLev)
				return sz;
			}
		sz++;
		}
	return NULL;
}

char *
SzFT(char *sz, DWORD *ptype)
{
	while (*sz)
		{
		if (*sz == '=')
			{
			if (*(sz-1) == '~')
				{
				*ptype = LDAP_FILTER_APPROX;
				*(sz-1) = 0;
				return sz;
				}
			else if (*(sz - 1) == '<')
				{
				*ptype = LDAP_FILTER_LE;
				*(sz-1) = 0;
				return sz;
				}
			else if (*(sz - 1) == '<')
				{
				*ptype = LDAP_FILTER_GE;
				*(sz-1) = 0;
				return sz;
				}
			if (*(sz + 1) == '*')
				{
				*ptype = LDAP_FILTER_PRESENT;
				*sz = 0;
				return sz+1;
				}
			*ptype = 0;
			return sz;
			}
		sz++;
		}
	return NULL;
}

char *
SzStar(char *sz)
{
	while (*sz)
		{
		if (*sz == '*')
			return sz;
		sz++;
		}
	return NULL;
}

void
Unquote(char *sz)
{
	char *pchSrc = sz, *pchDest = sz;
	BOOL fQuoted = FALSE;
	
	while (*pchSrc)
		{
		if (fQuoted)
			{
			goto LCopy;
			}
		else
			{
			if (*pchSrc == '\\')
				fQuoted = TRUE;
			else
				{
LCopy:
				*pchDest++ = *pchSrc;
				fQuoted = FALSE;
				}
			}
		pchSrc++;
		}
}

void
FreePfilter(PFILTER pfilter)
{
	PFILTER pfilterNext;

	while (pfilter)
		{
		if (pfilter->type == LDAP_FILTER_AND ||
			pfilter->type == LDAP_FILTER_OR ||
			pfilter->type == LDAP_FILTER_NOT)
			FreePfilter(pfilter->pfilterSub);
		pfilterNext = pfilter->pfilterNext;
		
		delete pfilter;
		
		pfilter = pfilterNext;		
		}
}

PFILTER
PfilterFromString(char *sz)
{
	PFILTER pfilter = NULL;
	char *szMatchingParen;
	char *szSubMatchingParen;
	PFILTER pfilterSub = NULL;
	PFILTER pfilterPrev = NULL;
	char *szFT;
	char *szStar;
	char *szOldStar;
	
	if (sz[0] != '(')
		return NULL;
	szMatchingParen = SzMatchingParen(sz);
	if (!szMatchingParen)
		return NULL;
		
	pfilter = new FILTER;
	if (!pfilter)
		return NULL;
	FillMemory(pfilter, sizeof(FILTER), 0);
	
	switch (sz[1])
		{
		case '&':
		case '|':
			if (sz[1] == '&')
				pfilter->type = LDAP_FILTER_AND;
			else
				pfilter->type = LDAP_FILTER_OR;
				
			sz++;
			sz++;

			// sz now points to what should be first paren of first subfilter
			while (sz < szMatchingParen)
				{
				szSubMatchingParen = SzMatchingParen(sz);
				if (!szSubMatchingParen || szSubMatchingParen >= szMatchingParen)
					goto LFail;
				pfilterSub = PfilterFromString(sz);
				if (!pfilter->pfilterSub)
					pfilter->pfilterSub = pfilterSub;
				if (pfilterPrev)
					pfilterPrev->pfilterNext = pfilterSub;
				pfilterPrev = pfilterSub;
				sz = szSubMatchingParen + 1;
				}

			break;
			
		case '!':
			pfilter->type = LDAP_FILTER_NOT;
			sz++;
			sz++;
			szSubMatchingParen = SzMatchingParen(sz);
			if (!szSubMatchingParen || szSubMatchingParen >= szMatchingParen)
				goto LFail;
			pfilterSub = PfilterFromString(sz);
			pfilter->pfilterSub = pfilterSub;
			break;
			
		default:
			// it's not an and/or/not, so it must be an attribute-related filter.
			sz++;
			szFT = SzFT(sz, &pfilter->type);
			if (!szFT)
				goto LFail;
			*szFT++ = 0;
			*szMatchingParen = 0;
			Unquote(sz);
			
			// so now sz points to the attribute and szFT points to the value.
			if (pfilter->type == LDAP_FILTER_PRESENT)
				{
				pfilter->szAttrib = sz;
				}
			else
				{
				pfilter->ava.szAttrib = sz;
				pfilter->ava.szValue = szFT;
				}

			if (!pfilter->type)
				{
				// if a type wasn't filled in, it means it's either eq or substring;
				// we need to grind through the string and look for *s.  note that we
				// use a less general format of substring commands than the LDAP
				// api and spec.
				szStar = SzStar(szFT);
				if (!szStar)
					{
					pfilter->type = LDAP_FILTER_EQUALITY;
					}
				else
					{
					pfilter->type = LDAP_FILTER_SUBSTRINGS;
					pfilter->sub.szAttrib = sz;
					pfilter->sub.szInitial = szFT;
					Unquote(szFT);
					*szStar++ = 0;
					szOldStar = szStar;
					szStar = SzStar(szOldStar);
					if (szStar)
						{
						*szStar++ = 0;
						pfilter->sub.szAny = szOldStar;
						Unquote(szOldStar);
						szOldStar = szStar;
						szStar = SzStar(szOldStar);
						if (szStar)
							{
							*szStar++ = 0;
							pfilter->sub.szFinal = szOldStar;
							Unquote(szOldStar);
							}
						}
					}
				}
			break;
		}
		
	return pfilter;
	
LFail:
	if (pfilter)
		{
		FreePfilter(pfilter);
		}
	return NULL;
}

int
CAttrib(char **rgsz)
{
	int c = 0;
	while (*rgsz)
		{
		c++;
		rgsz++;
		}
	return c;
}

int
Cval(PATTR pattr)
{
	PVAL pval = pattr->pvalFirst;

	int c = 0;
	while (pval)
		{
		c++;
		pval = pval->pvalNext;
		}
	return c;
}

extern "C" DLLEXPORT LDAP * __cdecl
ldap_open(char *hostname, int portno)
{
	PLCLI plcli = NULL;
	LDAP *pldap = NULL;
	
	pldap = new LDAP;
	if (!pldap)
		return NULL;
		
	FillMemory(pldap, sizeof(LDAP), 0);
	
	if (FAILED(HrCreateLdapClient(LDAP_VER_CURRENT, INTERFACE_VER_CURRENT, &plcli)))
		{
		delete pldap;
		return NULL;
		}

	if (FAILED(plcli->HrConnect(hostname, portno)))
		{
		delete pldap;
		plcli->Release();
		return NULL;
		}
		
	pldap->plcli = plcli;
		
	return pldap;
}

extern "C" DLLEXPORT int __cdecl
ldap_bind_s(LDAP *ld, char *dn, char *cred, int method)
{
	HRESULT hr;
	XID xid;

	if (!ld->plcli)
		return LDAP_PARAM_ERROR;

	if (method != LDAP_AUTH_SIMPLE)
		return LDAP_AUTH_METHOD_NOT_SUPPORTED;

	if (!cred)
		cred = "";

	if (!dn)
		dn = "";
		
	hr = ld->plcli->HrBindSimple(dn, cred, &xid);
	if (FAILED(hr))
		return LdapResFromHr(hr);
	
	hr = ld->plcli->HrGetBindResponse(xid, INFINITE);
	return LdapResFromHr(hr);
}

extern "C" DLLEXPORT int __cdecl
ldap_unbind(LDAP *ld)
{
	if (!ld->plcli)
		return LDAP_PARAM_ERROR;
		
	ld->plcli->HrUnbind();
	ld->plcli->HrDisconnect();
	ld->plcli->Release();

	// just in case someone tries to use the ld after this...
	ld->plcli = NULL;
	
	delete ld;
	return LDAP_SUCCESS;
}
	
extern "C" DLLEXPORT int __cdecl
ldap_search_s(LDAP *ld, char *base, int scope, char *filter, char *attrs[], int attrsonly, LDAPMessage **res)
{
	struct timeval time;

	timerclear(&time);
	return ldap_search_st(ld, base, scope, filter, attrs, attrsonly, &time, res);
}

char *attrsNull[] = {NULL};

extern "C" DLLEXPORT int __cdecl
ldap_search_st(LDAP *ld, char *base, int scope, char *filter, char *attrs[], int attrsonly, struct timeval *timeout, LDAPMessage **res)
{	
	HRESULT hr;
	POBJ pobj;
	XID xid;
	SP sp;
	char szFilter[1024];

	*res = NULL;

	if (!attrs)
		attrs = attrsNull;
	
	// make local copy so we can munge this in place
	if (lstrlen(filter) > 1023)
		return LDAP_PARAM_ERROR;
	lstrcpy(szFilter, filter);

	if (!ld->plcli)
		return LDAP_PARAM_ERROR;

	sp.szDNBase = base;
	sp.scope = scope;
	sp.deref = ld->ld_deref;
	sp.cRecordsMax = ld->ld_sizelimit;
	sp.cSecondsMax = ld->ld_timelimit;
	sp.fAttrsOnly = attrsonly;
	sp.pfilter = PfilterFromString(szFilter);
	if (!sp.pfilter)
		return LDAP_PARAM_ERROR;
	sp.cAttrib = CAttrib(attrs);
	sp.rgszAttrib = attrs;
		
	hr = ld->plcli->HrSearch(&sp, &xid);
	FreePfilter(sp.pfilter);
	if (FAILED(hr))
		return LdapResFromHr(hr);
		
	hr = ld->plcli->HrGetSearchResponse(xid, TimeoutFromTimeval(timeout), &pobj);
	if (FAILED(hr))
		return LdapResFromHr(hr);
		
	*res = pobj;
	return LdapResFromHr(hr);
}

extern "C" DLLEXPORT int __cdecl
ldap_msgfree(LDAPMessage *res)
{
	POBJ pobj = res;
	
	return LdapResFromHr(HrFreePobjList(pobj));
}

extern "C" DLLEXPORT LDAPMessage * __cdecl
ldap_first_entry(LDAP *ld, LDAPMessage *res)
{
	ld->ld_errno = 0;
	return res;
}

extern "C" DLLEXPORT LDAPMessage * __cdecl
ldap_next_entry(LDAP *ld, LDAPMessage *entry)
{
	ld->ld_errno = 0;
	return (LDAPMessage *)((POBJ)entry->pobjNext);
}

extern "C" DLLEXPORT int __cdecl
ldap_count_entries(LDAP *ld, LDAPMessage *res)
{
	POBJ pobj = (POBJ)res;
	int i = 0;
	
	ld->ld_errno = 0;
	while (pobj)
		{
		i++;
		pobj = pobj->pobjNext;
		}
	return i;
}

extern "C" DLLEXPORT char * __cdecl
ldap_first_attribute(LDAP *ld, LDAPMessage *entry, void **ptr)
{
	POBJ pobj = (POBJ)entry;

	*ptr = (void *)(pobj->pattrFirst);
	ld->ld_errno = 0;
	return pobj->pattrFirst->szAttrib;
}

// NOTE!  minor change from rfc1823 API: the **ptr field below is just *ptr
// in rfc1823,but thats not a good idea, so i'm using **ptr here
// instead.
extern "C" DLLEXPORT char * __cdecl
ldap_next_attribute(LDAP *ld, LDAPMessage *entry, void **ptr)
{
	ld->ld_errno = 0;
	if (!(*ptr))
		return NULL;

	PATTR pattr = ((PATTR)*ptr)->pattrNext;
	*ptr = (void *)pattr;
	if (pattr)
		return pattr->szAttrib;
	else
		return NULL;
}

PATTR
PattrForAttr(POBJ pobj, char *szAttr)
{
	PATTR pattr = pobj->pattrFirst;

	while (pattr)
		{
		if (!lstrcmpi(pattr->szAttrib, szAttr))
			return pattr;
		pattr = pattr->pattrNext;
		}
		
	return NULL;
}

extern "C" DLLEXPORT char ** __cdecl
ldap_get_values(LDAP *ld, LDAPMessage *entry, char *attr)
{
	POBJ pobj = (POBJ)entry;
	PATTR pattr;
	int cval;
	char **rgsz;
	int isz = 0;
	PVAL pval;
	
	ld->ld_errno = 0;
	pattr = PattrForAttr(pobj, attr);
	if (!pattr)
		return NULL;

	cval = Cval(pattr);
	rgsz = new char *[cval + 1];
	if (!rgsz)
		return NULL;
	pval = pattr->pvalFirst;
	while (pval)
		{
		rgsz[isz++] = pval->szVal;
		pval = pval->pvalNext;
		}
	rgsz[isz] = NULL;

	return rgsz;
}

extern "C" DLLEXPORT struct berval ** __cdecl
ldap_get_values_len(LDAP *ld, LDAPMessage *entry, char *attr)
{
	POBJ pobj = (POBJ)entry;
	PATTR pattr;
	int cval;
	BERVAL **rgpberval;
	int iberval = 0;
	PVAL pval;
	
	ld->ld_errno = 0;
	pattr = PattrForAttr(pobj, attr);
	if (!pattr)
		return NULL;

	cval = Cval(pattr);
	rgpberval = new BERVAL *[cval + 1];
	if (!rgpberval)
		return NULL;
		
	pval = pattr->pvalFirst;
	while (pval)
		{
		rgpberval[iberval] = new BERVAL;
		if (!rgpberval[iberval])
			{
			while (--iberval >= 0)
				delete rgpberval[iberval];
			
			delete [] rgpberval;
			return NULL;
			}

		rgpberval[iberval]->bv_len = lstrlen(pval->szVal) + 1;
		rgpberval[iberval]->bv_val = pval->szVal;
		
		iberval++;
		pval = pval->pvalNext;
		}
	rgpberval[iberval] = NULL;

	return rgpberval;
}

extern "C" DLLEXPORT int __cdecl
ldap_count_values(char **vals)
{
	// mmm, reuse of poorly-named code
	return CAttrib(vals);
}

extern "C" DLLEXPORT int __cdecl
ldap_count_values_len(struct berval **vals)
{
	// mmm, reuse of poorly-named code
	return CAttrib((char **)vals);
}

extern "C" DLLEXPORT int __cdecl
ldap_value_free(char **vals)
{
	delete [] vals;
	return LDAP_SUCCESS;
}

extern "C" DLLEXPORT int __cdecl
ldap_value_free_len(struct berval **rgpberval)
{
	BERVAL **ppberval = rgpberval;

	while (*ppberval)
		{
		delete *ppberval;
		ppberval++;
		}
	delete [] rgpberval;
	return LDAP_SUCCESS;
}

extern "C" DLLEXPORT char * __cdecl
ldap_get_dn(LDAP *ld, LDAPMessage *entry)
{
	POBJ pobj = (POBJ)entry;
	char *szDN;
	
	ld->ld_errno = 0;
	szDN = new char[lstrlen(pobj->szDN) + 1];
	if (!szDN)
		{
		ld->ld_errno = LDAP_NO_MEMORY;
		return NULL;
		}

	lstrcpy(szDN, pobj->szDN);
	return szDN;
}

extern "C" DLLEXPORT void __cdecl
ldap_free_dn(char *dn)
{
	delete [] dn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\lclilist.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client Xaction List.
//
//	History:
//		davidsan	04/26/96	Created
//
//--------------------------------------------------------------------------------------------

#ifndef _LCLILIST_H
#define _LCLILIST_H

extern XL g_xl;

// just use a simple linked-list, since there won't ever be more than a few of
// these in any one process.
class CXactionList
{
public:
	CXactionList();
	~CXactionList();
	
	PXD					PxdNewXaction(DWORD xtype);
	PXD					PxdForXid(XID xid);
	void				RemovePxd(PXD pxd);
	void				AddPxdToList(PXD pxd);
	
private:
	CRITICAL_SECTION	m_cs;
	PXD					m_pxdHead;
	
	void				DeletePxdChain(PXD pxd);
};

#endif // _LCLILIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\lclixd.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client Xaction Data class
//
//
//	History
//		davidsan	04-29-96	Created
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// INCLUDES
//
//--------------------------------------------------------------------------------------------
#include "ldappch.h"
#include "lclilist.h"
#include "lclixd.h"

//--------------------------------------------------------------------------------------------
//
// PROTOTYPES
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// GLOBALS
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// CLASSES
//
//--------------------------------------------------------------------------------------------

CXactionData::CXactionData()
{
	::InitializeCriticalSection(&m_cs);

	m_hsemSignal = NULL;
	m_pxb = NULL;
	m_xid = 0;
	m_xtype = xtypeNil;
	m_fCancelled = FALSE;
	m_fOOM = FALSE;
	m_pxdNext = NULL;
}

CXactionData::~CXactionData()
{
	::DeleteCriticalSection(&m_cs);

	if (m_hsemSignal)
		CloseHandle(m_hsemSignal);

	if (m_pxb)
		this->DeletePxbChain(m_pxb);
}

void
CXactionData::DeletePxbChain(PXB pxb)
{
	PXB pxbNext;

	while (pxb)
		{
		pxbNext = pxb->pxbNext;
		delete [] pxb->pbData;
		delete pxb;
		
		pxb = pxbNext;
		}
}

BOOL
CXactionData::FInit(XID xid, DWORD xtype)
{
	::EnterCriticalSection(&m_cs);
	m_xid = xid;
	m_xtype = xtype;
	m_hsemSignal = CreateSemaphore(NULL, 0, 64000, NULL);
	m_pxb = NULL;
	m_pxdNext = NULL;
	m_fCancelled = FALSE;
	m_fOOM = FALSE;
	
	::LeaveCriticalSection(&m_cs);
	return TRUE;
}

BOOL
CXactionData::FAddBuffer(BYTE *pb, int cb)
{
	BOOL fRet = FALSE;
	PXB pxb;
	PXB pxbPrev;

	::EnterCriticalSection(&m_cs);
	pxb = new XB;
	if (!pxb)
		goto LBail;
	pxb->pbData = new BYTE[cb];
	if (!pxb->pbData)
		{
		delete pxb;
		goto LBail;
		}
	pxb->cbData = cb;
	CopyMemory(pxb->pbData, pb, cb);
	pxb->pxbNext = NULL;
	fRet = TRUE;

	if (m_pxb)
		{
		pxbPrev = m_pxb;
		while (pxbPrev->pxbNext)
			pxbPrev = pxbPrev->pxbNext;
		pxbPrev->pxbNext = pxb;
		}
	else
		{
		m_pxb = pxb;
		}
LBail:
	::LeaveCriticalSection(&m_cs);
	return fRet;
}

BOOL
CXactionData::FGetBuffer(BYTE **ppb, int *pcb)
{
	BOOL fRet = FALSE;
	PXB pxb;
	
	::EnterCriticalSection(&m_cs);

	if (!m_pxb)
		{
		goto LBail;
		}

	if (!m_pxb->pbData)
		{
		goto LBail;
		}
	
	pxb = m_pxb;
	m_pxb = m_pxb->pxbNext;
	*ppb = pxb->pbData;
	*pcb = pxb->cbData;
	delete pxb;
	
	fRet = TRUE;
LBail:
	::LeaveCriticalSection(&m_cs);
	return fRet;
}

BOOL
CXactionData::FHasData()
{
	BOOL fRet;
	
	::EnterCriticalSection(&m_cs);
	fRet = m_pxb && m_pxb->pbData;
	::LeaveCriticalSection(&m_cs);
	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\ldapber.cpp ===
/*--------------------------------------------------------------------------
    ldapber.cpp

        Client build of the LDAP Basic Encoding Rules class (CLdapBer).

    Copyright (C) 1993 Microsoft Corporation
    All rights reserved.

    Authors:
        robertc     Rob Carney

    History:
        04-17-96	robertc     Created.
  --------------------------------------------------------------------------*/
#include "ldappch.h"
#include "ldapber.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\lclixd.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client Xaction Data class.
//
//	History:
//		davidsan	04/29/96	Created
//
//--------------------------------------------------------------------------------------------

#ifndef _LCLIXD_H
#define _LCLIXD_H

typedef struct _xactionbuffer
{
	struct _xactionbuffer	*pxbNext;
	BYTE					*pbData;
	int						cbData;
} XB, *PXB;

// transaction data
class CXactionData
{
public:
	CXactionData();
	~CXactionData();
	
	BOOL				FInit(XID xid, DWORD xtype);
	
	BOOL				FGetBuffer(BYTE **ppb, int *pcb);
	BOOL				FAddBuffer(BYTE *pb, int cb);

	BOOL				FHasData();

	// accessors:
	XID					Xid()						{return m_xid;};
	PXD					PxdNext()					{return m_pxdNext;};
	HANDLE				HsemSignal()				{return m_hsemSignal;};
	DWORD				Xtype()						{return m_xtype;};
	BOOL				FCancelled()				{return m_fCancelled;};
	BOOL				FOOM()						{return m_fOOM;};
	
	void				SetPxdNext(PXD pxdNext)		{m_pxdNext = pxdNext;};
	void				SetFOOM(BOOL fOOM)			{m_fOOM = fOOM;};
	void				SetFCancelled(BOOL fCan)	{m_fCancelled = fCan;};

private:
	void				DeletePxbChain(PXB pxb);

	CRITICAL_SECTION	m_cs;
	XID					m_xid;
	PXD					m_pxdNext;

	HANDLE				m_hsemSignal;
	DWORD				m_xtype;
	BOOL				m_fCancelled;
	BOOL				m_fOOM;
	PXB					m_pxb;
};

#endif // _LCLIXD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\ldapcli.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft LDAP Sockets implementation.
//		
//	Authors:
//
//		Umesh Madan
//		RobertC	4/17/96	Modified from CHATSOCK for LDAPCLI
//		davidsan	04-25-96	hacked to pieces and started over
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// INCLUDES
//
//--------------------------------------------------------------------------------------------
#include "ldappch.h"
#include "lclilist.h"
#include "lclixd.h"

//--------------------------------------------------------------------------------------------
//
// GLOBALS
//
//--------------------------------------------------------------------------------------------
XL g_xl; // transaction list.  limit one per process.

//--------------------------------------------------------------------------------------------
//
// PROTOTYPES
//
//--------------------------------------------------------------------------------------------
void ReceiveData(PVOID pvCookie, PVOID pv, int cb, int *pcbReceived);

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS
//
//--------------------------------------------------------------------------------------------

__declspec(dllexport) HRESULT
HrCreateLdapClient(int iVerLdap, int iVerInterface, PLCLI *pplcli)
{
	if (iVerLdap != LDAP_VER_CURRENT || iVerInterface != INTERFACE_VER_CURRENT)
		return LDAP_E_VERSION;

	*pplcli = new CLdapClient(iVerLdap);
	if (!*pplcli)
		return E_OUTOFMEMORY;

	return NOERROR;
}

__declspec(dllexport) HRESULT
HrFreePobjList(POBJ pobjList)
{
	PATTR pattr;
	PVAL pval;

	while (pobjList)
		{
		delete [] pobjList->szDN;
		pattr = pobjList->pattrFirst;
		while (pattr)
			{
			delete [] pattr->szAttrib;
			pval = pattr->pvalFirst;
			while (pval)
				{
				delete [] pval->szVal;
				pval = pval->pvalNext;
				}
			pattr = pattr->pattrNext;
			}
		
		pobjList = pobjList->pobjNext;
		}
	return NOERROR;
}

typedef struct _genericstruct
{
	struct _genericstruct *pgenNext;
} GEN, *PGEN;

void AddElemToList(void *pelem, void **ppelemList)
{
	PGEN pgen = (PGEN)pelem;
	PGEN *ppgenList = (PGEN *)ppelemList;
	PGEN pgenT;
	
	if (!*ppgenList)
		{
		*ppgenList = pgen;
		}
	else
		{
	 	pgenT = *ppgenList;
		while (pgenT->pgenNext)
			{
			pgenT = pgenT->pgenNext;
			}
		pgenT->pgenNext = pgen;
		}
}

//--------------------------------------------------------------------------------------------
//
// CLASSES
//
//--------------------------------------------------------------------------------------------

CLdapClient::CLdapClient(int iVerLdap)
{
	InitializeCriticalSection(&m_cs);
	InitializeCriticalSection(&m_csRef);

	m_cRef = 1;
	m_iVerLdap = iVerLdap;
	m_psock = NULL;
	m_fConnected = FALSE;
	
	m_fHasCred = FALSE;
	m_fHasCtxt = FALSE;
	
	// some idle asserts that i'll put here cuz i don't have any better
	// place:
	Assert(&(((PVAL)0)->pvalNext) == (PVAL)0);
	Assert(&(((PATTR)0)->pattrNext) == (PATTR)0);
	Assert(&(((POBJ)0)->pobjNext) == (POBJ)0);
}

CLdapClient::~CLdapClient(void)
{
	Assert(m_cRef == 0);

	delete m_psock;
	DeleteCriticalSection(&m_cs);
	DeleteCriticalSection(&m_csRef);
}

STDMETHODIMP
CLdapClient::QueryInterface(REFIID riid,LPVOID FAR *ppvObj)
{
	return E_NOTIMPL;
}

ULONG
CLdapClient::AddRef()
{
	ULONG cRefNew;

	::EnterCriticalSection(&m_csRef);
	cRefNew = ++m_cRef;
	::LeaveCriticalSection(&m_csRef);
	
	return cRefNew;
}

ULONG
CLdapClient::Release()
{
	ULONG cRefNew;

	::EnterCriticalSection(&m_csRef);
	cRefNew = --m_cRef;
	::LeaveCriticalSection(&m_csRef);
	
	if (!cRefNew)
		delete this;
	return cRefNew;
}

STDMETHODIMP
CLdapClient::HrConnect(char *szServer, USHORT usPort)
{
	HRESULT hr;

	lstrcpy(m_szServer, szServer);

	if (m_fConnected)
		return LDAP_E_ALREADYCONNECTED;

	::EnterCriticalSection(&m_cs);
	if (!m_psock)
		{
		m_psock = new SOCK;
		if (!m_psock)
			{
			hr = E_OUTOFMEMORY;
			goto LBail;
			}
		}
	hr = m_psock->HrConnect(::ReceiveData, (PVOID)this, szServer, usPort);
	if (FAILED(hr))
		goto LBail;

	m_fConnected = TRUE;
LBail:
	::LeaveCriticalSection(&m_cs);
	return hr;
}

// constructs and returns an int from the next cb bytes of pb.
DWORD
DwBer(BYTE *pb, int cb)
{
	int i;
	DWORD cbRet;

	cbRet = 0;
	for (i = 0; i < cb; i++)
		{
		cbRet <<= 8;
		cbRet |= pb[i];
		}
	return cbRet;
}

// decodes the length field at *pb, returning the length and setting *pcbLengthField.
HRESULT
HrCbBer(BYTE *pbData, int cbData, int *pcb, int *pcbLengthField)
{
	if (cbData < 1)
		return LDAP_E_NOTENOUGHDATA;
	if (*pbData & 0x80)
		{
		// bottom 7 bits of *pb are # of bytes to turn into a size.  let's us
		// just assume that we'll never have more than a 32-bit size indicator, mkey?
		*pcbLengthField = *pbData & 0x7f;
		if (cbData < *pcbLengthField + 1)
			return LDAP_E_NOTENOUGHDATA;
		*pcb = DwBer(&pbData[1], *pcbLengthField);
		(*pcbLengthField)++; // for the first byte
		}
	else
		{
		*pcbLengthField = 1;
		*pcb = (int)(DWORD)*pbData;
		}
	if (!*pcb)
		return LDAP_E_UNEXPECTEDDATA;
	return NOERROR;
}

// We can take advantage of certain features of LDAP to make assumptions
// about the data that we receive.  The main feature that's important for
// this is the fact that any data block we receive is nested at the outermost
// level with a SEQUENCE structure.  This means that any block we get in
// this routine should start with 0x30 followed by an encoded length field.
// We use this encoded length field to decide if we've received the entire
// data block or not.
void
CLdapClient::ReceiveData(PVOID pv, int cb, int *pcbReceived)
{
	BYTE *pb = (BYTE *)pv;
	int cbSeq;
	int cbMsgId;
	int cbLengthField;
	int i;
	int ibCur;
	XID xid;
	PXD pxd;

	Assert(cb > 0);

	Assert(BER_SEQUENCE == 0x30);
	Assert(BER_INTEGER == 0x02);
	if (pb[0] != BER_SEQUENCE)
		{
		// what should we be doing with this?  we've apparently
		// either received bogus data or gotten lost!  //$ TODO: remove the assert someday
		Assert(FALSE);
		*pcbReceived = 0;
		return;
		}

	if (FAILED(HrCbBer(&pb[1], cb, &cbSeq, &cbLengthField)))
		{
		*pcbReceived = 0;
		return;
		}
	if (cbSeq + cbLengthField + 1 > cb)
		{
		*pcbReceived = 0;
		return;
		}
	*pcbReceived = cbSeq + cbLengthField + 1;

	// process pb[2+cbLengthField..*pcbReceived].  first element of the overall
	// structure is a message id.  let's hope it's there...
	ibCur = 1 + cbLengthField;
	if (pb[ibCur++] != BER_INTEGER)
		{
		Assert(FALSE); //$ TODO: should remove this assert someday
		return;
		}
	// now a length
	if (FAILED(HrCbBer(&pb[ibCur], cb - ibCur, &cbMsgId, &cbLengthField)))
		return;

	ibCur += cbLengthField;

	// msg id is next bytes
	if (cbMsgId + ibCur >= cb)
		return;

	xid = DwBer(&pb[ibCur], cbMsgId);
	ibCur += cbMsgId;
	pxd = g_xl.PxdForXid(xid);
	
	// if we don't have an entry for this, assume it was cancelled or
	// something and just ignore this packet.
	if (!pxd)
		return;

	if (!pxd->FAddBuffer(&pb[ibCur], *pcbReceived - ibCur))
		{
		pxd->SetFOOM(TRUE);
		return;
		}

	ReleaseSemaphore(pxd->HsemSignal(), 1, NULL);
}

void
ReceiveData(PVOID pvCookie, PVOID pv, int cb, int *pcbReceived)
{
	CLdapClient *plcli = (CLdapClient *)pvCookie;
	
	plcli->ReceiveData(pv, cb, pcbReceived);
}

STDMETHODIMP
CLdapClient::HrDisconnect()
{
	if (!m_fConnected)
		{
		return LDAP_E_NOTCONNECTED;
		}
	m_fConnected = FALSE;
	return m_psock->HrDisconnect();
}

STDMETHODIMP
CLdapClient::HrIsConnected()
{
	return m_fConnected ? NOERROR : S_FALSE;
}

HRESULT
CLdapClient::HrSendBindMsg(XID xid, char *szDN, int iAuth, void *pv, int cb)
{
	LBER lber;
	HRESULT hr;
	
	// a BIND request looks like:
	//	[APPLICATION 0] (IMPLICIT) SEQUENCE {
	//		version (INTEGER)
	//		szDN (LDAPDN)
	//		authentication CHOICE {
	//			simple	[0] OCTET STRING
	//			[... other choices ...]
	//			}
	//		}
	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)xid));

	  VERIFY(lber.HrStartWriteSequence(LDAP_BIND_CMD));

		VERIFY(lber.HrAddValue((LONG)m_iVerLdap));
		VERIFY(lber.HrAddValue((const TCHAR *)szDN));

		VERIFY(lber.HrAddBinaryValue((BYTE *)pv, cb, iAuth));

	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());
	
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());

LBail:
	return hr;
}

STDMETHODIMP
CLdapClient::HrBindSimple(char *szDN, char *szPass, PXID pxid)
{
	LBER lber;
	HRESULT hr;
	PXD pxd;
	
	pxd = g_xl.PxdNewXaction(xtypeBind);
	if (!pxd)
		return E_OUTOFMEMORY;

	hr = this->HrSendBindMsg(pxd->Xid(), szDN, BIND_SIMPLE, szPass, lstrlen(szPass));

	if (FAILED(hr))
		return hr;

	*pxid = pxd->Xid();
	return NOERROR;
}

HRESULT
CLdapClient::HrWaitForPxd(PXD pxd, DWORD timeout, BOOL *pfDel)
{
	DWORD dwWait;
	HRESULT hr;
	
	*pfDel = FALSE;
	dwWait = WaitForSingleObject(pxd->HsemSignal(), timeout);
	switch (dwWait)
		{
		default:
			Assert(FALSE);
			// fall through
		case WAIT_FAILED:
			hr = LDAP_E_INVALIDXID;
			break;

		case WAIT_TIMEOUT:
			hr = LDAP_E_TIMEOUT;
			break;

		case WAIT_OBJECT_0:
			*pfDel = TRUE;
			if (pxd->FCancelled())
				{
				hr = LDAP_E_CANCELLED;
				}
			else if (pxd->FOOM())
				{
				hr = E_OUTOFMEMORY;
				}
			else
				{
				hr = NOERROR;
				}
			break;
		}
	return hr;
}

HRESULT
CLdapClient::HrGetSimpleResponse(XID xid, DWORD xtype, ULONG ulTagResult, DWORD timeout)
{
	PXD pxd;
	BYTE *pbData;
	int cbData;
	HRESULT hr = LDAP_E_UNEXPECTEDDATA;
	BOOL fDel;
	int cb;
	int cbSub;
	int cbLengthField;
	int ibCur;
	long lResult;
	ULONG ulTag;
	LBER lber;
	
	pxd = g_xl.PxdForXid(xid);
	if (!pxd)
		return LDAP_E_INVALIDXID;
	if (pxd->Xtype() != xtype)
		return LDAP_E_INVALIDXTYPE;
	if (pxd->FCancelled())
		return LDAP_E_CANCELLED;
	if (pxd->FOOM())
		return E_OUTOFMEMORY;

	if (pxd->FHasData())
		{
		fDel = TRUE;
		}
	else
		{
		hr = this->HrWaitForPxd(pxd, timeout, &fDel);
		if (FAILED(hr))
			goto LBail;
		}

	if (!pxd->FGetBuffer(&pbData, &cbData))
		{
		//$ what's the right error here?
		hr = LDAP_E_UNEXPECTEDDATA;
		goto LBail;
		}
	VERIFY(lber.HrLoadBer(pbData, cbData));

	VERIFY(lber.HrStartReadSequence(ulTagResult));
	  VERIFY(lber.HrPeekTag(&ulTag));
	  if (ulTag == BER_SEQUENCE)
		{
		Assert(FALSE); // i want to see if any server returns explicit sequences
		VERIFY(lber.HrStartReadSequence());
		}
	  VERIFY(lber.HrGetEnumValue(&lResult));
	  if (ulTag == BER_SEQUENCE)
	    {
	    VERIFY(lber.HrEndReadSequence());
		}
	VERIFY(lber.HrEndReadSequence());

	hr = this->HrFromLdapResult(lResult);

LBail:
	if (fDel)
		g_xl.RemovePxd(pxd);

	return hr;
}

STDMETHODIMP
CLdapClient::HrGetBindResponse(XID xid, DWORD timeout)
{
	return this->HrGetSimpleResponse(xid, xtypeBind, LDAP_BIND_RES, timeout);
}

STDMETHODIMP
CLdapClient::HrUnbind()
{
	PXD pxd;
	XID xid;
	HRESULT hr;
	LBER lber;

	pxd = g_xl.PxdNewXaction(xtypeUnbind);
	if (!pxd)
		return E_OUTOFMEMORY;
	xid = pxd->Xid();
	g_xl.RemovePxd(pxd); // don't need this, since there's no response

	// unbind:
	//	[APPLICATION 2] NULL
	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)xid));
	  VERIFY(lber.HrStartWriteSequence(LDAP_UNBIND_CMD));
		VERIFY(lber.HrAddValue((const TCHAR *)"", BER_NULL));
	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());

LBail:
	return hr;
}

HRESULT
CLdapClient::HrEncodeFilter(LBER *plber, PFILTER pfilter)
{
	HRESULT hr = E_OUTOFMEMORY;
	HRESULT hrSub;
	PFILTER pfilterT;

	switch (pfilter->type)
		{
		case LDAP_FILTER_AND:
		case LDAP_FILTER_OR:
			VERIFY(plber->HrStartWriteSequence(pfilter->type));
			  pfilterT = pfilter->pfilterSub;
			  while (pfilterT)
				{
				VERIFY(this->HrEncodeFilter(plber, pfilterT));
				pfilterT = pfilterT->pfilterNext;
				}
			VERIFY(plber->HrEndWriteSequence());
			break;

		case LDAP_FILTER_NOT:
			VERIFY(plber->HrStartWriteSequence(LDAP_FILTER_NOT));
			  VERIFY(this->HrEncodeFilter(plber, pfilter->pfilterSub));
			VERIFY(plber->HrEndWriteSequence());
			break;
			
		case LDAP_FILTER_GE:
		case LDAP_FILTER_LE:
		case LDAP_FILTER_APPROX:
		case LDAP_FILTER_EQUALITY:
			VERIFY(plber->HrStartWriteSequence(pfilter->type));
			  VERIFY(plber->HrAddValue(pfilter->ava.szAttrib));
			  VERIFY(plber->HrAddValue(pfilter->ava.szValue));
			VERIFY(plber->HrEndWriteSequence());
			break;
			
		case LDAP_FILTER_SUBSTRINGS:
			VERIFY(plber->HrStartWriteSequence(LDAP_FILTER_SUBSTRINGS));
			  VERIFY(plber->HrAddValue(pfilter->sub.szAttrib));
			  VERIFY(plber->HrStartWriteSequence());
				if (pfilter->sub.szInitial)
				  {
				  VERIFY(plber->HrAddValue(pfilter->sub.szInitial, 0 | BER_CLASS_CONTEXT_SPECIFIC));
				  }
				if (pfilter->sub.szAny)
				  {
				  VERIFY(plber->HrAddValue(pfilter->sub.szAny, 1 | BER_CLASS_CONTEXT_SPECIFIC));
				  }
				if (pfilter->sub.szFinal)
				  {
				  VERIFY(plber->HrAddValue(pfilter->sub.szFinal, 2 | BER_CLASS_CONTEXT_SPECIFIC));
				  }
			  VERIFY(plber->HrEndWriteSequence());
			VERIFY(plber->HrEndWriteSequence());
			break;
	
		case LDAP_FILTER_PRESENT:
			VERIFY(plber->HrAddValue(pfilter->szAttrib, LDAP_FILTER_PRESENT));
			break;
		}

	hr = NOERROR;
LBail:
	return hr;
}

STDMETHODIMP
CLdapClient::HrSearch(PSP psp, PXID pxid)
{
	LBER lber;
	HRESULT hr;
	PXD pxd;
	int i;
	
	pxd = g_xl.PxdNewXaction(xtypeSearch);
	if (!pxd)
		return E_OUTOFMEMORY;

	// a SEARCH request looks like:
	//	[APPLICATION 3] SEQUENCE {
	//		szDNBase (LDAPDN)
	//		scope {enum base==0, singlelevel==1, subtree=2}
	//		deref {enum never=0, derefsearch==1, derefbase==2, derefall==3}
	//		sizelimit (integer)
	//		timelimit (integer)
	//		attrsOnly (BOOLEAN)
	//		filter (complex type)
	//		sequence of attrtype

	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)pxd->Xid()));
	  VERIFY(lber.HrStartWriteSequence(LDAP_SEARCH_CMD));
		VERIFY(lber.HrAddValue((const TCHAR *)psp->szDNBase));
		VERIFY(lber.HrAddValue(psp->scope, BER_ENUMERATED));
		VERIFY(lber.HrAddValue(psp->deref, BER_ENUMERATED));
		VERIFY(lber.HrAddValue((LONG)psp->cRecordsMax));
		VERIFY(lber.HrAddValue((LONG)psp->cSecondsMax));
		VERIFY(lber.HrAddValue(psp->fAttrsOnly, BER_BOOLEAN));

		VERIFY(this->HrEncodeFilter(&lber, psp->pfilter));

		// attributes to return
		VERIFY(lber.HrStartWriteSequence());
		for (i = 0; i < psp->cAttrib; i++)
		  {
		  VERIFY(lber.HrAddValue((const TCHAR *)psp->rgszAttrib[i]));
		  }
		VERIFY(lber.HrEndWriteSequence());

	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());

	hr = m_psock->HrSend(lber.PbData(), lber.CbData());
LBail:
	if (FAILED(hr))
		return hr;

	*pxid = pxd->Xid();
	return NOERROR;
}

STDMETHODIMP
CLdapClient::HrGetSearchResponse(XID xid, DWORD timeout, POBJ *ppobj)
{
	PXD pxd;
	BYTE *pbData;
	int cbData;
	HRESULT hr = LDAP_E_UNEXPECTEDDATA;
	BOOL fDel;
	int cb;
	int cbString;
	int cbSub;
	int cbLengthField;
	int ibCur;
	ULONG ulTag;
	long lResult;
	LBER lber;
	BOOL fGotAllData = FALSE;
	POBJ pobj;
	PATTR pattr;
	PVAL pval;
	
	*ppobj = NULL;
	pxd = g_xl.PxdForXid(xid);
	if (!pxd)
		return LDAP_E_INVALIDXID;
	if (pxd->Xtype() != xtypeSearch)
		return LDAP_E_INVALIDXTYPE;

	while (!fGotAllData)
		{
		if (pxd->FCancelled())
			return LDAP_E_CANCELLED;
		if (pxd->FOOM())
			return E_OUTOFMEMORY;

		hr = this->HrWaitForPxd(pxd, timeout, &fDel);
		if (FAILED(hr))
			goto LBail;

		if (!pxd->FGetBuffer(&pbData, &cbData))
			{
			//$ what's the right error here?
			hr = LDAP_E_UNEXPECTEDDATA;
			Assert(FALSE);
			goto LBail;
			}
		VERIFY(lber.HrLoadBer(pbData, cbData));
	
		hr = LDAP_E_UNEXPECTEDDATA;
		VERIFY(lber.HrPeekTag(&ulTag));
		if (ulTag == (LDAP_SEARCH_ENTRY | BER_FORM_CONSTRUCTED | BER_CLASS_APPLICATION))
			{
			VERIFY(lber.HrStartReadSequence(LDAP_SEARCH_ENTRY | BER_FORM_CONSTRUCTED | BER_CLASS_APPLICATION));
			  pobj = new OBJ;
			  pobj->pobjNext = NULL;
			  pobj->pattrFirst = NULL;
			  if (!pobj)
				{
				hr = E_OUTOFMEMORY;
				goto LBail;
				}
			  AddElemToList(pobj, (void **)ppobj);
			  
			  VERIFY(lber.HrGetStringLength(&cbString));
			  pobj->szDN = new char[cbString + 1];
			  if (!pobj->szDN)
				{
				hr = E_OUTOFMEMORY;
				goto LBail;
				}
			  VERIFY(lber.HrGetValue(pobj->szDN, cbString + 1));
			  VERIFY(lber.HrStartReadSequence());
			  while (!lber.FEndOfSequence())
				{
				VERIFY(lber.HrStartReadSequence());
				while (!lber.FEndOfSequence())
				  {
				  pattr = new ATTR;
				  pattr->pattrNext = NULL;
				  pattr->pvalFirst = NULL;
				  AddElemToList(pattr, (void **)&(pobj->pattrFirst));
				  VERIFY(lber.HrGetStringLength(&cbString));
				  pattr->szAttrib = new char[cbString + 1];
				  if (!pattr->szAttrib)
				  	{
					hr = E_OUTOFMEMORY;
					goto LBail;
					}
				  VERIFY(lber.HrGetValue(pattr->szAttrib, cbString + 1));
				  VERIFY(lber.HrStartReadSequence(BER_SET));
				  while (!lber.FEndOfSequence())
					{
					pval = new VAL;
					pval->pvalNext = NULL;
					AddElemToList(pval, (void **)&(pattr->pvalFirst));
					VERIFY(lber.HrGetStringLength(&cbString));
					pval->szVal = new char[cbString + 1];
					if (!pval->szVal)
					  {
					  hr = E_OUTOFMEMORY;
					  goto LBail;
					  }
					VERIFY(lber.HrGetValue(pval->szVal, cbString + 1));
					}
				  VERIFY(lber.HrEndReadSequence());
				  }
				VERIFY(lber.HrEndReadSequence());
				}
			  VERIFY(lber.HrEndReadSequence());
			VERIFY(lber.HrEndReadSequence());
			}
		else if (ulTag == (LDAP_SEARCH_RESULTCODE | BER_FORM_CONSTRUCTED | BER_CLASS_APPLICATION))
			{
			fGotAllData = TRUE;
			VERIFY(lber.HrStartReadSequence(LDAP_SEARCH_RESULTCODE | BER_FORM_CONSTRUCTED | BER_CLASS_APPLICATION));
			  VERIFY(lber.HrGetEnumValue(&lResult));
			VERIFY(lber.HrEndReadSequence());
			hr = this->HrFromLdapResult(lResult);
			}
		else
			{
			goto LBail;
			}
		} // while !fGotAllData
LBail:
	if (fDel)
		g_xl.RemovePxd(pxd);

	return hr;
}

// seq { type set {values}}
HRESULT
CLdapClient::HrEncodePattr(LBER *plber, PATTR pattr)
{
	HRESULT hr;
	PVAL pval;
	
	VERIFY(plber->HrStartWriteSequence());
	  VERIFY(plber->HrAddValue((TCHAR *)pattr->szAttrib));
	  VERIFY(plber->HrStartWriteSequence(BER_SET));
		pval = pattr->pvalFirst;
		while (pval)
		  {
		  VERIFY(plber->HrAddValue((TCHAR *)pval->szVal));
		  pval = pval->pvalNext;
		  }
	  VERIFY(plber->HrEndWriteSequence());
	VERIFY(plber->HrEndWriteSequence());
LBail:
	return hr;
}

// pmod is SEQ { op seq { type set {values}}}
HRESULT
CLdapClient::HrEncodePmod(LBER *plber, PMOD pmod)
{
	HRESULT hr;
	PATTR pattr;
	
	VERIFY(plber->HrStartWriteSequence());
	  VERIFY(plber->HrAddValue((long)pmod->modop, BER_ENUMERATED));
	  pattr = pmod->pattrFirst;
	  while (pattr)
		{
		VERIFY(this->HrEncodePattr(plber, pattr));
		pattr = pattr->pattrNext;
		}
	VERIFY(plber->HrEndWriteSequence());
LBail:
	return hr;
}

STDMETHODIMP
CLdapClient::HrModify(char *szDN, PMOD pmod, PXID pxid)
{
	LBER lber;
	HRESULT hr;
	PXD pxd;
	
	pxd = g_xl.PxdNewXaction(xtypeModify);
	if (!pxd)
		return E_OUTOFMEMORY;

	// a MODIFY request looks like:
	//	[APPLICATION 6] SEQUENCE {
	//		object (LDAPDN)
	//		SEQUENCE OF SEQUENCE {
	//			operation
	//			SEQUENCE {
	//				type
	//				SET OF values
	//			}
	//		}
	//	}

	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)pxd->Xid()));
	  VERIFY(lber.HrStartWriteSequence(LDAP_MODIFY_CMD));
		VERIFY(lber.HrAddValue((const TCHAR *)szDN));
		VERIFY(lber.HrStartWriteSequence());
		while (pmod)
		  {
		  VERIFY(this->HrEncodePmod(&lber, pmod));
		  pmod = pmod->pmodNext;
		  }
		VERIFY(lber.HrEndWriteSequence());
	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());
	
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());
LBail:
	if (FAILED(hr))
		return hr;

	*pxid = pxd->Xid();
	return NOERROR;
}

STDMETHODIMP
CLdapClient::HrGetModifyResponse(XID xid, DWORD timeout)
{
	return this->HrGetSimpleResponse(xid, xtypeModify, LDAP_MODIFY_RES, timeout);
}

STDMETHODIMP
CLdapClient::HrAdd(char *szDN, PATTR pattr, PXID pxid)
{
	LBER lber;
	HRESULT hr;
	PXD pxd;
	
	pxd = g_xl.PxdNewXaction(xtypeAdd);
	if (!pxd)
		return E_OUTOFMEMORY;

	// an ADD request looks like:
	//	[APPLICATION 8] SEQUENCE {
	//		object (LDAPDN)
	//		SEQUENCE OF SEQUENCE {
	//			type
	//			SET OF values
	//		}
	//	}

	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)pxd->Xid()));
	  VERIFY(lber.HrStartWriteSequence(LDAP_ADD_CMD));
		VERIFY(lber.HrAddValue((const TCHAR *)szDN));
		VERIFY(lber.HrStartWriteSequence());
		while (pattr)
		  {
		  VERIFY(this->HrEncodePattr(&lber, pattr));
		  pattr = pattr->pattrNext;
		  }
		VERIFY(lber.HrEndWriteSequence());
	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());
	
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());
LBail:
	if (FAILED(hr))
		return hr;

	*pxid = pxd->Xid();
	return NOERROR;
}

STDMETHODIMP
CLdapClient::HrGetAddResponse(XID xid, DWORD timeout)
{
	return this->HrGetSimpleResponse(xid, xtypeAdd, LDAP_ADD_RES, timeout);
}
	
STDMETHODIMP
CLdapClient::HrDelete(char *szDN, PXID pxid)
{
	LBER lber;
	HRESULT hr;
	PXD pxd;
	
	pxd = g_xl.PxdNewXaction(xtypeDelete);
	if (!pxd)
		return E_OUTOFMEMORY;

	// a DELETE request looks like:
	//	[APPLICATION 10] LDAPDN

	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)pxd->Xid()));
	  VERIFY(lber.HrAddValue((const TCHAR *)szDN, LDAP_DELETE_CMD));
	VERIFY(lber.HrEndWriteSequence());
	
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());
LBail:
	if (FAILED(hr))
		return hr;

	*pxid = pxd->Xid();
	return NOERROR;
}

STDMETHODIMP
CLdapClient::HrGetDeleteResponse(XID xid, DWORD timeout)
{
	return this->HrGetSimpleResponse(xid, xtypeDelete, LDAP_DELETE_RES, timeout);
}

STDMETHODIMP
CLdapClient::HrModifyRDN(char *szDN, char *szNewRDN, BOOL fDeleteOldRDN, PXID pxid)
{
	LBER lber;
	HRESULT hr;
	PXD pxd;
	
	pxd = g_xl.PxdNewXaction(xtypeModifyRDN);
	if (!pxd)
		return E_OUTOFMEMORY;

	// a MODIFYRDN request looks like:
	//	[APPLICATION 12] SEQUENCE {
	//		object (LDAPDN)
	//		newrdn (RELATIVE LDAPDN)
	//		deleteoldrdn (BOOL)
	//	}

	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)pxd->Xid()));
	  VERIFY(lber.HrStartWriteSequence(LDAP_MODRDN_CMD));
		VERIFY(lber.HrAddValue((const TCHAR *)szDN));
		VERIFY(lber.HrAddValue((const TCHAR *)szNewRDN));
		VERIFY(lber.HrAddValue(fDeleteOldRDN, BER_BOOLEAN));
	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());
	
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());
LBail:
	if (FAILED(hr))
		return hr;

	*pxid = pxd->Xid();
	return NOERROR;
}

STDMETHODIMP
CLdapClient::HrGetModifyRDNResponse(XID xid, DWORD timeout)
{
	return this->HrGetSimpleResponse(xid, xtypeModifyRDN, LDAP_MODRDN_RES, timeout);
}

STDMETHODIMP
CLdapClient::HrCompare(char *szDN, char *szAttrib, char *szValue, PXID pxid)
{
	LBER lber;
	HRESULT hr;
	PXD pxd;
	
	pxd = g_xl.PxdNewXaction(xtypeCompare);
	if (!pxd)
		return E_OUTOFMEMORY;

	// a COMPARE request looks like:
	//	[APPLICATION 14] SEQUENCE {
	//		object (LDAPDN)
	//		AVA ava
	//	}

	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)pxd->Xid()));
	  VERIFY(lber.HrStartWriteSequence(LDAP_COMPARE_CMD));
		VERIFY(lber.HrAddValue((const TCHAR *)szDN));
		VERIFY(lber.HrStartWriteSequence());
		  VERIFY(lber.HrAddValue((const TCHAR *)szAttrib));
		  VERIFY(lber.HrAddValue((const TCHAR *)szValue));
		VERIFY(lber.HrEndWriteSequence());
	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());
	
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());
LBail:
	if (FAILED(hr))
		return hr;

	*pxid = pxd->Xid();
	return NOERROR;
}

STDMETHODIMP
CLdapClient::HrGetCompareResponse(XID xid, DWORD timeout)
{
	return this->HrGetSimpleResponse(xid, xtypeCompare, LDAP_COMPARE_RES, timeout);
}

STDMETHODIMP
CLdapClient::HrCancelXid(XID xid)
{
	PXD pxd = g_xl.PxdForXid(xid);
	PXD pxdNew;
	XID xidNew;
	HRESULT hr;
	LBER lber;

	if (!pxd)
		return LDAP_E_INVALIDXID;
	pxdNew = g_xl.PxdNewXaction(xtypeAbandon);
	if (!pxdNew)
		return E_OUTOFMEMORY;
	xidNew = pxdNew->Xid();
	g_xl.RemovePxd(pxdNew); // don't need to keep this around

	// abandon:
	//	[APPLICATION 16] message id
	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)xidNew));
	  VERIFY(lber.HrStartWriteSequence(LDAP_ABANDON_CMD));
		VERIFY(lber.HrAddValue((LONG)xid));
	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());

LBail:
	pxd->SetFCancelled(TRUE);
	return hr;
}

//$ TODO: Map all LDAP results to HRESULTs
HRESULT
CLdapClient::HrFromLdapResult(int iResult)
{
	HRESULT hr;

	switch (iResult)
		{
		default:
			return E_FAIL;

		case LDAP_OPERATIONS_ERROR:
			return LDAP_E_OPERATIONS;
			
		case LDAP_PROTOCOL_ERROR:
			return LDAP_E_PROTOCOL;
			
		case LDAP_TIMELIMIT_EXCEEDED:
			return LDAP_S_TIMEEXCEEDED;
			
		case LDAP_SIZELIMIT_EXCEEDED:
			return LDAP_S_SIZEEXCEEDED;

		case LDAP_COMPARE_FALSE:
			return S_FALSE;

		case LDAP_COMPARE_TRUE:
			return NOERROR;
			
		case LDAP_AUTH_METHOD_NOT_SUPPORTED:
			return LDAP_E_AUTHMETHOD;
			
		case LDAP_STRONG_AUTH_REQUIRED:
			return LDAP_E_STRONGAUTHREQUIRED;
			
		case LDAP_NO_SUCH_ATTRIBUTE:
			return LDAP_E_NOSUCHATTRIBUTE;
			
		case LDAP_UNDEFINED_TYPE:
			return LDAP_E_UNDEFINEDTYPE;
		
		case LDAP_INAPPROPRIATE_MATCHING:
			return LDAP_E_MATCHING;
			
		case LDAP_CONSTRAINT_VIOLATION:
			return LDAP_E_CONSTRAINT;
			
		case LDAP_ATTRIBUTE_OR_VALUE_EXISTS:
			return LDAP_E_ATTRIBORVALEXISTS;
		
		case LDAP_INVALID_SYNTAX:
			return LDAP_E_SYNTAX;
		
		case LDAP_NO_SUCH_OBJECT:
			return LDAP_E_NOSUCHOBJECT;
		
		case LDAP_ALIAS_PROBLEM:
			return LDAP_E_ALIAS;
		
		case LDAP_INVALID_DN_SYNTAX:
			return LDAP_E_DNSYNTAX;

		case LDAP_IS_LEAF:
			return LDAP_E_ISLEAF;
			
		case LDAP_ALIAS_DEREF_PROBLEM:
			return LDAP_E_ALIASDEREF;
		
		case LDAP_INAPPROPRIATE_AUTH:
			return LDAP_E_AUTH;

		case LDAP_INVALID_CREDENTIALS:
			return LDAP_E_CREDENTIALS;
		
		case LDAP_INSUFFICIENT_RIGHTS:
			return LDAP_E_RIGHTS;
			
		case LDAP_BUSY:
			return LDAP_E_BUSY;
			
		case LDAP_UNAVAILABLE:
			return LDAP_E_UNAVAILABLE;
			
		case LDAP_UNWILLING_TO_PERFORM:
			return LDAP_E_UNWILLING;
			
		case LDAP_LOOP_DETECT:
			return LDAP_E_LOOP;
			
		case LDAP_NAMING_VIOLATION:
			return LDAP_E_NAMING;
			
		case LDAP_OBJECT_CLASS_VIOLATION:
			return LDAP_E_OBJECTCLASS;
			
		case LDAP_NOT_ALLOWED_ON_NONLEAF:
			return LDAP_E_NOTALLOWEDONNONLEAF;
			
		case LDAP_NOT_ALLOWED_ON_RDN:
			return LDAP_E_NOTALLOWEDONRDN;
			
		case LDAP_ALREADY_EXISTS:
			return LDAP_E_ALREADYEXISTS;
			
		case LDAP_NO_OBJECT_CLASS_MODS:
			return LDAP_E_NOOBJECTCLASSMODS;
			
		case LDAP_RESULTS_TOO_LARGE:
			return LDAP_E_RESULTSTOOLARGE;
		
		case LDAP_OTHER:
			return LDAP_E_OTHER;
		
		case LDAP_SERVER_DOWN:
			return LDAP_E_SERVERDOWN;
			
		case LDAP_LOCAL_ERROR:
			return LDAP_E_LOCAL;
			
		case LDAP_ENCODING_ERROR:
			return LDAP_E_ENCODING;
			
		case LDAP_DECODING_ERROR:
			return LDAP_E_DECODING;

		case LDAP_TIMEOUT:
			return LDAP_E_TIMEOUT;
			
		case LDAP_AUTH_UNKNOWN:
			return LDAP_E_AUTHUNKNOWN;
			
		case LDAP_FILTER_ERROR:
			return LDAP_E_FILTER;
			
		case LDAP_USER_CANCELLED:
			return LDAP_E_USERCANCELLED;

		case LDAP_PARAM_ERROR:
			return E_INVALIDARG;

		case LDAP_NO_MEMORY:
			return E_OUTOFMEMORY;

		case LDAP_SUCCESS:
			return NOERROR;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\ldapber.h ===
/*--------------------------------------------------------------------------
    ldapber.h
        
        CLdapBer Class:
            This class handles Basic Encode Rules (BER) processing for LDAP.
			The following BER restrictions are assumed.  
				1)  Definite form of length encoding only.
				2)  Primitive forms only are used.


  Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        robertc     Rob Carney

    History:
        04-11-96    robertc     Created.
  --------------------------------------------------------------------------*/

#ifndef _LDAPBER_H
#define _LDAPBER_H

#if defined(DEBUG) && defined(INLINE)
#undef THIS_FILE
static char BASED_CODE_MODULE[] = "ldapber.h";
#define THIS_FILE LDAPBER_H
#endif

// Identifier masks.
#define	BER_TAG_MASK		0x1f
#define	BER_FORM_MASK		0x20
#define BER_CLASS_MASK		0xc0
#define GetBerTag(x)	(x & BER_TAG_MASK)
#define GetBerForm(x)	(x & BER_FORM_MASK)
#define GetBerClass(x)	(x & BER_CLASS_MASK)

// id classes
#define BER_FORM_CONSTRUCTED		0x20
#define BER_CLASS_APPLICATION		0x40	
#define BER_CLASS_CONTEXT_SPECIFIC	0x80
//
// Standard BER types.
#define BER_INVALID_TAG		0x00
#define BER_BOOLEAN			0x01
#define BER_INTEGER			0x02
#define	BER_BITSTRING		0x03
#define BER_OCTETSTRING		0x04
#define BER_NULL			0x05
#define	BER_ENUMERATED		0x0a
#define BER_SEQUENCE		0x30
#define BER_SET				0x31

#define CB_DATA_GROW		1024
#define MAX_BER_STACK		50		// max # of elements we can have in stack.

#define	MAX_ATTRIB_TYPE		40		// Max size of a AttributeType.

// The SEQ_STACK entry is used to keep state info when building up a sequence.
typedef struct
{
	ULONG	iPos;		// Current position in the BER buffer where the 
						// sequence length should go.
	ULONG	cbLength;	// # of bytes used for the length field.
	ULONG	iParentSeqStart;	// Starting position of the parent sequence.
	ULONG	cbParentSeq;		// # of bytes in the parent sequence.
} SEQ_STACK;


class CLdapBer;

typedef CLdapBer LBER;

class CLdapBer
{
    // FRIENDS ------------------------------------------------
private:    
    // INTERFACES ---------------------------------------------
    // DECLARE OBJECT TYPE (SERIAL/DYNAMIC/DYNACREATE) --------
public:
    // PUBLIC CONSTRUCTOR DESTRUCTOR --------------------------
	CLdapBer();
	~CLdapBer();

    // PUBLIC ACCESSORS ---------------------------------------
	BYTE	*PbData()	{ return m_pbData; }
	ULONG	CbData()	{ return m_cbData; }

	ULONG	CbSequence()	{ return m_cbSeq; }

    // PUBLIC FUNCTIONS ---------------------------------------
//#ifndef CLIENT
//	VOID *operator new (size_t cSize)		{ return m_cpool.Alloc(); }
//	VOID operator delete (VOID *pInstance)	{ m_cpool.Free(pInstance); }
//#endif

	void	Reset();

	// Loads the BER class from a buffer.
	HRESULT	HrLoadBer(BYTE *pbSrc, ULONG cbSrc, BOOL fLocalCopy=TRUE);

	// Function to make sure the input buffer has the full length field.
	static BOOL FCheckSequenceLength(BYTE *pbInput, ULONG cbInput, ULONG *pcbSeq, ULONG *piValuePos);

	// Read & Write sequence routines.
	HRESULT	HrStartReadSequence(ULONG ulTag=BER_SEQUENCE);
	HRESULT	HrEndReadSequence();
	HRESULT HrStartWriteSequence(ULONG ulTag=BER_SEQUENCE);
	HRESULT	HrEndWriteSequence();

	BOOL	FEndOfSequence()
				{	if ((m_iCurrPos - m_iSeqStart) >= m_cbSeq) return TRUE;
					 else return FALSE; }

	void	GetCurrPos(ULONG *piCurrPos)	{ *piCurrPos = m_iCurrPos; }
	HRESULT	FSetCurrPos(ULONG iCurrPos);

	HRESULT	HrSkipValue();
	HRESULT	HrSkipTag();
	HRESULT HrUnSkipTag();
	HRESULT	HrPeekTag(ULONG *pulTag);
	HRESULT	HrPeekLength(ULONG *pcb);
				  
	HRESULT	HrGetTag(ULONG *pulTag, ULONG ulTag=BER_INTEGER)
				{ return HrGetValue((LONG *)pulTag, ulTag); }
	HRESULT	HrGetValue(LONG *pi, ULONG ulTag=BER_INTEGER);
	HRESULT	HrGetValue(TCHAR *szValue, ULONG cbValue, ULONG ulTag=BER_OCTETSTRING);
	HRESULT	HrGetEnumValue(LONG *pi);
	HRESULT	HrGetStringLength(int *pcbValue, ULONG ulTag = BER_OCTETSTRING);
	HRESULT HrGetBinaryValue(BYTE *pbBuf, ULONG cbBuf, ULONG ulTag = BER_OCTETSTRING);

	HRESULT	HrAddValue(LONG i, ULONG ulTag=BER_INTEGER);
	HRESULT	HrAddValue(const TCHAR *szValue, ULONG ulTag = BER_OCTETSTRING);
	HRESULT	HrAddBinaryValue(BYTE *pbValue, ULONG cbValue, ULONG ulTag = BER_OCTETSTRING);

    // PUBLIC OVERRIDEABLES -----------------------------------
    // PUBLIC VARIABLES ---------------------------------------
//#ifndef CLIENT
//	static  CPool	m_cpool;
//#endif

    // PUBLIC DEBUG -------------------------------------------
protected:
    // PROTECTED CONSTRUCTOR DESTRUCTOR -----------------------
    // PROTECTED ACCESSORS ------------------------------------
    // PROTECTED FUNCTIONS ------------------------------------
    // PROTECTED OVERRIDEABLES --------------------------------
    // PROTECTED VARIABLES ------------------------------------
    // PROTECTED DEBUG ----------------------------------------
private:    
    // PRIVATE ACCESSORS --------------------------------------
    // PRIVATE FUNCTIONS --------------------------------------
	HRESULT		HrPushSeqStack(ULONG iPos, ULONG cbLength, 
								ULONG iParentSeqStart, ULONG cbParentSeq);
	HRESULT		HrPopSeqStack(ULONG *piPos, ULONG *pcbLength, 
								ULONG *piParentSeqStart, ULONG *pcbParentSeq);

	static void		GetCbLength(BYTE *pbData, ULONG *pcbLength);
	HRESULT		HrGetLength(ULONG *pcb);
	static HRESULT	HrGetLength(BYTE *pbData, ULONG *pcb, ULONG *piPos);

	void		GetInt(BYTE *pbData, ULONG cbValue, LONG *plValue);

	void		AddInt(BYTE *pbData, ULONG cbValue, LONG iValue);

	HRESULT		HrSetLength(ULONG cb, ULONG cbLength=0xffffffff);
	
	// if fExact is true, cbNeeded is exactly the amount of data we need.
	HRESULT		HrEnsureBuffer(ULONG cbNeeded, BOOL fExact = FALSE);
    // PRIVATE OVERRIDEABLES ----------------------------------
    // PRIVATE VARIABLES --------------------------------------
	ULONG		m_iCurrPos;		// Current position within the data buffer.
	ULONG		m_cbData;

	BOOL		m_fLocalCopy;	// TRUE to alloc space for a local copy, FALSE keeps a reference.
	ULONG		m_cbDataMax;	// Current total size of buffer
	BYTE		*m_pbData;

	ULONG		m_iCurrSeqStack;	// Curr position in the sequence stack.
	SEQ_STACK	m_rgiSeqStack[MAX_BER_STACK]; // Stack used for keeping track of sequences.

	ULONG		m_cbSeq;		// # of bytes in the current sequence.
	ULONG		m_iSeqStart;	// Starting position of the current sequence.
	union {
		BOOL	f;
		LONG	l;
		BYTE	*pb;
	} m_Value;

    // PRIVATE DEBUG ------------------------------------------
    // MESSAGE MAPS -------------------------------------------
};

#ifdef  INLINE
#endif // INLINE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\ldap.h ===
/*--------------------------------------------------------------------------
    ldap.h
        
        Base LDAP protocol typedefs & defines.  
		Some basic comments:
			All tags are CCFTTTTT
				where	CC - Tag class (00=Universal, 01=Application wide, 
										10=Context-specific, 11=private use).
						F  - The form (0=Primitive, 1=Constructed)
					TTTTT  - The tag #.


    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        robertc     Rob Carney

    History:
        04-02-96	robertc     Created.
  --------------------------------------------------------------------------*/
#ifndef _LDAP_H
#define _LDAP_H

#define	LDAP_VERSION		2

#define IPPORT_LDAP			389
#define IPPORT_LDAP_SECURE	390

// LDAP commands.  All tags are CCFTTTTT where
#define LDAP_BIND_CMD			0x60	// application + constructed.
#define LDAP_UNBIND_CMD			0x42	// application + primitive.
#define LDAP_SEARCH_CMD			0x63	// application + constructed.
#define	LDAP_MODIFY_CMD			0x66	// application + constructed.
#define LDAP_ADD_CMD			0x68	// application + constructed.
#define	LDAP_DELETE_CMD			0x4a	// application + primitive.
#define LDAP_MODRDN_CMD			0x6c	// application + constructed.
#define	LDAP_COMPARE_CMD		0x6e	// application + constructed.
#define	LDAP_ABANDON_CMD		0x50	// application + primitive.
#define LDAP_INVALID_CMD		0xff	

// Reponses/Results.
#define LDAP_BIND_RES			0x61	// application + constructed.
#define LDAP_SEARCH_ENTRY		0x64	// application + constructed.	Used if there were hits.
#define LDAP_SEARCH_RESULTCODE	0x65	// application + constructed.	Result sent if there were no hits.
#define LDAP_MODIFY_RES			0x67	// application + constructed.
#define LDAP_ADD_RES			0x69	// application + constructed.
#define LDAP_DELETE_RES			0x6b	// application + constructed.
#define LDAP_MODRDN_RES			0x6d	// application + constructed.
#define LDAP_COMPARE_RES		0x6f	// application + constructed.
#define LDAP_INVALID_RES		0xff	// application + constructed.

// Result Codes.
typedef enum {	
	LDAP_SUCCESS=0x00,				LDAP_OPERATIONS_ERROR=0x01,			LDAP_PROTOCOL_ERROR=0x02, 
	LDAP_TIMELIMIT_EXCEEDED=0x03,	LDAP_SIZELIMIT_EXCEEDED=0x04,		LDAP_COMPARE_FALSE=0x05,
	LDAP_COMPARE_TRUE=0x06,			LDAP_AUTH_METHOD_NOT_SUPPORTED=0x07,LDAP_STRONG_AUTH_REQUIRED=0x08,
	LDAP_NO_SUCH_ATTRIBUTE=0x10,	LDAP_UNDEFINED_TYPE=0x11,			LDAP_INAPPROPRIATE_MATCHING=0x12,
	LDAP_CONSTRAINT_VIOLATION=0x13,	LDAP_ATTRIBUTE_OR_VALUE_EXISTS=0x14,LDAP_INVALID_SYNTAX=0x15,
	LDAP_NO_SUCH_OBJECT=0x20,		LDAP_ALIAS_PROBLEM=0x21,			LDAP_INVALID_DN_SYNTAX=0x22,
	LDAP_IS_LEAF=0x23,				LDAP_ALIAS_DEREF_PROBLEM=0x24,		LDAP_INAPPROPRIATE_AUTH=0x30,
	LDAP_INVALID_CREDENTIALS=0x31,	LDAP_INSUFFICIENT_RIGHTS=0x32,		LDAP_BUSY=0x33,
	LDAP_UNAVAILABLE=0x34,			LDAP_UNWILLING_TO_PERFORM=0x35,		LDAP_LOOP_DETECT=0x36,
	LDAP_NAMING_VIOLATION=0x40,		LDAP_OBJECT_CLASS_VIOLATION=0x41,	LDAP_NOT_ALLOWED_ON_NONLEAF=0x42,
	LDAP_NOT_ALLOWED_ON_RDN=0x43,	LDAP_ALREADY_EXISTS=0x44,			LDAP_NO_OBJECT_CLASS_MODS=0x45,
	LDAP_RESULTS_TOO_LARGE=0x46,	LDAP_OTHER=0x50,					LDAP_SERVER_DOWN=0x51,
	LDAP_LOCAL_ERROR=0x52,			LDAP_ENCODING_ERROR=0x53,			LDAP_DECODING_ERROR=0x54,
	LDAP_TIMEOUT=0x55,				LDAP_AUTH_UNKNOWN=0x56,				LDAP_FILTER_ERROR=0x57,
	LDAP_USER_CANCELLED=0x58,		LDAP_PARAM_ERROR=0x59,				LDAP_NO_MEMORY=0x5a
} RETCODE;

// Bind request authorization types.
#define	BIND_NONE		0x00
#define BIND_SIMPLE		0x80		// context specific + primitive.
#define BIND_SIMPLE_C	0xa0		// context specific + contructed
#define BIND_KRBV41		0x81		// context specific + primitive.
#define BIND_KRBV42		0x82		// context specific + primitive.
#define BIND_SSPI_NEGOTIATE	0x8a	// context specific + primitive
#define BIND_SSPI_RESPONSE	0x8b	// context specific + primitive
#define BIND_KRBV4		0xff

//
// Filter types.
#define LDAP_FILTER_AND			0xa0	// context specific + constructed -	SET OF Filters.
#define LDAP_FILTER_OR			0xa1	// context specific + constructed -	SET OF Filters.
#define LDAP_FILTER_NOT			0xa2	// context specific + constructed - Filter
#define LDAP_FILTER_EQUALITY	0xa3	// context specific + constructed - AttributeValueAssertion.
#define LDAP_FILTER_SUBSTRINGS	0xa4	// context specific + constructed - SubstringFilter
#define LDAP_FILTER_GE			0xa5	// context specific + constructed - AttributeValueAssertion.
#define LDAP_FILTER_LE			0xa6	// context specific + constructed - AttributeValueAssertion.
#define LDAP_FILTER_PRESENT		0x87	// context specific + primitive   -	AttributeType.
#define LDAP_FILTER_APPROX		0xa8	// context specific + constructed -	AttributeValueAssertion.

//
// Scope of search.
#define LDAP_SCOPE_BASE			0x00
#define LDAP_SCOPE_ONELEVEL		0x01
#define LDAP_SCOPE_SUBTREE		0x02

//
// Alias dereferencing in searches.
#define LDAP_DEREF_NEVER		0x00
#define LDAP_DEREF_SEARCHING	0x01
#define LDAP_DEREF_FINDING		0x02
#define LDAP_DEREF_ALWAYS		0x03

//
// Substring filter choices
#define LDAP_SUBSTRING_INITIAL	0x80	// context specific + primitive   
#define LDAP_SUBSTRING_ANY		0x81	// context specific + primitive   
#define LDAP_SUBSTRING_FINAL	0x82	// context specific + primitive   

//
// Modify operations
#define LDAP_MODIFY_ADD			0x00
#define LDAP_MODIFY_DELETE		0x01
#define LDAP_MODIFY_REPLACE		0x02

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\ldapber.cxx ===
/*--------------------------------------------------------------------------
    ldapber.cxx

        This module contains the implementation for the LDAP Basic Encoding
		Rules (BER) class.  It is intended to be built for both client and
		server.

    Copyright (C) 1993 Microsoft Corporation
    All rights reserved.

    Authors:
        robertc     Rob Carney

    History:
        04-17-96	robertc     Created.
  --------------------------------------------------------------------------*/
#include "ldappch.h"

#ifdef CLIENT
#define ALLOCATE(cb) LocalAlloc(LMEM_FIXED, cb)
#define FREE LocalFree
#else
//CPool  CLdapBer::m_cpool(CLIENT_CONNECTION_SIGNATURE_VALID);
//#define Assert(x)	_ASSERT(x)
#define ALLOCATE(cb) malloc(cb)
#define FREE free
#endif


//
// CLdapBer Implementation
//
CLdapBer::CLdapBer()
{
	m_cbData	 = 0;
	m_cbDataMax	 = 0;
	m_pbData	 = NULL;
	m_iCurrPos	 = 0;
	m_cbSeq		 = 0;
	m_iSeqStart  = 0;
	m_fLocalCopy = TRUE;

	m_iCurrSeqStack = 0;
}


CLdapBer::~CLdapBer()
{
	Reset();

	if (m_pbData && m_fLocalCopy)
		FREE(m_pbData);
	m_cbDataMax	= 0;
}


/*!-------------------------------------------------------------------------
	CLdapBer::Reset
		Resets the class.
  ------------------------------------------------------------------------*/
void CLdapBer::Reset()
{
	m_cbData	= 0;
	m_iCurrPos	= 0;
	m_cbSeq		= 0;
	m_iSeqStart = 0;

	m_iCurrSeqStack = 0;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrLoadBer
		This routine loads the BER class from an input source data buffer
		that was received from the server.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrLoadBer(BYTE *pbSrc, ULONG cbSrc, BOOL fLocalCopy/*=TRUE*/)
{
	BYTE	*pbEnd;
	ULONG	iCurr, cbT;
	HRESULT	hr;

	Reset();

	if (!fLocalCopy)
	{
		// Just keep a reference so free any memory we once had.
		if (m_pbData && m_fLocalCopy)
		{
			FREE(m_pbData);
			m_pbData = NULL;
			m_cbDataMax	= 0;
		}

		m_pbData = pbSrc;
		m_fLocalCopy = FALSE;
	}
	else
	{
		m_fLocalCopy = TRUE;
	
		hr = HrEnsureBuffer(cbSrc, TRUE);
		if (FAILED(hr))
			return hr;
		
		CopyMemory(m_pbData, pbSrc, cbSrc);
	}

	m_cbData = cbSrc;

	//
	// Get at the sequence length and make sure we have all the data.
	HrSkipTag();
	GetCbLength(m_pbData + m_iCurrPos, &cbT);
	HrPeekLength(&m_cbSeq);
	if (m_cbSeq > (m_cbData - m_iCurrPos - cbT))
		return E_FAIL;

	HrUnSkipTag();

	m_cbSeq	= m_cbData;

	return NOERROR;
}


/*!-------------------------------------------------------------------------
	CLdapBer::FCheckSequenceLength
		This is a static function that checks to see if the input buffer
		contains the full length field.  If so, the length of the sequence
		is returned along with the position of the first value in the list.
  ------------------------------------------------------------------------*/
BOOL CLdapBer::FCheckSequenceLength(BYTE *pbInput, ULONG cbInput, ULONG *pcbSeq, ULONG *piValuePos)
{
	ULONG cbLen;

	// Assume Tag is 1 byte and length is at least 1 byte.
	if (cbInput >= 2)
	{
		GetCbLength(pbInput+1, &cbLen);
		if (cbInput >= (1 + cbLen))
		{
			*piValuePos = 1;
			if (SUCCEEDED(HrGetLength(pbInput, pcbSeq, piValuePos)))
				return TRUE;
		}
	}
	return FALSE;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrStartReadSequence
		Start a sequence for reading.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrStartReadSequence(ULONG ulTag/*=BER_SEQUENCE*/)
{
	HRESULT hr;
	ULONG	iPos, cbLength;

	if ((ULONG)m_pbData[m_iCurrPos] != ulTag)
	{
		return E_INVALIDARG;
	}
	m_iCurrPos++;			// Skip over the tag.

	GetCbLength(m_pbData + m_iCurrPos, &cbLength);	// Get the # bytes in the length field.

	hr = HrPushSeqStack(m_iCurrPos, cbLength, m_iSeqStart, m_cbSeq);

	if (SUCCEEDED(hr))
	{
		// Get the length of the sequence.
		hr = HrGetLength(&m_cbSeq);
		if (FAILED(hr))
			HrPopSeqStack(&iPos, &cbLength, &m_iSeqStart, &m_cbSeq);
		else
			m_iSeqStart = m_iCurrPos;	// Set to the first position in the sequence.
	}

	if (m_iCurrPos > m_cbData)
	{
		Assert(m_iCurrPos <= m_cbData);
		hr = E_INVALIDARG;
	}
	
	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrEndReadSequence
		Ends a read sequence and restores the current sequence counters.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrEndReadSequence()
{
	ULONG		cbSeq;
	ULONG		iPos, iPosSave, cbLength;
	SEQ_STACK	seqstack;
	HRESULT		hr;

	hr = HrPopSeqStack(&m_iCurrPos, &cbLength, &m_iSeqStart, &m_cbSeq);

	// Now position the current position to the end of the sequence.
	// m_iCurrPos is now pointing to the length field of the sequence.
	iPos = m_iCurrPos;

	if (SUCCEEDED(hr))
		{
		hr = HrGetLength(&cbSeq);
		if (SUCCEEDED(hr))
			{
			// Set the current position to the end of the sequence.
			m_iCurrPos = iPos + cbSeq + cbLength;	
			if (m_iCurrPos > m_cbData)
				hr = E_INVALIDARG;
			}
		}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrStartWriteSequence
		Start a sequence for writing.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrStartWriteSequence(ULONG ulTag/*=BER_SEQUENCE*/)
{
	HRESULT	hr;
	ULONG	cbLength = 3;	// BUGBUG: Defaults to 2 byte lengths

	if (FAILED(hr = HrEnsureBuffer(cbLength + 1)))
		return hr;

	m_pbData[m_iCurrPos++] = (BYTE)ulTag;

	hr = HrPushSeqStack(m_iCurrPos, cbLength, m_iSeqStart, m_cbSeq);

	m_iCurrPos += cbLength;	// Skip over length
	m_cbData = m_iCurrPos;

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrEndWriteSequence
		Ends a write sequence, by putting the sequence length field in.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrEndWriteSequence()
{
	HRESULT		hr;
	ULONG		cbSeq;
	ULONG		iPos, iPosSave, cbLength;
	SEQ_STACK	seqstack;

	hr = HrPopSeqStack(&iPos, &cbLength, &m_iSeqStart, &m_cbSeq);

	if (SUCCEEDED(hr))
	{
		// Get the length of the current sequence.
		cbSeq = m_iCurrPos - iPos - cbLength;
		
		// Save & set the current position.
		iPosSave = m_iCurrPos;
		m_iCurrPos = iPos;

		hr = HrSetLength(cbSeq, cbLength);
		m_iCurrPos = iPosSave;
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrPushSeqStack
		Pushes the current value on the sequence stack.  
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrPushSeqStack(ULONG iPos, ULONG cbLength, ULONG iParentSeqStart, ULONG cbParentSeq)
{
	ULONG	cb;

	Assert(m_iCurrSeqStack < MAX_BER_STACK);
	if (m_iCurrSeqStack >= MAX_BER_STACK)
		return E_OUTOFMEMORY;

	m_rgiSeqStack[m_iCurrSeqStack].iPos     = iPos;
	m_rgiSeqStack[m_iCurrSeqStack].cbLength = cbLength;
	m_rgiSeqStack[m_iCurrSeqStack].iParentSeqStart = iParentSeqStart;
	m_rgiSeqStack[m_iCurrSeqStack].cbParentSeq     = cbParentSeq;
	m_iCurrSeqStack++;

	return NOERROR;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrPopSeqStack
		Ends a read sequence.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrPopSeqStack(ULONG *piPos, ULONG *pcbLength, ULONG *piParentSeqStart, ULONG *pcbParentSeq)
{
	if (m_iCurrSeqStack == 0)
	{
		Assert(m_iCurrSeqStack != 0);
		return E_INVALIDARG;
	}

	--m_iCurrSeqStack;
	*piPos     = m_rgiSeqStack[m_iCurrSeqStack].iPos;
	*pcbLength = m_rgiSeqStack[m_iCurrSeqStack].cbLength;
	*piParentSeqStart = m_rgiSeqStack[m_iCurrSeqStack].iParentSeqStart;
	*pcbParentSeq     = m_rgiSeqStack[m_iCurrSeqStack].cbParentSeq;

	return NOERROR;
}


/*!-------------------------------------------------------------------------
	CLdapBer::FSetCurrPos
		Sets the current position to the input position index.
  ------------------------------------------------------------------------*/
HRESULT	CLdapBer::FSetCurrPos(ULONG iCurrPos)
{	
	if (iCurrPos >= m_cbData) 
		return E_FAIL;

	m_iCurrPos = iCurrPos;
	return NOERROR; 
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrSkipValue
		This routine skips over the current BER value.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrSkipValue()
{
	return E_NOTIMPL;
}

/*!-------------------------------------------------------------------------
	CLdapBer::HrSkipTag
		Skips over the current tag.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrSkipTag()
{
	m_iCurrPos++;

	return NOERROR;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrUnSkipTag
		Goes back to the tag given that we're currently at the length
		field.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrUnSkipTag()
{
	m_iCurrPos--;

	return NOERROR;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrPeekTag
		This routine gets the current tag, but doesn't increment the
		current position.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrPeekTag(ULONG *pulTag)
{
	ULONG	iPos;

	iPos = m_iCurrPos;

	*pulTag = (ULONG)m_pbData[iPos];

	return NOERROR;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrGetValue
		This routine gets an integer value from the current BER entry.  The
		default tag is an integer, but can Tagged with a different value
		via ulTag.  
		Returns: NOERROR, E_INVALIDARG, E_OUTOFMEMORY
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrGetValue(LONG *pi, ULONG ulTag/*=BER_INTEGER*/)
{
	HRESULT hr;
	ULONG	cb;
	ULONG	ul;

	ul = (ULONG)m_pbData[m_iCurrPos++];	// TAG

	if (ul != ulTag)
	{
		Assert(ul == ulTag);
		return E_INVALIDARG;
	}

	hr = HrGetLength(&cb);

	if (SUCCEEDED(hr) && (m_iCurrPos < m_cbData))
	{		 
		GetInt(m_pbData + m_iCurrPos, cb, pi);
		m_iCurrPos += cb;
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrGetValue
		This routine gets a string value from the current BER entry.  If
		the current BER entry isn't an integer type, then E_INVALIDARG is
		returned.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrGetValue(TCHAR *szValue, ULONG cbValue, ULONG ulTag/*=BER_OCTETSTRING*/)
{
	HRESULT	hr;
	ULONG	cb, ul;

	ul = (ULONG)m_pbData[m_iCurrPos++];	// TAG

	if (ul != ulTag)
	{
		Assert(ul == ulTag);
		return E_INVALIDARG;
	}

	hr = HrGetLength(&cb);

	szValue[0] = '\0';

	if (SUCCEEDED(hr) && (m_iCurrPos < m_cbData))
	{		 
		if (cb >= cbValue)
		{
			Assert(cb < cbValue);
			hr = E_INVALIDARG;
		}
		else
		{
			// Get the string.
			CopyMemory(szValue, m_pbData + m_iCurrPos, cb);
			szValue[cb] = '\0';
			m_iCurrPos += cb;
		}
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrGetBinaryValue
		This routine gets a binary value from the current BER entry.  If
		the current BER entry isn't the right type, then E_INVALIDARG is
		returned.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrGetBinaryValue(BYTE *pbBuf, ULONG cbBuf, ULONG ulTag/*=BER_OCTETSTRING*/)
{
	HRESULT	hr;
	ULONG	cb, ul;

	ul = (ULONG)m_pbData[m_iCurrPos++];	// TAG

	if (ul != ulTag)
	{
		Assert(ul == ulTag);
		return E_INVALIDARG;
	}

	hr = HrGetLength(&cb);

	if (SUCCEEDED(hr) && (m_iCurrPos < m_cbData))
	{		 
		if (cb >= cbBuf)
		{
			Assert(cb < cbBuf);
			hr = E_INVALIDARG;
		}
		else
		{
			// Get the string.
			CopyMemory(pbBuf, m_pbData + m_iCurrPos, cb);
			m_iCurrPos += cb;
		}
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrGetEnumValue
		This routine gets an enumerated value from the current BER entry.  If
		the current BER entry isn't an enumerated type, then E_INVALIDARG is
		returned.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrGetEnumValue(LONG *pi)
{
	HRESULT	hr;
	ULONG	cb;
	ULONG	cbLength;
	ULONG	ul;

	ul = (ULONG)m_pbData[m_iCurrPos++];	// TAG

	if (ul != BER_ENUMERATED)
	{
		Assert(ul == BER_ENUMERATED);
		return E_INVALIDARG;
	}

	hr = HrGetLength(&cb);

	if (SUCCEEDED(hr) && (m_iCurrPos < m_cbData))
	{		 
		GetInt(m_pbData + m_iCurrPos, cb, pi);
		m_iCurrPos += cb;
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrGetStringLength
		This routine gets the length of the current BER entry, which is
		assumed to be a string.  If the current BER entry's tag doesn't
		match ulTag, E_INVALIDARG is returned
  ------------------------------------------------------------------------*/
HRESULT
CLdapBer::HrGetStringLength(int *pcbValue, ULONG ulTag)
{
	ULONG	ul;
	ULONG	cbLength;
	int 	iCurrPosSave = m_iCurrPos;
	HRESULT	hr;

	ul = (ULONG)m_pbData[m_iCurrPos++];	// TAG

	if (ul != ulTag)
	{
		Assert(ul == ulTag);
		return E_INVALIDARG;
	}

	hr = HrGetLength((ULONG *)pcbValue);
	m_iCurrPos = iCurrPosSave;
	return hr;
}

/*!-------------------------------------------------------------------------
	CLdapBer::HrAddValue
		This routine puts an integer value in the BER buffer.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrAddValue(LONG i, ULONG ulTag/*=BER_INTEGER*/)
{
	HRESULT hr;
	LONG	iValue;
	ULONG	cbInt;
	DWORD	dwMask = 0xff000000;
	DWORD	dwHiBitMask = 0x80000000;
	
	if (i == 0)
	{
		cbInt = 1;
	}
	else
	{
		cbInt = sizeof(LONG);
		while (dwMask && !(i & dwMask))
		{
			dwHiBitMask >>= 8;
			dwMask >>= 8;
			cbInt--;
		}
		if (!(i & 0x80000000))
		{
			// It was a positive number so make sure we allow for upper most bit being set.
			// Make sure we send an extra byte since it's not a negative #.
			if (i & dwHiBitMask)
				cbInt++;
		}
	}

	hr = HrEnsureBuffer(1 + 3 + cbInt); // 1 for tag, 3 for length
	if (FAILED(hr))
		return hr;

	m_pbData[m_iCurrPos++] = (BYTE)ulTag;

	hr = HrSetLength(cbInt);
	if (SUCCEEDED(hr))
	{
		AddInt(m_pbData + m_iCurrPos, cbInt, i);

		m_iCurrPos += cbInt;

		m_cbData = m_iCurrPos;
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrAddValue
		Puts a string into the BER buffer.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrAddValue(const TCHAR *szValue, ULONG ulTag)
{
	HRESULT	hr;
	ULONG	cbValue = strlen(szValue);

	hr = HrEnsureBuffer(1 + 3 + cbValue); // 1 for tag, 3 for len
	if (FAILED(hr))
		return hr;

	m_pbData[m_iCurrPos++] = (BYTE)ulTag;

	hr = HrSetLength(cbValue);
	if (SUCCEEDED(hr))
	{
		CopyMemory(m_pbData + m_iCurrPos, szValue, cbValue);

		m_iCurrPos += cbValue;

		m_cbData = m_iCurrPos;
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrAddBinaryValue
		Puts a binary value into the BER buffer.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrAddBinaryValue(BYTE *pbValue, ULONG cbValue, ULONG ulTag)
{
	HRESULT	hr;

	hr = HrEnsureBuffer(1 + 3 + cbValue); // 1 for tag, 3 for len
	if (FAILED(hr))
		return hr;

	m_pbData[m_iCurrPos++] = (BYTE)ulTag;

	hr = HrSetLength(cbValue);
	if (SUCCEEDED(hr))
	{
		CopyMemory(m_pbData + m_iCurrPos, pbValue, cbValue);

		m_iCurrPos += cbValue;

		m_cbData = m_iCurrPos;
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrSetLength
		Sets the length of cb to the current position in the BER buffer.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrSetLength(ULONG cb, ULONG cbLength/*=0xffffffff*/)
{
	// Short or long version of length ?
	if (((cb <= 0x7f) && (cbLength == 0xffffffff)) || (cbLength == 1))
	{
		m_pbData[m_iCurrPos++] = (BYTE)cb;
	}
	else if (((cb <= 0x7fff) && (cbLength == 0xffffffff)) || (cbLength == 3))
	{
		// Two byte length
		m_pbData[m_iCurrPos++] = 0x82;
		m_pbData[m_iCurrPos++] = (BYTE)((cb>>8) & 0x00ff);
		m_pbData[m_iCurrPos++] = (BYTE)(cb & 0x00ff);
	}
	else if (((cb < 0x7fffffff) && (cbLength == 0xffffffff)) || (cbLength == 5))
	{
		// Don't bother with 3 byte length, go directly to 4 byte.
		m_pbData[m_iCurrPos++] = 0x84;
		m_pbData[m_iCurrPos++] = (BYTE)((cb>>24) & 0x00ff);
		m_pbData[m_iCurrPos++] = (BYTE)((cb>>16) & 0x00ff);
		m_pbData[m_iCurrPos++] = (BYTE)((cb>>8) & 0x00ff);
		m_pbData[m_iCurrPos++] = (BYTE)(cb & 0x00ff);
	}
	else
	{
		Assert(cb < 0x7fffffff);
		return E_INVALIDARG;
	}

	return NOERROR;
}


/*!-------------------------------------------------------------------------
	CLdapBer::GetCbLength
		Gets the # of bytes required for the length field in the current
		position in the BER buffer.
  ------------------------------------------------------------------------*/
void CLdapBer::GetCbLength(BYTE *pbData, ULONG *pcbLength)
{
	ULONG	cbLength;
	ULONG	i, cb;

	// Short or long version of the length ?
	if (*pbData & 0x80)
	{
		*pcbLength = 1;
		*pcbLength += *pbData & 0x7f;
	}
	else 
	{
		// Short version of the length.
		*pcbLength = 1;
	}
}



/*!-------------------------------------------------------------------------
	CLdapBer::HrGetLength
		Gets the length from the current position in the BER buffer.  Only
		definite lengths are supported.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrGetLength(ULONG *pcb)
{
	return HrGetLength(m_pbData, pcb, &m_iCurrPos);
}



/*!-------------------------------------------------------------------------
	CLdapBer::HrPeekLength
		Gets the length from the current position in the BER buffer without
		incrementing the current pointer.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrPeekLength(ULONG *pcb)
{
	ULONG iPos = m_iCurrPos;

	return HrGetLength(m_pbData, pcb, &iPos);
}



/*!-------------------------------------------------------------------------
	CLdapBer::HrGetLength
		This is a private function that gets the length given a current 
		input position. 
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrGetLength(BYTE *pbData, ULONG *pcb, ULONG *piPos)
{
	ULONG	cbLength;
	ULONG	i, cb, iPos;

	iPos = *piPos;

	GetCbLength(pbData + iPos, &cbLength);

	// Short or long version of the length ?
	if (cbLength == 1)
	{
		cb = pbData[iPos++] & 0x7f;
	}
	else if (cbLength <= 5)
	{
		// Account for the overhead byte.cbLength field.
		cbLength--;	
		iPos++;

		cb = pbData[iPos++];
		for (i=1; i < cbLength; i++)
		{
			cb <<= 8;
			cb |= pbData[iPos++];
		}
	}
	else
	{
		// We don't support lengths > 2^32.
		Assert(cbLength <= 5);
		return E_INVALIDARG;
	}

	*piPos = iPos;
	*pcb   = cb;

	return NOERROR;
}



/*!-------------------------------------------------------------------------
	CLdapBer::GetInt
		Gets an integer from a BER buffer. 
  ------------------------------------------------------------------------*/
void CLdapBer::GetInt(BYTE *pbData, ULONG cbValue, LONG *plValue)
{
	ULONG	ulVal=0, ulTmp=0;
	ULONG	cbDiff;
	BOOL	fSign = FALSE;

	// We assume the tag & length have already been taken off and we're
	// at the value part.

	cbDiff = sizeof(LONG) - cbValue;
	// See if we need to sign extend;
	if ((cbDiff > 0) && (*pbData & 0x80))
		fSign = TRUE;

	while (cbValue > 0)
	{
		ulVal <<= 8;
		ulVal |= (ULONG)*pbData++;
		cbValue--;
	}

	// Sign extend if necessary.
	if (fSign)
	{
		*plValue = 0x80000000;
		*plValue >>= cbDiff * 8;
	}
	else
		*plValue = (LONG) ulVal;
}


/*!-------------------------------------------------------------------------
	CLdapBer::AddInt
		Adds an integer to the input pbData buffer.
  ------------------------------------------------------------------------*/
void CLdapBer::AddInt(BYTE *pbData, ULONG cbValue, LONG lValue)
{
	ULONG i;

	for (i=cbValue; i > 0; i--)
	{
		*pbData++ = (BYTE)(lValue >> ((i - 1) * 8)) & 0xff;
	}
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrEnsureBuffer
		Ensures that we've got room to put cbNeeded more bytes into the buffer.
  ------------------------------------------------------------------------*/
HRESULT
CLdapBer::HrEnsureBuffer(ULONG cbNeeded, BOOL fExact)
{
	ULONG cbNew;
	BYTE *pbT;

	if (cbNeeded + m_cbData < m_cbDataMax)
		return NOERROR;

	Assert(m_fLocalCopy == TRUE);
	if (!m_fLocalCopy)
		return E_INVALIDARG;

	if (fExact)
		{
		cbNew = cbNeeded + m_cbData;
		}		
	else
		{
		if (cbNeeded > CB_DATA_GROW)
			cbNew = m_cbDataMax + cbNeeded;
		else
			cbNew = m_cbDataMax + CB_DATA_GROW;
		}
	pbT = (BYTE *)ALLOCATE(cbNew);
	if (!pbT)
		return E_OUTOFMEMORY;
	if (m_pbData)
		{
		CopyMemory(pbT, m_pbData, m_cbData);
		FREE(m_pbData);
		}
	m_pbData = pbT;
	m_cbDataMax = cbNew;
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\ldapclip.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client private header
//
//	History:
//		davidsan	05/08/96	Created
//
//--------------------------------------------------------------------------------------------

#ifndef _LDAPCLIP_H
#define _LDAPCLIP_H

// transaction type
const DWORD xtypeNil				= 0;
const DWORD xtypeBind				= 1;
const DWORD xtypeSearch				= 2;
const DWORD xtypeUnbind				= 3;
const DWORD xtypeAbandon			= 4;
const DWORD xtypeBindSSPINegotiate	= 5;
const DWORD xtypeBindSSPIResponse	= 6;
const DWORD xtypeModify				= 7;
const DWORD xtypeAdd				= 8;
const DWORD xtypeModifyRDN			= 9;
const DWORD xtypeCompare			= 10;
const DWORD xtypeDelete				= 11;

class CLdapClient : public ILdapClient
{
public:
	CLdapClient(int iVerLdap);
	~CLdapClient();
	
	STDMETHODIMP			QueryInterface(REFIID riid, LPVOID FAR *ppvObj);
	STDMETHODIMP_(ULONG)	AddRef(void);
	STDMETHODIMP_(ULONG)	Release(void);
	
	STDMETHODIMP			HrConnect(char *szServer, USHORT usPort);
	STDMETHODIMP			HrDisconnect(void);
	STDMETHODIMP			HrIsConnected(void);

	STDMETHODIMP			HrBindSimple(char *szDN, char *szPass, PXID pxid);
	STDMETHODIMP			HrGetBindResponse(XID xid, DWORD timeout);
	STDMETHODIMP			HrUnbind(void);

	STDMETHODIMP			HrBindSSPI(char *szDN, char *szUser, char *szPass, BOOL fPrompt, DWORD timeout);
	STDMETHODIMP			HrSendSSPINegotiate(char *szDN, char *szUser, char *szPass, BOOL fPrompt, PXID pxid);
	STDMETHODIMP			HrGetSSPIChallenge(XID xid, BYTE *pbBuf, int cbBuf, int *pcbChallenge, DWORD timeout);
	STDMETHODIMP			HrSendSSPIResponse(BYTE *pbChallenge, int cbChallenge, PXID pxid);

	STDMETHODIMP			HrSearch(PSP psp, PXID pxid);
	STDMETHODIMP			HrGetSearchResponse(XID xid, DWORD timeout, POBJ *ppobj);
	STDMETHODIMP			HrFreePobjList(POBJ pobj);
	
	STDMETHODIMP			HrModify(char *szDN, PMOD pmod, PXID pxid);
	STDMETHODIMP			HrGetModifyResponse(XID xid, DWORD timeout);
	
	STDMETHODIMP			HrAdd(char *szDN, PATTR pattr, PXID pxid);
	STDMETHODIMP			HrGetAddResponse(XID xid, DWORD timeout);
	
	STDMETHODIMP			HrDelete(char *szDN, PXID pxid);
	STDMETHODIMP			HrGetDeleteResponse(XID xid, DWORD timeout);

	STDMETHODIMP			HrModifyRDN(char *szDN, char *szNewRDN, BOOL fDeleteOldRDN, PXID pxid);
	STDMETHODIMP			HrGetModifyRDNResponse(XID xid, DWORD timeout);

	STDMETHODIMP			HrCompare(char *szDN, char *szAttrib, char *szValue, PXID pxid);
	STDMETHODIMP			HrGetCompareResponse(XID xid, DWORD timeout);

	STDMETHODIMP			HrCancelXid(XID xid);
	
protected:
	friend void ReceiveData(PVOID, PVOID, int, int *);
	void					ReceiveData(PVOID pv, int cb, int *pcbReceived);
	
private:
	HRESULT					HrEncodeFilter(LBER *plber, PFILTER pfilter);
	HRESULT					HrEncodePattr(LBER *plber, PATTR pattr);
	HRESULT					HrEncodePmod(LBER *plber, PMOD pmod);

	HRESULT					HrWaitForPxd(PXD pxd, DWORD timeout, BOOL *pfDel);
	
	HRESULT					HrGetSimpleResponse(XID xid, DWORD xtype, ULONG ulTagResult, DWORD timeout);
	HRESULT					HrFromLdapResult(int iResult);
	
	CRITICAL_SECTION		m_cs;
	CRITICAL_SECTION		m_csRef;
	
	PSOCK					m_psock;
	BOOL					m_fConnected;
	
	ULONG					m_cRef;
	int						m_iVerLdap;
	char					m_szServer[MAX_PATH];
	
	// SSPI stuff
	HRESULT					HrGetCredentials(char *szUser, char *szPass);
	HRESULT					HrSendBindMsg(XID xid, char *szDN, int iAuth, void *pv, int cb);
	CredHandle				m_hCred;
	CtxtHandle				m_hCtxt;
	BOOL					m_fHasCred;
	BOOL					m_fHasCtxt;
};

#define VERIFY(fncall)				\
	if (FAILED(hr = fncall))		\
		{							\
		Assert(FALSE);				\
		goto LBail;					\
		}				

#endif // _LDAPCLIP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\ldapcli.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft LDAP Client.
//
//		All Interfaces that are exposed to a CLIENT.
//
//	History
//
//		davidsan	04-24-96	Created.
//
//--------------------------------------------------------------------------------------------

// OVERVIEW:
// The LDAP Client DLL defines an interface, ILdapClient, and a set of structure types
// listed below.  The ILdapClient interface provides a set of methods for communicating
// with an LDAP-based directory service.  The general approach taken is that calling an
// ILdapClient method such as HrSearch() will return a transaction ID, or XID.  This XID
// can then be used in subsequent calls to wait for and retrieve the server's response;
// an example would be the HrGetSearchResponse() method, which takes an XID and returns
// the server's response to that search transaction.  The HrGet*Response() functions can
// also be used to check if the response is present by providing a timeout value of 0, which
// will return immediately with LDAP_E_TIMEOUT if the data is not yet present.

#ifndef _LDAPCLI_H
#define _LDAPCLI_H

//--------------------------------------------------------------------------------------------
//
// INCLUDES.
//
//--------------------------------------------------------------------------------------------
#include <windows.h>
#include <objbase.h>

#include <ldaperr.h>
#include <ldap.h>

//--------------------------------------------------------------------------------------------
//
// DECLARATIONS.
//
//--------------------------------------------------------------------------------------------

#define		LDAP_VER_CURRENT		2
#define		INTERFACE_VER_CURRENT	1

//--------------------------------------------------------------------------------------------
//
// TYPE DEFINITIONS.
//
//--------------------------------------------------------------------------------------------

// NOTE!  Make the 'Next' pointer be the first thing in all these linked-list structures!

// Attribute value.
typedef struct _attrval
{
	struct _attrval		*pvalNext;
	char				*szVal;
} VAL, *PVAL;

// Attribute.  Contains an attribute name (also called attribute type) followed by a set
// of attribute values.
typedef struct _attribute
{
	struct _attribute	*pattrNext;
	char				*szAttrib;
	PVAL				pvalFirst;
} ATTR, *PATTR;

// Database Object.  Consists of a DN which identifies the object, followed by a set of
// attributes.
typedef struct _object
{
	struct _object		*pobjNext;
	char				*szDN;
	PATTR				pattrFirst;
} OBJ, *POBJ;

// attribute value assertion
typedef struct _ava
{
	char	*szAttrib;
	char	*szValue;
} AVA, *PAVA;

// substrings filter.   this is less general than the ldap spec.  cope.
typedef struct _substrings
{
	char	*szAttrib;
	char	*szInitial;
	char	*szAny;
	char	*szFinal;
} SUB, *PSUB;

// search filter
typedef struct _filter
{
	struct _filter		*pfilterNext;	// for chaining in sets
	DWORD				type;
	union
		{
		struct _filter	*pfilterSub;
		AVA				ava;
		SUB				sub;
		char			*szAttrib;
		};
} FILTER, *PFILTER;

// search params
typedef struct _searchparms
{
	char		*szDNBase;
	DWORD	  	scope;
	DWORD		deref;
	int			cRecordsMax;
	int			cSecondsMax;
	BOOL		fAttrsOnly;
	PFILTER		pfilter;
	int			cAttrib;
	char		**rgszAttrib;
} SP, *PSP;

// modify params
typedef struct _modparms
{
	struct _modparms	*pmodNext;
	int					modop;
	PATTR				pattrFirst;
} MOD, *PMOD;

typedef DWORD XID, *PXID; // transaction ID

interface ILdapClient;
typedef interface ILdapClient LCLI, *PLCLI;

interface ICLdapClient;
typedef interface ICLdapClient CLCLI, *PCLCLI;

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS.
//
//--------------------------------------------------------------------------------------------
//
// To get an LDAP client interface call this.
//
#ifdef __cplusplus
extern "C" {
#endif

__declspec(dllexport) HRESULT __cdecl HrCreateLdapClient(int iVerLdap, int iVerInterface, PLCLI *pplcli);
__declspec(dllexport) HRESULT __cdecl HrCreateCLdapClient(int iVerLdap, int iVerInterface, PCLCLI *ppclcli);
__declspec(dllexport) HRESULT __cdecl HrFreePobjList(POBJ pobj);

#ifdef __cplusplus
}
#endif

//--------------------------------------------------------------------------------------------
//
// INTERFACES: Definitions.
//
//--------------------------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE ILdapClient

DECLARE_INTERFACE_(ILdapClient, IUnknown)
{
	// IUnknown:
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID FAR *ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG, Release)			(THIS) PURE;

	// ILdapClient	

	STDMETHOD(HrConnect)				(THIS_ CHAR *szServer, USHORT usPort) PURE;
	STDMETHOD(HrDisconnect)				(THIS) PURE;
	STDMETHOD(HrIsConnected)			(THIS) PURE;

	STDMETHOD(HrBindSimple)				(THIS_ char *szDN, char *szPass, PXID pxid) PURE;
	STDMETHOD(HrGetBindResponse)		(THIS_ XID xid, DWORD timeout) PURE;
	STDMETHOD(HrUnbind)					(THIS) PURE; // this doesn't return an XID because there's no response

	// this function is a synchronous wrapper around the SSPI bind gunk
	//$ TODO: Pass in SSPI Package name (or support NTLM some other way)
	STDMETHOD(HrBindSSPI)				(THIS_ char *szDN, char *szUser, char *szPass, BOOL fPrompt, DWORD timeout) PURE;
	STDMETHOD(HrSendSSPINegotiate)		(THIS_ char *szDN, char *szUser, char *szPass, BOOL fPrompt, PXID pxid) PURE;
	STDMETHOD(HrGetSSPIChallenge)		(THIS_ XID xid, BYTE *pbBuf, int cbBuf, int *pcbChallenge, DWORD timeout) PURE;
	STDMETHOD(HrSendSSPIResponse)		(THIS_ BYTE *pbChallenge, int cbChallenge, PXID pxid) PURE;

	STDMETHOD(HrSearch)					(THIS_ PSP psp, PXID pxid) PURE;
	STDMETHOD(HrGetSearchResponse)		(THIS_ XID xid, DWORD timeout, POBJ *ppobj) PURE;

	STDMETHOD(HrModify)					(THIS_ char *szDN, PMOD pmod, PXID pxid) PURE;
	STDMETHOD(HrGetModifyResponse)		(THIS_ XID xid, DWORD timeout) PURE;
	
	STDMETHOD(HrAdd)					(THIS_ char *szDN, PATTR pattr, PXID pxid) PURE;
	STDMETHOD(HrGetAddResponse)			(THIS_ XID xid, DWORD timeout) PURE;
	
	STDMETHOD(HrDelete)					(THIS_ char *szDN, PXID pxid) PURE;
	STDMETHOD(HrGetDeleteResponse)		(THIS_ XID xid, DWORD timeout) PURE;

	STDMETHOD(HrModifyRDN)				(THIS_ char *szDN, char *szNewRDN, BOOL fDeleteOldRDN, PXID pxid) PURE;
	STDMETHOD(HrGetModifyRDNResponse)	(THIS_ XID xid, DWORD timeout) PURE;

	STDMETHOD(HrCompare)				(THIS_ char *szDN, char *szAttrib, char *szValue, PXID pxid) PURE;
	STDMETHOD(HrGetCompareResponse)		(THIS_ XID xid, DWORD timeout) PURE;

	STDMETHOD(HrCancelXid)				(THIS_ XID xid) PURE;
};

#undef INTERFACE
#define INTERFACE ICLdapClient

DECLARE_INTERFACE_(ICLdapClient, IUnknown)
{
	// IUnknown:
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID FAR *ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG, Release)			(THIS) PURE;
	
	STDMETHOD(HrSetServerName)			(THIS_ char *szServer, USHORT usPort) PURE;
	STDMETHOD(HrSetServerIPAddr)		(THIS_ SOCKADDR_IN *psin) PURE;
	
	STDMETHOD(HrSearch)					(THIS_ PSP psp, PXID pxid) PURE;
	STDMETHOD(HrGetSearchResponse)		(THIS_ XID xid, DWORD timeout, POBJ *ppobj) PURE;
	STDMETHOD(HrCancelXid)				(THIS_ XID xid) PURE;
};

// RFC1823 stuff
typedef struct ldap
{
	// these are publically accessible fields.  this is how you control the parameters
	// of your search calls.
	int				ld_deref;
	int				ld_timelimit;
	int				ld_sizelimit;
	int				ld_errno;
	
	// these are not publically accessible fields.  pretend you didn't see them.
	ILdapClient		*plcli;
} LDAP;

typedef struct berval
{
	unsigned long	bv_len;
	char			*bv_val;
} BERVAL;

#define LDAP_AUTH_NONE		0
#define LDAP_AUTH_SIMPLE	1
#define LDAP_AUTH_KRBV41	2
#define LDAP_AUTH_KRBV42	3

typedef OBJ LDAPMessage;

#define DLLEXPORT __declspec(dllexport)

#ifdef __cplusplus
extern "C" {
#endif

DLLEXPORT LDAP * __cdecl ldap_open(char *hostname, int portno);
DLLEXPORT int __cdecl ldap_bind_s(LDAP *ld, char *dn, char *cred, int method);
DLLEXPORT int __cdecl ldap_unbind(LDAP *ld);
DLLEXPORT int __cdecl ldap_search_s(LDAP *ld, char *base, int scope, char *filter, char *attrs[], int attrsonly, LDAPMessage **res);
DLLEXPORT int __cdecl ldap_search_st(LDAP *ld, char *base, int scope, char *filter, char *attrs[], int attrsonly, struct timeval *timeout, LDAPMessage **res);
DLLEXPORT int __cdecl ldap_msgfree(LDAPMessage *res);

// result parsing stuff
DLLEXPORT LDAPMessage * __cdecl ldap_first_entry(LDAP *ld, LDAPMessage *res);
DLLEXPORT LDAPMessage * __cdecl ldap_next_entry(LDAP *ld, LDAPMessage *entry);
DLLEXPORT int __cdecl ldap_count_entries(LDAP *ld, LDAPMessage *res);

DLLEXPORT char * __cdecl ldap_first_attribute(LDAP *ld, LDAPMessage *entry, void **ptr);
DLLEXPORT char * __cdecl ldap_next_attribute(LDAP *ld, LDAPMessage *entry, void **ptr);

DLLEXPORT char ** __cdecl ldap_get_values(LDAP *ld, LDAPMessage *entry, char *attr);
DLLEXPORT struct berval ** __cdecl ldap_get_values_len(LDAP *ld, LDAPMessage *entry, char *attr);
DLLEXPORT int __cdecl ldap_count_values(char **vals);
DLLEXPORT int __cdecl ldap_count_values_len(struct berval **vals);
DLLEXPORT int __cdecl ldap_value_free(char **vals);
DLLEXPORT int __cdecl ldap_value_free_len(struct berval **vals);

DLLEXPORT char * __cdecl ldap_get_dn(LDAP *ld, LDAPMessage *entry);
DLLEXPORT void __cdecl ldap_free_dn(char *dn);

#ifdef __cplusplus
}
#endif

#endif // _LDAPCLI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\ldaperr.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft LDAP Client.
//		
//		Client error codes.
//
//	Authors:
//
//		Robert Carney
//		davidsan	04/23/96	converted to real HRESULTS
//
//--------------------------------------------------------------------------------------------

#ifndef _LDAPERR_H
#define _LDAPERR_H

//--------------------------------------------------------------------------------------------
//
// New HRESULTS for use with LDAP.  We use FACILITY_ITF rather than obtaining our own
// facility for the time being; this might change, but it probably won't.
//
//--------------------------------------------------------------------------------------------

#define LDAP_E_VERSION				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8000)
#define LDAP_E_NOTCONNECTED			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8001)
#define LDAP_E_SOCKETCLOSED			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8002)
#define LDAP_E_HOSTNOTFOUND			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8003)
#define LDAP_E_INVALIDSOCKET		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8004)
#define LDAP_E_CANTCONNECT			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8005)
#define LDAP_E_HOSTDROPPED			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8006)
#define LDAP_E_NODATA				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8007)
#define LDAP_E_CANTSEND				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8008)
#define LDAP_E_NOTLOGGEDON			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8009)
#define LDAP_E_NETWORKDOWN			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x800a)
#define LDAP_E_LOSTCONNECTION		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x800b)
#define LDAP_E_ALREADYCONNECTED		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x800c)
#define LDAP_E_INVALIDXID			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x800d)
#define LDAP_E_INVALIDXTYPE			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x800e)
#define LDAP_E_TIMEOUT				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x800f)
#define LDAP_E_CANCELLED			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8010)
#define LDAP_E_UNEXPECTEDDATA		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8011)
#define LDAP_E_NOTENOUGHDATA		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8012)
#define LDAP_E_AUTHNOTAVAIL			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8013)
#define LDAP_E_BUFFERTOOSMALL		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8014)
#define LDAP_E_OUTOFSEQUENCE		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8015)

#define LDAP_S_TIMEEXCEEDED			MAKE_SCODE(SEVERITY_SUCCESS,	FACILITY_ITF, 0x8016)
#define LDAP_S_SIZEEXCEEDED			MAKE_SCODE(SEVERITY_SUCCESS,	FACILITY_ITF, 0x8017)

#define LDAP_E_OPERATIONS			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8020)
#define LDAP_E_PROTOCOL				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8021)
#define LDAP_E_AUTHMETHOD			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8022)
#define LDAP_E_STRONGAUTHREQUIRED	MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8023)
#define LDAP_E_NOSUCHATTRIBUTE		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8024)
#define LDAP_E_UNDEFINEDTYPE		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8025)
#define LDAP_E_MATCHING				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8026)
#define LDAP_E_CONSTRAINT			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8027)
#define LDAP_E_ATTRIBORVALEXISTS	MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8028)
#define LDAP_E_SYNTAX				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8029)
#define LDAP_E_NOSUCHOBJECT			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x802a)
#define LDAP_E_ALIAS				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x802b)
#define LDAP_E_DNSYNTAX				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x802c)
#define LDAP_E_ISLEAF				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x802d)
#define LDAP_E_ALIASDEREF			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x802e)
#define LDAP_E_AUTH					MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x802f)
#define LDAP_E_CREDENTIALS			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8030)
#define LDAP_E_RIGHTS				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8031)
#define LDAP_E_BUSY					MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8032)
#define LDAP_E_UNAVAILABLE			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8033)
#define LDAP_E_UNWILLING			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8034)
#define LDAP_E_LOOP					MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8035)
#define LDAP_E_NAMING				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8036)
#define LDAP_E_OBJECTCLASS			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8037)
#define LDAP_E_NOTALLOWEDONNONLEAF	MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8038)
#define LDAP_E_NOTALLOWEDONRDN		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8039)
#define LDAP_E_ALREADYEXISTS		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x803a)
#define LDAP_E_NOOBJECTCLASSMODS	MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x803b)
#define LDAP_E_RESULTSTOOLARGE		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x803c)
#define LDAP_E_OTHER				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x803d)
#define LDAP_E_SERVERDOWN			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x803e)
#define LDAP_E_LOCAL				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x803f)
#define LDAP_E_ENCODING				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8040)
#define LDAP_E_DECODING				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8041)
#define LDAP_E_AUTHUNKNOWN			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8042)
#define LDAP_E_FILTER				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8043)
#define LDAP_E_USERCANCELLED		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8044)

#endif // _LDAPERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\ldapmain.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996-97
//
//	Description:
//
//		Microsoft Internet LDAP Client DLL.
//
//	Authors:
//
//		Umesh Madan 
//		RobertC	4/17/96	Modified for LDAPCLI
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// INCLUDES
//
//--------------------------------------------------------------------------------------------
#include "ldappch.h"
#include "ldapsspi.h"

//--------------------------------------------------------------------------------------------
//
// GLOBALS
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// PROTOTYPES
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS
//
//--------------------------------------------------------------------------------------------

extern "C" BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD dwReason, LPVOID lpReserved)
{
	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
			{
			if (!FInitSocketDLL())
				{
				return FALSE;
				}
			g_hrInitSSPI = HrInitializeSSPI();
			} break;
			
		case DLL_PROCESS_DETACH:
			FreeSocketDLL();
			HrTerminateSSPI();
			break;
			
		default:
			break;	
	}
		
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\ldapsspi.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client SSPI support
//
//	History:
//		davidsan	05/08/96	Created
//
//--------------------------------------------------------------------------------------------

#ifndef _LDAPSSPI_H
#define _LDAPSSPI_H

extern HRESULT g_hrInitSSPI;
extern HRESULT HrInitializeSSPI();
extern HRESULT HrTerminateSSPI();

#endif // _LDAPSSPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\lt.cpp ===
/*--------------------------------------------------------------------------
	lt.cpp
	
		ldap test

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

	Authors:
		davidsan	Dave Sanderman

	History:
		04/25/96	davidsan	Created.
  --------------------------------------------------------------------------*/

#include "lt.h"

PLCLI g_plcli = NULL;

BOOL
FInit()
{
	return TRUE;
}

BOOL
FConnect(char *szServer)
{
	HRESULT hr;
	XID xid;
	
	hr = HrCreateLdapClient(LDAP_VER_CURRENT, INTERFACE_VER_CURRENT, &g_plcli);
	if (FAILED(hr))
		{
		printf("HrCreateLdapClient returned %08X\n", hr);
		return FALSE;
		}
	hr = g_plcli->HrConnect(szServer, IPPORT_LDAP);
	if (FAILED(hr))
		{
		printf("HrConnect returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrBindSimple("cn=alex weinart, c=us", NULL, &xid);
	if (FAILED(hr))
		{
		printf("HrBindSimple returned %08X\n", hr);
		return FALSE;
		}
	hr = g_plcli->HrGetBindResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrBindSimple returned %08X\n", hr);
		return FALSE;
		}
	return TRUE;	
}

char *g_rgszAttrib[] = {"title", "sn", "objectClass", "krbName"};

BOOL
FSearch()
{
	HRESULT hr;
	XID xid;
	POBJ pobj;
	POBJ pobjT;
	PATTR pattr;
	PVAL pval;
	SP sp;
	FILTER filter;
	FILTER filterS1;
	FILTER filterS2;
	FILTER filterSS1;
	FILTER filterSS2;
	FILTER filterSS3;

#ifdef OLDSEARCH	
	filter.type = LDAP_FILTER_AND;
	filter.pfilterSub = &filterS1;

		filterS1.type = LDAP_FILTER_OR;
		filterS1.pfilterSub = &filterSS1;
		filterS1.pfilterNext = &filterS2;
	
			filterSS1.type = LDAP_FILTER_EQUALITY;
			filterSS1.ava.szAttrib = "cn";
			filterSS1.ava.szValue = "sander";
			filterSS1.pfilterNext = &filterSS2;

			filterSS2.type = LDAP_FILTER_EQUALITY;
			filterSS2.ava.szAttrib = "sn";
			filterSS2.ava.szValue = "sander";
			filterSS2.pfilterNext = &filterSS3;

			filterSS3.type = LDAP_FILTER_EQUALITY;
			filterSS3.ava.szAttrib = "uid";
			filterSS3.ava.szValue = "sander";
			filterSS3.pfilterNext = NULL;

		filterS2.type = LDAP_FILTER_EQUALITY;
		filterS2.ava.szAttrib = "objectClass";
		filterS2.ava.szValue = "Person";
		filterS2.pfilterNext = NULL;
	
#else
	filter.type = LDAP_FILTER_SUBSTRINGS;
	filter.sub.szAttrib = "cn";
	filter.sub.szInitial = "davidsan";
	filter.sub.szAny = NULL;
	filter.sub.szFinal = NULL;

//	filter.type = LDAP_FILTER_EQUALITY;
//	filter.ava.szAttrib = "cn";
//	filter.ava.szValue = "davidsan4";
#endif

	sp.szDNBase = "c=US";
	sp.scope = LDAP_SCOPE_SUBTREE;
	sp.deref = LDAP_DEREF_ALWAYS;
	sp.cRecordsMax = 0;
	sp.cSecondsMax = 0;
	sp.fAttrsOnly = FALSE;
	sp.pfilter = &filter;
	sp.cAttrib = 4;
	sp.rgszAttrib = g_rgszAttrib;
	hr = g_plcli->HrSearch(&sp, &xid);
	if (FAILED(hr))
		{
		printf("HrSearch returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetSearchResponse(xid, INFINITE, &pobj);
	if (FAILED(hr))
		{
		printf("HrGetSearchResponse returned %08X\n", hr);
		return FALSE;
		}
	pobjT = pobj;
	while (pobjT)
		{
		printf("OBJ: %s\n", pobjT->szDN);
		pattr = pobjT->pattrFirst;
		while (pattr)
			{
			printf("  ATTR: %s\n", pattr->szAttrib);
			pval = pattr->pvalFirst;
			while (pval)
				{
				printf("    VAL: %s\n", pval->szVal);
				pval = pval->pvalNext;
				}
			pattr = pattr->pattrNext;
			}
		pobjT = pobjT->pobjNext;
		}
	HrFreePobjList(pobj);
		
	return TRUE;
}

void
SetPattr(PATTR pattr, PATTR pattrNext, char *szAttrib, PVAL pval)
{
	pattr->pattrNext = pattrNext;
	pattr->szAttrib = szAttrib;
	pattr->pvalFirst = pval;
}

void
SetPval(PVAL pval, PVAL pvalNext, char *szVal)
{
	pval->pvalNext = pvalNext;
	pval->szVal = szVal;
}

BOOL
FTestOtherStuff()
{
	HRESULT hr;
	XID xid;
	
	hr = g_plcli->HrDelete("c=us, o=my pants, cn=davidsan", &xid);
	if (FAILED(hr))
		{
		printf("HrDelete returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetDeleteResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetDeleteResponse returned %08X\n", hr);
		}
		
	hr = g_plcli->HrDelete("alex", &xid);
	if (FAILED(hr))
		{
		printf("HrDelete returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetDeleteResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetDeleteResponse returned %08X\n", hr);
		}
		
	hr = g_plcli->HrCompare("c=us, cn=davidsan@microsoft.com", "URL", "ftp://ftp.netcom.com/pub/sa/sandmann", &xid);
	if (FAILED(hr))
		{
		printf("HrCompare returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetCompareResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetCompareResponse returned %08X\n", hr);
		}
		
	hr = g_plcli->HrModifyRDN("foo", "bar", TRUE, &xid);
	if (FAILED(hr))
		{
		printf("HrModifyRDN returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetModifyRDNResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetModifyRDNResponse returned %08X\n", hr);
		}

	hr = g_plcli->HrModifyRDN("c=us, cn=alex weinart", "bar", TRUE, &xid);
	if (FAILED(hr))
		{
		printf("HrModifyRDN returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetModifyRDNResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetModifyRDNResponse returned %08X\n", hr);
		}
		
	// test add:  add an obj with dn "c=us, cn=davidsan" and some other props
	ATTR attr1;
	VAL val1;
	ATTR attr2;
	VAL val2;
	ATTR attr3;
	VAL val3;
	
	SetPattr(&attr1, &attr2, "uid", &val1);
	SetPval(&val1, NULL, "davidsan");
	
	SetPattr(&attr2, &attr3, "sn", &val2);
	SetPval(&val2, NULL, "sanderman");
	
	SetPattr(&attr3, NULL, "st", &val3);
	SetPval(&val3, NULL, "wa");

	hr = g_plcli->HrAdd("c=us, cn=davidsan", &attr1, &xid);
	if (FAILED(hr))
		{
		printf("HrAdd returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetAddResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetAddResponse returned %08X\n", hr);
		}

	return TRUE;		
}

BOOL
FTerm()
{
	if (g_plcli)
		{
		g_plcli->HrUnbind();
		if (g_plcli->HrIsConnected() == NOERROR)
			g_plcli->HrDisconnect();
		g_plcli->Release();
		}
	return TRUE;
}

void
usage()
{
	printf("usage:	lt <server>\n");
	exit(1);
}

void __cdecl
main(int argc, char **argv)
{
	if (argc < 2)
		usage();

	if (!FInit())
		exit(1);

	if (!FConnect(argv[1]))
		exit(1);

	if (!FSearch())
		exit(1);
		
// 	FTestOtherStuff();

	FTerm();
	exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\lt18.cpp ===
/*--------------------------------------------------------------------------
	lt18.cpp
	
		ldap rfc1823 test

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

	Authors:
		davidsan	Dave Sanderman

	History:
		06/17/96	davidsan	Created.
  --------------------------------------------------------------------------*/

#include "lt18.h"

LDAP *g_pldap = NULL;

BOOL
FInit()
{
	return TRUE;
}

BOOL
FConnect(char *szServer)
{
	int iRet;

	g_pldap = ldap_open(szServer, IPPORT_LDAP);
	if (!g_pldap)
		{
		printf("Couldn't ldap_open\n");
		return FALSE;
		}
	
	iRet = ldap_bind_s(g_pldap, "cn=alexwe@microsoft.com", "test", LDAP_AUTH_SIMPLE);
	if (iRet != LDAP_SUCCESS)
		{
		printf("Couldn't ldap_bind: %d\n", iRet);
		return FALSE;
		}

	return TRUE;	
}

char *g_rgszAttrib[] = {"title", "sn", "objectClass", "krbName", NULL};

BOOL
FSearch(char *szSearch)
{
	int iRet;
	struct timeval timeout;
	LDAPMessage *res;
	LDAPMessage *entry;
	void *pv;
	char **rgsz;
	char **psz;
	BERVAL **rgpberval;
	BERVAL **ppberval;

	g_pldap->ld_deref = LDAP_DEREF_ALWAYS;
	g_pldap->ld_sizelimit = 100;
	g_pldap->ld_timelimit = 0;
	
	timeout.tv_usec = 0;
	timeout.tv_sec = 60 * 60;
	
	iRet = ldap_search_st(g_pldap,
						  "c=us",
						  LDAP_SCOPE_SUBTREE,
						  szSearch,
						  g_rgszAttrib,
						  FALSE,
						  &timeout,
						  &res);
	if (iRet != LDAP_SUCCESS)
		{
		printf("Couldn't ldap_search_st: %d\n", iRet);
    	ldap_msgfree(res);
		return FALSE;
		}
		
	entry = ldap_first_entry(g_pldap, res);
	if (!entry)
		{
		printf("No first entry.\n");
    	ldap_msgfree(res);
		return FALSE;
		}
	while (entry)
		{
		char *szDN = ldap_get_dn(g_pldap, entry);
		printf("DN: %s\n", szDN);
		ldap_free_dn(szDN);
		
		char *szAttr = ldap_first_attribute(g_pldap, entry, &pv);
		while (szAttr)
			{
			printf("attr: %s\n", szAttr);
			
			rgsz = ldap_get_values(g_pldap, entry, szAttr);
			if (!rgsz)
				{
				printf("  no values!\n");
				}
			else
				{
				printf("  %d values:\n", ldap_count_values(rgsz));
				psz = rgsz;
				while (*psz)
					{
					printf("    val: %s\n", *psz);
					psz++;
					}
				ldap_value_free(rgsz);
				}
			
			rgpberval = ldap_get_values_len(g_pldap, entry, szAttr);
			if (!rgpberval)
				{
				printf("  no values_len!\n");
				}
			else
				{
				printf("  %d values_len:\n", ldap_count_values_len(rgpberval));
				ppberval = rgpberval;
				while (*ppberval)
					{
					printf("    val: %s (len %d)\n", (*ppberval)->bv_val, (*ppberval)->bv_len);
					ppberval++;
					}
				ldap_value_free_len(rgpberval);
				}

			szAttr = ldap_next_attribute(g_pldap, entry, &pv);
			}
		
		entry = ldap_next_entry(g_pldap, entry);
		}
		
	ldap_msgfree(res);

	return TRUE;
}

BOOL
FTerm()
{
	if (g_pldap)
		ldap_unbind(g_pldap);
	g_pldap = NULL;

	return TRUE;
}

void
usage()
{
	printf("usage:	lt18 <server> <search string>\n");
	exit(1);
}

void __cdecl
main(int argc, char **argv)
{
	if (argc < 3)
		usage();

	if (!FInit())
		exit(1);

	if (!FConnect(argv[1]))
		exit(1);

	if (!FSearch(argv[2]))
		exit(1);
		
	FTerm();
	exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\lt18.h ===
/*--------------------------------------------------------------------------
	lt18.h

		Main header for lt18

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

	Authors:
		davidsan	Dave Sanderman

	History:
		06/17/96	davidsan	Created.
  --------------------------------------------------------------------------*/

#include <windows.h>
#include <stdio.h>
#include <ldapcli.h>
#include <lclityp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cs.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\ldapsspi.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft LDAP SSPI Support
//		
//	Authors:
//
//		davidsan	05/08/96	hacked to pieces and started over
//
//--------------------------------------------------------------------------------------------

#include "ldappch.h"
#include "ldapsspi.h"
#include "lclilist.h"
#include "lclixd.h"

HRESULT g_hrInitSSPI;
HINSTANCE g_hinstSecDll = NULL;
PSecurityFunctionTable g_ptblpfnSec;

//$ TODO: Possibly return more descriptive errors so clients know why SSPI
//$ isn't working
HRESULT
HrInitializeSSPI()
{
	char *szDll;
	OSVERSIONINFO ovi;
	INIT_SECURITY_INTERFACE pfnISI = NULL;
	
	if (g_ptblpfnSec)
		return NOERROR;

	Assert(!g_hinstSecDll);

	ovi.dwOSVersionInfoSize = sizeof(ovi);
	if (!GetVersionEx(&ovi))
		return E_FAIL;

	if (ovi.dwPlatformId == VER_PLATFORM_WIN32_NT)
		szDll = "security.dll";
	else if (ovi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
		szDll = "secur32.dll";
	else
		return E_FAIL;
		
	g_hinstSecDll = LoadLibrary(szDll);

	pfnISI = (INIT_SECURITY_INTERFACE)GetProcAddress(g_hinstSecDll, SECURITY_ENTRYPOINT);
	if (!pfnISI)
		{
LBail:
		FreeLibrary(g_hinstSecDll);
		g_hinstSecDll = NULL;
		return LDAP_E_AUTHNOTAVAIL;
		}
	g_ptblpfnSec = (*pfnISI)();
	if (!g_ptblpfnSec)
		goto LBail;
	return NOERROR;
}

HRESULT
HrTerminateSSPI()
{
	g_ptblpfnSec = NULL;
	if (g_hinstSecDll)
		FreeLibrary(g_hinstSecDll);
	g_hinstSecDll = NULL;

	return NOERROR;
}

HRESULT
CLdapClient::HrGetCredentials(char *szUser, char *szPass)
{
	HRESULT hr;
	SECURITY_STATUS stat;
	TimeStamp tsLifetime;
	SEC_WINNT_AUTH_IDENTITY authdata;
	
	if (FAILED(g_hrInitSSPI))
		return g_hrInitSSPI;

	Assert(g_ptblpfnSec);
	if (!g_ptblpfnSec)
		return LDAP_E_AUTHNOTAVAIL;

	::EnterCriticalSection(&m_cs);
	if (m_fHasCred)
		{
		::LeaveCriticalSection(&m_cs);
		return NOERROR;
		}

	if (szUser && szPass)
		{
		authdata.User = (BYTE *)szUser;
		authdata.UserLength = lstrlen(szUser);
		authdata.Password = (BYTE *)szPass;
		authdata.PasswordLength = lstrlen(szPass);
		authdata.Domain = (BYTE *)"";
		authdata.DomainLength = 0;
		authdata.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
		}

	stat =
		(*g_ptblpfnSec->AcquireCredentialsHandle)
			(NULL,
			 "MSN", //$ does this ever change?
			 SECPKG_CRED_OUTBOUND,
			 NULL,
			 ((szUser && szPass) ? &authdata : NULL),
			 NULL,
			 NULL,
			 &m_hCred,
			 &tsLifetime);
	if (stat == SEC_E_OK)
		{
		m_fHasCred = TRUE;
		hr = NOERROR;
		}
	else
		hr = LDAP_E_AUTHNOTAVAIL;

	::LeaveCriticalSection(&m_cs);
	return hr;
}

STDMETHODIMP
CLdapClient::HrSendSSPINegotiate(char *szDN, char *szUser, char *szPass, BOOL fPrompt, PXID pxid)
{
	HRESULT hr;
	SECURITY_STATUS stat;
	DWORD fContextAttrib;
	TimeStamp tsExpireTime;
	SecBufferDesc outSecDesc;
	SecBuffer outSecBuffer;
	DWORD grfReq = ISC_REQ_CONFIDENTIALITY | ISC_REQ_USE_SESSION_KEY;
	PXD pxd;
	BYTE rgb[512];

	pxd = g_xl.PxdNewXaction(xtypeBindSSPINegotiate);
	if (!pxd)
		return E_OUTOFMEMORY;

	if (FAILED(hr = this->HrGetCredentials(szUser, szPass)))
		return hr;

	outSecDesc.ulVersion = 0;
	outSecDesc.cBuffers = 1;
	outSecDesc.pBuffers = &outSecBuffer;
	outSecBuffer.cbBuffer = sizeof(rgb);
	outSecBuffer.BufferType = SECBUFFER_TOKEN;
	outSecBuffer.pvBuffer = rgb;
	
	if (szUser && szPass)
		grfReq |= ISC_REQ_USE_SUPPLIED_CREDS;
	else
		grfReq |= ISC_REQ_PROMPT_FOR_CREDS;

	stat =
		(*g_ptblpfnSec->InitializeSecurityContext)
			(&m_hCred,
			 NULL, // phCurrContext
			 NULL, // pszTargetName
			 grfReq,
			 0L,
			 SECURITY_NATIVE_DREP,
			 NULL,
			 0L,
			 &m_hCtxt,
			 &outSecDesc,
			 &fContextAttrib,
			 &tsExpireTime);

	if (FAILED(stat))
		{
		//$ TODO: determine what errors InitializeSecurityContext can return and
		//$ return appropriate errors to client
		return E_FAIL;
		}

	m_fHasCtxt = TRUE;
	hr = HrSendBindMsg(
						pxd->Xid(),
						szDN,
						BIND_SSPI_NEGOTIATE,
						outSecBuffer.pvBuffer,
						outSecBuffer.cbBuffer
					  );
	if (SUCCEEDED(hr))
		*pxid = pxd->Xid();
	return hr;
}

STDMETHODIMP
CLdapClient::HrGetSSPIChallenge(XID xid, BYTE *pbBuf, int cbBuf, int *pcbChallenge, DWORD timeout)
{
	PXD pxd;
	BOOL fDel;
	HRESULT hr = NOERROR;
	BYTE *pbData;
	int cbData;
	LBER lber;
	ULONG ulTag;
	LONG lResult;

	pxd = g_xl.PxdForXid(xid);
	if (!pxd)
		return LDAP_E_INVALIDXID;
	if (pxd->Xtype() != xtypeBindSSPINegotiate)
		return LDAP_E_INVALIDXTYPE;
	if (pxd->FCancelled())
		return LDAP_E_CANCELLED;
	if (pxd->FOOM())
		return E_OUTOFMEMORY;

	if (pxd->FHasData())
		fDel = TRUE;
	else
		{
		if (FAILED(hr = this->HrWaitForPxd(pxd, timeout, &fDel)))
			goto LBail;
		}
	if (!pxd->FGetBuffer(&pbData, &cbData))
		{
		//$ what's the right error here?
		hr = LDAP_E_UNEXPECTEDDATA;
		goto LBail;
		}
	VERIFY(lber.HrLoadBer(pbData, cbData));

	VERIFY(lber.HrStartReadSequence(LDAP_BIND_RES | BER_FORM_CONSTRUCTED | BER_CLASS_APPLICATION));
	  VERIFY(lber.HrPeekTag(&ulTag));
	  if (ulTag == BER_SEQUENCE)
		{
		Assert(FALSE); // i want to see if any server returns explicit sequences
		VERIFY(lber.HrStartReadSequence());
		}
	  VERIFY(lber.HrGetEnumValue(&lResult));
	  if (!lResult)
	  	{
		// we have 0 for success--the matchedDN field is the server's challenge.
		VERIFY(lber.HrGetStringLength(pcbChallenge));
		if (*pcbChallenge > cbBuf)
		  {
		  hr = LDAP_E_BUFFERTOOSMALL;
		  goto LBail;
		  }
		VERIFY(lber.HrGetBinaryValue(pbBuf, cbBuf));
		}
	  if (ulTag == BER_SEQUENCE)
	    {
	    VERIFY(lber.HrEndReadSequence());
		}
	VERIFY(lber.HrEndReadSequence());

	hr = this->HrFromLdapResult(lResult);

LBail:
	if (fDel)
		g_xl.RemovePxd(pxd);

	return hr;
}

STDMETHODIMP
CLdapClient::HrSendSSPIResponse(BYTE *pbChallenge, int cbChallenge, PXID pxid)
{
	HRESULT hr;
	SECURITY_STATUS stat;
	DWORD fContextAttrib;
	TimeStamp tsExpireTime;
	SecBufferDesc inSecDesc, outSecDesc;
	SecBuffer inSecBuffer, outSecBuffer;
	DWORD grfReq = ISC_REQ_CONFIDENTIALITY | ISC_REQ_USE_SESSION_KEY;
	PXD pxd;
	BYTE rgb[512];

	if (!m_fHasCtxt || !m_fHasCred)
		return LDAP_E_OUTOFSEQUENCE;

	pxd = g_xl.PxdNewXaction(xtypeBind);
	if (!pxd)
		return E_OUTOFMEMORY;

	inSecDesc.ulVersion = 0;
	inSecDesc.cBuffers = 1;
	inSecDesc.pBuffers = &inSecBuffer;
	
	inSecBuffer.cbBuffer = cbChallenge;
	inSecBuffer.BufferType = SECBUFFER_TOKEN;
	inSecBuffer.pvBuffer = (PVOID)pbChallenge;
	
	outSecDesc.ulVersion = 0;
	outSecDesc.cBuffers = 1;
	outSecDesc.pBuffers = &outSecBuffer;
	outSecBuffer.cbBuffer = sizeof(rgb);
	outSecBuffer.BufferType = SECBUFFER_TOKEN;
	outSecBuffer.pvBuffer = rgb;
	
	stat =
		(*g_ptblpfnSec->InitializeSecurityContext)
			(&m_hCred,
			 &m_hCtxt,
			 NULL, // pszTargetName
			 ISC_REQ_CONFIDENTIALITY | ISC_REQ_USE_SESSION_KEY,
			 0L,
			 SECURITY_NATIVE_DREP,
			 &inSecDesc,
			 0L,
			 &m_hCtxt,
			 &outSecDesc,
			 &fContextAttrib,
			 &tsExpireTime);

	if (FAILED(stat))
		{
		//$ TODO: determine what errors InitializeSecurityContext can return and
		//$ return appropriate errors to client
		return E_FAIL;
		}

	m_fHasCtxt = TRUE;
	hr = HrSendBindMsg(
						pxd->Xid(),
						"",
						BIND_SSPI_RESPONSE,
						outSecBuffer.pvBuffer,
						outSecBuffer.cbBuffer
					  );
	if (SUCCEEDED(hr))
		*pxid = pxd->Xid();
	return hr;
}

STDMETHODIMP
CLdapClient::HrBindSSPI(char *szDN, char *szUser, char *szPass, BOOL fPrompt, DWORD timeout)
{
	XID xid;
	HRESULT hr;
	BYTE rgb[512];
	int cbChallenge;
	
	if (FAILED(hr = this->HrSendSSPINegotiate(szDN, szUser, szPass, fPrompt, &xid)))
		return hr;
	if (FAILED(hr = this->HrGetSSPIChallenge(xid, rgb, sizeof(rgb), &cbChallenge, timeout)))
		return hr;
	if (FAILED(hr = this->HrSendSSPIResponse(rgb, cbChallenge, &xid)))
		return hr;
	
	return this->HrGetBindResponse(xid, timeout);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\lwinsock.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client.
//
//		Classes that manage connections with an LDAP server.
//
//	Authors:
//
//		RobertC		04/18/96
//
//--------------------------------------------------------------------------------------------

// NOTE: this class is responsible for buffering all data until complete top-level structures
// are received.

#ifndef _LSWINSOC_H
#define _LSWINSOC_H

//--------------------------------------------------------------------------------------------
//
// DEFINITIONS
//
//--------------------------------------------------------------------------------------------
typedef void (*PFNRECEIVEDATA)(PVOID pvCookie, PVOID pv, int cb, int *pcbReceived);

//--------------------------------------------------------------------------------------------
//
// CONSTANTS
//
//--------------------------------------------------------------------------------------------
const int CBBUFFERGROW	= 4096;

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS
//
//--------------------------------------------------------------------------------------------
extern BOOL FInitSocketDLL();
extern void FreeSocketDLL();

//--------------------------------------------------------------------------------------------
//
// CLASSES
//
//--------------------------------------------------------------------------------------------

class CLdapWinsock
{

//
// Interfaces
//

public:
	CLdapWinsock();
	~CLdapWinsock(void);
	
	STDMETHODIMP			HrConnect(PFNRECEIVEDATA pfnReceive, PVOID pvCookie, char *szServer, USHORT usPort = IPPORT_LDAP);
	STDMETHODIMP			HrDisconnect(void);
	STDMETHODIMP			HrIsConnected(void);

	STDMETHODIMP			HrSend(PVOID pv, int cb);

protected:
	friend DWORD __stdcall DwReadThread(PVOID pvData);
	DWORD					DwReadThread(void);
	
private:
	void					Receive(PVOID pv, int cb, int *pcbReceived);
	
	HRESULT					HrCreateReadThread(void);
	
	HRESULT					HrLastWinsockError(void);

	CRITICAL_SECTION		m_cs;

	SOCKET					m_sc;
	BOOL					m_fConnected;
	HANDLE					m_hthread;
	DWORD					m_dwTid;
	PFNRECEIVEDATA			m_pfnReceive;
	PVOID					m_pvCookie;

	// read buffer
	HRESULT					HrGrowBuffer();
	BYTE					*m_pbBuf;		// buffer for socket to read into
	int						m_cbBuf;		// current amount of data in the buffer
	int						m_cbBufMax;		// total size of buffer
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\apitest\instring.c ===
#include <windows.h>
#include "instring.h"


typedef struct _STRING_BUFFER {
    ULONG cbBuffer;
    LPTSTR lpBuffer;
    LPTSTR lpPrompt;
    LPTSTR lpTitle;
} STRING_BUFFER, *LPSTRING_BUFFER;

BOOL PASCAL InputStringDlgProc(HWND hDlg, WORD message, WORD wParam, LONG lParam) {
    static LPSTRING_BUFFER lpBuffer = NULL;
    USHORT cchString;

    switch (message) {
        case WM_INITDIALOG:
            // DialogBoxParam passes in pointer to buffer description.
            lpBuffer = (LPSTRING_BUFFER)lParam;

            if (lpBuffer->lpPrompt) {
                SetDlgItemText(hDlg, IDD_INPUT_STRING_PROMPT, lpBuffer->lpPrompt);
            }

            if (lpBuffer->lpTitle) {
                SetWindowText(hDlg, lpBuffer->lpTitle);
            }

            SendDlgItemMessage(hDlg,
              IDD_INPUT_STRING,
              EM_LIMITTEXT,
              (WPARAM)(lpBuffer->cbBuffer - 1), // text length, in characters (leave room for null)
              0);                               // not used; must be zero

            return(TRUE);

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                    // Get number of characters.
                    cchString = (WORD)SendDlgItemMessage(hDlg,
                      IDD_INPUT_STRING,
                      EM_LINELENGTH,
                      (WPARAM) 0,
                      (LPARAM) 0);

                    if (cchString == 0) {
                        *(lpBuffer->lpBuffer) = '\0';
                        EndDialog(hDlg, TRUE);
                        lpBuffer->cbBuffer = 0;
                        return FALSE;
                    }

                    // Put the number of characters into first word
                    // of buffer.
                    *((USHORT*)lpBuffer->lpBuffer) = cchString;
                    lpBuffer->cbBuffer = cchString;

                    // Get the characters.
                    SendDlgItemMessage(hDlg,
                      IDD_INPUT_STRING,
                      EM_GETLINE,
                      (WPARAM)0,        // line 0
                      (LPARAM)lpBuffer->lpBuffer);

                    // Null-terminate the string.
                    lpBuffer->lpBuffer[cchString] = 0;
                    lpBuffer = NULL;    // prevent reuse of buffer
                    EndDialog(hDlg, 0);
                    return(TRUE);
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}

/***************************************************************************

    Name      : InputString

    Purpose   : Brings up a dialog requesting string input

    Parameters: hInstance = hInstance of app
                hwnd = hwnd of parent window
                lpszTitle = Dialog box title
                lpszPrompt = Text in dialog box
                lpBuffer = buffer to fill
                cchBuffer = size of buffer

    Returns   : return ULONG number of characters entered (not including terminating
                NULL)

    Comment   :

***************************************************************************/
ULONG InputString(HINSTANCE hInstance, HWND hwnd, const LPTSTR lpszTitle,
  const LPTSTR lpszPrompt, LPTSTR lpBuffer, ULONG cchBuffer) {
    STRING_BUFFER StringBuffer;

    StringBuffer.lpPrompt = lpszPrompt;
    StringBuffer.lpTitle = lpszTitle;
    StringBuffer.cbBuffer = cchBuffer;
    StringBuffer.lpBuffer = lpBuffer;

    DialogBoxParam(hInstance, (LPCTSTR)"InputString", hwnd, (DLGPROC)InputStringDlgProc,
      (LPARAM)&StringBuffer);

    return(StringBuffer.cbBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\setup\makefile.inc ===
$O\wabver.bat : wabver.tmp $(BASEDIR)\public\sdk\inc\ntverp.h $(BASEDIR)\public\sdk\inc\ieverp.h
    cl /EP /I$(BASEDIR)\public\sdk\inc /DNASHVILLE /Tc wabver.tmp > $@

$O\wab.srx : wab.src $O\wabver.bat
    $O\wabver wab.src $@

$O\wab9x50.inx : $O\wab.srx $O\msoeacct.reg $O\msoeacct.str $O\wab32.reg $O\wab32.str $O\wabimp.reg $O\wabimp.str $O\wabfind.reg 
    cl /EP $(COPYPDB) $(DEFINEX86) /DWIN9X /Tc $O\wab.srx > $O\wab9x50.tmp
    copy $O\wab9x50.tmp /B +$O\msoeacct.str /B +$O\wab32.str /B +$O\wabimp.str /B $@
    del $O\wab9x50.tmp

$O\wab50.inx.nt : $O\wab.srx
    cl /EP $(COPYPDB) $(DEFINEX86) /Tc $** > $@

$O\wab50.inx.exe : $O\wab.srx
    cl /EP $(COPYPDB) $(DEFINEX86) /DIE5 /DOESETUP_EXE /Tc $** > $@

$O\wab50.inx.cab : $O\wab.srx
    cl /EP $(COPYPDB) $(DEFINEX86) /DIE5 /Tc $** > $@

$O\wab9x50.inf : $O\wab9x50.inx
    $(CLEANINF) $** $@
    del $**

$O\wab50.inf.nt : $O\wab50.inx.nt
    $(CLEANINF) $** $@
    del $**

$O\wab50.inf : $O\wab50.inf.nt
    copy $** $@

$O\wab50.inf.exe : $O\wab50.inx.exe
    $(CLEANINF) $** $@
    del $**

$O\wab50.inf.cab : $O\wab50.inx.cab
    $(CLEANINF) $** $@
    del $**

$O\wabcab.sed  : wabcab.src
    cl /EP $(COPYPDB) $(DEFINEX86) /DOESETUP_DEV /Tc $** > $@

$O\wabexe.se2 : wabcab.src
    cl /EP $(COPYPDB) $(DEFINEX86) /DOESETUP_DEV /DOESETUP_EXE /Tc $** > $@

$O\wabexe.sed : $O\wabexe.se2 $O\wabver.bat
    $O\wabver $O\wabexe.se2 $@
    del $O\wabexe.se2

$O\wabcabl.sed : wabcab.src
    cl /EP /Tc $** > $@

$O\wabexel.se2 : wabcab.src
    cl /EP /DOESETUP_EXE /Tc $** > $@

$O\wabexel.sed : $O\wabexel.se2 $O\wabver.bat
    $O\wabver $O\wabexel.se2 $@
    del $O\wabexel.se2

$O\msoeacct.reg : $(ATHROOT)\msoeacct\reg.src
    copy $** $@

$O\msoeacct.str : $(ATHROOT)\msoeacct\strings.src
    copy $** $@

$O\wab32.reg : $(WABROOT)\wabapi\reg.src $(WABROOT)\wabapi\reg2.src
    copy $(WABROOT)\wabapi\reg.src /B + $(WABROOT)\wabapi\reg2.src /B $@

$O\wab32.str : $(WABROOT)\wabapi\strings.src
    copy $** $@

$O\wabimp.reg : $(WABROOT)\convert\wmnets\reg.src
    copy $** $@

$O\wabimp.str : $(WABROOT)\convert\wmnets\strings.src
    copy $** $@

$O\wabfind.reg : $(WABROOT)\wabfind\reg.src $(WABROOT)\wabfind\reg2.src
    copy $(WABROOT)\wabfind\reg.src /B + $(WABROOT)\wabfind\reg2.src /B $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\ldapcli\lwinsock.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client 
//
//
//	Authors:
//
//		Umesh Madan
//		Robert Carney	4/17/96	Created from ChatSock library.
//		davidsan	04-25-96	hacked into tiny bits for my own devious purposes
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// INCLUDES
//
//--------------------------------------------------------------------------------------------
#include "ldappch.h"

//--------------------------------------------------------------------------------------------
//
// PROTOTYPES
//
//--------------------------------------------------------------------------------------------
DWORD __stdcall DwReadThread(PVOID pvData);

//--------------------------------------------------------------------------------------------
//
// GLOBALS
//
//--------------------------------------------------------------------------------------------
BOOL g_fInitedWinsock = FALSE;

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS
//
//--------------------------------------------------------------------------------------------
BOOL FInitSocketDLL()
{
	WORD	wVer; 
	WSADATA wsaData; 
	int		err; 
	
	wVer = MAKEWORD(1, 1);	// use Winsock 1.1 
	if (WSAStartup(wVer, &wsaData))
		return FALSE;

    return TRUE; 
}

void FreeSocketDLL()
{
	WSACleanup();
}

//--------------------------------------------------------------------------------------------
//
// CLASSES
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// CLdapWinsock
// 
// Wrapper that implements a socket based connection.
//
//--------------------------------------------------------------------------------------------

CLdapWinsock::CLdapWinsock()
{
	m_sc			= INVALID_SOCKET;
	m_pfnReceive	= NULL;
	m_pvCookie		= NULL;
	m_pbBuf			= NULL;
	m_cbBuf			= 0;
	m_cbBufMax		= 0;
	m_fConnected	= FALSE;
	m_hthread		= NULL;

	InitializeCriticalSection(&m_cs);
}

CLdapWinsock::~CLdapWinsock(void)
{
	if (m_pbBuf)
		delete [] m_pbBuf;
	DeleteCriticalSection(&m_cs);
}

//
// Open a connection the named server, and connect to the port 'usPort' (host byte order)
// Can block
//
STDMETHODIMP
CLdapWinsock::HrConnect(PFNRECEIVEDATA pfnReceive, PVOID pvCookie, CHAR *szServer, USHORT usPort)
{
	SOCKADDR_IN		sin;
	struct hostent	*phe;
	HRESULT			hr;
	
	if (!pfnReceive || !szServer || !usPort)
		return E_INVALIDARG;

	Assert(!m_pbBuf);
	if (!m_pbBuf)
		{
		m_cbBufMax = CBBUFFERGROW;
		m_pbBuf = new BYTE[m_cbBufMax];
		m_cbBuf = 0;
		if (!m_pbBuf)
			return E_OUTOFMEMORY;
		}
	FillMemory(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_port = htons(usPort);
	
	if (szServer[0] >= '1' && szServer[0] <= '9')
		{
		sin.sin_addr.s_addr = inet_addr(szServer);
		if (sin.sin_addr.s_addr == INADDR_NONE)
			{
			delete [] m_pbBuf;
			m_pbBuf = NULL;
			return LDAP_E_HOSTNOTFOUND;
			}
		}
	else
		{
		phe = gethostbyname(szServer);
		if (!phe)
			{
			delete [] m_pbBuf;
			m_pbBuf = NULL;
			return LDAP_E_HOSTNOTFOUND;
			}
		CopyMemory(&sin.sin_addr, phe->h_addr, phe->h_length);
		}

	::EnterCriticalSection(&m_cs);
	if (m_fConnected)
		this->HrDisconnect();

	m_sc = socket(PF_INET, SOCK_STREAM, 0);
	if (m_sc < 0)
		{
		delete [] m_pbBuf;
		m_pbBuf = NULL;
		::LeaveCriticalSection(&m_cs);
		return LDAP_E_INVALIDSOCKET;
		}
	if (connect(m_sc, (struct sockaddr *)&sin, sizeof(sin)) < 0)
		{
		delete [] m_pbBuf;
		m_pbBuf = NULL;
		::LeaveCriticalSection(&m_cs);
		return LDAP_E_CANTCONNECT;
		}

	hr = this->HrCreateReadThread();
	if (SUCCEEDED(hr))
		m_fConnected = TRUE;
	else
		{
		delete [] m_pbBuf;
		m_pbBuf = NULL;
		}
	::LeaveCriticalSection(&m_cs);
	m_pfnReceive = pfnReceive;
	m_pvCookie = pvCookie;
	return hr;
}

STDMETHODIMP
CLdapWinsock::HrDisconnect()
{
	HRESULT hr = NOERROR;

	if (!m_fConnected)
		return NOERROR;

	::EnterCriticalSection(&m_cs);
	m_fConnected = FALSE;
	closesocket(m_sc);
	::LeaveCriticalSection(&m_cs);
	
	WaitForSingleObject(m_hthread, INFINITE);
	
	::EnterCriticalSection(&m_cs);
	delete [] m_pbBuf;
	m_cbBuf = 0;
	m_cbBufMax = 0;
	m_pbBuf = NULL;
	::LeaveCriticalSection(&m_cs);
	return hr;
}

HRESULT
CLdapWinsock::HrCreateReadThread()
{
	HRESULT	hr = NOERROR;

	::EnterCriticalSection(&m_cs);

	m_hthread =	::CreateThread(
							NULL,
							0,
							::DwReadThread,
							(LPVOID)this,
							0,
							&m_dwTid
							);
	if (!m_hthread)
		hr = E_OUTOFMEMORY;
	::LeaveCriticalSection(&m_cs);
	return hr;
}

//
// Write pvData out to the current socket/connection.
// can block
//
HRESULT
CLdapWinsock::HrSend(PVOID pv, int cb)
{
	HRESULT hr = NOERROR;

	if (!pv || cb <= 0)
		return E_INVALIDARG;

	if (send(m_sc, (const char *)pv, cb, 0) == SOCKET_ERROR)
		hr = this->HrLastWinsockError();

	return hr;
}

HRESULT
CLdapWinsock::HrGrowBuffer()
{
	BYTE *pb;
	Assert(m_cbBufMax == m_cbBuf);
	
	pb = new BYTE[m_cbBufMax + CBBUFFERGROW];
	if (!pb)
		return E_OUTOFMEMORY;
	CopyMemory(pb, m_pbBuf, m_cbBuf);
	delete [] m_pbBuf;
	m_pbBuf = pb;
	m_cbBufMax += CBBUFFERGROW;
	return NOERROR;
}

void
CLdapWinsock::Receive(PVOID pv, int cb, int *pcbReceived)
{
	if (m_pfnReceive)
		m_pfnReceive(m_pvCookie, pv, cb, pcbReceived);
}

//$ TODO: Find a way to pass memory errors back to the API
DWORD
CLdapWinsock::DwReadThread()
{
	int cbRead;
	int cbLeft;
	int cbReceived;

	while (1)
		{
		// at the beginning of this loop: any unprocessed data is in m_pbBuf[0..m_cbBuf].
		Assert(m_cbBuf <= m_cbBufMax);
		if (m_cbBuf == m_cbBufMax)
			{
			if (FAILED(this->HrGrowBuffer()))
				return 0xFFFFFFFF;
			}
		cbLeft = m_cbBufMax - m_cbBuf;
		
		cbRead = recv(m_sc, (LPSTR)&(m_pbBuf[m_cbBuf]), cbLeft, 0);
		if (cbRead == 0 || cbRead == SOCKET_ERROR)
			return 0;
			
		// note: i don't know why this is happening, but it is...
		if (cbRead < 0)
			return 0;
			
		m_cbBuf += cbRead;
		do
			{
			this->Receive(m_pbBuf, m_cbBuf, &cbReceived);
			if (cbReceived)
				{
				m_cbBuf -= cbReceived;
				CopyMemory(m_pbBuf, &m_pbBuf[cbReceived], m_cbBuf);
				}
			}
		while (cbReceived && m_cbBuf);
		}
}

HRESULT
CLdapWinsock::HrIsConnected(void)
{
	return m_fConnected ? NOERROR : S_FALSE;
}

//$ TODO: Are there other errors that i need to handle here?
HRESULT
CLdapWinsock::HrLastWinsockError()
{
	int		idErr;
	HRESULT	hr = E_FAIL;

	idErr = WSAGetLastError();
	switch (idErr)
		{
		default:
			break;
		
		case WSANOTINITIALISED:
			AssertSz(0,"socket not initialized!");
			hr = E_FAIL;
			break;
		
		case WSAENETDOWN:
			hr = LDAP_E_NETWORKDOWN;
			break;
		
		case WSAENETRESET:
			hr = LDAP_E_LOSTCONNECTION;
			break;

		case WSAENOTCONN:
			AssertSz(0,"Not connected!");
			hr = E_FAIL;
			break;

		case WSAESHUTDOWN:
			hr = LDAP_E_SOCKETCLOSED;
			break;
		
		case WSAECONNRESET:
			hr = LDAP_E_HOSTDROPPED;
			break;
		}
	
	return hr;
}

DWORD __stdcall DwReadThread(PVOID pvData)
{
	PSOCK psock = (PSOCK)pvData;
	
	Assert(pvData);

	return psock->DwReadThread();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\apitest\apitest.c ===
/*-----------------------------------------
   APITEST.C -- Function Test of WABAPI.DLL
  -----------------------------------------*/

#include <windows.h>
#include <wab.h>
#include <wabguid.h>
#include "apitest.h"
#include "instring.h"
#include "dbgutil.h"

#define WinMainT WinMain
long FAR PASCAL WndProc (HWND, UINT, UINT, LONG) ;

#define MAX_INPUT_STRING    200

char szAppName [] = "APITest" ;
HINSTANCE hInst;

enum _AddressTestFlags
{
    ADDRESS_CONTENTS = 0,
    ADDRESS_CONTENTS_BROWSE,
    ADDRESS_CONTENTS_BROWSE_MODAL,
    ADDRESS_WELLS,
    ADDRESS_WELLS_DEFAULT,
};

void AllocTest(void);
void IPropTest(void);
void WABOpenTest(void);
void CreateEntryTest(HWND hwnd, BOOL fDL);
void GetContentsTableTest(void);
void GetSearchPathTest(void);
void ResolveNameTest(HWND hwnd);
void ResolveNamesTest(HWND hwnd);
void DeleteEntriesTest(HWND hwnd);
void WABAddressTest(HWND hWnd, int iFlag, int cDestWells);
void AddrBookDetailsTest(HWND hwnd);
void AddrBookDetailsOneOffTest(HWND hwnd);
void RootContainerTest(void);
void NotificationsTest(HWND hwnd);
void GetMeTest(HWND hWnd);

#define DATABASE_KEY    HKEY_CURRENT_USER
#define CCH_MAX_REGISTRY_DATA   256
const TCHAR szMainSectionName[] = TEXT("APITest");       // Test settings in here
const TCHAR szIniSectionName[] = TEXT("Software\\Microsoft\\WAB\\Test");  // Look here for settings
const TCHAR szContactNumberKey[] = TEXT("Next Contact Number");
const TCHAR szContainerNumberKey[] = TEXT("Container Number");



//
//  Global WAB Allocator access functions
//
typedef struct _WAB_ALLOCATORS {
    LPWABOBJECT lpWABObject;
    LPWABALLOCATEBUFFER lpAllocateBuffer;
    LPWABALLOCATEMORE lpAllocateMore;
    LPWABFREEBUFFER lpFreeBuffer;
} WAB_ALLOCATORS, *LPWAB_ALLOCATORS;

ULONG ulContainerNumber = 0;
WAB_ALLOCATORS WABAllocators = {0};

/***************************************************************************

    Name      : SetGlobalBufferFunctions

    Purpose   : Set the global buffer functions based on methods from
                the WAB object.

    Parameters: lpWABObject = the open wab object

    Returns   : none

    Comment   :

***************************************************************************/
void SetGlobalBufferFunctions(LPWABOBJECT lpWABObject) {
    if (lpWABObject && WABAllocators.lpWABObject != lpWABObject) {
        WABAllocators.lpAllocateBuffer = lpWABObject->lpVtbl->AllocateBuffer;
        WABAllocators.lpAllocateMore = lpWABObject->lpVtbl->AllocateMore;
        WABAllocators.lpFreeBuffer = lpWABObject->lpVtbl->FreeBuffer;
        WABAllocators.lpWABObject = lpWABObject;
    }
}


/***************************************************************************

    Name      : WABAllocateBuffer

    Purpose   : Use the WAB Allocator

    Parameters: cbSize = size to allocate
                lppBuffer = returned buffer

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABAllocateBuffer(ULONG cbSize, LPVOID FAR * lppBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpAllocateBuffer) {
        return(WABAllocators.lpAllocateBuffer(WABAllocators.lpWABObject, cbSize, lppBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


/***************************************************************************

    Name      : WABAllocateMore

    Purpose   : Use the WAB Allocator

    Parameters: cbSize = size to allocate
                lpObject = existing allocation
                lppBuffer = returned buffer

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABAllocateMore(ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpAllocateMore) {
        return(WABAllocators.lpAllocateMore(WABAllocators.lpWABObject, cbSize, lpObject, lppBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


/***************************************************************************

    Name      : WABFreeBuffer

    Purpose   : Use the WAB Allocator

    Parameters: lpBuffer = buffer to free

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABFreeBuffer(LPVOID lpBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpFreeBuffer) {
        return(WABAllocators.lpFreeBuffer(WABAllocators.lpWABObject, lpBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


/***************************************************************************

    Name      : WABFreePadrlist

    Purpose   : Free an adrlist and it's property arrays

    Parameters: lpBuffer = buffer to free

    Returns   : SCODE

    Comment   :

***************************************************************************/
void WABFreePadrlist(LPADRLIST lpAdrList) {
        ULONG           iEntry;

        if (lpAdrList) {
                for (iEntry = 0; iEntry < lpAdrList->cEntries; ++iEntry) {
           if (lpAdrList->aEntries[iEntry].rgPropVals) {
                             WABFreeBuffer(lpAdrList->aEntries[iEntry].rgPropVals);
           }
                }
                WABFreeBuffer(lpAdrList);
        }
}


/***************************************************************************

    Name      : StrInteger

    Purpose   : Replace atoi().  Base 10 string to integer.

    Parameters: lpszString = string pointer (null terminated)

    Returns   : integer value found in lpszString

    Comment   : Reads characters from lpszString until a non-digit is found.

***************************************************************************/
int __fastcall StrInteger(LPCTSTR lpszString) {
    register DWORD dwInt = 0;
    register LPTSTR lpsz = (LPTSTR)lpszString;

    if (lpsz) {
        while (*lpsz > '0' && *lpsz < '9') {
            dwInt = dwInt * 10 + (*lpsz - '0');
            lpsz++;
        }
    }

    return(dwInt);
}

/***************************************************************************

    Name      : GetInitializerInt

    Purpose   : Gets an integer value from the initializer data

    Parameters: lpszSection = section name
                lpszKey = key name
                dwDefault = default value if key not found
                lpszFile = inifile/keyname

    Returns   : UINT value from the initializer database (registry)

    Comment   : Same interface as GetPrivateProfileInt: If the key is not
                found, the return value is the specified default value.
                If value of the key is less than zero, the return value
                is zero.

                The registry key to get here is:
                  lpszFile\lpszSection
                The value name is lpszKey.

***************************************************************************/
UINT GetInitializerInt(LPCTSTR lpszSection, LPCTSTR lpszKey, INT dwDefault,
  LPCTSTR lpszFile) {

    LPTSTR lpszKeyName = NULL;
    HKEY hKey = NULL;
    INT iReturn = 0;
    DWORD dwType;
    DWORD cbData = CCH_MAX_REGISTRY_DATA;
    BYTE  lpData[CCH_MAX_REGISTRY_DATA];
    DWORD cchKey;
    DWORD dwErr;

    if (lpszFile == NULL || lpszSection == NULL || lpszKey == NULL) {
        return(dwDefault);
    }

    cchKey = lstrlen(lpszFile) + lstrlen(lpszSection) + 2;

    if ((lpszKeyName = LocalAlloc(LPTR, cchKey)) == NULL) {
        DebugTrace("GetInitializerInt: LocalAlloc(%u) failed\n", cchKey);
        return(0);
    }

    // Create keyname string
    lstrcpy(lpszKeyName, lpszFile);
    lstrcat(lpszKeyName, "\\");
    lstrcat(lpszKeyName, lpszSection);

    if (dwErr = RegOpenKeyEx(DATABASE_KEY, lpszKeyName, 0, KEY_READ, &hKey)) {
        DebugTrace("GetInitializerInt: RegOpenKeyEx(%s) --> %u, using default.\n",
          lpszKeyName, dwErr);
        iReturn = dwDefault;    // default
        goto Exit;
    }

    if (dwErr = RegQueryValueEx(hKey, (LPTSTR)lpszKey, 0, &dwType, lpData, &cbData)) {
        iReturn = dwDefault;
        goto Exit;
    }

    switch (dwType) {
        case REG_SZ:
            iReturn = StrInteger((char *)lpData);
            if (iReturn < 0) {
                iReturn = 0;    // match spec of GetPrivateProfileInt.
            }
            break;

        case REG_DWORD:
            if ((iReturn = (INT)(*(DWORD *)lpData)) < 0) {
                iReturn = 0;    // match spec of GetPrivateProfileInt.
            }

            break;
        default:
            DebugTrace("GetInitializerInt: RegQueryValueEx(%s) -> UNKNOWN dwType = %u\n",
              lpszKey, dwType);
            iReturn = dwDefault;
            break;
    }

Exit:
    if (hKey) {
        RegCloseKey(hKey);
    }
    LocalFree(lpszKeyName);
    return(iReturn);
}


/***************************************************************************

    Name      : WriteRegistryString

    Purpose   : Sets the string value in the registry

    Parameters: hKeyRoot = root key
                lpszSection = section name
                lpszKey = key name
                lpszString = string value to add
                lpszFile = inifile/keyname

    Returns   : TRUE on success

***************************************************************************/
BOOL WriteRegistryString(HKEY hKeyRoot, LPCTSTR lpszSection, LPCTSTR lpszKey,
  LPCTSTR lpszString, LPCTSTR lpszFile) {

    DWORD cchKey;
    LPTSTR lpszKeyName = NULL;
    HKEY hKey = NULL;
    BOOL fReturn = FALSE;
    DWORD dwDisposition;
    DWORD dwErr;

    if (lpszFile == NULL || lpszSection == NULL || lpszKey == NULL) {
        return(FALSE);
    }

    cchKey = lstrlen(lpszFile) + lstrlen(lpszSection) + 2;

    if ((lpszKeyName = LocalAlloc(LPTR, cchKey)) == NULL) {
        DebugTrace("WriteInitializerString: LocalAlloc(%u) failed\n", cchKey);
        return(0);
    }

    // Create keyname string
    lstrcpy(lpszKeyName, lpszFile);
    lstrcat(lpszKeyName, "\\");
    lstrcat(lpszKeyName, lpszSection);

    if (dwErr = RegCreateKeyEx(hKeyRoot, lpszKeyName, 0, NULL,
        REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisposition)) {
        DebugTrace("WriteInitializerString: RegCreateKeyEx(%s) --> %u.\n",
          lpszKeyName, dwErr);
        goto Exit;
    }

    if (dwErr = RegSetValueEx(hKey, lpszKey, 0, REG_SZ,
      (CONST LPBYTE)lpszString, lstrlen(lpszString) + 1)) {
        DebugTrace("WriteInitializerString: RegSetValueEx(%s) --> %u.\n",
          lpszKey, dwErr);
        goto Exit;
    }
    fReturn = TRUE; // must have succeeded

Exit:
    if (hKey) {
        RegCloseKey(hKey);
    }

    LocalFree(lpszKeyName);

    return(fReturn);
}


/***************************************************************************

    Name      : WriteInitializerString

    Purpose   : Sets the string value in the initializer data

    Parameters: lpszSection = section name
                lpszKey = key name
                lpszString = string value to add
                lpszFile = inifile/keyname

    Returns   : TRUE on success

    Comment   : Same interface as WritePrivateProfileString.

                The registry key to get here is:
                  lpszFile\lpszSection
                The value name is lpszKey.

***************************************************************************/
BOOL WriteInitializerString(LPCTSTR lpszSection, LPCTSTR lpszKey,
  LPCTSTR lpszString, LPCTSTR lpszFile) {

    return(WriteRegistryString(DATABASE_KEY, lpszSection, lpszKey,
      lpszString, lpszFile));
}


/***************************************************************************

    Name      : WriteInitializerInt

    Purpose   : Sets the integer value in the initializer data

    Parameters: lpszSection = section name
                lpszKey = key name
                i = int value to add
                lpszFile = inifile/keyname

    Returns   : TRUE on success

    Comment   : Same interface as WritePrivateProfileInt would be if
                there were one.

                The registry key to get here is:
                  lpszFile\lpszSection
                The value name is lpszKey.

***************************************************************************/
BOOL WriteInitializerInt(LPCTSTR lpszSection, LPCTSTR lpszKey,
  DWORD i, LPCTSTR lpszFile) {

    TCHAR szIntString[12];  //  put string representation of int here.

    wsprintf(szIntString, "%u", i);

    return(WriteInitializerString(lpszSection, lpszKey,
      szIntString, lpszFile));
}


/***************************************************************************

    Name      : GetNewMessageReference

    Purpose   : Generate a unique messag reference value

    Parameters: none

    Returns   : return ULONG message reference value.

    Comment   : Look in registry for the next available message reference
                value and update the registry.  We will increment the number
                to keep track of the number of faxes sent or received.  Since
                the number is a DWORD, it should be sufficient for the life
                of the product.  ie, if we could send 1 fax every second,
                it would last over 137 years.
                We will maintain the number as a count of messages handled,
                and will use the current number before incrementing as the
                ulMessageRef.

                This number will increment for all attempts to send and
                receive, not just successes.

                WARNING: This code is not reentrant!

***************************************************************************/
ULONG GetNewMessageReference(void) {
    ULONG ulNum;

    if ((ulNum = GetInitializerInt(szMainSectionName, szContactNumberKey,
      0xFFFFFFFF, szIniSectionName)) == 0xFFFFFFFF) {
        // Start with a one.
        ulNum = 1;
    }

    WriteInitializerInt(szMainSectionName, szContactNumberKey, ulNum + 1,
      szIniSectionName);

    return(ulNum);
}


/***************************************************************************

    Name      : FindProperty

    Purpose   : Finds a property in a proparray

    Parameters: cProps = number of props in the array
                lpProps = proparray
                ulPropTag = property tag to look for

    Returns   : array index of property or NOT_FOUND

    Comment   :

***************************************************************************/
ULONG FindProperty(ULONG cProps, LPSPropValue lpProps, ULONG ulPropTag) {
    register ULONG i;

    for (i = 0; i < cProps; i++) {
        if (lpProps[i].ulPropTag == ulPropTag) {
            return(i);
        }
    }

    return((ULONG)-1);
}


/***************************************************************************

    Name      : FindAdrEntryID

    Purpose   : Find the PR_ENTRYID in the Nth ADRENTRY of an ADRLIST

    Parameters: lpAdrList -> AdrList
                index = which ADRENTRY to look at

    Returns   : return pointer to the SBinary structure of the ENTRYID value

    Comment   :

***************************************************************************/
LPSBinary FindAdrEntryID(LPADRLIST lpAdrList, ULONG index) {
    LPADRENTRY lpAdrEntry;
    ULONG i;

    if (lpAdrList && index < lpAdrList->cEntries) {

        lpAdrEntry = &(lpAdrList->aEntries[index]);

        for (i = 0; i < lpAdrEntry->cValues; i++) {
            if (lpAdrEntry->rgPropVals[i].ulPropTag == PR_ENTRYID) {
                return((LPSBinary)&lpAdrEntry->rgPropVals[i].Value);
            }
        }
    }
    return(NULL);
}



//
// Properties to get from the contents table
//
enum {
    ircPR_OBJECT_TYPE = 0,
    ircPR_ENTRYID,
    ircPR_DISPLAY_NAME,
    ircMax
};
static const SizedSPropTagArray(ircMax, ptaRoot) =
{
    ircMax,
    {
        PR_OBJECT_TYPE,
        PR_ENTRYID,
        PR_DISPLAY_NAME,
    }
};

HRESULT GetContainerEID(LPADRBOOK lpAdrBook, LPULONG lpcbEID, LPENTRYID * lppEID) {
    HRESULT hResult;
    ULONG ulObjType;
    LPABCONT lpRoot = NULL;
    LPMAPITABLE lpRootTable = NULL;
    LPSRowSet lpRow = NULL;

    if (ulContainerNumber) {
        // Get the root contents table
        if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
          0,
          NULL,
          NULL,
          0,
          &ulObjType,
          (LPUNKNOWN *)&lpRoot))) {
            if (! (hResult = lpRoot->lpVtbl->GetContentsTable(lpRoot,
              0,
              &lpRootTable))) {
                // Set the columns
                lpRootTable->lpVtbl->SetColumns(lpRootTable,
                  (LPSPropTagArray)&ptaRoot,
                  0);

                lpRootTable->lpVtbl->SeekRow(lpRootTable,
                  BOOKMARK_BEGINNING,
                  ulContainerNumber,
                  NULL);

                if (hResult = lpRootTable->lpVtbl->QueryRows(lpRootTable,
                  1,    // one row at a time
                  0,    // ulFlags
                  &lpRow)) {
                    DebugTrace("GetContainerEID: QueryRows -> %x\n", GetScode(hResult));
                } else {
                    // Found it, copy entryid to new allocation
                    if (lpRow->cRows) {
                        *lpcbEID = lpRow->aRow[0].lpProps[ircPR_ENTRYID].Value.bin.cb;
                        WABAllocateBuffer(*lpcbEID, lppEID);
                        memcpy(*lppEID, lpRow->aRow[0].lpProps[ircPR_ENTRYID].Value.bin.lpb, *lpcbEID);
                    } else {
                        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
                        DebugTrace("GetContainerEID couldn't find -> container %u\n", ulContainerNumber);
                    }

                    FreeProws(lpRow);
                }
                lpRootTable->lpVtbl->Release(lpRootTable);
            }
            lpRoot->lpVtbl->Release(lpRoot);
        }
    } else {
        hResult = lpAdrBook->lpVtbl->GetPAB(lpAdrBook,
          lpcbEID,
          lppEID);
    }
    return(hResult);
}


int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow) {
    HWND     hwnd ;
    MSG      msg ;
    WNDCLASS wndclass ;

    if (!hPrevInstance) {
        hInst = hInstance;

        wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
        wndclass.lpfnWndProc   = WndProc ;
        wndclass.cbClsExtra    = 0 ;
        wndclass.cbWndExtra    = 0 ;
        wndclass.hInstance     = hInstance ;
        wndclass.hIcon         = LoadIcon(NULL, IDI_APPLICATION) ;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
        wndclass.hbrBackground = GetStockObject(WHITE_BRUSH) ;
        wndclass.lpszMenuName  = szAppName ;
        wndclass.lpszClassName = szAppName ;

        RegisterClass (&wndclass) ;
    }


    hwnd = CreateWindow (szAppName, "WAB API Test",
      WS_OVERLAPPEDWINDOW,
      0,        // CW_USEDEFAULT,
      0,        // CW_USEDEFAULT,
      300,      // CW_USEDEFAULT,
      200,      // CW_USEDEFAULT,
      NULL,
      NULL,
      hInstance,
      NULL) ;

    ShowWindow (hwnd, nCmdShow) ;
    UpdateWindow (hwnd) ;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage (&msg) ;
        DispatchMessage (&msg) ;
    }
    return msg.wParam ;
}

long FAR PASCAL WndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam) {
    switch (message) {
        case WM_CREATE:
            if ((ulContainerNumber = GetInitializerInt(szMainSectionName, szContainerNumberKey,
              0xFFFFFFFF, szIniSectionName)) == 0xFFFFFFFF) {
                // None
                ulContainerNumber = 0;
            }
            break;

        case WM_COMMAND :
            switch (wParam) {
                case IDM_EXIT :
                    SendMessage (hwnd, WM_CLOSE, 0, 0L) ;
                    return 0 ;

                case IDM_GETME:
                    GetMeTest(hwnd);
                    return(0);

                case IDM_ALLOCATE:
                    AllocTest();
                    return(0);

                case IDM_IPROP:
                    IPropTest();
                    return(0);

                case IDM_GETSEARCHPATH:
                    GetSearchPathTest();
                    return(0);

                case IDM_CONTENTS_TABLE:
                    GetContentsTableTest();
                    return(0);

                case IDM_WABOPEN:
                    WABOpenTest();
                    return(0);

                case IDM_CREATE_ENTRY:
                    CreateEntryTest(hwnd, FALSE);
                    return(0);

                case IDM_CREATE_DL:
                    CreateEntryTest(hwnd, TRUE);
                    break;

                case IDM_RESOLVE_NAME:
                    ResolveNameTest(hwnd);
                    return(0);

                case IDM_DETAILS:
                    AddrBookDetailsTest(hwnd);
                    return(0);

                case IDM_DETAILS_ONE_OFF:
                    AddrBookDetailsOneOffTest(hwnd);
                    return(0);

                case IDM_RESOLVE_NAMES:
                    ResolveNamesTest(hwnd);
                    return(0);

                case IDM_DELETE_ENTRIES:
                    DeleteEntriesTest(hwnd);
                    return(0);

                case IDM_ADDRESS_WELLS0:
                    WABAddressTest(hwnd,ADDRESS_WELLS,0);
                    return(0);

                case IDM_ADDRESS_WELLS1:
                    WABAddressTest(hwnd,ADDRESS_WELLS,1);
                    return(0);

                case IDM_ADDRESS_WELLS2:
                    WABAddressTest(hwnd,ADDRESS_WELLS,2);
                    return(0);

                case IDM_ADDRESS_DEFAULT:
                    WABAddressTest(hwnd,ADDRESS_WELLS_DEFAULT,3);
                    return(0);

                case IDM_ADDRESS_WELLS3:
                    WABAddressTest(hwnd,ADDRESS_WELLS,3);
                    return(0);

                case IDM_ADDRESS_PICK_USER:
                    WABAddressTest(hwnd,ADDRESS_CONTENTS,0);
                    return(0);

                case IDM_ADDRESS_BROWSE_ONLY:
                    WABAddressTest(hwnd,ADDRESS_CONTENTS_BROWSE,0);
                    return(0);

                case IDM_ADDRESS_BROWSE_MODAL_ONLY:
                    WABAddressTest(hwnd,ADDRESS_CONTENTS_BROWSE_MODAL,0);
                    return(0);

                case IDM_ROOT_CONTAINER:
                    RootContainerTest();
                    return(0);

                case IDM_NOTIFICATIONS:
                    NotificationsTest(hwnd);
                    return(0);

                case IDM_ABOUT:
                    MessageBox (hwnd, "WAB API Function Test.",
                    szAppName, MB_ICONINFORMATION | MB_OK);
                    return(0);
                }
            break ;

        case WM_DESTROY:
            PostQuitMessage(0);
            return(0);
        }
    return(DefWindowProc (hwnd, message, wParam, lParam));
}


#define MAX_INPUT_STRING    200

void AllocTest(void) {
    LPTSTR lpBuffer = NULL;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;

    WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);

    WABAllocateBuffer(1234, &lpBuffer);
    WABFreeBuffer(lpBuffer);

    lpAdrBook->lpVtbl->Release(lpAdrBook);
    lpWABObject->lpVtbl->Release(lpWABObject);
}


// enum for setting the created properties
enum {
    imuPR_DISPLAY_NAME = 0,     // must be first so DL's can use same enum
    imuPR_SURNAME,
    imuPR_GIVEN_NAME,
    imuPR_EMAIL_ADDRESS,
    imuPR_ADDRTYPE,
    imuMax
};
static const SizedSPropTagArray(imuMax, ptag)=
{
    imuMax,
    {
        PR_DISPLAY_NAME,
        PR_SURNAME,
        PR_GIVEN_NAME,
        PR_EMAIL_ADDRESS,
        PR_ADDRTYPE,
    }
};

void IPropTest(void) {
    LPPROPDATA lpPropData = NULL;
    SPropValue spv[imuMax];
    LPTSTR lpszDisplayName = "Bruce Kelley xxxxx";
    LPTSTR lpszEmailName = "brucek_xxxxx@microsoft.com";
    HRESULT hResult = hrSuccess;

    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;

    hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);

    WABCreateIProp(NULL,
        (LPALLOCATEBUFFER)WABAllocateBuffer,
        (LPALLOCATEMORE)WABAllocateMore,
        (LPFREEBUFFER)WABFreeBuffer,
        NULL,
        &lpPropData);


    if (lpPropData) {

        spv[imuPR_EMAIL_ADDRESS].ulPropTag      = PR_EMAIL_ADDRESS;
        spv[imuPR_EMAIL_ADDRESS].Value.lpszA    = lpszEmailName;

        spv[imuPR_ADDRTYPE].ulPropTag           = PR_ADDRTYPE;
        spv[imuPR_ADDRTYPE].Value.lpszA         = "SMTP";

        spv[imuPR_DISPLAY_NAME].ulPropTag       = PR_DISPLAY_NAME;
        spv[imuPR_DISPLAY_NAME].Value.lpszA     = lpszDisplayName;

        spv[imuPR_SURNAME].ulPropTag            = PR_SURNAME;
        spv[imuPR_SURNAME].Value.lpszA          = "Kelley";

        spv[imuPR_GIVEN_NAME].ulPropTag         = PR_GIVEN_NAME;
        spv[imuPR_GIVEN_NAME].Value.lpszA       = "Bruce";

        if (HR_FAILED(hResult = lpPropData->lpVtbl->SetProps(lpPropData,   // this
          imuMax,                   // cValues
          spv,                      // property array
          NULL))) {                 // problems array
        }

        hResult = lpPropData->lpVtbl->SaveChanges(lpPropData,               // this
          0);                       // ulFlags


        lpPropData->lpVtbl->Release(lpPropData);
    }

    lpAdrBook->lpVtbl->Release(lpAdrBook);
    lpWABObject->lpVtbl->Release(lpWABObject);
}

#define WORKS_STUFF TRUE


#ifdef WORKS_STUFF
#define PR_WKS_CONTACT_CHECKED	 PROP_TAG( PT_LONG, 0x8020)
const SizedSPropTagArray(4 , ipta) = {
    4,                             // count of entries
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
        PR_OBJECT_TYPE,
        PR_WKS_CONTACT_CHECKED,
    }
};
#else
const SizedSPropTagArray(3 , ipta) = {
      3,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
        PR_OBJECT_TYPE,
    }
};
#endif



#ifdef WORKS_STUFF
#define nStatusCheck 1

HRESULT RestrictToContactAndCheck(LPMAPITABLE pWabTable)
{
    SRestriction resAnd[2];
    SRestriction resResolve;
    SPropValue propRestrict0, propRestrict1;
    HRESULT hr;

    // Restrict to get checked status
    resAnd[0].rt = RES_PROPERTY; // Restriction type Property
    resAnd[0].res.resProperty.relop = RELOP_EQ;
    resAnd[0].res.resProperty.ulPropTag = PR_WKS_CONTACT_CHECKED;
    resAnd[0].res.resProperty.lpProp = &propRestrict0;
    propRestrict0.ulPropTag = PR_WKS_CONTACT_CHECKED;
    propRestrict0.Value.ul = nStatusCheck; // this is actually a #define with value of 1


    // Restrict to get contact (MailUsers)
    resAnd[1].rt = RES_PROPERTY; // Restriction type Property
    resAnd[1].res.resProperty.relop = RELOP_EQ;
    resAnd[1].res.resProperty.ulPropTag = PR_OBJECT_TYPE;
    resAnd[1].res.resProperty.lpProp = &propRestrict1;
    propRestrict1.ulPropTag = PR_OBJECT_TYPE;
    propRestrict1.Value.ul = MAPI_MAILUSER;

    resResolve.rt = RES_AND;
    resResolve.res.resAnd.cRes = 2;
    resResolve.res.resAnd.lpRes = resAnd;

    hr = pWabTable->lpVtbl->Restrict(pWabTable, &resResolve, 0);
    return(hr);
}
#endif



#ifdef PHONE_STUFF

#define WAB_PHONE_TYPE_COUNT 2
ULONG WABPHONEPROPLIST[WAB_PHONE_TYPE_COUNT] = {
    PR_BUSINESS_TELEPHONE_NUMBER,
    PR_HOME_TELEPHONE_NUMBER
};

/*----------------------------------------------------------------------------

Purpose:  Given a phone number returns the Name in the WAB if exists.

Paramaters:
    LPCTSTR lpcstrInputNumber:    Input Number string
#ifdef OLD_STUFF
    LPTSTR  lptstrOutputName:     Output Name string
#endif // OLD_STUFF


History
02/10/97      a-ericwa  Created
----------------------------------------------------------------------------*/
HRESULT WABNumberToName(LPADRBOOK m_pAdrBook, LPCTSTR lpcstrInputNumber) {
    HRESULT hRes = NOERROR;
    LPENTRYID lpEntryID = NULL;
    LPABCONT lpContainer = NULL;
    LPMAPITABLE lpMapiTable = NULL;
    UINT  cColumn = 0;
    LPSPropValue lpPropValue = NULL;
    LPSRowSet lpRow = NULL;
    ULONG ulObjType = 0;
    ULONG ulCounter = 0;
    ULONG ulRowCount = 0;
    ULONG ulEntryIDSize = 0;
    LPSTR lpszTempOutput = NULL;
    BOOL bFound = FALSE;

    SRestriction srOr, srPhoneNumType[WAB_PHONE_TYPE_COUNT]; //for the restriction
    SPropValue spvPhoneNumType[WAB_PHONE_TYPE_COUNT];         // d dd ddd ditto

    SizedSPropTagArray(21, OUR_PROPTAG_ARRAY) = {
        21, {
            PR_OBJECT_TYPE,
            PR_ENTRYID,
            PR_DISPLAY_NAME,
            PR_CALLBACK_TELEPHONE_NUMBER,
            PR_BUSINESS_TELEPHONE_NUMBER,
            PR_OFFICE_TELEPHONE_NUMBER,
            PR_HOME_TELEPHONE_NUMBER,
            PR_PRIMARY_TELEPHONE_NUMBER,
            PR_BUSINESS2_TELEPHONE_NUMBER,
            PR_OFFICE2_TELEPHONE_NUMBER,
            PR_MOBILE_TELEPHONE_NUMBER,
            PR_CELLULAR_TELEPHONE_NUMBER,
            PR_RADIO_TELEPHONE_NUMBER,
            PR_CAR_TELEPHONE_NUMBER,
            PR_OTHER_TELEPHONE_NUMBER,
            PR_PAGER_TELEPHONE_NUMBER,
            PR_BEEPER_TELEPHONE_NUMBER,
            PR_ASSISTANT_TELEPHONE_NUMBER,
            PR_HOME2_TELEPHONE_NUMBER,
            PR_PRIMARY_FAX_NUMBER,
            PR_HOME_FAX_NUMBER,
        }
    };

    //validate input
    if (!lpcstrInputNumber) {
        goto WABNTN_Exit;
    }

    //Get the PAB
    hRes = m_pAdrBook->lpVtbl->GetPAB(m_pAdrBook,
      &ulEntryIDSize,     //size
      &lpEntryID);        //EntryId
    if (FAILED(hRes)) {
        goto WABNTN_Exit;
    }

    //Open the root container
    hRes = m_pAdrBook->lpVtbl->OpenEntry(m_pAdrBook,
      ulEntryIDSize,  // size of EntryID to open
      lpEntryID,      // EntryID to open
      NULL,           // interface
      0,              // flags  (default is Read Only)
      &ulObjType,     //object type
      (LPUNKNOWN *)&lpContainer); //returned object
    if (FAILED(hRes) || (ulObjType != MAPI_ABCONT)) {
        goto WABNTN_Exit;
    }


    //Get the contents
    hRes = lpContainer->lpVtbl->GetContentsTable(lpContainer,
      0,    //FLAGS
      &lpMapiTable);  //returned Table Object
    if (FAILED(hRes)) {
        goto WABNTN_Exit;
    }

    // Set desired columns
    hRes = lpMapiTable->lpVtbl->SetColumns(lpMapiTable,
      (LPSPropTagArray)&OUR_PROPTAG_ARRAY,   // SPropTagArray of desired rows
      0);                                    //  reserved Must be zero for the WAB
    if (FAILED(hRes)) {
        goto WABNTN_Exit;
    }

    //Seek to the beginning
    hRes = lpMapiTable->lpVtbl->SeekRow(lpMapiTable, BOOKMARK_BEGINNING, 0, NULL);
    if (FAILED(hRes)) {
        goto WABNTN_Exit;
    }

    //Create the restriction
    srOr.rt = RES_OR;
    srOr.res.resOr.cRes = WAB_PHONE_TYPE_COUNT;
    srOr.res.resOr.lpRes = srPhoneNumType;
    for (ulCounter = 0; ulCounter < WAB_PHONE_TYPE_COUNT; ulCounter++) {
        spvPhoneNumType[ulCounter].ulPropTag = WABPHONEPROPLIST[ulCounter];
        spvPhoneNumType[ulCounter].Value.lpszA = (LPSTR) lpcstrInputNumber;
        spvPhoneNumType[ulCounter].dwAlignPad = 0;

        srPhoneNumType[ulCounter].rt = RES_CONTENT;
        srPhoneNumType[ulCounter].res.resContent.ulFuzzyLevel = FL_SUBSTRING;   //Fuzzy level
        srPhoneNumType[ulCounter].res.resContent.ulPropTag = WABPHONEPROPLIST[ulCounter];
        srPhoneNumType[ulCounter].res.resContent.lpProp = &(spvPhoneNumType[ulCounter]);
    }

    //Set the restriction
    if (hRes = lpMapiTable->lpVtbl->Restrict(lpMapiTable, &srOr, 0)) {
        DebugTrace("Restrict -> %x\n", GetScode(hRes));
    }

    DebugMapiTable(lpMapiTable);

    //Did any match?
    hRes = lpMapiTable->lpVtbl->GetRowCount(lpMapiTable, 0, &ulRowCount);
    if (FAILED(hRes) || (!ulRowCount)) {
        goto WABNTN_Exit;
    }


    //Get the name of the first match
    for (ulCounter = 0; ulCounter < ulRowCount; ulCounter++) {
        //Found at least one row
        hRes = lpMapiTable->lpVtbl->QueryRows(lpMapiTable, 1, // one row at a time
          0, // ulFlags
          &lpRow);
        if (FAILED(hRes) || (!lpRow->cRows)) {
            goto WABNTN_Exit;
        }

        //Get the Dispay Name Data
        lpPropValue = lpRow->aRow[0].lpProps;
        for(cColumn = 0; cColumn < lpRow->aRow[0].cValues; cColumn++) {
            if (lpPropValue->ulPropTag == PR_DISPLAY_NAME) {

                bFound = TRUE;
                break;
            }
            lpPropValue++;
        }   // cColumn loop

        if (lpRow) {
            WABFreeBuffer(lpRow); lpRow = NULL;
        }
        if (bFound) {
            break;
        }

    } //ulCounter loop

WABNTN_Exit:
    if (lpMapiTable) {
        lpMapiTable->lpVtbl->Release(lpMapiTable);
    }
    if (lpContainer) {
        lpContainer->lpVtbl->Release(lpContainer);
    }
    if (lpEntryID) {
        WABFreeBuffer(lpEntryID);
    }

    return(hRes);
}
#endif


void GetSearchPathTest(void)
{
    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;

    hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);

    if (lpAdrBook) 
    {
        ULONG i = 0, j=0;
        LPTSTR lpsz = NULL;
        LPSRowSet lpsrs = NULL;
        hResult = lpAdrBook->lpVtbl->GetSearchPath( lpAdrBook,
                                                    0,
                                                    &lpsrs);
        if(lpsrs && lpsrs->cRows)
        {
            ULONG nLen = 0;
            for(i=0;i<lpsrs->cRows;i++)
            {
                for(j=0;j<lpsrs->aRow[i].cValues;j++)
                {
                    if(lpsrs->aRow[i].lpProps[j].ulPropTag == PR_DISPLAY_NAME)
                    {
                        nLen += lstrlen(lpsrs->aRow[i].lpProps[j].Value.LPSZ) + lstrlen("\r\n") + 1;
                        break;
                    }
                }
            }
            lpsz = LocalAlloc(LMEM_ZEROINIT, nLen);
            if(lpsz)
            {
                *lpsz = '\0';
                for(i=0;i<lpsrs->cRows;i++)
                {
                    for(j=0;j<lpsrs->aRow[i].cValues;j++)
                    {
                        if(lpsrs->aRow[i].lpProps[j].ulPropTag == PR_DISPLAY_NAME)
                        {
                            lstrcat(lpsz,lpsrs->aRow[i].lpProps[j].Value.LPSZ);
                            lstrcat(lpsz,"\r\n");
                            break;
                        }
                    }
                }
                MessageBox(NULL, lpsz, "List of ResolveName containers", MB_OK);
            }

            if(lpsz)
                LocalFree(lpsz);
            for(i=0;i<lpsrs->cRows;i++)
                WABFreeBuffer(lpsrs->aRow[i].lpProps);
            WABFreeBuffer(lpsrs);
        }

        lpAdrBook->lpVtbl->Release(lpAdrBook);
    }

    if (lpWABObject) 
    {
        lpWABObject->lpVtbl->Release(lpWABObject);
    }


}

void GetContentsTableTest(void) {
    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    LPABCONT lpContainer = NULL;
    LPMAPITABLE lpContentsTable = NULL;
    ULONG ulObjType;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG cbWABEID;
    LPENTRYID lpWABEID = NULL;


    hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);

    if (lpAdrBook) {

#ifdef PHONE_STUFF
        WABNumberToName(lpAdrBook, "869-8347");
#endif

        if (! (hResult = GetContainerEID(lpAdrBook, &cbWABEID, &lpWABEID))) {
            if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
              cbWABEID,     // size of EntryID to open
              lpWABEID,     // EntryID to open
              NULL,         // interface
              0,            // flags
              &ulObjType, (LPUNKNOWN *)&lpContainer))) {
                // Opened PAB container OK
                // Call GetContentsTable on it.

                if (! (hResult = lpContainer->lpVtbl->GetContentsTable(lpContainer,
                  0,    // ulFlags
                  &lpContentsTable))) {
                    SRestriction res;
                    SPropValue propRestrict;
                    SizedSSortOrderSet(1, sos) = {
                        1,
                        0,
                        0,
                        {
                            PR_DISPLAY_NAME,
                            TABLE_SORT_DESCEND
                        }
                    };

                    res.rt = RES_PROPERTY;
                    res.res.resProperty.relop = RELOP_EQ;
                    res.res.resProperty.ulPropTag = PR_OBJECT_TYPE;
                    res.res.resProperty.lpProp = &propRestrict;
                    propRestrict.ulPropTag = PR_OBJECT_TYPE;
                    propRestrict.Value.ul = MAPI_DISTLIST; // MAPI_MAILUSER for Contact


                    hResult = lpContentsTable->lpVtbl->Restrict(lpContentsTable, &res, 0);


                    lpContentsTable->lpVtbl->SetColumns(lpContentsTable,
                      (LPSPropTagArray)&ipta, 0);

                    DebugMapiTable(lpContentsTable);

                    hResult = lpContentsTable->lpVtbl->SortTable(lpContentsTable,
                      (LPSSortOrderSet)&sos, 0);

//                    RestrictToContactAndCheck(lpContentsTable);

                    DebugMapiTable(lpContentsTable);

                    lpContentsTable->lpVtbl->Release(lpContentsTable);
                }

                lpContainer->lpVtbl->Release(lpContainer);
            }
            WABFreeBuffer(lpWABEID);
        }

        lpAdrBook->lpVtbl->Release(lpAdrBook);
    }
    if (lpWABObject) {
        lpWABObject->lpVtbl->Release(lpWABObject);
    }
}


extern LPALLOCATEBUFFER lpfnMAPIAllocateBuffer;
extern LPALLOCATEMORE lpfnMAPIAllocateMore;
extern LPFREEBUFFER lpfnMAPIFreeBuffer;
extern HRESULT MAPIInitialize(LPVOID lpMapiInit);


void WABOpenTest(void) {
    LPWABOBJECT lpWABObject1 = NULL, lpWABObject2 = NULL;
    LPADRBOOK lpAdrBook1 = NULL, lpAdrBook2 = NULL;
    LPABCONT lpContainer = NULL;
    HRESULT hResult = hrSuccess;
    LPTSTR lpBuffer1 = NULL;
    LPTSTR lpBuffer2 = NULL;
    ULONG ulObjType;
    ULONG cbWABEID;
    LPENTRYID lpWABEID = NULL;


    hResult = WABOpen(&lpAdrBook1, &lpWABObject1, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject1);


    if (!hResult) {
        if (! (hResult = WABOpen(&lpAdrBook2, &lpWABObject2, NULL, 0))) {
            lpWABObject2->lpVtbl->Release(lpWABObject2);
            lpAdrBook2->lpVtbl->Release(lpAdrBook2);
            lpAdrBook2 = NULL;
        }
    }

    if (lpAdrBook1) {
        if (! (hResult = GetContainerEID(lpAdrBook1, &cbWABEID, &lpWABEID))) {

            if (! (hResult = lpAdrBook1->lpVtbl->OpenEntry(lpAdrBook1,
              cbWABEID,     // size of EntryID to open
              lpWABEID,     // EntryID to open
              NULL,         // interface
              0,            // flags
              &ulObjType, (LPUNKNOWN *)&lpContainer))) {
            // Opened container OK

            lpContainer->lpVtbl->Release(lpContainer);
            }
            WABFreeBuffer(lpWABEID);
        }


        lpAdrBook1->lpVtbl->Release(lpAdrBook1);
        lpAdrBook1 = NULL;
    }
    if (lpWABObject1) {

        lpWABObject1->lpVtbl->AllocateBuffer(lpWABObject1, 1234, &lpBuffer1);
        lpWABObject1->lpVtbl->AllocateMore(lpWABObject1, 4321, lpBuffer1, &lpBuffer2);
        lpWABObject1->lpVtbl->FreeBuffer(lpWABObject1, lpBuffer1);

        lpWABObject1->lpVtbl->Release(lpWABObject1);
        lpWABObject1 = NULL;
    }


    // Try WABOpenEx

    MAPIInitialize(NULL);

    WABOpenEx(&lpAdrBook1, &lpWABObject1, NULL, 0,
      lpfnMAPIAllocateBuffer,
      lpfnMAPIAllocateMore,
      lpfnMAPIFreeBuffer);
    SetGlobalBufferFunctions(lpWABObject1);

    if (lpAdrBook1) {
        if (! (hResult = GetContainerEID(lpAdrBook1, &cbWABEID, &lpWABEID))) {

            if (! (hResult = lpAdrBook1->lpVtbl->OpenEntry(lpAdrBook1,
              cbWABEID,     // size of EntryID to open
              lpWABEID,     // EntryID to open
              NULL,         // interface
              0,            // flags
              &ulObjType, (LPUNKNOWN *)&lpContainer))) {
                // Opened container OK
                LPMAPITABLE lpContentsTable = NULL;

                if (! (hResult = lpContainer->lpVtbl->GetContentsTable(lpContainer,
                  0,    // ulFlags
                  &lpContentsTable))) {
                    SRestriction res;
                    SPropValue propRestrict;
                    SizedSSortOrderSet(1, sos) = {
                        1,
                        0,
                        0,
                        {
                            PR_DISPLAY_NAME,
                            TABLE_SORT_DESCEND
                        }
                    };

                    res.rt = RES_PROPERTY;
                    res.res.resProperty.relop = RELOP_EQ;
                    res.res.resProperty.ulPropTag = PR_OBJECT_TYPE;
                    res.res.resProperty.lpProp = &propRestrict;
                    propRestrict.ulPropTag = PR_OBJECT_TYPE;
                    propRestrict.Value.ul = MAPI_DISTLIST; // MAPI_MAILUSER for Contact


                    hResult = lpContentsTable->lpVtbl->Restrict(lpContentsTable, &res, 0);


                    lpContentsTable->lpVtbl->SetColumns(lpContentsTable,
                      (LPSPropTagArray)&ipta, 0);

                    DebugMapiTable(lpContentsTable);

                    hResult = lpContentsTable->lpVtbl->SortTable(lpContentsTable,
                      (LPSSortOrderSet)&sos, 0);

//                    RestrictToContactAndCheck(lpContentsTable);

                    DebugMapiTable(lpContentsTable);

                    lpContentsTable->lpVtbl->Release(lpContentsTable);
                }

                lpContainer->lpVtbl->Release(lpContainer);
            }
            WABFreeBuffer(lpWABEID);
        }


        lpAdrBook1->lpVtbl->Release(lpAdrBook1);
        lpAdrBook1 = NULL;
    }
    if (lpWABObject1) {

        lpWABObject1->lpVtbl->AllocateBuffer(lpWABObject1, 1234, &lpBuffer1);
        lpWABObject1->lpVtbl->AllocateMore(lpWABObject1, 4321, lpBuffer1, &lpBuffer2);
        lpWABObject1->lpVtbl->FreeBuffer(lpWABObject1, lpBuffer1);

        lpWABObject1->lpVtbl->Release(lpWABObject1);
        lpWABObject1 = NULL;
    }
}




//
// BUGBUG: Notifications are NOT YET IMPLEMENTED in WAB!
//
#undef	INTERFACE
#define	INTERFACE	struct _ADVS

#undef MAPIMETHOD_
#define MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, ADVS_)
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIADVISESINK_METHODS(IMPL)
#undef	MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(ADVS_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIADVISESINK_METHODS(IMPL)
};


typedef struct _ADVS FAR *LPADVS;

typedef struct _ADVS
{
	ADVS_Vtbl *		lpVtbl;
	UINT			cRef;
	LPMALLOC		pmalloc;
	LPVOID			lpvContext;
  LPNOTIFCALLBACK	lpfnCallback;
} ADVS;


ADVS_Vtbl vtblADVS =
{
	ADVS_QueryInterface,
	ADVS_AddRef,
	ADVS_Release,
	ADVS_OnNotify
};


STDMETHODIMP
ADVS_QueryInterface(LPADVS padvs, REFIID lpiid, LPVOID *ppvObj)
{
	HRESULT	hr;

	if (IsEqualMAPIUID((LPMAPIUID)lpiid, (LPMAPIUID)&IID_IUnknown) ||
		IsEqualMAPIUID((LPMAPIUID)lpiid, (LPMAPIUID)&IID_IMAPIAdviseSink))
	{
		++padvs->cRef;
		*ppvObj = padvs;
		hr = hrSuccess;
	} else {
		*ppvObj = NULL;
		hr = ResultFromScode(E_NOINTERFACE);
	}
	return hr;
}

STDMETHODIMP_(ULONG)
ADVS_AddRef(LPADVS padvs)
{
	return((ULONG)(++padvs->cRef));
}

STDMETHODIMP_(ULONG)
ADVS_Release(LPADVS padvs)
{
	if (--(padvs->cRef) == 0)
	{
		WABFreeBuffer(padvs);
		return 0L;
	}

	return (ULONG)padvs->cRef;
}

STDMETHODIMP_(ULONG)
ADVS_OnNotify(LPADVS padvs, ULONG cNotif, LPNOTIFICATION lpNotif)
{
	return (*(padvs->lpfnCallback))(padvs->lpvContext, cNotif, lpNotif);
}



void NotificationsTest(HWND hwnd) {
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    LPABCONT lpContainer = NULL;
    HRESULT hResult = hrSuccess;
    ULONG ulObjType;
    ULONG cbWABEID;
    LPENTRYID lpWABEID = NULL;
    ULONG ulConnection = 0;
    LPMAPIADVISESINK lpAdvs = NULL;


    hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);


    if (lpAdrBook) {
        if (! (hResult = GetContainerEID(lpAdrBook, &cbWABEID, &lpWABEID))) {

            if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
              cbWABEID,     // size of EntryID to open
              lpWABEID,     // EntryID to open
              NULL,         // interface
              0,            // flags
              &ulObjType, (LPUNKNOWN *)&lpContainer))) {
                // Opened container OK

                // Create the Advise Sink Object
                WABAllocateBuffer(sizeof(ADVS), &lpAdvs);
                ZeroMemory(lpAdvs, sizeof(ADVS));
                lpAdvs->lpVtbl = (struct IMAPIAdviseSinkVtbl *)&vtblADVS;
                lpAdvs->lpVtbl->AddRef(lpAdvs);


                // Call Advise on address book object
                if (! (hResult = lpAdrBook->lpVtbl->Advise(lpAdrBook,
                  cbWABEID,
                  lpWABEID,
                  fnevObjectCreated | fnevObjectDeleted | fnevObjectModified,
                  lpAdvs,
                  &ulConnection))) {

                    // Advise succeeded.
                    // Do something to fire a notification
                    WABAddressTest(hwnd, ADDRESS_CONTENTS_BROWSE_MODAL, 0);

                    if (! (hResult = lpAdrBook->lpVtbl->Unadvise(lpAdrBook,
                      ulConnection))) {

                    }
                }

                lpAdvs->lpVtbl->Release(lpAdvs);

                lpContainer->lpVtbl->Release(lpContainer);
            }
            WABFreeBuffer(lpWABEID);
        }


        lpAdrBook->lpVtbl->Release(lpAdrBook);
    }
    if (lpWABObject) {
        lpWABObject->lpVtbl->Release(lpWABObject);
    }
}


void ResolveNamesTest(HWND hwnd) {
#define MAX_INPUT_STRING    200
    TCHAR lpszInput[MAX_INPUT_STRING + 1] = "";
    LPADRLIST lpAdrList = NULL;
    ULONG rgFlagList[2];
    LPFlagList lpFlagList = (LPFlagList)rgFlagList;
    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    LPABCONT lpContainer = NULL;
    ULONG ulObjType;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG cbWABEID;
    LPENTRYID lpWABEID = NULL;


    if (InputString(hInst, hwnd, szAppName, "Resolve Name", lpszInput, MAX_INPUT_STRING)) {

        hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
        SetGlobalBufferFunctions(lpWABObject);

        if (lpAdrBook) {
            if (! (hResult = GetContainerEID(lpAdrBook, &cbWABEID, &lpWABEID))) {

                if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                  cbWABEID,     // size of EntryID to open
                  lpWABEID,     // EntryID to open
                  NULL,         // interface
                  0,            // flags
                  &ulObjType, (LPUNKNOWN *)&lpContainer))) {
                    // Opened container OK
                    // Call ResolveNames on it.

                    if (! (sc = WABAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), &lpAdrList))) {
                        lpAdrList->cEntries = 1;
                        lpAdrList->aEntries[0].ulReserved1 = 0;
                        lpAdrList->aEntries[0].cValues = 1;
                        if (! (sc = WABAllocateBuffer(sizeof(SPropValue), &lpAdrList->aEntries[0].rgPropVals))) {

                            lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
                            lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszInput;

                            lpFlagList->cFlags = 1;
                            lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

                            if (! (hResult = lpContainer->lpVtbl->ResolveNames(lpContainer,
                              NULL,            // tag set
                              0,               // ulFlags
                              lpAdrList,
                              lpFlagList))) {
                                DebugADRLIST(lpAdrList, "Resolved ADRLIST");
                            }
                        }

                        WABFreePadrlist(lpAdrList);
                    }

                    lpContainer->lpVtbl->Release(lpContainer);
                }
                WABFreeBuffer(lpWABEID);
            }

            lpAdrBook->lpVtbl->Release(lpAdrBook);
        }
        if (lpWABObject) {
            lpWABObject->lpVtbl->Release(lpWABObject);
        }
    }
}


// enum for setting the created properties
enum {
    irnPR_DISPLAY_NAME = 0,
    irnPR_RECIPIENT_TYPE,
    irnPR_ENTRYID,
    irnPR_EMAIL_ADDRESS,
    irnMax
};

void ResolveNameTest(HWND hwnd) {
    TCHAR lpszInput1[MAX_INPUT_STRING + 1] = "";
    TCHAR lpszInput2[MAX_INPUT_STRING + 1] = "";
    LPADRLIST lpAdrList = NULL;
    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG ulObjectType;
    LPMAILUSER lpMailUser = NULL;
    ULONG i = 0;


    if (InputString(hInst, hwnd, szAppName, "Resolve Name", lpszInput1, MAX_INPUT_STRING)) {

        hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
        SetGlobalBufferFunctions(lpWABObject);

        if (lpAdrBook) {
            if (! (sc = WABAllocateBuffer(sizeof(ADRLIST) + 5 * sizeof(ADRENTRY), &lpAdrList))) {
                lpAdrList->cEntries = 5;
                for (i = 0; i < lpAdrList->cEntries; i++) {
                    lpAdrList->aEntries[i].cValues = 0;
                    lpAdrList->aEntries[i].rgPropVals = NULL;
                }


                lpAdrList->aEntries[0].ulReserved1 = 0;
                lpAdrList->aEntries[0].cValues = irnMax - 1;    // No PR_EMAIL_ADDRESS;
                if (! (sc = WABAllocateBuffer(lpAdrList->aEntries[0].cValues * sizeof(SPropValue),
                   &lpAdrList->aEntries[0].rgPropVals))) {

                    lpAdrList->aEntries[0].rgPropVals[irnPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
                    lpAdrList->aEntries[0].rgPropVals[irnPR_DISPLAY_NAME].Value.LPSZ = lpszInput1;

                    lpAdrList->aEntries[0].rgPropVals[irnPR_RECIPIENT_TYPE].ulPropTag = PR_RECIPIENT_TYPE;
                    lpAdrList->aEntries[0].rgPropVals[irnPR_RECIPIENT_TYPE].Value.l = MAPI_TO;

                    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].ulPropTag = PR_ENTRYID;
                    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.cb = 0;
                    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.lpb = NULL;


                    hResult = lpAdrBook->lpVtbl->ResolveName(lpAdrBook,
                      (ULONG)hwnd,            // ulUIParam
                      MAPI_DIALOG,            // ulFlags
                      "APITest ResolveName",  // lpszNewEntryTitle
                      lpAdrList);

                    DebugTrace("ResolveName [%s] -> %x\n", lpszInput1, GetScode(hResult));

                    if (! HR_FAILED(hResult)) {
                        // Open the entry and dump it's properties

                        // Should have PR_ENTRYID in rgPropVals[2]
                        if (lpAdrList->aEntries[0].rgPropVals[2].ulPropTag == PR_ENTRYID) {

                            if (! (HR_FAILED(hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                      lpAdrList->aEntries[0].rgPropVals[2].Value.bin.cb,
                                                      (LPENTRYID)lpAdrList->aEntries[0].rgPropVals[2].Value.bin.lpb,
                                                      NULL,
                                                      0,
                                                      &ulObjectType,
                                                      (LPUNKNOWN *)&(lpMailUser))))) {
                                DebugObjectProps((LPMAPIPROP)lpMailUser, "Resolved Entry Properties");
                                lpMailUser->lpVtbl->Release(lpMailUser);
                            }
                        } else {
                            DebugTrace("Hey!  What happened to my PR_ENTRYID?\n");
                        }
                    }
                }
            }

            WABFreePadrlist(lpAdrList);

            lpAdrBook->lpVtbl->Release(lpAdrBook);
        }
        if (lpWABObject) {
            lpWABObject->lpVtbl->Release(lpWABObject);
        }
    }
}


// enum for getting the entryid of an entry
enum {
    ieidPR_DISPLAY_NAME = 0,
    ieidPR_ENTRYID,
    ieidMax
};
static const SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
    }
};

enum {
    iconPR_DEF_CREATE_MAILUSER = 0,
    iconPR_DEF_CREATE_DL,
    iconMax
};
static const SizedSPropTagArray(iconMax, ptaCon)=
{
    iconMax,
    {
        PR_DEF_CREATE_MAILUSER,
        PR_DEF_CREATE_DL,
    }
};

void DeleteEntriesTest(HWND hwnd) {
    TCHAR lpszInput[MAX_INPUT_STRING + 1] = "";
    LPADRLIST lpAdrList = NULL;
    ULONG rgFlagList[2];
    LPFlagList lpFlagList = (LPFlagList)rgFlagList;
    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    LPABCONT lpContainer = NULL;
    ULONG ulObjType;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG cbWABEID;
    LPENTRYID lpWABEID = NULL;
    ENTRYLIST EntryList;


    if (InputString(hInst, hwnd, szAppName, "Resolve Name", lpszInput, MAX_INPUT_STRING)) {

        hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
        SetGlobalBufferFunctions(lpWABObject);

        if (lpAdrBook) {
            if (! (hResult = GetContainerEID(lpAdrBook, &cbWABEID, &lpWABEID))) {

                if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                  cbWABEID,     // size of EntryID to open
                  lpWABEID,     // EntryID to open
                  NULL,         // interface
                  0,            // flags
                  &ulObjType, (LPUNKNOWN *)&lpContainer))) {
                    // Opened container OK
                    // Call ResolveNames on it.

                    if (! (sc = WABAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), &lpAdrList))) {
                        lpAdrList->cEntries = 1;
                        lpAdrList->aEntries[0].ulReserved1 = 0;
                        lpAdrList->aEntries[0].cValues = 1;
                        if (! (sc = WABAllocateBuffer(ieidMax * sizeof(SPropValue),
                          &lpAdrList->aEntries[0].rgPropVals))) {

                            lpAdrList->aEntries[0].rgPropVals[ieidPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
                            lpAdrList->aEntries[0].rgPropVals[ieidPR_DISPLAY_NAME].Value.LPSZ = lpszInput;

                            lpAdrList->aEntries[0].rgPropVals[ieidPR_ENTRYID].ulPropTag = PR_ENTRYID;
                            lpAdrList->aEntries[0].rgPropVals[ieidPR_ENTRYID].Value.bin.cb = 0;
                            lpAdrList->aEntries[0].rgPropVals[ieidPR_ENTRYID].Value.bin.lpb = NULL;

                            lpFlagList->cFlags = 1;
                            lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

                            lpContainer->lpVtbl->ResolveNames(lpContainer,
                              (LPSPropTagArray)&ptaEid,         // tag set
                              0,               // ulFlags
                              lpAdrList,
                              lpFlagList);

                            if (lpFlagList->ulFlag[0] != MAPI_RESOLVED) {
                                DebugTrace("Couldn't resolve name %s\n", lpszInput);
                            } else {
                                // Create a list of entryid's to delete
                                EntryList.cValues = 1;
                                EntryList.lpbin = &(lpAdrList->aEntries[0].rgPropVals[ieidPR_ENTRYID].Value.bin);


                                // Now, delete the entry found.
                                if (hResult = lpContainer->lpVtbl->DeleteEntries(lpContainer,
                                  &EntryList,
                                  0)) {
                                    DebugTrace("DeleteEntries -> %x", hResult);
                                }
                            }
                        }

                        WABFreePadrlist(lpAdrList);
                    }

                    lpContainer->lpVtbl->Release(lpContainer);
                }
                WABFreeBuffer(lpWABEID);
            }

            lpAdrBook->lpVtbl->Release(lpAdrBook);
        }
        if (lpWABObject) {
            lpWABObject->lpVtbl->Release(lpWABObject);
        }
    }
}


void TestNamedProps(LPMAILUSER lpEntry) {
    MAPINAMEID mnidT1;
    LPMAPINAMEID lpmnidT1;
    HRESULT hr;
    GUID guidT1 = { /* 13fbb976-15a2-11d0-9b9f-00c04fd90294 */
      0x13fbb976,
      0x15a2,
      0x11d0,
      {0x9b, 0x9f, 0x00, 0xc0, 0x4f, 0xd9, 0x02, 0x94}
    };


    LPSPropTagArray lptaga = NULL;
    SPropValue spv;
    MAPINAMEID mnidT2;
    LPMAPINAMEID lpmnidT2;
    GUID guidT2 = { /* 39f110d8-15a2-11d0-9b9f-00c04fd90294 */
      0x39f110d8,
      0x15a2,
      0x11d0,
      {0x9b, 0x9f, 0x00, 0xc0, 0x4f, 0xd9, 0x02, 0x94}
    };

    //
    //  We just made up that GUID.  On NT try uuidgen -s to get your own
    //

    mnidT1.lpguid = &guidT1;
    mnidT1.ulKind = MNID_ID;        //  This means union will contain a long...
    mnidT1.Kind.lID = 0x00000001;   // numeric property 1

    lpmnidT1 = &mnidT1;

    hr = lpEntry->lpVtbl->GetIDsFromNames(lpEntry,
      1, // Just one name
      &lpmnidT1, // &-of because this is an array
      MAPI_CREATE, // This is where MAPI_CREATE might go
      &lptaga);
    if (hr) {
        //
        //  I'd really be suprised if I got S_OK for this...
        //
        if (GetScode(hr) != MAPI_W_ERRORS_RETURNED) {
            //  Real error here
            goto out;
        }

        //  Basically, this means you don't have anything by this name and you
        //  didn't ask the object to create it.

        //$ no biggie
    }

    //  Free the lptaga, as it was allocated by the object and returned to the calling
    //  app.
    WABFreeBuffer(lptaga);


    //
    //  And here's how to successfully add a named property to an object.  In this case
    //  we'll slap on in and I'll demonstrate how to use this new property.
    //
    //
    //  We just made up that GUID.  On NT try uuidgen -s to get your own
    //

    mnidT2.lpguid = &guidT2;
    mnidT2.ulKind = MNID_STRING;    //  This means union will contain a UNICODE string...
    mnidT2.Kind.lpwstrName = L"Check out this cool property!";

    lpmnidT2 = &mnidT2;

    hr = lpEntry->lpVtbl->GetIDsFromNames(lpEntry,
      1, // Just one name
      &lpmnidT2, // &-of because this is an array
      MAPI_CREATE,
      &lptaga);
    if (hr) {
        //
        //  I'd really be suprised if I got S_OK for this...
        //
        if (GetScode(hr) != MAPI_W_ERRORS_RETURNED) {
            //  Real error here
            goto out;
        }

        //  Basically, this means you don't have anything by this name and you
        //  didn't ask the object to create it.

        //$ no biggie
    }

    //
    //  Ok, so what can I do with this ptaga?  Well, we can set a value for it by doing:
    //
    spv.ulPropTag = CHANGE_PROP_TYPE(lptaga->aulPropTag[0],PT_STRING8);
    spv.Value.lpszA = "This property brought to you by the letter M";

    hr = lpEntry->lpVtbl->SetProps(lpEntry,
      1,
      &spv,
      NULL);
    if (HR_FAILED(hr)) {
        goto out;
    }

    lpEntry->lpVtbl->SaveChanges(lpEntry,               // this
      KEEP_OPEN_READONLY);      // ulFlags

    DebugObjectProps((LPMAPIPROP)lpEntry, "");


    lpEntry->lpVtbl->DeleteProps(lpEntry, lptaga, NULL);


    DebugObjectProps((LPMAPIPROP)lpEntry, "");

    //  Free the lptaga, as it was allocated by the object and returned to the calling
    //  app.
    WABFreeBuffer(lptaga);
out:
    return;
}


void CreateEntryTest(HWND hwnd, BOOL fDL) {
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    LPABCONT lpContainer = NULL;
    HRESULT hResult = hrSuccess;
    LPTSTR lpBuffer1 = NULL;
    LPTSTR lpBuffer2 = NULL;
    ULONG ulObjType;
    LPMAPIPROP lpMailUser = NULL;
    SPropValue spv[imuMax];
    TCHAR lpszDisplayName[MAX_INPUT_STRING + 1] = "";
    TCHAR lpszEmailName[MAX_INPUT_STRING + 1] = "brucek_xxxxx@microsoft.com";
    ULONG ulContactNumber;
    ULONG cbWABEID;
    LPENTRYID lpWABEID = NULL;
    LPSPropValue lpCreateEIDs = NULL;
    LPSPropValue lpNewDLProps = NULL;
    ULONG cProps;
    ULONG ulObjectType;
    LPDISTLIST lpDistList = NULL;
    LPBYTE lpBuffer;


    hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);

    if (lpAdrBook) {
        if (! (hResult = GetContainerEID(lpAdrBook, &cbWABEID, &lpWABEID))) {

            if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
              cbWABEID,     // size of EntryID to open
              lpWABEID,     // EntryID to open
              NULL,         // interface
              0,            // flags
              &ulObjType, (LPUNKNOWN *)&lpContainer))) {
                // Opened PAB container OK
                DebugObjectProps((LPMAPIPROP)lpContainer, "WAB Container");

                ulContactNumber = GetNewMessageReference();
                if (! InputString(hInst, hwnd, szAppName, "Create Entry Name", lpszDisplayName, sizeof(lpszDisplayName))) {
                    wsprintf(lpszDisplayName, "Bruce Kelley %05u", ulContactNumber);
                }

                wsprintf(lpszEmailName, "brucek_%05u@microsoft.com", ulContactNumber);

                // Get us the creation entryids
                if ((hResult = lpContainer->lpVtbl->GetProps(lpContainer, (LPSPropTagArray)&ptaCon, 0, &cProps, &lpCreateEIDs))) {
                    DebugTrace("Can't get container properties for PAB\n");
                    // Bad stuff here!
                    return;
                }

                // Validate the properites
                if (lpCreateEIDs[iconPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
                  lpCreateEIDs[iconPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL) {
                    DebugTrace("Container property errors\n");
                    return;
                }

                if (fDL) {
                    LPDISTLIST lpNewObj = NULL;

                    // Create the default DL
                    if (! (hResult = lpContainer->lpVtbl->CreateEntry(lpContainer,
                      lpCreateEIDs[iconPR_DEF_CREATE_DL].Value.bin.cb,
                      (LPENTRYID)lpCreateEIDs[iconPR_DEF_CREATE_DL].Value.bin.lpb,
                      CREATE_CHECK_DUP_STRICT,
                      &lpMailUser))) {


                        // Set the display name
                        spv[imuPR_DISPLAY_NAME].ulPropTag       = PR_DISPLAY_NAME;
                        spv[imuPR_DISPLAY_NAME].Value.lpszA     = lpszDisplayName;

                        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,   // this
                          1,                        // cValues
                          spv,                      // property array
                          NULL))) {                 // problems array
                        }

                        hResult = lpMailUser->lpVtbl->SaveChanges(lpMailUser,               // this
                          KEEP_OPEN_READONLY);      // ulFlags

                        DebugObjectProps((LPMAPIPROP)lpMailUser, "New Distribution List");


                        lpNewObj = NULL;
                        lpMailUser->lpVtbl->QueryInterface(lpMailUser,
                          &IID_IDistList,
                          &lpNewObj);

                        if (lpNewObj) {
                            (lpNewObj)->lpVtbl->Release(lpNewObj);
                        }


                        // Get the EntryID so we can open it...
                        if ((hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
                          (LPSPropTagArray)&ptaEid,
                          0,
                          &cProps,
                          &lpNewDLProps))) {
                            DebugTrace("Can't get DL properties\n");
                            // Bad stuff here!
                            return;
                        }

                        lpMailUser->lpVtbl->Release(lpMailUser);

                        // Now, open the new entry as a DL
                        hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                          lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb,
                          (LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,
                          (LPIID)&IID_IDistList,
                          MAPI_MODIFY,
                          &ulObjectType,
                          (LPUNKNOWN*)&lpDistList);
                        if (lpDistList) {
                            ADRPARM AdrParms = {0};
                            LPADRLIST lpAdrList = NULL;
                            ULONG i;
                            LPSBinary lpsbEntryID;
                            LPMAPIPROP lpEntry = NULL;
                            LPMAPITABLE lpContentsTable = NULL;

                            // Do something with the DL object
                            // Add an entry to the DL

                            // Get entries to add.
                            AdrParms.ulFlags = DIALOG_MODAL;
                            AdrParms.lpszCaption = "Choose entries for this Distribution List";
                            AdrParms.cDestFields = 1;

                            hResult = lpAdrBook->lpVtbl->Address(lpAdrBook,
                              (LPULONG)&hwnd,
                              &AdrParms,
                              &lpAdrList);

                            if (! hResult && lpAdrList) {
                                for (i = 0; i < lpAdrList->cEntries; i++) {
                                    if (lpsbEntryID = FindAdrEntryID(lpAdrList, i)) {
                                        if (hResult = lpDistList->lpVtbl->CreateEntry(lpDistList,
                                          lpsbEntryID->cb,
                                          (LPENTRYID)lpsbEntryID->lpb,
                                          CREATE_CHECK_DUP_STRICT,
                                          &lpEntry)) {

                                            break;
                                        }

                                        hResult = lpEntry->lpVtbl->SaveChanges(lpEntry, FORCE_SAVE);

                                        if (lpEntry) {
                                            lpEntry->lpVtbl->Release(lpEntry);
                                            lpEntry = NULL;
                                        }
                                    }
                                }

                                DebugObjectProps((LPMAPIPROP)lpDistList, "Distribution List");

                                // Open the table object on the DL

                                if (! (hResult = lpDistList->lpVtbl->GetContentsTable(lpDistList,
                                  0,
                                  &lpContentsTable))) {
                                    ULONG ulRowCount;

                                    if (hResult = lpContentsTable->lpVtbl->GetRowCount(lpContentsTable,
                                      0,
                                      &ulRowCount)) {
                                        DebugTrace("GetRowCount -> %x\n", hResult);
                                    } else {
                                        DebugTrace("GetRowCount found %u rows\n", ulRowCount);
                                    }

                                    DebugTrace("Distribution list contents:\n");
                                    DebugMapiTable(lpContentsTable);

                                    lpContentsTable->lpVtbl->Release(lpContentsTable);
                                }

                                // Delete the entry from the DL
                                {
                                    ENTRYLIST el;


                                    el.cValues = 1;
                                    el.lpbin = lpsbEntryID;

                                    if (hResult = lpDistList->lpVtbl->DeleteEntries(lpDistList,
                                      &el,
                                      0)) {
                                        DebugTrace("DISTLIST_DeleteEntries -> %x\n", GetScode(hResult));
                                    }
                                }


                            }
                            if (lpAdrList) {
                                WABFreePadrlist(lpAdrList);
                            }

                            lpDistList->lpVtbl->Release(lpDistList);
                        }

                        if (lpNewDLProps) {
                            WABFreeBuffer(lpNewDLProps);
                        }
                    }
                } else {
                    if (! (hResult = lpContainer->lpVtbl->CreateEntry(lpContainer,
                      lpCreateEIDs[iconPR_DEF_CREATE_MAILUSER].Value.bin.cb,
                      (LPENTRYID)lpCreateEIDs[iconPR_DEF_CREATE_MAILUSER].Value.bin.lpb,
                      CREATE_CHECK_DUP_STRICT,
                      &lpMailUser))) {
                        // Successful creation of entry.  Do something with it.

#ifdef OLD_STUFF
                        // Try saving with no props.  Should fail.
                        hResult = lpMailUser->lpVtbl->SaveChanges(lpMailUser,               // this
                          KEEP_OPEN_READONLY);      // ulFlags


                        // Try just setting PR_COMPANY_NAME
                        spv[0].ulPropTag      = PR_COMPANY_NAME;
                        spv[0].Value.lpszA    = "Somebody's Company";
                        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,   // this
                          1,                        // cValues
                          spv,                      // property array
                          NULL))) {                 // problems array
                        }

                        hResult = lpMailUser->lpVtbl->SaveChanges(lpMailUser,               // this
                          KEEP_OPEN_READONLY);      // ulFlags

                        DebugObjectProps((LPMAPIPROP)lpMailUser, "New MailUser");

#endif // OLD_STUFF

                        spv[imuPR_EMAIL_ADDRESS].ulPropTag      = PR_EMAIL_ADDRESS;
                        spv[imuPR_EMAIL_ADDRESS].Value.lpszA    = lpszEmailName;

                        spv[imuPR_ADDRTYPE].ulPropTag           = PR_ADDRTYPE;
                        spv[imuPR_ADDRTYPE].Value.lpszA         = "SMTP";
                        spv[imuPR_DISPLAY_NAME].ulPropTag       = PR_DISPLAY_NAME;
                        spv[imuPR_DISPLAY_NAME].Value.lpszA     = lpszDisplayName;

                        spv[imuPR_SURNAME].ulPropTag = PR_NULL;
                        spv[imuPR_GIVEN_NAME].ulPropTag = PR_NULL;

#ifdef OLD_STUFF
// This case exercises the display name regeneration
                        spv[imuPR_DISPLAY_NAME].ulPropTag       = PR_DISPLAY_NAME;
                        spv[imuPR_DISPLAY_NAME].Value.lpszA     = "Stan Freck";

                        spv[imuPR_SURNAME].ulPropTag            = PR_SURNAME;
                        spv[imuPR_SURNAME].Value.lpszA          = "Freck";

                        spv[imuPR_GIVEN_NAME].ulPropTag         = PR_GIVEN_NAME;
                        spv[imuPR_GIVEN_NAME].Value.lpszA       = "Stanley";
#endif


                        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,   // this
                          imuMax,                   // cValues
                          spv,                      // property array
                          NULL))) {                 // problems array
                        }


#define ICON_SIZE   100000
                        WABAllocateBuffer(ICON_SIZE, &lpBuffer);
                        FillMemory(lpBuffer, ICON_SIZE, 'B');

                        spv[0].ulPropTag = PR_ICON;
                        spv[0].Value.bin.cb = ICON_SIZE;
                        spv[0].Value.bin.lpb = lpBuffer;

                        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,   // this
                          1,                   // cValues
                          spv,                      // property array
                          NULL))) {                 // problems array
                        }

                        WABFreeBuffer(lpBuffer);

                        TestNamedProps((LPMAILUSER)lpMailUser);

                        hResult = lpMailUser->lpVtbl->SaveChanges(lpMailUser,               // this
                          KEEP_OPEN_READONLY);      // ulFlags


                        DebugObjectProps((LPMAPIPROP)lpMailUser, "New MailUser");

                        lpMailUser->lpVtbl->Release(lpMailUser);
                    }
                }

                WABFreeBuffer(lpCreateEIDs);

                lpContainer->lpVtbl->Release(lpContainer);

            }
            WABFreeBuffer(lpWABEID);
        }


        lpAdrBook->lpVtbl->Release(lpAdrBook);
    }
    if (lpWABObject) {
        lpWABObject->lpVtbl->Release(lpWABObject);
    }
}

void STDMETHODCALLTYPE TestDismissFunction(ULONG ulUIParam, LPVOID lpvContext)
{
    LPDWORD lpdw = (LPDWORD) lpvContext;
    DebugTrace("TestDismissFunction [5x]:[%d]\n",ulUIParam,*lpdw);
    return;
}

DWORD dwContext = 77;

void WABAddressTest(HWND hWnd, int iFlag, int cDestWells)
{
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    LPADRLIST lpAdrList = NULL;
    HRESULT hResult = hrSuccess;
    LPSPropValue rgProps;
    SCODE sc;
    ADRPARM AdrParms = {0};
    ULONG i=0;
    DWORD dwEntryID1=22;
    LPTSTR lpszDestFieldsTitles[]={ TEXT("Title # 1"),
                                    TEXT("2nd Title"),
                                    TEXT("Third in line")
                                    };

    hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);

    if (lpAdrBook)
    {
        if(iFlag!=ADDRESS_CONTENTS)
        {
            sc = WABAllocateBuffer(sizeof(ADRLIST)+sizeof(ADRENTRY), &lpAdrList);
            lpAdrList->cEntries = 1;
            lpAdrList->aEntries[0].cValues = 7;
            sc = WABAllocateBuffer(7 * sizeof(SPropValue),&rgProps);
            lpAdrList->aEntries[0].rgPropVals = rgProps;
            lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
            lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = TEXT("Charlie Chaplin");
            lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_EMAIL_ADDRESS;
            lpAdrList->aEntries[0].rgPropVals[1].Value.LPSZ = TEXT("test@test1.com");
            lpAdrList->aEntries[0].rgPropVals[2].ulPropTag = PR_ADDRTYPE;
            lpAdrList->aEntries[0].rgPropVals[2].Value.LPSZ = TEXT("SMTP");
            lpAdrList->aEntries[0].rgPropVals[3].ulPropTag = PR_SURNAME;
            lpAdrList->aEntries[0].rgPropVals[3].Value.LPSZ = TEXT("Chaplin");
            lpAdrList->aEntries[0].rgPropVals[4].ulPropTag = PR_GIVEN_NAME;
            lpAdrList->aEntries[0].rgPropVals[4].Value.LPSZ = TEXT("Charlie");
            lpAdrList->aEntries[0].rgPropVals[5].ulPropTag = PR_RECIPIENT_TYPE;
            lpAdrList->aEntries[0].rgPropVals[5].Value.l = MAPI_TO;
            lpAdrList->aEntries[0].rgPropVals[6].ulPropTag = PR_ENTRYID;
            dwEntryID1 = 22;
            lpAdrList->aEntries[0].rgPropVals[6].Value.bin.lpb = NULL;
            lpAdrList->aEntries[0].rgPropVals[6].Value.bin.cb = 0;
        }
        switch(iFlag)
        {
        case(ADDRESS_CONTENTS_BROWSE_MODAL):
            AdrParms.cDestFields = 0;
            AdrParms.ulFlags = DIALOG_MODAL;
            break;
        case(ADDRESS_CONTENTS_BROWSE):
            AdrParms.cDestFields = 0;
            AdrParms.ulFlags = DIALOG_SDI;
            AdrParms.lpvDismissContext = &dwContext;
            AdrParms.lpfnDismiss = &TestDismissFunction;
            AdrParms.lpfnABSDI = NULL;
            break;
        case(ADDRESS_CONTENTS):
            AdrParms.cDestFields = 0;
            AdrParms.ulFlags = DIALOG_MODAL | ADDRESS_ONE;
            lpAdrList = NULL;
            break;
        case(ADDRESS_WELLS):
            AdrParms.cDestFields = cDestWells;
            AdrParms.ulFlags = DIALOG_MODAL;
            AdrParms.lppszDestTitles=lpszDestFieldsTitles;
            break;
        case(ADDRESS_WELLS_DEFAULT):
            AdrParms.cDestFields = cDestWells;
            AdrParms.ulFlags = DIALOG_MODAL;
            AdrParms.lppszDestTitles=NULL;
            break;
        }
        AdrParms.lpszCaption = "ApiTest Address Book Test";

        AdrParms.nDestFieldFocus = AdrParms.cDestFields-1;

        hResult = lpAdrBook->lpVtbl->Address(  lpAdrBook,
                                                (ULONG *) &hWnd,
                                                &AdrParms,
                                                &lpAdrList);

        if (AdrParms.lpfnABSDI)
        {
            (*(AdrParms.lpfnABSDI))((ULONG) hWnd, (LPVOID) NULL);
        }

        if (lpAdrList)
        {
            for(i=0;i<lpAdrList->aEntries[0].cValues;i++)
            {
                if(lpAdrList->aEntries[0].rgPropVals[i].ulPropTag == PR_ENTRYID)
                {
                    lpAdrBook->lpVtbl->Details(lpAdrBook,
                                                (LPULONG)&hWnd,
                                                NULL,
                                                NULL,
                                                lpAdrList->aEntries[0].rgPropVals[i].Value.bin.cb,
                                                (LPENTRYID) lpAdrList->aEntries[0].rgPropVals[i].Value.bin.lpb,
                                                NULL,
                                                NULL,
                                                NULL,
                                                0);
                }
            }
            WABFreePadrlist(lpAdrList);
        }

        lpAdrBook->lpVtbl->Release(lpAdrBook);
    }

    if (lpWABObject) {

        lpWABObject->lpVtbl->Release(lpWABObject);
    }
}



int _stdcall WinMainCRTStartup (void)
{
        int i;
        STARTUPINFOA si;
        PTSTR pszCmdLine = GetCommandLine();

        SetErrorMode(SEM_FAILCRITICALERRORS);

        if (*pszCmdLine == TEXT ('\"'))
        {
                // Scan, and skip over, subsequent characters until
                // another double-quote or a null is encountered.
                while (*++pszCmdLine && (*pszCmdLine != TEXT ('\"')));

                // If we stopped on a double-quote (usual case), skip over it.
                if (*pszCmdLine == TEXT ('\"')) pszCmdLine++;
        }
        else
        {
                while (*pszCmdLine > TEXT (' ')) pszCmdLine++;
        }

        // Skip past any white space preceeding the second token.
        while (*pszCmdLine && (*pszCmdLine <= TEXT (' '))) pszCmdLine++;

        si.dwFlags = 0;
        GetStartupInfo (&si);

        i = WinMainT(GetModuleHandle (NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

        ExitProcess(i);

        return i;
}


void AddrBookDetailsTest(HWND hWnd)
{

    TCHAR lpszInput[MAX_INPUT_STRING + 1] = "";
    DWORD dwEntryID;
    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    SCODE sc = SUCCESS_SUCCESS;
    LPMAILUSER lpMailUser = NULL;
    int i = 0,nLen=0;



    if (nLen = InputString(hInst, hWnd, szAppName, "Enter EntryID", lpszInput, MAX_INPUT_STRING))
    {

        dwEntryID=0;
        for(i=0;i<nLen;i++)
        {
            char a = lpszInput[i];
            if ((a <= '9') && (a >= '0'))
                dwEntryID = dwEntryID*10 + a - '0';
        }
        hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
        SetGlobalBufferFunctions(lpWABObject);

        if (lpAdrBook)
        {

            hResult = lpAdrBook->lpVtbl->Details(lpAdrBook,
                                                  (LPULONG) &hWnd,            // ulUIParam
                                                  NULL,
                                                  NULL,
                                                  sizeof(DWORD),
                                                  (LPENTRYID) &dwEntryID,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  0);

            lpAdrBook->lpVtbl->Release(lpAdrBook);
        }
        if (lpWABObject) {
            lpWABObject->lpVtbl->Release(lpWABObject);
        }
    }

}

void AddrBookDetailsOneOffTest(HWND hWnd)
{

    TCHAR lpszInput[MAX_INPUT_STRING + 1] = "";
    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    SCODE sc = SUCCESS_SUCCESS;
    LPMAILUSER lpMailUser = NULL;
    ULONG i = 0,nLen=0;
    LPENTRYID lpEntryID = NULL;
    ULONG cbEntryID = 0;
    ULONG ulObjectType = 0;
    LPADRLIST lpAdrList = NULL;


    if (nLen = InputString(hInst, hWnd, szAppName, "Enter One-Off Address", lpszInput, MAX_INPUT_STRING))
    {

        hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
        SetGlobalBufferFunctions(lpWABObject);


        if (lpAdrBook)
        {
                // generate a one off entry-id by calling resolvenames on the input one-off address

            if (! (sc = WABAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), &lpAdrList)))
            {
                lpAdrList->cEntries = 1;
                lpAdrList->aEntries[0].ulReserved1 = 0;
                lpAdrList->aEntries[0].cValues = 1;

                if (! (sc = WABAllocateBuffer(lpAdrList->aEntries[0].cValues * sizeof(SPropValue),
                                                &lpAdrList->aEntries[0].rgPropVals)))
                {

                    lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
                    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszInput;

                    hResult = lpAdrBook->lpVtbl->ResolveName(lpAdrBook,
                                                              (ULONG)hWnd,            // ulUIParam
                                                              0,            // ulFlags
                                                              "APITest ResolveName",  // lpszNewEntryTitle
                                                              lpAdrList);

                    DebugTrace("ResolveName [%s] -> %x\n", lpszInput, GetScode(hResult));

                    if (! HR_FAILED(hResult))
                    {
                        // Open the entry and dump it's properties

                        for(i=0;i<lpAdrList->aEntries[0].cValues;i++)
                        {
                            if (lpAdrList->aEntries[0].rgPropVals[i].ulPropTag == PR_ENTRYID)
                            {

                                cbEntryID = lpAdrList->aEntries[0].rgPropVals[i].Value.bin.cb;
                                lpEntryID = (LPENTRYID)lpAdrList->aEntries[0].rgPropVals[i].Value.bin.lpb;

                                if (! (HR_FAILED(hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                          cbEntryID,
                                                          lpEntryID,
                                                          NULL,
                                                          0,
                                                          &ulObjectType,
                                                          (LPUNKNOWN *)&(lpMailUser)))))
                                {
                                    DebugObjectProps((LPMAPIPROP)lpMailUser, "Resolved Entry Properties");
                                    lpMailUser->lpVtbl->Release(lpMailUser);
                                }

                                hResult = lpAdrBook->lpVtbl->Details(lpAdrBook,
                                                          (LPULONG) &hWnd,            // ulUIParam
                                                          NULL,
                                                          NULL,
                                                          cbEntryID,
                                                          lpEntryID,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          0);
                          }
                        }

                    }

                }


                WABFreePadrlist(lpAdrList);
            }

            lpAdrBook->lpVtbl->Release(lpAdrBook);

        }


        if (lpWABObject)
        {
           lpWABObject->lpVtbl->Release(lpWABObject);
        }
    }


    return;
}


//
// Properties to get for each row of the contents table
//
enum {
    iptaColumnsPR_OBJECT_TYPE = 0,
    iptaColumnsPR_ENTRYID,
    iptaColumnsPR_DISPLAY_NAME,
    iptaColumnsMax
};
static const SizedSPropTagArray(iptaColumnsMax, ptaColumns) =
{
    iptaColumnsMax,
    {
        PR_OBJECT_TYPE,
        PR_ENTRYID,
        PR_DISPLAY_NAME,
    }
};

void RootContainerTest(void) {
    LPMAPITABLE lpRootTable = NULL;
    HRESULT hResult;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    LPABCONT lpRoot = NULL;
    ULONG ulObjType;
    ULONG cRows = 0;
    LPSRowSet lpRow = NULL;
    LPABCONT lpContainer = NULL;



    hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);

    // Check out the ROOT container
    if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
      0,
      NULL,
      NULL,
      0,
      &ulObjType,
      (LPUNKNOWN *)&lpRoot))) {
        DebugObjectProps((LPMAPIPROP)lpRoot, "WAB Root Container");

        if (! (hResult = lpRoot->lpVtbl->GetContentsTable(lpRoot,
          0,
          &lpRootTable))) {

            DebugTrace("Root container contents:\n");
            DebugMapiTable(lpRootTable);


            // Set the columns
            lpRootTable->lpVtbl->SetColumns(lpRootTable,
              (LPSPropTagArray)&ptaColumns,
              0);


            // Open each container object
            cRows = 1;
            while (cRows) {
                if (hResult = lpRootTable->lpVtbl->QueryRows(lpRootTable,
                  1,    // one row at a time
                  0,    // ulFlags
                  &lpRow)) {
                    DebugTrace("QueryRows -> %x\n", GetScode(hResult));
                } else if (lpRow) {
                    if (cRows = lpRow->cRows) { // Yes, single '='
                        // Open the entry

                        if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                          lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                          (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb,
                          NULL,
                          0,
                          &ulObjType,
                          (LPUNKNOWN *)&lpContainer))) {
                            DebugObjectProps((LPMAPIPROP)lpContainer, "Container");
                            lpContainer->lpVtbl->Release(lpContainer);
                        }
                    }
                    FreeProws(lpRow);
                }
            }

            lpRootTable->lpVtbl->Release(lpRootTable);
        }
        lpRoot->lpVtbl->Release(lpRoot);
    }

    lpAdrBook->lpVtbl->Release(lpAdrBook);
    lpWABObject->lpVtbl->Release(lpWABObject);
}




void GetMeTest(HWND hWnd)
{

    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    SCODE sc = SUCCESS_SUCCESS;
    LPMAILUSER lpMailUser = NULL;
    int i = 0,nLen=0;
    SBinary sbEID;

    {
        hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
        SetGlobalBufferFunctions(lpWABObject);

        if(lpWABObject)
        {
            DWORD dwAction;
            lpWABObject->lpVtbl->GetMe(lpWABObject, lpAdrBook,
                                        0, &dwAction,
                                        &sbEID, 0);
        }

        if (lpAdrBook)
        {

            hResult = lpAdrBook->lpVtbl->Details(lpAdrBook,
                                                  (LPULONG) &hWnd,            // ulUIParam
                                                  NULL,
                                                  NULL,
                                                  sbEID.cb,
                                                  (LPENTRYID) sbEID.lpb,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  0);
            lpAdrBook->lpVtbl->Release(lpAdrBook);
        }
        if (lpWABObject) {
            lpWABObject->lpVtbl->Release(lpWABObject);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\apitest\apitest.h ===
#define IDM_NEW                     1
#define IDM_OPEN                    2
#define IDM_SAVE                    3
#define IDM_SAVEAS                  4
#define IDM_EXIT                    5

#define IDM_UNDO                    10
#define IDM_CUT                     11
#define IDM_COPY                    12
#define IDM_PASTE                   13
#define IDM_DEL                     14

#define IDM_WHITE                   20
#define IDM_LTGRAY                  21
#define IDM_GRAY                    22
#define IDM_DKGRAY                  23
#define IDM_BLACK                   24

#define IDM_START                   30
#define IDM_STOP                    31

#define IDM_HELP                    40
#define IDM_ABOUT                   41

#define IDM_ALLOCATE                1001
#define IDM_IPROP                   1002
#define IDM_WABOPEN                 1003
#define IDM_CREATE_ENTRY            1004
#define IDM_RESOLVE_NAME            1005
#define IDM_ADDRESS                 1006
#define IDM_ADDRESS_PICK_USER       1007
#define IDM_CONTENTS_TABLE          1008
#define IDM_DELETE_ENTRIES          1009
#define IDM_ADDRESS_BROWSE_ONLY     1010
#define IDM_RESOLVE_NAMES           1011
#define IDM_DETAILS                 1012
#define IDM_DETAILS_ONE_OFF         1013
#define IDM_ADDRESS_WELLS0          1014
#define IDM_ADDRESS_WELLS1          1015
#define IDM_ADDRESS_WELLS2          1016
#define IDM_ADDRESS_WELLS3          1017
#define IDM_ADDRESS_DEFAULT         1018
#define IDM_CREATE_DL               1019
#define IDM_ADDRESS_BROWSE_MODAL_ONLY 1020
#define IDM_ROOT_CONTAINER          1023
#define IDM_NOTIFICATIONS           1024
#define IDM_GETSEARCHPATH           1025
#define IDM_GETME                   1035
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\apitest\dbgutil.c ===
/***********************************************************************
 *
 * DBGUTIL.C
 *
 * Debug utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/

#include <windows.h>
#include <wab.h>

#include "apitest.h"
#include "dbgutil.h"

#define _WAB_DBGUTIL_C

PUCHAR PropTagName(ULONG ulPropTag);
const TCHAR szNULL[] = "";

extern SCODE WABFreeBuffer(LPVOID lpBuffer);
VOID FAR CDECL DebugTrace(LPSTR lpszFmt, ...);



/***************************************************************************

    Name      : FreeBufferAndNull

    Purpose   : Frees a MAPI buffer and NULLs the pointer

    Parameters: lppv = pointer to buffer pointer to free

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall FreeBufferAndNull(LPVOID * lppv) {
    if (lppv) {
        if (*lppv) {
            SCODE sc;
            if (sc = WABFreeBuffer(*lppv)) {
                DebugTrace("WABFreeBuffer(%x) -> 0x%08x\n", *lppv, sc);
            }
            *lppv = NULL;
        }
    }
}


/***************************************************************************

    Name      : ReleaseAndNull

    Purpose   : Releases an object and NULLs the pointer

    Parameters: lppv = pointer to pointer to object to release

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall ReleaseAndNull(LPVOID * lppv) {
    LPUNKNOWN * lppunk = (LPUNKNOWN *)lppv;

    if (lppunk) {
        if (*lppunk) {
            HRESULT hResult;

            if (hResult = (*lppunk)->lpVtbl->Release(*lppunk)) {
                DebugTrace("Release(%x) -> 0x%08x\n", *lppunk, GetScode(hResult));
            }
            *lppunk = NULL;
        }
    }
}


/***************************************************************************

    Name      : PropTypeString

    Purpose   : Map a proptype to a string

    Parameters: ulPropType = property type to map

    Returns   : string pointer to name of prop type

    Comment   :

***************************************************************************/
LPTSTR PropTypeString(ULONG ulPropType) {
    switch (ulPropType) {
        case PT_UNSPECIFIED:
            return("PT_UNSPECIFIED");
        case PT_NULL:
            return("PT_NULL       ");
        case PT_I2:
            return("PT_I2         ");
        case PT_LONG:
            return("PT_LONG       ");
        case PT_R4:
            return("PT_R4         ");
        case PT_DOUBLE:
            return("PT_DOUBLE     ");
        case PT_CURRENCY:
            return("PT_CURRENCY   ");
        case PT_APPTIME:
            return("PT_APPTIME    ");
        case PT_ERROR:
            return("PT_ERROR      ");
        case PT_BOOLEAN:
            return("PT_BOOLEAN    ");
        case PT_OBJECT:
            return("PT_OBJECT     ");
        case PT_I8:
            return("PT_I8         ");
        case PT_STRING8:
            return("PT_STRING8    ");
        case PT_UNICODE:
            return("PT_UNICODE    ");
        case PT_SYSTIME:
            return("PT_SYSTIME    ");
        case PT_CLSID:
            return("PT_CLSID      ");
        case PT_BINARY:
            return("PT_BINARY     ");
        case PT_MV_I2:
            return("PT_MV_I2      ");
        case PT_MV_LONG:
            return("PT_MV_LONG    ");
        case PT_MV_R4:
            return("PT_MV_R4      ");
        case PT_MV_DOUBLE:
            return("PT_MV_DOUBLE  ");
        case PT_MV_CURRENCY:
            return("PT_MV_CURRENCY");
        case PT_MV_APPTIME:
            return("PT_MV_APPTIME ");
        case PT_MV_SYSTIME:
            return("PT_MV_SYSTIME ");
        case PT_MV_STRING8:
            return("PT_MV_STRING8 ");
        case PT_MV_BINARY:
            return("PT_MV_BINARY  ");
        case PT_MV_UNICODE:
            return("PT_MV_UNICODE ");
        case PT_MV_CLSID:
            return("PT_MV_CLSID   ");
        case PT_MV_I8:
            return("PT_MV_I8      ");
        default:
            return("   <unknown>  ");
    }
}


/***************************************************************************

    Name      : TraceMVPStrings

    Purpose   : Debug trace a multivalued string property value

    Parameters: lpszCaption = caption string
                PropValue = property value to dump

    Returns   : none

    Comment   :

***************************************************************************/
void _TraceMVPStrings(LPTSTR lpszCaption, SPropValue PropValue) {
    ULONG i;

    DebugTrace("-----------------------------------------------------\n");
    DebugTrace("%s", lpszCaption);
    switch (PROP_TYPE(PropValue.ulPropTag)) {

        case PT_ERROR:
            DebugTrace("Error value 0x%08x\n", PropValue.Value.err);
            break;

        case PT_MV_TSTRING:
            DebugTrace("%u values\n", PropValue.Value.MVSZ.cValues);

            if (PropValue.Value.MVSZ.cValues) {
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
                for (i = 0; i < PropValue.Value.MVSZ.cValues; i++) {
                    DebugTrace("%u: \"%s\"\n", i, PropValue.Value.MVSZ.LPPSZ[i]);
                }
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
            }
            break;

        default:
            DebugTrace("TraceMVPStrings got incorrect property type %u for tag %x\n",
              PROP_TYPE(PropValue.ulPropTag), PropValue.ulPropTag);
            break;
    }
}


/***************************************************************************

    Name      : DebugBinary

    Purpose   : Debug dump an array of bytes

    Parameters: cb = number of bytes to dump
                lpb -> bytes to dump

    Returns   : none

    Comment   :

***************************************************************************/
#define DEBUG_NUM_BINARY_LINES  2
VOID DebugBinary(UINT cb, LPBYTE lpb) {
    UINT cbLines = 0;

#if (DEBUG_NUM_BINARY_LINES != 0)
    UINT cbi;

    while (cb && cbLines < DEBUG_NUM_BINARY_LINES) {
        cbi = min(cb, 16);
        cb -= cbi;

        switch (cbi) {
            case 16:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14],
                  lpb[15]);
                break;
            case 1:
                DebugTrace("%02x\n", lpb[0]);
                break;
            case 2:
                DebugTrace("%02x %02x\n", lpb[0], lpb[1]);
                break;
            case 3:
                DebugTrace("%02x %02x %02x\n", lpb[0], lpb[1], lpb[2]);
                break;
            case 4:
                DebugTrace("%02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3]);
                break;
            case 5:
                DebugTrace("%02x %02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3],
                  lpb[4]);
                break;
            case 6:
                DebugTrace("%02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5]);
                break;
            case 7:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6]);
                break;
            case 8:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7]);
                break;
            case 9:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8]);
                break;
            case 10:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9]);
                break;
            case 11:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10]);
                break;
            case 12:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11]);
                break;
            case 13:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12]);
                break;
            case 14:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13]);
                break;
            case 15:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14]);
                break;
        }
        lpb += cbi;
        cbLines++;
    }
    if (cb) {
        DebugTrace("<etc.>");    //
    }
#endif
}


#define MAX_TIME_DATE_STRING    64
/***************************************************************************

    Name      : FormatTime

    Purpose   : Format a time string for the locale

    Parameters: lpst -> system time/date
                lptstr -> output buffer
                cchstr = size in chars of lpstr

    Returns   : number of characters used/needed (including null)

    Comment   : If cchstr < the return value, nothing will be written
                to lptstr.

***************************************************************************/
UINT FormatTime(LPSYSTEMTIME lpst, LPTSTR lptstr, UINT cchstr) {
    return((UINT)GetTimeFormat(LOCALE_USER_DEFAULT,
      0, lpst, NULL, lptstr, cchstr));
}


/***************************************************************************

    Name      : FormatDate

    Purpose   : Format a date string for the locale

    Parameters: lpst -> system time/date
                lptstr -> output buffer
                cchstr = size in chars of lpstr

    Returns   : number of characters used/needed (including null)

    Comment   : If cchstr < the return value, nothing will be written
                to lptstr.

***************************************************************************/
UINT FormatDate(LPSYSTEMTIME lpst, LPTSTR lptstr, UINT cchstr) {
    return((UINT)GetDateFormat(LOCALE_USER_DEFAULT,
      0, lpst, NULL, lptstr, cchstr));
}


/***************************************************************************

    Name      : BuildDate

    Purpose   : Put together a formated local date/time string from a MAPI
                style time/date value.

    Parameters: lptstr -> buffer to fill.
                cchstr = size of buffer (or zero if we want to know how
                  big we need)
                DateTime = MAPI date/time value

    Returns   : count of bytes in date/time string (including null)

    Comment   : All MAPI times and Win32 FILETIMEs are in Universal Time and
                need to be converted to local time before being placed in the
                local date/time string.

***************************************************************************/
UINT BuildDate(LPTSTR lptstr, UINT cchstr, FILETIME DateTime) {
    SYSTEMTIME st;
    FILETIME ftLocal;
    UINT cbRet = 0;

    if (! FileTimeToLocalFileTime((LPFILETIME)&DateTime, &ftLocal)) {
        DebugTrace("BuildDate: Invalid Date/Time\n");
        if (cchstr > (18 * sizeof(TCHAR))) {
            lstrcpy(lptstr, TEXT("Invalid Date/Time"));
        }
    } else {
        if (FileTimeToSystemTime(&ftLocal, &st)) {
            // Do the date first.
            cbRet = FormatDate(&st, lptstr, cchstr);
            // Do the time.  Start at the null after
            // the date, but remember that we've used part
            // of the buffer, so the buffer is shorter now.

            if (cchstr) {
                lstrcat(lptstr, "  ");   // seperate date and time
            }
            cbRet+=1;

            cbRet += FormatTime(&st, lptstr + cbRet,
              cchstr ? cchstr - cbRet : 0);
        } else {
            DebugTrace("BuildDate: Invalid Date/Time\n");
            if (cchstr > (18 * sizeof(TCHAR))) {
               lstrcpy(lptstr, TEXT("Invalid Date/Time"));
            }
        }
    }
    return(cbRet);
}


/*
 * DebugTime
 *
 * Debug output of UTC filetime or MAPI time.
 *
 * All MAPI times and Win32 FILETIMEs are in Universal Time.
 *
 */
void DebugTime(FILETIME Date, PUCHAR lpszFormat) {
    UCHAR lpszSubmitDate[MAX_TIME_DATE_STRING];

    BuildDate(lpszSubmitDate, sizeof(lpszSubmitDate), Date);

    DebugTrace(lpszFormat, lpszSubmitDate);
}

#define RETURN_PROP_CASE(pt) case PROP_ID(pt): return(#pt)

/***************************************************************************

    Name      : PropTagName

    Purpose   : Associate a name with a property tag

    Parameters: ulPropTag = property tag

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
PUCHAR PropTagName(ULONG ulPropTag) {
    static UCHAR szPropTag[35]; // see string on default

    switch (PROP_ID(ulPropTag)) {

        RETURN_PROP_CASE(PR_INITIALS);
        RETURN_PROP_CASE(PR_SURNAME);
        RETURN_PROP_CASE(PR_TITLE);
        RETURN_PROP_CASE(PR_TELEX_NUMBER);
        RETURN_PROP_CASE(PR_GIVEN_NAME);
        RETURN_PROP_CASE(PR_PRIMARY_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PRIMARY_FAX_NUMBER);
        RETURN_PROP_CASE(PR_POSTAL_CODE);
        RETURN_PROP_CASE(PR_POSTAL_ADDRESS);
        RETURN_PROP_CASE(PR_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_PAGER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_OTHER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ORGANIZATIONAL_ID_NUMBER);
        RETURN_PROP_CASE(PR_OFFICE_LOCATION);
        RETURN_PROP_CASE(PR_LOCATION);
        RETURN_PROP_CASE(PR_LOCALITY);
        RETURN_PROP_CASE(PR_ISDN_NUMBER);
        RETURN_PROP_CASE(PR_GOVERNMENT_ID_NUMBER);
        RETURN_PROP_CASE(PR_GENERATION);
        RETURN_PROP_CASE(PR_DEPARTMENT_NAME);
        RETURN_PROP_CASE(PR_COUNTRY);
        RETURN_PROP_CASE(PR_COMPANY_NAME);
        RETURN_PROP_CASE(PR_COMMENT);
        RETURN_PROP_CASE(PR_CELLULAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CALLBACK_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS2_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_FAX_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT);
        RETURN_PROP_CASE(PR_ACCOUNT);
        RETURN_PROP_CASE(PR_TEMPLATEID);
        RETURN_PROP_CASE(PR_DETAILS_TABLE);
        RETURN_PROP_CASE(PR_SEARCH_KEY);
        RETURN_PROP_CASE(PR_LAST_MODIFICATION_TIME);
        RETURN_PROP_CASE(PR_CREATION_TIME);
        RETURN_PROP_CASE(PR_ENTRYID);
        RETURN_PROP_CASE(PR_RECORD_KEY);
        RETURN_PROP_CASE(PR_MAPPING_SIGNATURE);
        RETURN_PROP_CASE(PR_OBJECT_TYPE);
        RETURN_PROP_CASE(PR_ROWID);
        RETURN_PROP_CASE(PR_ADDRTYPE);
        RETURN_PROP_CASE(PR_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_EMAIL_ADDRESS);
        RETURN_PROP_CASE(PR_DEPTH);
        RETURN_PROP_CASE(PR_ROW_TYPE);
        RETURN_PROP_CASE(PR_RADIO_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_HOME_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_INSTANCE_KEY);
        RETURN_PROP_CASE(PR_DISPLAY_TYPE);
        RETURN_PROP_CASE(PR_RECIPIENT_TYPE);
        RETURN_PROP_CASE(PR_CONTAINER_FLAGS);
        RETURN_PROP_CASE(PR_DEF_CREATE_DL);
        RETURN_PROP_CASE(PR_DEF_CREATE_MAILUSER);
        RETURN_PROP_CASE(PR_CONTACT_ADDRTYPES);
        RETURN_PROP_CASE(PR_CONTACT_DEFAULT_ADDRESS_INDEX);
        RETURN_PROP_CASE(PR_CONTACT_EMAIL_ADDRESSES);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_CITY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_COUNTRY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POSTAL_CODE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STREET);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_MIDDLE_NAME);
        RETURN_PROP_CASE(PR_NICKNAME);
        RETURN_PROP_CASE(PR_PERSONAL_HOME_PAGE);
        RETURN_PROP_CASE(PR_BUSINESS_HOME_PAGE);
        RETURN_PROP_CASE(PR_MHS_COMMON_NAME);
        RETURN_PROP_CASE(PR_SEND_RICH_INFO);
        RETURN_PROP_CASE(PR_TRANSMITABLE_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_STREET_ADDRESS);

        default:
            wsprintf(szPropTag, "Unknown property tag 0x%x",
              PROP_ID(ulPropTag));
            return(szPropTag);
    }
}


/***************************************************************************

    Name      : DebugPropTagArray

    Purpose   : Displays MAPI property tags from a counted array

    Parameters: lpPropArray -> property array
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugPropTagArray(LPSPropTagArray lpPropArray, PUCHAR pszObject) {
    DWORD i;
    PUCHAR lpType;

    if (lpPropArray == NULL) {
        DebugTrace("Empty %s property tag array.\n", pszObject ? pszObject : szNULL);
        return;
    }

    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s property tags:\n", lpPropArray->cValues,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < lpPropArray->cValues ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpPropArray->aulPropTag[i],
          lpPropArray->aulPropTag[i] >> 16,
          lpPropArray->aulPropTag[i] & 0xffff);
#endif
        switch (lpPropArray->aulPropTag[i] & 0xffff) {
            case PT_STRING8:
                lpType = "STRING8";
                break;
            case PT_LONG:
                lpType = "LONG";
                break;
            case PT_I2:
                lpType = "I2";
                break;
            case PT_ERROR:
                lpType = "ERROR";
                break;
            case PT_BOOLEAN:
                lpType = "BOOLEAN";
                break;
            case PT_R4:
                lpType = "R4";
                break;
            case PT_DOUBLE:
                lpType = "DOUBLE";
                break;
            case PT_CURRENCY:
                lpType = "CURRENCY";
                break;
            case PT_APPTIME:
                lpType = "APPTIME";
                break;
            case PT_SYSTIME:
                lpType = "SYSTIME";
                break;
            case PT_UNICODE:
                lpType = "UNICODE";
                break;
            case PT_CLSID:
                lpType = "CLSID";
                break;
            case PT_BINARY:
                lpType = "BINARY";
                break;
            case PT_I8:
                lpType = "PT_I8";
                break;
            case PT_MV_I2:
                lpType = "MV_I2";
                break;
            case PT_MV_LONG:
                lpType = "MV_LONG";
                break;
            case PT_MV_R4:
                lpType = "MV_R4";
                break;
            case PT_MV_DOUBLE:
                lpType = "MV_DOUBLE";
                break;
            case PT_MV_CURRENCY:
                lpType = "MV_CURRENCY";
                break;
            case PT_MV_APPTIME:
                lpType = "MV_APPTIME";
                break;
            case PT_MV_SYSTIME:
                lpType = "MV_SYSTIME";
                break;
            case PT_MV_BINARY:
                lpType = "MV_BINARY";
                break;
            case PT_MV_STRING8:
                lpType = "MV_STRING8";
                break;
            case PT_MV_UNICODE:
                lpType = "MV_UNICODE";
                break;
            case PT_MV_CLSID:
                lpType = "MV_CLSID";
                break;
            case PT_MV_I8:
                lpType = "MV_I8";
                break;
            case PT_NULL:
                lpType = "NULL";
                break;
            case PT_OBJECT:
                lpType = "OBJECT";
                break;
            default:
                DebugTrace("<Unknown Property Type>");
                break;
        }
        DebugTrace("%s\t%s\n", PropTagName(lpPropArray->aulPropTag[i]), lpType);
    }
}


/***************************************************************************

    Name      : DebugProperties

    Purpose   : Displays MAPI properties in a property list

    Parameters: lpProps -> property list
                cProps = count of properties
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
void _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject) {
    DWORD i, j;


    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s properties:\n", cProps,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < cProps ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpProps[i].ulPropTag,
          lpProps[i].ulPropTag >> 16,
          lpProps[i].ulPropTag & 0xffff);
#endif
        DebugTrace("%s\n", PropTagName(lpProps[i].ulPropTag));

        switch (lpProps[i].ulPropTag & 0xffff) {
            case PT_STRING8:
                if (lstrlen(lpProps[i].Value.lpszA) < 1024) {
                    DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.lpszA);
                } else {
                    DebugTrace("STRING8 Value is too long to display\n");
                }
                break;
            case PT_LONG:
                DebugTrace("LONG Value:%u\n", lpProps[i].Value.l);
                break;
            case PT_I2:
                DebugTrace("I2 Value:%u\n", lpProps[i].Value.i);
                break;
            case PT_ERROR:
                DebugTrace("ERROR Value: 0x%08x\n", lpProps[i].Value.err);
                break;
            case PT_BOOLEAN:
                DebugTrace("BOOLEAN Value:%s\n", lpProps[i].Value.b ?
                  "TRUE" : "FALSE");
                break;
            case PT_R4:
                DebugTrace("R4 Value\n");
                break;
            case PT_DOUBLE:
                DebugTrace("DOUBLE Value\n");
                break;
            case PT_CURRENCY:
                DebugTrace("CURRENCY Value\n");
                break;
            case PT_APPTIME:
                DebugTrace("APPTIME Value\n");
                break;
            case PT_SYSTIME:
                DebugTime(lpProps[i].Value.ft, "SYSTIME Value:%s\n");
                break;
            case PT_UNICODE:
                DebugTrace("UNICODE Value\n");
                break;
            case PT_CLSID:
                DebugTrace("CLSID Value\n");
                break;
            case PT_BINARY:
                DebugTrace("BINARY Value %u bytes:\n", lpProps[i].Value.bin.cb);
                DebugBinary(lpProps[i].Value.bin.cb, lpProps[i].Value.bin.lpb);
                break;
            case PT_I8:
                DebugTrace("LARGE_INTEGER Value\n");
                break;
            case PT_MV_I2:
                DebugTrace("MV_I2 Value\n");
                break;
            case PT_MV_LONG:
                DebugTrace("MV_LONG Value\n");
                break;
            case PT_MV_R4:
                DebugTrace("MV_R4 Value\n");
                break;
            case PT_MV_DOUBLE:
                DebugTrace("MV_DOUBLE Value\n");
                break;
            case PT_MV_CURRENCY:
                DebugTrace("MV_CURRENCY Value\n");
                break;
            case PT_MV_APPTIME:
                DebugTrace("MV_APPTIME Value\n");
                break;
            case PT_MV_SYSTIME:
                DebugTrace("MV_SYSTIME Value\n");
                break;
            case PT_MV_BINARY:
                DebugTrace("MV_BINARY with %u values\n", lpProps[i].Value.MVbin.cValues);
                for (j = 0; j < lpProps[i].Value.MVbin.cValues; j++) {
                    DebugTrace("BINARY Value %u: %u bytes\n", j, lpProps[i].Value.MVbin.lpbin[j].cb);
                    DebugBinary(lpProps[i].Value.MVbin.lpbin[j].cb, lpProps[i].Value.MVbin.lpbin[j].lpb);
                }
                break;
            case PT_MV_STRING8:
                DebugTrace("MV_STRING8 with %u values\n", lpProps[i].Value.MVszA.cValues);
                for (j = 0; j < lpProps[i].Value.MVszA.cValues; j++) {
                    if (lstrlen(lpProps[i].Value.MVszA.lppszA[j]) < 1024) {
                        DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.MVszA.lppszA[j]);
                    } else {
                        DebugTrace("STRING8 Value is too long to display\n");
                    }
                }
                break;
            case PT_MV_UNICODE:
                DebugTrace("MV_UNICODE Value\n");
                break;
            case PT_MV_CLSID:
                DebugTrace("MV_CLSID Value\n");
                break;
            case PT_MV_I8:
                DebugTrace("MV_I8 Value\n");
                break;
            case PT_NULL:
                DebugTrace("NULL Value\n");
                break;
            case PT_OBJECT:
                DebugTrace("OBJECT Value\n");
                break;
            default:
                DebugTrace("Unknown Property Type\n");
                break;
        }
    }
}


/***************************************************************************

    Name      : DebugADRLIST

    Purpose   : Displays structure of an ADRLIST including properties

    Parameters: lpAdrList -> ADRLSIT to show
                lpszTitle = string to identify this dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle) {
     ULONG i;
     TCHAR szTitle[250];

     for (i = 0; i < lpAdrList->cEntries; i++) {

         wsprintf(szTitle, "%s : Entry %u", lpszTitle, i);
         _DebugProperties(lpAdrList->aEntries[i].rgPropVals,
           lpAdrList->aEntries[i].cValues, szTitle);
     }
}


/***************************************************************************

    Name      : DebugObjectProps

    Purpose   : Displays MAPI properties of an object

    Parameters: lpObject -> object to dump
                Label = string to identify this prop dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugObjectProps(LPMAPIPROP lpObject, LPTSTR Label) {
    DWORD cProps = 0;
    LPSPropValue lpProps = NULL;
    HRESULT hr = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;


    hr = lpObject->lpVtbl->GetProps(lpObject, NULL, 0, &cProps, &lpProps);
    switch (sc = GetScode(hr)) {
        case SUCCESS_SUCCESS:
            break;

        case MAPI_W_ERRORS_RETURNED:
            DebugTrace("GetProps -> Errors Returned\n");
            break;

        default:
            DebugTrace("GetProps -> Error 0x%x\n", sc);
            return;
    }

    _DebugProperties(lpProps, cProps, Label);

    FreeBufferAndNull(&lpProps);
}


/*
 *	Destroys an SRowSet structure.
 */
STDAPI_(void)
FreeProws(LPSRowSet prows)
{
	ULONG		irow;

	if (!prows)
		return;

	for (irow = 0; irow < prows->cRows; ++irow)
		WABFreeBuffer(prows->aRow[irow].lpProps);
	WABFreeBuffer(prows);
}


/***************************************************************************

    Name      : DebugMapiTable

    Purpose   : Displays structure of a MAPITABLE including properties

    Parameters: lpTable -> MAPITABLE to display

    Returns   : none

    Comment   : Don't sort the columns or rows here.  This routine should
                not produce side effects in the table.

***************************************************************************/
void _DebugMapiTable(LPMAPITABLE lpTable) {
    UCHAR szTemp[30];   // plenty for "ROW %u"
    ULONG ulCount;
    WORD wIndex;
    LPSRowSet lpsRow = NULL;
    ULONG ulCurrentRow = (ULONG)-1;
    ULONG ulNum, ulDen, lRowsSeeked;

    DebugTrace("=======================================\n");
    DebugTrace("+  Dump of MAPITABLE at 0x%x:\n", lpTable);
    DebugTrace("---------------------------------------\n");

    // How big is the table?
    lpTable->lpVtbl->GetRowCount(lpTable, 0, &ulCount);
    DebugTrace("Table contains %u rows\n", ulCount);

    // Save the current position in the table
    lpTable->lpVtbl->QueryPosition(lpTable, &ulCurrentRow, &ulNum, &ulDen);

    // Display the properties for each row in the table
    for (wIndex = 0; wIndex < ulCount; wIndex++) {
        // Get the next row
        lpTable->lpVtbl->QueryRows(lpTable, 1, 0, &lpsRow);

        if (lpsRow) {
//            Assert(lpsRow->cRows == 1); // should have exactly one row

            wsprintf(szTemp, "ROW %u", wIndex);

            DebugProperties(lpsRow->aRow[0].lpProps,
              lpsRow->aRow[0].cValues, szTemp);

            FreeProws(lpsRow);
        }
    }

    // Restore the current position for the table
    if (ulCurrentRow != (ULONG)-1) {
        lpTable->lpVtbl->SeekRow(lpTable, BOOKMARK_BEGINNING, ulCurrentRow,
          &lRowsSeeked);
    }
}


/*
 * DebugTrace -- printf to the debugger console or debug output file
 * Takes printf style arguments.
 * Expects newline characters at the end of the string.
 */
VOID FAR CDECL DebugTrace(LPSTR lpszFmt, ...) {
    va_list marker;
    TCHAR String[1100];


    va_start(marker, lpszFmt);
    wvsprintf(String, lpszFmt, marker);
        OutputDebugString(String);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\apitest\dbgutil.h ===
/***********************************************************************
 *
 * DBGUTIL.H
 *
 * Debug Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/
#ifdef __cplusplus
extern "C" {
#endif


VOID _DebugObjectProps(LPMAPIPROP lpObject, LPTSTR Label);
VOID _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject);
void _DebugMapiTable(LPMAPITABLE lpTable);
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle);

#define DebugObjectProps(lpObject, Label) _DebugObjectProps(lpObject, Label)
#define DebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define DebugMapiTable(lpTable) _DebugMapiTable(lpTable)
#define DebugADRLIST(lpAdrList, lpszTitle) _DebugADRLIST(lpAdrList, lpszTitle)

VOID FAR CDECL DebugTrace(LPSTR lpszFmt, ...);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\apitest\instring.h ===
#define IDD_INPUT_STRING 2001
#define IDD_INPUT_STRING_PROMPT 2002

ULONG InputString(HINSTANCE hInstance, HWND hwnd, const LPTSTR lpszTitle,
  const LPTSTR lpszPrompt, LPTSTR lpBuffer, ULONG cchBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\apitest\mapi.c ===
/*
 * MAPI.C
 *
 * Layer on top of MAPI calls
 *
 * Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * History:
 *      11/14/96    BruceK  First version to allow wab migration without mapi32.dll
 */

#include <windows.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include "apitest.h"
#include "instring.h"
#include "dbgutil.h"



LPMAPIINITIALIZE lpfnMAPIInitialize = NULL;
LPMAPILOGONEX lpfnMAPILogonEx = NULL;
LPMAPIALLOCATEBUFFER lpfnMAPIAllocateBuffer = NULL;
LPMAPIALLOCATEMORE lpfnMAPIAllocateMore = NULL;
LPMAPIFREEBUFFER lpfnMAPIFreeBuffer = NULL;

static HINSTANCE hinstMAPIDll = NULL;

// Constant strings
const TCHAR szMapiDll[] = TEXT("MAPI32.DLL");
const TCHAR szMAPIAllocateBuffer[] = TEXT("MAPIAllocateBuffer");
const TCHAR szMAPIAllocateMore[] = TEXT("MAPIAllocateMore");
const TCHAR szMAPIFreeBuffer[] = TEXT("MAPIFreeBuffer");
const TCHAR szMAPIInitialize[] = TEXT("MAPIInitialize");
const TCHAR szMAPILogonEx[] = TEXT("MAPILogonEx");


HRESULT MAPIInitialize(LPVOID lpMapiInit) {
    HRESULT hResult = hrSuccess;

    // If MAPI DLL is not loaded, do so now.
    if (! hinstMAPIDll) {

        if (! (hinstMAPIDll = LoadLibrary(szMapiDll))) {
            DWORD dwErr = GetLastError();
            DebugTrace("Couldn't load MAPI dll [%s] -> %u\n", szMapiDll, dwErr);
            switch (dwErr) {
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_OUTOFMEMORY:
                    hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                    break;

                case ERROR_HANDLE_DISK_FULL:
                case ERROR_DISK_FULL:
                    hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_DISK);
                    break;

                default:
                case ERROR_FILE_NOT_FOUND:
                case ERROR_PATH_NOT_FOUND:
                    hResult = ResultFromScode(MAPI_E_NOT_FOUND);
                    break;
            }
            goto exit;
        } else {
            // Get the function pointers
            if (! (lpfnMAPIInitialize = (LPMAPIINITIALIZE)GetProcAddress(hinstMAPIDll,
              szMAPIInitialize))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIInitialize, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPILogonEx = (LPMAPILOGONEX)GetProcAddress(hinstMAPIDll,
              szMAPILogonEx))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPILogonEx, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPIAllocateBuffer = (LPMAPIALLOCATEBUFFER)GetProcAddress(hinstMAPIDll,
              szMAPIAllocateBuffer))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIAllocateBuffer, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPIAllocateMore= (LPMAPIALLOCATEMORE)GetProcAddress(hinstMAPIDll,
              szMAPIAllocateMore))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIAllocateMore, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPIFreeBuffer = (LPMAPIFREEBUFFER)GetProcAddress(hinstMAPIDll,
              szMAPIFreeBuffer))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIFreeBuffer, szMapiDll, GetLastError());
                goto exit;
            }
        }
    }

exit:
    if (! lpfnMAPIInitialize ||
      ! lpfnMAPILogonEx ||
      ! lpfnMAPIAllocateMore ||
      ! lpfnMAPIAllocateBuffer ||
      ! lpfnMAPIFreeBuffer) {
        // Bad news.  Clean up and fail.
        if (hinstMAPIDll) {
            // unload the dll
            FreeLibrary(hinstMAPIDll);
            hinstMAPIDll = NULL;
            lpfnMAPIInitialize = NULL;
            lpfnMAPILogonEx = NULL;
            lpfnMAPIAllocateMore = NULL;
            lpfnMAPIAllocateBuffer = NULL;
            lpfnMAPIFreeBuffer = NULL;
        }
        if (hResult == hrSuccess) {
            hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        }

        return(hResult);
    }

    return(lpfnMAPIInitialize(lpMapiInit));
}


HRESULT MAPILogonEx(
  ULONG ulUIParam,
  LPTSTR lpszProfileName,
  LPTSTR lpszPassword,
  ULONG ulFlags,
  LPMAPISESSION FAR * lppSession
) {
    if (lpfnMAPILogonEx) {
        return(lpfnMAPILogonEx(ulUIParam,
          lpszProfileName,
          lpszPassword,
          ulFlags,
          lppSession));
    } else {
        return(ResultFromScode(MAPI_E_NOT_INITIALIZED));
    }
}

SCODE MAPIAllocateBuffer(
  ULONG cbSize,
  LPVOID FAR * lppBuffer
) {
    if (lpfnMAPIAllocateBuffer) {
        return(lpfnMAPIAllocateBuffer(cbSize,
          lppBuffer));
    } else {
        return(MAPI_E_NOT_INITIALIZED);
    }
}

SCODE MAPIAllocateMore(
  ULONG cbSize,
  LPVOID lpObject,
  LPVOID FAR * lppBuffer
) {
    if (lpfnMAPIAllocateMore) {
        return(lpfnMAPIAllocateMore(cbSize,
          lpObject,
          lppBuffer));
    } else {
        return(MAPI_E_NOT_INITIALIZED);
    }
}

ULONG MAPIFreeBuffer(LPVOID lpBuffer) {
    if (lpfnMAPIFreeBuffer) {
        return(lpfnMAPIFreeBuffer(lpBuffer));
    } else {
        return((ULONG)MAPI_E_NOT_INITIALIZED);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\apitest\wabguid.c ===
// This builds wabguid.obj, which can be linked into a DLL
// or EXE to provide the MAPI GUIDs. It contains all GUIDs
// defined by WAB.


#define USES_IID_IUnknown
#define USES_IID_IMAPIUnknown
#define USES_IID_IMAPITable
#define USES_IID_INotifObj
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPIStatus
#define USES_IID_IAddrBook
#define USES_IID_IMailUser
#define USES_IID_IMAPIContainer
#define USES_IID_IABContainer
#define USES_IID_IDistList
#define USES_IID_IMAPITableData
#define USES_IID_IMAPIAdviseSink


#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif


#define INITGUID
#include <windows.h>
#include <wab.h>
#include <wabguid.h>
#include "_layguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\luieng.dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Luieng.rc
//
#define ID_OK                           1
#define ID_CANCEL                       2
#define IDD_LOGGING                     101
#define IDD_LOG                         101
#define IDC_LOG                         1000
#define IDC_LOGGING                     1000
#define IDC_EDIT1                       1001
#define IDC_LOGNAME                     1001
#define IDC_LOGLEVEL                    1002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\luieng.dll\luieng.h ===
//LUIENG.DLL
//Created by Chad Mumford
//2/5/96


#include <windows.h>

//********************************************************************************
//**	Declarations
//********************************************************************************

#define MODULEAPI __declspec(dllexport)
#define INAPI __declspec(dllimport)

#ifndef LUIENG
#define LUIENG

enum LOGLEVEL{LHEADING,L1,L2,L3,L4,LPASS1,LPASS2,LPASS3,LPASS4,
			LFAIL1,LFAIL2,LFAIL3,LFAIL4,LPASS,LFAIL};

enum SUMLEVEL{SL1,SL2,SL3,SL4,SLALL}; //LALL only works with 
								//LUISummaryOut & LUIClearSummary

enum MENUTYPE{NORMAL,LINE,STARTSUBMENU,ENDSUBMENU,ENDMENU};


/*e.g.

Tests
  itm1			-NORMAL
  ----			-LINE
  itm2			-NORMAL	
  submenu1		-STARTSUBMENU
    itm1		-NORMAL
	itm2		-NORMAL
	itm3		-NORMAL
	itm4		-NORMAL
	submenu2	-STARTSUBMENU
		itm1	-NORMAL
				-ENDSUBMENU
				-ENDSUBMENU
  itm3			-NORMAL
				-ENDMENU
*/

struct MenuStruct
{
	char lpszItemName[20];
	UINT nItemID;
	MENUTYPE nType;
};


#define IDM_FILEOPEN	1
#define IDM_FILECLOSE	2
#define IDM_FILESAVE	3
#define IDM_FILEPRINT	4
#define IDM_CLOSE		5
#define IDM_RUN			6
#define IDM_STOP		7
#define IDM_PAUSE		8
#define IDM_EDIT_COPY	9
#define IDM_EDIT_CLEAR	10  //implemented by dll
#define IDM_EDIT_SETTINGS 12
#define IDM_FILEEXIT	11  //implemented by dll
#define IDM_ABOUT		13 
#define IDM_CONTENTS	14

// exported functions
extern "C"{
typedef INAPI BOOL (*LUIINIT)(HWND,MenuStruct *, MenuStruct *, BOOL);
typedef INAPI BOOL (*LUIMSGHANDLER)(UINT message, UINT wParam, LONG lParam);
typedef INAPI void (*LUIOUT)(LOGLEVEL Level, LPSTR lpszString,...);
typedef INAPI void (*LUISETSUMMARY)(SUMLEVEL level, UINT nPassed, UINT nFailed);
typedef INAPI void (*LUIGETSUMMARY)(SUMLEVEL level, UINT *nPassed, UINT *nFailed);
typedef INAPI void (*LUICLEARSUMMARY)(SUMLEVEL level);
typedef INAPI void (*LUISUMMARYOUT)(SUMLEVEL level);
}

#endif
//*******************************************************
//*	Function Descriptions
//********************************************************************************



//exported functions
//********************************************************************************

// LUICLASS * LUIInit(HWND hwnd,TestStruct *Tests, TestSettingsStruct *TestSettings, BOOL bLOR = FALSE);
//
// Parameters:
// hwnd:		Handle of parent window
// Tests:		Array of TestStructs.  Creates menu options 
//				under the Test Menu.
//				nItemID == 0 - a line
//				nItemID Range = 2000-2500
//				This structure must be in order
//
// TestSettings:Array of TestSettingsStructs.  Creates menu option 
//				under the Settings Menu
//				nItemID Range = 2500-3000
//				nItemID == 0 - a line
//
// bLOR:		TRUE - use LOR logging
//
// Purpose:		Takes a default window and creates a 
//				standardized test menu, logging
//				area and supported logging functions
//					
// Notes:		All options in the Test and Test Settings					
//				menus must be implemented by the calling
//				.exe
//
//********************************************************************************

//********************************************************************************
// BOOL LUICLASS::LUIOut(LOGLEVEL Level, LPSTR lpszString, ...);
//
// Parameters:
// Level:		Specifies format of string
// lpszString:	String to display
//
// Purpose:		Adds a string to the bottom of the log
//
//********************************************************************************

//********************************************************************************
// void LUICLASS::LUIMsgHandler(UINT message, UINT wParam, LONG lParam);
//
// Purpose:		Handles messages meant for log engine.  Should be first function
//				called by WndProc
//
// Other Messages Prehandled:
//							WM_SIZE
//							WM_CLOSE
//********************************************************************************




//internal functions accessible by default menu

// File
//********************************************************************************
// BOOL SaveLog(void);
//
// Parameters:
// Purpose:	
//
//********************************************************************************

//********************************************************************************
// BOOL OpenLog(void);
//
// Parameters:
// Purpose:	
//
//********************************************************************************

//********************************************************************************
// BOOL Exit(void);
//
// Parameters:
// Purpose:	
//
//********************************************************************************

//********************************************************************************
// BOOL PrintLog(void);//not imp
//
// Parameters:
// Purpose:	
//
//********************************************************************************


// Edit
//********************************************************************************
// BOOL Copy(void);//not imp
//
// Parameters:
// Purpose:	
//
//********************************************************************************

//********************************************************************************
// BOOL Clear(void);
//
// Parameters:
// Purpose:	
//
//********************************************************************************

//********************************************************************************
// BOOL Settings(void);
//
// Parameters:
// Purpose:	
//
//********************************************************************************



//Internal only functions

//********************************************************************************
// BOOL MakeMenu(void);
//
// Parameters:
// Purpose:	
//
//********************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\mfcext\mfcext.h ===
// mfcext.h : main header file for the MFCEXT DLL
//

#if !defined(AFX_MFCEXT_H__BA583A69_879D_11D1_9ACF_00A0C91F9C8B__INCLUDED_)
#define AFX_MFCEXT_H__BA583A69_879D_11D1_9ACF_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include <ole2.h>
#include <shlobj.h>
#include <prsht.h>
#include <winuser.h>
#include "propid.h"
#include "resource.h"		// main symbols
#include <initguid.h>
#include <wab.h>



/////////////////////////////////////////////////////////////////////////////
// CMfcextApp
// See mfcext.cpp for the implementation of this class
//

class CMfcextApp : public CWinApp
{
public:
	CMfcextApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcextApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CMfcextApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CMfcExt command target

class CMfcExt : public CCmdTarget
{
	DECLARE_DYNCREATE(CMfcExt)
protected:
	CMfcExt();           // protected constructor used by dynamic creation

// Attributes
public:
    UINT m_cRefThisDll;     // Reference count for this DLL
    HPROPSHEETPAGE m_hPage1; // Handle to the property sheet page
    HPROPSHEETPAGE m_hPage2; // Handle to the property sheet page

    LPWABEXTDISPLAY m_lpWED;

    LPWABEXTDISPLAY m_lpWEDContext;
    LPMAPIPROP m_lpPropObj; // For context menu extensions, hang onto the prop obj

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropExt)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CMfcExt();

	// Generated message map functions
	//{{AFX_MSG(CMfcExt)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE(CMfcExt)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CMfcExt)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

    // Declare the interface map for this object
    DECLARE_INTERFACE_MAP()

    // IShellPropSheetExt interface
    BEGIN_INTERFACE_PART(MfcExt, IShellPropSheetExt)
        STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
        STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);
    END_INTERFACE_PART(MfcExt)

    // IWABExtInit interface
    BEGIN_INTERFACE_PART(WABInit, IWABExtInit)
        STDMETHOD(Initialize)(LPWABEXTDISPLAY lpWED);
    END_INTERFACE_PART(WABInit)

    BEGIN_INTERFACE_PART(ContextMenuExt, IContextMenu)
        STDMETHOD(GetCommandString)(UINT idCmd,UINT uFlags,UINT *pwReserved,LPSTR pszName,UINT cchMax);
        STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
        STDMETHOD(QueryContextMenu)(HMENU hmenu,UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);    
    END_INTERFACE_PART(ContextMenuExt)

    static BOOL APIENTRY MfcExtDlgProc( HWND hDlg, UINT message, UINT wParam, LONG lParam);
    static BOOL APIENTRY MfcExtDlgProc2( HWND hDlg, UINT message, UINT wParam, LONG lParam);

};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CDlgContext dialog

class CDlgContext : public CDialog
{
// Construction
public:
	CDlgContext(CWnd* pParent = NULL);   // standard constructor
    LPADRLIST m_lpAdrList;

// Dialog Data
	//{{AFX_DATA(CDlgContext)
	enum { IDD = IDD_CONTEXT };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgContext)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgContext)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCEXT_H__BA583A69_879D_11D1_9ACF_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\mfcext\mfcext.cpp ===
// mfcext.cpp : Defines the initialization routines for the DLL.
//
#include "stdafx.h"
#include "mfcext.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//

/////////////////////////////////////////////////////////////////////////////
// CMfcextApp

BEGIN_MESSAGE_MAP(CMfcextApp, CWinApp)
	//{{AFX_MSG_MAP(CMfcextApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcextApp construction

CMfcextApp::CMfcextApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMfcextApp object

CMfcextApp theApp;



/////////////////////////////////////////////////////////////////////////////
// CPropextApp initialization

BOOL CMfcextApp::InitInstance()
{
	// Register all OLE server (factories) as running.  This enables the
	//  OLE libraries to create objects from other applications.
	COleObjectFactory::RegisterAll();
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Special entry points required for inproc servers

#if (_MFC_VER >= 0x300)
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return AfxDllGetClassObject(rclsid, riid, ppv);
}

STDAPI DllCanUnloadNow(void)
{
	return AfxDllCanUnloadNow();
}
#endif

// by exporting DllRegisterServer, you can use regsvr.exe
STDAPI DllRegisterServer(void)
{
	COleObjectFactory::UpdateRegistryAll();
    HKEY hSubKey = NULL;
    DWORD dwDisp = 0;
    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\WAB\\WAB4\\ExtDisplay\\MailUser",
                    0, NULL, 0, KEY_ALL_ACCESS, NULL, &hSubKey, &dwDisp))
    {
        UCHAR szEmpty[] = "";
        RegSetValueEx(hSubKey,"{BA9EE970-87A0-11D1-9ACF-00A0C91F9C8B}",0,REG_SZ, szEmpty, sizeof(szEmpty));
        RegCloseKey(hSubKey);
    }
    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\WAB\\WAB4\\ExtDisplay\\DistList",
                    0, NULL, 0, KEY_ALL_ACCESS, NULL, &hSubKey, &dwDisp))
    {
        UCHAR szEmpty[] = "";
        RegSetValueEx(hSubKey,"{BA9EE970-87A0-11D1-9ACF-00A0C91F9C8B}",0,REG_SZ, szEmpty, sizeof(szEmpty));
        RegCloseKey(hSubKey);
    }
    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\WAB\\WAB4\\ExtContext",
                    0, NULL, 0, KEY_ALL_ACCESS, NULL, &hSubKey, &dwDisp))
    {
        UCHAR szEmpty[] = "";
        RegSetValueEx(hSubKey,"{BA9EE970-87A0-11D1-9ACF-00A0C91F9C8B}",0,REG_SZ, szEmpty, sizeof(szEmpty));
        RegCloseKey(hSubKey);
    }
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPropExt

IMPLEMENT_DYNCREATE(CMfcExt, CCmdTarget)

CMfcExt::CMfcExt()
{
	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
    m_lpWED = NULL;
    m_lpWEDContext = NULL;
    m_lpPropObj = NULL;

    AfxOleLockApp();
}

CMfcExt::~CMfcExt()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}

void CMfcExt::OnFinalRelease()
{
	// When the last reference for an automation object is released
	//	OnFinalRelease is called.  This implementation deletes the 
	//	object.  Add additional cleanup required for your object before
	//	deleting it from memory.
    if(m_lpPropObj)
    {
        m_lpPropObj->Release();
        m_lpPropObj = NULL;
    }

	delete this;
}


BEGIN_MESSAGE_MAP(CMfcExt, CCmdTarget)
	//{{AFX_MSG_MAP(CPropExt)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CMfcExt, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CPropExt)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// {BA9EE970-87A0-11d1-9ACF-00A0C91F9C8B}
IMPLEMENT_OLECREATE(CMfcExt, "WABSamplePropExtSheet", 0xba9ee970, 0x87a0, 0x11d1, 0x9a, 0xcf, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b);

BEGIN_INTERFACE_MAP(CMfcExt, CCmdTarget)
    INTERFACE_PART(CMfcExt, IID_IShellPropSheetExt, MfcExt)
    INTERFACE_PART(CMfcExt, IID_IWABExtInit, WABInit)
    INTERFACE_PART(CMfcExt, IID_IContextMenu, ContextMenuExt)
END_INTERFACE_MAP()


// IUnknown for IShellPropSheet
STDMETHODIMP CMfcExt::XMfcExt::QueryInterface(REFIID riid, void** ppv)
{
    METHOD_PROLOGUE(CMfcExt, MfcExt);
    TRACE("CMfcExt::XMfcExt::QueryInterface\n");
    return pThis->ExternalQueryInterface(&riid, ppv);
}

STDMETHODIMP_(ULONG) CMfcExt::XMfcExt::AddRef(void)
{
    METHOD_PROLOGUE(CMfcExt, MfcExt);
    return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CMfcExt::XMfcExt::Release(void)
{
    METHOD_PROLOGUE(CMfcExt, MfcExt);
    return pThis->ExternalRelease();
}


STDMETHODIMP CMfcExt::XMfcExt::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    return E_NOTIMPL;
}


// IUnknown for IShellExtInit
STDMETHODIMP CMfcExt::XWABInit::QueryInterface(REFIID riid, void** ppv)
{
    METHOD_PROLOGUE(CMfcExt, WABInit);
    TRACE("CMfcExt::XWABInit::QueryInterface\n");
    return pThis->ExternalQueryInterface(&riid, ppv);
}

STDMETHODIMP_(ULONG) CMfcExt::XWABInit::AddRef(void)
{
    METHOD_PROLOGUE(CMfcExt, WABInit);
    return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CMfcExt::XWABInit::Release(void)
{
    METHOD_PROLOGUE(CMfcExt, WABInit);
    return pThis->ExternalRelease();
}

STDMETHODIMP CMfcExt::XWABInit::Initialize(LPWABEXTDISPLAY lpWABExtDisplay)
{
    METHOD_PROLOGUE(CMfcExt, WABInit);
    TRACE("CMfcExt::XWABInit::Intialize\n");

    if (lpWABExtDisplay == NULL)
    {
	    TRACE("CMfcExt::XWABInit::Initialize() no data object");
	    return E_FAIL;
    }

    // However if this is a context menu extension, we need to hang
    // onto the propobj till such time as InvokeCommand is called ..
    // At this point just AddRef the propobj - this will ensure that the
    // data in the lpAdrList remains valid till we release the propobj..
    // When we get another ContextMenu initiation, we can release the
    // older cached propobj - if we dont get another initiation, we 
    // release the cached object at shutdown time
    if(lpWABExtDisplay->ulFlags & WAB_CONTEXT_ADRLIST) // this means a IContextMenu operation is occuring
    {
        if(pThis->m_lpPropObj)
        {
            pThis->m_lpPropObj->Release();
            pThis->m_lpPropObj = NULL;
        }

        pThis->m_lpPropObj = lpWABExtDisplay->lpPropObj;
        pThis->m_lpPropObj->AddRef();

        pThis->m_lpWEDContext = lpWABExtDisplay;
    }
    else
    {
        // For property sheet extensions, the lpWABExtDisplay will
        // exist for the life of the property sheets ..
        pThis->m_lpWED = lpWABExtDisplay;
    }

    return S_OK;
}




// Globally cached hInstance for the DLL
HINSTANCE hinstApp = NULL;

// For the purposes of this sample, we will use 2 named properties,
// HomeTown and SportsTeam

// This demo's private GUID:
// {2B6D7EE0-36AB-11d1-9ABC-00A0C91F9C8B}
static const GUID WAB_ExtDemoGuid = 
{ 0x2b6d7ee0, 0x36ab, 0x11d1, { 0x9a, 0xbc, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b } };

static const LPTSTR lpMyPropNames[] = 
{   
    "MyHomeTown", 
    "MySportsTeam"
};

enum _MyTags
{
    myHomeTown = 0,
    mySportsTeam,
    myMax
};

ULONG MyPropTags[myMax];
ULONG PR_MY_HOMETOWN;
ULONG PR_MY_SPORTSTEAM;

// 
// Function prototypes:
//
HRESULT InitNamedProps(LPWABEXTDISPLAY lpWED);
BOOL CALLBACK fnDetailsPropDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void InitializeUI(HWND hDlg, LPWABEXTDISPLAY lpWED);
void SetDataInUI(HWND hDlg, LPWABEXTDISPLAY lpWED);
BOOL GetDataFromUI(HWND hDlg, LPWABEXTDISPLAY lpWED);
UINT CALLBACK fnCallback( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
void UpdateDisplayNameInfo(HWND hDlg, LPWABEXTDISPLAY lpWED);
BOOL bUpdatePropSheetData(HWND hDlg, LPWABEXTDISPLAY lpWED);



/*//$$****************************************************************
//
// InitNamedProps
//
// Gets the PropTags for the Named Props this app is interested in
//
//********************************************************************/
HRESULT InitNamedProps(LPWABEXTDISPLAY lpWED)
{
    ULONG i;
    HRESULT hr = E_FAIL;
    LPSPropTagArray lptaMyProps = NULL;
    LPMAPINAMEID * lppMyPropNames;
    SCODE sc;
    LPMAILUSER lpMailUser = NULL;
    WCHAR szBuf[myMax][MAX_PATH];

    if(!lpWED)
        goto err;

    lpMailUser = (LPMAILUSER) lpWED->lpPropObj;

    if(!lpMailUser)
        goto err;

    sc = lpWED->lpWABObject->AllocateBuffer(sizeof(LPMAPINAMEID) * myMax, 
                                            (LPVOID *) &lppMyPropNames);
    if(sc)
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    for(i=0;i<myMax;i++)
    {
        sc = lpWED->lpWABObject->AllocateMore(sizeof(MAPINAMEID), 
                                                lppMyPropNames, 
                                                (LPVOID *)&(lppMyPropNames[i]));
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto err;
        }
        lppMyPropNames[i]->lpguid = (LPGUID) &WAB_ExtDemoGuid;
        lppMyPropNames[i]->ulKind = MNID_STRING;

        *(szBuf[i]) = '\0';

        // Convert prop name to wide-char
        if ( !MultiByteToWideChar( GetACP(), 0, lpMyPropNames[i], -1, szBuf[i], sizeof(szBuf[i])) )
        {
            continue;
        }

        lppMyPropNames[i]->Kind.lpwstrName = (LPWSTR) szBuf[i];
    }

    hr = lpMailUser->GetIDsFromNames(   myMax, 
                                        lppMyPropNames,
                                        MAPI_CREATE, 
                                        &lptaMyProps);
    if(HR_FAILED(hr))
        goto err;

    if(lptaMyProps)
    {
        // Set the property types on the returned props
        MyPropTags[myHomeTown] = PR_MY_HOMETOWN = CHANGE_PROP_TYPE(lptaMyProps->aulPropTag[myHomeTown],    PT_TSTRING);
        MyPropTags[mySportsTeam] = PR_MY_SPORTSTEAM = CHANGE_PROP_TYPE(lptaMyProps->aulPropTag[mySportsTeam],    PT_TSTRING);
    }

err:
    if(lptaMyProps)
        lpWED->lpWABObject->FreeBuffer( lptaMyProps);

    if(lppMyPropNames)
        lpWED->lpWABObject->FreeBuffer( lppMyPropNames);

    return hr;

}


/*//$$****************************************************************
//
// fnDetailsPropDlgProc
//
// The dialog procedure that will handle all the windows messages for 
// the extended property page. 
//
//********************************************************************/
BOOL APIENTRY CMfcExt::MfcExtDlgProc( HWND hDlg, UINT message, UINT wParam,	LONG lParam)
{

    LPWABEXTDISPLAY lpWED = (LPWABEXTDISPLAY) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        //
        // The lParam on InitDialog contains the application data
        // Cache this on the dialog so we can retrieve it later.
        //
        {
            PROPSHEETPAGE * pps = (PROPSHEETPAGE *) lParam;
            LPWABEXTDISPLAY * lppWED = (LPWABEXTDISPLAY *) pps->lParam;
            if(lppWED)
            {
                SetWindowLong(hDlg,DWL_USER,(LPARAM)*lppWED);
                lpWED = *lppWED;
            }
        }
        
        // Initialize the named props for this prop sheet
        InitNamedProps(lpWED);

        // Initialize the UI appropriately
        InitializeUI(hDlg, lpWED);
        // Fill the UI with appropriate data
        SetDataInUI(hDlg, lpWED);
        return TRUE;
        break;


    case WM_COMMAND:
        switch(HIWORD(wParam)) //check the notification code
        {
            // If data changes, we should signal back to the WAB that
            // the data changed. If this flag is not set, the WAB will not
            // write the new data back to the store!!!
        case EN_CHANGE: //one of the edit boxes changed - dont care which
            lpWED->fDataChanged = TRUE;
            break;
        }
        break;
    

    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //Page being activated
            // Get the latest display name info and update the 
            // corresponding control
            UpdateDisplayNameInfo(hDlg, lpWED);
            break;


        case PSN_KILLACTIVE:    //Losing activation to another page or OK
            //
            // Take all the data from this prop sheet and convert it to a 
            // SPropValue array and place the data in an appropriate place.
            // The advantage of doing this in the KillActive notification is
            // that other property sheets can scan these property arrays and
            // if deisred, update data on other prop sheets based on this data
            //
            bUpdatePropSheetData(hDlg, lpWED);
            break;


        case PSN_RESET:         //cancel
            break;


        case PSN_APPLY:         //ok pressed
            if (!(lpWED->fReadOnly))
            {
                //
                // Check for any required properties here
                // If some required property is not filled in, you can prevent
                // the property sheet from closing
                //
                /*
                if (RequiredDataNotFilledIn())
                {
                    // abort this OK ... ie dont let them close
                    SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);
                }
                */
            }
            break;
        }
        break;
    }

    return 0;
}

BOOL APIENTRY CMfcExt::MfcExtDlgProc2( HWND hDlg, UINT message, UINT wParam,	LONG lParam)
{

	switch (message)
	{
		case WM_NOTIFY:
    		switch (((NMHDR FAR *) lParam)->code) 
    		{

				case PSN_APPLY:
 	           		SetWindowLong(hDlg,	DWL_MSGRESULT, TRUE);
					break;

				case PSN_KILLACTIVE:
	           		SetWindowLong(hDlg,	DWL_MSGRESULT, FALSE);
					return 1;
					break;

				case PSN_RESET:
	           		SetWindowLong(hDlg,	DWL_MSGRESULT, FALSE);
					break;
    	}
	}
	return FALSE;   
}


int EditControls[] = 
{
    IDC_EXT_EDIT_HOME,
    IDC_EXT_EDIT_TEAM
};

/*//$$****************************************************************
//
// InitializeUI
//
// Rearranges/Sets UI based on input params
//
//********************************************************************/
void InitializeUI(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    // The WAB property sheets can be readonly when opening LDAP entries,
    // or vCards or other things. If the READONLY flag is set, set this
    // prop sheets controls to readonly
    //
    int i;
    if(!lpWED)
        return;
    for(i=0;i<myMax;i++)
    {
        SendDlgItemMessage( hDlg, EditControls[i], EM_SETREADONLY, 
                            (WPARAM) lpWED->fReadOnly, 0);
        SendDlgItemMessage( hDlg, EditControls[i], EM_SETLIMITTEXT, 
                            (WPARAM) MAX_PATH-1, 0);
    }
    return;
}


/*//$$****************************************************************
//
// SetDataInUI
//
// Fills in the controls with data passed in by the WAB
//
//********************************************************************/
void SetDataInUI(HWND hDlg, LPWABEXTDISPLAY lpWED)
{

    // Search for our private named properties and set them in the UI
    //
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    ULONG i = 0, j =0;

    if(!lpWED)
        return;

    // Get all the props from this object - one can also selectively
    // ask for specific props by passing in an SPropTagArray
    //
    if(!HR_FAILED(lpWED->lpPropObj->GetProps(NULL, 0, 
                                            &ulcPropCount, 
                                            &lpPropArray)))
    {
        if(ulcPropCount && lpPropArray)
        {
            for(i=0;i<ulcPropCount;i++)
            {
                for(j=0;j<myMax;j++)
                {
                    if(lpPropArray[i].ulPropTag == MyPropTags[j])
                    {
                        SetWindowText(  GetDlgItem(hDlg, EditControls[j]),
                                        lpPropArray[i].Value.LPSZ);
                        break;
                    }
                }
            }
        }
    }
    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);
                                    
    return;
}

/*//$$****************************************************************
//
// GetDataFromUI
//
// Retrieves data from the UI and passes back to the WAB
//
//********************************************************************/
BOOL GetDataFromUI(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    TCHAR szData[myMax][MAX_PATH];
    int i;
    ULONG ulIndex = 0;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    SCODE sc;
    BOOL bRet = FALSE;

    // Did any data change that we have to care about ?
    // If nothing changed, old data will be retained by WAB
    //
    if(!lpWED->fDataChanged)
        return TRUE;

    // Check if we have any data to save ...
    for(i=0;i<myMax;i++)
    {
        *(szData[i]) = '\0';
        GetWindowText(GetDlgItem(hDlg, EditControls[i]), szData[i], MAX_PATH);
        if(lstrlen(szData[i]))
            ulcPropCount++;
    }

    if(!ulcPropCount) // no data
        return TRUE;

    // Else data exists. Create a return prop array to pass back to the WAB
    sc = lpWED->lpWABObject->AllocateBuffer(sizeof(SPropValue) * ulcPropCount, 
                                            (LPVOID *)&lpPropArray);
    if (sc!=S_OK)
        goto out;

    for(i=0;i<myMax;i++)
    {
        int nLen = lstrlen(szData[i]);
        if(nLen)
        {
            lpPropArray[ulIndex].ulPropTag = MyPropTags[i];
            sc = lpWED->lpWABObject->AllocateMore(  nLen+1, lpPropArray, 
                                                    (LPVOID *)&(lpPropArray[ulIndex].Value.LPSZ));

            if (sc!=S_OK)
                goto out;
            lstrcpy(lpPropArray[ulIndex].Value.LPSZ,szData[i]);
            ulIndex++;
        }
    }

    // Set this new data on the object
    //
    if(HR_FAILED(lpWED->lpPropObj->SetProps( ulcPropCount, lpPropArray, NULL)))
        goto out;

    // ** Important - do not call SaveChanges on the object
    //    SaveChanges makes persistent changes and may modify/lose data if called at this point
    //    The WAB will determine if its appropriate or not to call SaveChanges after the
    // ** user has closed the property sheets
    

    bRet = TRUE;

out:
    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);

    return bRet;

} 


/*//$$****************************************************************
//
// UpdateDisplayNameInfo
//
// Demonstrates how to read information from other sibling property
// sheets when the user switches between pages
//
// This demo function attempts to get the updated display name info 
// when the user switches to this page in the UI
//
//********************************************************************/
const SizedSPropTagArray(1, ptaName)=
{
    1,
    {
        PR_DISPLAY_NAME
    }
};

void UpdateDisplayNameInfo(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    // 
    // Scan all the updated information from all the other property sheets
    //
    ULONG i = 0, j=0;
    LPTSTR lpName = NULL;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    if(!lpWED)
        return;

    // Each sheet should update its data on the object when it looses
    // focus and gets the PSN_KILLACTIVE message, provided the user has
    // made any changes. We just scan the object for the desired properties
    // and use them.

    // Ask only for the display name
    if(!HR_FAILED(lpWED->lpPropObj->GetProps( (LPSPropTagArray) &ptaName,
                                              0,
                                              &ulcPropCount, &lpPropArray)))
    {
        if( ulcPropCount == 1 && 
            PROP_TYPE(lpPropArray[0].ulPropTag) == PT_TSTRING) // The call could succeed but there may be no DN
        {                                                      // in which case the PROP_TYPE will be PR_NULL 
            lpName = lpPropArray[0].Value.LPSZ;
        }
    }

    if(lpName && lstrlen(lpName))
        SetDlgItemText(hDlg, IDC_STATIC_NAME, lpName);

    if(ulcPropCount && lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);

    return;
}

/*//$$*********************************************************************
//
//  UpdateOldPropTagsArray
//
//  When we update the data on a particular property sheet, we want to update
//  all the properties related to that particular sheet. Since some properties
//  may have been deleted from the UI, we delete all relevant properties from
//  the property object
//
//**************************************************************************/
BOOL UpdateOldPropTagsArray(LPWABEXTDISPLAY lpWED)
{
    LPSPropTagArray lpPTA = NULL;
    SCODE sc = 0;
    int i =0;
    
    sc = lpWED->lpWABObject->AllocateBuffer(sizeof(SPropTagArray) + sizeof(ULONG)*(myMax), 
                                        (LPVOID *)&lpPTA);

    if(!lpPTA || sc!=S_OK)
        return FALSE;

    lpPTA->cValues = myMax;

    for(i=0;i<myMax;i++)
        lpPTA->aulPropTag[i] = MyPropTags[i];

    // Delete any props in the original that may have been modified on this propsheet
    lpWED->lpPropObj->DeleteProps(lpPTA, NULL);

    if(lpPTA)
        lpWED->lpWABObject->FreeBuffer(lpPTA);

    return TRUE;

}

/*//$$*********************************************************************
//
// bUpdatePropSheetData
//
// We delete any properties relevant to us from the object, and set new
// data from the property sheet onto the object
//
****************************************************************************/
BOOL bUpdatePropSheetData(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    BOOL bRet = TRUE;

    if(!lpWED)
        return bRet;

    // ****Dont**** do anything if this is a READ_ONLY operation
    // In that case the memory variables are not all set up and this
    // prop sheet is not expected to return anything at all
    //
    if(!lpWED->fReadOnly)
    {
        // Delete old
        if(!UpdateOldPropTagsArray(lpWED))
            return FALSE;

        bRet = GetDataFromUI(hDlg, lpWED);
    }
    return bRet;
}


STDMETHODIMP CMfcExt::XMfcExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    METHOD_PROLOGUE(CMfcExt, MfcExt);
    TRACE("CMfcExt::XMfcExt::AddPages\n");

    if(pThis->m_lpWED->fReadOnly)
        return NOERROR;

    PROPSHEETPAGE psp;

    hinstApp        = AfxGetResourceHandle();
    psp.dwSize      = sizeof(psp);   // no extra data
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USETITLE ;
    psp.hInstance   = hinstApp;
    psp.lParam      = (LPARAM) &(pThis->m_lpWED);
    psp.pcRefParent = (UINT *)&(pThis->m_cRefThisDll);

    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP);
    psp.pfnDlgProc  = (DLGPROC) pThis->MfcExtDlgProc;
    psp.pszTitle    = "WAB Ext 1"; // Title for your tab

    pThis->m_hPage1 = ::CreatePropertySheetPage(&psp);
    if (pThis->m_hPage1)
    {
        if (!lpfnAddPage(pThis->m_hPage1, lParam))
            ::DestroyPropertySheetPage(pThis->m_hPage1);
    }

    // create another one, just for kicks
    psp.pfnDlgProc  = (DLGPROC) pThis->MfcExtDlgProc2;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP2);
    psp.pszTitle    = "WAB Ext 2"; 

    pThis->m_hPage2 = ::CreatePropertySheetPage(&psp);
    if (pThis->m_hPage2)
    {
        if (!lpfnAddPage(pThis->m_hPage2, lParam))
            ::DestroyPropertySheetPage(pThis->m_hPage2);
    }

    return NOERROR;
}



STDMETHODIMP CMfcExt::XContextMenuExt::QueryInterface(REFIID riid, void** ppv)
{
    METHOD_PROLOGUE(CMfcExt, ContextMenuExt);
    TRACE("CMfcExt::XContextMenuExt::QueryInterface\n");
    return pThis->ExternalQueryInterface(&riid, ppv);
}

STDMETHODIMP_(ULONG) CMfcExt::XContextMenuExt::AddRef(void)
{
    METHOD_PROLOGUE(CMfcExt, ContextMenuExt);
    return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CMfcExt::XContextMenuExt::Release(void)
{
    METHOD_PROLOGUE(CMfcExt, ContextMenuExt);
    return pThis->ExternalRelease();
}

STDMETHODIMP CMfcExt::XContextMenuExt::GetCommandString(UINT idCmd,UINT uFlags,UINT *pwReserved,LPSTR pszName,UINT cchMax)
{
    if(uFlags & GCS_HELPTEXT)
    {
        switch (idCmd)
        {
        case 0:
            lstrcpy(pszName,"Collects E-Mail Addresses from selected entries.");
            break;
        case 1:
            lstrcpy(pszName,"Launches the Calculator (disabled when multiple entries are selected)");
            break;
        case 2:
            lstrcpy(pszName,"Launches Notepad (ignores WAB altogether).");
            break;
        }
    }
    return S_OK;
}

STDMETHODIMP CMfcExt::XContextMenuExt::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    METHOD_PROLOGUE(CMfcExt, ContextMenuExt);
    LPWABEXTDISPLAY lpWEC = pThis->m_lpWEDContext;
    LPADRLIST lpAdrList = NULL;
    int nCmdId = (int) lpici->lpVerb;

    if(!lpWEC || !(lpWEC->ulFlags & WAB_CONTEXT_ADRLIST))
        return E_FAIL;

    lpAdrList = (LPADRLIST) lpWEC->lpv;
    switch(nCmdId)
    {
    case 0:
        {
            if(!lpAdrList || !lpAdrList->cEntries)
            {
                AfxMessageBox("Please select some entries first", MB_OK, 0);
                return E_FAIL;
            }
            CDlgContext DlgContext;
            DlgContext.m_lpAdrList = lpAdrList;
            DlgContext.DoModal();
        }
        break;
    case 1:
        ShellExecute(lpici->hwnd, "open", "calc.exe", NULL, NULL, SW_RESTORE);
        break;
    case 2:
        ShellExecute(lpici->hwnd, "open", "notepad.exe", NULL, NULL, SW_RESTORE);
        break;
    }
    return S_OK;
}

STDMETHODIMP CMfcExt::XContextMenuExt::QueryContextMenu(HMENU hMenu,UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags)
{
    METHOD_PROLOGUE(CMfcExt, ContextMenuExt);
    LPWABEXTDISPLAY lpWEC = pThis->m_lpWEDContext;
    UINT idCmd = idCmdFirst;     
    BOOL bAppendItems=TRUE, bMultiSelected = FALSE; 
    UINT nNumCmd = 0;

    if(lpWEC && lpWEC->lpv)
        bMultiSelected = (((LPADRLIST)(lpWEC->lpv))->cEntries > 1);


    InsertMenu( hMenu, indexMenu++,
                MF_STRING | MF_BYPOSITION,
                idCmd++,
                "E-Mail Collecter");

    InsertMenu( hMenu, indexMenu++,
                MF_STRING | MF_BYPOSITION | (bMultiSelected ? MF_GRAYED : 0),
                idCmd++,
                "Calculator");

    InsertMenu( hMenu, indexMenu++,
                MF_STRING | MF_BYPOSITION,
                idCmd++,
                "Notepad");

    return (idCmd-idCmdFirst); //Must return number of menu 
}


/////////////////////////////////////////////////////////////////////////////
// CDlgContext dialog


CDlgContext::CDlgContext(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgContext::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgContext)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDlgContext::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgContext)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgContext, CDialog)
	//{{AFX_MSG_MAP(CDlgContext)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgContext message handlers

BOOL CDlgContext::OnInitDialog() 
{
	CDialog::OnInitDialog();
    CListBox * pListBox = (CListBox *) GetDlgItem(IDC_LIST_EMAIL);

    ULONG i = 0,j=0;
    for(i=0;i<m_lpAdrList->cEntries;i++)
    {
        LPSPropValue lpProps = m_lpAdrList->aEntries[i].rgPropVals;
        ULONG ulcPropCount = m_lpAdrList->aEntries[i].cValues;
        for(j=0;j<ulcPropCount;j++)
        {
            if(lpProps[j].ulPropTag == PR_EMAIL_ADDRESS)
            {
                pListBox->AddString(lpProps[j].Value.LPSZ);
                break;
            }
        }
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\mfcext\propid.h ===
// PropID.H

#ifndef _CLSID_WABSamplePropExtSheet_
#define _CLSID_WABSamplePropExtSheet_

// {BA9EE970-87A0-11d1-9ACF-00A0C91F9C8B}
DEFINE_GUID(CLSID_WABSamplePropExtSheet,
0xba9ee970, 0x87a0, 0x11d1, 0x9a, 0xcf, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b);

#endif // _CLSID_WABSamplePropExtSheet_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\apitest\_layguid.h ===
/*
 *	_LAYGUID.H
 *
 *	Lays down actual, 16-byte GUIDs for use in an EXE or DLL.
 *	Should be included in only one module (a .C file) of said EXE or DLL.
 *	Before including, define the tags for all the GUIDs you
 *	plan to use, e.g.
 *
 *		#define USES_IID_IUnknown
 *		#define USES_IID_IStream
 *		#define USES_IID_IMAPIProp
 *		#include <_layguid.h>
 */



#ifdef USES_GUID_NULL
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
#endif

#ifdef USES_IID_IUnknown
DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
#endif

#ifdef USES_IID_IClassFactory
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
#endif

#ifdef USES_IID_IMalloc
DEFINE_OLEGUID(IID_IMalloc,             0x00000002L, 0, 0);
#endif

#ifdef USES_IID_IMarshal
DEFINE_OLEGUID(IID_IMarshal,            0x00000003L, 0, 0);
#endif


/* RPC related interfaces */
#ifdef USES_IID_IRpcChannel
DEFINE_OLEGUID(IID_IRpcChannel,         0x00000004L, 0, 0);
#endif

#ifdef USES_IID_IRpcStub
DEFINE_OLEGUID(IID_IRpcStub,            0x00000005L, 0, 0);
#endif

#ifdef USES_IID_IStubManager
DEFINE_OLEGUID(IID_IStubManager,        0x00000006L, 0, 0);
#endif

#ifdef USES_IID_IRpcProxy
DEFINE_OLEGUID(IID_IRpcProxy,           0x00000007L, 0, 0);
#endif

#ifdef USES_IID_IProxyManager
DEFINE_OLEGUID(IID_IProxyManager,       0x00000008L, 0, 0);
#endif

#ifdef USES_IID_IPSFactory
DEFINE_OLEGUID(IID_IPSFactory,          0x00000009L, 0, 0);
#endif

#ifdef USES_IID_IRpcProxyBuffer
DEFINE_GUID(IID_IRpcProxyBuffer, 0xD5F56A34, 0x593B, 0x101A, 0xB5, 0x69, 0x08, 0x00, 0x2B, 0x2D, 0xBF, 0x7A);
#endif

#ifdef USES_IID_IPSFactoryBuffer
DEFINE_GUID(IID_IPSFactoryBuffer,0xD5F569D0,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);
#endif

#ifdef USES_IID_IRpcChannelBuffer
DEFINE_GUID(IID_IRpcChannelBuffer,0xD5F56B60,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);
#endif

#ifdef USES_IID_IRpcStubBuffer
DEFINE_GUID(IID_IRpcStubBuffer,0xD5F56AFC,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);
#endif

/* storage related interfaces */
#ifdef USES_IID_ILockBytes
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
#endif

#ifdef USES_IID_IStorage
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
#endif

#ifdef USES_IID_IStream
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
#endif

#ifdef USES_IID_IEnumSTATSTG
DEFINE_OLEGUID(IID_IEnumSTATSTG,        0x0000000dL, 0, 0);
#endif


/* moniker related interfaces */
#ifdef USES_IID_IBindCtx
DEFINE_OLEGUID(IID_IBindCtx,            0x0000000eL, 0, 0);
#endif

#ifdef USES_IID_IMoniker
DEFINE_OLEGUID(IID_IMoniker,            0x0000000fL, 0, 0);
#endif

#ifdef USES_IID_IRunningObjectTable
DEFINE_OLEGUID(IID_IRunningObjectTable, 0x00000010L, 0, 0);
#endif

#ifdef USES_IID_IInternalMoniker
DEFINE_OLEGUID(IID_IInternalMoniker,    0x00000011L, 0, 0);
#endif


/* storage related interfaces */
#ifdef USES_IID_IRootStorage
DEFINE_OLEGUID(IID_IRootStorage,        0x00000012L, 0, 0);
#endif

#ifdef USES_IID_IDfReserved1
DEFINE_OLEGUID(IID_IDfReserved1,        0x00000013L, 0, 0);
#endif

#ifdef USES_IID_IDfReserved2
DEFINE_OLEGUID(IID_IDfReserved2,        0x00000014L, 0, 0);
#endif

#ifdef USES_IID_IDfReserved3
DEFINE_OLEGUID(IID_IDfReserved3,        0x00000015L, 0, 0);
#endif


/* concurrency releated interfaces */
#ifdef USES_IID_IMessageFilter
DEFINE_OLEGUID(IID_IMessageFilter,      0x00000016L, 0, 0);
#endif


/* CLSID of standard marshaler */
#ifdef USES_CLSID_StdMarshal
DEFINE_OLEGUID(CLSID_StdMarshal,		0x00000017L, 0, 0);
#endif


/* interface on server for getting info for std marshaler */
#ifdef USES_IID_IStdMarshalInfo
DEFINE_OLEGUID(IID_IStdMarshalInfo,     0x00000018L, 0, 0);
#endif


/* NOTE: LSB 0x19 through 0xff are reserved for future use */

//	End of COGUID.H clone

//	Copied from OLEGUID.H

/* this file is the master definition of all public GUIDs specific to OLE
   and is included in ole2.h.

   NOTE: The second least significant byte of all of these GUIDs is 1.
*/


#ifdef USES_IID_IEnumUnknown
DEFINE_OLEGUID(IID_IEnumUnknown,            0x00000100, 0, 0);
#endif

#ifdef USES_IID_IEnumString
DEFINE_OLEGUID(IID_IEnumString,             0x00000101, 0, 0);
#endif

#ifdef USES_IID_IEnumMoniker
DEFINE_OLEGUID(IID_IEnumMoniker,            0x00000102, 0, 0);
#endif

#ifdef USES_IID_IEnumFORMATETC
DEFINE_OLEGUID(IID_IEnumFORMATETC,          0x00000103, 0, 0);
#endif

#ifdef USES_IID_IEnumOLEVERB
DEFINE_OLEGUID(IID_IEnumOLEVERB,            0x00000104, 0, 0);
#endif

#ifdef USES_IID_IEnumSTATDATA
DEFINE_OLEGUID(IID_IEnumSTATDATA,           0x00000105, 0, 0);
#endif


#ifdef USES_IID_IEnumGeneric
DEFINE_OLEGUID(IID_IEnumGeneric,            0x00000106, 0, 0);
#endif

#ifdef USES_IID_IEnumHolder
DEFINE_OLEGUID(IID_IEnumHolder,             0x00000107, 0, 0);
#endif

#ifdef USES_IID_IEnumCallback
DEFINE_OLEGUID(IID_IEnumCallback,           0x00000108, 0, 0);
#endif


#ifdef USES_IID_IPersistStream
DEFINE_OLEGUID(IID_IPersistStream,          0x00000109, 0, 0);
#endif

#ifdef USES_IID_IPersistStorage
DEFINE_OLEGUID(IID_IPersistStorage,         0x0000010a, 0, 0);
#endif

#ifdef USES_IID_IPersistFile
DEFINE_OLEGUID(IID_IPersistFile,            0x0000010b, 0, 0);
#endif

#ifdef USES_IID_IPersist
DEFINE_OLEGUID(IID_IPersist,                0x0000010c, 0, 0);
#endif


#ifdef USES_IID_IViewObject
DEFINE_OLEGUID(IID_IViewObject,             0x0000010d, 0, 0);
#endif

#ifdef USES_IID_IDataObject
DEFINE_OLEGUID(IID_IDataObject,             0x0000010e, 0, 0);
#endif

#ifdef USES_IID_IAdviseSink
DEFINE_OLEGUID(IID_IAdviseSink,             0x0000010f, 0, 0);
#endif

#ifdef USES_IID_IDataAdviseHolder
DEFINE_OLEGUID(IID_IDataAdviseHolder,       0x00000110, 0, 0);
#endif

#ifdef USES_IID_IOleAdviseHolder
DEFINE_OLEGUID(IID_IOleAdviseHolder,        0x00000111, 0, 0);
#endif


#ifdef USES_IID_IOleObject
DEFINE_OLEGUID(IID_IOleObject,              0x00000112, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceObject
DEFINE_OLEGUID(IID_IOleInPlaceObject,       0x00000113, 0, 0);
#endif

#ifdef USES_IID_IOleWindow
DEFINE_OLEGUID(IID_IOleWindow,              0x00000114, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceUIWindow
DEFINE_OLEGUID(IID_IOleInPlaceUIWindow,     0x00000115, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceFrame
DEFINE_OLEGUID(IID_IOleInPlaceFrame,        0x00000116, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceActiveObject
DEFINE_OLEGUID(IID_IOleInPlaceActiveObject, 0x00000117, 0, 0);
#endif


#ifdef USES_IID_IOleClientSite
DEFINE_OLEGUID(IID_IOleClientSite,          0x00000118, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceSite
DEFINE_OLEGUID(IID_IOleInPlaceSite,         0x00000119, 0, 0);
#endif


#ifdef USES_IID_IParseDisplayName
DEFINE_OLEGUID(IID_IParseDisplayName,       0x0000011a, 0, 0);
#endif

#ifdef USES_IID_IOleContainer
DEFINE_OLEGUID(IID_IOleContainer,           0x0000011b, 0, 0);
#endif

#ifdef USES_IID_IOleItemContainer
DEFINE_OLEGUID(IID_IOleItemContainer,       0x0000011c, 0, 0);
#endif


#ifdef USES_IID_IOleLink
DEFINE_OLEGUID(IID_IOleLink,                0x0000011d, 0, 0);
#endif

#ifdef USES_IID_IOleCache
DEFINE_OLEGUID(IID_IOleCache,               0x0000011e, 0, 0);
#endif

#ifdef USES_IID_IOleManager
DEFINE_OLEGUID(IID_IOleManager,             0x0000011f, 0, 0);
#endif

#ifdef USES_IID_IOlePresObj
DEFINE_OLEGUID(IID_IOlePresObj,             0x00000120, 0, 0);
#endif


#ifdef USES_IID_IDropSource
DEFINE_OLEGUID(IID_IDropSource,             0x00000121, 0, 0);
#endif

#ifdef USES_IID_IDropTarget
DEFINE_OLEGUID(IID_IDropTarget,             0x00000122, 0, 0);
#endif


#ifdef USES_IID_IDebug
DEFINE_OLEGUID(IID_IDebug,                  0x00000123, 0, 0);
#endif

#ifdef USES_IID_IDebugStream
DEFINE_OLEGUID(IID_IDebugStream,            0x00000124, 0, 0);
#endif



/* NOTE: LSB values 0x25 through 0xff are reserved */


/* GUIDs defined in OLE's private range */
#ifdef USES_CLSID_StdOleLink
DEFINE_OLEGUID(CLSID_StdOleLink,			0x00000300, 0, 0);
#endif

#ifdef USES_CLSID_StaticMetafile
DEFINE_OLEGUID(CLSID_StaticMetafile,        0x00000315, 0, 0);
#endif

#ifdef USES_CLSID_StaticDib
DEFINE_OLEGUID(CLSID_StaticDib,             0x00000316, 0, 0);
#endif

//	End of OLEGUID.H clone
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\mfcext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mfcext.rc
//
#define IDI_ICON1                       101
#define IDD_PROP2                       103
#define IDD_PROP                        104
#define IDI_ICON2                       104
#define IDD_CONTEXT                     106
#define IDC_EXT_EDIT_HOME               1000
#define IDC_EXT_EDIT_TEAM               1002
#define IDC_STATIC_NAME                 1004
#define IDC_BUTTON1                     1006
#define IDC_BUTTON2                     1007
#define IDC_BUTTON3                     1008
#define IDC_BUTTON4                     1009
#define IDC_BUTTON5                     1010
#define IDC_LIST_EMAIL                  1014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\mfcext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mfcext.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\calendar.h ===
#if !defined(AFX_CALENDAR_H__555D45A3_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_)
#define AFX_CALENDAR_H__555D45A3_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CCalendar wrapper class

class CCalendar : public CWnd
{
protected:
	DECLARE_DYNCREATE(CCalendar)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x8e27c92b, 0x1264, 0x101c, { 0x8a, 0x2f, 0x4, 0x2, 0x24, 0x0, 0x9c, 0x2 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	unsigned long GetBackColor();
	void SetBackColor(unsigned long newValue);
	short GetDay();
	void SetDay(short nNewValue);
	COleFont GetDayFont();
	void SetDayFont(LPDISPATCH newValue);
	unsigned long GetDayFontColor();
	void SetDayFontColor(unsigned long newValue);
	short GetDayLength();
	void SetDayLength(short nNewValue);
	short GetFirstDay();
	void SetFirstDay(short nNewValue);
	long GetGridCellEffect();
	void SetGridCellEffect(long nNewValue);
	COleFont GetGridFont();
	void SetGridFont(LPDISPATCH newValue);
	unsigned long GetGridFontColor();
	void SetGridFontColor(unsigned long newValue);
	unsigned long GetGridLinesColor();
	void SetGridLinesColor(unsigned long newValue);
	short GetMonth();
	void SetMonth(short nNewValue);
	short GetMonthLength();
	void SetMonthLength(short nNewValue);
	BOOL GetShowDateSelectors();
	void SetShowDateSelectors(BOOL bNewValue);
	BOOL GetShowDays();
	void SetShowDays(BOOL bNewValue);
	BOOL GetShowHorizontalGrid();
	void SetShowHorizontalGrid(BOOL bNewValue);
	BOOL GetShowTitle();
	void SetShowTitle(BOOL bNewValue);
	BOOL GetShowVerticalGrid();
	void SetShowVerticalGrid(BOOL bNewValue);
	COleFont GetTitleFont();
	void SetTitleFont(LPDISPATCH newValue);
	unsigned long GetTitleFontColor();
	void SetTitleFontColor(unsigned long newValue);
	VARIANT GetValue();
	void SetValue(const VARIANT& newValue);
	BOOL GetValueIsNull();
	void SetValueIsNull(BOOL bNewValue);
	short GetYear();
	void SetYear(short nNewValue);
	void NextDay();
	void NextMonth();
	void NextWeek();
	void NextYear();
	void PreviousDay();
	void PreviousMonth();
	void PreviousWeek();
	void PreviousYear();
	void Refresh();
	void Today();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CALENDAR_H__555D45A3_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\calendar.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "calendar.h"

// Dispatch interfaces referenced by this interface
#include "Font.h"

/////////////////////////////////////////////////////////////////////////////
// CCalendar

IMPLEMENT_DYNCREATE(CCalendar, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CCalendar properties

/////////////////////////////////////////////////////////////////////////////
// CCalendar operations

unsigned long CCalendar::GetBackColor()
{
	unsigned long result;
	InvokeHelper(DISPID_BACKCOLOR, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CCalendar::SetBackColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_BACKCOLOR, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

short CCalendar::GetDay()
{
	short result;
	InvokeHelper(0x11, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CCalendar::SetDay(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x11, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

COleFont CCalendar::GetDayFont()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x1, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);
	return COleFont(pDispatch);
}

void CCalendar::SetDayFont(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x1, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CCalendar::GetDayFontColor()
{
	unsigned long result;
	InvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CCalendar::SetDayFontColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

short CCalendar::GetDayLength()
{
	short result;
	InvokeHelper(0x12, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CCalendar::SetDayLength(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x12, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CCalendar::GetFirstDay()
{
	short result;
	InvokeHelper(0x13, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CCalendar::SetFirstDay(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x13, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CCalendar::GetGridCellEffect()
{
	long result;
	InvokeHelper(0x14, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CCalendar::SetGridCellEffect(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x14, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

COleFont CCalendar::GetGridFont()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x3, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);
	return COleFont(pDispatch);
}

void CCalendar::SetGridFont(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x3, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CCalendar::GetGridFontColor()
{
	unsigned long result;
	InvokeHelper(0x4, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CCalendar::SetGridFontColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x4, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CCalendar::GetGridLinesColor()
{
	unsigned long result;
	InvokeHelper(0xd, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CCalendar::SetGridLinesColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xd, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

short CCalendar::GetMonth()
{
	short result;
	InvokeHelper(0x10, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CCalendar::SetMonth(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x10, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CCalendar::GetMonthLength()
{
	short result;
	InvokeHelper(0x15, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CCalendar::SetMonthLength(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x15, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL CCalendar::GetShowDateSelectors()
{
	BOOL result;
	InvokeHelper(0x5, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CCalendar::SetShowDateSelectors(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x5, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CCalendar::GetShowDays()
{
	BOOL result;
	InvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CCalendar::SetShowDays(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x6, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CCalendar::GetShowHorizontalGrid()
{
	BOOL result;
	InvokeHelper(0x7, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CCalendar::SetShowHorizontalGrid(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x7, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CCalendar::GetShowTitle()
{
	BOOL result;
	InvokeHelper(0x8, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CCalendar::SetShowTitle(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x8, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CCalendar::GetShowVerticalGrid()
{
	BOOL result;
	InvokeHelper(0x9, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CCalendar::SetShowVerticalGrid(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x9, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

COleFont CCalendar::GetTitleFont()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0xa, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);
	return COleFont(pDispatch);
}

void CCalendar::SetTitleFont(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0xa, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CCalendar::GetTitleFontColor()
{
	unsigned long result;
	InvokeHelper(0xb, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CCalendar::SetTitleFontColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xb, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

VARIANT CCalendar::GetValue()
{
	VARIANT result;
	InvokeHelper(0xc, DISPATCH_PROPERTYGET, VT_VARIANT, (void*)&result, NULL);
	return result;
}

void CCalendar::SetValue(const VARIANT& newValue)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0xc, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 &newValue);
}

BOOL CCalendar::GetValueIsNull()
{
	BOOL result;
	InvokeHelper(0xe, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CCalendar::SetValueIsNull(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0xe, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

short CCalendar::GetYear()
{
	short result;
	InvokeHelper(0xf, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CCalendar::SetYear(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0xf, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

void CCalendar::NextDay()
{
	InvokeHelper(0x16, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::NextMonth()
{
	InvokeHelper(0x17, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::NextWeek()
{
	InvokeHelper(0x18, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::NextYear()
{
	InvokeHelper(0x19, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::PreviousDay()
{
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::PreviousMonth()
{
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::PreviousWeek()
{
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::PreviousYear()
{
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::Refresh()
{
	InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::Today()
{
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\mfcext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BA583A6B_879D_11D1_9ACF_00A0C91F9C8B__INCLUDED_)
#define AFX_STDAFX_H__BA583A6B_879D_11D1_9ACF_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BA583A6B_879D_11D1_9ACF_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\caldlg.cpp ===
// CalDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wabapp.h"
#include "CalDlg.h"
#include "Calendar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCalDlg dialog


CCalDlg::CCalDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCalDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCalDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CCalDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCalDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


void CCalDlg::SetItemName(CString szName)
{
    CString s1("Select a birthday date for ");
    CString s2(szName);
    CString sz(s1 + s2);
    m_psz = new CString(sz);
}

void CCalDlg::SetDate(SYSTEMTIME st)
{
    m_Day = (short) st.wDay;
    m_Month = (short) st.wMonth;
    m_Year = (short) st.wYear;
}

void CCalDlg::GetDate(SYSTEMTIME * lpst)
{
    lpst->wDay = m_Day;
    lpst->wMonth = m_Month;
    lpst->wYear = m_Year;
}

BEGIN_MESSAGE_MAP(CCalDlg, CDialog)
	//{{AFX_MSG_MAP(CCalDlg)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCalDlg message handlers


BOOL CCalDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    CStatic * pStatic = (CStatic *) GetDlgItem(IDC_STATIC_FRAME);

    pStatic->SetWindowText(*m_psz);

    CCalendar * pCal = (CCalendar *) GetDlgItem(IDC_CALENDAR);

    pCal->SetDay(m_Day);
    pCal->SetMonth(m_Month);
    pCal->SetYear(m_Year);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CCalDlg::OnOK() 
{
	// TODO: Add extra validation here
	
    CCalendar * pCal = (CCalendar *) GetDlgItem(IDC_CALENDAR);
    m_Day = pCal->GetDay();
    m_Month = pCal->GetMonth();
    m_Year = pCal->GetYear();
	CDialog::OnOK();
}

void CCalDlg::OnDestroy() 
{
	CDialog::OnDestroy();
	
	// TODO: Add your message handler code here
	delete m_psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\caldlg.h ===
#if !defined(AFX_CALDLG_H__555D45A2_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_)
#define AFX_CALDLG_H__555D45A2_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CalDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCalDlg dialog

class CCalDlg : public CDialog
{
// Construction
public:
	CCalDlg(CWnd* pParent = NULL);   // standard constructor
    void SetItemName(CString szName);
    void SetDate(SYSTEMTIME st);
    void GetDate(SYSTEMTIME * lpst);

// Dialog Data
	//{{AFX_DATA(CCalDlg)
	enum { IDD = IDD_DIALOG_CAL };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCalDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    CString * m_psz;
    short   m_Day;
    short   m_Month;
    short   m_Year;

	// Generated message map functions
	//{{AFX_MSG(CCalDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CALDLG_H__555D45A2_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\font.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "font.h"


/////////////////////////////////////////////////////////////////////////////
// COleFont properties

CString COleFont::GetName()
{
	CString result;
	GetProperty(0x0, VT_BSTR, (void*)&result);
	return result;
}

void COleFont::SetName(LPCTSTR propVal)
{
	SetProperty(0x0, VT_BSTR, propVal);
}

CY COleFont::GetSize()
{
	CY result;
	GetProperty(0x2, VT_CY, (void*)&result);
	return result;
}

void COleFont::SetSize(const CY& propVal)
{
	SetProperty(0x2, VT_CY, &propVal);
}

BOOL COleFont::GetBold()
{
	BOOL result;
	GetProperty(0x3, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetBold(BOOL propVal)
{
	SetProperty(0x3, VT_BOOL, propVal);
}

BOOL COleFont::GetItalic()
{
	BOOL result;
	GetProperty(0x4, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetItalic(BOOL propVal)
{
	SetProperty(0x4, VT_BOOL, propVal);
}

BOOL COleFont::GetUnderline()
{
	BOOL result;
	GetProperty(0x5, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetUnderline(BOOL propVal)
{
	SetProperty(0x5, VT_BOOL, propVal);
}

BOOL COleFont::GetStrikethrough()
{
	BOOL result;
	GetProperty(0x6, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetStrikethrough(BOOL propVal)
{
	SetProperty(0x6, VT_BOOL, propVal);
}

short COleFont::GetWeight()
{
	short result;
	GetProperty(0x7, VT_I2, (void*)&result);
	return result;
}

void COleFont::SetWeight(short propVal)
{
	SetProperty(0x7, VT_I2, propVal);
}

short COleFont::GetCharset()
{
	short result;
	GetProperty(0x8, VT_I2, (void*)&result);
	return result;
}

void COleFont::SetCharset(short propVal)
{
	SetProperty(0x8, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// COleFont operations
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\font.h ===
#if !defined(AFX_FONT_H__555D45A4_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_)
#define AFX_FONT_H__555D45A4_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// COleFont wrapper class

class COleFont : public COleDispatchDriver
{
public:
	COleFont() {}		// Calls COleDispatchDriver default constructor
	COleFont(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	COleFont(const COleFont& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
	CString GetName();
	void SetName(LPCTSTR);
	CY GetSize();
	void SetSize(const CY&);
	BOOL GetBold();
	void SetBold(BOOL);
	BOOL GetItalic();
	void SetItalic(BOOL);
	BOOL GetUnderline();
	void SetUnderline(BOOL);
	BOOL GetStrikethrough();
	void SetStrikethrough(BOOL);
	short GetWeight();
	void SetWeight(short);
	short GetCharset();
	void SetCharset(short);

// Operations
public:
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FONT_H__555D45A4_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wabapp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BEF211E9_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_)
#define AFX_STDAFX_H__BEF211E9_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BEF211E9_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\wabapp.h ===
// wabapp.h : main header file for the WABAPP application
//

#if !defined(AFX_WABAPP_H__BEF211E5_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_)
#define AFX_WABAPP_H__BEF211E5_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CWabappApp:
// See wabapp.cpp for the implementation of this class
//

class CWabappApp : public CWinApp
{
public:
	CWabappApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWabappApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CWabappApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WABAPP_H__BEF211E5_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wabapp.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_WABAPP_DIALOG               102
#define IDR_MAINFRAME                   128
#define IDD_DIALOG_CAL                  133
#define IDC_LIST                        1000
#define IDC_RADIO_DETAILS               1001
#define IDC_RADIO_PHONELIST             1002
#define IDC_RADIO_EMAILLIST             1003
#define IDC_RADIO_BIRTHDAYS             1004
#define IDC_BUTTON                      1006
#define IDC_EXPLORER                    1012
#define IDC_CALENDAR                    1013
#define IDC_STATIC_FRAME                1014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        135
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\wabapp.cpp ===
// wabapp.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "wabapp.h"
#include "wabappDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWabappApp

BEGIN_MESSAGE_MAP(CWabappApp, CWinApp)
	//{{AFX_MSG_MAP(CWabappApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWabappApp construction

CWabappApp::CWabappApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWabappApp object

CWabappApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWabappApp initialization

BOOL CWabappApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CWabappDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\wabappdlg.cpp ===
// wabappDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wabapp.h"
#include "wabappDlg.h"
#include "caldlg.h"
#include "webbrwsr.h"
#include "wabobject.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CWAB * g_pWAB;

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWabappDlg dialog

CWabappDlg::CWabappDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CWabappDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWabappDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CWabappDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWabappDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWabappDlg, CDialog)
	//{{AFX_MSG_MAP(CWabappDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BUTTON, OnBDayButtonClicked)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
	ON_BN_CLICKED(IDC_RADIO_DETAILS, OnRadioDetails)
	ON_BN_CLICKED(IDC_RADIO_PHONELIST, OnRadioPhonelist)
	ON_BN_CLICKED(IDC_RADIO_EMAILLIST, OnRadioEmaillist)
	ON_BN_CLICKED(IDC_RADIO_BIRTHDAYS, OnRadioBirthdays)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWabappDlg message handlers

BOOL CWabappDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here

    InitCommonControls();

    g_pWAB = new CWAB;
    
    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);
    g_pWAB->LoadWABContents(pListView);

    // select the first item in the list view
    pListView->SetItem(0,0,LVIF_STATE,NULL,0,LVNI_SELECTED,LVNI_SELECTED,NULL);

    // turn on the details button by default
    CButton * pButtonDetails = (CButton *) GetDlgItem(IDC_RADIO_DETAILS);
    pButtonDetails->SetCheck(BST_CHECKED);

    SendMessage(WM_COMMAND, (WPARAM) IDC_RADIO_DETAILS, 0);

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CWabappDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CWabappDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CWabappDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CWabappDlg::OnBDayButtonClicked() 
{
    CCalDlg CalDlg;

    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);

    int iItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(iItem == -1)
        return;

    CalDlg.SetItemName(pListView->GetItemText(iItem, 0));

    SYSTEMTIME st={0};

    if(!g_pWAB->GetSelectedItemBirthday(pListView, &st))
        GetSystemTime(&st);

    CalDlg.SetDate(st);

    if(IDOK == CalDlg.DoModal())
    {
        CalDlg.GetDate(&st);
        g_pWAB->SetSelectedItemBirthday(pListView, st);
    }

}

BOOL CWabappDlg::DestroyWindow() 
{
    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);
    
    g_pWAB->ClearWABLVContents(pListView);

    delete g_pWAB;

	return CDialog::DestroyWindow();
}



void CWabappDlg::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);

    static int oldItem;

    int newItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(newItem != oldItem && newItem != -1)
    {
        TCHAR szFileName[MAX_PATH];

        g_pWAB->CreateDetailsFileFromWAB(pListView, szFileName);
        if(lstrlen(szFileName))
        {
            CWebBrowser * pCWB = (CWebBrowser *) GetDlgItem(IDC_EXPLORER);
            pCWB->Navigate(szFileName, NULL, NULL, NULL, NULL);
        }
        oldItem = newItem;
    }
	
	*pResult = 0;
}

void CWabappDlg::OnRadioDetails() 
{
    g_pWAB->SetDetailsOn(TRUE);

    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);

    TCHAR szFileName[MAX_PATH];

    g_pWAB->CreateDetailsFileFromWAB(pListView, szFileName);
    if(lstrlen(szFileName))
    {
        CWebBrowser * pCWB = (CWebBrowser *) GetDlgItem(IDC_EXPLORER);
        pCWB->Navigate(szFileName, NULL, NULL, NULL, NULL);
    }

}

void CWabappDlg::OnRadioPhonelist() 
{
    TCHAR szFileName[MAX_PATH];
    
    g_pWAB->SetDetailsOn(FALSE);

    g_pWAB->CreatePhoneListFileFromWAB(szFileName);
    
    if(lstrlen(szFileName))
    {
        CWebBrowser * pCWB = (CWebBrowser *) GetDlgItem(IDC_EXPLORER);
        pCWB->Navigate(szFileName, NULL, NULL, NULL, NULL);
    }
}

void CWabappDlg::OnRadioEmaillist() 
{
    TCHAR szFileName[MAX_PATH];
    
    g_pWAB->SetDetailsOn(FALSE);

    g_pWAB->CreateEmailListFileFromWAB(szFileName);
    
    if(lstrlen(szFileName))
    {
        CWebBrowser * pCWB = (CWebBrowser *) GetDlgItem(IDC_EXPLORER);
        pCWB->Navigate(szFileName, NULL, NULL, NULL, NULL);
    }

}

void CWabappDlg::OnRadioBirthdays() 
{
    TCHAR szFileName[MAX_PATH];
    
    g_pWAB->SetDetailsOn(FALSE);

    g_pWAB->CreateBirthdayFileFromWAB(szFileName);
    
    if(lstrlen(szFileName))
    {
        CWebBrowser * pCWB = (CWebBrowser *) GetDlgItem(IDC_EXPLORER);
        pCWB->Navigate(szFileName, NULL, NULL, NULL, NULL);
    }
}

void CWabappDlg::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);
    
    g_pWAB->ShowSelectedItemDetails(m_hWnd, pListView);

	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\wabappdlg.h ===
// wabappDlg.h : header file
//

#if !defined(AFX_WABAPPDLG_H__BEF211E7_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_)
#define AFX_WABAPPDLG_H__BEF211E7_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CWabappDlg dialog

class CWabappDlg : public CDialog
{
// Construction
public:
	CWabappDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CWabappDlg)
	enum { IDD = IDD_WABAPP_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWabappDlg)
	public:
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CWabappDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnBDayButtonClicked();
	afx_msg void OnClickList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRadioDetails();
	afx_msg void OnRadioPhonelist();
	afx_msg void OnRadioEmaillist();
	afx_msg void OnRadioBirthdays();
	afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WABAPPDLG_H__BEF211E7_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\webbrwsr.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "webbrwsr.h"

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser

IMPLEMENT_DYNCREATE(CWebBrowser, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser properties

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser operations

void CWebBrowser::GoBack()
{
	InvokeHelper(0x64, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::GoForward()
{
	InvokeHelper(0x65, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::GoHome()
{
	InvokeHelper(0x66, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::GoSearch()
{
	InvokeHelper(0x67, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::Navigate(LPCTSTR URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers)
{
	static BYTE parms[] =
		VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x68, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 URL, Flags, TargetFrameName, PostData, Headers);
}

void CWebBrowser::Refresh()
{
	InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::Refresh2(VARIANT* Level)
{
	static BYTE parms[] =
		VTS_PVARIANT;
	InvokeHelper(0x69, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Level);
}

void CWebBrowser::Stop()
{
	InvokeHelper(0x6a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH CWebBrowser::GetApplication()
{
	LPDISPATCH result;
	InvokeHelper(0xc8, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH CWebBrowser::GetParent()
{
	LPDISPATCH result;
	InvokeHelper(0xc9, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH CWebBrowser::GetContainer()
{
	LPDISPATCH result;
	InvokeHelper(0xca, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH CWebBrowser::GetDocument()
{
	LPDISPATCH result;
	InvokeHelper(0xcb, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser::GetTopLevelContainer()
{
	BOOL result;
	InvokeHelper(0xcc, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

CString CWebBrowser::GetType()
{
	CString result;
	InvokeHelper(0xcd, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

long CWebBrowser::GetLeft()
{
	long result;
	InvokeHelper(0xce, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetLeft(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xce, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CWebBrowser::GetTop()
{
	long result;
	InvokeHelper(0xcf, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetTop(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xcf, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CWebBrowser::GetWidth()
{
	long result;
	InvokeHelper(0xd0, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetWidth(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xd0, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CWebBrowser::GetHeight()
{
	long result;
	InvokeHelper(0xd1, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetHeight(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xd1, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CString CWebBrowser::GetLocationName()
{
	CString result;
	InvokeHelper(0xd2, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

CString CWebBrowser::GetLocationURL()
{
	CString result;
	InvokeHelper(0xd3, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser::GetBusy()
{
	BOOL result;
	InvokeHelper(0xd4, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::Quit()
{
	InvokeHelper(0x12c, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::ClientToWindow(long* pcx, long* pcy)
{
	static BYTE parms[] =
		VTS_PI4 VTS_PI4;
	InvokeHelper(0x12d, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pcx, pcy);
}

void CWebBrowser::PutProperty(LPCTSTR szProperty, const VARIANT& vtValue)
{
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x12e, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szProperty, &vtValue);
}

VARIANT CWebBrowser::GetProperty_(LPCTSTR szProperty)
{
	VARIANT result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x12f, DISPATCH_METHOD, VT_VARIANT, (void*)&result, parms,
		szProperty);
	return result;
}

CString CWebBrowser::GetName()
{
	CString result;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

long CWebBrowser::GetHwnd()
{
	long result;
	InvokeHelper(DISPID_HWND, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

CString CWebBrowser::GetFullName()
{
	CString result;
	InvokeHelper(0x190, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

CString CWebBrowser::GetPath()
{
	CString result;
	InvokeHelper(0x191, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser::GetVisible()
{
	BOOL result;
	InvokeHelper(0x192, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetVisible(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x192, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetStatusBar()
{
	BOOL result;
	InvokeHelper(0x193, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetStatusBar(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x193, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

CString CWebBrowser::GetStatusText()
{
	CString result;
	InvokeHelper(0x194, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetStatusText(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x194, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

long CWebBrowser::GetToolBar()
{
	long result;
	InvokeHelper(0x195, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetToolBar(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x195, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL CWebBrowser::GetMenuBar()
{
	BOOL result;
	InvokeHelper(0x196, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetMenuBar(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x196, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetFullScreen()
{
	BOOL result;
	InvokeHelper(0x197, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetFullScreen(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x197, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

void CWebBrowser::Navigate2(VARIANT* URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers)
{
	static BYTE parms[] =
		VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x1f4, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 URL, Flags, TargetFrameName, PostData, Headers);
}

long CWebBrowser::QueryStatusWB(long cmdID)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1f5, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		cmdID);
	return result;
}

void CWebBrowser::ExecWB(long cmdID, long cmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x1f6, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 cmdID, cmdexecopt, pvaIn, pvaOut);
}

void CWebBrowser::ShowBrowserBar(VARIANT* pvaClsid, VARIANT* pvarShow, VARIANT* pvarSize)
{
	static BYTE parms[] =
		VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x1f7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pvaClsid, pvarShow, pvarSize);
}

long CWebBrowser::GetReadyState()
{
	long result;
	InvokeHelper(DISPID_READYSTATE, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser::GetOffline()
{
	BOOL result;
	InvokeHelper(0x226, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetOffline(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x226, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetSilent()
{
	BOOL result;
	InvokeHelper(0x227, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetSilent(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x227, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetRegisterAsBrowser()
{
	BOOL result;
	InvokeHelper(0x228, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetRegisterAsBrowser(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x228, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetRegisterAsDropTarget()
{
	BOOL result;
	InvokeHelper(0x229, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetRegisterAsDropTarget(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x229, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetTheaterMode()
{
	BOOL result;
	InvokeHelper(0x22a, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetTheaterMode(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x22a, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\_wabapp.h ===
#include "stdafx.h"
#include "webbrwsr.h"
#include "wabapp.h"
#include "wabappDlg.h"
#include "wab.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\wabobject.h ===
#include "stdafx.h"
#include "afxcview.h"
#include "wab.h"

class CWAB
{
public:
    CWAB();
    ~CWAB();
    BOOL CreatePhoneListFileFromWAB(LPTSTR szFileName);
    BOOL CreateEmailListFileFromWAB(LPTSTR szFileName);
    BOOL CreateBirthdayFileFromWAB(LPTSTR szFileName);
    BOOL CreateDetailsFileFromWAB(CListCtrl * pListView, LPTSTR szFileName);
    HRESULT LoadWABContents(CListCtrl * pListView);
    void ClearWABLVContents(CListCtrl * pListView);
    void SetDetailsOn(BOOL bOn);
    void ShowSelectedItemDetails(HWND hWndParent, CListCtrl * pListView);
    BOOL GetSelectedItemBirthday(CListCtrl * pListView, SYSTEMTIME * lpst);
    void SetSelectedItemBirthday(CListCtrl * pListView, SYSTEMTIME st);

private:
    BOOL        m_bInitialized;
    HINSTANCE   m_hinstWAB;
    LPWABOPEN   m_lpfnWABOpen;
    LPADRBOOK   m_lpAdrBook; 
    LPWABOBJECT m_lpWABObject;
    BOOL        m_bDetailsOn;

    void FreeProws(LPSRowSet prows);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\wabobject.cpp ===
#include "wabobject.h"



enum {
    ieidPR_DISPLAY_NAME = 0,
    ieidPR_ENTRYID,
	ieidPR_OBJECT_TYPE,
    ieidPR_WAB_CONF_SERVERS,
    ieidMax
};
static const SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
		PR_OBJECT_TYPE,
        0x8000101e,
    }
};

enum {
    iemailPR_DISPLAY_NAME = 0,
    iemailPR_ENTRYID,
    iemailPR_EMAIL_ADDRESS,
    iemailPR_OBJECT_TYPE,
    iemailMax
};
static const SizedSPropTagArray(iemailMax, ptaEmail)=
{
    iemailMax,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
        PR_EMAIL_ADDRESS,
        PR_OBJECT_TYPE
    }
};


enum {
    iphonePR_DISPLAY_NAME = 0,
    iphonePR_BUSINESS_TELEPHONE_NUMBER,
    iphonePR_HOME_TELEPHONE_NUMBER,
    iphonePR_ENTRYID,
    iphonePR_OBJECT_TYPE,
    iphoneMax
};
static const SizedSPropTagArray(iphoneMax, ptaPhone)=
{
    iphoneMax,
    {
        PR_DISPLAY_NAME,
        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_HOME_TELEPHONE_NUMBER,
        PR_ENTRYID,
        PR_OBJECT_TYPE
    }
};


enum {
    ibdayPR_BIRTHDAY=0,
    ibdayPR_DISPLAY_NAME,
    ibdayPR_ENTRYID,
    ibdayPR_OBJECT_TYPE,
    ibdayMax
};
static const SizedSPropTagArray(ibdayMax, ptaBday)=
{
    ibdayMax,
    {
        PR_BIRTHDAY,
        PR_DISPLAY_NAME,
        PR_ENTRYID,
        PR_OBJECT_TYPE
    }
};




/*********************************************************************************************************/

ULONG ulProps[] = 
{
    PR_DISPLAY_NAME,
    PR_HOME_TELEPHONE_NUMBER,
    PR_HOME_FAX_NUMBER,
    PR_CELLULAR_TELEPHONE_NUMBER,
    PR_BUSINESS_TELEPHONE_NUMBER,
    PR_BUSINESS_FAX_NUMBER,
    PR_PAGER_TELEPHONE_NUMBER,
    PR_HOME_ADDRESS_STREET,
    PR_HOME_ADDRESS_CITY,
    PR_HOME_ADDRESS_STATE_OR_PROVINCE,
    PR_HOME_ADDRESS_POSTAL_CODE,
    PR_HOME_ADDRESS_COUNTRY,
    PR_DEPARTMENT_NAME,
    PR_COMPANY_NAME,
    PR_OFFICE_LOCATION,
    PR_BUSINESS_ADDRESS_STREET,
    PR_BUSINESS_ADDRESS_CITY,
    PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
    PR_BUSINESS_ADDRESS_POSTAL_CODE,
    PR_BUSINESS_ADDRESS_COUNTRY,
    PR_PERSONAL_HOME_PAGE,
    PR_BUSINESS_HOME_PAGE,
    PR_COMMENT,
};
#define ulPropsMax 23

enum _Parts {
    pMain=0, 
    pEmail, 
    pPhone, 
    pHome, 
    pBusiness, 
    pURLS, 
    pNotes, 
    pEnd,
    pPartsMax
};


TCHAR szEmailPageHeader[] = 
"<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"><title>WAB Email Address List</title></head><body bgcolor=\"#A02303\" text=\"#FFFF00\" link=\"#FFFFFF\" vlink=\"#800000\" alink=\"#0000FF\"><div align=\"center\"><center><table border=\"0\" cellspacing=\"1\" width=\"520\" bgcolor=\"#000040\"><tr><th><font size=\"6\">Email Addresses</font></th></tr>";

TCHAR szEmailPageEnd[] =
"<tr><th><font size=\"6\">&nbsp;</font></th></tr></table></center></div></body></html>";

LPTSTR szEmailItem[] =
{
    "<tr><td><div align=\"center\"><center><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td align=\"center\" width=\"250\" bgcolor=\"#F24F00\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#F24F00\">&nbsp;</td></tr><tr><td align=\"center\" width=\"250\" bgcolor=\"#F24F00\"bordercolor=\"#008080\"><font size=\"4\" face=\"Comic Sans MS\">%1</font></td><td width=\"250\" bgcolor=\"#F24F00\"><a href=\"mailto:%2\">%2</a></td></tr><tr><td align=\"center\" width=\"250\" bgcolor=\"#F24F00\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#F24F00\">&nbsp;</td></tr></table></center></div></td></tr>",
    "<tr><td><div align=\"center\"><center><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td align=\"center\" width=\"250\" bgcolor=\"#3A7474\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#3A7474\">&nbsp;</td></tr><tr><td align=\"center\" width=\"250\" bgcolor=\"#3A7474\"bordercolor=\"#008080\"><font size=\"4\" face=\"Comic Sans MS\">%1</font></td><td width=\"250\" bgcolor=\"#3A7474\"><a href=\"mailto:%2\">%2</a></td></tr><tr><td align=\"center\" width=\"250\" bgcolor=\"#3A7474\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#3A7474\">&nbsp;</td></tr></table></center></div></td></tr>"
};

TCHAR szPhonePageHeader[] =
"<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"><title>WAB Phone List</title></head><body bgcolor=\"#A02303\" text=\"#FFFF00\" link=\"#FFFFFF\" vlink=\"#800000\" alink=\"#0000FF\"><div align=\"center\"><center><table border=\"0\" cellspacing=\"1\" width=\"520\" bgcolor=\"#000040\"><tr><th><font size=\"6\">Phone List</font></th></tr><tr><td>&nbsp;</td></tr><tr><td><div align=\"center\"><center><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">";

TCHAR szPhonePageEnd[] =
"</table></center></div></td></tr><tr><td>&nbsp;</td></tr></table></center></div></body></html>";

LPTSTR szPhoneItem[] =
{
"<tr><td align=\"center\" width=\"200\" bgcolor=\"#2B69AE\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#2B69AE\">&nbsp;</td></tr><tr><td align=\"center\" valign=\"top\" width=\"200\" bgcolor=\"#2B69AE\" bordercolor=\"#008080\"><font size=\"4\" face=\"Comic Sans MS\">%1</font></td><td width=\"250\" bgcolor=\"#2B69AE\"><div align=\"left\"><table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" width=\"240\" bordercolor=\"#FFFFFF\" bordercolordark=\"#2B69AE\" bordercolorlight=\"#FFFFFF\"><tr><td width=\"100\">Work:</td><td width=\"130\">%2</td></tr><tr><td width=\"100\">Home:</td><td width=\"130\">%3</td></tr></table></div></td></tr><tr><td align=\"center\" width=\"200\" bgcolor=\"#2B69AE\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#2B69AE\">&nbsp;</td></tr>",
"<tr><td align=\"center\" width=\"200\" bgcolor=\"#F36565\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#F36565\">&nbsp;</td></tr><tr><td align=\"center\" valign=\"top\" width=\"200\" bgcolor=\"#F36565\" bordercolor=\"#008080\"><font size=\"4\" face=\"Comic Sans MS\">%1</font></td><td width=\"250\" bgcolor=\"#F36565\"><div align=\"left\"><table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" width=\"240\" bordercolor=\"#FFFFFF\" bordercolordark=\"#F36565\" bordercolorlight=\"#FFFFFF\"><tr><td width=\"100\">Work:</td><td width=\"130\">%2</td></tr><tr><td width=\"100\">Home:</td><td width=\"130\">%3</td></tr></table></div></td></tr><tr><td align=\"center\" width=\"200\" bgcolor=\"#F36565\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#F36565\">&nbsp;</td></tr>",
};

TCHAR szDetailsPageHeader[] =
"<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">";

TCHAR szDetailsPageMain[] =
"<title>%1</title></head><body bgcolor=\"#A02303\" text=\"#FFFF00\" link=\"#FFFFFF\"vlink=\"#00FF00\"><div align=\"center\"><center><table border=\"1\" cellspacing=\"1\" width=\"520\" bgcolor=\"#000040\"><tr><th><font size=\"6\">%1</font></th></tr><tr><td><div align=\"center\"><center><table border=\"0\"cellspacing=\"1\"><tr>";

TCHAR szEmailAddressesStart[] = 
"<td valign=\"top\" width=\"200\">E-mail Addresses:<div align=\"left\"><table border=\"1\" cellspacing=\"1\" bgcolor=\"#000000\" bordercolor=\"#FF0000\">";

TCHAR szEmailAddressesMiddle[] = 
"<tr><td><font size=\"2\" face=\"Courier New\"><a href=\"mailto:%1\">%1</a></font></td></tr>";

TCHAR szEmailAddressesEnd[] =
"</table></div></td>";

TCHAR szPhoneNumbers[] = 
"<td valign=\"top\" width=\"300\">Phone Numbers:<div align=\"left\"><table border=\"1\" cellspacing=\"1\"bgcolor=\"#000000\" bordercolor=\"#FF0000\"><tr><td><font size=\"2\" face=\"Courier New\">Home:</font></td><td><font size=\"2\" face=\"Courier New\">%2</font></td></tr><tr><td><font size=\"2\" face=\"Courier New\">Home Fax:</font></td><td><font size=\"2\" face=\"Courier New\">%3</font></td></tr><tr><td><font size=\"2\" face=\"Courier New\">Cellular:</font></td><td><font size=\"2\" face=\"Courier New\">%4</font></td></tr><tr><td><font size=\"2\" face=\"Courier New\">Business:</font></td><td><font size=\"2\" face=\"Courier New\">%5</font></td></tr><tr><td><font size=\"2\" face=\"Courier New\">Business-Fax:</font></td><td><font size=\"2\" face=\"Courier New\">%6</font></td></tr><tr><td><font size=\"2\" face=\"Courier New\">Pager:</font></td><td><font size=\"2\" face=\"Courier New\">%7</font></td></tr></table></div></td>";

TCHAR szHomeAddress[] = 
"<td valign=\"top\">&nbsp;</td></tr></table></center></div></td></tr><tr><td><div align=\"center\"><center><table border=\"0\" cellspacing=\"1\"><tr><td valign=\"top\" width=\"200\">Home Address:<address>%8</address><address>%9 %10 %11</address><address>%12 </address></td>";

TCHAR szBusinessAddress[] = 
"<td width=\"200\">Business Address:<address>%13</address><address>%14</address><address>%15</address><address>%16</address><address>%17 %18 %19</address><address>%20</address></td></tr></table></center></div></td></tr>";

TCHAR szURLS[] = 
"<tr><td><ul><li>Personal Home Page: <a href=\"%21\">%21</a></li></ul><ul><li>Business Web Page: <a href=\"%22\">%22</a></li></ul></td></tr>";

TCHAR szNotes[] = 
"<tr><td>Notes: %23</td></tr></table></center></div>";

TCHAR szDetailsPageEnd[] = 
"</body></html>";


TCHAR szBdayHeader[] =
"<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"><meta name=\"GENERATOR\" content=\"Microsoft FrontPage 2.0\"><title>Birthdays</title></head><body bgcolor=\"#A02303\" text=\"#FFFF00\" link=\"#FFFFFF\" vlink=\"#800000\" alink=\"#0000FF\"><div align=\"center\"><center><table border=\"0\" cellspacing=\"1\" width=\"520\" bgcolor=\"#000040\"><tr><th><font color=\"#C0C0C0\" size=\"6\">Birthdays</font></th></tr><tr><td><table border=\"0\" cellspacing=\"1\" width=\"100%\">";

TCHAR szBdayEnd[] =
"</table></td></tr><tr><td>&nbsp;</td></tr></table></center></div></body></html>";

TCHAR szBdaySingleItem[] =
"<tr><td width=\"100\">&nbsp;</td><td align=\"right\" width=\"200\"><ul><li><p align=\"left\"><font size=\"4\" face=\"Comic Sans MS\">%2</font></p></li></ul></td><td align=\"right\" width=\"100\"><p align=\"center\"><font size=\"4\" face=\"Comic Sans MS\"><em>%1</em></font></p></td></tr>";

LPTSTR szBdayMonthItemStart[] =
{
    "<tr><td width=\"250\" bgcolor=\"#2B69AE\"><blockquote><h1><font color=\"#80FFFF\" size=\"5\" face=\"Comic Sans MS\">%1</font></h1></blockquote><div align=\"center\"><center><table border=\"0\" cellspacing=\"1\" width=\"400\">",
    "<tr><td width=\"250\" bgcolor=\"#77943A\"><blockquote><h1><font color=\"#80FFFF\" size=\"5\" face=\"Comic Sans MS\">%1</font></h1></blockquote><div align=\"center\"><center><table border=\"0\" cellspacing=\"1\" width=\"400\">",
};

TCHAR szBdayMonthItemEnd[]=
"</table></center></div></td></tr><tr><td>&nbsp;</td></tr>";

const LPTSTR szMonth[] = 
{
    "January", "February", "March", "April", "May", "June", 
    "July", "August", "September", "October", "November", "December"
};


/*********************************************************************************************************/


// contructor
CWAB::CWAB()
{
    // Here we load the WAB Object and initialize it
    m_bInitialized = FALSE;

    {
        TCHAR  szWABDllPath[MAX_PATH];

        DWORD  dwType = 0;
        ULONG  cbData = sizeof(szWABDllPath);
        HKEY hKey = NULL;

        *szWABDllPath = '\0';
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
            RegQueryValueEx( hKey, "", NULL, &dwType, (LPBYTE) szWABDllPath, &cbData);

        if(hKey) RegCloseKey(hKey);

        m_hinstWAB = LoadLibrary( (lstrlen(szWABDllPath)) ? szWABDllPath : WAB_DLL_NAME );
    }

    if(m_hinstWAB)
        m_lpfnWABOpen = (LPWABOPEN) GetProcAddress(m_hinstWAB, "WABOpen");

    if(m_lpfnWABOpen)
    {
        HRESULT hr = E_FAIL;
        hr = m_lpfnWABOpen(&m_lpAdrBook,&m_lpWABObject,NULL,0);
        if(!hr)
            m_bInitialized = TRUE;
    }

}


CWAB::~CWAB()
{
    if(m_bInitialized)
    {
        if(m_lpAdrBook)
            m_lpAdrBook->Release();

        if(m_lpWABObject)
            m_lpWABObject->Release();

        if(m_hinstWAB)
            FreeLibrary(m_hinstWAB);
    }
}


void CWAB::ClearWABLVContents(CListCtrl * pListView)
{
    int i;
    int nCount = pListView->GetItemCount();
    
    if(nCount<=0)
        return;

    for(i=0;i<nCount;i++)
    {
        LV_ITEM lvi ={0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = i;
        lvi.iSubItem = 0;
        pListView->GetItem(&lvi);
        if(lvi.lParam)
        {
            LPSBinary lpSB = (LPSBinary) lvi.lParam;
            m_lpWABObject->FreeBuffer(lpSB);
        }
    }

    pListView->DeleteAllItems();
}


HRESULT CWAB::LoadWABContents(CListCtrl * pListView)
{
    ULONG ulObjType =   0;
	LPMAPITABLE lpAB =  NULL;
    LPTSTR * lppszArray=NULL;
    ULONG cRows =       0;
    LPSRowSet lpRow =   NULL;
	LPSRowSet lpRowAB = NULL;
    LPABCONT  lpContainer = NULL;
    
    HRESULT hr = E_FAIL;

    ULONG lpcbEID;
	LPENTRYID lpEID = NULL;

    hr = m_lpAdrBook->GetPAB( &lpcbEID, &lpEID);

	ulObjType = 0;

    hr = m_lpAdrBook->OpenEntry(lpcbEID,
					    		(LPENTRYID)lpEID,
						    	NULL,
							    0,
							    &ulObjType,
							    (LPUNKNOWN *)&lpContainer);

	m_lpWABObject->FreeBuffer(lpEID);

	lpEID = NULL;
		
    hr = lpContainer->GetContentsTable( 0,
            							&lpAB);


	if ( SUCCEEDED(hr) )
		hr =lpAB->SetColumns( (LPSPropTagArray)&ptaEid, 0 );

	if ( SUCCEEDED(hr) )
		hr = lpAB->SeekRow( BOOKMARK_BEGINNING, 0, NULL );


	int cNumRows = 0;
    int nRows=0;



	do {

		if ( SUCCEEDED(hr) )
			hr = lpAB->QueryRows(1,	0, &lpRowAB);

        if(lpRowAB)
        {
            cNumRows = lpRowAB->cRows;

		    if ( SUCCEEDED(hr) && cNumRows)
		    {
                LPTSTR lpsz = lpRowAB->aRow[0].lpProps[ieidPR_DISPLAY_NAME].Value.lpszA;
                LPENTRYID lpEID = (LPENTRYID) lpRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
                ULONG cbEID = lpRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;

                if(lpRowAB->aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)
                {
                    LPSBinary lpSB = NULL;

                    m_lpWABObject->AllocateBuffer(sizeof(SBinary), (LPVOID *) &lpSB);
                
                    if(lpSB)
                    {
                        m_lpWABObject->AllocateMore(cbEID, lpSB, (LPVOID *) &(lpSB->lpb));

                        if(!lpSB->lpb)
                        {
                            m_lpWABObject->FreeBuffer(lpSB);
                            continue;
                        }
                    
                        CopyMemory(lpSB->lpb, lpEID, cbEID);
                        lpSB->cb = cbEID;

                        LV_ITEM lvi = {0};
                        lvi.mask = LVIF_TEXT | LVIF_PARAM;
                        lvi.iItem = pListView->GetItemCount();
                        lvi.iSubItem = 0;
                        lvi.pszText = lpsz;
                        lvi.lParam = (LPARAM) lpSB;

                        // Now add this item to the list view
                        pListView->InsertItem(&lvi);
                    }
                }
		    }
		    FreeProws(lpRowAB );		
        }

	}while ( SUCCEEDED(hr) && cNumRows && lpRowAB)  ;

	if ( lpContainer )
		lpContainer->Release();

	if ( lpAB )
		lpAB->Release();

    return hr;
}

BOOL CWAB::CreatePhoneListFileFromWAB(LPTSTR szFileName)
{
    BOOL bRet = FALSE;
    ULONG ulObjType =   0;
	LPMAPITABLE lpAB =  NULL;
    LPTSTR * lppszArray=NULL;
    ULONG cRows =       0;
    LPSRowSet lpRow =   NULL;
	LPSRowSet lpRowAB = NULL;
    LPABCONT  lpContainer = NULL;
    
    HRESULT hr = E_FAIL;

    ULONG lpcbEID;
	LPENTRYID lpEID = NULL;

    TCHAR szDir[MAX_PATH];

    GetTempPath(MAX_PATH, szDir);

    lstrcpy(szFileName, szDir);
    lstrcat(szFileName, "temp.htm");

    hr = m_lpAdrBook->GetPAB( &lpcbEID, &lpEID);

	ulObjType = 0;

    hr = m_lpAdrBook->OpenEntry(lpcbEID,
					    		(LPENTRYID)lpEID,
						    	NULL,
							    0,
							    &ulObjType,
							    (LPUNKNOWN *)&lpContainer);

	m_lpWABObject->FreeBuffer(lpEID);

	lpEID = NULL;
		
    hr = lpContainer->GetContentsTable( 0,
            							&lpAB);


	if ( SUCCEEDED(hr) )
		hr =lpAB->SetColumns( (LPSPropTagArray)&ptaPhone, 0 );

	if ( SUCCEEDED(hr) )
		hr = lpAB->SeekRow( BOOKMARK_BEGINNING, 0, NULL );


	int cNumRows = 0;
    int nRows=0;

    HANDLE hFile = NULL;
    DWORD dw;
    hFile = CreateFile( szFileName,
                          GENERIC_WRITE,	
                          0,    // sharing
                          NULL,
                          CREATE_ALWAYS,
                          FILE_FLAG_SEQUENTIAL_SCAN,	
                          NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        WriteFile(  hFile,
                    (LPCVOID) szPhonePageHeader,
                    (DWORD) lstrlen(szPhonePageHeader),
                    &dw,
                    NULL);
    }

    int nType = 0;

	do {

		if ( SUCCEEDED(hr) )
			hr = lpAB->QueryRows(1,	0, &lpRowAB);

        if(lpRowAB)
        {
            cNumRows = lpRowAB->cRows;
            LPTSTR sz[iphoneMax];

		    if ( SUCCEEDED(hr) && cNumRows)
		    {

                int i;
                for(i=0;i<iphoneMax-2;i++)
                {
                    sz[i] = lpRowAB->aRow[0].lpProps[i].Value.lpszA;
                    if(!sz[i] || !lstrlen(sz[i]))
                        sz[i] = TEXT("&nbsp;");
                }


                if(lpRowAB->aRow[0].lpProps[iphonePR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)
                {
                    LPTSTR lpPhoneItem =NULL;

                    FormatMessage(  FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    szPhoneItem[nType],
                                    0, 0, //ignored
                                    (LPTSTR) &lpPhoneItem, 0,
                                    (va_list *)sz);
                    nType = 1- nType;

                    if(lpPhoneItem)
                    {
                        if(hFile != INVALID_HANDLE_VALUE)
                        {
                            WriteFile(  hFile,
                                        (LPCVOID) lpPhoneItem,
                                        (DWORD) lstrlen(lpPhoneItem),
                                        &dw,
                                        NULL);
                        }

                        LocalFree(lpPhoneItem);
                    }
                }
		    }
		    FreeProws(lpRowAB );		
        }

	}while ( SUCCEEDED(hr) && cNumRows && lpRowAB)  ;

    if(hFile != INVALID_HANDLE_VALUE)
    {
        WriteFile(  hFile,
                    (LPCVOID) szPhonePageEnd,
                    (DWORD) lstrlen(szPhonePageEnd),
                    &dw,
                    NULL);
        CloseHandle(hFile);
    }

    if ( lpContainer )
		lpContainer->Release();

	if ( lpAB )
		lpAB->Release();

    return bRet;
}

BOOL CWAB::CreateEmailListFileFromWAB(LPTSTR szFileName)
{
    BOOL bRet = FALSE;
    ULONG ulObjType =   0;
	LPMAPITABLE lpAB =  NULL;
    LPTSTR * lppszArray=NULL;
    ULONG cRows =       0;
    LPSRowSet lpRow =   NULL;
	LPSRowSet lpRowAB = NULL;
    LPABCONT  lpContainer = NULL;
    
    HRESULT hr = E_FAIL;

    ULONG lpcbEID;
	LPENTRYID lpEID = NULL;

    TCHAR szDir[MAX_PATH];

    GetTempPath(MAX_PATH, szDir);

    lstrcpy(szFileName, szDir);
    lstrcat(szFileName, "temp.htm");

    hr = m_lpAdrBook->GetPAB( &lpcbEID, &lpEID);

	ulObjType = 0;

    hr = m_lpAdrBook->OpenEntry(lpcbEID,
					    		(LPENTRYID)lpEID,
						    	NULL,
							    0,
							    &ulObjType,
							    (LPUNKNOWN *)&lpContainer);

	m_lpWABObject->FreeBuffer(lpEID);

	lpEID = NULL;
		
    hr = lpContainer->GetContentsTable( 0,
            							&lpAB);


	if ( SUCCEEDED(hr) )
		hr =lpAB->SetColumns( (LPSPropTagArray)&ptaEmail, 0 );

	if ( SUCCEEDED(hr) )
		hr = lpAB->SeekRow( BOOKMARK_BEGINNING, 0, NULL );


	int cNumRows = 0;
    int nRows=0;

    HANDLE hFile = NULL;
    DWORD dw;
    hFile = CreateFile( szFileName,
                          GENERIC_WRITE,	
                          0,    // sharing
                          NULL,
                          CREATE_ALWAYS,
                          FILE_FLAG_SEQUENTIAL_SCAN,	
                          NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        WriteFile(  hFile,
                    (LPCVOID) szEmailPageHeader,
                    (DWORD) lstrlen(szEmailPageHeader),
                    &dw,
                    NULL);
    }

    int nType = 0;

	do {

		if ( SUCCEEDED(hr) )
			hr = lpAB->QueryRows(1,	0, &lpRowAB);

        if(lpRowAB)
        {
            cNumRows = lpRowAB->cRows;
            LPTSTR sz[2];

		    if ( SUCCEEDED(hr) && cNumRows)
		    {
                sz[0] = lpRowAB->aRow[0].lpProps[iemailPR_DISPLAY_NAME].Value.lpszA;
                sz[1] = lpRowAB->aRow[0].lpProps[iemailPR_EMAIL_ADDRESS].Value.lpszA;

                if(!sz[1] || !lstrlen(sz[1]))
                    sz[1] = "No E-mail";

                if(lpRowAB->aRow[0].lpProps[iemailPR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)
                {
                    LPTSTR lpEmailItem =NULL;

                    FormatMessage(  FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    szEmailItem[nType],
                                    0, 0, //ignored
                                    (LPTSTR) &lpEmailItem, 0,
                                    (va_list *)sz);
                    nType = 1- nType;

                    if(lpEmailItem)
                    {
                        if(hFile != INVALID_HANDLE_VALUE)
                        {
                            WriteFile(  hFile,
                                        (LPCVOID) lpEmailItem,
                                        (DWORD) lstrlen(lpEmailItem),
                                        &dw,
                                        NULL);
                        }

                        LocalFree(lpEmailItem);
                    }
                }
		    }
		    FreeProws(lpRowAB );		
        }

	}while ( SUCCEEDED(hr) && cNumRows && lpRowAB)  ;

    if(hFile != INVALID_HANDLE_VALUE)
    {
        WriteFile(  hFile,
                    (LPCVOID) szEmailPageEnd,
                    (DWORD) lstrlen(szEmailPageEnd),
                    &dw,
                    NULL);
        CloseHandle(hFile);
    }

    if ( lpContainer )
		lpContainer->Release();

	if ( lpAB )
		lpAB->Release();

    return bRet;
}

BOOL CWAB::CreateBirthdayFileFromWAB(LPTSTR szFileName)
{
    BOOL bRet = FALSE;
    ULONG ulObjType =   0;
	LPMAPITABLE lpAB =  NULL;
    LPTSTR * lppszArray=NULL;
    ULONG cRows =       0;
    LPSRowSet lpRow =   NULL;
	LPSRowSet lpRowAB = NULL;
    LPABCONT  lpContainer = NULL;
    
    HRESULT hr = E_FAIL;

    ULONG lpcbEID;
	LPENTRYID lpEID = NULL;

    TCHAR szDir[MAX_PATH];

    GetTempPath(MAX_PATH, szDir);

    lstrcpy(szFileName, szDir);
    lstrcat(szFileName, "temp.htm");

    hr = m_lpAdrBook->GetPAB( &lpcbEID, &lpEID);

	ulObjType = 0;

    hr = m_lpAdrBook->OpenEntry(lpcbEID,
					    		(LPENTRYID)lpEID,
						    	NULL,
							    0,
							    &ulObjType,
							    (LPUNKNOWN *)&lpContainer);

	m_lpWABObject->FreeBuffer(lpEID);

	lpEID = NULL;
		
    hr = lpContainer->GetContentsTable( 0,
            							&lpAB);


	if ( SUCCEEDED(hr) )
		hr =lpAB->SetColumns( (LPSPropTagArray)&ptaBday, 0 );


	int cNumRows = 0;
    int nRows=0;

    HANDLE hFile = NULL;
    DWORD dw;
    hFile = CreateFile( szFileName,
                          GENERIC_WRITE,	
                          0,    // sharing
                          NULL,
                          CREATE_ALWAYS,
                          FILE_FLAG_SEQUENTIAL_SCAN,	
                          NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        WriteFile(  hFile,
                    (LPCVOID) szBdayHeader,
                    (DWORD) lstrlen(szBdayHeader),
                    &dw,
                    NULL);
    }

    int nType = 0;
    int LastMonth = 0;
    BOOL bMonthSet = FALSE;

    for(LastMonth=1;LastMonth<=12;LastMonth++)
    {
        bMonthSet = FALSE;
        if ( SUCCEEDED(hr) )
	        hr = lpAB->SeekRow( BOOKMARK_BEGINNING, 0, NULL );


	do {

		if ( SUCCEEDED(hr) )
			hr = lpAB->QueryRows(1,	0, &lpRowAB);

        if(lpRowAB)
        {
            cNumRows = lpRowAB->cRows;

		    if ( SUCCEEDED(hr) && cNumRows)
		    {

                if( lpRowAB->aRow[0].lpProps[ibdayPR_BIRTHDAY].ulPropTag == PR_BIRTHDAY &&
                    lpRowAB->aRow[0].lpProps[ibdayPR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)
                {
                    FILETIME ft = lpRowAB->aRow[0].lpProps[ibdayPR_BIRTHDAY].Value.ft;
                    SYSTEMTIME st;

                    FileTimeToSystemTime(&ft, &st);

                    if(st.wMonth == LastMonth)
                    {
                        if(bMonthSet == FALSE)
                        {

                            nType = 1- nType;

                            LPTSTR lpMonthItem =NULL;

                            FormatMessage(  FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                            szBdayMonthItemStart[nType],
                                            0, 0, //ignored
                                            (LPTSTR) &lpMonthItem, 0,
                                            (va_list *)&szMonth[LastMonth-1]);

                            if(lpMonthItem)
                            {
                                if(hFile != INVALID_HANDLE_VALUE)
                                {
                                    WriteFile(  hFile,
                                                (LPCVOID) lpMonthItem,
                                                (DWORD) lstrlen(lpMonthItem),
                                                &dw,
                                                NULL);
                                }
                                LocalFree(lpMonthItem);
                            }
                            bMonthSet = TRUE;
                        }

                        LPTSTR lpBdayItem = NULL;
                        LPTSTR sz[2];
                        TCHAR szDate[256];
                        wsprintf(szDate,"%d",st.wDay);
                        sz[0] = szDate;
                        sz[1] = lpRowAB->aRow[0].lpProps[ibdayPR_DISPLAY_NAME].Value.LPSZ;

                        FormatMessage(  FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        szBdaySingleItem,
                                        0, 0, //ignored
                                        (LPTSTR) &lpBdayItem, 0,
                                        (va_list *)sz);

                        if(lpBdayItem)
                        {
                            if(hFile != INVALID_HANDLE_VALUE)
                            {
                                WriteFile(  hFile,
                                            (LPCVOID) lpBdayItem,
                                            (DWORD) lstrlen(lpBdayItem),
                                            &dw,
                                            NULL);
                            }
                            LocalFree(lpBdayItem);
                        }
                    }

                }
		    }
		    FreeProws(lpRowAB );		
        }

	}while ( SUCCEEDED(hr) && cNumRows && lpRowAB)  ;

        if(bMonthSet)
        {
            if(hFile != INVALID_HANDLE_VALUE)
            {
                WriteFile(  hFile,
                            (LPCVOID) szBdayMonthItemEnd,
                            (DWORD) lstrlen(szBdayMonthItemEnd),
                            &dw,
                            NULL);
            }
        }

    }//for

    if(hFile != INVALID_HANDLE_VALUE)
    {
        if(LastMonth > 0)
        {
            WriteFile(  hFile,
                        (LPCVOID) szBdayMonthItemEnd,
                        (DWORD) lstrlen(szBdayMonthItemEnd),
                        &dw,
                        NULL);
        }
        WriteFile(  hFile,
                    (LPCVOID) szBdayEnd,
                    (DWORD) lstrlen(szBdayEnd),
                    &dw,
                    NULL);
        CloseHandle(hFile);
    }

    if ( lpContainer )
		lpContainer->Release();

	if ( lpAB )
		lpAB->Release();

    return bRet;
}

BOOL CWAB::CreateDetailsFileFromWAB(CListCtrl * pListView, LPTSTR szFileName)
{
    BOOL bRet = FALSE;
    TCHAR szDir[MAX_PATH];
    LV_ITEM lvi = {0};
    LPMAILUSER lpMailUser = NULL;
    ULONG ulcProps;
    LPSPropValue lpPropArray = NULL;

    if(!szFileName)
        goto out;

    *szFileName = '\0';

    if(!m_bDetailsOn) // This is not a details view
        goto out;
 
    // Get the Selected Item from the listview
    lvi.mask = LVIF_PARAM;
    lvi.iItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(lvi.iItem == -1)
        goto out;

    lvi.iSubItem = 0;
 

    GetTempPath(MAX_PATH, szDir);

    lstrcpy(szFileName, szDir);
    lstrcat(szFileName, "temp.htm");

    pListView->GetItem(&lvi);

    if(lvi.lParam)
    {
        LPSBinary lpSB = (LPSBinary) lvi.lParam;
        ULONG ulObjType;
        HRESULT hr = E_FAIL;

        hr = m_lpAdrBook->OpenEntry(lpSB->cb,
                                   (LPENTRYID) lpSB->lpb,
                                  NULL,         // interface
                                  0,            // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpMailUser);

        if(hr || !lpMailUser)
            goto out;

        lpMailUser->GetProps(NULL, 0, &ulcProps, &lpPropArray);

        if(lpPropArray)
        {
            LPTSTR lpsz[ulPropsMax];
            LPTSTR szEmpty = "";
            ULONG i,j,nEmail = -1;
            for(i=0;i<ulPropsMax;i++)
            {
                lpsz[i] = szEmpty;
                for(j=0;j<ulcProps;j++)
                {
                    if(lpPropArray[j].ulPropTag == ulProps[i])
                    {
                        lpsz[i] = lpPropArray[j].Value.LPSZ;
                        break;
                    }
                }
            }

            LPTSTR lp[pPartsMax];
            LPTSTR lpTemplate[pPartsMax];
            LPTSTR lpFile;

            lpTemplate[pMain] = (LPTSTR) szDetailsPageMain;
            lpTemplate[pPhone] = (LPTSTR) szPhoneNumbers;
            lpTemplate[pHome] = (LPTSTR) szHomeAddress;
            lpTemplate[pBusiness] = (LPTSTR) szBusinessAddress;
            lpTemplate[pURLS] = (LPTSTR) szURLS;
            lpTemplate[pNotes] = (LPTSTR) szNotes;
            lpTemplate[pEnd] = (LPTSTR) szDetailsPageEnd;
            lpTemplate[pEmail] = NULL;

            for(i=0;i<pPartsMax;i++)
                lp[i]=NULL;

            for(i=0;i<pPartsMax;i++)
            {
                if(i!=pEmail)
                {
                    // use format message to create the various message components
                    FormatMessage(  FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    lpTemplate[i],
                                    0, 0, //ignored
                                    (LPTSTR) &(lp[i]), 0,
                                    (va_list *)lpsz);
                }
            }

            for(j=0;j<ulcProps;j++)
            {
                if(lpPropArray[j].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES)
                {
                    nEmail = j;
                    break;
                }
            }
            // Get the email addresses
            if(nEmail != -1)
            {
                int nCount = lpPropArray[nEmail].Value.MVSZ.cValues;
                LPTSTR lpEmail[10];
                if(nCount>10)
                    nCount = 10;

                {
                    int i, nLen = 0;
                    for(i=0;i<nCount;i++)
                    {
                        lpEmail[i] = szEmpty;
                        if(lstrlen(lpPropArray[nEmail].Value.MVSZ.LPPSZ[i]))
                        {
                            // use format message to create the various message components
                            FormatMessage(  FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                            szEmailAddressesMiddle,
                                            0, 0, //ignored
                                            (LPTSTR) &(lpEmail[i]), 0,
                                            (va_list *)&(lpPropArray[nEmail].Value.MVSZ.LPPSZ[i]));
                            nLen += lstrlen(lpEmail[i]);
                        }
                    }
                    nLen+= lstrlen(szEmailAddressesStart);
                    nLen+= lstrlen(szEmailAddressesEnd);
                    nLen++;

                    lp[pEmail] = (LPTSTR) LocalAlloc(LMEM_ZEROINIT, nLen);
                    if(lp[pEmail])
                    {
                        lstrcpy(lp[pEmail], szEmpty);
                        lstrcat(lp[pEmail], szEmailAddressesStart);
                        for(i=0;i<nCount;i++)
                            lstrcat(lp[pEmail], lpEmail[i]);
                        lstrcat(lp[pEmail], szEmailAddressesEnd);
                    }

                    for(i=0;i<nCount;i++)
                        LocalFree(lpEmail[i]);
                }
            }
            else
            {
                // Didnt find CONTACT_EMAIL_ADDRESSES .. just look for email address
                for(j=0;j<ulcProps;j++)
                {
                    if(lpPropArray[j].ulPropTag == PR_EMAIL_ADDRESS)
                    {
                        nEmail = j;
                        break;
                    }
                }
                if(nEmail!= -1)
                {
                    LPTSTR lpEmail = NULL;
                    int nLen = 0;
                    
                    FormatMessage(  FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    szEmailAddressesMiddle,
                                    0, 0, //ignored
                                    (LPTSTR) &(lpEmail), 0,
                                    (va_list *)&(lpPropArray[nEmail].Value.LPSZ));

                    nLen += lstrlen(lpEmail);
                    nLen+= lstrlen(szEmailAddressesStart);
                    nLen+= lstrlen(szEmailAddressesEnd);
                    nLen++;

                    lp[pEmail] = (LPTSTR) LocalAlloc(LMEM_ZEROINIT, nLen);
                    if(lp[pEmail])
                    {
                        lstrcpy(lp[pEmail], szEmpty);
                        lstrcat(lp[pEmail], szEmailAddressesStart);
                        lstrcat(lp[pEmail], lpEmail);
                        lstrcat(lp[pEmail], szEmailAddressesEnd);
                    }
                    if(lpEmail)
                        LocalFree(lpEmail);
                }

            }

            int nLen = 0;
            for(i=0;i<pPartsMax;i++)
            {
                if(lp[i])
                    nLen += lstrlen(lp[i]);
            }

            nLen++;

            lpFile = (LPTSTR) LocalAlloc(LMEM_ZEROINIT, nLen);
            if(lpFile)
            {
                lstrcpy(lpFile, szEmpty);
                for(i=0;i<pPartsMax;i++)
                {
                    if(lp[i])
                        lstrcat(lpFile,lp[i]);
                }

                HANDLE hFile = NULL;
                if (INVALID_HANDLE_VALUE != (hFile = CreateFile( szFileName,
                                                      GENERIC_WRITE,	
                                                      0,    // sharing
                                                      NULL,
                                                      CREATE_ALWAYS,
                                                      FILE_FLAG_SEQUENTIAL_SCAN,	
                                                      NULL)))
                {
                    DWORD dw;
                    WriteFile(  hFile,
                                (LPCVOID) lpFile,
                                (DWORD) lstrlen(lpFile)+1,
                                &dw,
                                NULL);
                    CloseHandle(hFile);

                }

                LocalFree(lpFile);
            }

            for(i=0;i<pPartsMax;i++)
            {
                if(lp[i])
                    LocalFree(lp[i]);
            }

        }
    }

    bRet = TRUE;

out:
    if(lpPropArray)
        m_lpWABObject->FreeBuffer(lpPropArray);

    if(lpMailUser)
        lpMailUser->Release();

    return bRet;
}


void CWAB::FreeProws(LPSRowSet prows)
{
	ULONG		irow;
	if (!prows)
		return;
	for (irow = 0; irow < prows->cRows; ++irow)
		m_lpWABObject->FreeBuffer(prows->aRow[irow].lpProps);
	m_lpWABObject->FreeBuffer(prows);
}

void CWAB::SetDetailsOn(BOOL bOn)
{
    m_bDetailsOn = bOn;
}


void CWAB::ShowSelectedItemDetails(HWND hWndParent, CListCtrl * pListView)
{
    HRESULT hr = S_OK;

    LV_ITEM lvi = {0};

    // Get the Selected Item from the listview
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(lvi.iItem == -1)
        return;

    pListView->GetItem(&lvi);

    if(lvi.lParam)
    {
        HWND hWnd = NULL;
        LPSBinary lpSB = (LPSBinary) lvi.lParam;
        hr = m_lpAdrBook->Details(  (LPULONG) &hWnd,            // ulUIParam
					        		NULL,
							        NULL,
								    lpSB->cb,
								    (LPENTRYID) lpSB->lpb,
								    NULL,
								    NULL,
								    NULL,
								    0);

        if(hr)
        {
            TCHAR sz[MAX_PATH];
            wsprintf(sz, "Error: %x GetLastError: %d\n",hr, GetLastError());
            OutputDebugString(sz);
        }

    }

    return;

}

BOOL CWAB::GetSelectedItemBirthday(CListCtrl * pListView, SYSTEMTIME * lpst)
{
    BOOL bRet = FALSE;

    LV_ITEM lvi = {0};
    // Get the Selected Item from the listview
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(lvi.iItem == -1)
        goto out;

    pListView->GetItem(&lvi);

    if(lvi.lParam)
    {
        LPMAILUSER lpMailUser = NULL;
        LPSBinary lpSB = (LPSBinary) lvi.lParam;
        ULONG ulObjType = 0;

        m_lpAdrBook->OpenEntry(lpSB->cb,
                               (LPENTRYID) lpSB->lpb,
                              NULL,         // interface
                              0,            // flags
                              &ulObjType,
                              (LPUNKNOWN *)&lpMailUser);

        if(lpMailUser)
        {
            ULONG cProps;
            LPSPropValue lpPropArray = NULL;
            SizedSPropTagArray(1, ptaBday) =
            {
                1,
                { PR_BIRTHDAY }
            };

            lpMailUser->GetProps((LPSPropTagArray) &ptaBday, 0, &cProps, &lpPropArray);

            if(lpPropArray)
            {
                if(lpPropArray[0].ulPropTag == PR_BIRTHDAY)
                {
                    FILETIME ft = lpPropArray[0].Value.ft;
                    if(FileTimeToSystemTime(&ft, lpst))
                    {
                        bRet = TRUE;
                    }
                }
                m_lpWABObject->FreeBuffer(lpPropArray);
            }

            lpMailUser->Release();
        }
                              

    }
out:
    return bRet;
}

void CWAB::SetSelectedItemBirthday(CListCtrl * pListView, SYSTEMTIME st)
{

    LV_ITEM lvi = {0};
    // Get the Selected Item from the listview
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(lvi.iItem == -1)
        goto out;

    pListView->GetItem(&lvi);

    if(lvi.lParam)
    {
        LPMAILUSER lpMailUser = NULL;
        LPSBinary lpSB = (LPSBinary) lvi.lParam;
        ULONG ulObjType = 0;

        m_lpAdrBook->OpenEntry(lpSB->cb,
                               (LPENTRYID) lpSB->lpb,
                              NULL,         // interface
                              MAPI_MODIFY,            // flags
                              &ulObjType,
                              (LPUNKNOWN *)&lpMailUser);
        if(lpMailUser)
        {
            ULONG cProps;
            SPropValue PropArray = {0};

            cProps = 1;
            PropArray.ulPropTag = PR_BIRTHDAY;

            FILETIME ft;
            if(SystemTimeToFileTime(&st, &ft))
            {
                PropArray.Value.ft = ft;

                if(S_OK == lpMailUser->SetProps(cProps, &PropArray, NULL))
                {
                    lpMailUser->SaveChanges(KEEP_OPEN_READWRITE);
                }
            }
            lpMailUser->Release();
        }
                              

    }
out:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabapp\webbrwsr.h ===
#if !defined(AFX_WEBBROWSER2_H__8E0170B0_D226_11D0_9A48_00A0C91F9C8B__INCLUDED_)
#define AFX_WEBBROWSER2_H__8E0170B0_D226_11D0_9A48_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser wrapper class

class CWebBrowser : public CWnd
{
protected:
	DECLARE_DYNCREATE(CWebBrowser)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x8856f961, 0x340a, 0x11d0, { 0xa9, 0x6b, 0x0, 0xc0, 0x4f, 0xd7, 0x5, 0xa2 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	void GoBack();
	void GoForward();
	void GoHome();
	void GoSearch();
	void Navigate(LPCTSTR URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers);
	void Refresh();
	void Refresh2(VARIANT* Level);
	void Stop();
	LPDISPATCH GetApplication();
	LPDISPATCH GetParent();
	LPDISPATCH GetContainer();
	LPDISPATCH GetDocument();
	BOOL GetTopLevelContainer();
	CString GetType();
	long GetLeft();
	void SetLeft(long nNewValue);
	long GetTop();
	void SetTop(long nNewValue);
	long GetWidth();
	void SetWidth(long nNewValue);
	long GetHeight();
	void SetHeight(long nNewValue);
	CString GetLocationName();
	CString GetLocationURL();
	BOOL GetBusy();
	void Quit();
	void ClientToWindow(long* pcx, long* pcy);
	void PutProperty(LPCTSTR szProperty, const VARIANT& vtValue);
	VARIANT GetProperty_(LPCTSTR szProperty);
	CString GetName();
	long GetHwnd();
	CString GetFullName();
	CString GetPath();
	BOOL GetVisible();
	void SetVisible(BOOL bNewValue);
	BOOL GetStatusBar();
	void SetStatusBar(BOOL bNewValue);
	CString GetStatusText();
	void SetStatusText(LPCTSTR lpszNewValue);
	long GetToolBar();
	void SetToolBar(long nNewValue);
	BOOL GetMenuBar();
	void SetMenuBar(BOOL bNewValue);
	BOOL GetFullScreen();
	void SetFullScreen(BOOL bNewValue);
	void Navigate2(VARIANT* URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers);
	long QueryStatusWB(long cmdID);
	void ExecWB(long cmdID, long cmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut);
	void ShowBrowserBar(VARIANT* pvaClsid, VARIANT* pvarShow, VARIANT* pvarSize);
	long GetReadyState();
	BOOL GetOffline();
	void SetOffline(BOOL bNewValue);
	BOOL GetSilent();
	void SetSilent(BOOL bNewValue);
	BOOL GetRegisterAsBrowser();
	void SetRegisterAsBrowser(BOOL bNewValue);
	BOOL GetRegisterAsDropTarget();
	void SetRegisterAsDropTarget(BOOL bNewValue);
	BOOL GetTheaterMode();
	void SetTheaterMode(BOOL bNewValue);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WEBBROWSER2_H__8E0170B0_D226_11D0_9A48_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define IDI_ICON1                       101
#define IDD_PROP2                       103
#define IDD_PROP                        104
#define IDC_EXT_EDIT_HOME               1000
#define IDC_EXT_EDIT_TEAM               1002
#define IDC_STATIC_NAME                 1004
#define IDC_BUTTON1                     1006
#define IDC_BUTTON2                     1007
#define IDC_BUTTON3                     1008
#define IDC_BUTTON4                     1009
#define IDC_BUTTON5                     1010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtests\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pabtest.rc
//
#define IDR_MENU1                       102
#define IDD_INIFILE                     104
#define IDC_EDIT                        1000
#define IDC_LIST2                       1002
#define IDM_HELP                        65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtests\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef REZ  // Mac resource compiler (mrc) defines REZ
#define RC_INVOKED
#endif

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// Tab Control styles
#ifndef TCS_MULTILINE // new in later versions of Win32
#define TCS_MULTILINE       0x0200
#endif

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0xFFFFL


// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
	// -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#ifdef _MAC
#define AFX_IDS_ABOUT                   0xF010
#endif
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2A0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2A0
#define AFX_IDP_DAO_DFX_BIND                    0xF2A1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2A2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2A3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2A4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2A5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE				0xF2D1
#define AFX_IDS_HTTP_NO_TEXT			0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST		0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED		0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN			0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND			0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR		0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED	0xF2D8


/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723
#ifdef _MAC
#define AFX_IDD_PREVIEW_SHORTTOOLBAR    30731
#endif

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7





#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtests\wabguid.c ===
// This builds mapiguid.obj, which can be linked into a DLL
// or EXE to provide the MAPI GUIDs. It contains all GUIDs
// defined by MAPI.


#define USES_IID_IUnknown
#define USES_IID_IMAPIUnknown
#define USES_IID_IMAPITable
#define USES_IID_INotifObj
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPIStatus
#define USES_IID_IAddrBook
#define USES_IID_IMailUser
#define USES_IID_IMAPIContainer
#define USES_IID_IABContainer
#define USES_IID_IDistList
#define USES_IID_IMAPITableData

#define USES_PS_MAPI
#define USES_PS_PUBLIC_STRINGS


#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#define INITGUID
//#include "_apipch.h"

#include <windows.h>
#include <windowsx.h>
#include <limits.h>
#include <memory.h>
#include <commdlg.h>
#include <stdio.h>
#include <string.h>
#include <mbstring.h>
#include <time.h>
#include <math.h>

//
// MAPI headers
//
#include <mapiwin.h>
#include <mapidefs.h>
#include <mapicode.h>
#include <mapitags.h>
#include <mapiguid.h>
//#include <mapispi.h>
#include <mapiutil.h>
#include <mapival.h>
#include <mapix.h>
#include <mapiutil.h>
#include <unknwn.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtests\bin.c ===
/***************************************************************************

    Name      : DebugBinary

    Purpose   : Debug dump an array of bytes

    Parameters: cb = number of bytes to dump
                lpb -> bytes to dump

    Returns   : none

    Comment   :

***************************************************************************/
#define DEBUG_NUM_BINARY_LINES  2
VOID DebugBinary(UINT cb, LPBYTE lpb) {
    UINT cbLines = 0;

#if (DEBUG_NUM_BINARY_LINES != 0)
    UINT cbi;

    while (cb && cbLines < DEBUG_NUM_BINARY_LINES) {
        cbi = min(cb, 16);
        cb -= cbi;

        switch (cbi) {
            case 16:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14],
                  lpb[15]);
                break;
            case 1:
                DebugTrace("%02x\n", lpb[0]);
                break;
            case 2:
                DebugTrace("%02x %02x\n", lpb[0], lpb[1]);
                break;
            case 3:
                DebugTrace("%02x %02x %02x\n", lpb[0], lpb[1], lpb[2]);
                break;
            case 4:
                DebugTrace("%02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3]);
                break;
            case 5:
                DebugTrace("%02x %02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3],
                  lpb[4]);
                break;
            case 6:
                DebugTrace("%02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5]);
                break;
            case 7:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6]);
                break;
            case 8:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7]);
                break;
            case 9:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8]);
                break;
            case 10:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9]);
                break;
            case 11:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10]);
                break;
            case 12:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11]);
                break;
            case 13:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12]);
                break;
            case 14:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13]);
                break;
            case 15:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14]);
                break;
        }
        lpb += cbi;
        cbLines++;
    }
    if (cb) {
        DebugTrace("<etc.>");    //
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtests\mutil.cpp ===
/***********************************************************************
 *
 * MUTIL.C
 *
 * Windows AB Mapi Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/

//#include <_apipch.h>
#include <wab.h>
#include "mutil.h"

#define _WAB_MUTIL_C

#ifdef DEBUG
PUCHAR PropTagName(ULONG ulPropTag);
const TCHAR szNULL[] = "";
#endif

#if defined (_MIPS_) || defined (_ALPHA_) || defined (_PPC_)
#define AlignProp(_cb)	Align8(_cb)
#else
#define AlignProp(_cb)	(_cb)
#endif


#define ALIGN_RISC		8
#define ALIGN_X86		1
//#define LPULONG unsigned long*

extern LPWABOBJECT		lpWABObject; //Global handle to session


/***************************************************************************

    Name      : RemoveDuplicateProps

    Purpose   : Removes duplicate properties from an SPropValue array.

    Parameters: lpcProps -> input/output: number of properties in lpProps
                lpProps -> input/output: prop array to remove dups from.

    Returns   : none

    Comment   : Gives preference to earlier properties.

***************************************************************************/
void RemoveDuplicateProps(LPULONG lpcProps, LPSPropValue lpProps) {
    ULONG i, j;
    ULONG cProps = *lpcProps;

    for (i = 0; i < cProps; i++) {
        for (j = i + 1; j < cProps; j++) {
            if (PROP_ID(lpProps[i].ulPropTag) == PROP_ID(lpProps[j].ulPropTag)) {
                // If j is PT_ERROR, use i, else use j.
                if (lpProps[j].ulPropTag != PR_NULL) {
                    if (PROP_TYPE(lpProps[j].ulPropTag) != PT_ERROR) {
                        // Replace i's propvalue with j's.  Nuke j's entry.
                        lpProps[i] = lpProps[j];
                    }
                    lpProps[j].ulPropTag = PR_NULL;
                }
            }
        }
    }

    // Now, squeeze out all the PR_NULLs.
    for (i = 0; i < cProps; i++) {
        if (lpProps[i].ulPropTag == PR_NULL) {
            // Move the array down
            cProps--;

            if (cProps > i) {

                MoveMemory(&lpProps[i], // dest
                  &lpProps[i + 1],      // src
                  (cProps - i) * sizeof(SPropValue));
                i--;    // Redo this row... it's new!
            }
        }
    }

    *lpcProps = cProps;
}


/***************************************************************************

    Name      : ScMergePropValues

    Purpose   : Merge two SPropValue arrays

    Parameters: cProps1 = count of properties in lpSource1
                lpSource1 -> 1st source SPropValue array
                cProps2 = count of properties in lpSource2
                lpSource2 -> 2nd source SPropValue array
                lpcPropsDest -> returned number of properties
                lppDest -> Returned destination SPropValue array.  This
                  buffer will be allocated using AllocateBuffer and is the
                  responsibility of the caller on return.

    Returns   : SCODE

    Comment   : Gives preference to Source2 over Source1 in case of collisions.

***************************************************************************/

SCODE ScMergePropValues(ULONG cProps1, LPSPropValue lpSource1,
  ULONG cProps2, LPSPropValue lpSource2, LPULONG lpcPropsDest, LPSPropValue * lppDest) {
    ULONG cb1, cb2, cb, cProps, i, cbT, cbMV;
    SCODE sc = SUCCESS_SUCCESS;
    LPSPropValue pprop, lpDestReturn = NULL;
    __UPV upv;
    LPBYTE pb;  // moving pointer for property data
    int iValue;



    DebugProperties(lpSource1, cProps1, "Source 1");
    DebugProperties(lpSource2, cProps2, "Source 2");


    // How big do I need to make the destination buffer?
    // Just add the sizes of the two together to get an upper limit.
    // This is close enough, though not optimal (consider overlap).

    if (sc = ScCountProps(cProps1, lpSource1, &cb1)) {
        goto exit;
    }
    if (sc = ScCountProps(cProps2, lpSource2, &cb2)) {
        goto exit;
    }

    cProps = cProps1 + cProps2;
    cb = cb1 + cb2;
    if (sc = MAPIAllocateBuffer(cb, (void **)&lpDestReturn)) {
        goto exit;
    }
//    MAPISetBufferName(lpDestReturn, "WAB: lpDestReturn in ScMergePropValues");



    // Copy each source property array to the destination
    memcpy(lpDestReturn, lpSource1, cProps1 * sizeof(SPropValue));
    memcpy(&lpDestReturn[cProps1], lpSource2, cProps2 * sizeof(SPropValue));


    // Remove duplicates
    RemoveDuplicateProps(&cProps, lpDestReturn);

    // Fixup the pointers.
    pb = (LPBYTE)&(lpDestReturn[cProps]);   // point past the prop array


    for (pprop = lpDestReturn, i = cProps; i--; ++pprop) {
        //	Tricky: common code after the switch increments pb and cb
        //	by the amount copied. If no increment is necessary, the case
        //	uses 'continue' rather than 'break' to exit the switch, thus
        //	skipping the increment -- AND any other code which may be
        //	added after the switch.

        switch (PROP_TYPE(pprop->ulPropTag)) {
            default:
                DebugTrace("ScMergePropValues: Unknown property type %s (index %d)\n",
                  SzDecodeUlPropTag(pprop->ulPropTag), pprop - lpDestReturn);
                sc = E_INVALIDARG;
                goto exit;

            case PT_I2:
            case PT_LONG:
            case PT_R4:
            case PT_APPTIME:
            case PT_DOUBLE:
            case PT_BOOLEAN:
            case PT_CURRENCY:
            case PT_SYSTIME:
            case PT_I8:
            case PT_ERROR:
            case PT_OBJECT:
            case PT_NULL:
                continue;	//	nothing to add

            case PT_CLSID:
                cbT = sizeof(GUID);
                MemCopy(pb, (LPBYTE)pprop->Value.lpguid, cbT);
                pprop->Value.lpguid = (LPGUID)pb;
                break;

            case PT_BINARY:
                cbT = (UINT)pprop->Value.bin.cb;
                MemCopy(pb, pprop->Value.bin.lpb, cbT);
                pprop->Value.bin.lpb = pb;
                break;

            case PT_STRING8:
                cbT = lstrlenA( pprop->Value.lpszA ) + 1;
                MemCopy(pb, pprop->Value.lpszA, cbT);
                pprop->Value.lpszA = (LPSTR)pb;
                break;

            case PT_UNICODE:
                cbT = (lstrlenW( pprop->Value.lpszW ) + 1) * sizeof(WCHAR);
                MemCopy(pb, pprop->Value.lpszW, cbT);
                pprop->Value.lpszW = (LPWSTR)pb;
                break;

            case PT_MV_I2:
                cbT = (UINT)pprop->Value.MVi.cValues * sizeof(short int);
                MemCopy(pb, pprop->Value.MVi.lpi, cbT);
                pprop->Value.MVi.lpi = (short int FAR *)pb;
                break;

            case PT_MV_LONG:
                cbT = (UINT)pprop->Value.MVl.cValues * sizeof(LONG);
                MemCopy(pb, pprop->Value.MVl.lpl, cbT);
                pprop->Value.MVl.lpl = (LONG FAR *)pb;
                break;

            case PT_MV_R4:
                cbT = (UINT)pprop->Value.MVflt.cValues * sizeof(float);
                MemCopy(pb, pprop->Value.MVflt.lpflt, cbT);
                pprop->Value.MVflt.lpflt = (float FAR *)pb;
                break;

            case PT_MV_APPTIME:
                cbT = (UINT)pprop->Value.MVat.cValues * sizeof(double);
                MemCopy(pb, pprop->Value.MVat.lpat, cbT);
                pprop->Value.MVat.lpat = (double FAR *)pb;
                break;

            case PT_MV_DOUBLE:
                cbT = (UINT)pprop->Value.MVdbl.cValues * sizeof(double);
                MemCopy(pb, pprop->Value.MVdbl.lpdbl, cbT);
                pprop->Value.MVdbl.lpdbl = (double FAR *)pb;
                break;

            case PT_MV_CURRENCY:
                cbT = (UINT)pprop->Value.MVcur.cValues * sizeof(CURRENCY);
                MemCopy(pb, pprop->Value.MVcur.lpcur, cbT);
                pprop->Value.MVcur.lpcur = (CURRENCY FAR *)pb;
                break;

            case PT_MV_SYSTIME:
                cbT = (UINT)pprop->Value.MVft.cValues * sizeof(FILETIME);
                MemCopy(pb, pprop->Value.MVft.lpft, cbT);
                pprop->Value.MVft.lpft = (FILETIME FAR *)pb;
                break;

            case PT_MV_CLSID:
                cbT = (UINT)pprop->Value.MVguid.cValues * sizeof(GUID);
                MemCopy(pb, pprop->Value.MVguid.lpguid, cbT);
                pprop->Value.MVguid.lpguid = (GUID FAR *)pb;
                break;

            case PT_MV_I8:
                cbT = (UINT)pprop->Value.MVli.cValues * sizeof(LARGE_INTEGER);
                MemCopy(pb, pprop->Value.MVli.lpli, cbT);
                pprop->Value.MVli.lpli = (LARGE_INTEGER FAR *)pb;
                break;

            case PT_MV_BINARY:
                upv = pprop->Value;
                pprop->Value.MVbin.lpbin = (SBinary *)pb;
                cbMV = upv.MVbin.cValues * sizeof(SBinary);
                pb += cbMV;
                cb += cbMV;
                for (iValue = 0; (ULONG)iValue < upv.MVbin.cValues; iValue++) {
                    pprop->Value.MVbin.lpbin[iValue].lpb = pb;
                    cbT = (UINT)upv.MVbin.lpbin[iValue].cb;
                    pprop->Value.MVbin.lpbin[iValue].cb = (ULONG)cbT;
                    MemCopy(pb, upv.MVbin.lpbin[iValue].lpb, cbT);
                    cbT = AlignProp(cbT);
                    cb += cbT;
                    pb += cbT;
                }
                continue;	//	already updated, don't do it again

            case PT_MV_STRING8:
                upv = pprop->Value;
                pprop->Value.MVszA.lppszA = (LPSTR *)pb;
                cbMV = upv.MVszA.cValues * sizeof(LPSTR);
                pb += cbMV;
                cb += cbMV;
                for (iValue = 0; (ULONG)iValue < upv.MVszA.cValues; iValue++) {
                    pprop->Value.MVszA.lppszA[iValue] = (LPSTR)pb;
                    cbT = lstrlenA(upv.MVszA.lppszA[iValue]) + 1;
                    MemCopy(pb, upv.MVszA.lppszA[iValue], cbT);
                    pb += cbT;
                    cb += cbT;
                }
                cbT = (UINT)AlignProp(cb);
                pb += cbT - cb;
                cb  = cbT;
                continue;	//	already updated, don't do it again

            case PT_MV_UNICODE:
                upv = pprop->Value;
                pprop->Value.MVszW.lppszW = (LPWSTR *)pb;
                cbMV = upv.MVszW.cValues * sizeof(LPWSTR);
                pb += cbMV;
                cb += cbMV;
                for (iValue = 0; (ULONG)iValue < upv.MVszW.cValues; iValue++) {
                    pprop->Value.MVszW.lppszW[iValue] = (LPWSTR)pb;
                    cbT = (lstrlenW(upv.MVszW.lppszW[iValue]) + 1)
                    * sizeof(WCHAR);
                    MemCopy(pb, upv.MVszW.lppszW[iValue], cbT);
                    pb += cbT;
                    cb += cbT;
                }
                cbT = (UINT)AlignProp(cb);
                pb += cbT - cb;
                cb  = cbT;
                continue;	//	already updated, don't do it again
        }

        //	Advance pointer and total count by the amount copied
        cbT = AlignProp(cbT);
        pb += cbT;
        cb += cbT;
    }

exit:
    // In case of error, free the memory.
    if (sc && lpDestReturn) {
        MAPIFreeBuffer(lpDestReturn);
        *lppDest = NULL;
    } else if (lpDestReturn) {
        *lppDest = lpDestReturn;
        *lpcPropsDest = cProps;
        DebugProperties(lpDestReturn, cProps, "Destination");
    } // else just return the error

    return(sc);
}





#ifdef OLD_STUFF
/***************************************************************************

    Name      : AddPropToMVPBin

    Purpose   : Add a property to a multi-valued binary property in a prop array

    Parameters: lpaProps -> array of properties
                cProps = number of props in lpaProps
                uPropTag = property tag for MVP
                index = index in lpaProps of MVP
                lpNew -> new data
                cbNew = size of lpbNew

    Returns   : HRESULT

    Comment   : Find the size of the existing MVP
                Add in the size of the new entry
                allocate new space
                copy old to new
                free old
                copy new entry
                point prop array lpbin the new space
                increment cValues


                Note: The new MVP memory is AllocMore'd onto the lpaProps
                allocation.  We will unlink the pointer to the old MVP array,
                but this will be cleaned up when the prop array is freed.

***************************************************************************/
HRESULT AddPropToMVPBin(
  LPSPropValue lpaProps,
  DWORD cProps,
  DWORD index,
  LPVOID lpNew,
  ULONG cbNew) {

    SBinaryArray * lprgsbOld = NULL;
    SBinaryArray * lprgsbNew = NULL;
    LPSBinary lpsbOld = NULL;
    LPSBinary lpsbNew = NULL;
    ULONG cbMVP = 0;
    ULONG cExisting = 0;
    LPBYTE lpNewTemp = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i;


    // Find the size of any existing MVP entries
    if (PROP_ERROR(lpaProps[index])) {
        // Un-ERROR the property tag
        lpaProps[index].ulPropTag = PROP_TAG(PT_MV_BINARY, PROP_ID(lpaProps[index].ulPropTag));
    } else {
        // point to the structure in the prop array.
        lprgsbOld = &(lpaProps[index].Value.MVbin);
        lpsbOld = lprgsbOld->lpbin;

        cExisting = lprgsbOld->cValues;
        cbMVP = cExisting * sizeof(SBinary);
    }

    // cbMVP now contains the current size of the MVP
    cbMVP += sizeof(SBinary);   // room in the MVP for another Sbin

    // Allocate room for new MVP
    if (sc = MAPIAllocateMore(cbMVP, lpaProps, (LPVOID)&lpsbNew)) {
        AwDebugError(("AddPropToMVPBin allocation (%u) failed %x\n", cbMVP, sc));
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    // If there are properties there already, copy them to our new MVP
    for (i = 0; i < cExisting; i++) {
        // Copy this property value to the MVP
        lpsbNew[i].cb = lpsbOld[i].cb;
        lpsbNew[i].lpb = lpsbOld[i].lpb;
    }

    // Add the new property value
    // Allocate room for it
    if (sc = MAPIAllocateMore(cbNew, lpaProps, (LPVOID)&(lpsbNew[i].lpb))) {
        AwDebugError(("AddPropToMVPBin allocation (%u) failed %x\n", cbNew, sc));
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    lpsbNew[i].cb = cbNew;
    CopyMemory(lpsbNew[i].lpb, lpNew, cbNew);

    lpaProps[index].Value.MVbin.lpbin = lpsbNew;
    lpaProps[index].Value.MVbin.cValues = cExisting + 1;

    return(hResult);
}


/***************************************************************************

    Name      : AddPropToMVPString

    Purpose   : Add a property to a multi-valued binary property in a prop array

    Parameters: lpaProps -> array of properties
                cProps = number of props in lpaProps
                uPropTag = property tag for MVP
                index = index in lpaProps of MVP
                lpszNew -> new data string

    Returns   : HRESULT

    Comment   : Find the size of the existing MVP
                Add in the size of the new entry
                allocate new space
                copy old to new
                free old
                copy new entry
                point prop array LPSZ to the new space
                increment cValues


                Note: The new MVP memory is AllocMore'd onto the lpaProps
                allocation.  We will unlink the pointer to the old MVP array,
                but this will be cleaned up when the prop array is freed.

***************************************************************************/
HRESULT AddPropToMVPString(
  LPSPropValue lpaProps,
  DWORD cProps,
  DWORD index,
  LPTSTR lpszNew) {

    SStringArray * lprgszOld = NULL;    // old SString array
    LPTSTR * lppszNew = NULL;           // new prop array
    LPTSTR * lppszOld = NULL;           // old prop array
    ULONG cbMVP = 0;
    ULONG cExisting = 0;
    LPBYTE lpNewTemp = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i;
    ULONG cbNew;

    if (lpszNew) {
        cbNew = lstrlen(lpszNew) + 1;
    } else {
        cbNew = 0;
    }

    // Find the size of any existing MVP entries
    if (PROP_ERROR(lpaProps[index])) {
        // Un-ERROR the property tag
        lpaProps[index].ulPropTag = PROP_TAG(PT_MV_TSTRING, PROP_ID(lpaProps[index].ulPropTag));
    } else {
        // point to the structure in the prop array.
        lprgszOld = &(lpaProps[index].Value.MVSZ);
        lppszOld = lprgszOld->LPPSZ;

        cExisting = lprgszOld->cValues;
        cbMVP = cExisting * sizeof(LPTSTR);
    }

    // cbMVP now contains the current size of the MVP
    cbMVP += sizeof(LPTSTR);    // room in the MVP for another string pointer


    // Allocate room for new MVP array
    if (sc = MAPIAllocateMore(cbMVP, lpaProps, (LPVOID)&lppszNew)) {
        AwDebugError(("AddPropToMVPString allocation (%u) failed %x\n", cbMVP, sc));
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    // If there are properties there already, copy them to our new MVP
    for (i = 0; i < cExisting; i++) {
        // Copy this property value to the MVP
        lppszNew[i] = lppszOld[i];
    }

    // Add the new property value
    // Allocate room for it
    if (cbNew) {
        if (sc = MAPIAllocateMore(cbNew, lpaProps, (LPVOID)&(lppszNew[i]))) {
            AwDebugError(("AddPropToMVPBin allocation (%u) failed %x\n", cbNew, sc));
            hResult = ResultFromScode(sc);
            return(hResult);
        }
        lstrcpy(lppszNew[i], lpszNew);

        lpaProps[index].Value.MVSZ.LPPSZ= lppszNew;
        lpaProps[index].Value.MVSZ.cValues = cExisting + 1;

    } else {
        lppszNew[i] = NULL;
    }

    return(hResult);
}


#endif // OLD_STUFF


/***************************************************************************

    Name      : FreeBufferAndNull

    Purpose   : Frees a MAPI buffer and NULLs the pointer

    Parameters: lppv = pointer to buffer pointer to free

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall FreeBufferAndNull(LPVOID * lppv) {
    if (lppv) {
        if (*lppv) {
            SCODE sc;
            if (sc = MAPIFreeBuffer(*lppv)) {
                DebugTrace("MAPIFreeBuffer(%x) -> %s\n", *lppv, SzDecodeScode(sc));
            }
            *lppv = NULL;
        }
    }
}


/***************************************************************************

    Name      : ReleaseAndNull

    Purpose   : Releases an object and NULLs the pointer

    Parameters: lppv = pointer to pointer to object to release

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall ReleaseAndNull(LPVOID * lppv) {
    LPUNKNOWN * lppunk = (LPUNKNOWN *)lppv;

    if (lppunk) {
        if (*lppunk) {
            HRESULT hResult;

            if (hResult = (*lppunk)->lpVtbl->Release(*lppunk)) {
                DebugTrace("Release(%x) -> %s\n", *lppunk, SzDecodeScode(GetScode(hResult)));
            }
            *lppunk = NULL;
        }
    }
}


#ifdef OLD_STUFF
/***************************************************************************

    Name      : MergeProblemArrays

    Purpose   : Merge a problem array into another

    Parameters: lpPaDest -> destination problem array
                lpPaSource -> source problem array
                cDestMax = total number of problem slots in lpPaDest.  This
                  includes those in use (lpPaDest->cProblem) and those not
                  yet in use.

    Returns   : none

    Comment   :

***************************************************************************/
void MergeProblemArrays(LPSPropProblemArray lpPaDest,
  LPSPropProblemArray lpPaSource, ULONG cDestMax) {
    ULONG i, j;
    ULONG cDest;
    ULONG cDestRemaining;

    cDest = lpPaDest->cProblem;
    cDestRemaining = cDestMax - cDest;

    // Loop through the source problems, copying the non-duplicates into dest
    for (i = 0; i < lpPaSource->cProblem; i++) {
        // Search the Dest problem array for the same property
        for (j = 0; j < cDest; j++) {
            // should just compare PROP_IDs here, since we may be overwriting
            // some of the proptypes with PT_NULL elsewhere.
            if (PROP_ID(lpPaSource->aProblem[i].ulPropTag) == PROP_ID(lpPaDest->aProblem[j].ulPropTag)) {
                break;  // Found a match, don't copy this one.  Move along.
            }
        }

        if (j == lpPaDest->cProblem) {
            Assert(cDestRemaining);
            if (cDestRemaining) {
                // No matches, copy this problem from Source to Dest
                lpPaDest->aProblem[lpPaDest->cProblem++] = lpPaSource->aProblem[i];
                cDestRemaining--;
            } else {
                AwDebugError(("MergeProblemArrays ran out of problem slots!\n"));
            }
        }
    }
}


/***************************************************************************

    Name      : MapObjectNamedProps

    Purpose   : Map the named properties WAB cares about into the object.

    Parameters: lpmp -> IMAPIProp object
                lppPropTags -> returned array of property tags.  Note: Must
                be MAPIFreeBuffer'd by caller.

    Returns   : none

    Comment   : What a pain in the butt!
                We could conceivably improve performance here by caching the
                returned table and comparing the object's PR_MAPPING_SIGNATURE
                against the cache.

***************************************************************************/
HRESULT MapObjectNamedProps(LPMAPIPROP lpmp, LPSPropTagArray * lppPropTags) {
    static GUID guidWABProps = { /* efa29030-364e-11cf-a49b-00aa0047faa4 */
        0xefa29030,
        0x364e,
        0x11cf,
        {0xa4, 0x9b, 0x00, 0xaa, 0x00, 0x47, 0xfa, 0xa4}
    };

    ULONG i;
    LPMAPINAMEID lppmnid[eMaxNameIDs] = {NULL};
    MAPINAMEID rgmnid[eMaxNameIDs] = {0};
    HRESULT hResult = hrSuccess;


    // Loop through each property, setting up the NAME ID structures
    for (i = 0; i < eMaxNameIDs; i++) {

        rgmnid[i].lpguid = &guidWABProps;
        rgmnid[i].ulKind = MNID_STRING;             // Unicode String
        rgmnid[i].Kind.lpwstrName = rgPropNames[i];

        lppmnid[i] = &rgmnid[i];
    }

    if (hResult = lpmp->lpVtbl->GetIDsFromNames(lpmp,
      eMaxNameIDs,      // how many?
      lppmnid,
      MAPI_CREATE,      // create them if they don't already exist
      lppPropTags)) {
        if (HR_FAILED(hResult)) {
            AwDebugError(("GetIDsFromNames -> %s\n", SzDecodeScode(GetScode(hResult))));
            goto exit;
        } else {
            DebugTrace("GetIDsFromNames -> %s\n", SzDecodeScode(GetScode(hResult)));
        }
    }

    Assert((*lppPropTags)->cValues == eMaxNameIDs);

    AwDebugTrace(("PropTag\t\tType\tProp Name\n"));
    // Loop through the property tags, filling in their property types.
    for (i = 0; i < eMaxNameIDs; i++) {
        (*lppPropTags)->aulPropTag[i] = CHANGE_PROP_TYPE((*lppPropTags)->aulPropTag[i],
          PROP_TYPE(rgulNamedPropTags[i]));
#ifdef DEBUG
        {
            TCHAR szBuffer[257];

            WideCharToMultiByte(CP_ACP, 0, rgPropNames[i], -1, szBuffer, 257, NULL, NULL);

            AwDebugTrace(("%08x\t%s\t%s\n", (*lppPropTags)->aulPropTag[i],
              PropTypeString(PROP_TYPE((*lppPropTags)->aulPropTag[i])), szBuffer));
        }
#endif

    }

exit:
    return(hResult);
}


/***************************************************************************

    Name      : PreparePropTagArray

    Purpose   : Prepare a prop tag array by replacing placeholder props tags
                with their named property tags.

    Parameters: ptaStatic = static property tag array (input)
                pptaReturn -> returned prop tag array (output)
                pptaNamedProps -> returned array of named property tags
                    Three possibilities here:
                       + NULL pointer: no input PTA or output named
                           props PTA is returned.  This is less efficient since
                           it must call MAPI to get the named props array.
                       + good pointer to NULL pointer:  no input PTA, but
                           will return a good PTA of named props which can
                           be used in later calls on this object for faster
                           operation.
                       + good pointer to good pointer.  Use the input PTA instead
                           of calling MAPI to map props.  Returned contents must
                           be freed with MAPIFreeBuffer.
                lpObject = object that the properties apply to.  Required if
                    no input *pptaNamedProps is supplied, otherwise, NULL.

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT PreparePropTagArray(LPSPropTagArray ptaStatic, LPSPropTagArray * pptaReturn,
  LPSPropTagArray * pptaNamedProps, LPMAPIPROP lpObject) {
    HRESULT hResult = hrSuccess;
    ULONG cbpta;
    LPSPropTagArray ptaTemp = NULL;
    LPSPropTagArray ptaNamedProps;
    ULONG i;

    if (pptaNamedProps) {
        // input Named Props PTA
        ptaNamedProps = *pptaNamedProps;
    } else {
        ptaNamedProps = NULL;
    }

    if (! ptaNamedProps) {
        if (! lpObject) {
            AwDebugError(("PreoparePropTagArray both lpObject and ptaNamedProps are NULL\n"));
            hResult = ResultFromScode(E_INVALIDARG);
            goto exit;
        }

        // Map the property names into the object
        if (hResult = MapObjectNamedProps(lpObject, &ptaTemp)) {
            AwDebugError(("PreoparePropTagArray both lpObject and ptaNamedProps are NULL\n"));
            goto exit;
        }
    }

    if (pptaReturn) {
        // Allocate a return pta
        cbpta = sizeof(SPropTagArray) + ptaStatic->cValues * sizeof(ULONG);
        if ((*pptaReturn = WABAlloc(cbpta)) == NULL) {
            AwDebugError(("PreparePropTagArray WABAlloc(%u) failed\n", cbpta));
            hResult = ResultFromScode(E_OUTOFMEMORY);
            goto exit;
        }

        (*pptaReturn)->cValues = ptaStatic->cValues;

        // Walk through the ptaStatic looking for named property placeholders.
        for (i = 0; i < ptaStatic->cValues; i++) {
            if (IS_PLACEHOLDER(ptaStatic->aulPropTag[i])) {
                // Found a placeholder.  Turn it into a true property tag
                Assert(PLACEHOLDER_INDEX(ptaStatic->aulPropTag[i]) < ptaNamedProps->cValues);
                (*pptaReturn)->aulPropTag[i] =
                   ptaNamedProps->aulPropTag[PLACEHOLDER_INDEX(ptaStatic->aulPropTag[i])];
            } else {
                (*pptaReturn)->aulPropTag[i] = ptaStatic->aulPropTag[i];
            }
        }
    }

exit:
    if (hResult || ! pptaNamedProps) {
        FreeBufferAndNull(&ptaTemp);
    } else {
        // Client is responsible for freeing this.
        *pptaNamedProps = ptaNamedProps;
    }

    return(hResult);
}


/***************************************************************************

    Name      : OpenCreateProperty

    Purpose   : Open an interface on a property or create if non-existent.

    Parameters: lpmp -> IMAPIProp object to open prop on
                ulPropTag = property tag to open
                lpciid -> interface identifier
                ulInterfaceOptions = interface specific flags
                ulFlags = MAPI_MODIFY?
                lppunk -> return the object here

    Returns   : HRESULT

    Comment   : Caller is responsible for Release'ing the returned object.

***************************************************************************/
HRESULT OpenCreateProperty(LPMAPIPROP lpmp,
  ULONG ulPropTag,
  LPCIID lpciid,
  ULONG ulInterfaceOptions,
  ULONG ulFlags,
  LPUNKNOWN * lppunk) {

    HRESULT hResult;

    if (hResult = lpmp->lpVtbl->OpenProperty(
      lpmp,
      ulPropTag,
      lpciid,
      ulInterfaceOptions,
      ulFlags,
      (LPUNKNOWN *)lppunk)) {
        AwDebugTrace(("OpenCreateProperty:OpenProperty(%s)-> %s\n", PropTagName(ulPropTag), SzDecodeScode(GetScode(hResult))));
        // property doesn't exist... try to create it
        if (hResult = lpmp->lpVtbl->OpenProperty(
          lpmp,
          ulPropTag,
          lpciid,
          ulInterfaceOptions,
          MAPI_CREATE | ulFlags,
          (LPUNKNOWN *)lppunk)) {
            AwDebugTrace(("OpenCreateProperty:OpenProperty(%s, MAPI_CREATE)-> %s\n", PropTagName(ulPropTag), SzDecodeScode(GetScode(hResult))));
        }
    }

    return(hResult);
}
#endif // OLD_STUFF


#ifdef DEBUG
/***************************************************************************

    Name      : PropTypeString

    Purpose   : Map a proptype to a string

    Parameters: ulPropType = property type to map

    Returns   : string pointer to name of prop type

    Comment   :

***************************************************************************/
LPTSTR PropTypeString(ULONG ulPropType) {
    switch (ulPropType) {
        case PT_UNSPECIFIED:
            return("PT_UNSPECIFIED");
        case PT_NULL:
            return("PT_NULL       ");
        case PT_I2:
            return("PT_I2         ");
        case PT_LONG:
            return("PT_LONG       ");
        case PT_R4:
            return("PT_R4         ");
        case PT_DOUBLE:
            return("PT_DOUBLE     ");
        case PT_CURRENCY:
            return("PT_CURRENCY   ");
        case PT_APPTIME:
            return("PT_APPTIME    ");
        case PT_ERROR:
            return("PT_ERROR      ");
        case PT_BOOLEAN:
            return("PT_BOOLEAN    ");
        case PT_OBJECT:
            return("PT_OBJECT     ");
        case PT_I8:
            return("PT_I8         ");
        case PT_STRING8:
            return("PT_STRING8    ");
        case PT_UNICODE:
            return("PT_UNICODE    ");
        case PT_SYSTIME:
            return("PT_SYSTIME    ");
        case PT_CLSID:
            return("PT_CLSID      ");
        case PT_BINARY:
            return("PT_BINARY     ");
        case PT_MV_I2:
            return("PT_MV_I2      ");
        case PT_MV_LONG:
            return("PT_MV_LONG    ");
        case PT_MV_R4:
            return("PT_MV_R4      ");
        case PT_MV_DOUBLE:
            return("PT_MV_DOUBLE  ");
        case PT_MV_CURRENCY:
            return("PT_MV_CURRENCY");
        case PT_MV_APPTIME:
            return("PT_MV_APPTIME ");
        case PT_MV_SYSTIME:
            return("PT_MV_SYSTIME ");
        case PT_MV_STRING8:
            return("PT_MV_STRING8 ");
        case PT_MV_BINARY:
            return("PT_MV_BINARY  ");
        case PT_MV_UNICODE:
            return("PT_MV_UNICODE ");
        case PT_MV_CLSID:
            return("PT_MV_CLSID   ");
        case PT_MV_I8:
            return("PT_MV_I8      ");
        default:
            return("   <unknown>  ");
    }
}


/***************************************************************************

    Name      : TraceMVPStrings

    Purpose   : Debug trace a multivalued string property value

    Parameters: lpszCaption = caption string
                PropValue = property value to dump

    Returns   : none

    Comment   :

***************************************************************************/
void _TraceMVPStrings(LPTSTR lpszCaption, SPropValue PropValue) {
    ULONG i;

    DebugTrace("-----------------------------------------------------\n");
    DebugTrace("%s", lpszCaption);
    switch (PROP_TYPE(PropValue.ulPropTag)) {

        case PT_ERROR:
            DebugTrace("Error value %s\n", SzDecodeScode(PropValue.Value.err));
            break;

        case PT_MV_TSTRING:
            DebugTrace("%u values\n", PropValue.Value.MVSZ.cValues);

            if (PropValue.Value.MVSZ.cValues) {
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
                for (i = 0; i < PropValue.Value.MVSZ.cValues; i++) {
                    DebugTrace("%u: \"%s\"\n", i, PropValue.Value.MVSZ.LPPSZ[i]);
                }
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
            }
            break;

        default:
            DebugTrace("TraceMVPStrings got incorrect property type %u for tag %x\n",
              PROP_TYPE(PropValue.ulPropTag), PropValue.ulPropTag);
            break;
    }
}


/***************************************************************************

    Name      : DebugBinary

    Purpose   : Debug dump an array of bytes

    Parameters: cb = number of bytes to dump
                lpb -> bytes to dump

    Returns   : none

    Comment   :

***************************************************************************/
#define DEBUG_NUM_BINARY_LINES  2
VOID DebugBinary(UINT cb, LPBYTE lpb) {
    UINT cbLines = 0;

#if (DEBUG_NUM_BINARY_LINES != 0)
    UINT cbi;

    while (cb && cbLines < DEBUG_NUM_BINARY_LINES) {
        cbi = min(cb, 16);
        cb -= cbi;

        switch (cbi) {
            case 16:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14],
                  lpb[15]);
                break;
            case 1:
                DebugTrace("%02x\n", lpb[0]);
                break;
            case 2:
                DebugTrace("%02x %02x\n", lpb[0], lpb[1]);
                break;
            case 3:
                DebugTrace("%02x %02x %02x\n", lpb[0], lpb[1], lpb[2]);
                break;
            case 4:
                DebugTrace("%02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3]);
                break;
            case 5:
                DebugTrace("%02x %02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3],
                  lpb[4]);
                break;
            case 6:
                DebugTrace("%02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5]);
                break;
            case 7:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6]);
                break;
            case 8:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7]);
                break;
            case 9:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8]);
                break;
            case 10:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9]);
                break;
            case 11:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10]);
                break;
            case 12:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11]);
                break;
            case 13:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12]);
                break;
            case 14:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13]);
                break;
            case 15:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14]);
                break;
        }
        lpb += cbi;
        cbLines++;
    }
    if (cb) {
        DebugTrace("<etc.>\n");    //
    }
#endif
}


#define RETURN_PROP_CASE(pt) case PROP_ID(pt): return(#pt)

/***************************************************************************

    Name      : PropTagName

    Purpose   : Associate a name with a property tag

    Parameters: ulPropTag = property tag

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
PUCHAR PropTagName(ULONG ulPropTag) {
    static UCHAR szPropTag[35]; // see string on default

    switch (PROP_ID(ulPropTag)) {
        RETURN_PROP_CASE(PR_INITIALS);
        RETURN_PROP_CASE(PR_SURNAME);
        RETURN_PROP_CASE(PR_TITLE);
        RETURN_PROP_CASE(PR_TELEX_NUMBER);
        RETURN_PROP_CASE(PR_GIVEN_NAME);
        RETURN_PROP_CASE(PR_PRIMARY_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PRIMARY_FAX_NUMBER);
        RETURN_PROP_CASE(PR_POSTAL_CODE);
        RETURN_PROP_CASE(PR_POSTAL_ADDRESS);
        RETURN_PROP_CASE(PR_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_PAGER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_OTHER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ORGANIZATIONAL_ID_NUMBER);
        RETURN_PROP_CASE(PR_OFFICE_LOCATION);
        RETURN_PROP_CASE(PR_LOCATION);
        RETURN_PROP_CASE(PR_LOCALITY);
        RETURN_PROP_CASE(PR_ISDN_NUMBER);
        RETURN_PROP_CASE(PR_GOVERNMENT_ID_NUMBER);
        RETURN_PROP_CASE(PR_GENERATION);
        RETURN_PROP_CASE(PR_DEPARTMENT_NAME);
        RETURN_PROP_CASE(PR_COUNTRY);
        RETURN_PROP_CASE(PR_COMPANY_NAME);
        RETURN_PROP_CASE(PR_COMMENT);
        RETURN_PROP_CASE(PR_CELLULAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CALLBACK_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS2_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_FAX_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT);
        RETURN_PROP_CASE(PR_ACCOUNT);
        RETURN_PROP_CASE(PR_TEMPLATEID);
        RETURN_PROP_CASE(PR_DETAILS_TABLE);
        RETURN_PROP_CASE(PR_SEARCH_KEY);
        RETURN_PROP_CASE(PR_LAST_MODIFICATION_TIME);
        RETURN_PROP_CASE(PR_CREATION_TIME);
        RETURN_PROP_CASE(PR_ENTRYID);
        RETURN_PROP_CASE(PR_RECORD_KEY);
        RETURN_PROP_CASE(PR_MAPPING_SIGNATURE);
        RETURN_PROP_CASE(PR_OBJECT_TYPE);
        RETURN_PROP_CASE(PR_ROWID);
        RETURN_PROP_CASE(PR_ADDRTYPE);
        RETURN_PROP_CASE(PR_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_EMAIL_ADDRESS);
        RETURN_PROP_CASE(PR_DEPTH);
        RETURN_PROP_CASE(PR_ROW_TYPE);
        RETURN_PROP_CASE(PR_RADIO_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_HOME_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_INSTANCE_KEY);
        RETURN_PROP_CASE(PR_DISPLAY_TYPE);
        RETURN_PROP_CASE(PR_RECIPIENT_TYPE);

        default:
            wsprintf(szPropTag, "Unknown property tag 0x%x",
              PROP_ID(ulPropTag));
            return(szPropTag);
    }
}


/***************************************************************************

    Name      : DebugPropTagArray

    Purpose   : Displays MAPI property tags from a counted array

    Parameters: lpPropArray -> property array
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugPropTagArray(LPSPropTagArray lpPropArray, PUCHAR pszObject) {
    DWORD i;
    PUCHAR lpType;

    if (lpPropArray == NULL) {
        DebugTrace("Empty %s property tag array.\n", pszObject ? pszObject : szNULL);
        return;
    }

    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s property tags:\n", lpPropArray->cValues,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < lpPropArray->cValues ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpPropArray->aulPropTag[i],
          lpPropArray->aulPropTag[i] >> 16,
          lpPropArray->aulPropTag[i] & 0xffff);
#endif
        switch (lpPropArray->aulPropTag[i] & 0xffff) {
            case PT_STRING8:
                lpType = "STRING8";
                break;
            case PT_LONG:
                lpType = "LONG";
                break;
            case PT_I2:
                lpType = "I2";
                break;
            case PT_ERROR:
                lpType = "ERROR";
                break;
            case PT_BOOLEAN:
                lpType = "BOOLEAN";
                break;
            case PT_R4:
                lpType = "R4";
                break;
            case PT_DOUBLE:
                lpType = "DOUBLE";
                break;
            case PT_CURRENCY:
                lpType = "CURRENCY";
                break;
            case PT_APPTIME:
                lpType = "APPTIME";
                break;
            case PT_SYSTIME:
                lpType = "SYSTIME";
                break;
            case PT_UNICODE:
                lpType = "UNICODE";
                break;
            case PT_CLSID:
                lpType = "CLSID";
                break;
            case PT_BINARY:
                lpType = "BINARY";
                break;
            case PT_I8:
                lpType = "PT_I8";
                break;
            case PT_MV_I2:
                lpType = "MV_I2";
                break;
            case PT_MV_LONG:
                lpType = "MV_LONG";
                break;
            case PT_MV_R4:
                lpType = "MV_R4";
                break;
            case PT_MV_DOUBLE:
                lpType = "MV_DOUBLE";
                break;
            case PT_MV_CURRENCY:
                lpType = "MV_CURRENCY";
                break;
            case PT_MV_APPTIME:
                lpType = "MV_APPTIME";
                break;
            case PT_MV_SYSTIME:
                lpType = "MV_SYSTIME";
                break;
            case PT_MV_BINARY:
                lpType = "MV_BINARY";
                break;
            case PT_MV_STRING8:
                lpType = "MV_STRING8";
                break;
            case PT_MV_UNICODE:
                lpType = "MV_UNICODE";
                break;
            case PT_MV_CLSID:
                lpType = "MV_CLSID";
                break;
            case PT_MV_I8:
                lpType = "MV_I8";
                break;
            case PT_NULL:
                lpType = "NULL";
                break;
            case PT_OBJECT:
                lpType = "OBJECT";
                break;
            default:
                DebugTrace("<Unknown Property Type>");
                break;
        }
        DebugTrace("%s\t%s\n", PropTagName(lpPropArray->aulPropTag[i]), lpType);
    }
}


/***************************************************************************

    Name      : DebugProperties

    Purpose   : Displays MAPI properties in a property list

    Parameters: lpProps -> property list
                cProps = count of properties
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
void _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject) {
    DWORD i;


    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s properties:\n", cProps,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < cProps ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpProps[i].ulPropTag,
          lpProps[i].ulPropTag >> 16,
          lpProps[i].ulPropTag & 0xffff);
#endif
        DebugTrace("%s\n", PropTagName(lpProps[i].ulPropTag));

        switch (lpProps[i].ulPropTag & 0xffff) {
            case PT_STRING8:
                if (lstrlen(lpProps[i].Value.lpszA) < 1024) {
                    DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.lpszA);
                } else {
                    DebugTrace("STRING8 Value is too long to display\n");
                }
                break;
            case PT_LONG:
                DebugTrace("LONG Value:%u\n", lpProps[i].Value.l);
                break;
            case PT_I2:
                DebugTrace("I2 Value:%u\n", lpProps[i].Value.i);
                break;
            case PT_ERROR:
                DebugTrace("ERROR Value: %s\n", SzDecodeScode(lpProps[i].Value.err));
                break;
            case PT_BOOLEAN:
                DebugTrace("BOOLEAN Value:%s\n", lpProps[i].Value.b ?
                  "TRUE" : "FALSE");
                break;
            case PT_R4:
                DebugTrace("R4 Value\n");
                break;
            case PT_DOUBLE:
                DebugTrace("DOUBLE Value\n");
                break;
            case PT_CURRENCY:
                DebugTrace("CURRENCY Value\n");
                break;
            case PT_APPTIME:
                DebugTrace("APPTIME Value\n");
                break;
            case PT_SYSTIME:
//                DebugTime(lpProps[i].Value.ft, "SYSTIME Value:%s\n");
                break;
            case PT_UNICODE:
                DebugTrace("UNICODE Value\n");
                break;
            case PT_CLSID:
                DebugTrace("CLSID Value\n");
                break;
            case PT_BINARY:
                DebugTrace("BINARY Value %u bytes:\n", lpProps[i].Value.bin.cb);
                DebugBinary(lpProps[i].Value.bin.cb, lpProps[i].Value.bin.lpb);
                break;
            case PT_I8:
                DebugTrace("LARGE_INTEGER Value\n");
                break;
            case PT_MV_I2:
                DebugTrace("MV_I2 Value\n");
                break;
            case PT_MV_LONG:
                DebugTrace("MV_LONG Value\n");
                break;
            case PT_MV_R4:
                DebugTrace("MV_R4 Value\n");
                break;
            case PT_MV_DOUBLE:
                DebugTrace("MV_DOUBLE Value\n");
                break;
            case PT_MV_CURRENCY:
                DebugTrace("MV_CURRENCY Value\n");
                break;
            case PT_MV_APPTIME:
                DebugTrace("MV_APPTIME Value\n");
                break;
            case PT_MV_SYSTIME:
                DebugTrace("MV_SYSTIME Value\n");
                break;
            case PT_MV_BINARY:
                DebugTrace("MV_BINARY Value\n");
                break;
            case PT_MV_STRING8:
                DebugTrace("MV_STRING8 Value\n");
                break;
            case PT_MV_UNICODE:
                DebugTrace("MV_UNICODE Value\n");
                break;
            case PT_MV_CLSID:
                DebugTrace("MV_CLSID Value\n");
                break;
            case PT_MV_I8:
                DebugTrace("MV_I8 Value\n");
                break;
            case PT_NULL:
                DebugTrace("NULL Value\n");
                break;
            case PT_OBJECT:
                DebugTrace("OBJECT Value\n");
                break;
            default:
                DebugTrace("Unknown Property Type\n");
                break;
        }
    }
}


/***************************************************************************

    Name      : DebugObjectProps

    Purpose   : Displays MAPI properties of an object

    Parameters: lpObject -> object to dump
                Label = string to identify this prop dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugObjectProps(LPMAPIPROP lpObject, LPTSTR Label) {
    DWORD cProps = 0;
    LPSPropValue lpProps = NULL;
    HRESULT hr = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;


    hr = lpObject->lpVtbl->GetProps(lpObject, NULL, 0, &cProps, &lpProps);
    switch (sc = GetScode(hr)) {
        case SUCCESS_SUCCESS:
            break;

        case MAPI_W_ERRORS_RETURNED:
            DebugTrace("GetProps -> Errors Returned\n");
            break;

        default:
            DebugTrace("GetProps -> Error 0x%x\n", sc);
            return;
    }

    _DebugProperties(lpProps, cProps, Label);

    FreeBufferAndNull(&lpProps);
}


/***************************************************************************

    Name      : DebugMapiTable

    Purpose   : Displays structure of a MAPITABLE including properties

    Parameters: lpTable -> MAPITABLE to display

    Returns   : none

    Comment   : Don't sort the columns or rows here.  This routine should
                not produce side effects in the table.

***************************************************************************/
void _DebugMapiTable(LPMAPITABLE lpTable) {
    UCHAR szTemp[30];   // plenty for "ROW %u"
    ULONG ulCount;
    WORD wIndex;
    LPSRowSet lpsRow = NULL;
    ULONG ulCurrentRow = (ULONG)-1;
    ULONG ulNum, ulDen, lRowsSeeked;

    DebugTrace("=======================================\n");
    DebugTrace("+  Dump of MAPITABLE at 0x%x:\n", lpTable);
    DebugTrace("---------------------------------------\n");

    // How big is the table?
    lpTable->lpVtbl->GetRowCount(lpTable, 0, &ulCount);
    DebugTrace("Table contains %u rows\n", ulCount);

    // Save the current position in the table
    lpTable->lpVtbl->QueryPosition(lpTable, &ulCurrentRow, &ulNum, &ulDen);

    // Display the properties for each row in the table
    for (wIndex = 0; wIndex < ulCount; wIndex++) {
        // Get the next row
        lpTable->lpVtbl->QueryRows(lpTable, 1, 0, &lpsRow);

        if (lpsRow) {
            Assert(lpsRow->cRows == 1); // should have exactly one row

            wsprintf(szTemp, "ROW %u", wIndex);

            DebugProperties(lpsRow->aRow[0].lpProps,
              lpsRow->aRow[0].cValues, szTemp);

            FreeProws(lpsRow);
        }
    }

    // Restore the current position for the table
    if (ulCurrentRow != (ULONG)-1) {
        lpTable->lpVtbl->SeekRow(lpTable, BOOKMARK_BEGINNING, ulCurrentRow,
          &lRowsSeeked);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabext\wabex.c ===
/*//$$***************************************************************
//
//
// WABEX.C
//
// Main source file for WABEX.DLL, a sample DLL that demonstrates 
// how to extend the wab properties UI - enabling WAB clients to add
// their own PropertySheets to the UI displayed for details on contacts
// and groups. This demo uses a couple of named properties to show
// how you can extend the wab with your own UI for your own named props
//
//
// Created: 9/26/97 vikramm
//
//********************************************************************/
#include <windows.h>
#include "resource.h"
#include <wab.h>

// Globally cached hInstance for the DLL
//
HINSTANCE hinstApp = NULL;


// For the purposes of this sample, we will use 2 named properties,
// HomeTown and SportsTeam

// This demo's private GUID:
// {2B6D7EE0-36AB-11d1-9ABC-00A0C91F9C8B}
static const GUID WAB_ExtDemoGuid = 
{ 0x2b6d7ee0, 0x36ab, 0x11d1, { 0x9a, 0xbc, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b } };

static const LPTSTR lpMyPropNames[] = 
{   
    "MyHomeTown", 
    "MySportsTeam"
};

enum _MyTags
{
    myHomeTown = 0,
    mySportsTeam,
    myMax
};

ULONG MyPropTags[myMax];
ULONG PR_MY_HOMETOWN;
ULONG PR_MY_SPORTSTEAM;



// 
// Function prototypes:
//
HRESULT InitNamedProps(LPWABEXTDISPLAY lpWED);
BOOL CALLBACK fnDetailsPropDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void InitializeUI(HWND hDlg, LPWABEXTDISPLAY lpWED);
void SetDataInUI(HWND hDlg, LPWABEXTDISPLAY lpWED);
BOOL GetDataFromUI(HWND hDlg, LPWABEXTDISPLAY lpWED);
UINT CALLBACK fnCallback( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
void UpdateDisplayNameInfo(HWND hDlg, LPWABEXTDISPLAY lpWED);
BOOL bUpdatePropSheetData(HWND hDlg, LPWABEXTDISPLAY lpWED);

/*//$$****************************************************************
//
// DllEntryPoint
//
// Entry point for win32 - just used here to cache the DLL instance
//
//********************************************************************/
BOOL WINAPI
DllEntryPoint(HINSTANCE hinst, DWORD dwReason, LPVOID lpvReserved)
{
	switch ((short)dwReason)
	{
	case DLL_PROCESS_ATTACH:
		hinstApp = hinst;
        break;
    }
    return TRUE;
}



/*//$$****************************************************************
//
// AddExtendedPropPage
//
// This is the main exported function that WAB will call. In this 
// function, you create your PropertyPage and pass it to the WAB
// through the lpfnAddPage function. The WAB will automatically call 
// DestroyPropertySheetPage on exit to clean up the page you create.
// The lParam passed into this function should be set as the lParam
// on the property sheet you create, as shown below.
//
// Input Params: 
//
// lpfnPage - pointer to AddPropSheetPage function proc you call to
//          pass your hpage to the WAB
// lParam - LPARAM you set on your PropSheet page and also pass back to
//          wab in the lpfnAddPage. This lParam is a pointer to a 
//          WABEXTDISPLAY struct that your propsheet will use to 
//          exchange information with the WAB 
// 
// ***IMPORTANT*** Make sure your callback function is declared as a
//              WINAPI otherwise ugly things happen to the stack when
//              this function is called
//
//********************************************************************/
HRESULT WINAPI AddExtendedPropPage(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, int * lpnPage)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    LPWABEXTDISPLAY * lppWED = (LPWABEXTDISPLAY *) lParam;
    LPWABEXTDISPLAY lpWED = NULL; 

    // Check that there is space to create this property sheet
    // WAB can support a maximum of WAB_MAX_EXT_PROPSHEETS extension sheets

    if(WAB_MAX_EXT_PROPSHEETS <= *lpnPage)
        return E_FAIL;

    lpWED = &((*lppWED)[*lpnPage]);

    psp.dwSize = sizeof(psp);
    
    psp.dwFlags =   PSP_USETITLE |
                    PSP_USECALLBACK;// Specify this callback only if you need
                                    // a seperate function to perform special
                                    // initialization and cleanup when the 
                                    // property sheet is created or destroyed.
    psp.hInstance = hinstApp;

    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP); // Dialog resource

    psp.pfnDlgProc = fnDetailsPropDlgProc; // Message handler function

    psp.pcRefParent = NULL; //ignored
    
    psp.pfnCallback = fnCallback; // Callback function if PSP_USECALLBACK specified
    
    psp.lParam = (LPARAM) lpWED; // *** VERY IMPORTANT *** dont forget to do this
    
    psp.pszTitle = "Extension 1"; // Title for your tab

    /*
    // If you have some private data of your own that you want to cache
    // on your page, you can add it to the WABEXTDISPLAY struct
    // However WAB will not free this data so you must do it yourself on
    // cleanup
    {
        LPMYDATA lpMyData;
        // Create Data Here
        lpWED->lParam = (LPARAM) lpMyData;
    }
    */

    // Check if we can retrieve our named props .. if we cant,
    // no point creating this dialog ..
    //
    if(HR_FAILED(InitNamedProps(lpWED)))
        return E_FAIL;

    // Create the property sheet
    //
    hpage = CreatePropertySheetPage(&psp);

    if(hpage)
    {
        // Pass this hpage back to the WAB
        //
        if(!lpfnAddPage(hpage, (LPARAM) lpWED))
            DestroyPropertySheetPage(hpage);
        else
            (*lpnPage)++;

        //return NOERROR;
    }

    // if you are creating more than one property sheet, repeat the above as follows


    // Check that there is space to create this property sheet
    // WAB can support a maximum of WAB_MAX_EXT_PROPSHEETS extension sheets

    if(WAB_MAX_EXT_PROPSHEETS <= *lpnPage)
        return E_FAIL;

    lpWED = &((*lppWED)[*lpnPage]);
    
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP2); // Dialog resource

    psp.pfnDlgProc = fnDetailsPropDlgProc; // Message handler function

    psp.pszTitle = "Extension 2"; // Title for your tab

    psp.lParam = (LPARAM) lpWED; // *** VERY IMPORTANT *** dont forget to do this

    // Create the property sheet
    //
    hpage = CreatePropertySheetPage(&psp);

    if(hpage)
    {
        // Pass this hpage back to the WAB
        //
        if(!lpfnAddPage(hpage, (LPARAM) lpWED))
            DestroyPropertySheetPage(hpage);
        else
            (*lpnPage)++;
        return NOERROR;
    }

    return E_FAIL;
}


/*//$$****************************************************************
//
// InitNamedProps
//
// Gets the PropTags for the Named Props this app is interested in
//
//********************************************************************/
HRESULT InitNamedProps(LPWABEXTDISPLAY lpWED)
{
    // The lpWED provides a lpMailUser object for
    // the specific purpose of retrieving named properties by 
    // calling GetNamesFromIDs. The lpMailUser object is otherwise
    // a blank object - you cant get properties from it and shouldnt
    // set properties on it
    //
    ULONG i;
    HRESULT hr = E_FAIL;
    LPSPropTagArray lptaMyProps = NULL;
    LPMAPINAMEID * lppMyPropNames;
    SCODE sc;
    LPMAILUSER lpMailUser = (LPMAILUSER) lpWED->lpPropObj;
    WCHAR szBuf[myMax][MAX_PATH];

    if(!lpMailUser)
        goto err;

    sc = lpWED->lpWABObject->lpVtbl->AllocateBuffer(lpWED->lpWABObject,
                                                    sizeof(LPMAPINAMEID) * myMax, 
                                                    (LPVOID *) &lppMyPropNames);
    if(sc)
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    for(i=0;i<myMax;i++)
    {
        sc = lpWED->lpWABObject->lpVtbl->AllocateMore(lpWED->lpWABObject,
                                                    sizeof(MAPINAMEID), 
                                                    lppMyPropNames, 
                                                    &(lppMyPropNames[i]));
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto err;
        }
        lppMyPropNames[i]->lpguid = (LPGUID) &WAB_ExtDemoGuid;
        lppMyPropNames[i]->ulKind = MNID_STRING;

        *(szBuf[i]) = '\0';

        // Convert prop name to wide-char
        if ( !MultiByteToWideChar( GetACP(), 0, lpMyPropNames[i], -1, szBuf[i], sizeof(szBuf[i])) )
        {
            continue;
        }

        lppMyPropNames[i]->Kind.lpwstrName = (LPWSTR) szBuf[i];
    }

    hr = lpMailUser->lpVtbl->GetIDsFromNames(lpMailUser, 
                                            myMax, 
                                            lppMyPropNames,
                                            MAPI_CREATE, 
                                            &lptaMyProps);
    if(HR_FAILED(hr))
        goto err;

    if(lptaMyProps)
    {
        // Set the property types on the returned props
        MyPropTags[myHomeTown] = PR_MY_HOMETOWN = CHANGE_PROP_TYPE(lptaMyProps->aulPropTag[myHomeTown],    PT_TSTRING);
        MyPropTags[mySportsTeam] = PR_MY_SPORTSTEAM = CHANGE_PROP_TYPE(lptaMyProps->aulPropTag[mySportsTeam],    PT_TSTRING);
    }

err:
    if(lptaMyProps)
        lpWED->lpWABObject->lpVtbl->FreeBuffer( lpWED->lpWABObject,
                                                lptaMyProps);

    if(lppMyPropNames)
        lpWED->lpWABObject->lpVtbl->FreeBuffer( lpWED->lpWABObject,
                                                lppMyPropNames);

    return hr;

}


#define lpW_E_D ((LPWABEXTDISPLAY)pps->lParam)
/*//$$****************************************************************
//
// fnDetailsPropDlgProc
//
// The dialog procedure that will handle all the windows messages for 
// the extended property page. 
//
//********************************************************************/
BOOL CALLBACK fnDetailsPropDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    PROPSHEETPAGE * pps;

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        //
        // The lParam on InitDialog contains the application data
        // Cache this on the dialog so we can retrieve it later.
        //
        SetWindowLong(hDlg,DWL_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;

        // Initialize the UI appropriately
        InitializeUI(hDlg, lpW_E_D);

        // Fill the UI with appropriate data
        SetDataInUI(hDlg, lpW_E_D);

        return TRUE;
        break;


    case WM_COMMAND:
        switch(HIWORD(wParam)) //check the notification code
        {
            // If data changes, we should signal back to the WAB that
            // the data changed. If this flag is not set, the WAB will not
            // write the new data back to the store!!!
        case EN_CHANGE: //one of the edit boxes changed - dont care which
            lpW_E_D->fDataChanged = TRUE;
            break;
        }
        break;
    

    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //Page being activated
            // Get the latest display name info and update the 
            // corresponding control
            UpdateDisplayNameInfo(hDlg, lpW_E_D);
            break;


        case PSN_KILLACTIVE:    //Losing activation to another page or OK
            //
            // Take all the data from this prop sheet and convert it to a 
            // SPropValue array and place the data in an appropriate place.
            // The advantage of doing this in the KillActive notification is
            // that other property sheets can scan these property arrays and
            // if deisred, update data on other prop sheets based on this data
            //
            bUpdatePropSheetData(hDlg, lpW_E_D);
            break;


        case PSN_RESET:         //cancel
            break;


        case PSN_APPLY:         //ok pressed
            if (!(lpW_E_D->fReadOnly))
            {
                //
                // Check for any required properties here
                // If some required property is not filled in, you can prevent
                // the property sheet from closing
                //
                /*
                if (RequiredDataNotFilledIn())
                {
                    // abort this OK ... ie dont let them close
                    SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);
                }
                */
            }
            break;
        }
        break;
    }

    return 0;
}

int EditControls[] = 
{
    IDC_EXT_EDIT_HOME,
    IDC_EXT_EDIT_TEAM
};

/*//$$****************************************************************
//
// InitializeUI
//
// Rearranges/Sets UI based on input params
//
//********************************************************************/
void InitializeUI(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    // The WAB property sheets can be readonly when opening LDAP entries,
    // or vCards or other things. If the READONLY flag is set, set this
    // prop sheets controls to readonly
    //
    int i;
    for(i=0;i<myMax;i++)
    {
        SendDlgItemMessage( hDlg, EditControls[i], EM_SETREADONLY, 
                            (WPARAM) lpWED->fReadOnly, 0);
        SendDlgItemMessage( hDlg, EditControls[i], EM_SETLIMITTEXT, 
                            (WPARAM) MAX_PATH-1, 0);
    }
    return;
}


/*//$$****************************************************************
//
// SetDataInUI
//
// Fills in the controls with data passed in by the WAB
//
//********************************************************************/
void SetDataInUI(HWND hDlg, LPWABEXTDISPLAY lpWED)
{

    // Search for our private named properties and set them in the UI
    //
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    ULONG i = 0, j =0;

    // Get all the props from this object - one can also selectively
    // ask for specific props by passing in an SPropTagArray
    //
    if(!HR_FAILED(lpWED->lpPropObj->lpVtbl->GetProps(lpWED->lpPropObj,
                                                    NULL, 0, 
                                                    &ulcPropCount, 
                                                    &lpPropArray)))
    {
        if(ulcPropCount && lpPropArray)
        {
            for(i=0;i<ulcPropCount;i++)
            {
                for(j=0;j<myMax;j++)
                {
                    if(lpPropArray[i].ulPropTag == MyPropTags[j])
                    {
                        SetWindowText(  GetDlgItem(hDlg, EditControls[j]),
                                        lpPropArray[i].Value.LPSZ);
                        break;
                    }
                }
            }
        }
    }
    if(lpPropArray)
        lpWED->lpWABObject->lpVtbl->FreeBuffer(lpWED->lpWABObject, lpPropArray);
                                    
    return;
}

/*//$$****************************************************************
//
// GetDataFromUI
//
// Retrieves data from the UI and passes back to the WAB
//
//********************************************************************/
BOOL GetDataFromUI(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    TCHAR szData[myMax][MAX_PATH];
    int i;
    ULONG ulIndex = 0;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    SCODE sc;
    BOOL bRet = FALSE;
    int nIndex = lpWED->nIndexNumber; // position of page in sheets

    // Did any data change that we have to care about ?
    // If nothing changed, old data will be retained by WAB
    //
    if(!lpWED->fDataChanged)
        return TRUE;

    // Check if we have any data to save ...
    for(i=0;i<myMax;i++)
    {
        *(szData[i]) = '\0';
        GetWindowText(GetDlgItem(hDlg, EditControls[i]), szData[i], MAX_PATH);
        if(lstrlen(szData[i]))
            ulcPropCount++;
    }

    if(!ulcPropCount) // no data
        return TRUE;

    // Else data exists. Create a return prop array to pass back to the WAB
    sc = lpWED->lpWABObject->lpVtbl->AllocateBuffer(    lpWED->lpWABObject,
                                                        sizeof(SPropValue) * ulcPropCount, 
                                                        &lpPropArray);
    if (sc!=S_OK)
        goto out;

    for(i=0;i<myMax;i++)
    {
        int nLen = lstrlen(szData[i]);
        if(nLen)
        {
            lpPropArray[ulIndex].ulPropTag = MyPropTags[i];
            sc = lpWED->lpWABObject->lpVtbl->AllocateMore(  lpWED->lpWABObject,
                                                            nLen+1, lpPropArray, 
                                                            &(lpPropArray[ulIndex].Value.LPSZ));

            if (sc!=S_OK)
                goto out;
            lstrcpy(lpPropArray[ulIndex].Value.LPSZ,szData[i]);
            ulIndex++;
        }
    }

    // Set this new data on the object
    //
    if(HR_FAILED(lpWED->lpPropObj->lpVtbl->SetProps( lpWED->lpPropObj,
                                                    ulcPropCount, lpPropArray, NULL)))
        goto out;

    // ** Important - do not call SaveChanges on the object
    //    SaveChanges makes persistent changes and may modify/lose data if called at this point
    //    The WAB will determine if its appropriate or not to call SaveChanges after the
    // ** user has closed the property sheets
    

    bRet = TRUE;

out:
    if(!bRet && lpPropArray)
        lpWED->lpWABObject->lpVtbl->FreeBuffer(lpWED->lpWABObject, lpPropArray);

    return bRet;

} 


/*//$$****************************************************************
//
// UpdateDisplayNameInfo
//
// Demonstrates how to read information from other sibling property
// sheets when the user switches between pages
//
// This demo function attempts to get the updated display name info 
// when the user switches to this page in the UI
//
//********************************************************************/
const SizedSPropTagArray(1, ptaName)=
{
    1,
    {
        PR_DISPLAY_NAME
    }
};

void UpdateDisplayNameInfo(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    // 
    // Scan all the updated information from all the other property sheets
    //
    ULONG i = 0, j=0;
    LPTSTR lpName = NULL;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    // Each sheet should update its data on the object when it looses
    // focus and gets the PSN_KILLACTIVE message, provided the user has
    // made any changes. We just scan the object for the desired properties
    // and use them.

    // Ask only for the display name
    if(!HR_FAILED(lpWED->lpPropObj->lpVtbl->GetProps( lpWED->lpPropObj,
                                                    (LPSPropTagArray) &ptaName,
                                                    0,
                                                    &ulcPropCount, &lpPropArray)))
    {
        if( ulcPropCount == 1 && 
            PROP_TYPE(lpPropArray[0].ulPropTag) == PT_TSTRING) // The call could succeed but there may be no DN
        {                                                      // in which case the PROP_TYPE will be PR_NULL 
            lpName = lpPropArray[0].Value.LPSZ;
        }
    }

    if(lpName && lstrlen(lpName))
        SetDlgItemText(hDlg, IDC_STATIC_NAME, lpName);

    if(ulcPropCount && lpPropArray)
        lpWED->lpWABObject->lpVtbl->FreeBuffer(lpWED->lpWABObject, lpPropArray);

    return;
}

/*//$$*********************************************************************
//
//  UpdateOldPropTagsArray
//
//  When we update the data on a particular property sheet, we want to update
//  all the properties related to that particular sheet. Since some properties
//  may have been deleted from the UI, we delete all relevant properties from
//  the property object
//
//**************************************************************************/
BOOL UpdateOldPropTagsArray(LPWABEXTDISPLAY lpWED, int nIndex)
{
    LPSPropTagArray lpPTA = NULL;
    SCODE sc = 0;
    int i =0;
    
    sc = lpWED->lpWABObject->lpVtbl->AllocateBuffer(lpWED->lpWABObject,
                            sizeof(SPropTagArray) + sizeof(ULONG)*(myMax), 
                            &lpPTA);

    if(!lpPTA || sc!=S_OK)
        return FALSE;

    lpPTA->cValues = myMax;

    for(i=0;i<myMax;i++)
        lpPTA->aulPropTag[i] = MyPropTags[i];

    // Delete any props in the original that may have been modified on this propsheet
    lpWED->lpPropObj->lpVtbl->DeleteProps(lpWED->lpPropObj,
                                            lpPTA,
                                            NULL);

    if(lpPTA)
        lpWED->lpWABObject->lpVtbl->FreeBuffer(lpWED->lpWABObject,
                                                lpPTA);

    return TRUE;

}

/*//$$*********************************************************************
//
// bUpdatePropSheetData
//
// We delete any properties relevant to us from the object, and set new
// data from the property sheet onto the object
//
****************************************************************************/
BOOL bUpdatePropSheetData(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    BOOL bRet = TRUE;

    // ****Dont**** do anything if this is a READ_ONLY operation
    // In that case the memory variables are not all set up and this
    // prop sheet is not expected to return anything at all
    //
    if(!lpWED->fReadOnly)
    {
        // Delete old
        if(!UpdateOldPropTagsArray(lpWED, lpWED->nIndexNumber))
            return FALSE;

        bRet = GetDataFromUI(hDlg, lpWED);
    }
    return bRet;
}



/*//$$****************************************************************
//
// fnCallback
//
// A callback function that is called when the property sheet is created
// and when it is destroyed. This functional is optional - you dont need
// it unless you want to do specific initialization and cleanup.
//
// See SDK documentation on PropSheetPageProc for more details
//
//********************************************************************/
UINT CALLBACK fnCallback( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp )
{
    switch(uMsg)
    {
    case PSPCB_CREATE:
        // Propsheet is being created
        break;
    case PSPCB_RELEASE:
        // Propsheet is being destroyed
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtests\mutil.h ===
/***********************************************************************
 *
 * MUTIL.H
 *
 * WAB Mapi Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/

#ifdef DEBUG
void _DebugObjectProps(LPMAPIPROP lpObject, LPTSTR Label);
void _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject);
void _DebugMapiTable(LPMAPITABLE lpTable);

#define DebugObjectProps(lpObject, Label) _DebugObjectProps(lpObject, Label)
#define DebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define DebugMapiTable(lpTable) _DebugMapiTable(lpTable)

#else

#define DebugObjectProps(lpObject, Label)
#define DebugProperties(lpProps, cProps, pszObject)
#define DebugMapiTable(lpTable)

#endif

SCODE ScMergePropValues(ULONG cProps1, LPSPropValue lpSource1,
  ULONG cProps2, LPSPropValue lpSource2, LPULONG lpcPropsDest, LPSPropValue * lppDest);

#define MAPIFreeBuffer lpWABObject->FreeBuffer
#define MAPIAllocateBuffer lpWABObject->AllocateBuffer
//#define DebugTrace(x) LUIOut(L4, #x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtests\wabsub.cpp ===
#include "wabtest.h"
#include <assert.h>

#include "resource.h"
#include "..\luieng.dll\luieng.h"

extern LUIOUT LUIOut;
extern BOOL bLUIInit;

#ifdef WAB
extern LPWABOBJECT		lpWABObject; //Global handle to session
#endif

#ifdef PAB
MAPIINIT_0 mapiinit = {    
            MAPI_INIT_VERSION,
            MAPI_MULTITHREAD_NOTIFICATIONS
            };

#endif //PAB


PropTableEntry	PropTable[] = {
		PR_7BIT_DISPLAY_NAME, "PR_7BIT_DISPLAY_NAME", 0,
		PR_ACCOUNT, "PR_ACCOUNT", 0,
		PR_ADDRTYPE, "PR_ADDRTYPE", 0,
		PR_ALTERNATE_RECIPIENT, "PR_ALTERNATE_RECIPIENT", 0,
		PR_ASSISTANT, "PR_ASSISTANT", 0,
		PR_ASSISTANT_TELEPHONE_NUMBER, "PR_ASSISTANT_TELEPHONE_NUMBER", 0,
		PR_BEEPER_TELEPHONE_NUMBER, "PR_BEEPER_TELEPHONE_NUMBER", 0,
		PR_BIRTHDAY, "PR_BIRTHDAY", 0,
		PR_BUSINESS_ADDRESS_CITY, "PR_BUSINESS_ADDRESS_CITY", 0,
		PR_BUSINESS_ADDRESS_COUNTRY, "PR_BUSINESS_ADDRESS_COUNTRY", 0,
		PR_BUSINESS_ADDRESS_POST_OFFICE_BOX, "PR_BUSINESS_ADDRESS_POST_OFFICE_BOX", 0,
		PR_BUSINESS_ADDRESS_POSTAL_CODE, "PR_BUSINESS_ADDRESS_POSTAL_CODE", 0,
		PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE, "PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE", 0,
		PR_BUSINESS_ADDRESS_STREET, "PR_BUSINESS_ADDRESS_STREET", 0,
		PR_BUSINESS_FAX_NUMBER, "PR_BUSINESS_FAX_NUMBER", 0,
		PR_BUSINESS_HOME_PAGE, "PR_BUSINESS_HOME_PAGE", 0,
		PR_BUSINESS_TELEPHONE_NUMBER, "PR_BUSINESS_TELEPHONE_NUMBER", 0,
		PR_BUSINESS2_TELEPHONE_NUMBER, "PR_BUSINESS2_TELEPHONE_NUMBER", 0, 
		PR_CALLBACK_TELEPHONE_NUMBER, "PR_CALLBACK_TELEPHONE_NUMBER", 0,
		PR_CAR_TELEPHONE_NUMBER, "PR_CAR_TELEPHONE_NUMBER", 0,
		PR_CELLULAR_TELEPHONE_NUMBER, "PR_CELLULAR_TELEPHONE_NUMBER", 0,
		PR_CHILDRENS_NAMES, "PR_CHILDRENS_NAMES", 0,
		PR_COMMENT, "PR_COMMENT", 0,
		PR_COMPANY_MAIN_PHONE_NUMBER, "PR_COMPANY_MAIN_PHONE_NUMBER", 0,
		PR_COMPANY_NAME, "PR_COMPANY_NAME", 0,
		PR_COMPUTER_NETWORK_NAME, "PR_COMPUTER_NETWORK_NAME", 0,
		PR_CONTACT_ADDRTYPES, "PR_CONTACT_ADDRTYPES", 0,
		PR_CONTACT_DEFAULT_ADDRESS_INDEX, "PR_CONTACT_DEFAULT_ADDRESS_INDEX", 0,
		PR_CONTACT_EMAIL_ADDRESSES, "PR_CONTACT_EMAIL_ADDRESSES", 0,
		PR_CONTACT_ENTRYIDS, "PR_CONTACT_ENTRYIDS", 0,
		PR_CONTACT_VERSION, "PR_CONTACT_VERSION", 0,
		PR_CONVERSION_PROHIBITED, "PR_CONVERSION_PROHIBITED", 0,
		PR_COUNTRY, "PR_COUNTRY", 0,
		PR_CUSTOMER_ID, "PR_CUSTOMER_ID", 0,
		PR_DEPARTMENT_NAME, "PR_DEPARTMENT_NAME", 0,
		PR_DISCLOSE_RECIPIENTS, "PR_DISCLOSE_RECIPIENTS", 0,
		PR_DISPLAY_NAME, "PR_DISPLAY_NAME", 0,
		PR_DISPLAY_NAME_PREFIX, "PR_DISPLAY_NAME_PREFIX", 0,
		PR_EMAIL_ADDRESS, "PR_EMAIL_ADDRESS", 0,
		PR_ENTRYID, "PR_ENTRYID", 0,
		PR_FTP_SITE, "PR_FTP_SITE", 0,
		PR_GENDER, "PR_GENDER", 0,
		PR_GENERATION, "PR_GENERATION", 0,
		PR_GIVEN_NAME, "PR_GIVEN_NAME", 0,
		PR_GOVERNMENT_ID_NUMBER, "PR_GOVERNMENT_ID_NUMBER", 0,
		PR_HOBBIES, "PR_HOBBIES", 0,
		PR_HOME_ADDRESS_CITY, "PR_HOME_ADDRESS_CITY", 0,
		PR_HOME_ADDRESS_COUNTRY, "PR_HOME_ADDRESS_COUNTRY", 0,
		PR_HOME_ADDRESS_POST_OFFICE_BOX, "PR_HOME_ADDRESS_POST_OFFICE_BOX", 0,
		PR_HOME_ADDRESS_POSTAL_CODE, "PR_HOME_ADDRESS_POSTAL_CODE", 0,
		PR_HOME_ADDRESS_STATE_OR_PROVINCE, "PR_HOME_ADDRESS_STATE_OR_PROVINCE", 0,
		PR_HOME_ADDRESS_STREET, "PR_HOME_ADDRESS_STREET", 0,
		PR_HOME_FAX_NUMBER, "PR_HOME_FAX_NUMBER", 0,
		PR_HOME_TELEPHONE_NUMBER, "PR_HOME_TELEPHONE_NUMBER", 0,
		PR_HOME2_TELEPHONE_NUMBER, "PR_HOME2_TELEPHONE_NUMBER", 0,
		PR_INITIALS, "PR_INITIALS", 0,
		PR_ISDN_NUMBER, "PR_ISDN_NUMBER", 0,
		PR_KEYWORD, "PR_KEYWORD", 0,
		PR_LANGUAGE, "PR_LANGUAGE", 0,
		PR_LOCALITY, "PR_LOCALITY", 0,
		PR_LOCATION, "PR_LOCATION", 0,
		PR_MAIL_PERMISSION, "PR_MAIL_PERMISSION", 0,
		PR_MANAGER_NAME, "PR_MANAGER_NAME", 0,
		PR_MHS_COMMON_NAME, "PR_MHS_COMMON_NAME", 0,
		PR_MIDDLE_NAME, "PR_MIDDLE_NAME", 0,
		PR_MOBILE_TELEPHONE_NUMBER, "PR_MOBILE_TELEPHONE_NUMBER", 0,
		PR_NICKNAME, "PR_NICKNAME", 0,
		PR_OBJECT_TYPE, "PR_OBJECT_TYPE", 0,
		PR_OFFICE_LOCATION, "PR_OFFICE_LOCATION", 0,
		PR_OFFICE_TELEPHONE_NUMBER, "PR_OFFICE_TELEPHONE_NUMBER", 0,
		PR_OFFICE2_TELEPHONE_NUMBER, "PR_OFFICE2_TELEPHONE_NUMBER", 0,
		PR_ORGANIZATIONAL_ID_NUMBER, "PR_ORGANIZATIONAL_ID_NUMBER", 0,
		PR_ORIGINAL_DISPLAY_NAME, "PR_ORIGINAL_DISPLAY_NAME", 0,
		PR_ORIGINAL_ENTRYID, "PR_ORIGINAL_ENTRYID", 0,
		PR_ORIGINAL_SEARCH_KEY, "PR_ORIGINAL_SEARCH_KEY", 0,
		PR_OTHER_ADDRESS_CITY, "PR_OTHER_ADDRESS_CITY", 0,
		PR_OTHER_ADDRESS_COUNTRY, "PR_OTHER_ADDRESS_COUNTRY", 0,
		PR_OTHER_ADDRESS_POST_OFFICE_BOX, "PR_OTHER_ADDRESS_POST_OFFICE_BOX", 0,
		PR_OTHER_ADDRESS_POSTAL_CODE, "PR_OTHER_ADDRESS_POSTAL_CODE", 0,
		PR_OTHER_ADDRESS_STATE_OR_PROVINCE, "PR_OTHER_ADDRESS_STATE_OR_PROVINCE", 0,
		PR_OTHER_ADDRESS_STREET,"PR_OTHER_ADDRESS_STREET", 0,
		PR_OTHER_TELEPHONE_NUMBER, "PR_OTHER_TELEPHONE_NUMBER", 0,
		PR_PAGER_TELEPHONE_NUMBER, "PR_PAGER_TELEPHONE_NUMBER", 0,
		PR_PERSONAL_HOME_PAGE, "PR_PERSONAL_HOME_PAGE", 0,
		PR_POST_OFFICE_BOX, "PR_POST_OFFICE_BOX", 0,
		PR_POSTAL_ADDRESS, "PR_POSTAL_ADDRESS", 0,
		PR_POSTAL_CODE, "PR_POSTAL_CODE", 0,
		PR_PREFERRED_BY_NAME, "PR_PREFERRED_BY_NAME", 0,
		PR_PRIMARY_FAX_NUMBER, "PR_PRIMARY_FAX_NUMBER", 0,
		PR_PRIMARY_TELEPHONE_NUMBER, "PR_PRIMARY_TELEPHONE_NUMBER", 0,
		PR_PROFESSION, "PR_PROFESSION", 0,
		PR_RADIO_TELEPHONE_NUMBER, "PR_RADIO_TELEPHONE_NUMBER", 0,
		PR_SEND_RICH_INFO, "PR_SEND_RICH_INFO", 0,
		PR_SPOUSE_NAME, "PR_SPOUSE_NAME", 0,
		PR_STATE_OR_PROVINCE, "PR_STATE_OR_PROVINCE", 0,
		PR_STREET_ADDRESS, "PR_STREET_ADDRESS", 0,
		PR_SURNAME, "PR_SURNAME", 0,
		PR_TELEX_NUMBER, "PR_TELEX_NUMBER", 0,
		PR_TITLE, "PR_TITLE", 0,
		PR_TRANSMITABLE_DISPLAY_NAME, "PR_TRANSMITABLE_DISPLAY_NAME", 0, 
		PR_TTYTDD_PHONE_NUMBER, "PR_TTYTDD_PHONE_NUMBER", 0,
		PR_USER_CERTIFICATE, "PR_USER_CERTIFICATE", 0,
		PR_WEDDING_ANNIVERSARY, "PR_WEDDING_ANNIVERSARY", 0,
		PR_USER_X509_CERTIFICATE, "PR_USER_X509_CERTIFICATE", 0,

		(ULONG)0, "End of Table", 0
	};



HRESULT OpenPABID(  IN  LPADRBOOK  lpAdrBook,
                        OUT ULONG		*lpcbEidPAB,
                        OUT LPENTRYID	*lppEidPAB,
                        OUT LPABCONT	*lppPABCont,
						OUT ULONG		*lpulObjType)
{
    HRESULT     hr          = hrSuccess;
	int retval = TRUE;

    *lpulObjType = 0;

    if ( (NULL == lpcbEidPAB) || 
         (NULL == lppEidPAB) ||
         (NULL == lppPABCont) ) 
         return(FALSE);

    *lpcbEidPAB = 0;
    *lppEidPAB  = NULL;
    *lppPABCont = NULL;


    //
    // Get the PAB
    //
    hr = lpAdrBook->GetPAB(    
                     OUT lpcbEidPAB,
                     OUT lppEidPAB);
     
    if (HR_FAILED(hr)) {
		 retval = FALSE;
         goto out;
	}
    
    if (0 == *lpcbEidPAB)  //There is no PAB associated with this profile
	{
		LUIOut(L2, "Call to GetPAB FAILED. No PAB associated with this profile"); 
		retval = FALSE;
        goto out;
	}
     
    
    //
    // Open the PAB Container
    //
    hr = lpAdrBook->OpenEntry(
                     IN	 *lpcbEidPAB,
                     IN	 *lppEidPAB,
                     IN	 NULL,         //interface
                     IN	 MAPI_MODIFY,   //flags
                     OUT lpulObjType,
                     OUT (LPUNKNOWN *) lppPABCont);
     
    if (0 == *lpulObjType) {
		retval = FALSE;
        goto out;
	}

out:
    return(retval); 
}


#ifdef PAB
BOOL MapiInitLogon(OUT LPMAPISESSION * lppMAPISession)
{

    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;
	char szProfileName[SML_BUF];

	hr = MAPIInitialize(IN & mapiinit); 
	

    if (hr)
    {
	   if (FAILED (GetScode(hr))) {
			LUIOut(L1,"Could not initialize MAPI\n");
			retval=FALSE;
	   }
    }

	szProfileName[0]='\0';
	GetPrivateProfileString("Misc","Profile","",szProfileName,SML_BUF,"c:\\pabtests.ini");

     sc = MAPILogonEx(
                IN  0,                 //window handle
                IN  szProfileName,   //Profile Name
                IN  NULL,              //Password
                IN  MAPI_NEW_SESSION | 
                    MAPI_EXTENDED | 
                    MAPI_LOGON_UI |
                    MAPI_EXPLICIT_PROFILE |
					MAPI_ALLOW_OTHERS |
					MAPI_NO_MAIL,      //Flags
                OUT lppMAPISession);   //Session Pointer address
     
     if (FAILED(sc))
     {
        hr = ResultFromScode(sc);
        LUIOut(L1,"Could not start MAPI Session");
		retval=FALSE;
     }
	 return retval;
}

#endif //PAB

BOOL GetPropsFromIniBufEntry(LPSTR EntryBuf,ULONG cValues, char (*EntProp)[BIG_BUF])
{
//char szTemp[BIG_BUF];
int j=0;
	if (EntryBuf) {	
		for (int i = 0; i < (int)cValues; i++) {
			if ((*EntryBuf) == '"') {
				EntryBuf++;
			}
			j=0;
			while ((*EntryBuf)&&((*EntryBuf) != '"')&&(j< BIG_BUF-1)) {

				EntProp[i][j]= *EntryBuf;
				j++; EntryBuf++;
			}
			EntProp[i][j]='\0'; 
			if (*EntryBuf) EntryBuf++;
			if ((*EntryBuf)&&((*EntryBuf) == ',')) EntryBuf++;
		}
		return TRUE;
	}
	else {
		for (int i = 0; i < (int)cValues; i++) {
			EntProp[i][0]=0;
		}
		return FALSE;
	}
}


HRESULT HrCreateEntryListFromID(
					IN LPWABOBJECT lpLocalWABObject,
                    IN ULONG cbeid,                     // count of bytes in Entry ID
                    IN LPENTRYID lpeid,                 // pointer to Entry ID
                    OUT LPENTRYLIST FAR *lppEntryList)  // pointer to address variable of Entry
                                                        // list
{
    HRESULT hr              = NOERROR;
    SCODE   sc              = 0;
    LPVOID  lpvSBinaryArray = NULL;
    LPVOID  lpvSBinary      = NULL;
    LPVOID  lpv             = NULL;

    
    if (NULL == lppEntryList) return(FALSE);

    *lppEntryList = NULL;


#ifdef PAB
    sc = MAPIAllocateBuffer(cbeid, &lpv);                  
#endif
#ifdef WAB
    sc = lpLocalWABObject->AllocateBuffer(cbeid, &lpv);                  
#endif


    if(FAILED(sc))                           
    {                                                   
        hr = ResultFromScode(sc);
        goto cleanup;
    }                                                   

  
    // Copy entry ID
    CopyMemory(lpv, lpeid, cbeid);


#ifdef PAB
    sc = MAPIAllocateBuffer(sizeof(SBinary), &lpvSBinary);
#endif
#ifdef WAB
    sc = lpLocalWABObject->AllocateBuffer(sizeof(SBinary), &lpvSBinary);
#endif

    if(FAILED(sc))                           
    {                                                   
        hr = ResultFromScode(sc);
        goto cleanup;
    }                                                   

    // Initialize SBinary structure
    ZeroMemory(lpvSBinary, sizeof(SBinary));

    ((LPSBinary)lpvSBinary)->cb = cbeid;
    ((LPSBinary)lpvSBinary)->lpb = (LPBYTE)lpv;

#ifdef PAB
	sc = MAPIAllocateBuffer(sizeof(SBinaryArray), &lpvSBinaryArray);
#endif
#ifdef WAB
	sc = lpLocalWABObject->AllocateBuffer(sizeof(SBinaryArray), &lpvSBinaryArray);
#endif

    if(FAILED(sc))                           
    {                                                   
        hr = ResultFromScode(sc);
        goto cleanup;
    }                                                   

    // Initialize SBinaryArray structure
    ZeroMemory(lpvSBinaryArray, sizeof(SBinaryArray));

    ((SBinaryArray *)lpvSBinaryArray)->cValues = 1;
    ((SBinaryArray *)lpvSBinaryArray)->lpbin = (LPSBinary)lpvSBinary;

    *lppEntryList = (LPENTRYLIST)lpvSBinaryArray;

cleanup:

    if (HR_FAILED(hr))
    {
#ifdef PAB
        if (lpv)
            MAPIFreeBuffer(lpv);
        
        if (lpvSBinary)
            MAPIFreeBuffer(lpvSBinary);

        if (lpvSBinaryArray)
            MAPIFreeBuffer(lpvSBinaryArray);
#endif
#ifdef WAB
        if (lpv)
            lpLocalWABObject->FreeBuffer(lpv);
        
        if (lpvSBinary)
            lpLocalWABObject->FreeBuffer(lpvSBinary);

        if (lpvSBinaryArray)
            lpLocalWABObject->FreeBuffer(lpvSBinaryArray);
#endif
    }

    return(hr);

}



HRESULT HrCreateEntryListFromRows(
			IN LPWABOBJECT lpLocalWABObject,
			IN LPSRowSet far* lppRows,
			OUT LPENTRYLIST FAR *lppEntryList)  // pointer to address variable of Entry
                                                // list
{	LPSRowSet		lpRows = *lppRows;
    HRESULT			hr              = NOERROR;
    SCODE			sc              = 0;
    SBinaryArray*	lpvSBinaryArray = NULL;
	ULONG			Rows			= lpRows->cRows;
	unsigned int	PropIndex;					
	ULONG			cb;
	LPENTRYID		lpb;


    
    if (NULL == lppEntryList) return(FALSE);

    *lppEntryList = NULL;
	if (lpRows) {
		// Allocate the SBinaryArray
		sc = lpLocalWABObject->AllocateBuffer(sizeof(SBinaryArray), (void**)&lpvSBinaryArray);
		if(FAILED(sc))                           
		{   
			LUIOut(L2, "HrCreateEntryListFromRows: Unable to allocate memory for the SBinaryArray.");
			hr = ResultFromScode(sc);
			goto cleanup;
		}                                                   
		// Initialize SBinaryArray structure
		ZeroMemory(lpvSBinaryArray, sizeof(SBinaryArray));
		lpvSBinaryArray->cValues = Rows;
		
		// Allocate the SBinary structures
		sc = lpLocalWABObject->AllocateBuffer((Rows*sizeof(SBinary)), (void**)&lpvSBinaryArray->lpbin);
		if(FAILED(sc))                           
		{                                                   
			LUIOut(L2, "HrCreateEntryListFromRows: Unable to allocate memory for the SBinary structures.");
			hr = ResultFromScode(sc);
			goto cleanup;
		}                                                   
		// Initialize SBinary structure
		ZeroMemory(lpvSBinaryArray->lpbin, (Rows*sizeof(SBinary)));
		FindPropinRow(&lpRows->aRow[0],			// Find which column has the EID 
					  PR_ENTRYID,
					  &PropIndex);
		
		// Walk through the rows, allocate the lpb and copy over each cbeid and lpb into the entrylist
		for (ULONG Row = 0; Row < Rows; Row++) {
			cb = lpRows->aRow[Row].lpProps[PropIndex].Value.bin.cb,
			lpb = (ENTRYID*)lpRows->aRow[Row].lpProps[PropIndex].Value.bin.lpb,
			sc = lpLocalWABObject->AllocateBuffer(cb, (void**)&(lpvSBinaryArray->lpbin[Row].lpb));
			if(FAILED(sc))                           
			{                                                   
				LUIOut(L2, "HrCreateEntryListFromRows: Unable to allocate memory for the SBinary->lpb.");
				hr = ResultFromScode(sc);
				goto cleanup;
			}                                                   
		    // Copy entry ID
		    lpvSBinaryArray->lpbin[Row].cb = cb;
		    CopyMemory(lpvSBinaryArray->lpbin[Row].lpb, lpb, cb);
		}
	    *lppEntryList = (LPENTRYLIST)lpvSBinaryArray;
		return TRUE;
	}
	return FALSE;

cleanup:

    if (HR_FAILED(hr))
    {
		for (ULONG Kill=0; Kill<Rows; Kill++) {
			if (lpvSBinaryArray->lpbin[Kill].lpb)
            lpLocalWABObject->FreeBuffer(lpvSBinaryArray->lpbin[Kill].lpb);
			lpvSBinaryArray->lpbin[Kill].lpb = NULL;
		}
        
        if (lpvSBinaryArray->lpbin)
            lpLocalWABObject->FreeBuffer(lpvSBinaryArray->lpbin);

        if (lpvSBinaryArray)
            lpLocalWABObject->FreeBuffer(lpvSBinaryArray);
    }

    return(hr);

}


BOOL FreeEntryList(IN LPWABOBJECT lpLocalWABObject,
				   IN LPENTRYLIST *lppEntryList) // pointer to address variable of Entry
														// list
{	LPENTRYLIST	lpEntryList = *lppEntryList;

	if (lpEntryList == NULL) return FALSE;
	for (ULONG Row = 0; Row < lpEntryList->cValues; Row++) {
		if (lpEntryList->lpbin[Row].lpb)
            lpLocalWABObject->FreeBuffer(lpEntryList->lpbin[Row].lpb);
	}
        
    if (lpEntryList->lpbin)
        lpLocalWABObject->FreeBuffer(lpEntryList->lpbin);

    if (lpEntryList)
        lpLocalWABObject->FreeBuffer(lpEntryList);

	*lppEntryList = NULL;
	return TRUE;
}

BOOL FreeRows(IN LPWABOBJECT lpLocalWABObject,
			  IN LPSRowSet far* lppRows)
{	LPSRowSet lpRows = *lppRows;

#ifdef WAB
	if (lpRows) {
		for (ULONG Kill = 0; Kill < lpRows->cRows; Kill++) 
			lpLocalWABObject->FreeBuffer(lpRows->aRow[Kill].lpProps);
		lpLocalWABObject->FreeBuffer(lpRows);
		*lppRows = NULL;
#endif
		return TRUE;
	}
	return FALSE;
}
	

BOOL DisplayRows(IN LPSRowSet lpRows)
{	ULONG	Rows, Columns;
	WORD*	Key;
	if (lpRows) {
		Rows = lpRows->cRows;
		LUIOut(L2, "%u rows found.", Rows);
		for (ULONG Row = 0; Row < Rows; Row++) {
			Columns = lpRows->aRow[Row].cValues;
			LUIOut(L3, "Row %u contains %u columns.", Row, Columns);
			for (ULONG Column = 0; Column < Columns; Column++) {
				switch(lpRows->aRow[Row].lpProps[Column].ulPropTag) {
				case PR_ADDRTYPE:
					LUIOut(L3, "Column %u: PR_ADDRTYPE = %s", Column, lpRows->aRow[Row].lpProps[Column].Value.LPSZ); 
					break;
				case PR_DISPLAY_NAME:
					LUIOut(L3, "Column %u: PR_DISPLAY_NAME = %s", Column, lpRows->aRow[Row].lpProps[Column].Value.LPSZ); 
					break;
				case PR_DISPLAY_TYPE:
					switch(lpRows->aRow[Row].lpProps[Column].Value.l) {
					case DT_AGENT:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = DT_AGENT", Column); 
						break;
					case DT_DISTLIST:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = DT_DISTLIST", Column); 
						break;
					case DT_FORUM:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = DT_FORUM", Column); 
						break;
					case DT_MAILUSER:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = DT_MAILUSER", Column); 
						break;
					case DT_ORGANIZATION:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = DT_ORGANIZATION", Column); 
						break;
					case DT_PRIVATE_DISTLIST:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = DT_PRIVATE_DISTLIST", Column); 
						break;
					case DT_REMOTE_MAILUSER:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = DT_REMOTE_MAILUSER", Column); 
						break;
					default:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = UNKNOWN!! [0x%x]", Column,
								lpRows->aRow[Row].lpProps[Column].Value.l); 
					}
					break;
				case PR_ENTRYID:
					LUIOut(L3, "Column %u: PR_ENTRYID", Column); 
					break;
				case PR_INSTANCE_KEY:
					Key = (WORD*)lpRows->aRow[Row].lpProps[Column].Value.bin.lpb;
					LUIOut(L3, "Column %u: PR_INSTANCE_KEY = 0x%x%x%x%x%x%x%x%x", Column,
							Key[0],Key[2],Key[4],Key[6],Key[8],Key[10],Key[12],Key[14]); 
					break;
				case PR_OBJECT_TYPE:
					switch(lpRows->aRow[Row].lpProps[Column].Value.l) {
					case MAPI_ABCONT:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_ABCONT", Column); 
						break;
					case MAPI_ADDRBOOK:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_ADDRBOOK", Column); 
						break;
					case MAPI_ATTACH:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_ATTACH", Column); 
						break;
					case MAPI_DISTLIST:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_DISTLIST", Column); 
						break;
					case MAPI_FOLDER:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_FOLDER", Column); 
						break;
					case MAPI_FORMINFO:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_FORMINFO", Column); 
						break;
					case MAPI_MAILUSER:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_MAILUSER", Column); 
						break;
					case MAPI_MESSAGE:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_MESSAGE", Column); 
						break;
					case MAPI_PROFSECT:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_PROFSECT", Column); 
						break;
					case MAPI_STATUS:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_STATUS", Column); 
						break;
					case MAPI_STORE:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_STORE", Column); 
						break;
					default:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = UNKNOWN!! [0x%x]", Column,
								lpRows->aRow[Row].lpProps[Column].Value.l); 
					}
					break;
				case PR_RECORD_KEY:
					LUIOut(L3, "Column %u: PR_RECORD_KEY", Column); 
					break;
				default:
					LUIOut(L3, "Column %u: Property tag UNKNOWN!! [0x%x]", Column,
							lpRows->aRow[Row].lpProps[Column].ulPropTag); 
				}
			}
		}
		return TRUE;
	}
	return FALSE;
}
	


BOOL ValidateAdrList(LPADRLIST lpAdrList, ULONG cEntries)
{
	int         i           = 0;
	int         idx         = 0;
	int         cMaxProps   = 0;

	for(i=0; i<(int) cEntries; ++i)
	{
	cMaxProps = (int)lpAdrList->aEntries[i].cValues;
	//Check to see if Email Address Type exists
	idx=0;
	while(lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ADDRTYPE )
	{
		idx++;
		if(idx == cMaxProps) {
			LUIOut(L4, "PR_ADDRTYPE was not found in the lpAdrList");
			return FALSE;
		}
	}

	//Check to see if Email Address exists
	idx=0;
	while(lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_OBJECT_TYPE )
	{
		idx++;
		if(idx == cMaxProps) {
			LUIOut(L4, "PR_OBJECT_TYPE was not found in the lpAdrList");
			return FALSE;
		}
	}

	//Check to see if Email Address exists
	idx=0;
	while(lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_TYPE )
	{
		idx++;
		if(idx == cMaxProps) {
			LUIOut(L4, "PR_DISPLAY_TYPE was not found in the lpAdrList");
			return FALSE;
		}
	}
	
	//Check to see if Display Name exists
	idx=0;
	while(lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_NAME )
	{
		idx++;
		if(idx == cMaxProps) {
			LUIOut(L4, "PR_DISPLAY_NAME was not found in the lpAdrList");
			return FALSE;
		}
	}
	LUIOut(L4,"Display Name: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);

	//Check to see if EntryID exists
	idx=0;
	while(lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ENTRYID )
	{
		idx++;
		if(idx == cMaxProps)	{
			LUIOut(L4, "PR_ENTRYID was not found in the lpAdrList");
			return FALSE;
		}
	}
	}
	return TRUE;
}


//
// PROCEDURE:	VerifyResolvedAdrList
// DESCRIPTION: Walk through a lpAdrList looking for PR_DISPLAY_NAME, PR_EMAIL_ADDRESS,
//				PR_ADDRTYPE, PR_ENTRYID, and PR_OBJECT_TYPE. Each EID is sanity checked
//				(lpb != NULL and cb != 0) and valid EIDs are passed to OpenEntry with
//				a MailUser interface specified. If OpenEntry succedes, we assume the EID
//				is a valid MailUser ID.
//				
// PARAMETERS:	LPADRLIST lpAdrList 
//				char* lpszInput - can be NULL to bypass match checking
//

BOOL VerifyResolvedAdrList(LPADRLIST lpAdrList, char* lpszInput)
{
	extern LPADRBOOK	glbllpAdrBook;
	int		i = 0, idx = 0, cMaxProps = 0;
	BOOL	Found = FALSE, retval = TRUE, localretval = TRUE;
	ULONG	cEntries = lpAdrList->cEntries;
	ULONG	cbLookupEID, ulObjType;
	LPENTRYID	lpLookupEID;
	HRESULT	hr;
	LPUNKNOWN	lpUnk=NULL;
	LPADRBOOK	lpAdrBook;
	LPCIID		lpcIID;
	LPVOID	Reserved1=NULL;
	DWORD	Reserved2=0;
//	LPWABOBJECT	lpWABObject2;
	

/*	kludge to work around multiple wabopen/release bug, storing adrbook ptr
	in a global variable

	hr = WABOpen(&lpAdrBook, &lpWABObject2, Reserved1, Reserved2); 
	if (hr != S_OK) {
		LUIOut(L4, "WABOpen FAILED. Couldn't obtain IAdrBook.");
		retval = FALSE;
	}

*/
#ifdef WAB
	lpAdrBook = glbllpAdrBook;
	lpAdrBook->AddRef();
#endif //WAB

	
	// Walk through each AdrList entry
	for(i=0; ((i<(int) lpAdrList->cEntries) && (!Found)); ++i)	{
		LUIOut(L3, "Searching Entry #%i out of %i", i+1, cEntries);
		cMaxProps = (int)lpAdrList->aEntries[i].cValues;
		
		//Check to see if Display Name exists
		idx=0; localretval = TRUE;
		while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_NAME )	
			&& localretval)	{
			idx++;
			if(idx == cMaxProps) {
				LUIOut(L4, "PR_DISPLAY_NAME was not found in lpAdrList entry #%i",i);
				localretval = FALSE; retval = FALSE;
				goto skip;
			}
		}
		LUIOut(L4,"Display Name: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
		if (lpszInput) {
			if (!lstrcmp(lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ,lpszInput))	{
				LUIOut(L3, "Found the entry we just added");
				Found = TRUE;
			}
			else {
				LUIOut(L3, "Did not find the entry we just added");
				retval = FALSE;
			}
		}
		
		//Check to see if EntryID exists
		LUIOut(L3, "Verifying a PR_ENTRYID entry exists in the PropertyTagArray");
		idx=0; localretval = TRUE;
		while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ENTRYID )	
			&& localretval)	{
			idx++;
			if(idx == cMaxProps)	{
				LUIOut(L4, "PR_ENTRYID was not found in the lpAdrList");
				localretval = FALSE; retval = FALSE;
				goto skip;
			}
		}
		if (idx < cMaxProps) {
			// Store EID for call to OpenEntry
			lpLookupEID = (ENTRYID*)lpAdrList->aEntries[i].rgPropVals[idx].Value.bin.lpb;
			cbLookupEID = lpAdrList->aEntries[i].rgPropVals[idx].Value.bin.cb;
			if ((cbLookupEID == 0) || (lpLookupEID == NULL)) {
				LUIOut(L4, "EntryID found, but is NULL or has size = 0. Test FAILED");
				retval = FALSE;
				goto skip;
			}
			else LUIOut(L4, "EntryID found and appears to be valid (not NULL and >0 size).");
			// Try calling OpenEntry on the returned EID specifying a mailuser interface
			LUIOut(L4, "Calling OpenEntry on the EntryID");
			lpcIID = &IID_IMailUser;
			hr = lpAdrBook->OpenEntry(cbLookupEID, lpLookupEID, lpcIID, 
					MAPI_BEST_ACCESS, &ulObjType, &lpUnk);
			switch(hr)	{
			case S_OK:
				if ((lpUnk) && (ulObjType==MAPI_MAILUSER))
					LUIOut(L4, "OpenEntry call succeded on this EntryID and returned a valid object pointer and type.");
				else	{
					LUIOut(L4, "OpenEntry call succeded on this EntryID but returned an invalid object pointer or incorrect type. Test FAILED");
					retval = FALSE;
				}
				break;
			case MAPI_E_NOT_FOUND:
				LUIOut(L4, "OpenEntry returned MAPI_E_NOT_FOUND for this EntryID. Test FAILED");
				retval = FALSE;
				break;
			case MAPI_E_UNKNOWN_ENTRYID:
				LUIOut(L4, "OpenEntry returned MAPI_E_UNKNOWN_ENTRYID for this EntryID. Test FAILED");
				retval = FALSE;
				break;
			case MAPI_E_NO_ACCESS:
				LUIOut(L4, "OpenEntry returned MAPI_E_NO_ACCESS for this EntryID. Test FAILED");
				retval = FALSE;
				break;
			default:
				LUIOut(L4, "OpenEntry returned unknown result code (0x%x) for this EntryID. Test FAILED", hr);
				retval = FALSE;
				lpUnk = NULL;
				break;
			}
		}

		//Check to see if PR_EMAIL_ADDRESS exists
		LUIOut(L3, "Verifying a PR_EMAIL_ADDRESS entry exists in the PropertyTagArray");
		idx=0; localretval = TRUE;
		while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_EMAIL_ADDRESS )	
			&& localretval)	{
			idx++;
			if(idx == cMaxProps)	{
				LUIOut(L4, "PR_EMAIL_ADDRESS was not found in the lpAdrList");
				localretval = FALSE; //retval = FALSE;
			}
		}
		if (idx < cMaxProps) {
			LUIOut(L4,"Email Address: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
		}

		//Check to see if PR_ADDRTYPE exists
		LUIOut(L3, "Verifying a PR_ADDRTYPE entry exists in the PropertyTagArray");
		idx=0; localretval = TRUE;
		while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ADDRTYPE )	
			&& localretval)	{
			idx++;
			if(idx == cMaxProps)	{
				LUIOut(L4, "PR_ADDRTYPE was not found in the lpAdrList");
				localretval = FALSE; //retval = FALSE;
			}
		}
		if (idx < cMaxProps) {
			LUIOut(L4,"Address Type: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
		}

		//Check to see if PR_OBJECT_TYPE exists
		LUIOut(L3, "Verifying a PR_OBJECT_TYPE entry exists in the PropertyTagArray");
		idx=0; localretval = TRUE;
		while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_OBJECT_TYPE )	
			&& localretval)	{
			idx++;
			if(idx == cMaxProps)	{
				LUIOut(L4, "PR_OBJECT_TYPE was not found in the lpAdrList");
				localretval = FALSE; retval = FALSE;
			}
		}
		if (idx < cMaxProps) {
			switch (lpAdrList->aEntries[i].rgPropVals[idx].Value.l) {
			case MAPI_MAILUSER: 
				LUIOut(L4, "Object Type: MAPI_MAILUSER");
				break;
			case MAPI_DISTLIST: 
				LUIOut(L4, "Object Type: MAPI_DISTLIST");
				break;
			default: 
				LUIOut(L4,"Object Type not MAILUSER or DISTLIST. Test FAILED");
			}
		}


skip:	// skip the current entry and continue through the lpAdrList
	if (lpUnk) lpUnk->Release();	//Release the object returned from OpenEntry
	}
	if (lpAdrBook) lpAdrBook->Release();
	//if (lpWABObject2) lpWABObject->Release();
	return(retval);
}

BOOL DisplayAdrList(LPADRLIST lpAdrList, ULONG cEntries)
{
	int         i           = 0;
	int         idx         = 0;
	int         cMaxProps   = 0;
	BOOL		Found, retval = TRUE;

	for(i=0; i<(int) cEntries; ++i)	{
		LUIOut(L3, "Searching Entry #%i out of %i", i+1, cEntries);
      cMaxProps = (int)lpAdrList->aEntries[i].cValues;
/*
	  //Check to see if Email Address Type exists
	  idx=0; Found = TRUE;
	  while(Found && lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ADDRTYPE )	{
	    idx++;
		if(idx == cMaxProps) {
		  LUIOut(L4, "PR_ADDRTYPE was not found in the lpAdrList");
		  Found = FALSE;
		}
	  }
	  if (Found) LUIOut(L4,"Address Type: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
	
	    //Check to see if Email Address exists
		idx=0; Found = TRUE;
		while(Found && lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_OBJECT_TYPE )	{
		  idx++;
		  if(idx == cMaxProps) {
			LUIOut(L4, "PR_OBJECT_TYPE was not found in the lpAdrList");
			Found = FALSE;
		  }
		}
		if (Found) LUIOut(L4,"Object Type: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);

	      //Check to see if display type exists
		  idx=0; Found = TRUE;
		  while(Found && lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_TYPE )	{
			idx++;
			if(idx == cMaxProps) {
			  LUIOut(L4, "PR_DISPLAY_TYPE was not found in the lpAdrList");
			  Found = FALSE;
		    }
		  }
		  if (Found) LUIOut(L4,"Display Type: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
	
*/
		//Check to see if Display Name exists
		idx=0; Found = TRUE;
		while(Found && lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_NAME )	{
		  idx++;
		  if(idx == cMaxProps) {
			LUIOut(L4, "PR_DISPLAY_NAME was not found in the lpAdrList");
			Found = FALSE;
		  }
		}
		if (Found) LUIOut(L4,"Display Name: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);

		//Check to see if EntryID exists
		idx=0; Found = TRUE;
		while(Found && lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ENTRYID )	{
			idx++;
			if(idx == cMaxProps)	{
			  LUIOut(L4, "PR_ENTRYID was not found in the lpAdrList");
			  Found = FALSE;
			}
		}
		if (Found) LUIOut(L4,"Entry ID Found");
		//Check to see if Recipient Type exists
	    idx=0; Found = TRUE;
	    while(Found && lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_RECIPIENT_TYPE )	{
			idx++;
			if(idx == cMaxProps)	{
				LUIOut(L4, "PR_RECIPIENT_TYPE was not found in the lpAdrList");
				Found = FALSE;
			}
		}
		if (Found) {
			switch((ULONG)lpAdrList->aEntries[i].rgPropVals[idx].Value.l)	{
				case MAPI_TO:	{
					LUIOut(L4, "Recipient Type: [TO:]");
					break;
				}
				case MAPI_CC:	{
					LUIOut(L4, "Recipient Type: [CC:]");
					break;
				}
				case MAPI_BCC:	{
					LUIOut(L4, "Recipient Type: [BCC:]");
					break;
				}
				default:	{
					LUIOut(L4, "Recipient Type: [UNKNOWN]. Test FAILED");
				}
			}
		}
	}
	return retval;
}



BOOL LogIt(HRESULT hr, int Level,char * LogString)
{
	switch (Level) {

		case 0: 
			if (HR_FAILED(hr)) {
				LUIOut(LFAIL, "%s",LogString);
				return FALSE;
			}
			else LUIOut(LPASS,"%s",LogString);
			return TRUE;

		case 1: 
			if (HR_FAILED(hr)) {
				LUIOut(LFAIL1, "%s",LogString);
				return FALSE;
			}
			else LUIOut(LPASS1,"%s",LogString);
			return TRUE;
		case 2: 
			if (HR_FAILED(hr)) {
				LUIOut(LFAIL2, "%s",LogString);
				return FALSE;
			}
			else LUIOut(LPASS2,"%s",LogString);
			return TRUE;
		
		case 3: 
			if (HR_FAILED(hr)) {
				LUIOut(LFAIL3, "%s",LogString);
				return FALSE;
			}
			else LUIOut(LPASS3,"%s",LogString);
			return TRUE;

		case 4: 
			if (HR_FAILED(hr)) {
				LUIOut(LFAIL4, "%s",LogString);
				return FALSE;
			}
			else LUIOut(LPASS4,"%s",LogString);
			return TRUE;

		default: break;
	}
	if (HR_FAILED(hr)) {
			LUIOut(LFAIL2, "%s",LogString);
			return FALSE;
	}
	else LUIOut(LPASS2,"%s",LogString);
	return TRUE;
}

//
// PROCEDURE:	AllocateAdrList
// DESCRIPTION: Uses either MAPI or WAB allocaters to allocate an lpAdrList
//				
// PARAMETERS:	LPWABOBJECT lpLocalWABObject - ptr to opened WABObject
//				int nEntries - how many AdrEntries to allocate
//				int nProps - how many properties per AdrEntry
//				LPADRLIST * lppAdrList - where to return the allocated ptr
//

BOOL AllocateAdrList(IN LPWABOBJECT lpLocalWABObject, IN int nEntries, IN int nProps, OUT LPADRLIST * lppAdrList) {
	BOOL	retval = TRUE;
	SCODE	sc;

*lppAdrList = NULL;
#ifdef PAB
    if (! (sc = MAPIAllocateBuffer(sizeof(ADRLIST) + (nEntries * sizeof(ADRENTRY)), 
		(void **)lppAdrList))) {
		(*lppAdrList)->cEntries = nEntries;
		for (int entry = 0; entry < nEntries; entry++) {
		    (*lppAdrList)->aEntries[entry].ulReserved1 = 0;
			(*lppAdrList)->aEntries[entry].cValues = nProps;
			sc = MAPIAllocateBuffer((nProps * sizeof(SPropValue)), 
				(void **)(&(*lppAdrList)->aEntries[entry].rgPropVals));
			if (sc != S_OK) retval = FALSE;
		}
	}
	else retval = FALSE;

	//
	// Should do cleanup here for a partial allocation that fails
	//

#endif //PAB
#ifdef WAB
    if (! (sc = lpLocalWABObject->AllocateBuffer(sizeof(ADRLIST) + (nEntries * sizeof(ADRENTRY)), 
		(void **)lppAdrList))) {
		(*lppAdrList)->cEntries = nEntries;
		for (int entry = 0; entry < nEntries; entry++) {
		    (*lppAdrList)->aEntries[entry].ulReserved1 = 0;
			(*lppAdrList)->aEntries[entry].cValues = nProps;
			sc = lpLocalWABObject->AllocateBuffer((nProps * sizeof(SPropValue)), 
				(void **)(&(*lppAdrList)->aEntries[entry].rgPropVals));
			if (sc != S_OK) retval = FALSE;
		}
	}
	else retval = FALSE;

	//
	// Should do cleanup here for a partial allocation that fails
	//
#endif //WAB
return retval;
}

//
// PROCEDURE:	GrowAdrList
// DESCRIPTION: Takes an existing lpAdrList, allocates a new, larger lpAdrList
//				, copies over the old entries and allocates new entries, returning
//				a pointer to the new AdrList in lpAdrList.
//				
// PARAMETERS:	int nEntries - how many AdrEntries to allocate in new list
//				int nProps - how many properties per new AdrEntry
//				LPADRLIST * lppAdrList - where to return the allocated ptr
//

BOOL GrowAdrList(IN UINT nEntries, IN UINT nProps, OUT LPADRLIST * lppAdrList) {
	BOOL	retval = TRUE;
	SCODE	sc;
	LPADRLIST	lpTempAdrList;
	unsigned int		entry;


	if ((!lppAdrList) || ((*lppAdrList)->cEntries>=nEntries))	
		return FALSE;

#ifdef PAB
    if (! (sc = MAPIAllocateBuffer(sizeof(ADRLIST) + (nEntries * sizeof(ADRENTRY)), 
		(void **)&lpTempAdrList))) {
		lpTempAdrList->cEntries = nEntries;
		// Copy over old entries
		entry = (*lppAdrList)->cEntries;
		memcpy(lpTempAdrList, *lppAdrList, (entry * sizeof(ADRENTRY)));
		// Allocate new entries 
		for (; entry < nEntries; entry++) {
		    lpTempAdrList->aEntries[entry].ulReserved1 = 0;
			lpTempAdrList->aEntries[entry].cValues = nProps;
			sc = MAPIAllocateBuffer((nProps * sizeof(SPropValue)), 
				(void **)(&lpTempAdrList->aEntries[entry].rgPropVals));
			if (sc != S_OK) retval = FALSE;
		}
		FreeAdrList(lppAdrList);
		*lppAdrList = lpTempAdrList;
	}
	else retval = FALSE;

	//
	// Should do cleanup here for a partial allocation that fails
	//

#endif //PAB
#ifdef WAB
    if (! (sc = lpWABObject->AllocateBuffer(sizeof(ADRLIST) + (nEntries * sizeof(ADRENTRY)), 
		(void **)&lpTempAdrList))) {
		// Copy over old entries
		entry = (*lppAdrList)->cEntries;
		memcpy(lpTempAdrList, *lppAdrList, (sizeof(ADRLIST)+(entry * sizeof(ADRENTRY))));
		lpTempAdrList->cEntries = nEntries;
		// Allocate new entries 
		for (; entry < nEntries; entry++) {
		    lpTempAdrList->aEntries[entry].ulReserved1 = 0;
			lpTempAdrList->aEntries[entry].cValues = nProps;
			sc = lpWABObject->AllocateBuffer((nProps * sizeof(SPropValue)), 
				(void **)(&lpTempAdrList->aEntries[entry].rgPropVals));
			if (sc != S_OK) retval = FALSE;
		}
		FreePartAdrList(lppAdrList);
		*lppAdrList = lpTempAdrList;
	}
	else retval = FALSE;

	//
	// Should do cleanup here for a partial allocation that fails
	//

#endif //WAB
return retval;
}


//
// PROCEDURE:	FreeAdrList
// DESCRIPTION: Uses either MAPI or WAB de-allocaters to walk and free an lpAdrList
//				
// PARAMETERS:	LPWABOBJECT lpLocalWABObject - ptr to opened WABObject
//				LPADRLIST * lppAdrList - where the lpAdrList to free is stored
//

BOOL FreeAdrList(IN LPWABOBJECT lpLocalWABObject, IN LPADRLIST * lppAdrList) {
	LPADRLIST	lpAdrList = NULL;
	UINT	idx;
	
	if (lppAdrList) lpAdrList = *lppAdrList;

#ifdef PAB
	if (lpAdrList) {
		for (idx = 0; idx < lpAdrList->cEntries; idx++)
			MAPIFreeBuffer(lpAdrList->aEntries[idx].rgPropVals);
		MAPIFreeBuffer(lpAdrList);
		*lppAdrList=NULL;
	}
#endif //PAB
#ifdef WAB
	if (lpAdrList) {
		for (idx = 0; idx < lpAdrList->cEntries; idx++)
			lpLocalWABObject->FreeBuffer(lpAdrList->aEntries[idx].rgPropVals);
		lpLocalWABObject->FreeBuffer(lpAdrList);
		*lppAdrList=NULL;
	}
#endif //WAB
	
	return TRUE;
}


//
// PROCEDURE:	FreePartAdrList
// DESCRIPTION: Uses either MAPI or WAB de-allocaters to free an lpAdrList
//				but not the associated properties.
//				
// PARAMETERS:	LPADRLIST * lppAdrList - where the lpAdrList to free is stored
//

BOOL FreePartAdrList(IN LPADRLIST * lppAdrList) {
	LPADRLIST	lpAdrList = NULL;
	
	if (lppAdrList) lpAdrList = *lppAdrList;

#ifdef PAB
	if (lpAdrList) {
		MAPIFreeBuffer(lpAdrList);
		lpAdrList=NULL;
	}
#endif //PAB
#ifdef WAB
	if (lpAdrList) {
		lpWABObject->FreeBuffer(lpAdrList);
		lpAdrList=NULL;
	}
#endif //WAB
	
	return TRUE;
}


//
// PROCEDURE:	FindProp
// DESCRIPTION: Walks through the properties of an AdrEntry and returns the index
//				of the requested property tag.
//				
// PARAMETERS:	LPADRENTRY lpAdrEntry - Entry to search through
//				ULONG ulPropTag - Property tag to look for
//				unsigned int* lpnFoundIndex - Ptr to output variable where the found index 
//				  value is to be stored. 
//
// RETURNS:		TRUE if succesfull.
//

BOOL FindProp(IN LPADRENTRY lpAdrEntry, IN ULONG ulPropTag, OUT unsigned int* lpnFoundIndex) {

	if ((!lpAdrEntry) || (!ulPropTag) || (!lpnFoundIndex)) return(FALSE);
	
	for (unsigned int Counter1 = 0; Counter1 < lpAdrEntry->cValues; Counter1++) {
		if (lpAdrEntry->rgPropVals[Counter1].ulPropTag == ulPropTag) {
			*lpnFoundIndex = Counter1;
			return(TRUE);
		}
	}
	return(FALSE);
}


//
// PROCEDURE:	FindPropinRow
// DESCRIPTION: Walks through the properties of an SRowSet and returns the index
//				of the requested property tag.
//				
// PARAMETERS:	LPSRow lpRow - Row to search through
//				ULONG ulPropTag - Property tag to look for
//				unsigned int* lpnFoundIndex - Ptr to output variable where the found index 
//				  value is to be stored. 
//
// RETURNS:		TRUE if succesfull.
//

BOOL FindPropinRow(IN LPSRow lpRow, IN ULONG ulPropTag, OUT unsigned int* lpnFoundIndex) {

	if ((!lpRow) || (!ulPropTag) || (!lpnFoundIndex)) return(FALSE);
	

	for (ULONG Column = 0; Column < lpRow->cValues; Column++) {
		if (lpRow->lpProps[Column].ulPropTag == ulPropTag) {
			*lpnFoundIndex = Column;
			return(TRUE);
		}
	}
	return(FALSE);
}




//
// PROCEDURE:	ParseIniBuffer
// DESCRIPTION: Walks through a buffer read from an ini file which contains
//				several strings separated by quotation marks and copies the
//				requested string to the users buffer.
//				
// PARAMETERS:	LPSTR	lpszIniBuffer
//				UINT	uSelect - which string (in order left to right starting with 1 ) to return
//				LPSTR	lpszReturnBuffer - pre-alocated by caller and dumb (assumes enough space)
//

BOOL ParseIniBuffer(LPSTR lpszIniBuffer, UINT uSelect, LPSTR lpszReturnBuffer) {
	UINT	Selected = 0;

	// while (*(lpszIniBuffer++) != '"');	// Advance to first entry 
	// lpszIniBuffer++; 
	Selected++;		// Now pointing at 1st letter of first item
	while(uSelect != Selected++) {
		while (*(lpszIniBuffer++) != '"');	// Advance to end of this entry 
		while (*(lpszIniBuffer++) != '"');	// Advance to beginning of next entry 
		// Now we are pointing at the 1st letter of the desired entry so copy
	}
	while((*(lpszIniBuffer) != '"') && (*(lpszIniBuffer) != '\0')) {
		*(lpszReturnBuffer++) = *lpszIniBuffer++;
	}
	*lpszReturnBuffer = '\0';	// Add the terminator
	return(TRUE);
}
		

//
// PROCEDURE:	PropError
// DESCRIPTION: Compares the passed in property type with PT_ERROR returning TRUE is error is found
//				
// PARAMETERS:	ulPropTag - Tag to compare
//				cValues - # of entries returned from GetProps
//

BOOL PropError(ULONG ulPropTag, ULONG cValues) {
	BOOL retval = FALSE;
#ifdef DISTLISTS
	for(ULONG Counter = 0; Counter < cValues; Counter++) {
		if (PROP_TYPE(ulPropTag) == PT_ERROR) retval = TRUE;
	}
#endif
	return retval;
}

//
// PROCEDURE:	DeleteWABFile
// DESCRIPTION: Reads the registry to determine the location of the WAB file,
//				and deletes the file.
//				
// PARAMETERS:	none
//

BOOL DeleteWABFile () {
	BOOL	retval = TRUE;
	long	lretval;
	HKEY	hKey;
	char	KeyAddress[] = "Software\\Microsoft\\WAB\\Wab File Name";
	DWORD	dType, dSize = 256;
	char	achData[256];

	if (!MyRegOpenKeyEx(HKEY_CURRENT_USER, 
						   KeyAddress, 
						   KEY_QUERY_VALUE, 
						   &hKey)) {
		LUIOut(L2, "MyRegOpenKeyEx call failed");
		retval = FALSE;
		return(retval);
	}

	
	lretval = RegQueryValueEx(hKey,					// handle of key to query 
							  NULL,					// address of name of value to query 
							  (LPDWORD)NULL,		// reserved 
							  &dType,				// address of buffer for value type 
							  (LPBYTE)achData,		// address of data buffer 
							  &dSize	 			// address of data buffer size 
							 );				 

	if (lretval != ERROR_SUCCESS) {
		LUIOut(L2, "RegQueryValueEx call failed with error code %u", lretval);
		retval = FALSE;
		return(retval);
	}

	LUIOut(L2, "Deleting WAB file: %s", achData);

	RegCloseKey(hKey);

	if (!DeleteFile(achData)) {
		LUIOut(L3, "Delete FAILED. Could not locate or delete file.");			
		retval = FALSE;
	}

	return(retval);
}

//
// PROCEDURE:	MyRegOpenKeyEx
// DESCRIPTION: Walks through a null terminated string, such as "\Software\Microsoft\WAB"
//				openning each key until it reaches the end and returns that open key (closing
//				the interim keys along the way). The caller must close the returned HKEY.
//				
// PARAMETERS:	StartKey - one of the predefined "open" keys to root at
//				szAddress - null terminated string specifcying the path to the key to be opened
//				RegSec - the security access required (i.e. KEY_READ)
//				lpReturnKey - address of HKEY where final opened key is stored
//

BOOL MyRegOpenKeyEx(HKEY StartKey, char* szAddress, REGSAM RegSec, HKEY* lpReturnKey) {
	HKEY	workkey1, workkey2, *lpOpenKey=&workkey1, *lpNewKey=&workkey2;
	char	workbuffer[256], *lpAddr = szAddress, *lpWork = workbuffer;
	BOOL	Started = FALSE, Done = FALSE;
	long	lretval;

	if (!szAddress) return FALSE;

	while (!Done) {
		if (*lpAddr == '\\') lpAddr++;		//skip over the initial backslash if it exists
		while((*(lpAddr) != '\\') && (*(lpAddr) != '\0')) {
			*(lpWork++) = *lpAddr++;
		}
		*lpWork = '\0';						// Add the terminator
		if (*(lpAddr) == '\0') Done = TRUE;
		lpWork = workbuffer;
		if (!Started) {
			//
			// First, special case the starting key (predefined/open key root)
			//
			lretval = RegOpenKeyEx(	StartKey, 
									lpWork, 
									DWORD(0), 
									RegSec, 
									lpOpenKey);
			Started = TRUE;
		}
		else {
			lretval = RegOpenKeyEx(	*lpOpenKey, 
									lpWork, 
									DWORD(0), 
									RegSec, 
									lpNewKey);
			RegCloseKey(*lpOpenKey);
			*lpOpenKey = *lpNewKey;
		}
		if (lretval != ERROR_SUCCESS) {
			LUIOut(L2, "RegOpenKeyEx call failed with error code 0x%x", lretval);
			return(FALSE);
		}

	}

		*lpReturnKey = *lpNewKey;
		return(TRUE);
}

//
// PROCEDURE:	CreateMultipleEntries
// DESCRIPTION: Creates multiple entries in the WAB using the display name stored in the
//				pabtests.ini file CreateEntriesStress section.
//				
// PARAMETERS:	NumEntriesIn - how many entries to create. If 0, then the value is read
//				from the same CreateEntriesStress section.
//				lpPerfData - address of a dword data type to hold the average time in milliseconds
//				required during SaveChanges. If NULL perf data is not accumulated.
//

BOOL CreateMultipleEntries(IN UINT NumEntriesIn, DWORD* lpPerfData)
{
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;
	DWORD	StartTime, StopTime;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpABCont= NULL;
	ULONG		  cbEidPAB = 0;
	LPENTRYID	  lpEidPAB   = NULL;

    char	EntProp[10][BIG_BUF];  //MAX_PROP
	ULONG   cValues = 0, ulObjType=NULL;	
	int i=0,k=0;
	char EntryBuf[MAX_BUF];
	char szDLTag[SML_BUF];
	unsigned int	NumEntries, counter, StrLen;
	
    LPMAILUSER  lpMailUser=NULL,lpDistList=NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.

    LPSPropValue lpSPropValueAddress = NULL;
	LPSPropValue lpSPropValueDL = NULL;

    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
	
	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	// Wipe perfdata if we're tracking this
	if (lpPerfData) *lpPerfData = (DWORD)0;
	// 
	// Try to create a MailUser entry in the container
	//


	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}
        
    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //

	// Retrieve user info from ini file
	cValues = 3; //# of props we are setting 
	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("CreateEntriesStress",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
	StrLen = (strlen(EntProp[0]));
	_itoa(0,(char*)&EntProp[0][StrLen],10);
	EntProp[0][StrLen+1]= '\0';
	NumEntries = (NumEntriesIn > 0) ? 
		NumEntriesIn:GetPrivateProfileInt("CreateEntriesStress","NumCopies",0,INIFILENAME);

	if (NumEntries > 100)
		LUIOut(L2, "Adding %u MailUser entries to the WAB. This may take several minutes.", NumEntries);
	for (counter = 0; counter < NumEntries; counter++)	{ 
//		LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
		hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);
     
		if (HR_FAILED(hr)) {
			LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
			retval=FALSE;			
			goto out;
		}

		//  
		// Then set the properties
		// 

		PropValue[0].ulPropTag  = PR_DISPLAY_NAME;
		PropValue[1].ulPropTag  = PR_ADDRTYPE;
		PropValue[2].ulPropTag  = PR_EMAIL_ADDRESS;

     
			
		_itoa(counter,(char*)&EntProp[0][StrLen],10);
//		LUIOut(L2,"MailUser Entry to Add: %s",EntProp[0]);
			
		for (i=0; i<(int)cValues;i++)
			PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
		hr = lpMailUser->SetProps(IN  cValues,
								 IN  PropValue,
								 IN  NULL);
			
		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 		retval=FALSE;			
			goto out;
		} 
//		else 	LUIOut(L3,"MailUser->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

		StartTime = GetTickCount();
		hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags
		StopTime = GetTickCount();
/*		if (lpPerfData) {
			if ((StopTime-StartTime) > *lpPerfData)
				*lpPerfData = (StopTime - StartTime);
		}
*/
		if (lpPerfData) {
			*lpPerfData += (StopTime - StartTime);
		}

		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SaveChanges FAILED");
			retval=FALSE;
			goto out;
		}
//		else LUIOut(L3,"MailUser->SaveChanges PASSED, entry added to PAB/WAB");

		if (lpMailUser) {
			lpMailUser->Release();
			lpMailUser = NULL;
		}

	}
	if (lpPerfData)
		*lpPerfData /= NumEntries;


out:
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB) 
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress); 

		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL); 

#endif
#ifdef WAB
		if (lpEidPAB) 
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress); 

		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL); 

#endif
		if (lpMailUser)
			lpMailUser->Release();

		if (lpDistList)
			lpDistList->Release();

		if (lpABCont) 
				lpABCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject) {
			lpWABObject->Release();
			lpWABObject = NULL;
		}
#endif

		return retval;    
}

void GenerateRandomPhoneNumber(char **lppPhone) {
#define FORMATSIZE 15	// Size of formatted phone# + terminator i.e. (206)-882-8080
#define MAXNUMSIZE (FORMATSIZE + 32)
	unsigned int	Offset = 0;
	extern BOOL Seeded; 
	*lppPhone = (char*)LocalAlloc(LMEM_FIXED, MAXNUMSIZE*sizeof(char));
	(*lppPhone)[0] = '\0';		// Set the first char to a terminator
	
	// seed the random number generator with the current time
	if (!Seeded) {
		srand( (unsigned)GetTickCount());
		Seeded = TRUE; 
	}
	while (Offset < FORMATSIZE) {
		_itoa(rand(), ((*lppPhone)+Offset), 10);
		Offset = strlen(*lppPhone);
	}
	// Overwrite some numbers with formatting characters
	(*lppPhone)[0] = '(';
	(*lppPhone)[4] = ')';
	(*lppPhone)[5] = '-';
	(*lppPhone)[9] = '-';
	(*lppPhone)[FORMATSIZE-1] = '\0';	//Cutoff the end in case it's > FORMATSIZE
}

void GenerateRandomText(char **lppText, UINT unSize) {
	unsigned int	Offset = 0;
	extern BOOL Seeded; 
	extern ULONG glblTest, glblCount, glblDN;
	*lppText = (char*)LocalAlloc(LMEM_FIXED, (unSize+1)*sizeof(char));
	
	// seed the random number generator with the current time
	if (!Seeded) {
		srand( (unsigned)GetTickCount());
		Seeded = TRUE; 
	}
#ifdef TESTPASS
	for (Offset = 0; Offset < unSize; Offset++) {
		(*lppText)[Offset] = (char)glblTest;
		if ((*lppText)[Offset] == '\0') (*lppText)[Offset] = (char)'?';	//don't want a terminator mid string
	}
	(*lppText)[unSize] = '\0';	//Cutoff the end 
	if (glblDN) {
		glblDN = 0;
		if (++glblCount == 15) {
			glblTest++;
			glblCount=0;
			LUIOut(L4, "Testing value %i [%c].", glblTest, glblTest);
		}
	}
#else
	for (Offset = 0; Offset < unSize; Offset++) {
		(*lppText)[Offset] = rand();
		if ((*lppText)[Offset] == '\0') (*lppText)[Offset] = (char)'?';	//don't want a terminator mid string
	}
	(*lppText)[unSize] = '\0';	//Cutoff the end 
#endif
}

void GenerateRandomBoolean(unsigned short *lpBool) {
	extern BOOL Seeded; 
	
	// seed the random number generator with the current time
	if (!Seeded) {
		srand( (unsigned)GetTickCount());
		Seeded = TRUE; 
	}

	*lpBool = (unsigned short)(GetTickCount() & 0x01); //If bit 0 is set then true otherwise false
}

void GenerateRandomLong(long *lpLong) {
	extern BOOL Seeded; 

	// seed the random number generator with the current time
	if (!Seeded) {
		srand( (unsigned)GetTickCount());
		Seeded = TRUE; 
	}
	*lpLong = (long)rand();
}

void GenerateRandomBinary(SBinary *lpBinary, UINT unSize) {
	unsigned int	Offset = 0;
	extern BOOL Seeded; 
	lpBinary->lpb = (LPBYTE)LocalAlloc(LMEM_FIXED, unSize);
	lpBinary->cb = unSize;
	// seed the random number generator with the current time
	if (!Seeded) {
		srand( (unsigned)GetTickCount());
		Seeded = TRUE; 
	}
	
	for (Offset = 0; Offset < unSize; Offset++) {
		lpBinary->lpb[Offset] = (BYTE)(rand() * 255)/RAND_MAX;
	}
}

//***
//*** set unCount to AUTONUM_OFF to disable autonumbering display names
//*** if lppDisplayName is not NULL then the *lppDisplayName string is used for the prefix of 
//*** the DN and the ptr to the completed DisplayName is returned to the callee if lppReturnName is not NULL
//***
void CreateProps(LPTSTR lpszFileName, LPTSTR lpszSection, SPropValue** lppProperties, ULONG* lpcValues, UINT unCount, char** lppDisplayName, char ** lppReturnName) {
	UINT	StrLen1, PropIndex = 0, Properties = 0;		//How many props does the user want to set
	char	*lpszLocalDisplayName, DNText[] = {"Test Entry #"};
	extern ULONG glblDN;
	PropTableEntry*	lpEntry = PropTable;

	while (lpEntry->ulPropTag) {
		lpEntry->unSize = GetPrivateProfileInt(lpszSection,lpEntry->lpszPropTag,0,lpszFileName);
		if ((lpEntry->ulPropTag == PR_DISPLAY_NAME) && (unCount != AUTONUM_OFF))
			lpEntry->unSize = TRUE;	//If we're autonumbering the display name, then make sure unsize is not zero
		if (lpEntry->unSize) Properties++;
		lpEntry++;
	}

	//At this point, any table entry with nonzero size we need to create
	//LUIOut(L3, "Setting %i properties.", Properties);
	*lpcValues = Properties;
	*lppProperties = (SPropValue*)LocalAlloc(LMEM_FIXED, (Properties * sizeof(SPropValue)));
	lpEntry = PropTable;

	while (lpEntry->ulPropTag) {
		if (lpEntry->unSize) {
			//special case phone numbers
			if ((strstr(lpEntry->lpszPropTag, "PHONE")) || (strstr(lpEntry->lpszPropTag, "FAX"))) {
				//LUIOut(L3, "Found a prop I think is a phone number, called %s.", lpEntry->lpszPropTag);
				(*lppProperties)[PropIndex].ulPropTag = lpEntry->ulPropTag;
				GenerateRandomPhoneNumber(&((*lppProperties)[PropIndex].Value.LPSZ));
			}
			//special case for autonumbering display names if requested
			else if ((lpEntry->ulPropTag == PR_DISPLAY_NAME) && (unCount != AUTONUM_OFF)) {
				if ((lppDisplayName)&&(*lppDisplayName)) {
					//Caller passed in a string to use as the prefix
					StrLen1 = strlen(*lppDisplayName);	
					lpszLocalDisplayName = (char*)LocalAlloc(LMEM_FIXED, (StrLen1+5)*sizeof(char)); //5 for terminator plus # up to 9999
					strcpy(lpszLocalDisplayName, *lppDisplayName);
				}
				else {
					StrLen1 = strlen(DNText);	
					lpszLocalDisplayName = (char*)LocalAlloc(LMEM_FIXED, (StrLen1+5)*sizeof(char)); //5 for terminator plus # up to 9999
					strcpy(lpszLocalDisplayName, DNText);
				}
				// Add the Entry # to the display name
				_itoa(unCount,(char*)&(lpszLocalDisplayName[StrLen1]),10);
				(*lppProperties)[PropIndex].ulPropTag = lpEntry->ulPropTag;
				(*lppProperties)[PropIndex].Value.LPSZ = lpszLocalDisplayName;
				if (lppReturnName) *lppReturnName = lpszLocalDisplayName;
			}
			else {
				switch(PROP_TYPE(lpEntry->ulPropTag)) {
				case PT_STRING8:
					(*lppProperties)[PropIndex].ulPropTag = lpEntry->ulPropTag;
#ifdef TESTPASS
					if (lpEntry->ulPropTag == PR_DISPLAY_NAME) glblDN = 1;
#endif					
					GenerateRandomText(&((*lppProperties)[PropIndex].Value.LPSZ),lpEntry->unSize);
					if ((lpEntry->ulPropTag == PR_DISPLAY_NAME) && lppReturnName)
						*lppReturnName = (*lppProperties)[PropIndex].Value.LPSZ;
					break;
				case PT_BOOLEAN:
					(*lppProperties)[PropIndex].ulPropTag = lpEntry->ulPropTag;
					GenerateRandomBoolean(&((*lppProperties)[PropIndex].Value.b));
					break;
				case PT_LONG:
					(*lppProperties)[PropIndex].ulPropTag = lpEntry->ulPropTag;
					GenerateRandomLong(&((*lppProperties)[PropIndex].Value.l));
					break;
				case PT_BINARY:
					(*lppProperties)[PropIndex].ulPropTag = lpEntry->ulPropTag;
					GenerateRandomBinary(&((*lppProperties)[PropIndex].Value.bin),lpEntry->unSize);
					break;
				default:
					LUIOut(L1, "Unrecognized prop type 0x%x for property %s", PROP_TYPE(lpEntry->ulPropTag), lpEntry->lpszPropTag);
				}
			}
			PropIndex++;
		}
		lpEntry++;
	}

}

//***
//*** Walks through the expected props and searches the found props for the same prop/value combo
//***
BOOL CompareProps(SPropValue* lpExpectedProps, ULONG cValuesExpected, SPropValue* lpCompareProps, ULONG cValuesCompare) {
	ULONG	TargetProp, CompareIndex; 
	BOOL	Result = TRUE, Found;
	for (ULONG PropertyIndex = 0; PropertyIndex < cValuesExpected; PropertyIndex++) {
		TargetProp = lpExpectedProps[PropertyIndex].ulPropTag;
		for (CompareIndex = 0, Found = FALSE; CompareIndex < cValuesCompare; CompareIndex++) {
			if (lpCompareProps[CompareIndex].ulPropTag == TargetProp) {
				//if (TargetProp == PR_DISPLAY_NAME) _asm{int 3};
				Found = TRUE;
				switch(PROP_TYPE(TargetProp)) {
				case PT_STRING8:
					if (strcmp(lpExpectedProps[PropertyIndex].Value.LPSZ, lpCompareProps[CompareIndex].Value.LPSZ)) {
						//Strings did not match so fail compare
						LUIOut(L3, "Comparison failed for prop 0x%x. Expected %s but found %s",	TargetProp, lpExpectedProps[PropertyIndex].Value.LPSZ, lpCompareProps[CompareIndex].Value.LPSZ);
						Result = FALSE;
						//_asm{int 3};
					}
					break;
				case PT_BOOLEAN:
					if (lpExpectedProps[PropertyIndex].Value.b != lpCompareProps[CompareIndex].Value.b) {
						//bools did not match so fail compare
						LUIOut(L3, "Comparison failed for prop 0x%x. Expected %u but found %u",	TargetProp, lpExpectedProps[PropertyIndex].Value.b, lpCompareProps[CompareIndex].Value.b);
						Result = FALSE;
					}
					break;
				case PT_LONG:
					if (lpExpectedProps[PropertyIndex].Value.l != lpCompareProps[CompareIndex].Value.l) {
						//bools did not match so fail compare
						LUIOut(L3, "Comparison failed for prop 0x%x. Expected %u but found %u",	TargetProp, lpExpectedProps[PropertyIndex].Value.l, lpCompareProps[CompareIndex].Value.l);
						Result = FALSE;
					}
					break;
				case PT_BINARY:
					if (memcmp(lpExpectedProps[PropertyIndex].Value.bin.lpb, lpCompareProps[CompareIndex].Value.bin.lpb, lpExpectedProps[PropertyIndex].Value.bin.cb)) {
						//bools did not match so fail compare
						LUIOut(L3, "Comparison failed for prop 0x%x. %u bytes expected, %u found and they are not equal",	TargetProp, lpExpectedProps[PropertyIndex].Value.bin.cb, lpCompareProps[CompareIndex].Value.bin.cb);
						Result = FALSE;
					}
					break;
				default:
					LUIOut(L3, "Unrecognized prop type 0x%x", PROP_TYPE(lpExpectedProps[PropertyIndex].ulPropTag));
				} //switch
			} //if propr match
		} //for loop (CompareIndex)
		if (!Found) {
			LUIOut(L3, "Did not find property 0x%x. Compare FAILS", TargetProp);
			Result = FALSE;
		}
	} //for loop (PropertyIndex)
	//LUIOut(L3, "%u propertes compared %s", PropertyIndex, Result ? "Successfully" : "With Errors");
	return(Result);
} //CompareProps()

//***
//*** Walks through the expected props until it finds the target prop and displays its value
//***
BOOL DisplayProp(SPropValue *lpSearchProps, ULONG ulTargetProp, ULONG cValues) {
	BOOL	Result = TRUE, Found = FALSE;
	for (ULONG PropertyIndex = 0; PropertyIndex < cValues; PropertyIndex++) {
		if (lpSearchProps[PropertyIndex].ulPropTag == ulTargetProp) {
			//if (TargetProp == PR_DISPLAY_NAME) _asm{int 3};
			Found = TRUE;
			switch(PROP_TYPE(ulTargetProp)) {
			case PT_STRING8:
				LUIOut(L4, "Property 0x%x has value:%s", ulTargetProp, lpSearchProps[PropertyIndex].Value.LPSZ);
				break;
			case PT_BOOLEAN:
				LUIOut(L4, "Property 0x%x has value:%i", ulTargetProp, lpSearchProps[PropertyIndex].Value.b);
				break;
			case PT_LONG:
				LUIOut(L4, "Property 0x%x has value:0x%x", ulTargetProp, lpSearchProps[PropertyIndex].Value.l);
				break;
			case PT_BINARY:
				LUIOut(L4, "Binary prop found but not displayed.");
				break;
			default:
				LUIOut(L3, "Unrecognized prop type 0x%x", PROP_TYPE(ulTargetProp));
			} //switch
		} //if propr match
	} //for loop (PropertyIndex)
	if (!Found) {
		LUIOut(L4, "Did not find property 0x%x.", ulTargetProp);
		Result = FALSE;
	}
	return(Result);
} //DisplayProp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtool\dlgprop.h ===
#if !defined(AFX_DLGPROP_H__ED006BC1_F340_11D0_9A82_00A0C91F9C8B__INCLUDED_)
#define AFX_DLGPROP_H__ED006BC1_F340_11D0_9A82_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgProp.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgProp dialog

class CDlgProp : public CDialog
{
// Construction
public:
	CDlgProp(CWnd* pParent = NULL);   // standard constructor

    ULONG   m_ulPropTag;
    LPTSTR  m_lpszPropVal;
    ULONG   m_cbsz;

// Dialog Data
	//{{AFX_DATA(CDlgProp)
	enum { IDD = IDD_DIALOG_PROP };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgProp)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgProp)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGPROP_H__ED006BC1_F340_11D0_9A82_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtool\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wabtool.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_WABTOOL_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDD_DIALOG_PROP                 129
#define IDC_STATIC123                   465
#define IDC_STATIC_FILENAME             987
#define IDC_LIST                        1000
#define IDC_LIST_TAGS                   1002
#define IDC_BUTTON_NEW                  1004
#define IDC_BUTTON_DELETE               1005
#define IDC_EDIT_PROPDATA               1007
#define IDC_BUTTON_BROWSE               1008
#define IDC_BUTTON_REFRESH              1009
#define IDC_BUTTON_DETAILS              1010
#define IDC_STATIC_PROPNAME             1011
#define IDC_STATIC_PROPTYPE             1012
#define IDC_BUTTON_ADDPROP              1013
#define IDC_BUTTON_MODIFYPROP           1014
#define IDC_STATIC_PROPTAG              1015
#define IDC_STATIC_NUMENTRIES           1016
#define IDC_BUTTON_WABVIEW              1017
#define IDC_EDIT_VALUE                  1020
#define IDC_EDIT_TAG                    1021
#define IDC_STATIC_SELECTED             1022

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtests\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#define OBM_CLOSE       32754
#define OBM_UPARROW     32753
#define OBM_DNARROW     32752
#define OBM_RGARROW     32751
#define OBM_LFARROW     32750
#define OBM_REDUCE      32749
#define OBM_ZOOM        32748
#define OBM_RESTORE     32747
#define OBM_REDUCED     32746
#define OBM_ZOOMD       32745
#define OBM_RESTORED    32744
#define OBM_UPARROWD    32743
#define OBM_DNARROWD    32742
#define OBM_RGARROWD    32741
#define OBM_LFARROWD    32740
#define OBM_MNARROW     32739
#define OBM_COMBO       32738
#define OBM_UPARROWI    32737
#define OBM_DNARROWI    32736
#define OBM_RGARROWI    32735
#define OBM_LFARROWI    32734
#define OBM_OLD_CLOSE   32767
#define OBM_SIZE        32766
#define OBM_OLD_UPARROW 32765
#define OBM_OLD_DNARROW 32764
#define OBM_OLD_RGARROW 32763
#define OBM_OLD_LFARROW 32762
#define OBM_BTSIZE      32761
#define OBM_CHECK       32760
#define OBM_CHECKBOXES  32759
#define OBM_BTNCORNERS  32758
#define OBM_OLD_REDUCE  32757
#define OBM_OLD_ZOOM    32756
#define OBM_OLD_RESTORE 32755
#define OCR_NORMAL      32512
#define OCR_IBEAM       32513
#define OCR_WAIT        32514
#define OCR_CROSS       32515
#define OCR_UP          32516
#define OCR_SIZE        32640
#define OCR_ICON        32641
#define OCR_SIZENWSE    32642
#define OCR_SIZENESW    32643
#define OCR_SIZEWE      32644
#define OCR_SIZENS      32645
#define OCR_SIZEALL     32646
#define OCR_ICOCUR      32647
#define OCR_NO          32648
#define OIC_SAMPLE      32512
#define OIC_HAND        32513
#define OIC_QUES        32514
#define OIC_BANG        32515
#define OIC_NOTE        32516

#if (WINVER >= 0x0400)
#define OCR_APPSTARTING     32650
#define OIC_WINLOGO         32517
#define OIC_WARNING         OIC_BANG
#define OIC_ERROR           OIC_HAND
#define OIC_INFORMATION     OIC_NOTE
#endif

#define WS_OVERLAPPED   0x00000000L
#define WS_POPUP        0x80000000L
#define WS_CHILD        0x40000000L
#define WS_CLIPSIBLINGS 0x04000000L
#define WS_CLIPCHILDREN 0x02000000L
#define WS_VISIBLE      0x10000000L
#define WS_DISABLED     0x08000000L
#define WS_MINIMIZE     0x20000000L
#define WS_MAXIMIZE     0x01000000L
#define WS_CAPTION      0x00C00000L
#define WS_BORDER       0x00800000L
#define WS_DLGFRAME     0x00400000L
#define WS_VSCROLL      0x00200000L
#define WS_HSCROLL      0x00100000L
#define WS_SYSMENU      0x00080000L
#define WS_THICKFRAME   0x00040000L
#define WS_MINIMIZEBOX  0x00020000L
#define WS_MAXIMIZEBOX  0x00010000L
#define WS_GROUP        0x00020000L
#define WS_TABSTOP      0x00010000L

// other aliases
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW  (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW  (WS_CHILD)
#define WS_TILED        WS_OVERLAPPED
#define WS_ICONIC       WS_MINIMIZE
#define WS_SIZEBOX      WS_THICKFRAME
#define WS_TILEDWINDOW  WS_OVERLAPPEDWINDOW

#define WS_EX_DLGMODALFRAME     0x00000001L
#define WS_EX_NOPARENTNOTIFY    0x00000004L
#define WS_EX_TOPMOST           0x00000008L
#define WS_EX_ACCEPTFILES       0x00000010L
#define WS_EX_TRANSPARENT       0x00000020L
#if (WINVER >= 0x0400)
#define WS_EX_MDICHILD          0x00000040L
#define WS_EX_TOOLWINDOW        0x00000080L
#define WS_EX_WINDOWEDGE        0x00000100L
#define WS_EX_CLIENTEDGE        0x00000200L
#define WS_EX_CONTEXTHELP       0x00000400L

#define WS_EX_RIGHT             0x00001000L
#define WS_EX_LEFT              0x00000000L
#define WS_EX_RTLREADING        0x00002000L
#define WS_EX_LTRREADING        0x00000000L
#define WS_EX_LEFTSCROLLBAR     0x00004000L
#define WS_EX_RIGHTSCROLLBAR    0x00000000L

#define WS_EX_CONTROLPARENT     0x00010000L
#define WS_EX_STATICEDGE        0x00020000L
#define WS_EX_APPWINDOW         0x00040000L

#define WS_EX_OVERLAPPEDWINDOW  (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)
#define WS_EX_PALETTEWINDOW     (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)
#endif

#define VK_LBUTTON      0x01
#define VK_RBUTTON      0x02
#define VK_CANCEL       0x03
#define VK_MBUTTON      0x04
#define VK_BACK         0x08
#define VK_TAB          0x09
#define VK_CLEAR        0x0C
#define VK_RETURN       0x0D
#define VK_SHIFT        0x10
#define VK_CONTROL      0x11
#define VK_MENU         0x12
#define VK_PAUSE        0x13
#define VK_CAPITAL      0x14
#define VK_ESCAPE       0x1B
#define VK_SPACE        0x20
#define VK_PRIOR        0x21
#define VK_NEXT         0x22
#define VK_END          0x23
#define VK_HOME         0x24
#define VK_LEFT         0x25
#define VK_UP           0x26
#define VK_RIGHT        0x27
#define VK_DOWN         0x28
#define VK_SELECT       0x29
#define VK_PRINT        0x2A
#define VK_EXECUTE      0x2B
#define VK_SNAPSHOT     0x2C
#define VK_INSERT       0x2D
#define VK_DELETE       0x2E
#define VK_HELP         0x2F
#define VK_NUMPAD0      0x60
#define VK_NUMPAD1      0x61
#define VK_NUMPAD2      0x62
#define VK_NUMPAD3      0x63
#define VK_NUMPAD4      0x64
#define VK_NUMPAD5      0x65
#define VK_NUMPAD6      0x66
#define VK_NUMPAD7      0x67
#define VK_NUMPAD8      0x68
#define VK_NUMPAD9      0x69
#define VK_MULTIPLY     0x6A
#define VK_ADD          0x6B
#define VK_SEPARATOR    0x6C
#define VK_SUBTRACT     0x6D
#define VK_DECIMAL      0x6E
#define VK_DIVIDE       0x6F
#define VK_F1           0x70
#define VK_F2           0x71
#define VK_F3           0x72
#define VK_F4           0x73
#define VK_F5           0x74
#define VK_F6           0x75
#define VK_F7           0x76
#define VK_F8           0x77
#define VK_F9           0x78
#define VK_F10          0x79
#define VK_F11          0x7A
#define VK_F12          0x7B
#define VK_F13          0x7C
#define VK_F14          0x7D
#define VK_F15          0x7E
#define VK_F16          0x7F
#define VK_F17          0x80
#define VK_F18          0x81
#define VK_F19          0x82
#define VK_F20          0x83
#define VK_F21          0x84
#define VK_F22          0x85
#define VK_F23          0x86
#define VK_F24          0x87
#define VK_NUMLOCK      0x90
#define VK_SCROLL       0x91

#define VK_LSHIFT       0xA0
#define VK_RSHIFT       0xA1
#define VK_LCONTROL     0xA2
#define VK_RCONTROL     0xA3
#define VK_LMENU        0xA4
#define VK_RMENU        0xA5

#if (WINVER >= 0x0400)
#define VK_PROCESSKEY   0xE5
#endif /* WINVER >= 0x0400 */

#define VK_ATTN         0xF6
#define VK_CRSEL        0xF7
#define VK_EXSEL        0xF8
#define VK_EREOF        0xF9
#define VK_PLAY         0xFA
#define VK_ZOOM         0xFB
#define VK_NONAME       0xFC
#define VK_PA1          0xFD
#define VK_OEM_CLEAR    0xFE

#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

#define DS_ABSALIGN     0x01L
#define DS_SYSMODAL     0x02L
#define DS_LOCALEDIT    0x20L
#define DS_SETFONT      0x40L
#define DS_MODALFRAME   0x80L
#define DS_NOIDLEMSG    0x100L
#define DS_SETFOREGROUND 0x200L

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

#if (WINVER >= 0x0400)
#define DS_3DLOOK       0x0004L
#define DS_FIXEDSYS     0x0008L
#define DS_NOFAILCREATE 0x0010L
#define DS_CONTROL      0x0400L
#define DS_CENTER       0x0800L
#define DS_CENTERMOUSE  0x1000L
#define DS_CONTEXTHELP  0x2000L
#endif

#define SS_LEFT         0x00000000L
#define SS_CENTER       0x00000001L
#define SS_RIGHT        0x00000002L
#define SS_ICON         0x00000003L
#define SS_BLACKRECT    0x00000004L
#define SS_GRAYRECT     0x00000005L
#define SS_WHITERECT    0x00000006L
#define SS_BLACKFRAME   0x00000007L
#define SS_GRAYFRAME    0x00000008L
#define SS_WHITEFRAME   0x00000009L
#define SS_SIMPLE       0x0000000BL
#define SS_LEFTNOWORDWRAP 0x0000000CL
#define SS_BITMAP           0x0000000EL

#if (WINVER >= 0x0400)
#define SS_OWNERDRAW        0x0000000DL
#define SS_ENHMETAFILE      0x0000000FL
#define SS_ETCHEDHORZ       0x00000010L
#define SS_ETCHEDVERT       0x00000011L
#define SS_ETCHEDFRAME      0x00000012L
#endif

#define SS_NOPREFIX     0x00000080L
#if (WINVER >= 0x0400)
#define SS_NOTIFY           0x00000100L
#endif
#define SS_CENTERIMAGE      0x00000200L
#if (WINVER >= 0x0400)
#define SS_RIGHTJUST        0x00000400L
#define SS_REALSIZEIMAGE    0x00000800L
#define SS_SUNKEN           0x00001000L
#endif

#define BS_PUSHBUTTON   0x00000000L
#define BS_DEFPUSHBUTTON 0x00000001L
#define BS_CHECKBOX     0x00000002L
#define BS_AUTOCHECKBOX 0x00000003L
#define BS_RADIOBUTTON  0x00000004L
#define BS_3STATE       0x00000005L
#define BS_AUTO3STATE   0x00000006L
#define BS_GROUPBOX     0x00000007L
#define BS_USERBUTTON   0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW        0x0000000BL
#define BS_LEFTTEXT     0x00000020L
#if (WINVER >= 0x0400)
#define BS_TEXT             0x00000000L
#define BS_ICON             0x00000040L
#define BS_BITMAP           0x00000080L
#define BS_LEFT             0x00000100L
#define BS_RIGHT            0x00000200L
#define BS_CENTER           0x00000300L
#define BS_TOP              0x00000400L
#define BS_BOTTOM           0x00000800L
#define BS_VCENTER          0x00000C00L
#define BS_PUSHLIKE         0x00001000L
#define BS_MULTILINE        0x00002000L
#define BS_NOTIFY           0x00004000L
#define BS_FLAT             0x00008000L
#define BS_RIGHTBUTTON      BS_LEFTTEXT
#endif

#define ES_LEFT         0x00000000L
#define ES_CENTER       0x00000001L
#define ES_RIGHT        0x00000002L
#define ES_MULTILINE    0x00000004L
#define ES_UPPERCASE    0x00000008L
#define ES_LOWERCASE    0x00000010L
#define ES_PASSWORD     0x00000020L
#define ES_AUTOVSCROLL  0x00000040L
#define ES_AUTOHSCROLL  0x00000080L
#define ES_NOHIDESEL    0x00000100L
#define ES_OEMCONVERT   0x00000400L
#define ES_READONLY     0x00000800L
#define ES_WANTRETURN   0x00001000L
#if (WINVER >= 0x0400)
#define ES_NUMBER       0x2000L
#endif

#define SBS_HORZ        0x0000L
#define SBS_VERT        0x0001L
#define SBS_TOPALIGN    0x0002L
#define SBS_LEFTALIGN   0x0002L
#define SBS_BOTTOMALIGN 0x0004L
#define SBS_RIGHTALIGN  0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN 0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX     0x0008L
#if (WINVER >= 0x0400)
#define SBS_SIZEGRIP    0x0010L
#endif

#define LBS_NOTIFY      0x0001L
#define LBS_SORT        0x0002L
#define LBS_NOREDRAW    0x0004L
#define LBS_MULTIPLESEL 0x0008L
#define LBS_OWNERDRAWFIXED 0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS  0x0040L
#define LBS_USETABSTOPS 0x0080L
#define LBS_NOINTEGRALHEIGHT 0x0100L
#define LBS_MULTICOLUMN 0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL 0x0800L
#define LBS_DISABLENOSCROLL 0x1000L
#if (WINVER >= 0x0400)
#define LBS_NOSEL       0x4000L
#endif
#define LBS_STANDARD    (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)

#define CBS_SIMPLE      0x0001L
#define CBS_DROPDOWN    0x0002L
#define CBS_DROPDOWNLIST 0x0003L
#define CBS_OWNERDRAWFIXED 0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL 0x0040L
#define CBS_OEMCONVERT  0x0080L
#define CBS_SORT        0x0100L
#define CBS_HASSTRINGS  0x0200L
#define CBS_NOINTEGRALHEIGHT 0x0400L
#define CBS_DISABLENOSCROLL 0x0800L
#if (WINVER >= 0x0400)
#define CBS_UPPERCASE   0x2000L
#define CBS_LOWERCASE   0x4000L
#endif

// operation messages sent to DLGINIT
#define WM_USER         0x0400
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#if (WINVER >= 0x0400)

#define HDS_HORZ                0x00000000
#define HDS_BUTTONS             0x00000002
#define HDS_HIDDEN              0x00000008

#define TTS_ALWAYSTIP           0x01
#define TTS_NOPREFIX            0x02

#define SBARS_SIZEGRIP          0x0100

#define TBS_AUTOTICKS           0x0001
#define TBS_VERT                0x0002
#define TBS_HORZ                0x0000
#define TBS_TOP                 0x0004
#define TBS_BOTTOM              0x0000
#define TBS_LEFT                0x0004
#define TBS_RIGHT               0x0000
#define TBS_BOTH                0x0008
#define TBS_NOTICKS             0x0010
#define TBS_ENABLESELRANGE      0x0020
#define TBS_FIXEDLENGTH         0x0040
#define TBS_NOTHUMB             0x0080

#define UDS_WRAP                0x0001
#define UDS_SETBUDDYINT         0x0002
#define UDS_ALIGNRIGHT          0x0004
#define UDS_ALIGNLEFT           0x0008
#define UDS_AUTOBUDDY           0x0010
#define UDS_ARROWKEYS           0x0020
#define UDS_HORZ                0x0040
#define UDS_NOTHOUSANDS         0x0080

#define CCS_TOP                 0x00000001L
#define CCS_NOMOVEY             0x00000002L
#define CCS_BOTTOM              0x00000003L
#define CCS_NORESIZE            0x00000004L
#define CCS_NOPARENTALIGN       0x00000008L
#define CCS_NOHILITE            0x00000010L
#define CCS_ADJUSTABLE          0x00000020L
#define CCS_NODIVIDER           0x00000040L

#define LVS_ICON                0x0000
#define LVS_REPORT              0x0001
#define LVS_SMALLICON           0x0002
#define LVS_LIST                0x0003
#define LVS_TYPEMASK            0x0003
#define LVS_SINGLESEL           0x0004
#define LVS_SHOWSELALWAYS       0x0008
#define LVS_SORTASCENDING       0x0010
#define LVS_SORTDESCENDING      0x0020
#define LVS_SHAREIMAGELISTS     0x0040
#define LVS_NOLABELWRAP         0x0080
#define LVS_AUTOARRANGE         0x0100
#define LVS_EDITLABELS          0x0200
#define LVS_NOSCROLL            0x2000

#define LVS_ALIGNTOP            0x0000
#define LVS_ALIGNLEFT           0x0800
#define LVS_ALIGNMASK           0x0c00

#define LVS_OWNERDRAWFIXED      0x0400
#define LVS_NOCOLUMNHEADER      0x4000
#define LVS_NOSORTHEADER        0x8000

#define TVS_HASBUTTONS          0x0001
#define TVS_HASLINES            0x0002
#define TVS_LINESATROOT         0x0004
#define TVS_EDITLABELS          0x0008
#define TVS_DISABLEDRAGDROP     0x0010
#define TVS_SHOWSELALWAYS       0x0020

#define TCS_FORCEICONLEFT       0x0010
#define TCS_FORCELABELLEFT      0x0020
#define TCS_SHAREIMAGELISTS     0x0040
#define TCS_TABS                0x0000
#define TCS_BUTTONS             0x0100
#define TCS_SINGLELINE          0x0000
#define TCS_MULTILINE           0x0200
#define TCS_RIGHTJUSTIFY        0x0000
#define TCS_FIXEDWIDTH          0x0400
#define TCS_RAGGEDRIGHT         0x0800
#define TCS_FOCUSONBUTTONDOWN   0x1000
#define TCS_OWNERDRAWFIXED      0x2000
#define TCS_TOOLTIPS            0x4000
#define TCS_FOCUSNEVER          0x8000

#define ACS_CENTER              0x0001
#define ACS_TRANSPARENT         0x0002
#define ACS_AUTOPLAY            0x0004

#endif // (WINVER >= 0x0400)

// 32-bit language/sub-language identifiers

#ifndef LANG_NEUTRAL
// Primary language IDs.
#define LANG_NEUTRAL                     0x00

#define LANG_BULGARIAN                   0x02
#define LANG_CHINESE                     0x04
#define LANG_CROATIAN                    0x1a
#define LANG_CZECH                       0x05
#define LANG_DANISH                      0x06
#define LANG_DUTCH                       0x13
#define LANG_ENGLISH                     0x09
#define LANG_FINNISH                     0x0b
#define LANG_FRENCH                      0x0c
#define LANG_GERMAN                      0x07
#define LANG_GREEK                       0x08
#define LANG_HUNGARIAN                   0x0e
#define LANG_ICELANDIC                   0x0f
#define LANG_ITALIAN                     0x10
#define LANG_JAPANESE                    0x11
#define LANG_KOREAN                      0x12
#define LANG_NORWEGIAN                   0x14
#define LANG_POLISH                      0x15
#define LANG_PORTUGUESE                  0x16
#define LANG_ROMANIAN                    0x18
#define LANG_RUSSIAN                     0x19
#define LANG_SLOVAK                      0x1b
#define LANG_SLOVENIAN                   0x24
#define LANG_SPANISH                     0x0a
#define LANG_SWEDISH                     0x1d
#define LANG_TURKISH                     0x1f
#endif //!LANG_NEUTRAL

#ifndef SUBLANG_NEUTRAL
// Sublanguage IDs.
#define SUBLANG_NEUTRAL                  0x00
#define SUBLANG_DEFAULT                  0x01
#define SUBLANG_SYS_DEFAULT              0x02

#define SUBLANG_CHINESE_TRADITIONAL      0x01
#define SUBLANG_CHINESE_SIMPLIFIED       0x02
#define SUBLANG_CHINESE_HONGKONG         0x03
#define SUBLANG_CHINESE_SINGAPORE        0x04
#define SUBLANG_DUTCH                    0x01
#define SUBLANG_DUTCH_BELGIAN            0x02
#define SUBLANG_ENGLISH_US               0x01
#define SUBLANG_ENGLISH_UK               0x02
#define SUBLANG_ENGLISH_AUS              0x03
#define SUBLANG_ENGLISH_CAN              0x04
#define SUBLANG_ENGLISH_NZ               0x05
#define SUBLANG_ENGLISH_EIRE             0x06
#define SUBLANG_FRENCH                   0x01
#define SUBLANG_FRENCH_BELGIAN           0x02
#define SUBLANG_FRENCH_CANADIAN          0x03
#define SUBLANG_FRENCH_SWISS             0x04
#define SUBLANG_GERMAN                   0x01
#define SUBLANG_GERMAN_SWISS             0x02
#define SUBLANG_GERMAN_AUSTRIAN          0x03
#define SUBLANG_ITALIAN                  0x01
#define SUBLANG_ITALIAN_SWISS            0x02
#define SUBLANG_NORWEGIAN_BOKMAL         0x01
#define SUBLANG_NORWEGIAN_NYNORSK        0x02
#define SUBLANG_PORTUGUESE               0x02
#define SUBLANG_PORTUGUESE_BRAZILIAN     0x01
#define SUBLANG_SPANISH                  0x01
#define SUBLANG_SPANISH_MEXICAN          0x02
#define SUBLANG_SPANISH_MODERN           0x03
#endif //!SUBLANG_NEUTRAL

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#define IDOK            1
#define IDCANCEL        2
#define IDABORT         3
#define IDRETRY         4
#define IDIGNORE        5
#define IDYES           6
#define IDNO            7
#if (WINVER >= 0x0400)
#define IDCLOSE         8
#define IDHELP          9
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtests\wabtest.h ===
#ifndef PABTEST_H
#define PABTEST_H

//#define TESTPASS

// Set the provider to either PAB or WAB
//#define PAB
#ifndef PAB
#define WAB
#endif

#include <windows.h>
#include <windowsx.h>

#ifdef WAB
//
// WAB Headers
//
#include <wab.h>
#endif

#ifdef PAB
//
// MAPI headers
//
#include <mapiwin.h>
#include <mapidefs.h>
#include <mapicode.h>
#include <mapitags.h>
//#include <mapispi.h>
#include <mapiutil.h>
#include <mapival.h>
#include <mapix.h>
#include <mapiutil.h>
#endif

//MAPI Headers that are needed for WAB
#include <mapiguid.h>


#include <limits.h>
#include <memory.h>
#include <commdlg.h>
#include <stdio.h>
#include <string.h>
#include <mbstring.h>
#include <time.h>
#include <math.h>


#include <unknwn.h>




LRESULT CALLBACK WndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam);



// Foreign Address Book Provider MAPIUID
//#define MUIDFAB {0x45,0xef,0xe6,0xe0,0xfd,0xd8,0x11,0xce,0xa4,0x88,0x00,0xaa,0x00,0x47,0xfa,0xa4}



// Test for PT_ERROR property tag
#define PROP_ERROR(prop) (prop.ulPropTag == PROP_TAG(PT_ERROR, PROP_ID(prop.ulPropTag)))


// Blank tags                    
#define	IN 
#define	OUT
#define BIG_BUF	256
#define MAX_BUF 1000
#define SML_BUF	50
#define MAXMENU 20
#define MAXSTRING 64
#define INIFILENAME "c:\\Pabtests.ini"

// Flag used only in sample code shell toswitch between operations
// using and not-using UI
#define SAMPWAB_ADDRESS_UI  0x00000001

#define BUFFERSIZE	1024
#define BUFFERSIZE2 2003
#define BUFFERSIZE3	4096
#define PATTERN	0xA5	// 1 byte test pattern for verifying memory
#define INVALIDPTR	0xfeeefeee
#define AUTONUM_OFF 0xFFFF

HRESULT OpenPABID(
                IN  LPADRBOOK	lpAdrBook,
                OUT ULONG		*lpcbEidPAB,
                OUT LPENTRYID	*lppEidPAB,
                OUT LPABCONT	*lppPABCont,
				OUT ULONG		*lpulObjType);

#ifdef PAB
BOOL MapiUnInit(IN LPMAPISESSION);
BOOL MapiInitLogon(OUT LPMAPISESSION *);
#endif

BOOL GetPropsFromIniBufEntry(LPSTR,ULONG,char (*)[BIG_BUF]);
HRESULT HrCreateEntryListFromID(LPWABOBJECT,
                    IN ULONG ,                     // count of bytes in Entry ID
                    IN LPENTRYID ,                 // pointer to Entry ID
                    OUT LPENTRYLIST FAR *); // pointer to address variable of Entry
                                                        // list
BOOL GetAB(OUT LPADRBOOK*);
BOOL ValidateAdrList(LPADRLIST, ULONG);
BOOL PabCreateEntry();
BOOL PabDeleteEntry();
BOOL PabEnumerateAll();
BOOL ClearPab(int);
BOOL CreateOneOff();
BOOL PABResolveName();
BOOL PABSetProps();
BOOL PABQueryInterface();
BOOL PABPrepareRecips();
BOOL PABCopyEntries();
BOOL PABRunBVT();
BOOL PABAllocateBuffer();
BOOL PABAllocateMore();
BOOL PABFreeBuffer();
BOOL PAB_IABOpenEntry();
BOOL PAB_IABContainerCreateEntry();
BOOL PAB_IMailUserSetGetProps();
BOOL PAB_IMailUserSaveChanges();
BOOL PAB_IABContainerResolveNames();
BOOL PAB_IABContainerOpenEntry();
BOOL PAB_IABAddress();
BOOL PAB_AddMultipleEntries();
BOOL PAB_IABResolveName();
BOOL PAB_IABNewEntry_Details();
BOOL ThreadManager();
BOOL ThreadStress(LPVOID);
BOOL Performance();
BOOL PAB_IDLSuite();
BOOL NamedPropsSuite();

BOOL AllocateAdrList(LPWABOBJECT, int, int, LPADRLIST *);
BOOL FreeAdrList(LPWABOBJECT, LPADRLIST *);
BOOL FreePartAdrList(IN LPADRLIST *);
BOOL GrowAdrList(UINT, UINT, LPADRLIST *);
BOOL ParseIniBuffer(LPSTR, UINT, LPSTR);
BOOL VerifyBuffer(DWORD **, DWORD);
BOOL DisplayAdrList(LPADRLIST, ULONG);
BOOL VerifyResolvedAdrList(LPADRLIST, char*);
BOOL CALLBACK SetIniFile(HWND,UINT, WPARAM, LONG);
BOOL LogIt(HRESULT, int, char *);
BOOL PropError(ULONG, ULONG);
BOOL FindProp(LPADRENTRY, ULONG, unsigned int*);
BOOL FreeEntryList(LPWABOBJECT, IN LPENTRYLIST *);
BOOL FreeRows(LPWABOBJECT, LPSRowSet far*);
BOOL DisplayRows(LPSRowSet lpRows);
BOOL FindPropinRow(LPSRow, ULONG, unsigned int*);
BOOL DeleteWABFile();
BOOL MyRegOpenKeyEx(HKEY, char*, REGSAM, HKEY*);
BOOL CreateMultipleEntries(IN UINT, OUT DWORD*);
HRESULT HrCreateEntryListFromRows(LPWABOBJECT, LPSRowSet far*, LPENTRYLIST FAR *);
void GenerateRandomPhoneNumber(char **lppPhone);
void GenerateRandomText(char **lppPhone, UINT);
void CreateProps(LPTSTR, LPTSTR, SPropValue**, ULONG*, UINT, char**, char**);
BOOL CompareProps(SPropValue*, ULONG, SPropValue*, ULONG);
BOOL DisplayProp(SPropValue *, ULONG, ULONG);
void GenerateRandomBoolean(unsigned short *);
void GenerateRandomLong(long *);
void GenerateRandomBinary(SBinary *, UINT);


struct EntryID {
	char*	lpDisplayName;
	ULONG	cb;
	LPBYTE	lpb;
};

struct PropTableEntry {
	ULONG	ulPropTag;	//MAPI Property ID
	char*	lpszPropTag;	//String version of the prop name for lookup in ini file

//	void*	lpValue;	//ptr to the value if supplied or NULL if don't use or create random
	UINT	unSize;		//size of rand value to create or 0 if don't use or value supplied in lpValue
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtool\dlgprop.cpp ===
// DlgProp.cpp : implementation file
//

#include "stdafx.h"
#include "wabtool.h"
#include "DlgProp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgProp dialog


CDlgProp::CDlgProp(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgProp::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgProp)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDlgProp::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgProp)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgProp, CDialog)
	//{{AFX_MSG_MAP(CDlgProp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgProp message handlers

BOOL CDlgProp::OnInitDialog() 
{
	CDialog::OnInitDialog();

    CEdit * pEdit = (CEdit *) GetDlgItem(IDC_EDIT_TAG);
    pEdit->SetLimitText(32);
    TCHAR sz[32];
    wsprintf(sz, "%x", m_ulPropTag);
    pEdit->SetWindowText(sz);


    pEdit = (CEdit *) GetDlgItem(IDC_EDIT_VALUE);
    pEdit->SetLimitText(512);
    pEdit->SetWindowText(m_lpszPropVal);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

ULONG GetULONGVal(CEdit * pEdit)
{
    TCHAR sz[32];
    const LPTSTR lpZero = "00000000";

    pEdit->GetWindowText(sz, sizeof(sz));

    int nLen = lstrlen(sz);
    if(nLen < 8)
    {
        // pad with zeros
        TCHAR sz1[32];
        lstrcpy(sz1, sz);
        CopyMemory(sz, lpZero, 8-nLen);
        sz[8-nLen] = '\0';
        lstrcat(sz, sz1);
    }

    CharUpper(sz);
    LPTSTR lp = sz;
    ULONG ulVal = 0;

    while(lp && *lp)
    {
        int i = 0;

        if(*lp >= 'A' && *lp <= 'F')
            i = *lp - 'A' + 10;
        else if(*lp >= '0' && *lp <= '9')
            i = *lp - '0';

        ulVal = ulVal * 16 + i;

        lp = CharNext(lp);
    }

    return ulVal;
}

void CDlgProp::OnOK() 
{
    m_ulPropTag = GetULONGVal((CEdit *) GetDlgItem(IDC_EDIT_TAG));
	
    GetDlgItemText(IDC_EDIT_VALUE, m_lpszPropVal, m_cbsz);

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\test\wabtests\wabtest.cpp ===
#include "wabtest.h"

#include <assert.h>
#include "resource.h"
#include "..\luieng.dll\luieng.h"
#include "wabtest.h"


#define IDM_CREATEENTRIES 2000
#define	IDM_ENUMERATEALL 2001
#define	IDM_DELETEENTRIES 2002
#define IDM_DELETEALL 2003
#define	IDM_DELETEUSERSONLY 2004
#define IDM_CREATEONEOFF	2005
#define IDM_RESOLVENAME		2006
#define IDM_SETPROPS		2007
#define IDM_QUERYINTERFACE	2008
#define IDM_PREPARERECIPS	2009
#define IDM_COPYENTRIES		2010
#define IDM_RUNBVT			2011
#define IDM_ALLOCATEBUFFER	2012
#define IDM_ALLOCATEMORE	2013
#define IDM_FREEBUFFER		2014
#define IDM_IABOPENENTRY    2015
#define IDM_ICCREATEENTRY	2016
#define IDM_IMUSETGETPROPS	2017
#define IDM_IMUSAVECHANGES	2018
#define IDM_ICRESOLVENAMES	2019
#define IDM_ICOPENENTRY		2020
#define IDM_IABADDRESS		2021
#define IDM_ADDMULTIPLE		2022
#define IDM_IABRESOLVENAME	2023
#define IDM_MULTITHREAD		2024
#define IDM_IABNEWENTRYDET	2025
#define IDM_DELWAB			2026
#define IDM_PERFORMANCE		2027
#define IDM_IDLSUITE		2028
#define IDM_NAMEDPROPS		2029

#define IDM_SETINIFILE		2501
#define ID_MULTITHREADCOMPLETE	2502



//
// Globals
//
GUID WabTestGUID = { /* 683ce274-343a-11d0-9ff1-00a0c905424c */
    0x683ce274,
    0x343a,
    0x11d0,
    {0x9f, 0xf1, 0x00, 0xa0, 0xc9, 0x05, 0x42, 0x4c}
  };
static char szAppName[]= "WABTESTS";
char szIniFile[BIG_BUF];
CRITICAL_SECTION	CriticalSection;
ULONG	glblCount = 0, glblTest = 39, glblDN = 0;

#ifdef PAB
LPMAPISESSION	lpMAPISession;	//Global handle to session
#endif
#ifdef WAB
LPWABOBJECT		lpWABObject; //Global handle to session
LPADRBOOK		glbllpAdrBook;
#endif

DWORD ThreadIdJunk;
HWND glblhwnd;
HINSTANCE hinstLib, glblhinst;
HANDLE glblThreadManager;
LUIINIT LUIInit;
LUIMSGHANDLER LUIMsgHandler;
LUIOUT LUIOut;
BOOL bLUIInit, glblStop, Seeded;

//***************************************************************

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPSTR lpszCmdLine, int nCmdShow)
	{
	HWND hwnd;
	MSG msg;
	WNDCLASS wndclass;


	//
	// Init Global Variables Here
	//
#ifdef PAB
	lpMAPISession = NULL;
#endif
	glblThreadManager = NULL;
	bLUIInit = FALSE;
	glblStop = FALSE;
	Seeded = FALSE;

	if (!hPrevInstance)
		{
		wndclass.style = CS_HREDRAW|CS_VREDRAW;
		wndclass.lpfnWndProc = WndProc;
		wndclass.hInstance = hInstance;
		wndclass.cbClsExtra = 4;
		wndclass.cbWndExtra = 0;
		wndclass.lpszMenuName = MAKEINTRESOURCE(IDR_MENU1);
		wndclass.hIcon = LoadIcon(NULL,IDI_APPLICATION);
		wndclass.hCursor = LoadCursor(NULL,IDC_ARROW);
		wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
		wndclass.lpszClassName = szAppName;

		RegisterClass(&wndclass);
		}

	hwnd = CreateWindow(szAppName,"WABTests", WS_OVERLAPPEDWINDOW,
						CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,CW_USEDEFAULT,
						NULL, NULL, hInstance, NULL);

	hinstLib = LoadLibrary("luieng.dll");
	if (hinstLib) {
		LUIInit = (LUIINIT)GetProcAddress(hinstLib,"LUIInit");
		LUIMsgHandler=(LUIMSGHANDLER)GetProcAddress(hinstLib,"LUIMsgHandler");
		LUIOut = (LUIOUT)GetProcAddress(hinstLib,"LUIOut");

		lstrcpy(szIniFile,INIFILENAME);
	
		MenuStruct Tests[MAXMENU];
		MenuStruct Tools[MAXMENU];
		MenuStruct TestSettings[MAXMENU];

		memset((void *)Tests,0,sizeof(Tests));
		memset((void *)Tools,0,sizeof(Tests));
		memset((void *)TestSettings,0,sizeof(TestSettings));

		Tests[0].nType = LINE;
		Tests[1].nItemID = IDM_ALLOCATEBUFFER;
		Tests[1].nType = NORMAL;
		lstrcpy(Tests[1].lpszItemName,"&AllocateBuffer");
		Tests[2].nItemID = IDM_ALLOCATEMORE;
		Tests[2].nType = NORMAL;
		lstrcpy(Tests[2].lpszItemName,"&AllocateMore");
		Tests[3].nItemID = IDM_FREEBUFFER;
		Tests[3].nType = NORMAL;
		lstrcpy(Tests[3].lpszItemName,"&FreeBuffer");
		Tests[4].nItemID = IDM_IABOPENENTRY;
		Tests[4].nType = NORMAL;
		lstrcpy(Tests[4].lpszItemName,"IAB->OpenEntry");
		Tests[5].nItemID = IDM_IABADDRESS;
		Tests[5].nType = NORMAL;
		lstrcpy(Tests[5].lpszItemName,"IAB->Address");
		Tests[6].nItemID = IDM_IABRESOLVENAME;
		Tests[6].nType = NORMAL;
		lstrcpy(Tests[6].lpszItemName,"IAB->ResolveName");
		Tests[7].nItemID = IDM_IABNEWENTRYDET;
		Tests[7].nType = NORMAL;
		lstrcpy(Tests[7].lpszItemName,"IAB->NewEntry/Det");
		Tests[8].nItemID = IDM_ICCREATEENTRY;
		Tests[8].nType = NORMAL;
		lstrcpy(Tests[8].lpszItemName,"ICtr->CreateEntry");
		Tests[9].nItemID = IDM_ICRESOLVENAMES;
		Tests[9].nType = NORMAL;
		lstrcpy(Tests[9].lpszItemName,"ICtr->ResolveNames");
		Tests[10].nItemID = IDM_ICOPENENTRY;
		Tests[10].nType = NORMAL;
		lstrcpy(Tests[10].lpszItemName,"ICtr->OpenEntry");
		Tests[11].nItemID = IDM_IMUSETGETPROPS;
		Tests[11].nType = NORMAL;
		lstrcpy(Tests[11].lpszItemName,"IMU->Set/GetProps");
		Tests[12].nItemID = IDM_IMUSAVECHANGES;
		Tests[12].nType = NORMAL;
		lstrcpy(Tests[12].lpszItemName,"IMU->SaveChanges");
		Tests[13].nItemID = IDM_IDLSUITE;
		Tests[13].nType = NORMAL;
		lstrcpy(Tests[13].lpszItemName,"IDL Test Suite");
		Tests[14].nItemID = IDM_NAMEDPROPS;
		Tests[14].nType = NORMAL;
		lstrcpy(Tests[14].lpszItemName,"Named Props Suite");

		Tests[15].nType= ENDMENU;

/*		Tests[15].nType = LINE;
		Tests[16].nItemID = IDM_ADDMULTIPLE;
		Tests[16].nType = NORMAL;
		lstrcpy(Tests[16].lpszItemName,"AddMultipleEntries");
		Tests[17].nItemID = IDM_DELWAB;
		Tests[17].nType = NORMAL;
		lstrcpy(Tests[17].lpszItemName,"DeleteWABFile");
		Tests[18].nItemID = IDM_PERFORMANCE;
		Tests[18].nType = NORMAL;
		lstrcpy(Tests[18].lpszItemName,"Performance Suite");
		Tests[19].nItemID = IDM_MULTITHREAD;
		Tests[19].nType = NORMAL;
		lstrcpy(Tests[19].lpszItemName,"MultiThreadStress");
		
		Tests[6].nItemID = IDM_CREATEENTRIES;
		Tests[6].nType = NORMAL;
		lstrcpy(Tests[6].lpszItemName,"&CreateEntries");
		Tests[7].nItemID = IDM_ENUMERATEALL;
		Tests[7].nType = NORMAL;
		lstrcpy(Tests[7].lpszItemName,"&EnumerateAll");
		Tests[8].nItemID = IDM_DELETEENTRIES;
		Tests[8].nType = NORMAL;
		lstrcpy(Tests[8].lpszItemName,"&DeleteEntries");
		Tests[9].nItemID = IDM_DELETEALL;
		Tests[9].nType = NORMAL;
		lstrcpy(Tests[9].lpszItemName,"Delete&All");
		*/

		
		TestSettings[0].nItemID = IDM_SETINIFILE;
		TestSettings[0].nType = NORMAL;
		lstrcpy(TestSettings[0].lpszItemName,"&INI File");
		TestSettings[1].nType = ENDMENU;
	
		Tools[0].nItemID = IDM_ADDMULTIPLE;
		Tools[0].nType = NORMAL;
		lstrcpy(Tools[0].lpszItemName,"AddMultipleEntries");
		Tools[1].nItemID = IDM_DELWAB;
		Tools[1].nType = NORMAL;
		lstrcpy(Tools[1].lpszItemName,"DeleteWABFile");
		Tools[2].nItemID = IDM_PERFORMANCE;
		Tools[2].nType = NORMAL;
		lstrcpy(Tools[2].lpszItemName,"Performance Suite");
		Tools[4].nType= ENDMENU;
		Tools[3].nItemID = IDM_MULTITHREAD;
		Tools[3].nType = NORMAL;
		lstrcpy(Tools[3].lpszItemName,"MultiThreadStress");

		bLUIInit = LUIInit(hwnd,Tests,Tools,/*TestSettings,*/FALSE);

		glblhwnd=hwnd;
		glblhinst=hInstance;
		ShowWindow(hwnd, nCmdShow);
		UpdateWindow(hwnd);

		while(GetMessage(&msg,NULL,0,0))
			{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			}

		FreeLibrary(hinstLib);
	}
	else MessageBox(NULL,"LoadLibrary Failed: Cannot find testcntl.dll","PabTest Error",MB_OK);	
	return msg.wParam;
	}

//***************************************************************

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam)
{
	static int i;
	DWORD	retval;
	
	if (bLUIInit)
		LUIMsgHandler(message,wParam,lParam);
	
	switch(message)
	{
	case WM_CREATE:
		{
			i=0;
			return 0;
		}
	case WM_SIZE:
		{
			return 0;
		}
	case WM_COMMAND:
		{
			switch(LOWORD(wParam))
			{
			case IDM_STOP :
				glblStop = TRUE;
				break;
			case IDM_ALLOCATEBUFFER:
				if (PABAllocateBuffer()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"AllocateBuffer: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"AllocateBuffer: %d",i);
				}
				i++;
				return 0;
			
			case IDM_ALLOCATEMORE:
				if (PABAllocateMore()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"AllocateMore: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"AllocateMore: %d",i);
				}
				i++;
				return 0;
			
			case IDM_FREEBUFFER :
				if (PABFreeBuffer()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"FreeBuffer: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"FreeBuffer: %d",i);
				}
				i++;
				return 0;
			
			case IDM_IABOPENENTRY :
				if (PAB_IABOpenEntry()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IAddrBook->OpenEntry: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IAddrBook->OpenEntry: %d",i);
				}
				i++;
				return 0;
			

			case IDM_ICCREATEENTRY :
				if (PAB_IABContainerCreateEntry()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IABContainer->CreateEntry: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IABContainer->CreateEntry: %d",i);
				}
				i++;
				return 0;
			

			case IDM_IMUSETGETPROPS :
				if (PAB_IMailUserSetGetProps()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IMailUser->Set/GetProps: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IMailUser->Set/GetProps: %d",i);
				}
				i++;
				return 0;

			case IDM_IMUSAVECHANGES :
				if (PAB_IMailUserSaveChanges()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IMailUser->SaveChanges: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IMailUser->SaveChanges: %d",i);
				}
				i++;
				return 0;

			
			case IDM_ICRESOLVENAMES :
				if (PAB_IABContainerResolveNames()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IABContainer->ResolveNames: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IABContainer->ResolveNames: %d",i);
				}
				i++;
				return 0;


			case IDM_ICOPENENTRY :
				if (PAB_IABContainerOpenEntry()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IABContainer->OpenEntry: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IABContainer->OpenEntry: %d",i);
				}
				i++;
				return 0;


			case IDM_IABADDRESS :
				if (PAB_IABAddress()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IAdrBook->Address: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IAdrBook->Address: %d",i);
				}
				i++;
				return 0;
			
			case IDM_ADDMULTIPLE :
				if (PAB_AddMultipleEntries()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"AddMultipleEntries: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"AddMultipleEntries: %d",i);
				}
				i++;
				return 0;
			
			case IDM_IABRESOLVENAME :
				if (PAB_IABResolveName()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IAdrBook->ResolveName: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IAdrBook->ResolveName: %d",i);
				}
				i++;
				return 0;
			

			case IDM_IABNEWENTRYDET :
				if (PAB_IABNewEntry_Details()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IAdrBook->NewEntry/Details: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IAdrBook->NewEntry/Details: %d",i);
				}
				i++;
				return 0;
			

			case IDM_CREATEENTRIES :
				if (PabCreateEntry()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"Create Entries: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Create Entries: %d",i);
				}
				i++;
				return 0;
			
			case IDM_MULTITHREAD :
				if (glblThreadManager) {
					LUIOut(L1, "In cleanup routine");
					TerminateThread(glblThreadManager, (DWORD)0);
					CloseHandle(glblThreadManager);
				}
				glblThreadManager =(HANDLE)CreateThread(
					(LPSECURITY_ATTRIBUTES) NULL,		// pointer to thread security attributes
					(DWORD) 0,							// initial thread stack size, in bytes
					(LPTHREAD_START_ROUTINE) ThreadManager,		// pointer to thread function
					(LPVOID) NULL,						// argument for new thread
					(DWORD) 0,							// creation flags
					&ThreadIdJunk						// pointer to returned thread identifier
				);
				if (!glblThreadManager) LUIOut(L1, "<ERROR> WndProc: CreateThread returned 0x%X", GetLastError());
				return 0;
			
			case ID_MULTITHREADCOMPLETE :
				if (glblThreadManager) {
					//GetExitCodeThread(glblThreadManager, &retval);
					retval = HIWORD(wParam);
					if (retval) {
						LUIOut(L1," ");
						LUIOut(LPASS,"MultiThreadStress: %d",i);
					}
					else {
						LUIOut(L1," ");
						LUIOut(LFAIL,"MultiThreadStress: %d",i);
					}
					CloseHandle(glblThreadManager);
				}
				
				glblStop = FALSE;		//reset stop flag
				i++;
				return 0;
			
			case IDM_DELWAB :
				if (DeleteWABFile()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"Delete WAB File: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Delete WAB File: %d",i);
				}
				i++;
				return 0;
			
			case IDM_IDLSUITE :
				if (PAB_IDLSuite()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"Distribution List Test Suite: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Distribution List Test Suite: %d",i);
				}
				i++;
				return 0;
		

			case IDM_PERFORMANCE :
				if (Performance()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"WAB Performance Suite: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"WAB Performance Suite: %d",i);
				}
				i++;
				return 0;
			
			case IDM_NAMEDPROPS :
				if (NamedPropsSuite()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"Named Properties Test Suite: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Named Properties Test Suite: %d",i);
				}
				i++;
				return 0;

			case IDM_ENUMERATEALL :
				if (PabEnumerateAll())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"Enumerate All: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Enumerate All: %d",i);
				}
				i++;
				return 0;
			
			case IDM_DELETEENTRIES :
				if (PabDeleteEntry()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"Delete specified Entries: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Delete specified Entries: %d",i);
				}
				i++;
				return 0;
			
			case IDM_DELETEALL:
				if (ClearPab(0))  {
					LUIOut(L1," ");
					LUIOut(LPASS,"Delete All Entries: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Delete All Entries: %d",i);
				}
				i++;
				return 0;
	
			case IDM_DELETEUSERSONLY:
				if (ClearPab(1))  {
					LUIOut(L1," ");
					LUIOut(LPASS,"Delete Mail Users Only: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Delete Mail Users Only: %d",i);
				}
				i++;
				return 0;

			case IDM_CREATEONEOFF :
				if (CreateOneOff())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"CreateOneOff: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"CreateOneOff: %d",i);
				}
				i++;
				return 0;
			
			case IDM_RESOLVENAME :
				if (PABResolveName())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"ResolveName: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"ResolveName: %d",i);
				}
				i++;
				return 0;

			case IDM_SETPROPS :
				if (PABSetProps())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"SetProps: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"SetProps: %d",i);
				}
				i++;
				return 0;
		
			case IDM_QUERYINTERFACE :
				if (PABQueryInterface())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"QueryInterface: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"QueryInterface: %d",i);
				}
				i++;
				return 0;
			
			case IDM_PREPARERECIPS :
				if (PABPrepareRecips())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"PrepareRecips: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"PrepareRecips: %d",i);
				}
				i++;
				return 0;

			case IDM_COPYENTRIES :
				if (PABCopyEntries())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"CopyEntries: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"CopyEntries: %d",i);
				}
				i++;
				return 0;

			case IDM_RUNBVT :
				if (PABRunBVT())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"RunBVT: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"RunBVT: %d",i);
				}
				i++;
				return 0;

			case IDM_SETINIFILE :
				DialogBox(glblhinst,MAKEINTRESOURCE(IDD_INIFILE),glblhwnd,(DLGPROC)SetIniFile);
				return 0;    			
			}
			return 0;
		}

	case WM_DESTROY:
		{
			PostQuitMessage(0);
			return 0;
		}
	}
	return DefWindowProc(hwnd,message,wParam,lParam);
}

BOOL PABAllocateBuffer()
{
    DWORD ** lppBuffer;
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

	ULONG       cValues = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int i=0,k=0;
	
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
    LPMAILUSER  lpAddress   = NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	
	LUIOut(L1," ");
	LUIOut(L1,"Running AllocateBuffer");
	LUIOut(L2,"-> Allocates and confirms memory using the Allocate Buffer");
	LUIOut(L2, "   routine. confirms by writing a bit pattern and verifying.");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Allocate a buffer and check for success
	
	lppBuffer = new (DWORD*);
#ifdef PAB
	if ((MAPIAllocateBuffer(BUFFERSIZE, (LPVOID FAR *)lppBuffer) == S_OK) && *lppBuffer)
			LUIOut(L2,"MAPIAllocateBuffer PASSED");
	else 	{
		LUIOut(L2,"MAPIAllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

#ifdef WAB
	if ((lpWABObject->AllocateBuffer(BUFFERSIZE, (LPVOID FAR *)lppBuffer) == S_OK) && *lppBuffer)
			LUIOut(L2,"lpWABObject->AllocateBuffer PASSED");
	else 	{
		LUIOut(L2,"lpWABObject->AllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

	if ( !VerifyBuffer(lppBuffer,BUFFERSIZE) )
		retval = FALSE;

out:
#ifdef PAB
		if (*lppBuffer)	{
			if (MAPIFreeBuffer(*lppBuffer) == S_OK)
				LUIOut(L2,"MAPIFreeBuffer Succeded");	
			else 	LUIOut(L2,"MAPIFreeBuffer Failed");
		}

		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
#endif
#ifdef WAB
		if (*lppBuffer)	{
			if (lpWABObject->FreeBuffer(*lppBuffer) == S_OK)
				LUIOut(L2,"lpWABObject->FreeBuffer Succeded");	
			else 	LUIOut(L2,"lpWABObject->FreeBuffer Failed");
		}

		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
#endif

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpDLCont)
				lpDLCont->Release();


		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();

#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}


BOOL PABAllocateMore()
{
    DWORD ** lppBuffer, ** lppBuffer2, ** lppBuffer3;
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

	ULONG       cValues = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int i=0,k=0;
	
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
    LPMAILUSER  lpAddress   = NULL;

	LUIOut(L1," ");
	LUIOut(L1,"Running AllocateMore");
	LUIOut(L2,"-> Allocates memory using the AllocateBuffer routine");
	LUIOut(L2, "    followed by two calls to AllocateMore using different");
	LUIOut(L2, "    buffer sizes. It then confirms the buffer by writing");
	LUIOut(L2, "    a bit pattern and verifying.");
	LUIOut(L1," ");


	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Allocate a buffer and check for success
	
	lppBuffer = new (DWORD*);
#ifdef PAB
	if ((MAPIAllocateBuffer(BUFFERSIZE, (LPVOID FAR *)lppBuffer) == S_OK) && *lppBuffer)
			LUIOut(L2,"MAPIAllocateBuffer PASSED");
	else 	{
		LUIOut(L2,"MAPIAllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

#ifdef WAB
	if ((lpWABObject->AllocateBuffer(BUFFERSIZE, (LPVOID FAR *)lppBuffer) == S_OK) && *lppBuffer)
			LUIOut(L2,"lpWABObject->AllocateBuffer PASSED");
	else 	{
		LUIOut(L2,"lpWABObject->AllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

	lppBuffer2 = new (DWORD*);
#ifdef PAB
	if ((MAPIAllocateMore(BUFFERSIZE2, *lppBuffer, (LPVOID FAR *)lppBuffer2) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"MAPIAllocateMore PASSED, %u bytes allocated", BUFFERSIZE2);
	else 	{
		LUIOut(L2,"MAPIAllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

#ifdef WAB
	if ((lpWABObject->AllocateMore(BUFFERSIZE2, *lppBuffer, (LPVOID FAR *)lppBuffer2) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"lpWABObject->AllocateMore PASSED, %u bytes allocated", BUFFERSIZE2);
	else 	{
		LUIOut(L2,"lpWABObject->AllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

	lppBuffer3 = new (DWORD*);
#ifdef PAB
	if ((MAPIAllocateMore(BUFFERSIZE3, *lppBuffer, (LPVOID FAR *)lppBuffer3) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"MAPIAllocateMore PASSED, %u bytes allocated", BUFFERSIZE3);
	else 	{
		LUIOut(L2,"MAPIAllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

#ifdef WAB
	if ((lpWABObject->AllocateMore(BUFFERSIZE3, *lppBuffer, (LPVOID FAR *)lppBuffer3) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"lpWABObject->AllocateMore PASSED, %u bytes allocated", BUFFERSIZE3);
	else 	{
		LUIOut(L2,"lpWABObject->AllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

	if ( !VerifyBuffer(lppBuffer,BUFFERSIZE) )
		retval = FALSE;
	if ( !VerifyBuffer(lppBuffer2,BUFFERSIZE2) )
		retval = FALSE;
	if ( !VerifyBuffer(lppBuffer3,BUFFERSIZE3) )
		retval = FALSE;


out:
#ifdef PAB
		if (*lppBuffer)	{
			if (MAPIFreeBuffer(*lppBuffer) == S_OK)
				LUIOut(L2,"MAPIFreeBuffer Succeded");	
			else 	LUIOut(L2,"MAPIFreeBuffer Failed");
		}

		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
#endif
#ifdef WAB
		if (*lppBuffer)	{
			if (lpWABObject->FreeBuffer(*lppBuffer) == S_OK)
				LUIOut(L2,"lpWABObject->FreeBuffer Succeded");	
			else 	LUIOut(L2,"lpWABObject->FreeBuffer Failed");
		}

		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
#endif

		if (lpAddress)
			lpAddress->Release();

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}

BOOL PABFreeBuffer()
{
    DWORD ** lppBuffer, ** lppBuffer2, ** lppBuffer3;
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

	ULONG       cValues = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int i=0,k=0;
	
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
    LPMAILUSER  lpAddress   = NULL;
	
	LUIOut(L1," ");
	LUIOut(L1,"Running FreeBuffer");
	LUIOut(L2,"-> Allocates memory using the AllocateBuffer routine");
	LUIOut(L2, "    followed by two calls to AllocateMore using different");
	LUIOut(L2, "    buffer sizes. It then frees the initial buffer and verifies");
	LUIOut(L2, "    that all 3 pointers are nullified.");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Allocate a buffer and check for success
	
	lppBuffer = new (DWORD*);
#ifdef PAB
	if ((MAPIAllocateBuffer(BUFFERSIZE, (LPVOID FAR *)lppBuffer) == S_OK) && *lppBuffer)
			LUIOut(L2,"MAPIAllocateBuffer PASSED");
	else 	{
		LUIOut(L2,"MAPIAllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

#ifdef WAB
	if ((lpWABObject->AllocateBuffer(BUFFERSIZE, (LPVOID FAR *)lppBuffer) == S_OK) && *lppBuffer)
			LUIOut(L2,"lpWABObject->AllocateBuffer PASSED");
	else 	{
		LUIOut(L2,"lpWABObject->AllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

	lppBuffer2 = new (DWORD*);
#ifdef PAB
	if ((MAPIAllocateMore(BUFFERSIZE2, *lppBuffer, (LPVOID FAR *)lppBuffer2) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"MAPIAllocateMore PASSED, %u bytes allocated", BUFFERSIZE2);
	else 	{
		LUIOut(L2,"MAPIAllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

#ifdef WAB
	if ((lpWABObject->AllocateMore(BUFFERSIZE2, *lppBuffer, (LPVOID FAR *)lppBuffer2) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"lpWABObject->AllocateMore PASSED, %u bytes allocated", BUFFERSIZE2);
	else 	{
		LUIOut(L2,"lpWABObject->AllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

	lppBuffer3 = new (DWORD*);
#ifdef PAB
	if ((MAPIAllocateMore(BUFFERSIZE3, *lppBuffer, (LPVOID FAR *)lppBuffer3) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"MAPIAllocateMore PASSED, %u bytes allocated", BUFFERSIZE3);
	else 	{
		LUIOut(L2,"MAPIAllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

#ifdef WAB
	if ((lpWABObject->AllocateMore(BUFFERSIZE3, *lppBuffer, (LPVOID FAR *)lppBuffer3) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"lpWABObject->AllocateMore PASSED, %u bytes allocated", BUFFERSIZE3);
	else 	{
		LUIOut(L2,"lpWABObject->AllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif


	// Now free the original buffer
#ifdef PAB
	if (*lppBuffer)	{
		if (MAPIFreeBuffer(*lppBuffer) == S_OK)
			LUIOut(L2,"Call to MAPIFreeBuffer Succeded");	
		else	{
			LUIOut(L2,"Call to MAPIFreeBuffer Failed");
		}
	}
#endif
#ifdef WAB
	if (*lppBuffer)	{
		if (lpWABObject->FreeBuffer(*lppBuffer) == S_OK)
			LUIOut(L2,"Call to lpWABObject->FreeBuffer Succeded");	
		else	{
			LUIOut(L2,"Call to lpWABObject->FreeBuffer Failed");
		}
	}
#endif

	/*
	dwTest = INVALIDPTR;
	//Verify all 3 pointers are now null
	if (IsBadReadPtr(*lppBuffer,BUFFERSIZE)&&IsBadReadPtr(*lppBuffer2, BUFFERSIZE2)
		&&IsBadReadPtr(*lppBuffer3, BUFFERSIZE3)){
		LUIOut(L2,"MAPIFreeBuffer Succeded, all pointers are invalidated");			
	}
	else	{	
		LUIOut(L2,"MAPIFreeBuffer Failed to invalidate all pointers");	
		retval = FALSE;
	}
	*/
out:

#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
#endif

		if (lpAddress)
			lpAddress->Release();

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}		 		 		


BOOL PAB_IABOpenEntry()
{
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpABCont= NULL, lpABCont2= NULL;
	LPABCONT	  lpDLCont= NULL;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	ULONG		  cbEidPAB = 0;
	LPENTRYID lpEid=NULL;

	ULONG       cValues = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int i=0,k=0;
	
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
    LPMAILUSER  lpAddress   = NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	SizedSPropTagArray(2, Cols) = { 2, {PR_OBJECT_TYPE, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;
    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IABOpenEntry");
	LUIOut(L2,"-> Verifies IAddrBook->OpenEntry is functional by checking the following:");
	LUIOut(L2, "   # The return code from OpenEntry");
	LUIOut(L2, "   # The object type returned is compared to MAPI_ABCONT");
	LUIOut(L2, "   # QueryInterface is called on the returned object and checked for success");
	LUIOut(L2, "   # Release is called on the interface ptr returned from QI and the reference");
	LUIOut(L2, "     count is tested for <= 0 (pass)");
	LUIOut(L1," ");

	
	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}


	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	LUIOut(L2, "Calling IABOpenEntry");
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr) || (!lpABCont)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}
	LUIOut(L3, "The call to IABOpenEntry PASSED");

	// Check to make sure the object type is what we expect

	LUIOut(L3, "Checking to make sure the returned object type is correct");
	if (ulObjType != MAPI_ABCONT) {
		LUIOut(L2, "Object type is not MAPI_ABCONT");
		retval = FALSE;
		goto out;
	}
	LUIOut(L3, "Object type is MAPI_ABCONT");
	
	
	// Call QueryInterface on the object
	LUIOut(L3, "Calling QueryInterface on the returned object");	
	hr = (lpABCont->QueryInterface((REFIID)(IID_IABContainer), (VOID **) &lpABCont2));
	if (HR_FAILED(hr))	{
		LUIOut(L2, "QueryInterface on IID_IABContainer FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "QueryInterface on IID_IABContainer PASSED");

	LUIOut(L3, "Trying to release the object QI returned");
	if(lpABCont2)	{
		if ((LPUNKNOWN)(lpABCont2)->Release() <= 0)
			LUIOut(L3, "QueryInterface returned a valid ptr and released succesfully");
		else	{
			LUIOut(L2, "Release FAILED:returned a > zero ref count");
		}
		lpABCont2 = NULL;

	}
	else {
		LUIOut(L2, "QueryInterface did not return a valid ptr");
		retval = FALSE;
		goto out;
	}

out:
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif

		if (lpAddress)
			lpAddress->Release();

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpABCont)
				lpABCont->Release();
		
		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}



BOOL PAB_IABContainerCreateEntry()
{
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpABCont= NULL, lpABCont2= NULL;
	LPABCONT	  lpPABCont= NULL,lpPABCont2= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

	ULONG       cValues = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int i=0,k=0;
	
    LPMAILUSER  lpAddress=NULL,lpAddress2=NULL,lpAddress3=NULL,lpAddress4=NULL;
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	SizedSPropTagArray(2, Cols) = { 2, {PR_OBJECT_TYPE, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;
    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IABContainerCreateEntry");
	LUIOut(L2,"-> Verifies IABContainer->CreateEntry is functional by performing the following:");
	LUIOut(L2, "   Attempts to CreateEntry with the MailUser template and checks...");
	LUIOut(L2, "   # The return code from CreateEntry");
	LUIOut(L2, "   # QueryInterface is called on the returned object and checked for success");
	LUIOut(L2, "   # Release is called on the interface ptr returned from QI and the reference");
	LUIOut(L2, "     count is tested for <= 0 (pass)");
	LUIOut(L2, "   Attempts to CreateEntry with the DistList template and checks...");
	LUIOut(L2, "   # The return code from CreateEntry");
	LUIOut(L2, "   # QueryInterface is called on the returned object and checked for success");
	LUIOut(L2, "   # Release is called on the interface ptr returned from QI and the reference");
	LUIOut(L2, "     count is tested for <= 0 (pass)");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Try to create a MailUser entry in the container
	//

	LUIOut(L2, "Creating a Mail User in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_MAILUSER property");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpAddress);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		retval=FALSE;			
	    goto out;
	}


	// Call QueryInterface on the object
	
	hr = (lpAddress->QueryInterface((REFIID)(IID_IMailUser), (VOID **) &lpAddress2));
	if (HR_FAILED(hr))	{
		LUIOut(L2, "QueryInterface on IID_IMailUser FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L2, "QueryInterface on IID_IMailUser PASSED");

	if(lpAddress2)	{
		if ((LPUNKNOWN)(lpAddress2)->Release() <= 0)
			LUIOut(L2, "QueryInterface returned a valid ptr and released succesfully");
		else	{
			LUIOut(L2, "Release FAILED:returned a > zero ref count");
		}
		lpAddress2 = NULL;

	}
	else {
		LUIOut(L2, "QueryInterface did not return a valid ptr");
		retval = FALSE;
		goto out;
	}

#ifdef DISTLIST
	//
	// Try to create a DL entry in the container
	//

	LUIOut(L2, "Creating a Distribution List in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_DL property");
	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_DL
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueDL);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps failed for Default DL template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_DL is an
    // EntryID which one can pass to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpAddress3);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
		retval=FALSE;			
	    goto out;
	}


	// Call QueryInterface on the object
	hr = (lpAddress3->QueryInterface((REFIID)(IID_IDistList), (VOID **) &lpAddress4));
	if (HR_FAILED(hr))	{
		LUIOut(L2, "QueryInterface on IID_IDistList FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L2, "QueryInterface on IID_IDistList PASSED");

	if(lpAddress4)	{
		if ((LPUNKNOWN)(lpAddress4)->Release() <= 0)
			LUIOut(L2, "QueryInterface returned a valid ptr and released succesfully");
		else	{
			LUIOut(L2, "Release FAILED:returned a > zero ref count");
		}
		lpAddress4 = NULL;

	}
	else {
		LUIOut(L2, "QueryInterface did not return a valid ptr");
		retval = FALSE;
		goto out;
	}
#endif

out:
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		if (lpAddress)
			lpAddress->Release();

		if (lpAddress2)
			lpAddress2->Release();

		if (lpAddress3)
			lpAddress3->Release();

		if (lpAddress4)
			lpAddress4->Release();

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpABCont)
				lpABCont->Release();

		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}



BOOL PAB_IDLSuite()
{
	BOOL	Cleanup;
    HRESULT hr      = hrSuccess;
	int		retval=TRUE;
	ULONG	cbEidPAB = 0;
	ULONG   cbEid=0;  // entry id of the entry being added
	ULONG   cValues = 0, ulObjType=NULL, cValues2;	
    ULONG   cRows           = 0;
	UINT	Entry, DL, NumEntries, NumDLs, PropIndex;
	char	szDLTag[SML_BUF], *lpszDisplayName = NULL, *lpszReturnName = NULL;
	EntryID	*lpEntries, *lpDLs;
	char	EntryBuf[MAX_BUF];
		
	LPENTRYID		lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST		lpEntryList=NULL; // needed for copy entry to PDL
    LPADRBOOK		lpAdrBook= NULL;
	LPABCONT		lpABCont= NULL;
    LPMAILUSER		lpMailUser=NULL;
	LPDISTLIST		lpDL=NULL,lpDL2=NULL;
	LPMAPITABLE		lpTable = NULL;
	LPSRowSet		lpRows = NULL;
	SRestriction	Restriction;
	SPropValue		*lpPropValue = NULL;		//Used to create props for the mailusers
	SPropValue		PropValue[1]= {0};			//
    LPSPropValue	lpSPropValueAddress = NULL; //Used to create default mailuser
    LPSPropValue	lpSPropValueEntryID = NULL; //Used to getprops on entryid of user
	LPSPropValue	lpSPropValueDL = NULL;		//Used to create default DL
    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IDLSuite");
	LUIOut(L2,"-> Tests Distribution List functionality by performing the following:");
	LUIOut(L2, "   Attempts to CreateEntry with the DistList template and checks...");
	LUIOut(L2, "   # The return code from CreateEntry");
	LUIOut(L2, "   # QueryInterface is called on the returned object and checked for success");
	LUIOut(L2, "   # Release is called on the interface ptr returned from QI and the reference");
	LUIOut(L2, "     count is tested for <= 0 (pass)");
	LUIOut(L2, "   Calls CreateEntry on the DistList object to add MailUser and DL members and checks...");
	LUIOut(L2, "   # The return code from CreateEntry");
	LUIOut(L2, "   # QueryInterface is called on the returned object and checked for success");
	LUIOut(L2, "   # Release is called on the interface ptr returned from QI and the reference");
	LUIOut(L2, "     count is tested for <= 0 (pass)");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Create MailUsers in the container
	//

	LUIOut(L2, "Creating MailUsers");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //
	// Retrieve user info from ini file
	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("DLTestSuite",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	//_itoa(0,(char*)lpszDisplayName[strlen(lpszDisplayName)],10);

	NumEntries = GetPrivateProfileInt("DLTestSuite","NumCopies",0,INIFILENAME);

	//Allocate an array of String pointers to hold the EntryIDs
	lpEntries = (EntryID*)LocalAlloc(LMEM_FIXED, NumEntries * sizeof(EntryID));
	lpszDisplayName = (char*)LocalAlloc(LMEM_FIXED, MAX_BUF);
	ParseIniBuffer(IN EntryBuf, IN 1, OUT lpszDisplayName);

	for (Entry = 0; Entry < NumEntries; Entry++)	{
		hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
			retval=FALSE;			
			goto out;
		}

		//
		// Then set the properties
		//
		CreateProps(IN INIFILENAME, IN "Properties", OUT &lpPropValue, OUT &cValues2, IN Entry, IN &lpszDisplayName, OUT &lpszReturnName);
	

		LUIOut(L3,"MailUser Entry to Add: %s",lpszReturnName);
			
		hr = lpMailUser->SetProps(IN  cValues2,
								 IN  lpPropValue,
								 IN  NULL);
			
		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SetProps call FAILED with 0x%x",hr);
	 		retval=FALSE;			
			goto out;
		}

		hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SaveChanges FAILED");
			retval=FALSE;
			goto out;
		}


		// Store the EID for deleting this entry later
		hr = lpMailUser->GetProps(   IN  (LPSPropTagArray) &SPTArrayEntryID,
								   IN  0,      //Flags
								   OUT &cValues,
								   OUT &lpSPropValueEntryID);

		if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps FAILED for MailUser");
	 			retval=FALSE;			
				goto out;
		}
		//Allocate space for the display name
		lpEntries[Entry].lpDisplayName = (char*)LocalAlloc(LMEM_FIXED, (strlen(lpszReturnName)+1));
		//Copy the DisplayName for use later
		strcpy(lpEntries[Entry].lpDisplayName, lpszReturnName);
		//Allocate space for the EID (lpb)
		lpEntries[Entry].lpb = (LPBYTE)LocalAlloc(LMEM_FIXED, lpSPropValueEntryID->Value.bin.cb);
		//Copy the EID for use later
		lpEntries[Entry].cb = lpSPropValueEntryID->Value.bin.cb;
		memcpy(lpEntries[Entry].lpb,lpSPropValueEntryID->Value.bin.lpb,
				lpEntries[Entry].cb);

		
		//Free the SPropValue for use in the next loop
		if (lpPropValue) {
			for (unsigned int Prop = 0; Prop < cValues2; Prop++) {
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_STRING8)	{
					if (lpPropValue[Prop].Value.LPSZ) {
						LocalFree(lpPropValue[Prop].Value.LPSZ);
						lpPropValue[Prop].Value.LPSZ = NULL;
					}
				}
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_BINARY) {
					if (lpPropValue[Prop].Value.bin.lpb) {
						LocalFree(lpPropValue[Prop].Value.bin.lpb);
						lpPropValue[Prop].Value.bin.lpb = NULL;
					}
				}
			}
			LocalFree(lpPropValue);
			lpPropValue=NULL;
		}

		if (lpSPropValueEntryID) {
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
			lpSPropValueEntryID = NULL;
		}
		lpMailUser->Release();
		lpMailUser = NULL;
	}
	
	
	//
	// Create the Distribution Lists in the container
	//
	NumDLs = GetPrivateProfileInt("DLTestSuite","NumDLs",0,INIFILENAME);
	lpDLs = (EntryID*)LocalAlloc(LMEM_FIXED, NumDLs * sizeof(EntryID));
	LUIOut(L2, "Creating Distribution Lists");
	for (DL = 0; DL < NumDLs; DL++) {

		hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
								   IN  0,      //Flags
								   OUT &cValues,
								   OUT &lpSPropValueDL);

		if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 			retval=FALSE;			
				goto out;
		}

		// The returned value of PR_DEF_CREATE_DL is an
		// EntryID which can be passed to CreateEntry
		//
		//LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
		hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
									 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
									 IN  0,
									 OUT (LPMAPIPROP *) &lpDL);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
			retval=FALSE;			
			goto out;
		}


		// Call QueryInterface on the object
		
		hr = (lpDL->QueryInterface((REFIID)(IID_IDistList), (VOID **) &lpDL2));
		if (HR_FAILED(hr))	{
			LUIOut(L4, "QueryInterface on IID_IDistList FAILED. hr = 0x%x", hr);
			retval = FALSE;
			goto out;
		}
		else LUIOut(L4, "QueryInterface on IID_IDistList PASSED");

		lstrcpy(szDLTag,"DistList1");
		GetPrivateProfileString("DLTestSuite",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
		PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

		//StrLen2 = (StrLen1 + sprintf((char*)&EntProp[0][StrLen1], " [Thread #%i] - ", *(int *)lpThreadNum));	
		_itoa(DL,(char*)&EntryBuf[strlen(EntryBuf)],10);

		LUIOut(L3,"DistList Entry to Add: %s",EntryBuf);
		cValues = 1;		
		PropValue[0].Value.LPSZ = (LPTSTR)EntryBuf;
		hr = lpDL->SetProps(IN  cValues,
								 IN  PropValue,
								 IN  NULL);
			
		if (HR_FAILED(hr)) {
			LUIOut(L3,"DL->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 		retval=FALSE;			
			goto out;
		}

		hr = lpDL->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

		if (HR_FAILED(hr)) {
			LUIOut(L3,"DL->SaveChanges FAILED");
			retval=FALSE;
			goto out;
		}

		// Want a container interface to the DL, and since QueryInterface on a DL
		// is currently broken (returns a MailUser interface when called with IID_IDistList)
		// we do it the hard way. Call GetProps to get the EID for the new DL, and then
		// call OpenEntry from the container or AB interfaces to open a DL interface
		hr = lpDL->GetProps(   IN  (LPSPropTagArray) &SPTArrayEntryID,
								   IN  0,      //Flags
								   OUT &cValues,
								   OUT &lpSPropValueEntryID);

		if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps FAILED for MailUser");
	 			retval=FALSE;			
				goto out;
		}

		lpDL2->Release();	//Free up this pointer so we can recycle it
		hr = lpABCont->OpenEntry(IN		lpSPropValueEntryID->Value.bin.cb,
								 IN		(LPENTRYID) lpSPropValueEntryID->Value.bin.lpb,
								 IN		&IID_IDistList,
								 IN		MAPI_BEST_ACCESS,
								 OUT	&ulObjType,
								 OUT	(LPUNKNOWN*) &lpDL2);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"OpenEntry failed for DistList");
			retval=FALSE;			
			goto out;
		}

		LUIOut(L3, "Adding MailUser Members to the Distribution List");
		
		//
		// Now add mailuser entries to the DL
		//
		for (Entry = 0; Entry < NumEntries; Entry++)	{
			hr = lpDL2->CreateEntry(  IN  lpEntries[Entry].cb,
									 IN  (LPENTRYID) lpEntries[Entry].lpb,
									 IN  0,
									 OUT (LPMAPIPROP *) &lpMailUser);

			if (HR_FAILED(hr)) {
				LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
				retval=FALSE;			
				goto out;
			}

			hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

			if (HR_FAILED(hr)) {
				LUIOut(L3,"MailUser->SaveChanges FAILED");
				retval=FALSE;
				goto out;
			}
			lpMailUser->Release();
			lpMailUser = NULL;
		}

		//Allocate space for the display name
		lpDLs[DL].lpDisplayName = (char*)LocalAlloc(LMEM_FIXED, (strlen(EntryBuf)+1));
		//Copy the DisplayName for use later
		strcpy(lpDLs[DL].lpDisplayName, EntryBuf);
		//Allocate space for the EID (lpb)
		lpDLs[DL].lpb = (LPBYTE)LocalAlloc(LMEM_FIXED, lpSPropValueEntryID->Value.bin.cb);
		//Copy the EID for use later
		lpDLs[DL].cb = lpSPropValueEntryID->Value.bin.cb;
		memcpy(lpDLs[DL].lpb,lpSPropValueEntryID->Value.bin.lpb,
				lpDLs[DL].cb);
		
		if (lpSPropValueEntryID) {
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
			lpSPropValueEntryID = NULL;
		}
		if (lpSPropValueDL) {
			lpWABObject->FreeBuffer(lpSPropValueDL);
			lpSPropValueDL = NULL;
		}
		lpDL->Release();
		lpDL = NULL;
		lpDL2->Release();
		lpDL2 = NULL;
	}

	//
	// Verify all entries are in the DL
	//
	LUIOut(L2, "Verifying MailUser Members are in the Distribution List");

	for (DL = 0; DL < NumDLs; DL++) {
		// Need to get an interface to the DL
		hr = lpABCont->OpenEntry(IN		lpDLs[DL].cb,
								 IN		(LPENTRYID) lpDLs[DL].lpb,
								 IN		&IID_IDistList,
								 IN		MAPI_BEST_ACCESS,
								 OUT	&ulObjType,
								 OUT	(LPUNKNOWN*) &lpDL);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"OpenEntry failed for DistList");
			retval=FALSE;			
			goto out;
		}

		// Create a contents table to verify each added entry exists in the DL
		hr = lpDL->GetContentsTable(ULONG(0), &lpTable);
		if (HR_FAILED(hr)) {
			LUIOut(L3,"DistList->GetContentsTable call FAILED, returned 0x%x", hr);
			retval=FALSE;
			goto out;
		}

		// Allocate the SpropValue ptr in the restriction structure
		lpWABObject->AllocateBuffer(sizeof(SPropValue), (void**)&(Restriction.res.resProperty.lpProp));
		Restriction.res.resProperty.lpProp = (SPropValue*)Restriction.res.resProperty.lpProp;
		for (Entry = 0; Entry < NumEntries; Entry++) {
			hr = lpDL->OpenEntry(	IN		lpEntries[Entry].cb,
									IN		(LPENTRYID) lpEntries[Entry].lpb,
									IN		&IID_IMailUser,
									IN		MAPI_BEST_ACCESS,
									OUT	&ulObjType,
									OUT	(LPUNKNOWN*) &lpMailUser);

			if (HR_FAILED(hr)) {
				LUIOut(L3,"OpenEntry failed for DistList");
				retval=FALSE;			
				goto out;
			}
		
			lpMailUser->Release();
			lpMailUser = NULL;

			// Build the restriction structure to pass to lpTable->Restrict
		
			//** For testing the fail case only, stub out for real testing
			// lstrcpy(lpszDisplayNames[Counter2], "This should not match");
			//**
			Restriction.rt = RES_PROPERTY;					//Property restriction
			Restriction.res.resProperty.relop = RELOP_EQ;	//Equals
			Restriction.res.resProperty.ulPropTag = PR_DISPLAY_NAME;
			Restriction.res.resProperty.lpProp->ulPropTag = PR_DISPLAY_NAME;
			Restriction.res.resProperty.lpProp->Value.LPSZ = lpEntries[Entry].lpDisplayName;

			hr = lpTable->Restrict(&Restriction, ULONG(0));
			if (HR_FAILED(hr)) {
				LUIOut(L3,"Table->Restrict call FAILED, returned 0x%x", hr);
				retval=FALSE;
				goto out;
			}

			hr = lpTable->QueryRows(LONG(1),
									ULONG(0),
									&lpRows);
			if (HR_FAILED(hr)) {
				LUIOut(L3,"Table->QueryRows call FAILED: Entry #%i, returned 0x%x", Entry, hr);
				retval=FALSE;
				goto out;
			}

			if (!lpRows->cRows) {
				LUIOut(L2, "QueryRows did not find entry #%i. Test FAILED", Entry);
				retval=FALSE;
				goto out;
			}

			//** For testing purposes only, stub out for real testing
			//InitializeCriticalSection(&CriticalSection);
			//EnterCriticalSection(&CriticalSection);
			//DisplayRows(lpRows);
			//LeaveCriticalSection(&CriticalSection);
			//**

			// Does the user want us to cleanup after ourself?
			Cleanup = GetPrivateProfileInt("DLTestSuite","Cleanup",1,INIFILENAME);
		
			if (Cleanup) {
				// Change the EntryID to a LPENTRYLIST
				FindPropinRow(&lpRows->aRow[0],
							 PR_ENTRYID,
							 &PropIndex);
				hr = HrCreateEntryListFromID(lpWABObject,
						IN  lpRows->aRow[0].lpProps[PropIndex].Value.bin.cb,
						IN  (ENTRYID*)lpRows->aRow[0].lpProps[PropIndex].Value.bin.lpb,
						OUT &lpEntryList);
				if (HR_FAILED(hr)) {
						LUIOut(L3,"Could not Create Entry List");
						retval=FALSE;
						goto out;
				}

				// Then pass the lpEntryList to DeleteEntries to delete ...
				hr = lpDL->DeleteEntries(IN  lpEntryList,IN  0);

				if (HR_FAILED(hr)) {
						LUIOut(L3,"Could not Delete Entry %i. DeleteEntry returned 0x%x", Entry, hr);
						FreeEntryList(lpWABObject, &lpEntryList);
						retval=FALSE;
						goto out;
				}


				FreeRows(lpWABObject, &lpRows);	// Cleanup from first call to queryrows

				// Verify the entry was deleted by calling QueryRows again
				hr = lpTable->QueryRows(LONG(1),
										ULONG(0),
										&lpRows);
				if (HR_FAILED(hr)) {
					LUIOut(L3,"Table->QueryRows call FAILED: Entry #%i, returned 0x%x", Entry, hr);
					retval=FALSE;
					goto out;
				}

				if (lpRows->cRows) {	// Should be 0 if deleted
					LUIOut(L2, "QueryRows found entry #%i even tho it was deleted. Test FAILED", Entry);
					retval=FALSE;
					goto out;
				}
			}
			//Cleanup
			FreeRows(lpWABObject, &lpRows);	// Cleanup from second call to queryrows
			if (lpEntryList) {
				FreeEntryList(lpWABObject, &lpEntryList);
				lpEntryList = NULL;
			}
		}
		LUIOut(L3, "All members verified for Distribution List #%i", DL);

		//Free up memory
		lpWABObject->FreeBuffer(Restriction.res.resProperty.lpProp);
		if (lpTable) {
			lpTable->Release();
			lpTable = NULL;
		}
		lpDL->Release();
		lpDL = NULL;
	}
	//
	// Cleanup the WAB
	//
	if (Cleanup) {

		LUIOut(L2, "Cleanup: Removing MailUsers");
		// First, delete the MailUser entries from the wab
		for (Entry = 0; Entry < NumEntries; Entry++)	{
			hr = HrCreateEntryListFromID(lpWABObject,
				IN  lpEntries[Entry].cb,
				IN  (ENTRYID*)lpEntries[Entry].lpb,
				OUT &lpEntryList);
			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Create Entry List");
					retval=FALSE;
					goto out;
			}

			// Then pass the lpEntryList to DeleteEntries to delete ...
			hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
					FreeEntryList(lpWABObject, &lpEntryList);
					retval=FALSE;
					goto out;
			}
			
			LocalFree((HLOCAL)lpEntries[Entry].lpDisplayName);
			LocalFree((HLOCAL)lpEntries[Entry].lpb);
			FreeEntryList(lpWABObject, &lpEntryList);
		}

		LocalFree((HLOCAL)lpEntries);
	
		LUIOut(L2, "Cleanup: Removing Distribution Lists");
		// Now, delete the Distribution Lists from the wab
		for (DL = 0; DL < NumDLs; DL++)	{
			hr = HrCreateEntryListFromID(lpWABObject,
				IN  lpDLs[DL].cb,
				IN  (ENTRYID*)lpDLs[DL].lpb,
				OUT &lpEntryList);
			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Create Entry List");
					retval=FALSE;
					goto out;
			}

			// Then pass the lpEntryList to DeleteEntries to delete ...
			hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
					FreeEntryList(lpWABObject, &lpEntryList);
					retval=FALSE;
					goto out;
			}
			
			LocalFree((HLOCAL)lpDLs[DL].lpDisplayName);
			LocalFree((HLOCAL)lpDLs[DL].lpb);
			FreeEntryList(lpWABObject, &lpEntryList);
		}
		LocalFree((HLOCAL)lpDLs);
	}
	else {
		LUIOut(L2, "Cleanup: User has requested that the MailUser entries and DistLists not be removed");
		for (Entry = 0; Entry < NumEntries; Entry++)	{
			LocalFree((HLOCAL)lpEntries[Entry].lpDisplayName);
			LocalFree((HLOCAL)lpEntries[Entry].lpb);
		}
		LocalFree((HLOCAL)lpEntries);
	
		for (DL = 0; DL < NumDLs; DL++)	{
			LocalFree((HLOCAL)lpDLs[DL].lpDisplayName);
			LocalFree((HLOCAL)lpDLs[DL].lpb);
		}
		LocalFree((HLOCAL)lpDLs);
	}
	

out:
#ifdef PAB
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		//if (lpszDisplayName) LocalFree(lpszDisplayName);
		if (lpMailUser)
			lpMailUser->Release();

		if (lpDL)
			lpDL->Release();

		if (lpDL2)
			lpDL2->Release();

		if (lpTable)
			lpTable->Release();

		if (lpABCont)
				lpABCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}


BOOL NamedPropsSuite()
{
	BOOL	Cleanup;
    HRESULT hr      = hrSuccess;
	int		retval=TRUE;
	ULONG	cbEidPAB = 0;
	ULONG   cbEid=0;  // entry id of the entry being added
	ULONG   cValues = 0, ulObjType=NULL, cValues2;	
    ULONG   cRows           = 0;
	UINT	Entry, DL, NumEntries, NumDLs, PropIndex;
	char	szDLTag[SML_BUF], *lpszDisplayName = NULL, *lpszReturnName = NULL;
	EntryID	*lpEntries, *lpDLs;
	char	EntryBuf[MAX_BUF];
		
	LPENTRYID		lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST		lpEntryList=NULL; // needed for copy entry to PDL
    LPADRBOOK		lpAdrBook= NULL;
	LPABCONT		lpABCont= NULL;
    LPMAILUSER		lpMailUser=NULL;
	LPDISTLIST		lpDL=NULL,lpDL2=NULL;
	LPMAPITABLE		lpTable = NULL;
	LPSRowSet		lpRows = NULL;
	SRestriction	Restriction;
	SPropValue		*lpPropValue = NULL;		//Used to create props for the mailusers
	SPropValue		PropValue[1]= {0};			//
    LPSPropValue	lpSPropValueAddress = NULL; //Used to create default mailuser
    LPSPropValue	lpSPropValueEntryID = NULL; //Used to getprops on entryid of user
	LPSPropValue	lpSPropValueDL = NULL;		//Used to create default DL
    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
    MAPINAMEID		mnid[3];
	LPMAPINAMEID	lpmnid = &(mnid[0]);
    LPSPropTagArray lpNamedPropTags = NULL;
    SPropValue		spv[3];

	
/*	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IDLSuite");
	LUIOut(L2,"-> Tests Distribution List functionality by performing the following:");
	LUIOut(L2, "   Attempts to CreateEntry with the DistList template and checks...");
	LUIOut(L2, "   # The return code from CreateEntry");
	LUIOut(L2, "   # QueryInterface is called on the returned object and checked for success");
	LUIOut(L2, "   # Release is called on the interface ptr returned from QI and the reference");
	LUIOut(L2, "     count is tested for <= 0 (pass)");
	LUIOut(L2, "   Calls CreateEntry on the DistList object to add MailUser and DL members and checks...");
	LUIOut(L2, "   # The return code from CreateEntry");
	LUIOut(L2, "   # QueryInterface is called on the returned object and checked for success");
	LUIOut(L2, "   # Release is called on the interface ptr returned from QI and the reference");
	LUIOut(L2, "     count is tested for <= 0 (pass)");
*/	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Create MailUsers in the container
	//

	LUIOut(L2, "Creating MailUsers");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //
	// Retrieve user info from ini file
	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("NamedPropsTestSuite",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	//_itoa(0,(char*)lpszDisplayName[strlen(lpszDisplayName)],10);

	NumEntries = GetPrivateProfileInt("NamedPropsTestSuite","NumCopies",0,INIFILENAME);

	//Allocate an array of String pointers to hold the EntryIDs
	lpEntries = (EntryID*)LocalAlloc(LMEM_FIXED, NumEntries * sizeof(EntryID));
	lpszDisplayName = (char*)LocalAlloc(LMEM_FIXED, MAX_BUF);
	ParseIniBuffer(IN EntryBuf, IN 1, OUT lpszDisplayName);

	for (Entry = 0; Entry < NumEntries; Entry++)	{
		hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
			retval=FALSE;			
			goto out;
		}

		//
		// Then set the properties
		//
		CreateProps(IN INIFILENAME, IN "Properties", OUT &lpPropValue, OUT &cValues2, IN Entry, IN &lpszDisplayName, OUT &lpszReturnName);
	

		LUIOut(L3,"MailUser Entry to Add: %s",lpszReturnName);
			
		hr = lpMailUser->SetProps(IN  cValues2,
								 IN  lpPropValue,
								 IN  NULL);
			
		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SetProps call FAILED with 0x%x",hr);
	 		retval=FALSE;			
			goto out;
		}

		//
		// Create and save 3 Named Properties
		//

	    mnid[0].lpguid = &WabTestGUID;
	    mnid[0].ulKind = MNID_STRING;    //  This means union will contain a UNICODE string...
		mnid[0].Kind.lpwstrName = L"A long test string of little meaning or relevance entered here ~!@#$%^&*{}[]()";

	    mnid[1].lpguid = &WabTestGUID;
		mnid[1].ulKind = MNID_ID;        //  This means union will contain a long...
		mnid[1].Kind.lID = 0x00000000;   // numeric property 1

	    mnid[2].lpguid = &WabTestGUID;
		mnid[2].ulKind = MNID_ID;        //  This means union will contain a long...
		mnid[2].Kind.lID = 0xFFFFFFFF;   // numeric property 1
		
		hr = lpMailUser->GetIDsFromNames(3, // named props in the array
		  &lpmnid, // &-of because this is an array
		  MAPI_CREATE,
		  &lpNamedPropTags);
		if (hr) {
			//
			//  I'd really be suprised if I got S_OK for this...
			//
			if (GetScode(hr) != MAPI_W_ERRORS_RETURNED) {
				//  Real error here
				retval = FALSE;
				goto out;
			}

			//  Basically, this means you don't have anything by this name and you
			//  didn't ask the object to create it.

			//$ no biggie
		}

		LUIOut(L4, "GetIDsFromNames returned %i tags.", lpNamedPropTags->cValues);
		//
		//  Ok, so what can I do with this ptaga?  Well, we can set a value for it by doing:
		//
		spv[0].ulPropTag = CHANGE_PROP_TYPE(lpNamedPropTags->aulPropTag[0],PT_STRING8);
		spv[0].Value.lpszA = "More meaningless testing text of no consequence !@#$%&*()_+[]{}";
		spv[1].ulPropTag = CHANGE_PROP_TYPE(lpNamedPropTags->aulPropTag[1],PT_LONG);
		spv[1].Value.l = 0x5A5A5A5A;
		spv[2].ulPropTag = CHANGE_PROP_TYPE(lpNamedPropTags->aulPropTag[2],PT_BINARY);
		GenerateRandomBinary(&(spv[2].Value.bin),256); // stick 256 bytes of random data in there

		hr = lpMailUser->SetProps(
		  3,
		  &spv[0],
		  NULL);
		if (HR_FAILED(hr)) {
			goto out;
		}
		hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SaveChanges FAILED");
			retval=FALSE;
			goto out;
		}


		// Store the EID for deleting this entry later
		hr = lpMailUser->GetProps(   IN  (LPSPropTagArray) &SPTArrayEntryID,
								   IN  0,      //Flags
								   OUT &cValues,
								   OUT &lpSPropValueEntryID);

		if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps FAILED for MailUser");
	 			retval=FALSE;			
				goto out;
		}
		//Allocate space for the display name
		lpEntries[Entry].lpDisplayName = (char*)LocalAlloc(LMEM_FIXED, (strlen(lpszReturnName)+1));
		//Copy the DisplayName for use later
		strcpy(lpEntries[Entry].lpDisplayName, lpszReturnName);
		//Allocate space for the EID (lpb)
		lpEntries[Entry].lpb = (LPBYTE)LocalAlloc(LMEM_FIXED, lpSPropValueEntryID->Value.bin.cb);
		//Copy the EID for use later
		lpEntries[Entry].cb = lpSPropValueEntryID->Value.bin.cb;
		memcpy(lpEntries[Entry].lpb,lpSPropValueEntryID->Value.bin.lpb,
				lpEntries[Entry].cb);

		
		//Free the SPropValue for use in the next loop
		if (lpPropValue) {
			for (unsigned int Prop = 0; Prop < cValues2; Prop++) {
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_STRING8)	{
					if (lpPropValue[Prop].Value.LPSZ) {
						LocalFree(lpPropValue[Prop].Value.LPSZ);
						lpPropValue[Prop].Value.LPSZ = NULL;
					}
				}
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_BINARY) {
					if (lpPropValue[Prop].Value.bin.lpb) {
						LocalFree(lpPropValue[Prop].Value.bin.lpb);
						lpPropValue[Prop].Value.bin.lpb = NULL;
					}
				}
			}
			LocalFree(lpPropValue);
			lpPropValue=NULL;
		}

		if (lpSPropValueEntryID) {
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
			lpSPropValueEntryID = NULL;
		}
		lpMailUser->Release();
		lpMailUser = NULL;
	}
	
	
	//
	// Create the Distribution Lists in the container
	//
	NumDLs = GetPrivateProfileInt("NamedPropsTestSuite","NumDLs",0,INIFILENAME);
	lpDLs = (EntryID*)LocalAlloc(LMEM_FIXED, NumDLs * sizeof(EntryID));
	LUIOut(L2, "Creating Distribution Lists");
	for (DL = 0; DL < NumDLs; DL++) {

		hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
								   IN  0,      //Flags
								   OUT &cValues,
								   OUT &lpSPropValueDL);

		if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 			retval=FALSE;			
				goto out;
		}

		// The returned value of PR_DEF_CREATE_DL is an
		// EntryID which can be passed to CreateEntry
		//
		//LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
		hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
									 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
									 IN  0,
									 OUT (LPMAPIPROP *) &lpDL);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
			retval=FALSE;			
			goto out;
		}


		// Call QueryInterface on the object
		
		hr = (lpDL->QueryInterface((REFIID)(IID_IDistList), (VOID **) &lpDL2));
		if (HR_FAILED(hr))	{
			LUIOut(L4, "QueryInterface on IID_IDistList FAILED. hr = 0x%x", hr);
			retval = FALSE;
			goto out;
		}
		else LUIOut(L4, "QueryInterface on IID_IDistList PASSED");

		lstrcpy(szDLTag,"DistList1");
		GetPrivateProfileString("NamedPropsTestSuite",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
		PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

		//StrLen2 = (StrLen1 + sprintf((char*)&EntProp[0][StrLen1], " [Thread #%i] - ", *(int *)lpThreadNum));	
		_itoa(DL,(char*)&EntryBuf[strlen(EntryBuf)],10);

		LUIOut(L3,"DistList Entry to Add: %s",EntryBuf);
		cValues = 1;		
		PropValue[0].Value.LPSZ = (LPTSTR)EntryBuf;
		hr = lpDL->SetProps(IN  cValues,
								 IN  PropValue,
								 IN  NULL);
			
		if (HR_FAILED(hr)) {
			LUIOut(L3,"DL->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 		retval=FALSE;			
			goto out;
		}

		hr = lpDL->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

		if (HR_FAILED(hr)) {
			LUIOut(L3,"DL->SaveChanges FAILED");
			retval=FALSE;
			goto out;
		}

		// Want a container interface to the DL, and since QueryInterface on a DL
		// is currently broken (returns a MailUser interface when called with IID_IDistList)
		// we do it the hard way. Call GetProps to get the EID for the new DL, and then
		// call OpenEntry from the container or AB interfaces to open a DL interface
		hr = lpDL->GetProps(   IN  (LPSPropTagArray) &SPTArrayEntryID,
								   IN  0,      //Flags
								   OUT &cValues,
								   OUT &lpSPropValueEntryID);

		if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps FAILED for MailUser");
	 			retval=FALSE;			
				goto out;
		}

		lpDL2->Release();	//Free up this pointer so we can recycle it
		hr = lpABCont->OpenEntry(IN		lpSPropValueEntryID->Value.bin.cb,
								 IN		(LPENTRYID) lpSPropValueEntryID->Value.bin.lpb,
								 IN		&IID_IDistList,
								 IN		MAPI_BEST_ACCESS,
								 OUT	&ulObjType,
								 OUT	(LPUNKNOWN*) &lpDL2);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"OpenEntry failed for DistList");
			retval=FALSE;			
			goto out;
		}

		LUIOut(L3, "Adding MailUser Members to the Distribution List");
		
		//
		// Now add mailuser entries to the DL
		//
		for (Entry = 0; Entry < NumEntries; Entry++)	{
			hr = lpDL2->CreateEntry(  IN  lpEntries[Entry].cb,
									 IN  (LPENTRYID) lpEntries[Entry].lpb,
									 IN  0,
									 OUT (LPMAPIPROP *) &lpMailUser);

			if (HR_FAILED(hr)) {
				LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
				retval=FALSE;			
				goto out;
			}

			hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

			if (HR_FAILED(hr)) {
				LUIOut(L3,"MailUser->SaveChanges FAILED");
				retval=FALSE;
				goto out;
			}
			lpMailUser->Release();
			lpMailUser = NULL;
		}

		//Allocate space for the display name
		lpDLs[DL].lpDisplayName = (char*)LocalAlloc(LMEM_FIXED, (strlen(EntryBuf)+1));
		//Copy the DisplayName for use later
		strcpy(lpDLs[DL].lpDisplayName, EntryBuf);
		//Allocate space for the EID (lpb)
		lpDLs[DL].lpb = (LPBYTE)LocalAlloc(LMEM_FIXED, lpSPropValueEntryID->Value.bin.cb);
		//Copy the EID for use later
		lpDLs[DL].cb = lpSPropValueEntryID->Value.bin.cb;
		memcpy(lpDLs[DL].lpb,lpSPropValueEntryID->Value.bin.lpb,
				lpDLs[DL].cb);
		
		if (lpSPropValueEntryID) {
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
			lpSPropValueEntryID = NULL;
		}
		if (lpSPropValueDL) {
			lpWABObject->FreeBuffer(lpSPropValueDL);
			lpSPropValueDL = NULL;
		}
		lpDL->Release();
		lpDL = NULL;
		lpDL2->Release();
		lpDL2 = NULL;
	}

	//
	// Verify all entries are in the DL
	//
	LUIOut(L2, "Verifying MailUser Members are in the Distribution List");

	for (DL = 0; DL < NumDLs; DL++) {
		// Need to get an interface to the DL
		hr = lpABCont->OpenEntry(IN		lpDLs[DL].cb,
								 IN		(LPENTRYID) lpDLs[DL].lpb,
								 IN		&IID_IDistList,
								 IN		MAPI_BEST_ACCESS,
								 OUT	&ulObjType,
								 OUT	(LPUNKNOWN*) &lpDL);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"OpenEntry failed for DistList");
			retval=FALSE;			
			goto out;
		}

		// Create a contents table to verify each added entry exists in the DL
		hr = lpDL->GetContentsTable(ULONG(0), &lpTable);
		if (HR_FAILED(hr)) {
			LUIOut(L3,"DistList->GetContentsTable call FAILED, returned 0x%x", hr);
			retval=FALSE;
			goto out;
		}

		// Allocate the SpropValue ptr in the restriction structure
		lpWABObject->AllocateBuffer(sizeof(SPropValue), (void**)&(Restriction.res.resProperty.lpProp));
		Restriction.res.resProperty.lpProp = (SPropValue*)Restriction.res.resProperty.lpProp;
		for (Entry = 0; Entry < NumEntries; Entry++) {
			hr = lpDL->OpenEntry(	IN		lpEntries[Entry].cb,
									IN		(LPENTRYID) lpEntries[Entry].lpb,
									IN		&IID_IMailUser,
									IN		MAPI_BEST_ACCESS,
									OUT	&ulObjType,
									OUT	(LPUNKNOWN*) &lpMailUser);

			if (HR_FAILED(hr)) {
				LUIOut(L3,"OpenEntry failed for DistList");
				retval=FALSE;			
				goto out;
			}
		
			lpMailUser->Release();
			lpMailUser = NULL;

			// Build the restriction structure to pass to lpTable->Restrict
		
			//** For testing the fail case only, stub out for real testing
			// lstrcpy(lpszDisplayNames[Counter2], "This should not match");
			//**
			Restriction.rt = RES_PROPERTY;					//Property restriction
			Restriction.res.resProperty.relop = RELOP_EQ;	//Equals
			Restriction.res.resProperty.ulPropTag = PR_DISPLAY_NAME;
			Restriction.res.resProperty.lpProp->ulPropTag = PR_DISPLAY_NAME;
			Restriction.res.resProperty.lpProp->Value.LPSZ = lpEntries[Entry].lpDisplayName;

			hr = lpTable->Restrict(&Restriction, ULONG(0));
			if (HR_FAILED(hr)) {
				LUIOut(L3,"Table->Restrict call FAILED, returned 0x%x", hr);
				retval=FALSE;
				goto out;
			}

			hr = lpTable->QueryRows(LONG(1),
									ULONG(0),
									&lpRows);
			if (HR_FAILED(hr)) {
				LUIOut(L3,"Table->QueryRows call FAILED: Entry #%i, returned 0x%x", Entry, hr);
				retval=FALSE;
				goto out;
			}

			if (!lpRows->cRows) {
				LUIOut(L2, "QueryRows did not find entry #%i. Test FAILED", Entry);
				retval=FALSE;
				goto out;
			}

			//** For testing purposes only, stub out for real testing
			//InitializeCriticalSection(&CriticalSection);
			//EnterCriticalSection(&CriticalSection);
			//DisplayRows(lpRows);
			//LeaveCriticalSection(&CriticalSection);
			//**

			// Does the user want us to cleanup after ourself?
			Cleanup = GetPrivateProfileInt("NamedPropsTestSuite","Cleanup",1,INIFILENAME);
		
			if (Cleanup) {
				// Change the EntryID to a LPENTRYLIST
				FindPropinRow(&lpRows->aRow[0],
							 PR_ENTRYID,
							 &PropIndex);
				hr = HrCreateEntryListFromID(lpWABObject,
						IN  lpRows->aRow[0].lpProps[PropIndex].Value.bin.cb,
						IN  (ENTRYID*)lpRows->aRow[0].lpProps[PropIndex].Value.bin.lpb,
						OUT &lpEntryList);
				if (HR_FAILED(hr)) {
						LUIOut(L3,"Could not Create Entry List");
						retval=FALSE;
						goto out;
				}

				// Then pass the lpEntryList to DeleteEntries to delete ...
				hr = lpDL->DeleteEntries(IN  lpEntryList,IN  0);

				if (HR_FAILED(hr)) {
						LUIOut(L3,"Could not Delete Entry %i. DeleteEntry returned 0x%x", Entry, hr);
						FreeEntryList(lpWABObject, &lpEntryList);
						retval=FALSE;
						goto out;
				}


				FreeRows(lpWABObject, &lpRows);	// Cleanup from first call to queryrows

				// Verify the entry was deleted by calling QueryRows again
				hr = lpTable->QueryRows(LONG(1),
										ULONG(0),
										&lpRows);
				if (HR_FAILED(hr)) {
					LUIOut(L3,"Table->QueryRows call FAILED: Entry #%i, returned 0x%x", Entry, hr);
					retval=FALSE;
					goto out;
				}

				if (lpRows->cRows) {	// Should be 0 if deleted
					LUIOut(L2, "QueryRows found entry #%i even tho it was deleted. Test FAILED", Entry);
					retval=FALSE;
					goto out;
				}
			}
			//Cleanup
			FreeRows(lpWABObject, &lpRows);	// Cleanup from second call to queryrows
			if (lpEntryList) {
				FreeEntryList(lpWABObject, &lpEntryList);
				lpEntryList = NULL;
			}
		}
		LUIOut(L3, "All members verified for Distribution List #%i", DL);

		//Free up memory
		lpWABObject->FreeBuffer(Restriction.res.resProperty.lpProp);
		if (lpTable) {
			lpTable->Release();
			lpTable = NULL;
		}
		lpDL->Release();
		lpDL = NULL;
	}
	//
	// Cleanup the WAB
	//
	if (Cleanup) {

		LUIOut(L2, "Cleanup: Removing MailUsers");
		// First, delete the MailUser entries from the wab
		for (Entry = 0; Entry < NumEntries; Entry++)	{
			hr = HrCreateEntryListFromID(lpWABObject,
				IN  lpEntries[Entry].cb,
				IN  (ENTRYID*)lpEntries[Entry].lpb,
				OUT &lpEntryList);
			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Create Entry List");
					retval=FALSE;
					goto out;
			}

			// Then pass the lpEntryList to DeleteEntries to delete ...
			hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
					FreeEntryList(lpWABObject, &lpEntryList);
					retval=FALSE;
					goto out;
			}
			
			LocalFree((HLOCAL)lpEntries[Entry].lpDisplayName);
			LocalFree((HLOCAL)lpEntries[Entry].lpb);
			FreeEntryList(lpWABObject, &lpEntryList);
		}

		LocalFree((HLOCAL)lpEntries);
	
		LUIOut(L2, "Cleanup: Removing Distribution Lists");
		// Now, delete the Distribution Lists from the wab
		for (DL = 0; DL < NumDLs; DL++)	{
			hr = HrCreateEntryListFromID(lpWABObject,
				IN  lpDLs[DL].cb,
				IN  (ENTRYID*)lpDLs[DL].lpb,
				OUT &lpEntryList);
			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Create Entry List");
					retval=FALSE;
					goto out;
			}

			// Then pass the lpEntryList to DeleteEntries to delete ...
			hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
					FreeEntryList(lpWABObject, &lpEntryList);
					retval=FALSE;
					goto out;
			}
			
			LocalFree((HLOCAL)lpDLs[DL].lpDisplayName);
			LocalFree((HLOCAL)lpDLs[DL].lpb);
			FreeEntryList(lpWABObject, &lpEntryList);
		}
		LocalFree((HLOCAL)lpDLs);
	}
	else {
		LUIOut(L2, "Cleanup: User has requested that the MailUser entries and DistLists not be removed");
		for (Entry = 0; Entry < NumEntries; Entry++)	{
			LocalFree((HLOCAL)lpEntries[Entry].lpDisplayName);
			LocalFree((HLOCAL)lpEntries[Entry].lpb);
		}
		LocalFree((HLOCAL)lpEntries);
	
		for (DL = 0; DL < NumDLs; DL++)	{
			LocalFree((HLOCAL)lpDLs[DL].lpDisplayName);
			LocalFree((HLOCAL)lpDLs[DL].lpb);
		}
		LocalFree((HLOCAL)lpDLs);
	}
	

out:
#ifdef PAB
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		//if (lpszDisplayName) LocalFree(lpszDisplayName);
		if (lpMailUser)
			lpMailUser->Release();

		if (lpDL)
			lpDL->Release();

		if (lpDL2)
			lpDL2->Release();

		if (lpTable)
			lpTable->Release();

		if (lpABCont)
				lpABCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}


BOOL PAB_IMailUserSetGetProps()
{
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	lpAdrBook       = NULL;
	LPABCONT	lpABCont= NULL, lpABCont2= NULL;
	LPABCONT	lpPABCont= NULL,lpPABCont2= NULL;
	LPABCONT	lpDLCont= NULL;
	ULONG		cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG		cbEid=0;  // entry id of the entry being added
	LPENTRYID	lpEid=NULL;

    char		EntProp[10][BIG_BUF];  //MAX_PROP
	ULONG       cValues = 0, cValues2 = 0, ulObjType=NULL;	
	int i=0,k=0;
	char EntryBuf[MAX_BUF];
	char szDLTag[SML_BUF];
	
    LPMAILUSER  lpMailUser=NULL,lpMailUser2=NULL,lpDistList=NULL,lpDistList2=NULL;
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	SizedSPropTagArray(2, Cols) = { 2, {PR_OBJECT_TYPE, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueMailUser = NULL;
    LPSPropValue lpSPropValueDistList = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;

    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	SizedSPropTagArray(1,SPTArrayDisplayName) = {1, {PR_DISPLAY_NAME} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IMailUserSetGetProps");
	LUIOut(L2,"-> Verifies IMailUser->SetProps and GetProps are functional by performing the following:");
	LUIOut(L2, "   Attempts to Set/GetProps on a MailUser PR_DISPLAY_NAME using address1 from the");
	LUIOut(L2, "   ini file and checks...");
	LUIOut(L2, "   # The return code from both SetProps and GetProps");
	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L2, "   Attempts to Set/GetProps on a DistList PR_DISPLAY_NAME using Name1 from the");
	LUIOut(L2, "   ini file and checks...");
	LUIOut(L2, "   # The return code from both SetProps and GetProps");
	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Try to create a MailUser entry in the container
	//

	LUIOut(L2, "Creating a Mail User in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_MAILUSER property");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //


	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("CreateEntries",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
		
	LUIOut(L2,"MailUser Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpMailUser->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"MailUser->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

	LUIOut(L2, "Calling MailUser->GetProps to verify the properties are what we expect");
	hr = lpMailUser->GetProps(	IN (LPSPropTagArray) &SPTArrayDisplayName,
								IN 0,
								OUT &cValues2,
								OUT (LPSPropValue FAR *)&lpSPropValueMailUser);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueMailUser->ulPropTag, cValues2))) {
		LUIOut(L3,"MailUser->GetProps call FAILED");
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"MailUser->GetProps call PASSED. Now verifying property array...");
	
	for (i=0; i<(int)cValues;i++)	{
		if (lstrcmp(PropValue[i].Value.LPSZ, lpSPropValueMailUser->Value.LPSZ))	{	//FAILED
			LUIOut(L3, "Display names are not egual. [%s != %s]",
				PropValue[i].Value.LPSZ, lpSPropValueMailUser->Value.LPSZ);
			retval = FALSE;
			goto out;
		}
		else LUIOut(L3, "Display names are equal. [%s = %s]",
			PropValue[i].Value.LPSZ, lpSPropValueMailUser->Value.LPSZ);
	}
	LUIOut(L2, "MailUserSet/GetProps PASSED");

#ifdef DISTLIST
	//
	// Try to create a DL entry in the container
	//

	LUIOut(L2, "Creating a Distribution List in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_DL property");
	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_DL
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueDL);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps failed for Default DL template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_DL is an
    // EntryID which one can pass to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpDistList);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
	lstrcpy(szDLTag,"Name1");
	GetPrivateProfileString("CreatePDL",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
		
	LUIOut(L2,"DistList Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpDistList->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"DistList->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

	LUIOut(L2, "Calling DistList->GetProps to verify the properties are what we expect");
	hr = lpDistList->GetProps(	IN (LPSPropTagArray) &SPTArrayDisplayName,
								IN 0,
								OUT &cValues2,
								OUT (LPSPropValue FAR *)&lpSPropValueDistList);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDistList->ulPropTag))) {
		LUIOut(L3,"DistList->GetProps call FAILED");
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"DistList->GetProps call PASSED. Now verifying property array...");
	
	for (i=0; i<(int)cValues;i++)	{
		if (lstrcmp(PropValue[i].Value.LPSZ, lpSPropValueDistList->Value.LPSZ))	{	//FAILED
			LUIOut(L3, "Display names are not egual. [%s != %s]",
				PropValue[i].Value.LPSZ, lpSPropValueDistList->Value.LPSZ);
			retval = FALSE;
			goto out;
		}
		else LUIOut(L3, "Display names are equal. [%s = %s]",
			PropValue[i].Value.LPSZ, lpSPropValueDistList->Value.LPSZ);
	}
	LUIOut(L2, "DistList Set/GetProps PASSED");
#endif DISTLIST


out:
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueMailUser)
			MAPIFreeBuffer(lpSPropValueMailUser);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueMailUser)
			lpWABObject->FreeBuffer(lpSPropValueMailUser);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		if (lpMailUser)
			lpMailUser->Release();

		if (lpMailUser2)
			lpMailUser2->Release();

		if (lpDistList)
			lpDistList->Release();

		if (lpDistList2)
			lpDistList2->Release();

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpABCont)
				lpABCont->Release();

		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}

BOOL PAB_IMailUserSaveChanges()
{
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpABCont= NULL, lpABCont2= NULL;
	LPABCONT	  lpPABCont= NULL,lpPABCont2= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

	ULONG       cValues = 0, cValues2 = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int i=0,k=0;
	
    LPMAILUSER  lpMailUser=NULL,lpMailUser2=NULL,lpDistList=NULL,lpDistList2=NULL;
	SPropValue*	lpPropValue = NULL;
	SizedSPropTagArray(2, Cols) = { 2, {PR_OBJECT_TYPE, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueMailUser = NULL;
    LPSPropValue lpSPropValueDistList = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;

    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	SizedSPropTagArray(1,SPTArrayDisplayName) = {1, {PR_DISPLAY_NAME} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IMailUserSaveChanges");
	LUIOut(L2,"-> Verifies IMailUser->SaveChanges is functional by performing the following:");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a MailUser PR_DISPLAY_NAME using address1 from the");
	LUIOut(L2, "   ini file and checks...");
	LUIOut(L2, "   # The return code from SaveChanges");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a DistList PR_DISPLAY_NAME using address1 from the");
	LUIOut(L2, "   ini file and checks...");
	LUIOut(L2, "   # The return code from SaveChanges");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Try to create a MailUser entry in the container
	//

	LUIOut(L2, "Creating a Mail User in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_MAILUSER property");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

#ifdef TESTPASS
	while (1) {
#endif
	
	CreateProps(IN INIFILENAME, IN "Properties", OUT &lpPropValue, OUT &cValues2, IN AUTONUM_OFF, IN NULL, OUT NULL);

	LUIOut(L4, "Creating a MailUser with %i properties.", cValues2);
	hr = lpMailUser->SetProps(IN  cValues2,
                             IN  lpPropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SetProps call FAILED");
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"MailUser->SetProps call PASSED");

    hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"MailUser->SaveChanges PASSED, entry added to PAB/WAB");

	// Now retrieve all the props and compare to what we expect
	
	hr = lpMailUser->GetProps(   IN  (LPSPropTagArray) NULL,	//Want all props
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueEntryID);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for MailUser");
	 		retval=FALSE;			
			goto out;
	}
	
	DisplayProp(lpSPropValueEntryID, PR_GIVEN_NAME, cValues);
	DisplayProp(lpSPropValueEntryID, PR_SURNAME, cValues);

	if (!CompareProps(lpPropValue, cValues2, lpSPropValueEntryID, cValues)) {
		retval=FALSE;
		goto out;
	}
	else LUIOut(L4, "Compared expected and found props. No differences detected.");

	// Free the memory associated with this ptr so the ptr can be reused below
	if (lpSPropValueEntryID)
		lpWABObject->FreeBuffer(lpSPropValueEntryID);

	
	if (lpPropValue) {
		for (unsigned int Prop = 0; Prop < cValues2; Prop++) {
			if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_STRING8)	{
				if (lpPropValue[Prop].Value.LPSZ) {
					LocalFree(lpPropValue[Prop].Value.LPSZ);
					lpPropValue[Prop].Value.LPSZ = NULL;
				}
			}
			if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_BINARY) {
				if (lpPropValue[Prop].Value.bin.lpb) {
					LocalFree(lpPropValue[Prop].Value.bin.lpb);
					lpPropValue[Prop].Value.bin.lpb = NULL;
				}
			}
		}
		LocalFree(lpPropValue);
		lpPropValue=NULL;
	}
		
#ifdef TESTPASS
	}
#endif
	// Now delete the entry from the wab
	
	hr = lpMailUser->GetProps(   IN  (LPSPropTagArray) &SPTArrayEntryID,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueEntryID);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for MailUser");
	 		retval=FALSE;			
			goto out;
	}
	

	hr = HrCreateEntryListFromID(lpWABObject,
		IN  lpSPropValueEntryID->Value.bin.cb,
		IN  (ENTRYID*)lpSPropValueEntryID->Value.bin.lpb,
		OUT &lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}

	FreeEntryList(lpWABObject, &lpEntryList);


out:
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		if (lpPropValue) {
			for (unsigned int Prop = 0; Prop < cValues2; Prop++) {
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_STRING8)	{
					if (lpPropValue[Prop].Value.LPSZ) {
						LocalFree(lpPropValue[Prop].Value.LPSZ);
						lpPropValue[Prop].Value.LPSZ = NULL;
					}
				}
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_BINARY) {
					if (lpPropValue[Prop].Value.bin.lpb) {
						LocalFree(lpPropValue[Prop].Value.bin.lpb);
						lpPropValue[Prop].Value.bin.lpb = NULL;
					}
				}
			}
			LocalFree(lpPropValue);
			lpPropValue=NULL;
		}
		
		if (lpMailUser)
			lpMailUser->Release();

		if (lpMailUser2)
			lpMailUser2->Release();

		if (lpDistList)
			lpDistList->Release();

		if (lpDistList2)
			lpDistList2->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpABCont)
				lpABCont->Release();

		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}

BOOL PAB_IABContainerResolveNames()
{
	//DWORD	nCells, counter;
	
	BOOL	Found = FALSE;
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;
	int NumEntries, NumProps;

	unsigned int i = 0, idx = 0, cMaxProps =0, cEntries = 0;

    char lpszInput[] = "Resolve THIS buddy!01234567891123456789212345678931234567894123456789512345678961234567897123456789812345678991234567890123456789112345678921234567893123456789412345678951234567896123456789712345678981234567899123456789012345678911234567892123456789312345678941234567895123456789612345678971234567898123456789", lpszInput2[] = "Resolve THIS DL buddy!";
    LPADRLIST lpAdrList = NULL;
    ULONG rgFlagList[2];
    LPFlagList lpFlagList = (LPFlagList)rgFlagList;


    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpABCont= NULL, lpABCont2= NULL;
	LPABCONT	  lpPABCont= NULL,lpPABCont2= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

    char   EntProp[10][BIG_BUF];  //MAX_PROP
	ULONG       cValues = 0, cValues2 = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int k=0;
	
    LPMAILUSER  lpMailUser=NULL,lpMailUser2=NULL,lpDistList=NULL,lpDistList2=NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	SizedSPropTagArray(2, SPTArrayCols) = { 2, {PR_DISPLAY_NAME, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueMailUser = NULL;
    LPSPropValue lpSPropValueDistList = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;

    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	SizedSPropTagArray(1,SPTArrayDisplayName) = {1, {PR_DISPLAY_NAME} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IABContainerResolveNames");
	LUIOut(L2,"-> Verifies IABContainer->ResolveNames is functional by performing the following:");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a MailUser PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a DistList PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Try to create a MailUser entry in the container
	//

	LUIOut(L2, "Creating a Mail User in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_MAILUSER property");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
/*	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("CreateEntries",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
*/
	lstrcpy((LPTSTR)EntProp[0], lpszInput);		
	LUIOut(L2,"MailUser Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpMailUser->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"MailUser->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

    hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"MailUser->SaveChanges PASSED, entry added to PAB/WAB");

	//
	// Do a ResolveNames on the string
	//
	
	LUIOut(L2, "Retrieving the entry and verifying against what we tried to save.");

	NumEntries = 1, NumProps = 1;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszInput;

	lpFlagList->cFlags = 1;
	lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

	hr = lpABCont->ResolveNames(
		(LPSPropTagArray)&SPTArrayCols,    // tag set for disp_name and eid
		0,               // ulFlags
		lpAdrList,
		lpFlagList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->ResolveNames call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	else LUIOut(L3,"ABContainer->ResolveNames call PASSED");

	VerifyResolvedAdrList(lpAdrList, lpszInput);
		// Now delete the entry from the wab
	
	hr = lpMailUser->GetProps(   IN  (LPSPropTagArray) &SPTArrayEntryID,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueEntryID);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for MailUser");
	 		retval=FALSE;			
			goto out;
	}
	
	
	hr = HrCreateEntryListFromID(lpWABObject,
		IN  lpSPropValueEntryID->Value.bin.cb,
		IN  (ENTRYID*)lpSPropValueEntryID->Value.bin.lpb,
		OUT &lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}

	FreeEntryList(lpWABObject, &lpEntryList);

	FreeAdrList(lpWABObject, &lpAdrList);	// Free lpAdrList and properties

	

#ifdef DISTLIST
	//
	// Try to create a DL entry in the container
	//

	LUIOut(L2, "Creating a Distribution List in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_DL property");
	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_DL
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueDL);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps failed for Default DL template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_DL is an
    // EntryID which one can pass to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpDistList);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
/*	lstrcpy(szDLTag,"Name1");
	GetPrivateProfileString("CreatePDL",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
		
*/	
	lstrcpy((LPTSTR)EntProp[0], lpszInput2);		
	LUIOut(L2,"DistList Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpDistList->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"DistList->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

    hr = lpDistList->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"DistList->SaveChanges PASSED, entry added to PAB/WAB");
	
	//
	// Do a ResolveNames on the string
	//
	
	LUIOut(L2, "Retrieving the entry and verifying against what we tried to save.");

	// use WAB Allocators here
#ifdef PAB
    if (! (sc = MAPIAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), (void **)&lpAdrList))) {
#endif //PAB
#ifdef WAB
    if (! (sc = lpWABObject->AllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), (void **)&lpAdrList))) {
#endif //WAB
		lpAdrList->cEntries = 1;
        lpAdrList->aEntries[0].ulReserved1 = 0;
        lpAdrList->aEntries[0].cValues = 1;

#ifdef PAB
        if (! (sc = MAPIAllocateMore(sizeof(SPropValue), lpAdrList,
               (void **)&lpAdrList->aEntries[0].rgPropVals))) {
#endif //WAB
#ifdef WAB
        if (! (sc = lpWABObject->AllocateMore(sizeof(SPropValue), lpAdrList,
               (void **)&lpAdrList->aEntries[0].rgPropVals))) {
#endif //WAB

			lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
            lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszInput2;
			
			lpFlagList->cFlags = 1;
            lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

            hr = lpABCont->ResolveNames(
				(LPSPropTagArray)&SPTArrayCols,    // tag set for disp_name and eid
                0,               // ulFlags
                lpAdrList,
                lpFlagList);
		    if (HR_FAILED(hr)) {
				LUIOut(L3,"ABContainer->ResolveNames call FAILED, returned 0x%x", hr);
				retval=FALSE;
				goto out;
			}
			else LUIOut(L3,"ABContainer->ResolveNames call PASSED");

			Found = FALSE;
			// Search through returned AdrList for our entry
			for(i=0; ((i<(int) lpAdrList->cEntries) && (!Found)); ++i)	{
				cMaxProps = (int)lpAdrList->aEntries[i].cValues;
				//Check to see if Display Name exists
				idx=0;
				while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_NAME )	
						&& retval)	{
					idx++;
					if(idx == cMaxProps) {
						LUIOut(L4, "PR_DISPLAY_NAME was not found in the lpAdrList");
						retval = FALSE;
					}
				}
				LUIOut(L4,"Display Name: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
				if (!lstrcmp(lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ,lpszInput2))	{
					LUIOut(L3, "Found the entry we just added");
					Found = TRUE;
				}
				//Check to see if EntryID exists
				LUIOut(L3, "Verifying a PR_ENTRYID entry exists in the PropertyTagArray");
				idx=0;
				while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ENTRYID )	
						&& retval)	{
					idx++;
					if(idx == cMaxProps)	{
						LUIOut(L4, "PR_ENTRYID was not found in the lpAdrList");
						retval =  FALSE;
					}
				}
				if (!Found) LUIOut(L3, "Did not find the entry. Test FAILED");
				if (idx < cMaxProps) LUIOut(L3, "EntryID found");
				if (!(retval && Found)) retval = FALSE;
				else	{
					// Store EID for call to OpenEntry
				}
			}
		}			

#ifdef PAB
        MAPIFreeBuffer(lpAdrList);
#endif //PAB
#ifdef WAB
        lpWABObject->FreeBuffer(lpAdrList);
#endif //WAB
	}
#endif //DISTLIST


out:
	// Free lpAdrList and properties
FreeAdrList(lpWABObject, &lpAdrList);
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		if (lpMailUser)
			lpMailUser->Release();

		if (lpMailUser2)
			lpMailUser2->Release();

		if (lpDistList)
			lpDistList->Release();

		if (lpDistList2)
			lpDistList2->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpABCont)
				lpABCont->Release();

		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}

BOOL PAB_IABContainerOpenEntry()
{
	//DWORD	nCells, counter;
	
	BOOL	Found = FALSE;
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE, NumEntries, NumProps;
	unsigned int i = 0, idx = 0, cMaxProps =0, cEntries = 0, PropIndex;

    char lpszInput[] = "Resolve THIS buddy!", lpszInput2[] = "Resolve THIS DL buddy!";
    LPADRLIST lpAdrList = NULL;
    FlagList rgFlagList;
    LPFlagList lpFlagList = (LPFlagList)&rgFlagList;


    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpABCont= NULL, lpABCont2= NULL;
	LPABCONT	  lpPABCont= NULL,lpPABCont2= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

    char   EntProp[10][BIG_BUF];  //MAX_PROP
	ULONG       cValues = 0, cValues2 = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	ULONG	cbLookupEID;
	LPENTRYID	lpLookupEID;
	int k=0;
	
    LPMAILUSER  lpMailUser=NULL,lpMailUser2=NULL,lpDistList=NULL,lpDistList2=NULL;
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	SizedSPropTagArray(2, SPTArrayCols) = { 2, {PR_DISPLAY_NAME, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueMailUser = NULL;
    LPSPropValue lpSPropValueDistList = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;

    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	SizedSPropTagArray(1,SPTArrayDisplayName) = {1, {PR_DISPLAY_NAME} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IABContainerOpenEntry");
	LUIOut(L2,"-> Verifies IABContainer->ResolveNames is functional by performing the following:");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a MailUser PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a DistList PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}


	//
	// Try to create a MailUser entry in the container
	//

	LUIOut(L2, "Creating a Mail User in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_MAILUSER property");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
/*	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("CreateEntries",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
*/
	lstrcpy((LPTSTR)&(EntProp[0]), lpszInput);		
	LUIOut(L2,"MailUser Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpMailUser->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"MailUser->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

    hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"MailUser->SaveChanges PASSED, entry added to PAB/WAB");

	//
	// Do a ResolveNames on the string
	//
	
	LUIOut(L2, "Retrieving the entry and verifying against what we tried to save.");

	NumEntries = 1, NumProps = 1;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszInput;

	lpFlagList->cFlags = 1;
	lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

	hr = lpABCont->ResolveNames(
		(LPSPropTagArray)&SPTArrayCols,    // tag set for disp_name and eid
		0,               // ulFlags
		lpAdrList,
		lpFlagList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->ResolveNames call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	else LUIOut(L3,"ABContainer->ResolveNames call PASSED");

	switch((ULONG)*lpFlagList->ulFlag) {
	case MAPI_AMBIGUOUS:	{
			LUIOut(L4, "ResolveNames returned the MAPI_AMBIGUOUS flag. Test FAILED");
			retval = FALSE;
			break;
	}
	case MAPI_RESOLVED:	{
			LUIOut(L4, "ResolveNames returned the MAPI_RESOLVED flag. Test PASSED");
			break;
	}
	case MAPI_UNRESOLVED:	{
			LUIOut(L4, "ResolveNames returned the MAPI_UNRESOLVED flag. Test FAILED");
			retval = FALSE;
			break;
	}
	default:	{
		LUIOut(L4, "Undefined flag value [%i] returned. Test FAILED", (ULONG)lpFlagList->ulFlag);
		retval = FALSE;
	}
	}

	// Search through returned AdrList for our entry
	VerifyResolvedAdrList(lpAdrList, lpszInput);

	FindProp(&lpAdrList->aEntries[0],
			 PR_ENTRYID,
			 &PropIndex);

	lpLookupEID = (ENTRYID*)lpAdrList->aEntries[0].rgPropVals[PropIndex].Value.bin.lpb;
	cbLookupEID = lpAdrList->aEntries[0].rgPropVals[PropIndex].Value.bin.cb;

    hr = lpABCont->OpenEntry(	IN  cbLookupEID,
								IN  lpLookupEID,
								IN  0,					// Interface
								IN	MAPI_BEST_ACCESS,	// Flags
								OUT	&ulObjType,
								OUT (LPUNKNOWN *) &lpMailUser2
								);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"OpenEntry FAILED");
		retval=FALSE;			
		goto dl;
	}
		// Check to make sure the object type is what we expect

	LUIOut(L3, "Checking to make sure the returned object type is correct");
	if (ulObjType != MAPI_MAILUSER) {
		LUIOut(L2, "Object type is not MAPI_MAILUSER");
		retval = FALSE;
		goto out;
	}
	LUIOut(L3, "Object type is MAPI_MAILUSER");
	
	// Call QueryInterface on the object
	LUIOut(L3, "Calling QueryInterface on the returned object");	
	hr = (lpMailUser2->QueryInterface((REFIID)(IID_IMailUser), (VOID **) &lpABCont2));
	if (HR_FAILED(hr))	{
		LUIOut(L2, "QueryInterface on IID_IMailUser FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "QueryInterface on IID_IMailUser PASSED");

	LUIOut(L3, "Trying to release the object QI returned");
	if(lpABCont2)	{
		if ((LPUNKNOWN)(lpABCont2)->Release() <= 0)
			LUIOut(L3, "QueryInterface returned a valid ptr and released succesfully");
		else	{
			LUIOut(L2, "Release FAILED:returned a > zero ref count");
		}
		lpABCont2 = NULL;

	}
	else {
		LUIOut(L2, "QueryInterface did not return a valid ptr");
		retval = FALSE;
		goto out;
	}

	//
	// Delete the test entry we created in the wab
	//

	hr = HrCreateEntryListFromID(lpWABObject,
		IN  cbLookupEID,
		IN  lpLookupEID,
		OUT &lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}

	FreeEntryList(lpWABObject, &lpEntryList);
	// Free lpAdrList and properties
	FreeAdrList(lpWABObject, &lpAdrList);
	
dl:
#ifdef DISTLIST
	//
	// Try to create a DL entry in the container
	//

	LUIOut(L2, "Creating a Distribution List in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_DL property");
	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_DL
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueDL);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps failed for Default DL template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_DL is an
    // EntryID which one can pass to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpDistList);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
/*	lstrcpy(szDLTag,"Name1");
	GetPrivateProfileString("CreatePDL",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
		
*/	
	lstrcpy((LPTSTR)EntProp[0], lpszInput2);		
	LUIOut(L2,"DistList Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpDistList->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"DistList->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

    hr = lpDistList->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"DistList->SaveChanges PASSED, entry added to PAB/WAB");
	
	//
	// Do a ResolveNames on the string
	//
	
	LUIOut(L2, "Retrieving the entry and verifying against what we tried to save.");

	// use WAB Allocators here
#ifdef PAB
    if (! (sc = MAPIAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), (void **)&lpAdrList))) {
#endif //PAB
#ifdef WAB
    if (! (sc = lpWABObject->AllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), (void **)&lpAdrList))) {
#endif //WAB
		lpAdrList->cEntries = 1;
        lpAdrList->aEntries[0].ulReserved1 = 0;
        lpAdrList->aEntries[0].cValues = 1;

#ifdef PAB
        if (! (sc = MAPIAllocateMore(sizeof(SPropValue), lpAdrList,
               (void **)&lpAdrList->aEntries[0].rgPropVals))) {
#endif //WAB
#ifdef WAB
        if (! (sc = lpWABObject->AllocateMore(sizeof(SPropValue), lpAdrList,
               (void **)&lpAdrList->aEntries[0].rgPropVals))) {
#endif //WAB

			lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
            lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszInput2;
			
			lpFlagList->cFlags = 1;
            lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

            hr = lpABCont->ResolveNames(
				(LPSPropTagArray)&SPTArrayCols,    // tag set for disp_name and eid
                0,               // ulFlags
                lpAdrList,
                lpFlagList);
		    if (HR_FAILED(hr)) {
				LUIOut(L3,"ABContainer->ResolveNames call FAILED, returned 0x%x", hr);
				retval=FALSE;
				goto out;
			}
			else LUIOut(L3,"ABContainer->ResolveNames call PASSED");

			Found = FALSE;
			// Search through returned AdrList for our entry
			for(i=0; ((i<(int) lpAdrList->cEntries) && (!Found)); ++i)	{
				cMaxProps = (int)lpAdrList->aEntries[i].cValues;
				//Check to see if Display Name exists
				idx=0;
				while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_NAME )	
						&& retval)	{
					idx++;
					if(idx == cMaxProps) {
						LUIOut(L4, "PR_DISPLAY_NAME was not found in the lpAdrList");
						retval = FALSE;
					}
				}
				LUIOut(L4,"Display Name: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
				if (!lstrcmp(lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ,lpszInput2))	{
					LUIOut(L3, "Found the entry we just added");
					Found = TRUE;
				}
				//Check to see if EntryID exists
				LUIOut(L3, "Verifying a PR_ENTRYID entry exists in the PropertyTagArray");
				idx=0;
				while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ENTRYID )	
						&& retval)	{
					idx++;
					if(idx == cMaxProps)	{
						LUIOut(L4, "PR_ENTRYID was not found in the lpAdrList");
						retval =  FALSE;
					}
				}
				if (!Found) LUIOut(L3, "Did not find the entry. Test FAILED");
				if (idx < cMaxProps) LUIOut(L3, "EntryID found");
				if (!(retval && Found)) retval = FALSE;
				else	{
					// Store EID for call to OpenEntry
					lpLookupEID = (ENTRYID*)lpAdrList->aEntries[i].rgPropVals[idx].Value.bin.lpb;
					cbLookupEID = lpAdrList->aEntries[i].rgPropVals[idx].Value.bin.cb;
				}
			}
		}			

    hr = lpABCont->OpenEntry(	IN  cbLookupEID,
								IN  lpLookupEID,
								IN  0,					// Interface
								IN	MAPI_BEST_ACCESS,	// Flags
								OUT	&ulObjType,
								OUT (LPUNKNOWN *) &lpDistList2
								);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"OpenEntry FAILED");
		retval=FALSE;
		//goto out;
	}
		// Check to make sure the object type is what we expect

	LUIOut(L3, "Checking to make sure the returned object type is correct");
	if (ulObjType != MAPI_DISTLIST) {
		LUIOut(L2, "Object type is not MAPI_DISTLIST");
		retval = FALSE;
		goto out;
	}
	LUIOut(L3, "Object type is MAPI_DISTLIST");
	
	// Call QueryInterface on the object
	LUIOut(L3, "Calling QueryInterface on the returned object");	
	hr = (lpABCont->QueryInterface((REFIID)(IID_IDistList), (VOID **) &lpABCont2));
	if (HR_FAILED(hr))	{
		LUIOut(L2, "QueryInterface on IID_IDistList FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "QueryInterface on IID_IDistList PASSED");

	LUIOut(L3, "Trying to release the object QI returned");
	if(lpABCont2)	{
		if ((LPUNKNOWN)(lpABCont2)->Release() <= 0)
			LUIOut(L3, "QueryInterface returned a valid ptr and released succesfully");
		else	{
			LUIOut(L2, "Release FAILED:returned a > zero ref count");
		}
		lpABCont2 = NULL;

	}
	else {
		LUIOut(L2, "QueryInterface did not return a valid ptr");
		retval = FALSE;
		goto out;
	}

#ifdef PAB
        MAPIFreeBuffer(lpAdrList);
#endif //PAB
#ifdef WAB
        lpWABObject->FreeBuffer(lpAdrList);
#endif //WAB
	}
#endif //DISTLIST


out:
	// Free lpAdrList and properties
FreeAdrList(lpWABObject, &lpAdrList);
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		if (lpMailUser)
			lpMailUser->Release();

		if (lpMailUser2)
			lpMailUser2->Release();

		if (lpDistList)
			lpDistList->Release();

		if (lpDistList2)
			lpDistList2->Release();

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpABCont)
				lpABCont->Release();

		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}


BOOL PAB_IABAddress()
{
	//DWORD	nCells, counter;
	
	HWND		hwnd = glblhwnd;
	ADRPARM		AdrParms;
	LPADRPARM	lpAdrParms = &AdrParms;
    LPADRLIST lpAdrList = NULL;
	char 	lpszCaptionText[64], lpszDestWellsText[64];
	char lpszDisplayName[MAXSTRING], lpszDisplayName2[MAXSTRING], lpszDisplayName3[MAXSTRING];

	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE, NumEntries, NumProps;
	unsigned int i = 0, idx = 0, cMaxProps =0, cEntries = 0;

    ULONG rgFlagList[2];
    LPFlagList lpFlagList = (LPFlagList)rgFlagList;


    LPADRBOOK	  lpAdrBook       = NULL;
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IABAddress");
	LUIOut(L2,"-> Verifies IABContainer->ResolveNames is functional by performing the following:");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a MailUser PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a DistList PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	
	//
	// MULTISELECT MODE - To well only
	//

	// Fill in the ADRPARM structure
	ZeroMemory(lpAdrParms, sizeof(ADRPARM));

	NumEntries = 3, NumProps = 2;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);

	strcpy(lpszDisplayName, "Abraham Lincoln");
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszDisplayName;
	lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[1].Value.l = MAPI_TO;

	strcpy(lpszDisplayName2, "Carl Sagon");
	lpAdrList->aEntries[1].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[1].rgPropVals[0].Value.LPSZ = lpszDisplayName2;
	lpAdrList->aEntries[1].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[1].rgPropVals[1].Value.l = MAPI_TO;
			
	strcpy(lpszDisplayName3, "Ren & Stimpy");
	lpAdrList->aEntries[2].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[2].rgPropVals[0].Value.LPSZ = lpszDisplayName3;
	lpAdrList->aEntries[2].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[2].rgPropVals[1].Value.l = MAPI_TO;
			

	LUIOut(L2, "Calling IABAddress with multiselect mode and only the To well");

	MessageBox(NULL, "Calling IAB->Address in multi-select mode with To: well only. You should see 3 entries in the To: well.",
		"WAB Test Harness", MB_OK);

	lpAdrParms->ulFlags = (	DIALOG_MODAL );
	strcpy(lpszCaptionText, "WABTEST - MultiSelect mode");
	strcpy(lpszDestWellsText, "WABTEST - Destination well text");
	lpAdrParms->lpszCaption = lpszCaptionText;
	lpAdrParms->lpszDestWellsTitle = lpszDestWellsText;
	lpAdrParms->cDestFields = 1;

	hr = lpAdrBook->Address((ULONG*)&hwnd, lpAdrParms, &lpAdrList);
	if (HR_FAILED(hr))	{
		LUIOut(L2, "IAdrBook->Address call FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "IAdrBook->Address call PASSED");
	if (lpAdrList) DisplayAdrList(lpAdrList, lpAdrList->cEntries);
	else	{
		LUIOut(L3, "IAdrBook->Address returned a NULL lpAdrList. No entries were selected.");
	}

	// Free lpAdrList and properties
	FreeAdrList(lpWABObject, &lpAdrList);

	if (MessageBox(NULL, "Did the multi-select UI display correctly?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "Test operator reports the UI did not display correctly. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
	
	//
	// MULTISELECT MODE - To and CC wells only
	//

	// Fill in the ADRPARM structure
	ZeroMemory(lpAdrParms, sizeof(ADRPARM));

	NumEntries = 3, NumProps = 2;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);

	strcpy(lpszDisplayName, "Abraham Lincoln");
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszDisplayName;
	lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[1].Value.l = MAPI_TO;

	strcpy(lpszDisplayName2, "Carl Sagon");
	lpAdrList->aEntries[1].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[1].rgPropVals[0].Value.LPSZ = lpszDisplayName2;
	lpAdrList->aEntries[1].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[1].rgPropVals[1].Value.l = MAPI_CC;
			
	strcpy(lpszDisplayName3, "Ren & Stimpy");
	lpAdrList->aEntries[2].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[2].rgPropVals[0].Value.LPSZ = lpszDisplayName3;
	lpAdrList->aEntries[2].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[2].rgPropVals[1].Value.l = MAPI_BCC;
			
	LUIOut(L2, "Calling IABAddress with multiselect mode and both To and CC wells");

	MessageBox(NULL, "Calling IAB->Address in multi-select mode with both To: and CC: wells. You should see 1 entry in each of the wells.",
		"WAB Test Harness", MB_OK);

	lpAdrParms->ulFlags = (	DIALOG_MODAL );
	strcpy(lpszCaptionText, "WABTEST - MultiSelect mode");
	strcpy(lpszDestWellsText, "WABTEST - Destination well text");
	lpAdrParms->lpszCaption = lpszCaptionText;
	lpAdrParms->lpszDestWellsTitle = lpszDestWellsText;
	lpAdrParms->cDestFields = 2;

	hr = lpAdrBook->Address((ULONG*)&hwnd, lpAdrParms, &lpAdrList);
	if (HR_FAILED(hr))	{
		LUIOut(L2, "IAdrBook->Address call FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "IAdrBook->Address call PASSED");
	if (lpAdrList) DisplayAdrList(lpAdrList, lpAdrList->cEntries);
	else	{
		LUIOut(L3, "IAdrBook->Address returned a NULL lpAdrList. No entries were selected.");
	}

	// Free lpAdrList and properties
	FreeAdrList(lpWABObject, &lpAdrList);

	if (MessageBox(NULL, "Did the multi-select UI display correctly?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "Test operator reports the UI did not display correctly. Test FAILED");
		retval = FALSE;
		goto out;
	}

	
	//
	// MULTISELECT MODE - To, CC and BCC wells
	//

	// Fill in the ADRPARM structure
	ZeroMemory(lpAdrParms, sizeof(ADRPARM));

	NumEntries = 3, NumProps = 2;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);

	strcpy(lpszDisplayName, "Abraham Lincoln");
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszDisplayName;
	lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[1].Value.l = MAPI_TO;

	strcpy(lpszDisplayName2, "Carl Sagon");
	lpAdrList->aEntries[1].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[1].rgPropVals[0].Value.LPSZ = lpszDisplayName2;
	lpAdrList->aEntries[1].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[1].rgPropVals[1].Value.l = MAPI_CC;
			
	strcpy(lpszDisplayName3, "Ren & Stimpy");
	lpAdrList->aEntries[2].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[2].rgPropVals[0].Value.LPSZ = lpszDisplayName3;
	lpAdrList->aEntries[2].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[2].rgPropVals[1].Value.l = MAPI_BCC;
			
	LUIOut(L2, "Calling IABAddress with multiselect mode and To, CC and BCC wells");

	MessageBox(NULL, "Calling IAB->Address in multi-select mode with To:, CC: and BCC: wells. You should see 1 entry in each well.",
		"WAB Test Harness", MB_OK);

	lpAdrParms->ulFlags = (	DIALOG_MODAL );
	strcpy(lpszCaptionText, "WABTEST - MultiSelect mode");
	strcpy(lpszDestWellsText, "WABTEST - Destination well text");
	lpAdrParms->lpszCaption = lpszCaptionText;
	lpAdrParms->lpszDestWellsTitle = lpszDestWellsText;
	lpAdrParms->cDestFields = 3;

	hr = lpAdrBook->Address((ULONG*)&hwnd, lpAdrParms, &lpAdrList);
	if (HR_FAILED(hr))	{
		LUIOut(L2, "IAdrBook->Address call FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "IAdrBook->Address call PASSED");
	if (lpAdrList) DisplayAdrList(lpAdrList, lpAdrList->cEntries);
	else	{
		LUIOut(L3, "IAdrBook->Address returned a NULL lpAdrList. No entries were selected.");
	}

	// Free lpAdrList and properties
	FreeAdrList(lpWABObject, &lpAdrList);

	if (MessageBox(NULL, "Did the multi-select UI display correctly?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "Test operator reports the UI did not display correctly. Test FAILED");
		retval = FALSE;
		goto out;
	}

	//
	// BROWSE MODE - Modal
	//

	ZeroMemory(lpAdrParms, sizeof(ADRPARM));

	NumEntries = 2, NumProps = 2;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);

	strcpy(lpszDisplayName, "Abraham Lincoln");
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszDisplayName;
	lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[1].Value.l = MAPI_TO;

	strcpy(lpszDisplayName2, "Carl Sagon");
	lpAdrList->aEntries[1].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[1].rgPropVals[0].Value.LPSZ = lpszDisplayName2;
	lpAdrList->aEntries[1].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[1].rgPropVals[1].Value.l = MAPI_CC;
		
	LUIOut(L2, "Calling IABAddress with browse mode (modal)");
	MessageBox(NULL, "Calling IAB->Address in browse mode with the modal flag set.",
		"WAB Test Harness", MB_OK);

	
	lpAdrParms->ulFlags = (	DIALOG_MODAL );
	strcpy(lpszCaptionText, "WABTEST - Browse mode (modal)");
	lpAdrParms->lpszCaption = lpszCaptionText;
	lpAdrParms->cDestFields = 0;

	hr = lpAdrBook->Address((ULONG*)&hwnd, lpAdrParms, &lpAdrList);
	if (HR_FAILED(hr))	{
		LUIOut(L2, "IAdrBook->Address call FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "IAdrBook->Address call PASSED");


	// Free lpAdrList and properties
	FreeAdrList(lpWABObject, &lpAdrList);

	if (MessageBox(NULL, "Did the modal, browse UI display correctly?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "Test operator reports the UI did not display correctly. Test FAILED");
		retval = FALSE;
		goto out;
	}

	//
	// BROWSE MODE - Modeless
	//

	ZeroMemory(lpAdrParms, sizeof(ADRPARM));

	NumEntries = 2, NumProps = 2;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);

	strcpy(lpszDisplayName, "Abraham Lincoln");
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszDisplayName;
	lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[1].Value.l = MAPI_TO;

	strcpy(lpszDisplayName2, "Carl Sagon");
	lpAdrList->aEntries[1].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[1].rgPropVals[0].Value.LPSZ = lpszDisplayName2;
	lpAdrList->aEntries[1].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[1].rgPropVals[1].Value.l = MAPI_CC;
		
	LUIOut(L2, "Calling IABAddress with browse mode (modeless)");
	MessageBox(NULL, "Calling IAB->Address in browse mode with the SDI (modeless) flag set.",
		"WAB Test Harness", MB_OK);

	
	lpAdrParms->ulFlags = (	DIALOG_SDI );
	strcpy(lpszCaptionText, "WABTEST - Browse mode (modeless)");
	lpAdrParms->lpszCaption = lpszCaptionText;
	lpAdrParms->cDestFields = 0;

	hr = lpAdrBook->Address((ULONG*)&hwnd, lpAdrParms, &lpAdrList);
	if (HR_FAILED(hr))	{
		LUIOut(L2, "IAdrBook->Address call FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "IAdrBook->Address call PASSED");

	//Reset the hwnd as the modeless call returns the hwnd of the modeless dialog
	hwnd = glblhwnd;

	// Free lpAdrList and properties
	FreeAdrList(lpWABObject, &lpAdrList);

	if (MessageBox(NULL, "Did the modeless, browse UI display correctly?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "Test operator reports the UI did not display correctly. Test FAILED");
		retval = FALSE;
		goto out;
	}


	//
	// SINGLESELECT MODE
	//
	
	NumEntries = 1, NumProps = 2;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);

	strcpy(lpszDisplayName, "Abraham Lincoln");
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszDisplayName;
	lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[1].Value.l = MAPI_TO;

	LUIOut(L2, "Calling IABAddress with single select mode");
	MessageBox(NULL, "Calling IAB->Address in single select mode.",
		"WAB Test Harness", MB_OK);

	lpAdrParms->ulFlags = (	DIALOG_MODAL | ADDRESS_ONE );
	strcpy(lpszCaptionText, "WABTEST - SingleSelect mode");
	lpAdrParms->lpszCaption = lpszCaptionText;
	lpAdrParms->cDestFields = 0;
	
	hr = lpAdrBook->Address((ULONG*)&hwnd, lpAdrParms, &lpAdrList);
	if (HR_FAILED(hr))	{
		LUIOut(L2, "IAdrBook->Address call FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "IAdrBook->Address call PASSED");
	
	if (lpAdrList) DisplayAdrList(lpAdrList, lpAdrList->cEntries);
	else	{
		LUIOut(L3, "IAdrBook->Address returned a NULL lpAdrList. No entries were selected.");
	}
	

	// Free lpAdrList and properties
	FreeAdrList(lpWABObject, &lpAdrList);

	if (MessageBox(NULL, "Did the single select UI display correctly?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "Test operator reports the UI did not display correctly. Test FAILED");
		retval = FALSE;
		goto out;
	}

out:
	FreeAdrList(lpWABObject, &lpAdrList);
		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}


BOOL ThreadStress(LPVOID lpThreadNum) {
	HRESULT			hr;
	LPENTRYLIST		lpEntryList=NULL;
	LPADRBOOK		lpLocalAdrBook;
	LPVOID			Reserved1 = NULL;
	DWORD			Reserved2 = 0;
	LPWABOBJECT		lpLocalWABObject;
	BOOL			retval = TRUE;
    LPSPropValue	lpSPropValueAddress = NULL, lpSCompareProps = NULL;
	ULONG			cValues = 0, cValues2 = 0, cbEidPAB = 0, ulObjType = 0;
	LPENTRYID		lpEidPAB = NULL;
	LPABCONT		lpABCont= NULL;
	char			szDLTag[SML_BUF], *lpszReturnName = NULL, *lpszDisplayName = NULL, **lpszDisplayNames;
	char			EntryBuf[MAX_BUF];
	unsigned int	NumEntries, Counter1, Counter2, StrLen1, PropIndex;
    LPMAILUSER		lpMailUser = NULL;
	LPMAPITABLE		lpTable = NULL;
	LPSRowSet		lpRows = NULL;
	SRestriction	Restriction;
	SPropValue*		lpPropValue;
	SizedSPropTagArray(1, SPTArrayCols) = { 1, {PR_ENTRYID} };
    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	WAB_PARAM		WP;

	LUIOut(L2, "Thread #%i initializing.", *(int *)lpThreadNum);
	ZeroMemory((void *)&WP, sizeof(WAB_PARAM));
	WP.cbSize=sizeof(WAB_PARAM);

	hr = WABOpen(&lpLocalAdrBook, &lpLocalWABObject, &WP, Reserved2);
	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"WABOpen Failed");
		retval=FALSE;
		goto out;
	}

	//lpWABObject = lpLocalWABObject;	//AllocateAdrList expects a global ptr to the WAB obj

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpLocalAdrBook != NULL);
	hr = OpenPABID(  IN lpLocalAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	if (HR_FAILED(hr)) {
		LUIOut(L2,"OpenPABID Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Try to create a MailUser entry in the container
	//


	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //

	// Retrieve user info from ini file
	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("CreateEntriesStress",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	NumEntries = GetPrivateProfileInt("CreateEntriesStress","NumCopies",0,INIFILENAME);

	//Allocate an array of String pointers to hold the display names
	lpszDisplayNames = (char**)LocalAlloc(LMEM_FIXED, NumEntries * sizeof(LPSTR));
	lpszDisplayName = (char*)LocalAlloc(LMEM_FIXED, MAX_BUF*sizeof(char));
	ParseIniBuffer(IN EntryBuf, IN 1, OUT lpszDisplayName);
	StrLen1 = strlen(lpszDisplayName);
	sprintf(&(lpszDisplayName[StrLen1]), " [Thread #%i] - ", *(int *)lpThreadNum);	

	LUIOut(L2, "Thread #%i adding %i entries", *(int *)lpThreadNum, NumEntries);

	for (Counter1 = 0; Counter1 < NumEntries; Counter1++)	{
		hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
			retval=FALSE;			
			goto out;
		}

		//
		// Then set the properties
		//


		CreateProps(IN INIFILENAME, IN "Properties", OUT &lpPropValue, OUT &cValues, IN Counter1, IN &lpszDisplayName, OUT &lpszReturnName);
		
		//Allocate space for the display name
		lpszDisplayNames[Counter1] = (char*)LocalAlloc(LMEM_FIXED, (strlen(lpszReturnName)+1)*sizeof(char));
		//Copy the DisplayName for use later
		strcpy(lpszDisplayNames[Counter1], lpszReturnName);
		//LUIOut(L2,"MailUser Entry to Add: %s",lpszDisplayName);
			
		hr = lpMailUser->SetProps(IN  cValues,
								 IN  lpPropValue,
								 IN  NULL);
			
		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SetProps call FAILED for %s properties",lpszReturnName);
	 		retval=FALSE;			
			goto out;
		}

		hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SaveChanges FAILED with error code 0x%x",hr);
			retval=FALSE;
			goto out;
		}

		// Now retrieve all the props and compare to what we expect
		
		hr = lpMailUser->GetProps(   IN  (LPSPropTagArray) NULL,	//Want all props
								   IN  0,      //Flags
								   OUT &cValues2,
								   OUT &lpSCompareProps);

		if ((HR_FAILED(hr))||(PropError(lpSCompareProps->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps FAILED for MailUser");
	 			retval=FALSE;			
				goto out;
		}
		
		if (!CompareProps(lpPropValue, cValues, lpSCompareProps, cValues2)) {
			retval=FALSE;
			goto out;
		}
		
		//Free the SPropValue for use in the next loop
		if (lpPropValue) {
			for (unsigned int Prop = 0; Prop < cValues; Prop++) {
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_STRING8)	{
					if (lpPropValue[Prop].Value.LPSZ) {
						LocalFree(lpPropValue[Prop].Value.LPSZ);
						lpPropValue[Prop].Value.LPSZ = NULL;
					}
				}
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_BINARY) {
					if (lpPropValue[Prop].Value.bin.lpb) {
						LocalFree(lpPropValue[Prop].Value.bin.lpb);
						lpPropValue[Prop].Value.bin.lpb = NULL;
					}
				}
			}
			LocalFree(lpPropValue);
			lpPropValue=NULL;
		}
		


		if (lpSCompareProps) {
			lpLocalWABObject->FreeBuffer(lpSCompareProps);
			lpSCompareProps = NULL;
		}
		lpMailUser->Release();
		lpMailUser = NULL;
	}

	//LUIOut(L2, "Thread #%i added %i entries with %i properties", *(int *)lpThreadNum, NumEntries, cValues);
	if (retval) LUIOut(L2, "Thread #%i compared %i props. No differences found", *(int *)lpThreadNum, cValues);

	
	//
	// Verify each entry we added now exists in the WAB and then delete it
	//

	LUIOut(L2, "Thread #%i verifying and deleting %i entries", *(int *)lpThreadNum, NumEntries);

	// Create a contents table to verify each added entry exists in the store
	hr = lpABCont->GetContentsTable(ULONG(0), &lpTable);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->GetContentsTable call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	//else LUIOut(L3,"ABContainer->ResolveNames call PASSED");

	// Allocate the SpropValue ptr in the restriction structure
	lpLocalWABObject->AllocateBuffer(sizeof(SPropValue), (void**)&(Restriction.res.resProperty.lpProp));
	Restriction.res.resProperty.lpProp = (SPropValue*)Restriction.res.resProperty.lpProp;

	//Now walk the FlagList and make sure everything resolved, if it did then delete it now
	for (Counter2 = 0; Counter2 < NumEntries; Counter2++)	{
	
	// Build the restriction structure to pass to lpTable->Restrict
	
		//** For testing the fail case only, stub out for real testing
		// lstrcpy(lpszDisplayNames[Counter2], "This should not match");
		//**
		Restriction.rt = RES_PROPERTY;					//Property restriction
		Restriction.res.resProperty.relop = RELOP_EQ;	//Equals
		Restriction.res.resProperty.ulPropTag = PR_DISPLAY_NAME;
		Restriction.res.resProperty.lpProp->ulPropTag = PR_DISPLAY_NAME;
		Restriction.res.resProperty.lpProp->Value.LPSZ = lpszDisplayNames[Counter2];

		hr = lpTable->Restrict(&Restriction, ULONG(0));
		if (HR_FAILED(hr)) {
			LUIOut(L3,"Table->Restrict call FAILED, returned 0x%x", hr);
			retval=FALSE;
			goto out;
		}

		hr = lpTable->QueryRows(LONG(1),
								ULONG(0),
								&lpRows);
		if (HR_FAILED(hr)) {
			LUIOut(L3,"Table->QueryRows call FAILED: Entry #%i, returned 0x%x", Counter2, hr);
			retval=FALSE;
			goto out;
		}

		if (!lpRows->cRows) {
			LUIOut(L2, "QueryRows did not find entry #%i. Test FAILED", Counter2);
			retval=FALSE;
			goto out;
		}

		//** For testing purposes only, stub out for real testing
		//EnterCriticalSection(&CriticalSection);
		//DisplayRows(lpRows);
		//LeaveCriticalSection(&CriticalSection);
		//**

	
		// Change the EntryID to a LPENTRYLIST
		FindPropinRow(&lpRows->aRow[0],
					 PR_ENTRYID,
					 &PropIndex);
		hr = HrCreateEntryListFromID(lpLocalWABObject,
				IN  lpRows->aRow[0].lpProps[PropIndex].Value.bin.cb,
				IN  (ENTRYID*)lpRows->aRow[0].lpProps[PropIndex].Value.bin.lpb,
				OUT &lpEntryList);
		if (HR_FAILED(hr)) {
				LUIOut(L3,"Could not Create Entry List");
				retval=FALSE;
				goto out;
		}

		// Then pass the lpEntryList to DeleteEntries to delete ...
		hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

		if (HR_FAILED(hr)) {
				LUIOut(L3,"Could not Delete Entry %i. DeleteEntry returned 0x%x", Counter2, hr);
				FreeEntryList(lpLocalWABObject, &lpEntryList);
				retval=FALSE;
				goto out;
		}


		FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from first call to queryrows

		// Verify the entry was deleted by calling QueryRows again
		hr = lpTable->QueryRows(LONG(1),
								ULONG(0),
								&lpRows);
		if (HR_FAILED(hr)) {
			LUIOut(L3,"Table->QueryRows call FAILED: Entry #%i, returned 0x%x", Counter2, hr);
			retval=FALSE;
			goto out;
		}

		if (lpRows->cRows) {	// Should be 0 if deleted
			LUIOut(L2, "Thread #%i: QueryRows found entry #%i even tho it was deleted. Test FAILED", *(int *)lpThreadNum, Counter2);
			retval=FALSE;
			goto out;
		}
		
		//Cleanup
		FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from second call to queryrows
		if (lpEntryList) {
			FreeEntryList(lpLocalWABObject, &lpEntryList);
			lpEntryList = NULL;
		}
		LocalFree((HLOCAL)lpszDisplayNames[Counter2]);
		lpszDisplayNames[Counter2] = NULL;
	}



out:
	if (lpszDisplayName) {
		LocalFree(lpszDisplayName);
		lpszDisplayName = NULL;
	}
	if (lpPropValue) {
		for (unsigned int Prop = 0; Prop < cValues; Prop++) {
			if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_STRING8)	{
				if (lpPropValue[Prop].Value.LPSZ) {
					LocalFree(lpPropValue[Prop].Value.LPSZ);
					lpPropValue[Prop].Value.LPSZ = NULL;
				}
			}
			if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_BINARY) {
				if (lpPropValue[Prop].Value.bin.lpb) {
					LocalFree(lpPropValue[Prop].Value.bin.lpb);
					lpPropValue[Prop].Value.bin.lpb = NULL;
				}
			}
		}
		LocalFree(lpPropValue);
		lpPropValue=NULL;
	}
	
	if (lpEntryList) {
		FreeEntryList(lpLocalWABObject, &lpEntryList);
		lpEntryList = NULL;
	}

	if (Restriction.res.resProperty.lpProp) {
		lpLocalWABObject->FreeBuffer(Restriction.res.resProperty.lpProp);
		Restriction.res.resProperty.lpProp = NULL;
	}

	if (lpszDisplayNames) {
		for (unsigned int FreeCounter = 0; FreeCounter < NumEntries; FreeCounter++) {
			if (lpszDisplayNames[FreeCounter]) LocalFree((HLOCAL)lpszDisplayNames[FreeCounter]);
		}
		LocalFree((HLOCAL)lpszDisplayNames);
	}

	FreeRows(lpLocalWABObject, &lpRows);

#ifdef PAB
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);
#endif
#ifdef WAB
		if (lpEidPAB)
			lpLocalWABObject->FreeBuffer(lpEidPAB);
		if (lpSCompareProps) {
			lpLocalWABObject->FreeBuffer(lpSCompareProps);
			lpSCompareProps = NULL;
		}
		if (lpSPropValueAddress)
			lpLocalWABObject->FreeBuffer(lpSPropValueAddress);
#endif
		if (lpTable)
			lpTable->Release();
		
		if (lpMailUser)
			lpMailUser->Release();

		if (lpABCont)
				lpABCont->Release();

		if (lpLocalAdrBook)
				lpLocalAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpLocalWABObject)
			lpLocalWABObject->Release();
#endif
	return(retval);
}


BOOL ThreadManager()
{
	int		NumReps, NumThreads, Counter1, Counter2, Counter3;
	BOOL	retval = TRUE;
	HANDLE *lpThreads;			//ptr to Array of thread handles
	int	*	lpThreadParams;		//ptr to Array of params passed to threads
	DWORD	ThreadId;			//Don't care about thread IDs so it gets overwritten each time
	DWORD	ThreadRetVal;

	
	// how many reps and threads
	// Retrieve user info from ini file
	InitializeCriticalSection(&CriticalSection);
	NumReps = GetPrivateProfileInt("CreateEntriesStress","NumReps",1,INIFILENAME);
	NumThreads = GetPrivateProfileInt("CreateEntriesStress","NumThreads",3,INIFILENAME);

	LUIOut(L1, "ThreadManager: Preparing to run %i repititions with %i threads each",
			NumReps, NumThreads);

	// allocate lpThreads for NumThreads
	lpThreads = (HANDLE*)LocalAlloc(LMEM_FIXED, NumThreads * sizeof(HANDLE));
	lpThreadParams = (int*)LocalAlloc(LMEM_FIXED, NumThreads * sizeof(int));
	if (lpThreads) {
		for (Counter1 = 0; ((Counter1 < NumReps) || ((NumReps == 0) && (!glblStop))) && retval; Counter1++) {
			for (Counter2 = 0; (Counter2 < NumThreads); Counter2++) {
				lpThreadParams[Counter2] = Counter2;
				lpThreads[Counter2] = CreateThread(
					(LPSECURITY_ATTRIBUTES) NULL,		// pointer to thread security attributes
					(DWORD) 0,							// initial thread stack size, in bytes
					(LPTHREAD_START_ROUTINE) ThreadStress,		// pointer to thread function
					(LPVOID) &(lpThreadParams[Counter2]),		// argument for new thread
					(DWORD) 0,							// creation flags
					(LPDWORD) &ThreadId					// pointer to returned thread identifier
				);
				if (!lpThreads[Counter2]) {
					LUIOut(L1, "<ERROR> ThreadManager: Unable to create one of the helper threads");
					retval = FALSE;
					break;	//We're outta here, just go on to cleanup the threads that launched
				}
			}
			
			//Threads are off and running at this point
			//Wait till they complete, collect retvals and cleanup
			WaitForMultipleObjects(
				(DWORD) (Counter2),					// number of handles in handle array or
													// partial if not all threads made it
				lpThreads,							// address of object-handle array
				TRUE,								// wait flag - TRUE = wait for all threads
				INFINITE						 	// time-out interval in milliseconds
			);
			//Check each thread for errors and then free the handles
			for (Counter3 = 0; Counter3 < Counter2; Counter3++) {
				GetExitCodeThread(
					(HANDLE) lpThreads[Counter3],		// handle to the thread
					(LPDWORD) &ThreadRetVal				// address to receive termination status
				);
				if (!(ThreadRetVal)) retval = FALSE;
				CloseHandle(lpThreads[Counter3]);
			}

		}		
		DeleteCriticalSection(&CriticalSection);
		LocalFree((HLOCAL)lpThreadParams);
		LocalFree((HLOCAL)lpThreads);
	}
	else {
		LUIOut(L1, "<ERROR> ThreadManager: Couldn't allocate the thread handle array.");
		//Tell the app that ThreadManager has finished and pass back the return value in
		//the HIWORD of the wParam - since we know it failed at this point, no need to
		//stuff the HIWORD since it's already zero.
		PostMessage(glblhwnd, WM_COMMAND, (WPARAM)ID_MULTITHREADCOMPLETE, (LPARAM)0);
		return(FALSE);
	}
	
	//Tell the app that ThreadManager has finished and pass back the return value in
	//the HIWORD of the wParam
	PostMessage(glblhwnd, WM_COMMAND,
				(WPARAM)(ID_MULTITHREADCOMPLETE | (retval << 16)), (LPARAM)0);
	return(retval);
}

BOOL PAB_AddMultipleEntries()
{
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpABCont= NULL;
	LPABCONT	  lpPABCont= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

    char   EntProp[10][BIG_BUF];  //MAX_PROP
	ULONG       cValues = 0, cValues2 = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int i=0,k=0;
	char EntryBuf[MAX_BUF];
	char szDLTag[SML_BUF];
	unsigned int	NumEntries, counter, StrLen;
	
    LPMAILUSER  lpMailUser=NULL,lpDistList=NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.

    LPSPropValue lpSPropValueAddress = NULL;
	LPSPropValue lpSPropValueDL = NULL;

    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_AddMultipleEntries");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Try to create a MailUser entry in the container
	//

	LUIOut(L2, "Creating a Mail User in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_MAILUSER property");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //

	// Retrieve user info from ini file
	cValues = 3; //# of props we are setting
	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("CreateEntriesStress",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
	StrLen = (strlen(EntProp[0]));
	_itoa(0,(char*)&EntProp[0][StrLen],10);
	EntProp[0][StrLen+1]= '\0';
	NumEntries = GetPrivateProfileInt("CreateEntriesStress","NumCopies",0,INIFILENAME);

	for (counter = 0; counter < NumEntries; counter++)	{
//		LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
		hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
			retval=FALSE;			
			goto out;
		}

		//
		// Then set the properties
		//

		PropValue[0].ulPropTag  = PR_DISPLAY_NAME;
		PropValue[1].ulPropTag  = PR_ADDRTYPE;
		PropValue[2].ulPropTag  = PR_EMAIL_ADDRESS;


			
		_itoa(counter,(char*)&EntProp[0][StrLen],10);
		LUIOut(L2,"MailUser Entry to Add: %s",EntProp[0]);
			
		for (i=0; i<(int)cValues;i++)
			PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
		hr = lpMailUser->SetProps(IN  cValues,
								 IN  PropValue,
								 IN  NULL);
			
		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 		retval=FALSE;			
			goto out;
		}
//		else 	LUIOut(L3,"MailUser->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

		hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SaveChanges FAILED");
			retval=FALSE;
			goto out;
		}
//		else LUIOut(L3,"MailUser->SaveChanges PASSED, entry added to PAB/WAB");

		if (lpMailUser) {
			lpMailUser->Release();
			lpMailUser = NULL;
		}

	}

#ifdef DISTLIST
	//
	// Try to create a DL entry in the container
	//

	LUIOut(L2, "Creating a Distribution List in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_DL property");
	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_DL
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueDL);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps failed for Default DL template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_DL is an
    // EntryID which one can pass to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpDistList);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
	lstrcpy(szDLTag,"Name1");
	GetPrivateProfileString("CreatePDL",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
		
	LUIOut(L2,"DistList Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpDistList->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"DistList->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

    hr = lpDistList->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"DistList->SaveChanges PASSED, entry added to PAB/WAB");
#endif DISTLIST	


out:
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		if (lpMailUser)
			lpMailUser->Release();

		if (lpDistList)
			lpDistList->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpABCont)
				lpABCont->Release();

		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}


BOOL PAB_IABResolveName()
{
	//DWORD	nCells, counter;
	
	char 	lpTitleText[64];
	BOOL	Found = FALSE;
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;
	unsigned int i = 0, idx = 0, cMaxProps =0, cEntries = 0;
	ENTRYLIST*	lpEntryList;

    char	lpszMatch[MAXSTRING], lpszNoMatch[MAXSTRING], lpszOneOff[MAXSTRING], lpszOneOff2[MAXSTRING];
	char	lpszMatchDisplayName[MAXSTRING], lpszMatchAddrType[MAXSTRING], lpszMatchEmailAddress[MAXSTRING];
    char	lpszOneOff2DisplayName[MAXSTRING], lpszOneOff2EmailAddress[MAXSTRING];
	char	lpszOneOffDisplayName[MAXSTRING], lpszOneOffEmailAddress[MAXSTRING];
	LPADRLIST	lpAdrList = NULL;
    ULONG		rgFlagList[2];
    LPFlagList	lpFlagList = (LPFlagList)rgFlagList;


    LPADRBOOK	lpAdrBook = NULL;
	LPABCONT	lpABCont = NULL;
	LPABCONT	lpDLCont = NULL;
	ULONG		cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	lpEidPAB = NULL, lpDLEntryID= NULL, lpLookupEID=NULL;

	ULONG		cbLookupEID, cValues = 0, cValues2 = 0, ulObjType=NULL;	
	int			k=0, NumEntries, NumProps;
	
    LPMAILUSER  lpMailUser=NULL,lpDistList=NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	SizedSPropTagArray(2, SPTArrayCols) = { 2, {PR_DISPLAY_NAME, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueMailUser = NULL;
    LPSPropValue lpSPropValueDistList = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;

    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	SizedSPropTagArray(1,SPTArrayDisplayName) = {1, {PR_DISPLAY_NAME} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IABResolveName");
	LUIOut(L2,"-> Verifies IAdrBook->ResolveNames is functional by performing the following:");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a MailUser PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # Verifies the resolve UI is displayed when it should be by asking the test operator.");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a DistList PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # Verifies the resolve UI is displayed when it should be by asking the test operator.");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);

	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Try to create a MailUser entry in the container
	//

	LUIOut(L2, "Creating a Mail User in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_MAILUSER property");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

	// Read in the ini file strings to resolve against
	// Only adding 1 entry for the first ResName in the ini file
	// but will attempt to resolve all ResNames in the multientry resolve case
	GetPrivateProfileString("ResolveName","ResName1","no ini found",lpszMatch,MAXSTRING,INIFILENAME);
	GetPrivateProfileString("ResolveName","NonExistentName","no ini found",lpszNoMatch,MAXSTRING,INIFILENAME);
	GetPrivateProfileString("ResolveName","OneOffAddress","no ini found",lpszOneOff,MAXSTRING,INIFILENAME);
	GetPrivateProfileString("ResolveName","OneOffAddress2","no ini found",lpszOneOff2,MAXSTRING,INIFILENAME);
	

	ParseIniBuffer(lpszMatch, 1, lpszMatchDisplayName);
	ParseIniBuffer(lpszMatch, 2, lpszMatchAddrType);
	ParseIniBuffer(lpszMatch, 3, lpszMatchEmailAddress);

	ParseIniBuffer(lpszOneOff2, 1, lpszOneOff2DisplayName);
	ParseIniBuffer(lpszOneOff2, 3, lpszOneOff2EmailAddress);

	ParseIniBuffer(lpszOneOff, 1, lpszOneOffDisplayName);
	ParseIniBuffer(lpszOneOff, 3, lpszOneOffEmailAddress);

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;
    PropValue[1].ulPropTag  = PR_ADDRTYPE;
    PropValue[2].ulPropTag  = PR_EMAIL_ADDRESS;
    PropValue[0].Value.LPSZ = lpszMatchDisplayName;
    PropValue[1].Value.LPSZ = lpszMatchAddrType;
    PropValue[2].Value.LPSZ = lpszMatchEmailAddress;

	/*
	cValues = 3; //# of props we are setting

	GetPropsFromIniBufEntry(lpszMatch,cValues,EntProp);

	//lstrcpy((LPTSTR)EntProp[0], lpszMatch);		
	LUIOut(L2,"MailUser Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	
	*/
	LUIOut(L2,"MailUser Entry to Add: %s",PropValue[0].Value.LPSZ);
	hr = lpMailUser->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"MailUser->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

    hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"MailUser->SaveChanges PASSED, entry added to PAB/WAB");

	//
	// Call ResolveName on the entry we just added which will be an exact match,
	// not display the UI and return a valid EID
	//
	
	// Allocate an AdrList for NumEntries of NumProps
	NumEntries = 1;	// How many AdrEntries
	NumProps = 1;	// How many props for each entry

	if (!AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList)) {
		LUIOut(L2, "Couldn't allocate AdrList. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
	// Fill in the properties we want
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszMatchDisplayName;

	LUIOut(L2, "Calling IAdrBook->ResolveName with an exact match. Expect no UI and success.");
	
	MessageBox(NULL, "Calling IAB->ResolveName on the entry that was just added. Since this will be an exact match, you should not see the resolve dialog box.",
						"WAB Test Harness", MB_OK);
    strcpy(lpTitleText, "IAdrBook->ResolveName Test");
	hr = lpAdrBook->ResolveName((ULONG)glblhwnd,
								MAPI_DIALOG,               // ulFlags
								lpTitleText,
								lpAdrList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		if (hr == MAPI_E_AMBIGUOUS_RECIP)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_AMBIGUOUS_RECIP");
		else if (hr == MAPI_E_NOT_FOUND)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_NOT_FOUND");
		else if (hr == MAPI_E_USER_CANCEL)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_USER_CANCEL");
		else
			LUIOut(L3, "IAdrBook->ResolveName returned UNKNOWN result code");
		retval=FALSE;
		goto out;
	}
	else LUIOut(L3,"IAdrBook->ResolveName call PASSED");

	if (MessageBox(NULL, "Did you see the ResolveName dialog box appear?",
		"WAB Test Harness", MB_YESNO) == IDYES)	{
		LUIOut(L3, "IABResolveName dialog displayed even tho we had an exact match. Test FAILED");
		retval = FALSE;
		goto out;
	}

	// Search through returned AdrList and verify each entry is resolved correctly
	if (!VerifyResolvedAdrList(lpAdrList, NULL)) retval = FALSE;

	// Store EID for multiple entry test case later on which needs a valid EID
	//lpLookupEID = (ENTRYID*)lpAdrList->aEntries[0].rgPropVals[idx].Value.bin.lpb;
	//cbLookupEID = lpAdrList->aEntries[0].rgPropVals[idx].Value.bin.cb;
	lpLookupEID = (ENTRYID*)NULL;
	cbLookupEID = 0;

	// Cleanup
	FreeAdrList(lpWABObject, &lpAdrList);

 	//
	// Call ResolveName on a OneOff Address which should succede with
	// no UI and return a valid EID. One off has a foo@com type DN and no email address
	//

	// Allocate an AdrList for NumEntries of NumProps
	NumEntries = 1;	// How many AdrEntries
	NumProps = 1;	// How many props for each entry

	if (!AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList)) {
		LUIOut(L2, "Couldn't allocate AdrList. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
	// Fill in the properties we want
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszOneOff;

	LUIOut(L2, "Calling IAdrBook->ResolveName with a one-off address (DN = foo@com type and no email addr). Expect no UI and success.");
	MessageBox(NULL, "Calling IAB->ResolveName on a one-off address. Since this will be an exact match, you should not see the resolve dialog box.",
						"WAB Test Harness", MB_OK);
    strcpy(lpTitleText, "IAdrBook->ResolveName Test");
	hr = lpAdrBook->ResolveName((ULONG)glblhwnd,
								MAPI_DIALOG,               // ulFlags
								lpTitleText,
								lpAdrList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		if (hr == MAPI_E_AMBIGUOUS_RECIP)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_AMBIGUOUS_RECIP");
		else if (hr == MAPI_E_NOT_FOUND)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_NOT_FOUND");
		else if (hr == MAPI_E_USER_CANCEL)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_USER_CANCEL");
		else
			LUIOut(L3, "IAdrBook->ResolveName returned UNKNOWN result code");
		retval=FALSE;
		goto out;
	}
	else LUIOut(L3,"IAdrBook->ResolveName call PASSED");

	if (MessageBox(NULL, "Did you see the ResolveName dialog box appear?",
		"WAB Test Harness", MB_YESNO) == IDYES)	{
		LUIOut(L3, "IABResolveName dialog displayed even tho we had an exact match. Test FAILED");
		retval = FALSE;
		goto out;
	}

	if (!VerifyResolvedAdrList(lpAdrList, NULL)) retval = FALSE;
	FreeAdrList(lpWABObject, &lpAdrList);

 	//
	// Call ResolveName on a OneOff Address which should succede with
	// no UI and return a valid EID. One off has a DN of foo and an email address
	// of type foo@com
	//

	// Allocate an AdrList for NumEntries of NumProps
	NumEntries = 1;	// How many AdrEntries
	NumProps = 2;	// How many props for each entry

	if (!AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList)) {
		LUIOut(L2, "Couldn't allocate AdrList. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
	// Fill in the properties we want
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszOneOff2DisplayName;
	lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_EMAIL_ADDRESS;
    lpAdrList->aEntries[0].rgPropVals[1].Value.LPSZ = lpszOneOff2EmailAddress;

	LUIOut(L2, "Calling IAdrBook->ResolveName with a one-off address (DN = foo, email addr = foo@...). Expect no UI and success.");
	MessageBox(NULL, "Calling IAB->ResolveName on a second type of one-off address (DN = foo, EMail = foo@com type). Since this will be an exact match, you should not see the resolve dialog box.",
						"WAB Test Harness", MB_OK);
    strcpy(lpTitleText, "IAdrBook->ResolveName Test");
	hr = lpAdrBook->ResolveName((ULONG)glblhwnd,
								MAPI_DIALOG,               // ulFlags
								lpTitleText,
								lpAdrList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		if (hr == MAPI_E_AMBIGUOUS_RECIP)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_AMBIGUOUS_RECIP");
		else if (hr == MAPI_E_NOT_FOUND)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_NOT_FOUND");
		else if (hr == MAPI_E_USER_CANCEL)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_USER_CANCEL");
		else
			LUIOut(L3, "IAdrBook->ResolveName returned UNKNOWN result code");
		retval=FALSE;
		goto out;
	}
	else LUIOut(L3,"IAdrBook->ResolveName call PASSED");

	if (MessageBox(NULL, "Did you see the ResolveName dialog box appear?",
		"WAB Test Harness", MB_YESNO) == IDYES)	{
		LUIOut(L3, "IABResolveName dialog displayed even tho we had an exact match. Test FAILED");
		retval = FALSE;
		goto out;
	}

	if (!VerifyResolvedAdrList(lpAdrList, NULL)) retval = FALSE;
	FreeAdrList(lpWABObject, &lpAdrList);

	
	//
	// Call ResolveName on an entry we don't expect to match exactly
	// Should bring up the resolve UI. Have the user select an entry and
	// then check for success
	//

	// Allocate an AdrList for NumEntries of NumProps
	NumEntries = 1;	// How many AdrEntries
	NumProps = 1;	// How many props for each entry

	if (!AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList)) {
		LUIOut(L2, "Couldn't allocate AdrList. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
	// Fill in the properties we want
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszNoMatch;

	LUIOut(L2, "Calling IAdrBook->ResolveName with a non-exact match. Expect to see UI and success  (user presses OK).");

	MessageBox(NULL, "Calling IAB->ResolveName on 'No such name' which should not match. This should cause the resolve dialog box to display. Please select any entry from the ListBox and press the OK button",
						"WAB Test Harness", MB_OK);
    strcpy(lpTitleText, "IAdrBook->ResolveName Test");
	hr = lpAdrBook->ResolveName((ULONG)glblhwnd,
								MAPI_DIALOG,               // ulFlags
								lpTitleText,
								lpAdrList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		if (hr == MAPI_E_AMBIGUOUS_RECIP)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_AMBIGUOUS_RECIP");
		else if (hr == MAPI_E_NOT_FOUND)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_NOT_FOUND");
		else if (hr == MAPI_E_USER_CANCEL)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_USER_CANCEL");
		else
			LUIOut(L3, "IAdrBook->ResolveName returned UNKNOWN result code");
		retval=FALSE;
		goto out;
	}
	else LUIOut(L3,"IAdrBook->ResolveName call PASSED");

	if (MessageBox(NULL, "Did you see the ResolveName dialog box appear?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "IABResolveName dialog did not display even tho we did not have an exact match. Test FAILED");
		retval = FALSE;
		goto out;
	}

	if (!VerifyResolvedAdrList(lpAdrList, NULL)) retval = FALSE;
	FreeAdrList(lpWABObject, &lpAdrList);

	//
	// Call ResolveName on an entry we don't expect to match exactly
	// Should bring up the resolve UI. Have the user cancel from the UI
	// then check for MAPI_E_USER_CANCEL
	//

	// Allocate an AdrList for NumEntries of NumProps
	NumEntries = 1;	// How many AdrEntries
	NumProps = 1;	// How many props for each entry

	if (!AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList)) {
		LUIOut(L2, "Couldn't allocate AdrList. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
	// Fill in the properties we want
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszNoMatch;

	LUIOut(L2, "Calling IAdrBook->ResolveName with a non-exact match. Expect to see UI and MAPI_E_USER_CANCEL  (user presses CANCEL).");

	MessageBox(NULL, "Calling IAB->ResolveName on 'No such name' which should not match. This should cause the resolve dialog box to display. When the ListBox is displayed, please press the CANCEL button",
						"WAB Test Harness", MB_OK);
    strcpy(lpTitleText, "IAdrBook->ResolveName Test");
	hr = lpAdrBook->ResolveName(
		(ULONG)glblhwnd,
        MAPI_DIALOG,               // ulFlags
        lpTitleText,
		lpAdrList);
	if (hr == MAPI_E_USER_CANCEL) {
		LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_USER_CANCEL");
		LUIOut(L3,"IAdrBook->ResolveName call PASSED");
	}
	else if (hr == MAPI_E_AMBIGUOUS_RECIP) {
		LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_AMBIGUOUS_RECIP");
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		retval=FALSE;
		goto out;
	}
	else if (hr == MAPI_E_NOT_FOUND) {
		LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_NOT_FOUND");
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		retval=FALSE;
		goto out;
	}
	else {
		LUIOut(L3, "IAdrBook->ResolveName returned UNKNOWN result code");
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		retval=FALSE;
		goto out;
	}

	if (MessageBox(NULL, "Did you see the ResolveName dialog box appear?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "IABResolveName dialog did not display even tho we did not have an exact match. Test FAILED");
		retval = FALSE;
		goto out;
	}

	// Don't want to track the success of verify for this case
	VerifyResolvedAdrList(lpAdrList, NULL);
	FreeAdrList(lpWABObject, &lpAdrList);

	//
	// Call ResolveName on 4 entries as follows:
	//	* Entry with a non-zero EID prop -> already resolved so no UI
	//	* One-off entry with NULL EID -> will resolve but not bring up UI
	//	* non-exact match with NULL EID -> Will resolve and bring up UI
	//	* exact match with NULL EID -> Will resolve but not bring up UI
	//
	// When the UI is presented to the user, they should select a valid
	// entry and press OK. VerifyAdrList is expected to succede.
	//

	// Allocate an AdrList for NumEntries of NumProps
	NumEntries = 2;	// How many AdrEntries
	NumProps = 1;	// How many props for each entry

	if (!AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList)) {
		LUIOut(L2, "Couldn't allocate AdrList. Test FAILED");
		retval = FALSE;
		goto out;
	}

	// [ENTRY #1] - Exact match pre-resolve
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszMatchDisplayName;
	// [ENTRY #2] - One-off pre-resolve
	lpAdrList->aEntries[1].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[1].rgPropVals[0].Value.LPSZ = lpszOneOffDisplayName;
	// Pre-resolve these entries
    strcpy(lpTitleText, "IAdrBook->ResolveName Test");
	hr = lpAdrBook->ResolveName((ULONG)glblhwnd,
								(ULONG)0,               // want no UI this time
								lpTitleText,
								lpAdrList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"PRE-RESOLVE FAILED: IAdrBook->ResolveName call FAILED");
		if (hr == MAPI_E_AMBIGUOUS_RECIP)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_AMBIGUOUS_RECIP");
		else if (hr == MAPI_E_NOT_FOUND)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_NOT_FOUND");
		else if (hr == MAPI_E_USER_CANCEL)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_USER_CANCEL");
		else
			LUIOut(L3, "IAdrBook->ResolveName returned UNKNOWN result code");
		retval=FALSE;
		goto out;
	}
	
	// Allocate the final AdrList for NumEntries of NumProps
	NumEntries = 5;	// How many AdrEntries
	NumProps = 2;	// How many props for each new entry

	if (!GrowAdrList(NumEntries, NumProps, &lpAdrList)) {
		LUIOut(L2, "Couldn't grow AdrList. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
	
	
	// [ENTRY #3] - Non-exact match not resolved
	lpAdrList->aEntries[2].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[2].rgPropVals[0].Value.LPSZ = lpszNoMatch;
	lpAdrList->aEntries[2].rgPropVals[1].ulPropTag = PR_NULL;

	// [ENTRY #4] - Exact match not resolved
	lpAdrList->aEntries[3].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[3].rgPropVals[0].Value.LPSZ = lpszMatchDisplayName;
	lpAdrList->aEntries[3].rgPropVals[1].ulPropTag = PR_NULL;
	// [ENTRY #5] - one-off type 2 (dispname and email addr) not resolved
	// Fill in the properties we want
    //PropValue[0].ulPropTag  = PR_DISPLAY_NAME;
    //PropValue[1].ulPropTag  = PR_ADDRTYPE;
    //PropValue[2].ulPropTag  = PR_EMAIL_ADDRESS;
	lpAdrList->aEntries[4].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[4].rgPropVals[0].Value.LPSZ = lpszOneOff2DisplayName;
	lpAdrList->aEntries[4].rgPropVals[1].ulPropTag = PR_EMAIL_ADDRESS;
    lpAdrList->aEntries[4].rgPropVals[1].Value.LPSZ = lpszOneOff2EmailAddress;
	
	LUIOut(L2, "Calling IAdrBook->ResolveName with 5 Entries. Expect to see UI once and success  (user presses OK).");

	MessageBox(NULL, "Calling IAB->ResolveName with multiple entries. This should cause the resolve dialog box to display only once. Please select any entry from the ListBox and press the OK button",
						"WAB Test Harness", MB_OK);
    strcpy(lpTitleText, "IAdrBook->ResolveName Test");
	hr = lpAdrBook->ResolveName((ULONG)glblhwnd,
								MAPI_DIALOG,               // ulFlags
								lpTitleText,
								lpAdrList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		if (hr == MAPI_E_AMBIGUOUS_RECIP)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_AMBIGUOUS_RECIP");
		else if (hr == MAPI_E_NOT_FOUND)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_NOT_FOUND");
		else if (hr == MAPI_E_USER_CANCEL)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_USER_CANCEL");
		else
			LUIOut(L3, "IAdrBook->ResolveName returned UNKNOWN result code");
		retval=FALSE;
		goto out;
	}
	else LUIOut(L3,"IAdrBook->ResolveName call PASSED");

	if (MessageBox(NULL, "Did you see the ResolveName dialog box appear?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "IABResolveName dialog did not display even tho we did not have an exact match. Test FAILED");
		retval = FALSE;
		goto out;
	}

	if (!VerifyResolvedAdrList(lpAdrList, NULL)) retval = FALSE;

		// Now delete the entry from the wab
	
	hr = lpMailUser->GetProps(   IN  (LPSPropTagArray) &SPTArrayEntryID,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueEntryID);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for MailUser");
	 		retval=FALSE;			
			goto out;
	}
	
	
	hr = HrCreateEntryListFromID(lpWABObject,
		IN  lpSPropValueEntryID->Value.bin.cb,
		IN  (ENTRYID*)lpSPropValueEntryID->Value.bin.lpb,
		OUT &lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}

	FreeEntryList(lpWABObject, &lpEntryList);

	FreeAdrList(lpWABObject, &lpAdrList);

#ifdef DISTLIST
	//
	// Try to create a DL entry in the container
	//

	LUIOut(L2, "Creating a Distribution List in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_DL property");
	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_DL
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueDL);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps failed for Default DL template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_DL is an
    // EntryID which one can pass to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpDistList);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
	lstrcpy((LPTSTR)EntProp[0], lpszInput2);		
	LUIOut(L2,"DistList Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpDistList->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"DistList->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

    hr = lpDistList->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"DistList->SaveChanges PASSED, entry added to PAB/WAB");
	
	//
	// Do a ResolveNames on the string
	//
	
	LUIOut(L2, "Retrieving the entry and verifying against what we tried to save.");

	// use WAB Allocators here
#ifdef PAB
    if (! (sc = MAPIAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), (void **)&lpAdrList))) {
#endif //PAB
#ifdef WAB
    if (! (sc = lpWABObject->AllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), (void **)&lpAdrList))) {
#endif //WAB
		lpAdrList->cEntries = 1;
        lpAdrList->aEntries[0].ulReserved1 = 0;
        lpAdrList->aEntries[0].cValues = 1;

#ifdef PAB
        if (! (sc = MAPIAllocateMore(sizeof(SPropValue), lpAdrList,
               (void **)&lpAdrList->aEntries[0].rgPropVals))) {
#endif //WAB
#ifdef WAB
        if (! (sc = lpWABObject->AllocateMore(sizeof(SPropValue), lpAdrList,
               (void **)&lpAdrList->aEntries[0].rgPropVals))) {
#endif //WAB

			lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
            lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszInput2;
			
			lpFlagList->cFlags = 1;
            lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

            hr = lpABCont->ResolveNames(
				(LPSPropTagArray)&SPTArrayCols,    // tag set for disp_name and eid
                0,               // ulFlags
                lpAdrList,
                lpFlagList);
		    if (HR_FAILED(hr)) {
				LUIOut(L3,"ABContainer->ResolveNames call FAILED, returned 0x%x", hr);
				retval=FALSE;
				goto out;
			}
			else LUIOut(L3,"ABContainer->ResolveNames call PASSED");

			Found = FALSE;
			// Search through returned AdrList for our entry
			for(i=0; ((i<(int) lpAdrList->cEntries) && (!Found)); ++i)	{
				cMaxProps = (int)lpAdrList->aEntries[i].cValues;
				//Check to see if Display Name exists
				idx=0;
				while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_NAME )	
						&& retval)	{
					idx++;
					if(idx == cMaxProps) {
						LUIOut(L4, "PR_DISPLAY_NAME was not found in the lpAdrList");
						retval = FALSE;
					}
				}
				LUIOut(L4,"Display Name: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
				if (!lstrcmp(lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ,lpszInput2))	{
					LUIOut(L3, "Found the entry we just added");
					Found = TRUE;
				}
				//Check to see if EntryID exists
				LUIOut(L3, "Verifying a PR_ENTRYID entry exists in the PropertyTagArray");
				idx=0;
				while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ENTRYID )	
						&& retval)	{
					idx++;
					if(idx == cMaxProps)	{
						LUIOut(L4, "PR_ENTRYID was not found in the lpAdrList");
						retval =  FALSE;
					}
				}
				if (!Found) LUIOut(L3, "Did not find the entry. Test FAILED");
				if (idx < cMaxProps) LUIOut(L3, "EntryID found");
				if (!(retval && Found)) retval = FALSE;
				else	{
					// Store EID for call to OpenEntry
				}
			}
		}			

#ifdef PAB
        MAPIFreeBuffer(lpAdrList);
#endif //PAB
#ifdef WAB
        lpWABObject->FreeBuffer(lpAdrList);
#endif //WAB
	}
#endif //DISTLIST

out:
		FreeAdrList(lpWABObject, &lpAdrList);

#ifdef PAB
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		if (lpMailUser)
			lpMailUser->Release();

		if (lpDistList)
			lpDistList->Release();

		if (lpABCont)
				lpABCont->Release();

		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}


BOOL PAB_IABNewEntry_Details()
{
    LPADRBOOK	lpAdrBook = NULL;
	LPABCONT	lpABCont= NULL;
	ULONG		cbEidPAB = 0, cbEid = 0;
	LPENTRYID	lpEidPAB   = NULL, lpEid = NULL;
	ULONG		ulObjType=NULL;	
    HRESULT		hr = hrSuccess;
	int			retval=TRUE;
	ULONG		UIParam = (ULONG)glblhwnd;
	
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IABNewEntry//Details");
	LUIOut(L2,"-> Verifies IAdrBook->NewEntry and Details are functional by performing the following:");
	LUIOut(L2, "   Calls NewEntry and then passes the returned EID to Details");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);

	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Bringing up the NewEntry UI
	//

	LUIOut(L2, "Calling NewEntry");
	assert(lpABCont != NULL);

	MessageBox(NULL, "Calling IAB->NewEntry, which will bring up the property panes for creating a new WAB entry. Fill in as many fields as possible and press the OK button",
						"WAB Test Harness", MB_OK);
	hr = lpAdrBook->NewEntry(
						IN (ULONG)glblhwnd,
						IN 0,		//ulFlags - reserved, must be zero
						IN cbEidPAB,
						IN lpEidPAB,
						IN 0,		//cbEIDNewEntryTpl - not supported by WAB, must be zero
						IN NULL,	//lpEIDNewEntryTpl - not supported by WAB, must be zero
						OUT &cbEid,
						OUT &lpEid);

	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->NewEntry Failed");
		retval=FALSE;
		goto out;
	}

	MessageBox(NULL, "Calling IAB->Details, which will bring up the property panes for the WAB entry you just created. Please verify the values of the fields are as expected and press the OK button",
						"WAB Test Harness", MB_OK);
	hr = lpAdrBook->Details(
						&UIParam,
						IN NULL,	//lpfnDismiss - must be NULL for tier1 WAB
						IN 0,		//lpvDismissContext
						IN cbEid,
						IN lpEid,
						IN NULL,	//lpfButtonCallback - not supported in WAB, must be NULL
						IN NULL,	//lpvButtonContext - not supported in WAB, must be NULL
						IN NULL,	//lpszButtonText - not supported in WAB, must be NULL
						IN 0);		//ulFlags - not supported in WAB, must be zero

	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->Details Failed");
		retval=FALSE;
		goto out;
	}
	
	if (MessageBox(NULL, "Did the new entry get added/displayed properly?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "User ansered No to the pass-test message box. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
out:
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
#endif
		if (lpABCont)
				lpABCont->Release();
		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

	return(retval);
}


BOOL Performance()
{
	
    HRESULT hr;
	int		retval=TRUE;
	DWORD	StartTime, StopTime, Elapsed;
	LPVOID			Reserved1 = NULL;
	DWORD			Reserved2 = 0;

    LPADRBOOK		lpLocalAdrBook;
	LPABCONT		lpABCont= NULL;
	ULONG			cbEidPAB = 0;
	LPENTRYID		lpEidPAB   = NULL;
	LPMAPITABLE		lpTable = NULL;
	LPSRowSet		lpRows = NULL;
	LPWABOBJECT		lpLocalWABObject;
	ENTRYLIST		EntryList,*lpEntryList = &EntryList;

	ULONG   cValues = 0, ulObjType=NULL;	
	int i=0,k=0;
	unsigned int	NumEntries;
	DWORD	PerfData;
	WAB_PARAM		WP;
	
	LUIOut(L1, "WAB Performance Suite");
	NumEntries = 20;
	LUIOut(L1, " ");
	LUIOut(L2, "Running performance data for %u entries.", NumEntries);
	DeleteWABFile();
	CreateMultipleEntries(NumEntries,&PerfData);
	LUIOut(L2, "** Time for SaveChanges (Avg. per entry) = %u milliseconds", PerfData);

	hr = WABOpen(&lpLocalAdrBook, &lpLocalWABObject, &WP, Reserved2);
	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"WABOpen Failed");
		retval=FALSE;
		goto out;
	}

	assert(lpLocalAdrBook != NULL);
	hr = OpenPABID(  IN lpLocalAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"OpenPABID Failed");
		retval=FALSE;
		goto out;
	}
	StartTime = GetTickCount();
	hr = lpABCont->GetContentsTable(ULONG(0), &lpTable);
	StopTime = GetTickCount();
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->GetContentsTable call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to GetContentsTable (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));
	hr = lpTable->QueryRows(LONG(0x7FFFFFFF),
							ULONG(0),
							&lpRows);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"Table->QueryRows call FAILED with errorcode 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	if (!lpRows->cRows) {
		LUIOut(L2, "QueryRows did not find any entries. Test FAILED");
		retval=FALSE;
		goto out;
	}
	else
		LUIOut(L3, "QueryRows returned %u rows.", lpRows->cRows);

	// Change the EntryIDs to a LPENTRYLIST
	hr = HrCreateEntryListFromRows(IN lpLocalWABObject,
								   IN  &lpRows,
								   OUT (ENTRYLIST**)&lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	StartTime = GetTickCount();
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);
	StopTime = GetTickCount();
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to DeleteEntries (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entries. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpLocalWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}
	FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from first call to queryrows
	FreeEntryList(lpLocalWABObject, (ENTRYLIST**)&lpEntryList);
	if (lpTable) {
		lpTable->Release();
		lpTable = NULL;
	}
	lpLocalWABObject->FreeBuffer(lpEidPAB);
	lpEidPAB = NULL;
	lpABCont->Release();
	lpABCont = NULL;
	lpLocalAdrBook->Release();
	lpLocalAdrBook = NULL;
	lpLocalWABObject->Release();
	lpLocalWABObject = NULL;

	NumEntries = 100;
	LUIOut(L1, " ");
	LUIOut(L2, "Running performance data for %u entries.", NumEntries);
	DeleteWABFile();
	CreateMultipleEntries(NumEntries,&PerfData);
	LUIOut(L2, "** Time for SaveChanges (Avg. per entry) = %u milliseconds", PerfData);

	hr = WABOpen(&lpLocalAdrBook, &lpLocalWABObject, &WP, Reserved2);
	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"WABOpen Failed");
		retval=FALSE;
		goto out;
	}

	assert(lpLocalAdrBook != NULL);
	hr = OpenPABID(  IN lpLocalAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"OpenPABID Failed");
		retval=FALSE;
		goto out;
	}
	StartTime = GetTickCount();
	hr = lpABCont->GetContentsTable(ULONG(0), &lpTable);
	StopTime = GetTickCount();
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->GetContentsTable call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to GetContentsTable (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));
	hr = lpTable->QueryRows(LONG(0x7FFFFFFF),
							ULONG(0),
							&lpRows);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"Table->QueryRows call FAILED with errorcode 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	if (!lpRows->cRows) {
		LUIOut(L2, "QueryRows did not find any entries. Test FAILED");
		retval=FALSE;
		goto out;
	}
	else
		LUIOut(L3, "QueryRows returned %u rows.", lpRows->cRows);

	// Change the EntryIDs to a LPENTRYLIST
	hr = HrCreateEntryListFromRows(IN lpLocalWABObject,
								   IN  &lpRows,
								   OUT (ENTRYLIST**)&lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	StartTime = GetTickCount();
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);
	StopTime = GetTickCount();
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to DeleteEntries (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entries. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpLocalWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}
	FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from first call to queryrows
	FreeEntryList(lpLocalWABObject, (ENTRYLIST**)&lpEntryList);
	if (lpTable) {
		lpTable->Release();
		lpTable = NULL;
	}
	lpLocalWABObject->FreeBuffer(lpEidPAB);
	lpEidPAB = NULL;
	lpABCont->Release();
	lpABCont = NULL;
	lpLocalAdrBook->Release();
	lpLocalAdrBook = NULL;
	lpLocalWABObject->Release();
	lpLocalWABObject = NULL;


	NumEntries = 500;
	LUIOut(L1, " ");
	LUIOut(L2, "Running performance data for %u entries.", NumEntries);
	DeleteWABFile();
	CreateMultipleEntries(NumEntries,&PerfData);
	LUIOut(L2, "** Time for SaveChanges (Avg. per entry) = %u milliseconds", PerfData);

	hr = WABOpen(&lpLocalAdrBook, &lpLocalWABObject, &WP, Reserved2);
	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"WABOpen Failed");
		retval=FALSE;
		goto out;
	}

	assert(lpLocalAdrBook != NULL);
	hr = OpenPABID(  IN lpLocalAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"OpenPABID Failed");
		retval=FALSE;
		goto out;
	}
	StartTime = GetTickCount();
	hr = lpABCont->GetContentsTable(ULONG(0), &lpTable);
	StopTime = GetTickCount();
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->GetContentsTable call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to GetContentsTable (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));
	hr = lpTable->QueryRows(LONG(0x7FFFFFFF),
							ULONG(0),
							&lpRows);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"Table->QueryRows call FAILED with errorcode 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	if (!lpRows->cRows) {
		LUIOut(L2, "QueryRows did not find any entries. Test FAILED");
		retval=FALSE;
		goto out;
	}
	else
		LUIOut(L3, "QueryRows returned %u rows.", lpRows->cRows);

	// Change the EntryIDs to a LPENTRYLIST
	hr = HrCreateEntryListFromRows(IN lpLocalWABObject,
								   IN  &lpRows,
								   OUT (ENTRYLIST**)&lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	StartTime = GetTickCount();
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);
	StopTime = GetTickCount();
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to DeleteEntries (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entries. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpLocalWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}
	FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from first call to queryrows
	FreeEntryList(lpLocalWABObject, (ENTRYLIST**)&lpEntryList);
	if (lpTable) {
		lpTable->Release();
		lpTable = NULL;
	}
	lpLocalWABObject->FreeBuffer(lpEidPAB);
	lpEidPAB = NULL;
	lpABCont->Release();
	lpABCont = NULL;
	lpLocalAdrBook->Release();
	lpLocalAdrBook = NULL;
	lpLocalWABObject->Release();
	lpLocalWABObject = NULL;


	NumEntries = 1000;
	LUIOut(L1, " ");
	LUIOut(L2, "Running performance data for %u entries.", NumEntries);
	DeleteWABFile();
	CreateMultipleEntries(NumEntries,&PerfData);
	LUIOut(L2, "** Time for SaveChanges (Avg. per entry) = %u milliseconds", PerfData);

	hr = WABOpen(&lpLocalAdrBook, &lpLocalWABObject, &WP, Reserved2);
	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"WABOpen Failed");
		retval=FALSE;
		goto out;
	}

	assert(lpLocalAdrBook != NULL);
	hr = OpenPABID(  IN lpLocalAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"OpenPABID Failed");
		retval=FALSE;
		goto out;
	}
	StartTime = GetTickCount();
	hr = lpABCont->GetContentsTable(ULONG(0), &lpTable);
	StopTime = GetTickCount();
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->GetContentsTable call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to GetContentsTable (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));
	hr = lpTable->QueryRows(LONG(0x7FFFFFFF),
							ULONG(0),
							&lpRows);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"Table->QueryRows call FAILED with errorcode 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	if (!lpRows->cRows) {
		LUIOut(L2, "QueryRows did not find any entries. Test FAILED");
		retval=FALSE;
		goto out;
	}
	else
		LUIOut(L3, "QueryRows returned %u rows.", lpRows->cRows);

	// Change the EntryIDs to a LPENTRYLIST
	hr = HrCreateEntryListFromRows(IN lpLocalWABObject,
								   IN  &lpRows,
								   OUT (ENTRYLIST**)&lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	StartTime = GetTickCount();
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);
	StopTime = GetTickCount();
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to DeleteEntries (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entries. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpLocalWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}
	FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from first call to queryrows
	FreeEntryList(lpLocalWABObject, (ENTRYLIST**)&lpEntryList);
	if (lpTable) {
		lpTable->Release();
		lpTable = NULL;
	}
	lpLocalWABObject->FreeBuffer(lpEidPAB);
	lpEidPAB = NULL;
	lpABCont->Release();
	lpABCont = NULL;
	lpLocalAdrBook->Release();
	lpLocalAdrBook = NULL;
	lpLocalWABObject->Release();
	lpLocalWABObject = NULL;


	NumEntries = 5000;
	LUIOut(L1, " ");
	LUIOut(L2, "Running performance data for %u entries.", NumEntries);
	DeleteWABFile();
	CreateMultipleEntries(NumEntries,&PerfData);
	LUIOut(L2, "** Time for SaveChanges (Avg. per entry) = %u milliseconds", PerfData);

	hr = WABOpen(&lpLocalAdrBook, &lpLocalWABObject, &WP, Reserved2);
	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"WABOpen Failed");
		retval=FALSE;
		goto out;
	}

	assert(lpLocalAdrBook != NULL);
	hr = OpenPABID(  IN lpLocalAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"OpenPABID Failed");
		retval=FALSE;
		goto out;
	}
	StartTime = GetTickCount();
	hr = lpABCont->GetContentsTable(ULONG(0), &lpTable);
	StopTime = GetTickCount();
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->GetContentsTable call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to GetContentsTable (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));
	hr = lpTable->QueryRows(LONG(0x7FFFFFFF),
							ULONG(0),
							&lpRows);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"Table->QueryRows call FAILED with errorcode 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	if (!lpRows->cRows) {
		LUIOut(L2, "QueryRows did not find any entries. Test FAILED");
		retval=FALSE;
		goto out;
	}
	else
		LUIOut(L3, "QueryRows returned %u rows.", lpRows->cRows);

	// Change the EntryIDs to a LPENTRYLIST
	hr = HrCreateEntryListFromRows(IN lpLocalWABObject,
								   IN  &lpRows,
								   OUT (ENTRYLIST**)&lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	StartTime = GetTickCount();
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);
	StopTime = GetTickCount();
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to DeleteEntries (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entries. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpLocalWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}
	FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from first call to queryrows
	FreeEntryList(lpLocalWABObject, (ENTRYLIST**)&lpEntryList);
	if (lpTable) {
		lpTable->Release();
		lpTable = NULL;
	}
	lpLocalWABObject->FreeBuffer(lpEidPAB);
	lpEidPAB = NULL;
	lpABCont->Release();
	lpABCont = NULL;
	lpLocalAdrBook->Release();
	lpLocalAdrBook = NULL;

// Don't want to release the WABObject at this point since we'll need it to free memory below	
//	lpLocalWABObject->Release();
//	lpLocalWABObject = NULL;

	
out:
		FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from first call to queryrows
		FreeEntryList(lpLocalWABObject, (ENTRYLIST**)&lpEntryList);
		if (lpTable) {
			lpTable->Release();
			lpTable = NULL;
		}
#ifdef PAB
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
#endif

#ifdef WAB
		if (lpEidPAB)
			lpLocalWABObject->FreeBuffer(lpEidPAB);
#endif

		if (lpABCont)
				lpABCont->Release();

		if (lpLocalAdrBook)
			  lpLocalAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		
		if (lpLocalWABObject) {
			lpLocalWABObject->Release();
			lpLocalWABObject = NULL;
		}

		if (lpWABObject) {
			lpWABObject->Release();
			lpWABObject = NULL;
		}
#endif

		return retval;
}



BOOL PabCreateEntry()
{
    ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

#ifdef PAB

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

    char   EntProp[10][BIG_BUF];  //MAX_PROP
	ULONG       cValues = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int cEntriesToAdd,i=0,k=0;
	char szEntryTag[SML_BUF],szTagBuf[SML_BUF],EntryBuf[MAX_BUF];
	char szDLTag[SML_BUF];
	
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
    LPMAILUSER  lpAddress   = NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	SizedSPropTagArray(2, Cols) = { 2, {PR_OBJECT_TYPE, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;
    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running CreateEntries");
	LUIOut(L2,"-> Creates specified entries in PAB");
	LUIOut(L2, "   And also copies them into a Distribution List");
	LUIOut(L1," ");
	if (!(MapiInitLogon(OUT &lpMAPISession))) {
			LUIOut(L2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}
		 		 		
	// Create an Entry of type "Other Address" in PAB
	// OpenPAB

	 hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType);
						
	 if (HR_FAILED(hr)) {
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	 }

	// Create a PDL to fill

	 	hr = lpPABCont->GetProps(  IN  (LPSPropTagArray) &SPTArrayDL,
                                IN  0,      //Flags
                                OUT &cValues,
                                OUT &lpSPropValueDL);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps failed for Default DL template");
		 		retval=FALSE;			
				goto out;
		}

        // The returned value of PR_DEF_CREATE_DL is an
        // EntryID which one can pass to CreateEntry
        //
        hr = lpPABCont->CreateEntry(
                    IN  lpSPropValueDL->Value.bin.cb,               //Template cbEid
                    IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,  //Template lpEid
                    IN  0,
                    OUT (LPMAPIPROP *) &lpAddress);

        if (HR_FAILED(hr)) {
				LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
		 		retval=FALSE;			
			    goto out;
		}

        //
        // Then set the properties
        //

        PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

		cValues = 1; //# of props we are setting
		
		lstrcpy(szDLTag,"Name1");
		GetPrivateProfileString("CreatePDL",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
		GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
		
		LUIOut(L2,"PDL Entry to Add: %s",EntProp[0]);
		
		for (i=0; i<(int)cValues;i++)
			PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	    hr = lpAddress->SetProps(IN  cValues,
                                IN  PropValue,
                                IN  NULL);
		
        if (HR_FAILED(hr)) {
			LUIOut(L3,"SetProps on failed for %s properties",PropValue[0].Value.LPSZ);
		 	retval=FALSE;			
			goto out;
		}
		//else 	LUIOut(L3,"SetProps Passed for %s properties",PropValue[0].Value.LPSZ);
		
        hr = lpAddress->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

        if (HR_FAILED(hr)) {
			LUIOut(L3,"SaveChanges failed for SetProps");
			retval=FALSE;
            goto out;
		}
		else LUIOut(L3,"PDL Entry Added to PAB");

		if (lpAddress) {
			lpAddress->Release();
			lpAddress = NULL;
		}

//***
		
	//Get the PAB table so we can extract the DL
	hr = lpPABCont->GetContentsTable( IN  0,          //Flags
                                OUT &lpContentsTable);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"GetContentsTable: Failed");
		retval = FALSE;
        goto out;
	}

	// look for the first PDL that you can find

	hr = lpContentsTable->SetColumns(IN  (LPSPropTagArray) &Cols,
                                IN  0);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"SetColumns Failed");
		retval = FALSE;
        goto out;
	}

	do
	{
		hr = lpContentsTable->QueryRows(IN  1,
								IN  0,
							    OUT &lpRowSet);
		if (HR_FAILED(hr)){
			LUIOut(L3,"QueryRows Failed");
			retval = FALSE;
			goto out;
		}
		
		cRows = lpRowSet->cRows;
		for (iEntry = 0; iEntry < cRows; iEntry++)
		{
			//
			//  For each entry, process it.
			//
			//lpSPropValue = lpRowSet->aRow[iEntry].lpProps;
			if ((lpRowSet->aRow[iEntry].lpProps[0].ulPropTag == PR_OBJECT_TYPE) &&
				(lpRowSet->aRow[iEntry].lpProps[0].Value.ul == MAPI_DISTLIST))
            {
                if (lpRowSet->aRow[iEntry].lpProps[1].ulPropTag == PR_ENTRYID)
			    {
					cbDLEntryID = lpRowSet->aRow[iEntry].lpProps[1].Value.bin.cb;
					if ( !MAPIAllocateBuffer(cbDLEntryID, (LPVOID *)&lpDLEntryID)) {						
                  		 CopyMemory(lpDLEntryID, (LPENTRYID)lpRowSet->aRow[iEntry].lpProps[1].Value.bin.lpb, cbDLEntryID);
					}
					else {
						LUIOut(L3,"MAPIAllocateBuffer Failed");
						retval = FALSE;
					}
					break;
                }
		    }
        }

        //
		//  done, clean up
		//
        if(lpRowSet) {
		    FreeProws(lpRowSet);
			lpRowSet = NULL;
		}
		
      }while((0!=cRows)&& (0==(cbDLEntryID)));

	if (cbDLEntryID == 0)
		LUIOut(L3,"PDL does not exist");

	hr = lpPABCont->OpenEntry(
                         IN	 cbDLEntryID,
                         IN	 lpDLEntryID,
                         IN	 NULL,              //default interface
                         IN	 MAPI_BEST_ACCESS,  //flags
                         OUT &ulObjType,
                         OUT (LPUNKNOWN *) &lpDLCont);

	if (HR_FAILED(hr)) {
			LUIOut(L2,"OpenEntry Failed");
			retval=FALSE;
			goto out;
	}

		

//***
	// Get Entry displayname, addresstype and (email)address from INI
	
	
	cEntriesToAdd= GetPrivateProfileInt("CreateEntries","NumEntries",0,INIFILENAME);
	
	for (k= 0; k<cEntriesToAdd; k++) {
		lstrcpy((LPSTR)szEntryTag,"Address");
		lstrcat(szEntryTag,_itoa(k+1,szTagBuf,10));
		// Addresses are comma delimited and enclosed in quotes
		GetPrivateProfileString("CreateEntries",szEntryTag,"",EntryBuf,MAX_BUF,INIFILENAME);
		// parse the buffer for properties: displayname, emailaddress and address type
	
	// if no email address specified
	// then user will enter
	// else enter programatically
	// else part implemented below

	hr = lpPABCont->GetProps(  IN  (LPSPropTagArray) &SPTArrayAddress,
                                IN  0,      //Flags
                                OUT &cValues,
                                OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps failed for Default template");
		 		retval=FALSE;			
				goto out;
		}

        // The returned value of PR_DEF_CREATE_MAILUSER is an
        // EntryID which one can pass to CreateEntry
        //
				
        hr = lpPABCont->CreateEntry(
                    IN  lpSPropValueAddress->Value.bin.cb,               //Template cbEid
                    IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,  //Template lpEid
                    IN  0,
                    OUT (LPMAPIPROP *) &lpAddress);

        if (HR_FAILED(hr)) {
				LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		 		retval=FALSE;			
			    goto out;
		}

        //
        // Then set the properties
        //

        PropValue[0].ulPropTag  = PR_DISPLAY_NAME;
        PropValue[1].ulPropTag  = PR_ADDRTYPE;
        PropValue[2].ulPropTag  = PR_EMAIL_ADDRESS;

		cValues = 3; //# of props we are setting
	
		GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
		
		LUIOut(L2,"Entry to Add: %s",EntProp[0]);
		
		for (i=0; i<(int)cValues;i++)
			PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	    hr = lpAddress->SetProps(IN  cValues,
                                IN  PropValue,
                                IN  NULL);
		
        if (HR_FAILED(hr)) {
			LUIOut(L3,"SetProps failed for %s",PropValue[0].Value.LPSZ);
		 	retval=FALSE;			
			goto out;
		}
		//else 	LUIOut(L3,"SetProps Passed for %s properties",PropValue[0].Value.LPSZ);
		
        hr = lpAddress->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

        if (HR_FAILED(hr)) {
			LUIOut(L3,"SaveChanges failed for SetProps");
			retval=FALSE;
            goto out;
		}
		else LUIOut(L3,"Entry Added to PAB");

		
	/** */
	// Now copy the entry to the default DL

	// Get EntryID

		hr = lpAddress->GetProps(
                    IN (LPSPropTagArray) &SPTArrayEntryID,
                    IN  0,
                    OUT &cValues,
                    OUT &lpSPropValueEntryID);
    if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag))) {
		{
					LUIOut( L2,"GetProps on entry in PAB failed" );
					retval = FALSE;
					goto out;
		}
		
		cbEid = lpSPropValueEntryID->Value.bin.cb;
		if ( !MAPIAllocateBuffer(cbEid, (LPVOID *)&lpEid)) {						
                 CopyMemory(lpEid, (VOID*)(LPENTRYID) lpSPropValueEntryID->Value.bin.lpb, cbEid);
		} else {
						LUIOut(L3,"MAPIAllocateBuffer Failed");
						retval = FALSE;
		}
		

	/** */
	// Now copy the entry to the default DL

	hr = HrCreateEntryListFromID(lpLocalWABObject, lpLocalWABObject,    IN  cbEid,
									IN  lpEid,
									OUT &lpEntryList);
	if (HR_FAILED(hr)) {
				LUIOut(L3,"Could not Create Entry List");
				retval=FALSE;
				goto out;
	}
	
	hr = lpDLCont->CopyEntries(IN lpEntryList,IN NULL, IN NULL, IN NULL);

	if (HR_FAILED(hr)) {
				LUIOut(L3,"Could not Copy Entry %s", EntProp[0]);
				retval=FALSE;
				goto out;
	} else 	LUIOut(L3,"Copied Entry: %s to PDL", EntProp[0]);

		/** */

		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);

		if (lpAddress) {
			lpAddress->Release();
			lpAddress = NULL;
		}
}


	out:
 	
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

		if (lpEid)
			MAPIFreeBuffer(lpEid);

		if (lpAddress)
			lpAddress->Release();

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpDLCont)
				lpDLCont->Release();


		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);

		if (lpAdrBook)
			  lpAdrBook->Release();

		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
		return retval;
}

BOOL PabDeleteEntry()
{
    ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

#ifdef PAB

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
	ULONG		  cbEidPAB = 0;
	LPENTRYID	  lpEidPAB   = NULL;
    char   szDispName[BIG_BUF];

	ULONG       cValues         = 0;
	int cEntriesToDelete,i=0,k=0;
	char szEntryTag[SML_BUF],szTagBuf[SML_BUF];
	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;

    LPMAPITABLE lpContentsTable = NULL;

    LPSRowSet   lpRowSet    = NULL;

    SPropValue   PropValue      = {0};
    LPSPropValue lpSPropValue   = NULL;

	SizedSPropTagArray(2, Cols) = { 2, {PR_DISPLAY_NAME, PR_ENTRYID } };

	LPENTRYLIST	lpEntryList=NULL;
	ULONG     cbEid=0;
	LPENTRYID lpEid=NULL;
	LPVOID *lpEid2=NULL;
	
	LUIOut(L1," ");
	LUIOut(L1,"Running DeleteEntries");
	LUIOut(L2,"-> Deletes specified entries from the PAB");
	LUIOut(L1," ");
		
	if (!(MapiInitLogon(OUT &lpMAPISession))) {
		LUIOut(L2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}
		 		 		
	// OpenPAB

	 hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType);
						
	 if (HR_FAILED(hr)) {
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	 }

	// Get Entry displayname from INI

	cEntriesToDelete = GetPrivateProfileInt("DeleteEntries","NumEntries",0,INIFILENAME);
	
	for (k= 0; k<cEntriesToDelete; k++) {
		lstrcpy((LPSTR)szEntryTag,"Name");
		lstrcat(szEntryTag,_itoa(k+1,szTagBuf,10));
		GetPrivateProfileString("DeleteEntries",szEntryTag,"",szDispName,MAX_BUF,INIFILENAME);
		if (szDispName[0]==0) continue;
		LUIOut(L2,"Entry to Delete: %s",szDispName);
		cbEid=0;

	//
    // Get the Contents Table for the PAB container
    //
    hr = lpPABCont->GetContentsTable( IN  0,          //Flags
                                OUT &lpContentsTable);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"GetContentsTable: Failed");
        goto out;
	}

    //
    // Only interested in 2 columns:
    // PR_DISPLAY_NAME and PR_ENTRYID
    //
    hr = lpContentsTable->SetColumns(IN  (LPSPropTagArray) &Cols,
                                IN  0);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"SetColumns Failed");
		retval = FALSE;
        goto out;
	}

    //
    // Since we don't know how many entries exist in the PAB,
    // we will scan them 1000 at a time till we find the desired
    // contact or reach the end of the table...
    do
	{
		hr = lpContentsTable->QueryRows(IN  1000,
								IN  0,
							    OUT &lpRowSet);
		if (HR_FAILED(hr)){
			LUIOut(L3,"QueryRows Failed");
			retval = FALSE;
			goto out;
		}
			
		cRows = lpRowSet->cRows;
		for (iEntry = 0; iEntry < cRows; iEntry++)
		{
			//
			//  For each entry, process it.
			//
			lpSPropValue = lpRowSet->aRow[iEntry].lpProps;
			if (    (lpSPropValue[0].ulPropTag == PR_DISPLAY_NAME) &&
                    (!lstrcmpi(lpSPropValue[0].Value.LPSZ, szDispName)) )
            {
                if (lpSPropValue[1].ulPropTag == PR_ENTRYID)
			    {
    	    		cbEid = lpSPropValue[1].Value.bin.cb;
					lpEid = (LPENTRYID) lpSPropValue[1].Value.bin.lpb;

					if ( !MAPIAllocateBuffer(cbEid, (LPVOID *)&lpEid2)) {						
                  		 CopyMemory(lpEid2, lpEid, cbEid);
						 lpEid= (LPENTRYID)lpEid2;
					}
					else {
						LUIOut(L3,"MAPIAllocateBuffer Failed");
						retval = FALSE;
					}
	    	    	//lpEid = (LPENTRYID) lpSPropValue[1].Value.bin.lpb;

                  // if ( !MAPIAllocateBuffer(cbEid, (LPVOID*)lppEid))
                  //  {
                   //     CopyMemory(*lppEid, lpEid, *lpcbEid);
                  //  }
                    break;
                }
		    }
        }

        //
		//  done, clean up
		//
        if(lpRowSet) {
		    FreeProws(lpRowSet);
			lpRowSet = NULL;
		}
		
      }while((0!=cRows)&& (0==(cbEid)));

	if (cbEid == 0)
		LUIOut(L3,"Entry does not exist");
	else {

		//
		// Change the EntryID to a LPENTRYLIST
		//
		hr = HrCreateEntryListFromID(lpLocalWABObject,    IN  cbEid,
										IN  lpEid,
										OUT &lpEntryList);
		if (HR_FAILED(hr)) {
				LUIOut(L3,"Could not Create Entry List");
				retval=FALSE;
				goto out;
		}



		//
		// Then pass the lpEntryList to DeleteEntries to delete ...
		//
		hr = lpPABCont->DeleteEntries(IN  lpEntryList,IN  0);

		if (HR_FAILED(hr)) {
				LUIOut(L3,"Could not Delete Entry %s", szDispName);
				retval=FALSE;
				goto out;
		} else 	LUIOut(L3,"Deleted Entry: %s", szDispName);
	}

}
		
	out:
 	
		if (lpSPropValue)
			MAPIFreeBuffer(lpSPropValue);

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpEid)
			MAPIFreeBuffer(lpEid);

		if (lpPABCont)
				lpPABCont->Release();

		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);

		if (lpAdrBook)
			  lpAdrBook->Release();

		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();

#endif
		return retval;
}

BOOL PabEnumerateAll()
{
	HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		i = 0,j = 0,retval=TRUE, bDistList = FALSE;

#ifdef PAB

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL, lpDLCont = NULL;
	ULONG ulEntries=0, ulEntriesDL = 0;
	ULONG     cbEid=0, cbDLEid=0;
	LPENTRYID lpEid=NULL, lpDLEid = NULL;
	ULONG	ulObjType=NULL,cValues=0;
	LPMAILUSER	lpUser=NULL, lpDLUser = NULL;
	ULONG		  cbEidPAB = 0;
	LPENTRYID	  lpEidPAB   = NULL;
    LPMAPITABLE lpContentsTable = NULL, lpDLContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL, lpRowSetDL= NULL;

	LPSPropValue lpSPropValue = NULL, lpSPropValueDL = NULL;
    SizedSPropTagArray(2,SPTTagArray) = {2, {PR_DISPLAY_NAME, PR_EMAIL_ADDRESS} };

    LUIOut(L1," ");
	LUIOut(L1,"Running EnumerateAll");
	LUIOut(L2,"-> Enumerates all the entries in the PAB");
	LUIOut(L1," ");

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
			LUIOut(L2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}
	
	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}
	
	if(! OpenPABID(IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType))
	{
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	}
	assert(lpPABCont != NULL);
	hr = lpPABCont->GetContentsTable( IN  0,          //Flags
                                OUT &lpContentsTable);

    if (HR_FAILED(hr)) {
		LUIOut(L2,"GetContentsTable: Failed");
		retval=FALSE;
		goto out;
	}
	assert(lpRowSet == NULL);	
	assert(lpRowSetDL == NULL);
	assert(lpContentsTable != NULL);
	while(!HR_FAILED(hr = lpContentsTable->QueryRows(IN  1,
								IN  0,
							    OUT &lpRowSet))) {
		assert(lpRowSet != NULL);
		bDistList = FALSE;
			
		if (lpRowSet->cRows) {
			ulEntries++;
			i=0;
			while(lpRowSet->aRow[0].lpProps[i].ulPropTag != PR_ENTRYID )
				if (++i >= (int) lpRowSet->aRow[0].cValues)
				{
					LUIOut( L2, "Didn't find PR_ENTRYID in the row!" );
					retval=FALSE;
					goto out;
				}

			cbEid = lpRowSet->aRow[0].lpProps[i].Value.bin.cb;
			lpEid = (LPENTRYID)lpRowSet->aRow[0].lpProps[i].Value.bin.lpb;
			assert(lpEid != NULL);

			// Is this a DL
			i=0;
			while(lpRowSet->aRow[0].lpProps[i].ulPropTag != PR_OBJECT_TYPE )
				if (++i >= (int) lpRowSet->aRow[0].cValues)
				{
					LUIOut( L2, "Didn't find PR_OBJECT_TYPE in the row!" );
					retval=FALSE;
					goto out;
				}
			if (lpRowSet->aRow[0].lpProps[i].Value.ul == MAPI_DISTLIST)
				bDistList = TRUE;
		//d	lpUser = NULL;
			assert(lpUser == NULL);
			assert(lpPABCont != NULL);
	
			hr = lpPABCont->OpenEntry(
                         IN	 cbEid,
                         IN	 lpEid,
                         IN	 NULL,              //default interface
                         IN	 MAPI_BEST_ACCESS,  //flags
                         OUT &ulObjType,
                         OUT (LPUNKNOWN *) &lpUser);

			if (HR_FAILED(hr)) {
				LUIOut(L2,"OpenEntry Failed");
				retval=FALSE;
				goto out;
			}
			else
			{
				//d assert(lpUser != NULL);
				//LUIOut( L2,"OpenEntry on EntryID for User Passed" );
				
				assert(lpUser != NULL);
				hr = lpUser->GetProps(
                    IN (LPSPropTagArray) &SPTTagArray,
                    IN  0,
                    OUT &cValues,
                    OUT &lpSPropValue);


    if ((HR_FAILED(hr))||(PropError(lpSPropValue->ulPropTag, cValues))) {
				{
					LUIOut( L2,"GetProps on User Object failed" );
				}
				else
				{
					LUIOut(L2,"Entry Name: %s",lpSPropValue->Value.LPSZ);
					if (lpSPropValue) {
						MAPIFreeBuffer(lpSPropValue);
						lpSPropValue = NULL;
					}
					assert(lpSPropValue == NULL);

				}	
				
				/* */
				if (bDistList) {
					//d lpDLCont = NULL;
					assert(lpDLCont == NULL);
					assert(lpPABCont != NULL);
					hr = lpPABCont->OpenEntry(
                         IN	 cbEid,
                         IN	 lpEid,
                         IN	 NULL,              //default interface
                         IN	 MAPI_BEST_ACCESS,  //flags
                         OUT &ulObjType,
                         OUT (LPUNKNOWN *) &lpDLCont);

						if (HR_FAILED(hr)) {
								LUIOut(L2,"OpenEntry Failed");
								retval=FALSE;
								goto out;
						}
						//d set to NULL?
						assert(lpDLContentsTable == NULL);
			
						assert(lpDLCont != NULL);
						hr = lpDLCont->GetContentsTable( IN  0,          //Flags
                                OUT &lpDLContentsTable);

						if (HR_FAILED(hr)) {
							LUIOut(L2,"GetContentsTable: Failed");
							retval=FALSE;
							goto out;
						}
						assert(lpRowSetDL == NULL);
						
						assert(lpDLContentsTable != NULL);
						while(!HR_FAILED(hr = lpDLContentsTable->QueryRows(IN  1,
								IN  0,
							    OUT &lpRowSetDL))) {
						if (lpRowSetDL->cRows) {
							ulEntriesDL++;
							j=0;
							while(lpRowSetDL->aRow[0].lpProps[j].ulPropTag != PR_ENTRYID )
								if (++j >= (int) lpRowSetDL->aRow[0].cValues)
								{
									LUIOut( L2, "Didn't find PR_ENTRYID in the row!" );
									retval=FALSE;
									goto out;
								}
							cbDLEid = lpRowSetDL->aRow[0].lpProps[j].Value.bin.cb;
							lpDLEid = (LPENTRYID)lpRowSetDL->aRow[0].lpProps[j].Value.bin.lpb;
							assert(lpDLEid != NULL);
							//d lpDLUser = NULL;
							//d assert(lpDLUser == NULL);
							assert(lpDLCont != NULL);
						
							hr = lpDLCont->OpenEntry(
									 IN	 cbDLEid,
									 IN	 lpDLEid,
									 IN	 NULL,              //default interface
									 IN	 MAPI_BEST_ACCESS,  //flags
									 OUT &ulObjType,
									 OUT (LPUNKNOWN *) &lpDLUser);

						if (HR_FAILED(hr)) {
							LUIOut(L2,"OpenEntry Failed");
							retval=FALSE;
							goto out;
						}
						else
						{
							assert(lpSPropValueDL == NULL);
							//LUIOut( L2,"OpenEntry on EntryID for User Passed" );
						assert(lpDLUser != NULL);
						
						hr = lpDLUser->GetProps(
								IN (LPSPropTagArray) &SPTTagArray,
								IN  0,
								OUT &cValues,
								OUT &lpSPropValueDL);


					    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
							assert( lpSPropValueDL == NULL);
							LUIOut( L3,"GetProps on User Object failed" );
						}
						else {
							LUIOut(L3,"Entry Name: %s",lpSPropValueDL->Value.LPSZ);
							assert( lpSPropValueDL != NULL);
							if (lpSPropValueDL) {
								MAPIFreeBuffer(lpSPropValueDL);
								lpSPropValueDL = NULL;
							}
							assert( lpSPropValueDL == NULL);
							
						}
						}
						if (lpRowSetDL) {
							FreeProws( lpRowSetDL );
							lpRowSetDL = NULL;
						}
						assert( lpRowSetDL == NULL);
						if(lpDLUser) {
							lpDLUser->Release();	
							lpDLUser = NULL;
						}
			/* */		}
				
					else  // no more rows in table
					{
						//Free Row
						if (lpRowSetDL) {
							FreeProws(lpRowSetDL);
							lpRowSetDL = NULL;
						}
						assert( lpRowSetDL == NULL);
						break;
					}
					if(ulEntriesDL == 50)  // we only handle the first 50 entries otherwise this would take forever
						break;
				assert(lpRowSetDL == NULL);
				//***//
				}		
				if (lpDLCont)
					lpDLCont->Release();
				lpDLCont = NULL;
				
				assert(lpRowSetDL == NULL);
				if (lpDLContentsTable)
					lpDLContentsTable->Release();
				lpDLContentsTable = NULL;
			}
			}
			//Free Row
			if (lpRowSet) {
				FreeProws(lpRowSet);
				lpRowSet = NULL;
			}
			assert( lpRowSet == NULL);
			
			
		}
		else  // no more rows in table
		{
			//Free Row
			if (lpRowSet) {
				FreeProws(lpRowSet);
				lpRowSet = NULL;
			}
			assert( lpRowSet == NULL);
						
			break;
		}

		if(ulEntries == 50)  // we only handle the first 50 entries otherwise this would take forever
			break;
	assert(lpRowSet == NULL);	
	assert(lpRowSetDL == NULL);
	assert(lpContentsTable != NULL);
	
	if(lpUser) {
		lpUser->Release();
		lpUser = NULL;
	}
}//while
	
	assert(lpRowSet == NULL);
	assert(lpRowSetDL == NULL);
	LUIOut(L2,"Total Entries: %d", ulEntries);

	if (HR_FAILED(hr)){
			LUIOut(L2,"QueryRows Failed");
			retval = FALSE;
			goto out;
		}		
	
out:
		
		if (lpSPropValue)
			MAPIFreeBuffer(lpSPropValue);

		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpDLContentsTable)
			lpDLContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpDLCont)
				lpDLCont->Release();

		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);

		if (lpAdrBook)
			  lpAdrBook->Release();

		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
		return retval;
}

BOOL ClearPab(int bMAILUSERS)
{
// Clear PAB of all the entries. If bMailUsers flag is TRUE,
//	then only clear MAILUSERS, else clear everything.


    ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

#ifdef PAB

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
	ULONG		  cbEidPAB = 0;
	LPENTRYID	  lpEidPAB   = NULL;
    //char   szDispName[BIG_BUF];

	ULONG       cValues         = 0;
	//int cEntriesToDelete;
	int i=0,k=0;
	//char szEntryTag[SML_BUF];
	//char szTagBuf[SML_BUF];
	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;

    LPMAPITABLE lpContentsTable = NULL;

    LPSRowSet   lpRowSet    = NULL;

    SPropValue   PropValue      = {0};
    LPSPropValue lpSPropValue   = NULL;

	SizedSPropTagArray(3, Cols) = { 3, {PR_DISPLAY_NAME, PR_ENTRYID, PR_OBJECT_TYPE } };

	LPENTRYLIST	lpEntryList=NULL;
	ULONG     cbEid=0;
	LPENTRYID lpEid=NULL;
	LPVOID *lpEid2=NULL;
	
	LUIOut(L1," ");
	if (bMAILUSERS) {
		LUIOut(L1,"Running DeleteUsersOnly");
		LUIOut(L2,"-> Deletes mail users Only (not distribution lists) from the PAB");
		LUIOut(L1," ");
	}
	else {
		LUIOut(L1,"Running Delete All Entries");
		LUIOut(L2,"-> Clears the PAB");
		LUIOut(L1," ");
	}

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
		LUIOut(L2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}
		 		 		
	// OpenPAB

	 hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType);
						
	 if (HR_FAILED(hr)) {
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	 }
	//
    // Get the Contents Table for the PAB container
    //
    hr = lpPABCont->GetContentsTable( IN  0,          //Flags
                                OUT &lpContentsTable);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"GetContentsTable: Failed");
        goto out;
	}

    //
    // Only interested in 2 columns:
    // PR_DISPLAY_NAME and PR_ENTRYID
    //
    hr = lpContentsTable->SetColumns(IN  (LPSPropTagArray) &Cols,
                                IN  0);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"SetColumns Failed");
		retval = FALSE;
        goto out;
	}

    // Query and delete 1 row at a time
    do
	{
		hr = lpContentsTable->QueryRows(IN  1,
								IN  0,
							    OUT &lpRowSet);
		if (HR_FAILED(hr)){
			LUIOut(L3,"QueryRows Failed");
			retval = FALSE;
			goto out;
		}
			
		cRows = lpRowSet->cRows;
		for (iEntry = 0; iEntry < cRows; iEntry++)
		{
			//
			//  For each entry, process it.
			//
			lpSPropValue = lpRowSet->aRow[iEntry].lpProps;
		    if (lpSPropValue[1].ulPropTag == PR_ENTRYID)
			{
				// don't delete this since it is not a mail user
				//
				if ((!bMAILUSERS) || (bMAILUSERS &&(lpSPropValue[2].ulPropTag == PR_OBJECT_TYPE)
					&& (lpSPropValue[2].Value.ul == MAPI_MAILUSER))) {
				
    	    		cbEid = lpSPropValue[1].Value.bin.cb;
					lpEid = (LPENTRYID) lpSPropValue[1].Value.bin.lpb;
					
					hr = HrCreateEntryListFromID(lpLocalWABObject,    IN  cbEid,
													IN  lpEid,
													OUT &lpEntryList);
					if (HR_FAILED(hr)) {
							LUIOut(L3,"Could not Create Entry List");
							retval=FALSE;
							goto out;
					}
					//
					// Then pass the lpEntryList to DeleteEntries to delete ...
					//
					hr = lpPABCont->DeleteEntries(IN  lpEntryList,IN  0);

					if (HR_FAILED(hr)) {
							LUIOut(L3,"Could not Delete Entry %s", lpSPropValue[0].Value.LPSZ);
							retval=FALSE;
							goto out;
					} else 	LUIOut(L3,"Deleted Entry: %s", lpSPropValue[0].Value.LPSZ);
				}
			}

      }
	  if(lpRowSet) {
		    FreeProws(lpRowSet);
			lpRowSet = NULL;
	  }

		
  }while((0!=cRows) && (0==!(cbEid)));
		
  out:
        if(lpRowSet)
		    FreeProws(lpRowSet);		

		if (lpSPropValue)
			MAPIFreeBuffer(lpSPropValue);

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpEid)
			MAPIFreeBuffer(lpEid);

		if (lpPABCont)
				lpPABCont->Release();

		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);

		if (lpAdrBook)
			  lpAdrBook->Release();

		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
		return retval;
}

BOOL CreateOneOff()
{
    ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

#ifdef PAB

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
//	ULONG		  cbEidPAB = 0;
//	LPENTRYID	  lpEidPAB   = NULL;
	ULONG     cbEid=0, cValues;
	LPENTRYID lpEid=NULL;
	ULONG   ulObjType=NULL;	
	LPMAILUSER	lpUser=NULL;
	char   szDispName[BIG_BUF];
	char   szAddressType[BIG_BUF];
	char   szEmailAddress[BIG_BUF];

	LPSPropValue lpSPropValue = NULL;
	SizedSPropTagArray(5,SPTTagArray) = {5, {PR_DISPLAY_NAME,
		PR_ADDRTYPE, PR_EMAIL_ADDRESS,
		PR_OBJECT_TYPE,PR_ENTRYID} };

	LUIOut(L1," ");
	LUIOut(L1,"Running CreateOneOff");
		LUIOut(L2,"-> Creates a one off entry as specified, in the PAB");
		LUIOut(L3,"And then verifies the properties of the entry created");
		LUIOut(L1," ");

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
		LUIOut(L2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}
	// Get the details of the Entry to Create from INI file
	GetPrivateProfileString("CreateOneOff","Name","",szDispName,BIG_BUF,INIFILENAME);
	GetPrivateProfileString("CreateOneOff","AddressType","",szAddressType,BIG_BUF,INIFILENAME);
	GetPrivateProfileString("CreateOneOff","EmailAddress","",szEmailAddress,BIG_BUF,INIFILENAME);
	
	hr = lpAdrBook->CreateOneOff(szDispName,szAddressType,szEmailAddress,NULL,&cbEid,&lpEid);

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"CreateOneOff Failed");
			 retval=FALSE;
			 goto out;
	}
	//Verification
		hr = lpAdrBook->OpenEntry(IN cbEid, IN lpEid, IN NULL, MAPI_BEST_ACCESS,
			OUT & ulObjType,(LPUNKNOWN *) &lpUser);
	
		if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenEntry Failed");
			 retval=FALSE;
			 goto out;
		} else LUIOut(L2,"OpenEntry Succeeded");
		
		hr = lpUser->GetProps(
                    IN (LPSPropTagArray) &SPTTagArray,
                    IN  0,
                    OUT &cValues,
                    OUT &lpSPropValue);

	    if ((HR_FAILED(hr))||(PropError(lpSPropValue->ulPropTag, cValues))) {

					LUIOut( L2,"GetProps on User Object failed" );
		else {
			LUIOut(L2,"Entry Name: %s",(lpSPropValue[0]).Value.LPSZ);
			if (lstrcmpi((lpSPropValue[0]).Value.LPSZ, (LPSTR)szDispName))
				retval = FALSE;
			LUIOut(L2,"AddressType: %s",(lpSPropValue[1]).Value.LPSZ);
			if (lstrcmpi((lpSPropValue[1]).Value.LPSZ, (LPSTR)szAddressType))
				retval = FALSE;
			LUIOut(L2,"EmailAddress: %s",(lpSPropValue[2]).Value.LPSZ);
			if (lstrcmpi((lpSPropValue[2]).Value.LPSZ, (LPSTR)szEmailAddress))
				retval = FALSE;
			LUIOut(L2,"ObjectType: %0x",(lpSPropValue[3]).Value.ul);
			if ((lpSPropValue[3]).Value.ul  != MAPI_MAILUSER)
				retval = FALSE;
		}	
				
out:
		
		if (lpSPropValue)
			MAPIFreeBuffer(lpSPropValue);

		if (lpEid)
			MAPIFreeBuffer(lpEid);
	
		if (lpAdrBook)
			  lpAdrBook->Release();

		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
		return retval;
}

BOOL PABResolveName()
{
	HRESULT hr      = hrSuccess;
    int		retval=TRUE;
#ifdef PAB

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	ULONG cEntries=0;
	LPADRLIST lpAdrList = NULL, lpAdrListNew = NULL;
	int temp1=0, temp2 =0, temp3=0, temp4=0;
	char szResName[10][BIG_BUF];
	int i = 0;

	
	LUIOut(L1," ");
	LUIOut(L1,"Running ResolveName");
		LUIOut(L2,"-> Does Name Resolution Tests on PAB");
		LUIOut(L1," ");

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
		LUIOut(LFAIL2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(LFAIL2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}
	
	cEntries = 1;
	GetPrivateProfileString("ResolveName","ResName1","",szResName[0],BIG_BUF,INIFILENAME);
	LUIOut(L2,"Step1: Resolve unresolved name");
	LUIOut(L3,"Name to resolve: %s",szResName[0]);
	temp1 = sizeof(ADRLIST) + cEntries*(sizeof(ADRENTRY));
	temp2 = CbNewADRLIST(cEntries);

	MAPIAllocateBuffer(CbNewADRLIST(cEntries), (LPVOID *) &lpAdrList );
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[0].rgPropVals));
	
	lpAdrList->cEntries = cEntries;
	lpAdrList->aEntries[0].cValues = 1;
	lpAdrList->aEntries[0].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[0].rgPropVals->dwAlignPad = 0;
	lpAdrList->aEntries[0].rgPropVals->Value.LPSZ = szResName[0];

	hr = lpAdrBook->ResolveName((ULONG)GetActiveWindow(), MAPI_DIALOG, NULL, lpAdrList);

	if (HR_FAILED(hr)) {		
			 LUIOut(LFAIL4,"ResolveName Failed for %s",lpAdrList->aEntries[0].rgPropVals->Value.LPSZ);
			 retval=FALSE;
			 goto out;
	}
	else LUIOut(LPASS4,"Resolved successfully");

	if (ValidateAdrList(lpAdrList, cEntries))
		LUIOut(LPASS4,"Validation passed");
	else {
		LUIOut(LFAIL4,"Validation unsuccessful");
		retval = FALSE;
	}


	LUIOut(L2,"Step2: Resolve the previously resolved name");

	hr = lpAdrBook->ResolveName(0, 0, NULL, lpAdrList);

	if (HR_FAILED(hr)) {		
			 LUIOut(LFAIL4,"ResolveName Failed for %s",lpAdrList->aEntries[0].rgPropVals->Value.LPSZ);
			 retval=FALSE;
			 goto out;
	}
	else LUIOut(LPASS4,"Resolved successfully");

	LUIOut(L4,"Validate the returned PropList");

	if (ValidateAdrList(lpAdrList, cEntries))
		LUIOut(LPASS4,"Validation passed");
	else {
		LUIOut(LFAIL4,"Validation unsuccessful");
		retval = FALSE;
	}
	
	MAPIFreeBuffer( lpAdrList->aEntries[0].rgPropVals );
	MAPIFreeBuffer( lpAdrList );
	lpAdrList = NULL;
	
	LUIOut(L2,"Step3: Resolve  mixed names");
	LUIOut(L2,"->prev. resolved and unresolved");

	LUIOut(L3,"Step3a: Resolve following unresolved names: ");

	GetPrivateProfileString("ResolveName","ResName2","",szResName[1],BIG_BUF,INIFILENAME);
	GetPrivateProfileString("ResolveName","ResName3","",szResName[2],BIG_BUF,INIFILENAME);
	GetPrivateProfileString("ResolveName","ResName4","",szResName[3],BIG_BUF,INIFILENAME);

	LUIOut(L4,"%s",szResName[1]);
	LUIOut(L4,"%s",szResName[2]);
	LUIOut(L4,"%s",szResName[3]);

	cEntries = 3;

	MAPIAllocateBuffer(CbNewADRLIST(cEntries), (LPVOID *) &lpAdrList );
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[0].rgPropVals));
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[1].rgPropVals));
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[2].rgPropVals));

	lpAdrList->cEntries = cEntries;
	// Name 1
	lpAdrList->aEntries[0].cValues = 1;
	lpAdrList->aEntries[0].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[0].rgPropVals->Value.LPSZ = szResName[1];
	// Name 2
	lpAdrList->aEntries[1].cValues = 1;
	lpAdrList->aEntries[1].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[1].rgPropVals->Value.LPSZ = szResName[2];
	// Name 3
	lpAdrList->aEntries[2].cValues = 1;
	lpAdrList->aEntries[2].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[2].rgPropVals->Value.LPSZ = szResName[3];

	if(HR_FAILED(lpAdrBook->ResolveName((ULONG)GetActiveWindow(), MAPI_DIALOG, NULL, lpAdrList))) {
		LUIOut( LFAIL4, "ResolveName failed for unresolved names" );
		retval = FALSE;
		goto out;
	}
	LUIOut( LPASS4, "ResolveName passed for unresolved names." );

	//Validate the AdrList
	LUIOut(L4,"Validate the returned PropList");
	if (ValidateAdrList(lpAdrList, cEntries))
		LUIOut(LPASS4,"Validation passed");
	else {
		LUIOut(LFAIL4,"Validation unsuccessful");
		retval = FALSE;
	}

	// Now add two unresolved names to the AdrList
	LUIOut(L4,"Step3b: Add the following unresolved names to the list: ");

	GetPrivateProfileString("ResolveName","ResName5","",szResName[4],BIG_BUF,INIFILENAME);
	GetPrivateProfileString("ResolveName","ResName6","",szResName[5],BIG_BUF,INIFILENAME);
	LUIOut(L4,"%s",szResName[4]);
	LUIOut(L4,"%s",szResName[5]);

	cEntries = 5;
	MAPIAllocateBuffer(CbNewADRLIST(cEntries), (LPVOID *) &lpAdrListNew);
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrListNew->aEntries[1].rgPropVals));
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrListNew->aEntries[3].rgPropVals));
	
	lpAdrListNew->cEntries = cEntries;

	// Name 2
	lpAdrListNew->aEntries[1].cValues = 1;
	lpAdrListNew->aEntries[1].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrListNew->aEntries[1].rgPropVals->Value.LPSZ = szResName[4];

	// Name 4
	lpAdrListNew->aEntries[3].cValues = 1;
	lpAdrListNew->aEntries[3].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrListNew->aEntries[3].rgPropVals->Value.LPSZ = szResName[5];

	lpAdrListNew->aEntries[0] = lpAdrList->aEntries[0];
	lpAdrListNew->aEntries[2] = lpAdrList->aEntries[1];
	lpAdrListNew->aEntries[4] = lpAdrList->aEntries[2];

	MAPIFreeBuffer(lpAdrList);
	lpAdrList = NULL;

	lpAdrList = lpAdrListNew;

	// call ResolveName() w/ a mix of resolved and unresolved.

	if(HR_FAILED(lpAdrBook->ResolveName((ULONG) GetActiveWindow(), MAPI_DIALOG, NULL, lpAdrList)))
	{
		LUIOut( LFAIL4, "ResolveName failed with resolved and unresolved names" );
		retval = FALSE;
		goto out;
	}
	LUIOut( LPASS4, "ResolveName passed with resolved and unresolved names" );

	//Validate the AdrList
	LUIOut(L4,"Validate the returned PropList");
	if (ValidateAdrList(lpAdrList, cEntries))
		LUIOut(LPASS4,"Validation passed");
	else {
		LUIOut(LFAIL4,"Validation unsuccessful");
		retval = FALSE;
	}

	for(i=0; i<(int) cEntries; ++i)
		MAPIFreeBuffer(lpAdrList->aEntries[i].rgPropVals);

	MAPIFreeBuffer(lpAdrList );
	lpAdrList = NULL;

	GetPrivateProfileString("ResolveName","NonExistentName","",szResName[6],BIG_BUF,INIFILENAME);
	LUIOut(L3,"Step 4: Resolve non existent name");
	LUIOut(L3,"Name: %s",szResName[6]);

	//call ResolveName() with a non-existant name
	cEntries = 1;

	MAPIAllocateBuffer(CbNewADRLIST(cEntries), (LPVOID *) &lpAdrList);
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[0].rgPropVals));


	lpAdrList->cEntries = cEntries;
	lpAdrList->aEntries[0].cValues = 1;
	lpAdrList->aEntries[0].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[0].rgPropVals->Value.LPSZ = szResName[6];
	
	if(lpAdrBook->ResolveName(0,0, NULL,lpAdrList)	!= MAPI_E_NOT_FOUND)
	{
		LUIOut( LFAIL4, "ResolveName did not return NOT FOUND" );
		retval = FALSE;
		goto out;
	}
	LUIOut( LPASS4, "ResolveName correctly returned MAPI_E_NOT_FOUND." );

	MAPIFreeBuffer(lpAdrList->aEntries[0].rgPropVals );
	MAPIFreeBuffer(lpAdrList );
	lpAdrList = NULL;

	//call ResolveName() w/ just the ambiguous name
	cEntries = 1;
	GetPrivateProfileString("ResolveName","AmbigousName","",szResNam