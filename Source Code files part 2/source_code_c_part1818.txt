unction overrides
	//{{AFX_VIRTUAL(CAllServerWinStationsPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAllServerWinStationsPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CAllServerWinStationsPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnWinStationItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusWinstationList( NMHDR* , LRESULT* );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAllServerWinStationsPage


////////////////////////////
// CLASS: CAllServerProcessesPage
//
class CAllServerProcessesPage : public CAdminPage
{
friend class CAllServersView;

protected:
	CAllServerProcessesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAllServerProcessesPage)

// Form Data
public:
	//{{AFX_DATA(CAllServerProcessesPage)
	enum { IDD = IDD_ALL_SERVER_PROCESSES };
	CListCtrl	m_ProcessList;
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

private:
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:

protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);
	void UpdateProcesses(CServer *pServer);
	void RemoveProcess(CProcess *pProcess);

private:
	virtual void Reset(void *);
	void DisplayProcesses( NODETYPE );			
	BOOL AddServerToList(CServer *pServer);
	int AddProcessToList(CProcess *pProcess);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAllServerProcessesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAllServerProcessesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CAllServerProcessesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusProcessList(NMHDR* , LRESULT* pResult);

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAllServerProcessesPage


//////////////////////////
// CLASS: CAllServerLicensesPage
//
class CAllServerLicensesPage : public CAdminPage
{
friend class CAllServersView;

protected:
	CAllServerLicensesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAllServerLicensesPage)

// Form Data
public:
	//{{AFX_DATA(CAllServerLicencesPage)
	enum { IDD = IDD_ALL_SERVER_LICENSES };
	CListCtrl	m_LicenseList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxBase;		// index of Base image
	int m_idxBump;		// index of Bump image
	int m_idxEnabler;	// index of Enabler image 
	int m_idxUnknown;	// index of Unknown image

private:
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;

// Operations
public:

protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayLicenses();			
	void DisplayLicenseCounts();
	virtual void Reset(void*);
	BOOL AddServerToList(CServer *pServer);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAllServerLicensesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAllServerLicensesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CAllServerLicensesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusLicenseList(NMHDR* , LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAllServerLicensesPage


#endif  // _ALLSERVERPAGES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\apppgs.h ===
/*******************************************************************************
*
* apppgs.h
*
* - declarations for the Application info pages
* - the application info pages are all CFormView derivatives
*   based on dialog templates
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\apppgs.h  $
*  
*     Rev 1.2   16 Feb 1998 16:00:02   donm
*  modifications to support pICAsso extension
*  
*     Rev 1.1   03 Nov 1997 15:20:26   donm
*  added descending sort
*  
*     Rev 1.0   16 Oct 1997 13:40:52   donm
*  Initial revision.
*  
*******************************************************************************/

#ifndef _APPLICATIONPAGES_H
#define _APPLICATIONPAGES_H

#include "Resource.h"
#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "winadmin.h"

//////////////////////////
// CLASS: CApplicationServersPage
//
class CApplicationServersPage : public CAdminPage
{
friend class CApplicationView;

protected:
	CApplicationServersPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CApplicationServersPage)

// Form Data
public:
	//{{AFX_DATA(CApplicationServersPage)
	enum { IDD = IDD_APPLICATION_SERVERS };
	CListCtrl	m_ServerList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_imageList;		// image list associated with the tree control

	int m_idxServer;		   // index of Server image
	int m_idxCurrentServer;		// index of Current Server image

private:
	CPublishedApp *m_pApplication;	// pointer to current Application's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayServers();			
	void Reset(void *pApplication);
	void UpdateServer(CServer *pServer);
	void AddServer(CAppServer *pAppServer);
	void RemoveServer(CAppServer *pAppServer);
	int AddServerToList(CAppServer *pAppServer);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CApplicationServersPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CApplicationServersPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CApplicationServersPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusServerList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnCommandHelp(void);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CApplicationServersPage


//////////////////////////
// CLASS: CApplicationUsersPage
//
class CApplicationUsersPage : public CAdminPage
{
friend class CApplicationView;

protected:
	CApplicationUsersPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CApplicationUsersPage)

// Form Data
public:
	//{{AFX_DATA(CApplicationUsersPage)
	enum { IDD = IDD_APPLICATION_USERS };
	CListCtrl	m_UserList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_imageList;		// image list associated with the tree control

	int m_idxUser;				// index of User image
	int m_idxCurrentUser;		// index of Current User image

private:
	CPublishedApp *m_pApplication;	// pointer to current Application's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:

protected:
	void UpdateWinStations(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayUsers();			
	void Reset(void *pApplication);
	int AddUserToList(CWinStation *pWinStation);
	void PopulateUserColumns(int item, CWinStation *pWinStation, BOOL newitem);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CApplicationUsersPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CApplicationUsersPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CApplicationUsersPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusUserList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnCommandHelp(void);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CApplicationUsersPage


//////////////////////////
// CLASS: CApplicationInfoPage
//

const int LOCAL_GROUP_IMAGE = 0;
const int GLOBAL_GROUP_IMAGE = 1;
const int USER_IMAGE = 2;

class CApplicationInfoPage : public CAdminPage
{
friend class CApplicationView;

protected:
	CApplicationInfoPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CApplicationInfoPage)

// Form Data
public:
	//{{AFX_DATA(CApplicationInfoPage)
	enum { IDD = IDD_APPLICATION_INFO };
	CListCtrl	m_SecurityList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_imageList;		// image list associated with the tree control

private:
	CPublishedApp *m_pApplication;	// pointer to current Application's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;

// Operations
public:

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void Display();			
	void Reset(void *pApplication);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CApplicationInfoPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CApplicationInfoPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CApplicationInfoPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusSecurityList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnCommandHelp(void);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CApplicationInfoPage


#endif  // _APPLICATIONPAGES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\apppgs.cpp ===
/*******************************************************************************
*
* apppgs.cpp
*
* implementations for the Application info pages
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\apppgs.cpp  $
*  
*     Rev 1.4   16 Feb 1998 16:00:00   donm
*  modifications to support pICAsso extension
*  
*     Rev 1.3   03 Nov 1997 15:20:24   donm
*  added descending sort
*  
*     Rev 1.2   22 Oct 1997 21:06:14   donm
*  update
*  
*     Rev 1.1   18 Oct 1997 18:49:48   donm
*  update
*  
*******************************************************************************/

#include "stdafx.h"
#include "afxpriv.h"
#include "winadmin.h"
#include "admindoc.h"
#include "apppgs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////////////////
// MESSAGE MAP: CApplicationServersPage
//
IMPLEMENT_DYNCREATE(CApplicationServersPage, CFormView)

BEGIN_MESSAGE_MAP(CApplicationServersPage, CFormView)
	//{{AFX_MSG_MAP(CApplicationServersPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_APPLICATION_SERVER_LIST, OnColumnClick)
	ON_NOTIFY(NM_SETFOCUS, IDC_APPLICATION_SERVER_LIST, OnSetfocusServerList)
	ON_COMMAND(ID_HELP, CWnd::OnHelp)
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	ON_MESSAGE(WM_HELP, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CApplicationServersPage ctor
//
CApplicationServersPage::CApplicationServersPage()
	: CAdminPage(CApplicationServersPage::IDD)
{
	//{{AFX_DATA_INIT(CApplicationServersPage)
	//}}AFX_DATA_INIT

    m_pApplication = NULL;
    m_bSortAscending = TRUE;

}  // end CApplicationServersPage ctor


/////////////////////////////
// F'N: CApplicationServersPage dtor
//
CApplicationServersPage::~CApplicationServersPage()
{
}  // end CApplicationServersPage dtor


////////////////////////////////////////
// F'N: CApplicationServersPage::DoDataExchange
//
void CApplicationServersPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CApplicationServersPage)
	DDX_Control(pDX, IDC_APPLICATION_SERVER_LIST, m_ServerList);	
	//}}AFX_DATA_MAP

}  // end CApplicationServersPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CApplicationServersPage::AssertValid
//
void CApplicationServersPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CApplicationServersPage::AssertValid


//////////////////////////////
// F'N: CApplicationServersPage::Dump
//
void CApplicationServersPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CApplicationServersPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CApplicationServersPage::OnCommandHelp
//
void CApplicationServersPage::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CApplicationServersPage::IDD + HID_BASE_RESOURCE);

}  // end CApplicationServersPage::OnCommandHelp

static ColumnDef ServerColumns[] = {
	CD_SERVER,
{ 	IDS_COL_COMMAND_LINE,	LVCFMT_LEFT,	200		},
{ 	IDS_COL_WORKING_DIR,	LVCFMT_LEFT,	200		},
{ 	IDS_COL_TCP_LOAD,		LVCFMT_RIGHT,	100		},
{ 	IDS_COL_IPX_LOAD,		LVCFMT_RIGHT,	100		},
{	IDS_COL_NETBIOS_LOAD,	LVCFMT_RIGHT,	100		}
};

#define NUM_SERVER_COLUMNS sizeof(ServerColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CApplicationServersPage::OnInitialUpdate
//
void CApplicationServersPage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

	BuildImageList();		// builds the image list for the list control

	CString columnString;

	for(int col = 0; col < NUM_SERVER_COLUMNS; col++) {
		columnString.LoadString(ServerColumns[col].stringID);
		m_ServerList.InsertColumn(col, columnString, ServerColumns[col].format, ServerColumns[col].width, col);
	}

	m_CurrentSortColumn = APP_SERVER_COL_SERVER;

}  // end CApplicationServersPage::OnInitialUpdate


//////////////////////////////
// F'N: CApplicationServersPage::OnColumnClick
//
void CApplicationServersPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	SortByColumn(VIEW_APPLICATION, PAGE_APP_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);

	*pResult = 0;

}  // end CApplicationUsersPage::OnColumnClick


//////////////////////////////
// F'N: CApplicationServersPage::OnSize
//
void CApplicationServersPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	rect.top += LIST_TOP_OFFSET;

	if(m_ServerList.GetSafeHwnd())
		m_ServerList.MoveWindow(&rect, TRUE);

	CFormView::OnSize(nType, cx, cy);

}  // end CApplicationServersPage::OnSize


//////////////////////////////
// F'N: CApplicationServersPage::Reset
//
void CApplicationServersPage::Reset(void *pApplication)
{
	m_pApplication = (CPublishedApp*)pApplication;
	DisplayServers();

}  // end CApplicationServersPage::Reset


//////////////////////////////
// F'N: CApplicationServersPage::AddServer
//
void CApplicationServersPage::AddServer(CAppServer *pAppServer)
{
	ASSERT(pAppServer);

	// We have to make sure the server isn't already in the list
	// Add the server to the list
	if(AddServerToList(pAppServer)) {
	    // Tell the list to sort itself
	    LockListControl();
	    SortByColumn(VIEW_APPLICATION, PAGE_APP_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);	
	    UnlockListControl();
    }

}  // end CApplicationServersPage::AddServer


//////////////////////////////
// F'N: CApplicationServersPage::RemoveServer
//
void CApplicationServersPage::RemoveServer(CAppServer *pAppServer)
{
	ASSERT(pAppServer);

	LockListControl();
	// Find out how many items in the list
	int ItemCount = m_ServerList.GetItemCount();

	// Go through the items are remove this server
	for(int item = 0; item < ItemCount; item++) {
		CAppServer *pListAppServer = (CAppServer*)m_ServerList.GetItemData(item);
		
		if(pListAppServer == pAppServer) {
			m_ServerList.DeleteItem(item);
			break;
		}
	}
	UnlockListControl();

}  // end CApplicationServersPage::RemoveServer


//////////////////////////////
// F'N: CApplicationServersPage::AddServerToList
//
int CApplicationServersPage::AddServerToList(CAppServer *pAppServer)
{
	ASSERT(pAppServer);

	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

	// Server - put at the end of the list
	int item = m_ServerList.InsertItem(m_ServerList.GetItemCount(), pAppServer->GetName(), 
		pAppServer->IsCurrentServer() ? m_idxCurrentServer : m_idxServer);

	// Command Line
	m_ServerList.SetItemText(item, APP_SERVER_COL_CMDLINE, pAppServer->GetInitialProgram());

	// Working Directory
	m_ServerList.SetItemText(item, APP_SERVER_COL_WORKDIR, pAppServer->GetWorkDirectory());

	CServer *pServer = pDoc->FindServerByName(pAppServer->GetName());
	if(pServer) {
		ExtServerInfo *pExtServerInfo = pServer->GetExtendedInfo();
		CString LoadLevelString;
		if(pExtServerInfo && ((pExtServerInfo->Flags & ESF_LOAD_BALANCING) > 0)) {
			if(pExtServerInfo->TcpLoadLevel == 0xFFFFFFFF) {
				LoadLevelString.LoadString(IDS_NOT_APPLICABLE);
			}
			else LoadLevelString.Format(TEXT("%lu"), pExtServerInfo->TcpLoadLevel);
			m_ServerList.SetItemText(item, APP_SERVER_COL_TCP_LOAD, LoadLevelString);

			if(pExtServerInfo->IpxLoadLevel == 0xFFFFFFFF) {
				LoadLevelString.LoadString(IDS_NOT_APPLICABLE);
			}
			else LoadLevelString.Format(TEXT("%lu"), pExtServerInfo->IpxLoadLevel);
			m_ServerList.SetItemText(item, APP_SERVER_COL_IPX_LOAD, LoadLevelString);

			if(pExtServerInfo->NetbiosLoadLevel == 0xFFFFFFFF) {
				LoadLevelString.LoadString(IDS_NOT_APPLICABLE);
			}
			else LoadLevelString.Format(TEXT("%lu"), pExtServerInfo->NetbiosLoadLevel);
			m_ServerList.SetItemText(item, APP_SERVER_COL_NETBIOS_LOAD, LoadLevelString);
		} else {
			LoadLevelString.LoadString(IDS_NOT_APPLICABLE);
			m_ServerList.SetItemText(item, APP_SERVER_COL_TCP_LOAD, LoadLevelString);
			m_ServerList.SetItemText(item, APP_SERVER_COL_IPX_LOAD, LoadLevelString);
			m_ServerList.SetItemText(item, APP_SERVER_COL_NETBIOS_LOAD, LoadLevelString);
		}
	}

	m_ServerList.SetItemData(item, (DWORD)pAppServer);

	return item;

}  // end CApplicationServersPage::AddServerToList


/////////////////////////////////////
// F'N: CApplicationServersPage::DisplayServers
//
void CApplicationServersPage::DisplayServers()
{
	// Clear out the list control
	m_ServerList.DeleteAllItems();

    m_pApplication->LockServerList();

	// Get a pointer to this App's list of Servers
	CObList *pServerList = m_pApplication->GetServerList();

	// Iterate through the Server list
	POSITION pos = pServerList->GetHeadPosition();

	while(pos) {
		CAppServer *pAppServer = (CAppServer*)pServerList->GetNext(pos);

		AddServerToList(pAppServer);


	}	// end while(pos)

	m_pApplication->UnlockServerList();

	SortByColumn(VIEW_APPLICATION, PAGE_APP_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);

}  // end CApplicationServersPage::DisplayServers


/////////////////////////////////////
// F'N: CApplicationServersPage::UpdateServer
//
void CApplicationServersPage::UpdateServer(CServer *pServer)
{
	ASSERT(pServer);

	CAppServer *pAppServer = m_pApplication->FindServerByName(pServer->GetName());

	if(!pAppServer) return;

	LV_FINDINFO FindInfo;
	FindInfo.flags = LVFI_PARAM;
	FindInfo.lParam = (LPARAM)pAppServer;

	// Find the AppServer in our list
	int item = m_ServerList.FindItem(&FindInfo, -1);

	if(item != -1) {
		ExtServerInfo *pExtServerInfo = pServer->GetExtendedInfo();
		CString LoadLevelString;
		if(pExtServerInfo && ((pExtServerInfo->Flags & ESF_LOAD_BALANCING) > 0)) {
			if(pExtServerInfo->TcpLoadLevel == 0xFFFFFFFF) {
				LoadLevelString.LoadString(IDS_NOT_APPLICABLE);
			}
			else LoadLevelString.Format(TEXT("%lu"), pExtServerInfo->TcpLoadLevel);
			m_ServerList.SetItemText(item, APP_SERVER_COL_TCP_LOAD, LoadLevelString);

			if(pExtServerInfo->IpxLoadLevel == 0xFFFFFFFF) {
				LoadLevelString.LoadString(IDS_NOT_APPLICABLE);
			}
			else LoadLevelString.Format(TEXT("%lu"), pExtServerInfo->IpxLoadLevel);
			m_ServerList.SetItemText(item, APP_SERVER_COL_IPX_LOAD, LoadLevelString);

			if(pExtServerInfo->NetbiosLoadLevel == 0xFFFFFFFF) {
				LoadLevelString.LoadString(IDS_NOT_APPLICABLE);
			}
			else LoadLevelString.Format(TEXT("%lu"), pExtServerInfo->NetbiosLoadLevel);
			m_ServerList.SetItemText(item, APP_SERVER_COL_NETBIOS_LOAD, LoadLevelString);
		} 
	}
	
}	// end CApplicationServersPage::UpdateServer


/////////////////////////////////////
// F'N: CApplicationServersPage::BuildImageList
//
// - calls m_imageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CApplicationServersPage::BuildImageList()
{
	m_imageList.Create(16, 16, TRUE, 2, 0);

	m_idxServer  = AddIconToImageList(IDI_SERVER);
	m_idxCurrentServer = AddIconToImageList(IDI_CURRENT_SERVER);
	
	m_ServerList.SetImageList(&m_imageList, LVSIL_SMALL);

}  // end CApplicationServersPage::BuildImageList


/////////////////////////////////////////
// F'N: CApplicationServersPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_imageList, and returns
//   the newly-added icon's index in the image list
//
int CApplicationServersPage::AddIconToImageList(int iconID)
{
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
	return m_imageList.Add(hIcon);

}  // end CApplicationServersPage::AddIconToImageList
 

/////////////////////////////////////////
// F'N: CApplicationServersPage::OnSetfocusServerList
//
void CApplicationServersPage::OnSetfocusServerList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	if(m_ServerList) m_ServerList.Invalidate();	
	*pResult = 0;
}	// end CApplicationServersPage::OnSetfocusServerList


////////////////////////////////
// MESSAGE MAP: CApplicationUsersPage
//
IMPLEMENT_DYNCREATE(CApplicationUsersPage, CFormView)

BEGIN_MESSAGE_MAP(CApplicationUsersPage, CFormView)
	//{{AFX_MSG_MAP(CApplicationUsersPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_APPLICATION_USER_LIST, OnColumnClick)
	ON_NOTIFY(NM_SETFOCUS, IDC_APPLICATION_USER_LIST, OnSetfocusUserList)
	ON_COMMAND(ID_HELP, CWnd::OnHelp)
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	ON_MESSAGE(WM_HELP, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CApplicationUsersPage ctor
//
CApplicationUsersPage::CApplicationUsersPage()
	: CAdminPage(CApplicationUsersPage::IDD)
{
	//{{AFX_DATA_INIT(CApplicationUsersPage)
	//}}AFX_DATA_INIT

    m_pApplication = NULL;
    m_bSortAscending = TRUE;

}  // end CApplicationUsersPage ctor


/////////////////////////////
// F'N: CApplicationUsersPage dtor
//
CApplicationUsersPage::~CApplicationUsersPage()
{
}  // end CApplicationUsersPage dtor


////////////////////////////////////////
// F'N: CApplicationUsersPage::DoDataExchange
//
void CApplicationUsersPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CApplicationUsersPage)
	DDX_Control(pDX, IDC_APPLICATION_USER_LIST, m_UserList);	
	//}}AFX_DATA_MAP

}  // end CApplicationUsersPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CApplicationUsersPage::AssertValid
//
void CApplicationUsersPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CApplicationUsersPage::AssertValid


//////////////////////////////
// F'N: CApplicationUsersPage::Dump
//
void CApplicationUsersPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CApplicationUsersPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CApplicationUsersPage::OnCommandHelp
//
void CApplicationUsersPage::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CApplicationUsersPage::IDD + HID_BASE_RESOURCE);

}  // end CApplicationUsersPage::OnCommandHelp

static ColumnDef UserColumns[] = {
	CD_SERVER,
	CD_USER3,
	CD_SESSION,
	CD_ID,
	CD_STATE,
	CD_IDLETIME,
	CD_LOGONTIME
};

#define NUM_USER_COLUMNS sizeof(UserColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CApplicationUsersPage::OnInitialUpdate
//
void CApplicationUsersPage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

	BuildImageList();		// builds the image list for the list control

	CString columnString;

	for(int col = 0; col < NUM_USER_COLUMNS; col++) {
		columnString.LoadString(UserColumns[col].stringID);
		m_UserList.InsertColumn(col, columnString, UserColumns[col].format, UserColumns[col].width, col);
	}

	m_CurrentSortColumn = APP_USERS_COL_SERVER;

}  // end CApplicationUsersPage::OnInitialUpdate


//////////////////////////////
// F'N: CApplicationUsersPage::OnColumnClick
//
void CApplicationUsersPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	SortByColumn(VIEW_APPLICATION, PAGE_APP_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);

	*pResult = 0;

}  // end CApplicationUsersPage::OnColumnClick


//////////////////////////////
// F'N: CApplicationUsersPage::OnSize
//
void CApplicationUsersPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

   rect.top += LIST_TOP_OFFSET;

	if(m_UserList.GetSafeHwnd())
		m_UserList.MoveWindow(&rect, TRUE);

	CFormView::OnSize(nType, cx, cy);

}  // end CApplicationUsersPage::OnSize


//////////////////////////////
// F'N: CApplicationUsersPage::Reset
//
void CApplicationUsersPage::Reset(void *pApplication)
{
	m_pApplication = (CPublishedApp*)pApplication;
	DisplayUsers();

}  // end CApplicationUsersPage::Reset


/////////////////////////////////////
// F'N: CApplicationUsersPage::DisplayUsers
//
//
void CApplicationUsersPage::DisplayUsers()
{
	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

	// Clear out the list control
	m_UserList.DeleteAllItems();

    pDoc->LockServerList();

	// Get a pointer to this document's list of Servers
	CObList *pServerList = pDoc->GetServerList();

	// Iterate through the Server list
	POSITION pos = pServerList->GetHeadPosition();

	while(pos) {
		CServer *pServer = (CServer*)pServerList->GetNext(pos);

		if(!pServer->IsState(SS_GOOD)) continue;

		// Loop through the WinStations on this server and
		// see if any are running this published app
		CObList *pWinStationList = pServer->GetWinStationList();
		pServer->LockWinStationList();

		POSITION pos2 = pWinStationList->GetHeadPosition();

		while(pos2) {
			CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos2);
		
			if(pWinStation->IsActive() 
				&& pWinStation->HasUser()
				&& pWinStation->IsRunningPublishedApp() 
				&& pWinStation->IsRunningPublishedApp(m_pApplication->GetName())) {
					AddUserToList(pWinStation);
			}
		}	// end while(pos2)

		pServer->UnlockWinStationList();

	}	// end while(pos)

	pDoc->UnlockServerList();

	SortByColumn(VIEW_APPLICATION, PAGE_APP_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);

}  // end CApplicationUsersPage::DisplayUsers


//////////////////////////////
// F'N: CApplicationUsersPage::UpdateWinStations
//
void CApplicationUsersPage::UpdateWinStations(CServer *pServer)
{
	ASSERT(pServer);

	// If the server isn't in the list of servers for this application, there's
	// nothing to do
	if(!m_pApplication->FindServerByName(pServer->GetName())) return;

	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
	BOOL bAnyChanges = FALSE;

	// Loop through the WinStations
	pServer->LockWinStationList();
	CObList *pWinStationList = pServer->GetWinStationList();

	POSITION pos = pWinStationList->GetHeadPosition();

	while(pos) {
		CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

		LV_FINDINFO FindInfo;
		FindInfo.flags = LVFI_PARAM;
		FindInfo.lParam = (LPARAM)pWinStation;

		// Find the WinStation in our list
		int item = m_UserList.FindItem(&FindInfo, -1);

		// If user is not in the list
		if(item == -1) {
			// If the WinStation is not in the list but now has a user that is running
			// this published application, add it to the list
			if((pWinStation->IsCurrent() || pWinStation->IsNew())
				&& pWinStation->HasUser()
				&& pWinStation->IsRunningPublishedApp() 
				&& pWinStation->IsRunningPublishedApp(m_pApplication->GetName())) {

				AddUserToList(pWinStation);
				bAnyChanges = TRUE;
				continue;
			}

		// user is already in the list
		} else {
			// If the WinStation is no longer current,
			// remove it from the list
			if(!pWinStation->IsCurrent() || !pWinStation->HasUser()) {
				// Remove the WinStation from the list
				m_UserList.DeleteItem(item);
				pWinStation->ClearSelected();
				continue;
			}

			// If the WinStation info has changed, change
			// it's info in our tree
			if(pWinStation->IsChanged()) {

				PopulateUserColumns(item, pWinStation, FALSE);

				if(m_CurrentSortColumn != APP_USERS_COL_ID)
					bAnyChanges = TRUE;

				continue;
			}
		}
	}

	pServer->UnlockWinStationList();

	if(bAnyChanges) SortByColumn(VIEW_APPLICATION, PAGE_APP_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);

}  // end CApplicationUsersPage::UpdateWinStations


//////////////////////////////
// F'N: CApplicationUsersPage::AddUserToList
//
int CApplicationUsersPage::AddUserToList(CWinStation *pWinStation)
{
	ASSERT(pWinStation);

	CServer *pServer = pWinStation->GetServer();

	LockListControl();

	//////////////////////
	// Fill in the columns
	//////////////////////
	// Server - put at the end of the list
	int item = m_UserList.InsertItem(m_UserList.GetItemCount(), pServer->GetName(),
		pWinStation->IsCurrentUser() ? m_idxCurrentUser : m_idxUser);

	PopulateUserColumns(item, pWinStation, TRUE);

	// Attach a pointer to the CWinStation structure to the list item
	m_UserList.SetItemData(item, (DWORD)pWinStation);

	UnlockListControl();

	return item;

}  // end CApplicationUsersPage::AddUserToList


//////////////////////////////
// F'N: CApplicationUsersPage::PopulateUserColumns
//
void CApplicationUsersPage::PopulateUserColumns(int item, CWinStation *pWinStation, BOOL newitem)
{
	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

	if(!newitem) {
		// User
		m_UserList.SetItemText(item, APP_USERS_COL_USER, pWinStation->GetUserName());
	}

	// WinStation Name
	if(pWinStation->GetName()[0])
	    m_UserList.SetItemText(item, APP_USERS_COL_WINSTATION, pWinStation->GetName());
	else {
		CString NameString(" ");
		if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
		if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
	    m_UserList.SetItemText(item, APP_USERS_COL_WINSTATION, NameString);
	}

	// Logon ID
	CString ColumnString;
	ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
	m_UserList.SetItemText(item, APP_USERS_COL_ID, ColumnString);
	
	// Connect State
	m_UserList.SetItemText(item, APP_USERS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

	// Idle Time
	TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

	ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

	if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
	{
		ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
	}
	else wcscpy(IdleTimeString, TEXT("."));

	m_UserList.SetItemText(item, APP_USERS_COL_IDLETIME, IdleTimeString);

	// Logon Time
	TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
	// We don't want to pass a 0 logon time to DateTimeString()
	// It will blow up if the timezone is GMT
	if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
		DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
		pDoc->FixUnknownString(LogonTimeString);
	}
	else LogonTimeString[0] = '\0';

	m_UserList.SetItemText(item, APP_USERS_COL_LOGONTIME, LogonTimeString);

}	// end CApplicationUsersPage::PopulateUserColumns


/////////////////////////////////////
// F'N: CApplicationUsersPage::BuildImageList
//
// - calls m_imageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CApplicationUsersPage::BuildImageList()
{
	m_imageList.Create(16, 16, TRUE, 2, 0);

	m_idxUser  = AddIconToImageList(IDI_USER);
	m_idxCurrentUser = AddIconToImageList(IDI_CURRENT_USER);
	
	m_UserList.SetImageList(&m_imageList, LVSIL_SMALL);

}  // end CApplicationUsersPage::BuildImageList


/////////////////////////////////////////
// F'N: CApplicationUsersPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_imageList, and returns
//   the newly-added icon's index in the image list
//
int CApplicationUsersPage::AddIconToImageList(int iconID)
{
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
	return m_imageList.Add(hIcon);

}  // end CApplicationUsersPage::AddIconToImageList


/////////////////////////////////////////
// F'N: CApplicationUsersPage::OnSetfocusUserList
//
void CApplicationUsersPage::OnSetfocusUserList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	m_UserList.Invalidate();	
	*pResult = 0;
}	// end CApplicationUsersPage::OnSetfocusUserList


////////////////////////////////
// MESSAGE MAP: CApplicationInfoPage
//
IMPLEMENT_DYNCREATE(CApplicationInfoPage, CFormView)

BEGIN_MESSAGE_MAP(CApplicationInfoPage, CFormView)
	//{{AFX_MSG_MAP(CApplicationInfoPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_APPLICATION_SECURITY_LIST, OnColumnClick)
	ON_NOTIFY(NM_SETFOCUS, IDC_APPLICATION_SECURITY_LIST, OnSetfocusSecurityList)
	ON_COMMAND(ID_HELP, CWnd::OnHelp)
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	ON_MESSAGE(WM_HELP, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CApplicationInfoPage ctor
//
CApplicationInfoPage::CApplicationInfoPage()
	: CAdminPage(CApplicationInfoPage::IDD)
{
	//{{AFX_DATA_INIT(CApplicationInfoPage)
	//}}AFX_DATA_INIT

    m_pApplication = NULL;
    m_bSortAscending = TRUE;

}  // end CApplicationInfoPage ctor


/////////////////////////////
// F'N: CApplicationInfoPage dtor
//
CApplicationInfoPage::~CApplicationInfoPage()
{
}  // end CApplicationInfoPage dtor


////////////////////////////////////////
// F'N: CApplicationInfoPage::DoDataExchange
//
void CApplicationInfoPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CApplicationInfoPage)
	DDX_Control(pDX, IDC_APPLICATION_SECURITY_LIST, m_SecurityList);	
	//}}AFX_DATA_MAP

}  // end CApplicationInfoPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CApplicationInfoPage::AssertValid
//
void CApplicationInfoPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CApplicationInfoPage::AssertValid


//////////////////////////////
// F'N: CApplicationInfoPage::Dump
//
void CApplicationInfoPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CApplicationInfoPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CApplicationInfoPage::OnCommandHelp
//
void CApplicationInfoPage::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CApplicationInfoPage::IDD + HID_BASE_RESOURCE);

}  // end CApplicationInfoPage::OnCommandHelp

static ColumnDef SecurityColumns[] = {
{	IDS_COL_USER_GROUP, 		LVCFMT_LEFT,	200		},
{   IDS_COL_USER_TYPE,          LVCFMT_LEFT,    80      }
};

#define NUM_SECURITY_COLUMNS sizeof(SecurityColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CApplicationInfoPage::OnInitialUpdate
//
void CApplicationInfoPage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

	BuildImageList();		// builds the image list for the list control

	CString columnString;

	for(int col = 0; col < NUM_SECURITY_COLUMNS; col++) {
		columnString.LoadString(SecurityColumns[col].stringID);
		m_SecurityList.InsertColumn(col, columnString, SecurityColumns[col].format, SecurityColumns[col].width, col);
	}

	m_CurrentSortColumn = APP_SEC_COL_USERGROUP;

}  // end CApplicationInfoPage::OnInitialUpdate


//////////////////////////////
// F'N: CApplicationInfoPage::OnColumnClick
//
void CApplicationInfoPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	SortByColumn(VIEW_APPLICATION, PAGE_APP_INFO, &m_SecurityList, m_CurrentSortColumn, m_bSortAscending);

	*pResult = 0;

}  // end CApplicationInfoPage::OnColumnClick


//////////////////////////////
// F'N: CApplicationInfoPage::OnSize
//
void CApplicationInfoPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetWindowRect(&rect);

 	CWnd *pWnd = GetDlgItem(IDC_APPUSERS_LABEL);
	if(pWnd) {
		RECT rect2;
		pWnd->GetWindowRect(&rect2);
		rect.top = rect2.bottom + 5;
	}

	ScreenToClient(&rect);	

	if(m_SecurityList.GetSafeHwnd())
		m_SecurityList.MoveWindow(&rect, TRUE);

	CFormView::OnSize(nType, cx, cy);

}  // end CApplicationInfoPage::OnSize


//////////////////////////////
// F'N: CApplicationInfoPage::Reset
//
void CApplicationInfoPage::Reset(void *pApplication)
{
	m_pApplication = (CPublishedApp*)pApplication;
	Display();

}  // end CApplicationInfoPage::Reset


/////////////////////////////////////
// F'N: CApplicationInfoPage::Display
//
//
void CApplicationInfoPage::Display()
{
	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

	// Clear out the list control
	m_SecurityList.DeleteAllItems();

    // Application Type
    CString appString;
    appString.LoadString(m_pApplication->IsAnonymous() ? IDS_ANONYMOUS : IDS_EXPLICIT);
    SetDlgItemText(IDC_APP_TYPE, appString);

    // Hide Title Bar
    appString.LoadString(m_pApplication->IsTitleBarHidden() ? IDS_YES : IDS_NO);
    SetDlgItemText(IDC_HIDE_TITLE_BAR, appString);

	// Maximize Window
	appString.LoadString(m_pApplication->IsMaximize() ? IDS_YES : IDS_NO);
	SetDlgItemText(IDC_MAXIMIZE_WINDOW, appString);

    ////////////////////////////////////
    // Add users to list control
    ////////////////////////////////////
    m_pApplication->LockAllowedUserList();
    CObList *pList = m_pApplication->GetAllowedUserList();

 	POSITION pos = pList->GetHeadPosition();

	while(pos) {
		CAppAllowed *pAppAllowed = (CAppAllowed*)pList->GetNext(pos);
   
 		

		UINT stringID = IDS_USER;
		int image = USER_IMAGE;
		
		switch(pAppAllowed->GetType()) {
			case AAT_USER:
				stringID = IDS_USER;				
				image = USER_IMAGE;
				break;
			
			case AAT_LOCAL_GROUP:
				stringID = IDS_LOCAL_GROUP;
				image = LOCAL_GROUP_IMAGE;
				break;

			case AAT_GLOBAL_GROUP:
				stringID = IDS_GLOBAL_GROUP;
				image = GLOBAL_GROUP_IMAGE;
				break;
		}
		
		int item = m_SecurityList.InsertItem(m_SecurityList.GetItemCount(), pAppAllowed->m_Name, image);

		CString userString;
		userString.LoadString(stringID);
		m_SecurityList.SetItemText(item, APP_SEC_COL_USERTYPE, userString);

        m_SecurityList.SetItemData(item, (DWORD)pAppAllowed);
    }

	m_pApplication->UnlockAllowedUserList();

}  // end CApplicationInfoPage::Display


/////////////////////////////////////
// F'N: CApplicationInfoPage::BuildImageList
//
// - calls m_imageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CApplicationInfoPage::BuildImageList()
{
	m_imageList.Create(IDB_APP_USERS, 19, 0, RGB(255,255,255));

	m_SecurityList.SetImageList(&m_imageList, LVSIL_SMALL);

}  // end CApplicationInfoPage::BuildImageList


/////////////////////////////////////////
// F'N: CApplicationInfoPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_imageList, and returns
//   the newly-added icon's index in the image list
//
int CApplicationInfoPage::AddIconToImageList(int iconID)
{
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
	return m_imageList.Add(hIcon);

}  // end CApplicationaInfoPage::AddIconToImageList


/////////////////////////////////////////
// F'N: CApplicationInfoPage::OnSetfocusSecurityList
//
void CApplicationInfoPage::OnSetfocusSecurityList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	m_SecurityList.Invalidate();	
	*pResult = 0;

}	// end CApplicationInfoPage::OnSetfocusSecurityList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\appview.cpp ===
/*******************************************************************************
*
* appview.cpp
*
* implementation of the CApplicationView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\appview.cpp  $
*  
*     Rev 1.3   16 Feb 1998 16:00:26   donm
*  modifications to support pICAsso extension
*  
*     Rev 1.2   03 Nov 1997 15:20:32   donm
*  update
*  
*     Rev 1.1   22 Oct 1997 21:06:22   donm
*  update
*  
*     Rev 1.0   16 Oct 1997 14:00:06   donm
*  Initial revision.
*  
*******************************************************************************/

#include "stdafx.h"
#include "resource.h"
#include "appview.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////
// MESSAGE MAP: CApplicationView
//
IMPLEMENT_DYNCREATE(CApplicationView, CView)

BEGIN_MESSAGE_MAP(CApplicationView, CView)
	//{{AFX_MSG_MAP(CApplicationView)
	ON_WM_SIZE()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_NOTIFY(TCN_SELCHANGE, 0, OnTabSelChange)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATIONS, OnAdminUpdateWinStations)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER_INFO, OnAdminUpdateServerInfo)
	ON_MESSAGE(WM_EXT_ADD_APP_SERVER, OnExtAddAppServer)
	ON_MESSAGE(WM_EXT_REMOVE_APP_SERVER, OnExtRemoveAppServer)
	ON_MESSAGE(WM_EXT_APP_CHANGED, OnExtAppChanged)
END_MESSAGE_MAP()

PageDef CApplicationView::pages[NUMBER_OF_APP_PAGES] = {
	{ NULL, RUNTIME_CLASS( CApplicationServersPage ),	IDS_TAB_SERVERS, PAGE_APP_SERVERS,	NULL },
	{ NULL, RUNTIME_CLASS( CApplicationUsersPage ),		IDS_TAB_USERS,	 PAGE_APP_USERS,	NULL },
	{ NULL, RUNTIME_CLASS( CApplicationInfoPage ),		IDS_TAB_INFO,	PAGE_APP_INFO,		NULL }
};

///////////////////////
// F'N: CApplicationView ctor
//
CApplicationView::CApplicationView()
{
	m_pTabs       = NULL;
	m_pTabFont    = NULL;
	m_pApplication = NULL;

	m_CurrPage = PAGE_APP_SERVERS;

}  // end CApplicationView ctor


///////////////////////
// F'N: CApplicationView dtor
//
CApplicationView::~CApplicationView()
{
	if(m_pTabs)    delete m_pTabs;
	if(m_pTabFont) delete m_pTabFont;

}  // end CApplicationView dtor


#ifdef _DEBUG
///////////////////////////////
// F'N: CApplicationView::AssertValid
//
void CApplicationView::AssertValid() const
{
	CView::AssertValid();

}  // end CApplicationView::AssertValid


////////////////////////
// F'N: CApplicationView::Dump
//
void CApplicationView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CApplicationView::Dump

#endif //_DEBUG


////////////////////////////
// F'N: CApplicationView::OnCreate
//
int CApplicationView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;

}  // end CApplicationView::OnCreate


///////////////////////////////////
// F'N: CApplicationView::OnInitialUpdate
//
// - pointers to the pages of the sheet are obtained
//
void CApplicationView::OnInitialUpdate() 
{
	// create the tab control
	m_pTabs = new CTabCtrl;
    if(!m_pTabs) return;
	m_pTabs->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, CRect(0,0,0,0), this, 0);

	m_pTabFont = new CFont;
    if(m_pTabFont) {
	    m_pTabFont->CreateStockObject(DEFAULT_GUI_FONT);
	    m_pTabs->SetFont(m_pTabFont, TRUE);
    }

	TCHAR szTemp[40];
	CString tabString;
	int index = 0;
	for(int i = 0; i < NUMBER_OF_APP_PAGES; i++) {
		// If the page is shown under Picasso only and we're not running
		// under Picasso, skip to the next one
		if((pages[i].flags & PF_PICASSO_ONLY) && !((CWinAdminApp*)AfxGetApp())->IsPicasso()) continue;
		if(!(pages[i].flags & PF_NO_TAB)) {
			tabString.LoadString(pages[i].tabStringID);
			wcscpy(szTemp,tabString);
			AddTab(index, szTemp);
			index++;
		}
		pages[i].m_pPage = (CAdminPage*)pages[i].m_pRuntimeClass->CreateObject();
		pages[i].m_pPage->Create(NULL, NULL, WS_CHILD, CRect(0, 0, 0, 0), this, i, NULL);
		GetDocument()->AddView(pages[i].m_pPage);		
	}


	m_pTabs->SetCurSel(0);	

	m_CurrPage = PAGE_APP_SERVERS;

	OnChangePage(NULL, NULL);

}  // end CApplicationView::OnInitialUpdate


//////////////////////////
// F'N: CApplicationView::OnSize
//
// - size the pages to fill the entire view
//
void CApplicationView::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);
	if(m_pTabs->GetSafeHwnd())  {			// make sure the tabs object is valid
		m_pTabs->MoveWindow(&rect, TRUE);	// size the tabs

		// for the next part (sizing of pages), we might want to add a member var
		// that keeps track of which page/tab is current... this way we could
		// only actually do a redraw (MoveWindow second parm == TRUE) for the
		// guy who is currently visible--DJM
	
		// we want to size the pages, too
		m_pTabs->AdjustRect(FALSE, &rect);

      for(int i = 0; i < NUMBER_OF_APP_PAGES; i++) {
         if(pages[i].m_pPage && pages[i].m_pPage->GetSafeHwnd())
            pages[i].m_pPage->MoveWindow(&rect, TRUE);
      }
	}

}  // end CApplicationView::OnSize


//////////////////////////
// F'N: CApplicationView::OnDraw
//
// - the CApplicationView and it's pages draw themselves, so there isn't anything
//   to do here...
//
void CApplicationView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here

}  // end CApplicationView::OnDraw


/////////////////////////
// F'N: CApplicationView::Reset
//
// - 'resets' the view by taking a pointer to a CPublishedApp object and filling in 
//   the various property pages with info appropriate to that Application
//
void CApplicationView::Reset(void *pApplication)
{
	ASSERT(pApplication);

	m_pApplication = (CPublishedApp*)pApplication;

	for(int i = 0; i < NUMBER_OF_APP_PAGES; i++) {
		if(pages[i].m_pPage)
			pages[i].m_pPage->Reset(pApplication);
	}

	((CWinAdminDoc*)GetDocument())->SetCurrentPage(m_CurrPage);

}  // end CApplicationView::Reset


//////////////////////////
// F'N: CApplicationView::AddTab
//
void CApplicationView::AddTab(int index, TCHAR* text)
{
	TC_ITEM tc;
	tc.mask = TCIF_TEXT;
	tc.pszText = text;

	m_pTabs->InsertItem(index, &tc);

}  // end CApplicationView::AddTab


////////////////////////////////
// F'N: CApplicationView::OnChangePage
//
// - changes to a new Application page based on currently selected tab
// - OnChangePage needs to force recalculation of scroll bars!!!--DJM
//
LRESULT CApplicationView::OnChangePage(WPARAM wParam, LPARAM lParam)
{
	// find out which tab is now selected
	int index = m_pTabs->GetCurSel();
						
	// hide the current page
	pages[m_CurrPage].m_pPage->ModifyStyle(WS_VISIBLE, WS_DISABLED);	 
	m_CurrPage = index;
	((CWinAdminDoc*)GetDocument())->SetCurrentPage(m_CurrPage);
	// show the new page
	pages[index].m_pPage->ModifyStyle(WS_DISABLED, WS_VISIBLE);
	pages[index].m_pPage->ScrollToPosition(CPoint(0,0));
	pages[index].m_pPage->Invalidate();
	pages[index].m_pPage->SetFocus();

	return 0;

}  // end CApplicationView::OnChangeview


//////////////////////////
// F'N: CApplicationView::OnTabSelChange
//
void CApplicationView::OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnChangePage(NULL, NULL);
	*pResult = 0;

}  // end CApplicationView::OnTabSelChange


////////////////////////////////
// F'N: CApplicationView::OnAdminUpdateWinStations
//
//
LRESULT CApplicationView::OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam)
{
	((CApplicationUsersPage*)pages[PAGE_APP_USERS].m_pPage)->UpdateWinStations((CServer*)lParam);
	
	return 0;

}  // end CApplicationView::OnAdminUpdateWinStations


////////////////////////////////
// F'N: CApplicationView::OnAdminUpdateServerInfo
//
//
LRESULT CApplicationView::OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam)
{
	((CApplicationServersPage*)pages[PAGE_APP_SERVERS].m_pPage)->UpdateServer((CServer*)lParam);
	
	return 0;

}  // end CApplicationView::OnAdminUpdateWinStations


////////////////////////////////
// F'N: CApplicationView::OnExtAddAppServer
//
//
LRESULT CApplicationView::OnExtAddAppServer(WPARAM wParam, LPARAM lParam)
{
	if(m_pApplication == (CPublishedApp*)((ExtAddTreeNode*)wParam)->pParent) {
		((CApplicationServersPage*)pages[PAGE_APP_SERVERS].m_pPage)->AddServer((CAppServer*)lParam);
	}
	
	return 0;

}  // end CApplicationView::OnExtAddAppServer


////////////////////////////////
// F'N: CApplicationView::OnExtRemoveAppServer
//
//
LRESULT CApplicationView::OnExtRemoveAppServer(WPARAM wParam, LPARAM lParam)
{
	if(m_pApplication == (CPublishedApp*)wParam) {
		((CApplicationServersPage*)pages[PAGE_APP_SERVERS].m_pPage)->RemoveServer((CAppServer*)lParam);
	}
	
	return 0;

}  // end CApplicationView::OnExtAppChanged

////////////////////////////////
// F'N: CApplicationView::OnExtAppChanged
//
//
LRESULT CApplicationView::OnExtAppChanged(WPARAM wParam, LPARAM lParam)
{
	if(m_pApplication == (CPublishedApp*)lParam) {
		((CApplicationInfoPage*)pages[PAGE_APP_INFO].m_pPage)->Reset((CPublishedApp*)lParam);
	}
	
	return 0;

}  // end CApplicationView::OnExtAppChanged
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\appview.h ===
/*******************************************************************************
*
* appview.h
*
* declarations for the CApplicationView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\appview.h  $
*  
*     Rev 1.2   16 Feb 1998 16:00:28   donm
*  modifications to support pICAsso extension
*  
*     Rev 1.1   22 Oct 1997 21:06:58   donm
*  update
*  
*     Rev 1.0   16 Oct 1997 14:00:08   donm
*  Initial revision.
*  
*******************************************************************************/

#ifndef _APPLICATIONVIEW_H
#define _APPLICATIONVIEW_H

#include "apppgs.h"

const int NUMBER_OF_APP_PAGES = 3;

////////////////////
// CLASS: CApplicationView
//
class CApplicationView : public CAdminView
{
friend class CRightPane;
friend class CAdminPage;

private:
	CTabCtrl*	m_pTabs;
	CFont*      m_pTabFont;

	int m_CurrPage;
	CPublishedApp *m_pApplication;

protected:
	CApplicationView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CApplicationView)

// Attributes
public:

protected:
	static PageDef pages[NUMBER_OF_APP_PAGES];

// Operations
protected:
	void Reset(void *pApplication);

	void AddTab(int index, TCHAR* text);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CApplicationView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CApplicationView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CApplicationView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT OnChangePage(WPARAM wParam, LPARAM lParam);
	afx_msg void OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg LRESULT OnAdminUpdateWinStations(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateServerInfo(WPARAM, LPARAM);
	afx_msg LRESULT OnExtAddAppServer(WPARAM, LPARAM);
	afx_msg LRESULT OnExtRemoveAppServer(WPARAM, LPARAM);
	afx_msg LRESULT OnExtAppChanged(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CApplicationView

#endif  // _APPLICATIONVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\apptree.cpp ===
/*******************************************************************************
*
* apptree.cpp
*
* implementation of the CAppTreeView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\apptree.cpp  $
*  
*     Rev 1.2   16 Feb 1998 16:00:06   donm
*  modifications to support pICAsso extension
*  
*     Rev 1.1   03 Nov 1997 15:21:24   donm
*  update
*  
*     Rev 1.0   13 Oct 1997 22:31:20   donm
*  Initial revision.
*  
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "admindoc.h"
#include "apptree.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////
// MESSAGE MAP: CAppTreeView
//
IMPLEMENT_DYNCREATE(CAppTreeView, CBaseTreeView)

BEGIN_MESSAGE_MAP(CAppTreeView, CBaseTreeView)
	//{{AFX_MSG_MAP(CAppTreeView)
	ON_MESSAGE(WM_EXT_ADD_APPLICATION, OnExtAddApplication)
	ON_MESSAGE(WM_EXT_REMOVE_APPLICATION, OnExtRemoveApplication)
	ON_MESSAGE(WM_EXT_APP_CHANGED, OnExtAppChanged)
	ON_MESSAGE(WM_EXT_ADD_APP_SERVER, OnExtAddAppServer)
	ON_MESSAGE(WM_EXT_REMOVE_APP_SERVER, OnExtRemoveAppServer)
	ON_MESSAGE(WM_ADMIN_VIEWS_READY, OnAdminViewsReady)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER, OnAdminUpdateServer)
	ON_MESSAGE(WM_ADMIN_ADD_WINSTATION, OnAdminAddWinStation)
	ON_MESSAGE(WM_ADMIN_REMOVE_WINSTATION, OnAdminRemoveWinStation)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATION, OnAdminUpdateWinStation)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(NM_RCLICK, AFX_IDW_PANE_FIRST, OnRClick)
	ON_NOTIFY(NM_RCLICK, 1, OnRClick)
	ON_WM_LBUTTONDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////
// CAppTreeView ctor
//
CAppTreeView::CAppTreeView()
{

}  // end CAppTreeView ctor


//////////////////////////
// CAppTreeView dtor
//
CAppTreeView::~CAppTreeView()
{

}  // end CAppTreeView dtor


#ifdef _DEBUG
//////////////////////////////////
// CAppTreeView::AssertValid
//
void CAppTreeView::AssertValid() const
{
	CBaseTreeView::AssertValid();	  

}  // end CAppTreeView::AssertValid


///////////////////////////
// CAppTreeView::Dump
//
void CAppTreeView::Dump(CDumpContext& dc) const
{
	CBaseTreeView::Dump(dc);

}  // end CAppTreeView::Dump
#endif


/////////////////////////////////////
// CAppTreeView::BuildImageList
//
// - calls m_imageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the CTreeCtrl
//
void CAppTreeView::BuildImageList()
{
	m_ImageList.Create(16, 16, TRUE, 7, 0);

	m_idxApps = AddIconToImageList(IDI_APPS);
	m_idxGenericApp = AddIconToImageList(IDI_GENERIC_APP);
	m_idxServer = AddIconToImageList(IDI_SERVER);
	m_idxNotSign = AddIconToImageList(IDI_NOTSIGN);
	m_idxQuestion = AddIconToImageList(IDI_QUESTIONMARK);
	m_idxUser = AddIconToImageList(IDI_USER);
	m_idxCurrentServer = AddIconToImageList(IDI_CURRENT_SERVER);
	m_idxCurrentUser = AddIconToImageList(IDI_CURRENT_USER);
	m_idxServerNotConnected = AddIconToImageList(IDI_SERVER_NOT_CONNECTED);

	// Overlay for Servers we can't talk to
	m_ImageList.SetOverlayImage(m_idxNotSign, 1);
	// Overlay for Servers we are currently gathering information about
	m_ImageList.SetOverlayImage(m_idxQuestion, 2);

	GetTreeCtrl().SetImageList(&m_ImageList, TVSIL_NORMAL);

}  // end CAppTreeView::BuildImageList


//////////////////////////////////
// CAppTreeView::OnAdminViewsReady
//
LRESULT CAppTreeView::OnAdminViewsReady(WPARAM wParam, LPARAM lParam)
{
	LockTreeControl();

	// Get a pointer to our document
	CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();

	// add the root to the tree
	CString citrix;
	citrix.LoadString(IDS_PUBLISHED_APPS);
	CTreeNode* pRootNode = new CTreeNode(NODE_PUBLISHED_APPS, NULL);
    if(pRootNode) {
	    HTREEITEM hRoot = AddItemToTree(NULL, citrix, TVI_ROOT, m_idxApps, (DWORD)pRootNode);
	    if(!hRoot) delete pRootNode;
    }

    UnlockTreeControl();

	return 0;

}  // end CAppTreeView::OnAdminViewsReady


////////////////////////////////
// CAppTreeView::OnExtAddApplication
//
//	Message Handler to add a published application to the tree
//	Pointer to ExtAddTreeNode is in wParam
//	Pointer to CPublishedApp is in lParam
//
LRESULT CAppTreeView::OnExtAddApplication(WPARAM wParam, LPARAM lParam)
{      
	LockTreeControl();

	ExtAddTreeNode *pExtAddTreeNode = (ExtAddTreeNode*)wParam;

	// First make sure the application isn't already in the tree
	HTREEITEM hRoot = GetTreeCtrl().GetRootItem();
	// Get the first application
	HTREEITEM hItem = GetTreeCtrl().GetNextItem(hRoot, TVGN_CHILD);
	while(hItem) {
		// Get the data attached to the tree item
		CTreeNode *node = (CTreeNode*)GetTreeCtrl().GetItemData(hItem);
		// Is this the application we want to add?
		if((CObject*)node->GetTreeObject() == pExtAddTreeNode->pObject) return 0;
		hItem = GetTreeCtrl().GetNextItem(hItem, TVGN_NEXT);
	}

	// Add the published application to the tree
	// Create a CTreeNode object with info about this tree node
	CTreeNode* pNode = new CTreeNode(NODE_APPLICATION, pExtAddTreeNode->pObject);
    if(pNode) {
	    HTREEITEM hApplication = AddItemToTree(hRoot, pExtAddTreeNode->Name, TVI_SORT,
		    m_idxGenericApp, (DWORD)pNode);

	    if(!hApplication) delete pNode;

		if(!((CPublishedApp*)pExtAddTreeNode->pObject)->IsState(PAS_GOOD))
			GetTreeCtrl().SetItemState(hApplication, STATE_QUESTION, 0x0F00);

		((CPublishedApp*)pExtAddTreeNode->pObject)->SetTreeItem(hApplication);
    }

   	UnlockTreeControl();

	return 0;                                                                  
                                                                               
}  // end CAppTreeView::OnExtAddApplication


////////////////////////////////
// CAppTreeView::OnExtRemoveApplication
//
//	Message Handler to remove a published application from the tree
//	Pointer to CPublishedApp is in lParam
//
LRESULT CAppTreeView::OnExtRemoveApplication(WPARAM wParam, LPARAM lParam)
{      
	ASSERT(lParam);

	CPublishedApp *pApplication = (CPublishedApp*)lParam;

	HTREEITEM hApplication = pApplication->GetTreeItem();
	if(!hApplication) return 0;

	LockTreeControl();

	// Get the data attached to this tree node
	CTreeNode *node = (CTreeNode*)GetTreeCtrl().GetItemData(hApplication);
    if(node) {
	    // Is this the application we want to remove
	    CPublishedApp *pTreeApp = (CPublishedApp*)node->GetTreeObject();
	    // Make sure the tree node is correct
	    if(pTreeApp != pApplication) {
			UnlockTreeControl();
			return 0;
		}
    }
    else {
		UnlockTreeControl();
		return 0;
	}

	// Loop through it's children and delete their data
	HTREEITEM hAppServer = GetTreeCtrl().GetNextItem(hApplication, TVGN_CHILD);
	while(hAppServer) {
		CTreeNode *pTreeNode = (CTreeNode*)GetTreeCtrl().GetItemData(hAppServer);
        if(pTreeNode) {
		    delete pTreeNode;
        }
		// Loop through the users nodes under the AppServer in the tree
		HTREEITEM hUser = GetTreeCtrl().GetNextItem(hAppServer, TVGN_CHILD);
		while(hUser) {
			CTreeNode *pTreeNode = (CTreeNode*)GetTreeCtrl().GetItemData(hUser);
		    if(pTreeNode) {
				CWinStation *pWinStation = (CWinStation*)pTreeNode->GetTreeObject();
				if(pWinStation) 
					pWinStation->SetAppTreeItem(NULL);
				delete pTreeNode;
			}					
		}

		hAppServer = GetTreeCtrl().GetNextItem(hAppServer, TVGN_NEXT);
	}

	// Delete the data attached to the tree item
	delete node;
	// Let the application know he is no longer in the tree
	pApplication->SetTreeItem(NULL);
	// Remove the application from the tree
	// This SHOULD remove all it's children
	GetTreeCtrl().DeleteItem(hApplication);
		
	UnlockTreeControl();

	return 0;                                                                  
                                                                               
}  // end CAppTreeView::OnExtRemoveApplication


/////////////////////////////////////////
// CAppTreeView::OnExtAppChanged
//
LRESULT CAppTreeView::OnExtAppChanged(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	// we only care if it is a state change
	if(wParam & ACF_STATE) {
		
		CPublishedApp *pApplication = (CPublishedApp*)lParam;
	
		HTREEITEM hApplication = pApplication->GetTreeItem();
		if(!hApplication) return 0;

		LockTreeControl();

		// Get the data attached to this tree node
		CTreeNode *node = (CTreeNode*)GetTreeCtrl().GetItemData(hApplication);
		if(node) {
			// Is this the app we want to update?
			CPublishedApp *pTreeApp = (CPublishedApp*)node->GetTreeObject();
			// Make sure the tree node is correct
			if(pTreeApp != pApplication) {
				UnlockTreeControl();
				return 0;
			}
		} else {
			UnlockTreeControl();
			return 0;
		}

		USHORT NewState;
		// Remember the previous state
		USHORT PreviousState = GetTreeCtrl().GetItemState(hApplication, 0x0F00);
		// Change the icon/overlay for the app
		// If we aren't done getting all the information about this app,
		// put a question mark over the icon
		if(pApplication->IsState(PAS_GETTING_INFORMATION)) NewState = STATE_QUESTION;
		// If it is fine, we want to remove any overlays from the icon
		else NewState = STATE_NORMAL;

		// Set the tree item to the new state
		GetTreeCtrl().SetItemState(hApplication, NewState, 0x0F00);
	}

	return 0;

}	// end CAppTreeView::OnExtAppChanged


/////////////////////////////////////////
// CAppTreeView::DetermineServerIcon
//
//	determines which icon to display for a Server
//	in the tree
//
int CAppTreeView::DetermineServerIcon(CServer *pServer)
{
    if(!pServer) return m_idxServerNotConnected;

	int WhichIcon = m_idxServer;
	
	// Is this the current server?
	if(pServer->IsCurrentServer()) {
		if(pServer->IsState(SS_NONE) || pServer->IsState(SS_NOT_CONNECTED))
			WhichIcon = m_idxServerNotConnected;
		else
			WhichIcon = m_idxCurrentServer;
	} else {  // not the current server
		if(pServer->IsState(SS_NONE) || pServer->IsState(SS_NOT_CONNECTED))
			WhichIcon = m_idxServerNotConnected;
	}
			
	return WhichIcon;

}  // end CAooTreeView::DetermineServerIcon


////////////////////////////////
// CAppTreeView::OnExtAddAppServer
//
//	Message Handler to add a server beneath a published application
//	Pointer to ExtAddTreeNode is in wParam
//	Pointer to CAppServer is in lParam
//
LRESULT CAppTreeView::OnExtAddAppServer(WPARAM wParam, LPARAM lParam)
{      
	ExtAddTreeNode *pExtAddTreeNode = (ExtAddTreeNode*)wParam;

	HTREEITEM hParent = pExtAddTreeNode->hParent;
	if(!hParent) return 0;

	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
	CServer *pServer = pDoc->FindServerByName(pExtAddTreeNode->Name);

    LockTreeControl();
	CTreeCtrl &tree = GetTreeCtrl();

	// First make sure the server isn't already in the tree
	// Get the first server under the application
	HTREEITEM hItem = tree.GetNextItem(hParent, TVGN_CHILD);
	while(hItem) {
		// Get the data attached to the tree item
		CTreeNode *node = (CTreeNode*)tree.GetItemData(hItem);
        if(node) {
		    // Is this the server we want to add
		    CAppServer *pAppServer = (CAppServer*)node->GetTreeObject();
		    if(pAppServer == (CAppServer*)pExtAddTreeNode->pObject) {
				UnlockTreeControl();
				return 0;
			}
        }
		hItem = tree.GetNextItem(hItem, TVGN_NEXT);
	}

	CTreeNode* pNode = new CTreeNode(NODE_APP_SERVER, pExtAddTreeNode->pObject);
    if(pNode) {

	    HTREEITEM hServer = AddItemToTree(hParent, pExtAddTreeNode->Name, TVI_SORT,
											DetermineServerIcon(pServer), (DWORD)pNode);
	    if(!hServer) delete pNode;
		((CAppServer*)pExtAddTreeNode->pObject)->SetTreeItem(hServer);
		
		if(pServer) {
			// If the server isn't sane, put a not sign over the icon
			if(!pServer->IsServerSane()) tree.SetItemState(hServer, STATE_NOT, 0x0F00);
			// If we aren't done getting all the information about this server,
			// put a question mark over the icon
			else if(pServer->IsState(SS_GETTING_INFO)) tree.SetItemState(hServer, STATE_QUESTION, 0x0F00);
		}

    }

    UnlockTreeControl();
	return 0;	

}	// end CAppTreeView::OnExtAddAppServer


////////////////////////////////
// CAppTreeView::OnExtRemoveAppServer
//
//	Message Handler to remove a server from beneath a published application
//	Pointer to CPublishedApp is in wParam
//	Pointer to CAppServer is in lParam
//
LRESULT CAppTreeView::OnExtRemoveAppServer(WPARAM wParam, LPARAM lParam)
{      
	ASSERT(wParam);
	ASSERT(lParam);

	HTREEITEM hServer = ((CAppServer*)lParam)->GetTreeItem();
	if(!hServer) return 0;

    LockTreeControl();
	CTreeCtrl &tree = GetTreeCtrl();

	CTreeNode *ServerNode = (CTreeNode*)tree.GetItemData(hServer);

	// Remove the Users underneath this server in the tree
	HTREEITEM hUser = tree.GetNextItem(hServer, TVGN_CHILD);
	while(hUser) {
		// Get the data attached to the tree item
		CTreeNode *node = (CTreeNode*)tree.GetItemData(hUser);
        if(node) {
			CWinStation *pWinStation = (CWinStation*)node->GetTreeObject();
			pWinStation->SetAppTreeItem(NULL);
			delete node;
		}					
	
		hUser = tree.GetNextItem(hUser, TVGN_NEXT);
	}

	// Delete the data attached to the tree item
	delete ServerNode;
	// Let the AppServer know he is no longer in the tree
	((CAppServer*)lParam)->SetTreeItem(NULL);
	// Remove the AppServer from the tree
	// This SHOULD remove all it's children
	GetTreeCtrl().DeleteItem(hServer);

    UnlockTreeControl();
	return 0;	

}	// end CAppTreeView::OnExtRemoveAppServer


/////////////////////////////////////////
// CAppTreeView::AddServerChildren
//
//	Adds the Users running the published app on a given Server
//	to the tree
//
void CAppTreeView::AddServerChildren(HTREEITEM hServer, CServer *pServer)
{
    ASSERT(hServer);
    ASSERT(pServer);

	if(pServer->IsServerSane()) {

		LockTreeControl();
		
		HTREEITEM hParent = GetTreeCtrl().GetParentItem(hServer);

		HTREEITEM hLastNode = hServer;

		CTreeNode *pParentNode = (CTreeNode*)GetTreeCtrl().GetItemData(hParent);
		CPublishedApp *pApplication = (CPublishedApp*)pParentNode->GetTreeObject();

		pServer->LockWinStationList();
		// Get a pointer to the server's list of WinStations
		CObList *pWinStationList = pServer->GetWinStationList();

		// Iterate through the WinStation list
		POSITION pos = pWinStationList->GetHeadPosition();

		while(pos) {
			CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

			// We only care if the user is running this published app
			if(pWinStation->GetState() == State_Active
				&& pWinStation->HasUser()
				&& pWinStation->IsRunningPublishedApp()
				&& pWinStation->IsRunningPublishedApp(pApplication->GetName())) {

				// Figure out what text to display
				CString UserString;
				if(wcslen(pWinStation->GetUserName())) {
					UserString.Format(TEXT("%s (%s)"), pWinStation->GetName(), pWinStation->GetUserName());
				}
				else UserString.Format(TEXT("%s"), pWinStation->GetName());
								
				CTreeNode *pNode = new CTreeNode(NODE_WINSTATION, pWinStation);
				if(pNode) {
				    pNode->SetSortOrder(pWinStation->GetSortOrder());
					hLastNode = AddItemToTree(hServer, UserString, TVI_SORT,
						pWinStation->IsCurrentUser() ? m_idxCurrentUser : m_idxUser, (DWORD)pNode);
				    if(!hLastNode) delete pNode;
				}
	
				// The WinStation wants to know his tree item handle
				pWinStation->SetAppTreeItem(hLastNode);
			}
		}

		pServer->UnlockWinStationList();

		UnlockTreeControl();

	}  // end if(pServer->IsServerSane())


}  // end CAppTreeView::AddServerChildren


////////////////////////////////
// CAppTreeView::OnAdminUpdateServer
//
//	Message handler to update a Server in the tree
//	Pointer to CServer to update is in lParam
//
LRESULT CAppTreeView::OnAdminUpdateServer(WPARAM wParam, LPARAM lParam)
{      
	ASSERT(lParam);

	CServer *pServer = (CServer*)lParam;
    if(!pServer) return 0;

	LockTreeControl();

	// The server can be in the tree more than one place
	UINT itemCount = GetTreeCtrl().GetCount();

	HTREEITEM hTreeItem = GetTreeCtrl().GetRootItem();
	for(UINT i = 0; i < itemCount; i++)  {
		CTreeNode *node = ((CTreeNode*)GetTreeCtrl().GetItemData(hTreeItem));
		if(node) {
			// we only care about app servers
			if(node->GetNodeType() == NODE_APP_SERVER) {
				CAppServer *pAppServer = (CAppServer*)node->GetTreeObject();
				// Is it the same server?
				if(0 == wcscmp(pAppServer->GetName(), pServer->GetName())) {
					USHORT NewState;
					// Remember the previous state
					USHORT PreviousState = GetTreeCtrl().GetItemState(hTreeItem, 0x0F00);
					// Change the icon/overlay for the server
					// If the server isn't sane, put a not sign over the icon
					if(!pServer->IsServerSane()) NewState = STATE_NOT;
					// If we aren't done getting all the information about this server,
					// put a question mark over the icon
					else if(pServer->IsState(SS_GETTING_INFO)) NewState = STATE_QUESTION;
					// If it is fine, we want to remove any overlays from the icon
					else NewState = STATE_NORMAL;

					// Set the tree item to the new state
					GetTreeCtrl().SetItemState(hTreeItem, NewState, 0x0F00);

					// If this Server was not opened and now is GOOD,
					// add it's children to the tree
					if(PreviousState != STATE_NORMAL && pServer->IsState(SS_GOOD)) {
						int ServerIcon = DetermineServerIcon(pServer);
						GetTreeCtrl().SetItemImage(hTreeItem, ServerIcon, ServerIcon);
						AddServerChildren(hTreeItem, pServer);
					}
					else if(pServer->GetPreviousState() == SS_DISCONNECTING && pServer->IsState(SS_NOT_CONNECTED)) {
						int ServerIcon = DetermineServerIcon(pServer);
						GetTreeCtrl().SetItemImage(hTreeItem, ServerIcon, ServerIcon);
					}

					// If we changed the state of this server and it is the currently
					// selected node in the tree, we need to send a message to change
					// the view
					// We also need to make sure this is the currently selected tree
					CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
					if(NewState != PreviousState && hTreeItem == GetTreeCtrl().GetSelectedItem()
							&& pDoc->GetCurrentTree() == TREEVIEW_APPS) {
#if 0
						LONG Result;
						OnSelChange(NULL, &Result);
#endif
						ForceSelChange();
					}				
				}
			}
		}
		hTreeItem = GetNextItem(hTreeItem);
	}

	UnlockTreeControl();

    return 0;                                                                  
                                                                               
}  // end CAppTreeView::OnAdminUpdateServer


////////////////////////////////
// CAppTreeView::AddUser
//
HTREEITEM CAppTreeView::AddUser(CWinStation *pWinStation)
{
	ASSERT(pWinStation);

	HTREEITEM hWinStation = NULL;

	// Find the published app that this WinStation is running in our tree
	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
	CPublishedApp *pApplication = pDoc->FindPublishedAppByName(pWinStation->GetPublishedAppName());
	CServer *pServer = pWinStation->GetServer();

	if(!pApplication) return NULL;

	HTREEITEM hApplication = pApplication->GetTreeItem();
	if(!hApplication) return NULL;

	CTreeCtrl &tree = LockTreeControl();

	// Find this WinStation's server under the published application in the tree
	HTREEITEM hServer = NULL;

	hServer = tree.GetChildItem(hApplication);   

	while(hServer) {
		CTreeNode *pNode = (CTreeNode*)GetTreeCtrl().GetItemData(hServer);
		CAppServer *pAppServer = (CAppServer*)pNode->GetTreeObject();
		if(0 == wcscmp(pAppServer->GetName(), pServer->GetName())) {
			// Figure out what text to display
			CString UserString;
			if(wcslen(pWinStation->GetUserName())) {
				UserString.Format(TEXT("%s (%s)"), pWinStation->GetName(), pWinStation->GetUserName());
			}
			else UserString.Format(TEXT("%s"), pWinStation->GetName());
								
			CTreeNode *pNewNode = new CTreeNode(NODE_WINSTATION, pWinStation);
			if(pNewNode) {    
				hWinStation = AddItemToTree(hServer, UserString, TVI_SORT,
					pWinStation->IsCurrentUser() ? m_idxCurrentUser : m_idxUser, (DWORD)pNewNode);
				if(!hWinStation) delete pNewNode;
				// The WinStation wants to know his tree item handle
				pWinStation->SetAppTreeItem(hWinStation);
			}	
		}

		hServer = tree.GetNextSiblingItem(hServer);
	}

	UnlockTreeControl();

	return hWinStation;

}


////////////////////////////////
// CAppTreeView::OnAdminAddWinStation
//
//	Message handler to add a WinStation to the tree
//	lParam = pointer to CWinStation to add
//	wParam is TRUE if this is replacing a WinStation that was currently selected
//
LRESULT CAppTreeView::OnAdminAddWinStation(WPARAM wParam, LPARAM lParam)
{   
	ASSERT(lParam);

	CWinStation *pWinStation = (CWinStation*)lParam;
    if(!pWinStation) return 0;

	// If this WinStation isn't running a published App, we
	// don't give a damn
	if(!pWinStation->IsState(State_Active) || !pWinStation->IsRunningPublishedApp())
		return 0;

	AddUser(pWinStation);

	return 0;

}  // end CAppTreeView::OnAdminAddWinStation


////////////////////////////////
// CAppTreeView::OnAdminUpdateWinStation
//
//	Message handler to update a WinStation in the tree
//	lParam = pointer to CWinStation to update
//
LRESULT CAppTreeView::OnAdminUpdateWinStation(WPARAM wParam, LPARAM lParam)
{      
	ASSERT(lParam);

	CWinStation *pWinStation = (CWinStation*)lParam;
    if(!pWinStation) return 0;

	// If this WinStation isn't running a published App, we
	// don't give a damn
	if(!pWinStation->IsState(State_Active) || !pWinStation->IsRunningPublishedApp())
		return 0;

	// If this WinStation is already in the tree, we don't want to
	// add it again
	if(pWinStation->GetAppTreeItem())
		return 0;

	AddUser(pWinStation);

	return 0;

}  // end CAppTreeView::OnAdminUpdateWinStation


////////////////////////////////
// CAppTreeView::OnAdminRemoveWinStation
//
//	Message handler to remove a WinStation from the tree
//	lParam = pointer to CWinStation to remove
LRESULT CAppTreeView::OnAdminRemoveWinStation(WPARAM wParam, LPARAM lParam)
{   
	ASSERT(lParam);

	BOOL CurrentInTree = FALSE;
	
	CWinStation *pWinStation = (CWinStation*)lParam;
    if(!pWinStation) return 0;

	HTREEITEM hWinStation = pWinStation->GetAppTreeItem();
	if(!hWinStation) return 0;

	LockTreeControl();

	// Get the data attached to this tree node
	CTreeNode *node = (CTreeNode*)GetTreeCtrl().GetItemData(hWinStation);
    if(node) {
	    // Is this the WinStation we want to update
	    CWinStation *pTreeWinStation = (CWinStation*)node->GetTreeObject();
	    // Make sure the tree node is correct
	    if(pTreeWinStation != pWinStation) {
			UnlockTreeControl();
			return 0;
		}
    } else {
		UnlockTreeControl();
		return 0;
	}

	// Delete the data attached to the tree item
	delete node;
	// Let the WinStation know he is no longer in the tree
	pWinStation->SetAppTreeItem(NULL);
	// Is this WinStation currently selected in the tree?
	CurrentInTree = (GetTreeCtrl().GetSelectedItem() == hWinStation);
	// Remove the WinStation from the tree
	GetTreeCtrl().DeleteItem(hWinStation);

	// If this WinStation is the currently selected node in the tree,
	// make it not so
	// This may not be necessary!
	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
	if(CurrentInTree && pDoc->GetCurrentTree() == TREEVIEW_APPS)
		((CWinAdminDoc*)GetDocument())->SetCurrentView(VIEW_CHANGING);

	UnlockTreeControl();

	return 0;

}  // end CAppTreeView::OnAdminRemoveWinStation


////////////////////////////////
// CAppTreeView::OnContextMenu
//
//	Message handler called when user wants a context menu
//	This happens when the user clicks the right mouse button,
//	presses Shift-F10, or presses the menu key on a Windows keyboard
//
void CAppTreeView::OnContextMenu(CWnd* pWnd, CPoint ptScreen) 
{
	CTreeCtrl &tree = GetTreeCtrl();

	UINT flags;
	HTREEITEM hItem;
	CPoint ptClient = ptScreen;
	ScreenToClient(&ptClient);

	// If we got here from the keyboard,
	if(ptScreen.x == -1 && ptScreen.y == -1) {
		hItem = tree.GetSelectedItem();
		RECT rect;
		tree.GetItemRect(hItem, &rect, 0);
		ptScreen.x = rect.left + (rect.right - rect.left)/2;
		ptScreen.y = rect.top + (rect.bottom - rect.top)/2;
		ClientToScreen(&ptScreen);
	}
	else {
		hItem = tree.HitTest(ptClient, &flags);
		if((NULL == hItem) || !(TVHT_ONITEM & flags))
			return;
	}

	// Pop-up the menu
	CTreeNode *pNode = (CTreeNode*)tree.GetItemData(hItem);
	CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();
	pDoc->SetTreeTemp(pNode->GetTreeObject(), (pNode->GetNodeType()));

	if(pNode) {
		CMenu menu;
		UINT nIDResource = 0;

		switch(pNode->GetNodeType()) {
			case NODE_APP_SERVER:
				{
				CAppServer *pAppServer = (CAppServer*)pNode->GetTreeObject();
				CServer *pServer = ((CWinAdminDoc*)GetDocument())->FindServerByName(pAppServer->GetName());
				if(pServer) {
					pDoc->SetTreeTemp(pServer, NODE_SERVER);
				} else return;
				nIDResource = IDR_SERVER_POPUP;
				}
				break;

			case NODE_WINSTATION:
				nIDResource = IDR_WINSTATION_TREE_POPUP;
				break;
		}

		if(nIDResource) {
			if(menu.LoadMenu(nIDResource)) {
				menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
						TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
			}
		}

	} // end if(pNode)

} // end CAppTreeView::OnContextMenu


////////////////////////////////
// CAppTreeView::OnRClick
//
// The Tree Common Control sends a WM_NOTIFY of NM_RCLICK when
// the user presses the right mouse button in the tree
//
void CAppTreeView::OnRClick(NMHDR* pNMHDR, LRESULT* pResult)
{
	CPoint ptScreen(::GetMessagePos());

	LockTreeControl();

	// Get a pointer to our document
	CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();

	CTreeCtrl &tree = GetTreeCtrl();

	UINT flags;
	HTREEITEM hItem;
	CPoint ptClient = ptScreen;
	ScreenToClient(&ptClient);

	hItem = tree.HitTest(ptClient, &flags);
	if((NULL == hItem) || !(TVHT_ONITEM & flags)) {
		UnlockTreeControl();
		return;
	}

	// Pop-up the menu
	CTreeNode *pNode = (CTreeNode*)tree.GetItemData(hItem);
	CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();
	pDoc->SetTreeTemp(pNode->GetTreeObject(), (pNode->GetNodeType()));

	if(pNode) {
		CMenu menu;
		UINT nIDResource = 0;

		switch(pNode->GetNodeType()) {
			case NODE_APP_SERVER:
				{
				CAppServer *pAppServer = (CAppServer*)pNode->GetTreeObject();
				CServer *pServer = ((CWinAdminDoc*)GetDocument())->FindServerByName(pAppServer->GetName());
				if(pServer) {
					pDoc->SetTreeTemp(pServer, NODE_SERVER);
				} else return;
				nIDResource = IDR_SERVER_POPUP;
				}
				break;

			case NODE_WINSTATION:
				nIDResource = IDR_WINSTATION_TREE_POPUP;
				break;
		}

		if(nIDResource) {
			if(menu.LoadMenu(nIDResource)) {
				menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
						TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
			}
		}

	} // end if(pNode)

	UnlockTreeControl();

}	// end CAppTreeView::OnRClick


////////////////////////////////
// CAppTreeView::OnLButtonDown
//
void CAppTreeView::OnLButtonDown(UINT nFlags, CPoint ptClient) 
{
	// Figure out what they clicked on
	LockTreeControl();

	CTreeCtrl &tree = GetTreeCtrl();

	UINT flags;
	HTREEITEM hItem;

	hItem = tree.HitTest(ptClient, &flags);
	if((NULL == hItem) || !(TVHT_ONITEM & flags)) {
		UnlockTreeControl();
		CTreeView::OnLButtonDown(nFlags, ptClient);
		return;
	}

	// We only care about servers
	CTreeNode *pNode = (CTreeNode*)tree.GetItemData(hItem);
	if(pNode && pNode->GetNodeType() == NODE_APP_SERVER) {
		// Is it the same item as is selected
		if(hItem == tree.GetSelectedItem()) {
			CAppServer *pAppServer = (CAppServer*)pNode->GetTreeObject();
			CServer *pServer = ((CWinAdminDoc*)GetDocument())->FindServerByName(pAppServer->GetName());
			// Is this server in the "just disconnected" state			
			// If both previous state and state are SS_NOT_CONNECTED,
			// we know the user just disconnected from this server
			if(pServer && pServer->IsState(SS_NOT_CONNECTED)) {
				UnlockTreeControl();
				LONG Result;
				OnSelChange(NULL, &Result);
				return;
			}
		}
	}
	
	UnlockTreeControl();

	CTreeView::OnLButtonDown(nFlags, ptClient);
	
} // CAppTreeView::OnLButtonDown
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\apptree.h ===
/*******************************************************************************
*
* apptree.h
*
* - declarations for the CAppTreeView class
* - the CAppTreeView class lives in the left pane of the mainframe's splitter
* - derived from CBaseTreeView
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\apptree.h  $
*  
*     Rev 1.1   16 Feb 1998 16:00:22   donm
*  modifications to support pICAsso extension
*  
*     Rev 1.0   13 Oct 1997 22:32:52   donm
*  Initial revision.
*  
*******************************************************************************/

#ifndef _APPTREE_H
#define _APPTREE_H

#include "afxcview.h"
#include "basetree.h"

///////////////////////
// CLASS: CAppTreeView
//
class CAppTreeView : public CBaseTreeView
{
friend class CTreeTabCtrl;
friend class CLeftPane;

protected:
	CAppTreeView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAppTreeView)

// Attributes
protected:
	int m_idxApps;					// index of Apps icon image
	int m_idxGenericApp;			// index of Generic Application icon image
	int m_idxServer;				// index of Server icon image 
	int m_idxNotSign;				// index of Not Sign overlay (for non-sane servers)
	int m_idxQuestion;				// index of Question Mark overlay (for non-opened servers)
	int m_idxUser;					// index of User icon image
	int m_idxCurrentServer;			// index of Current Server image
	int m_idxCurrentUser;			// index of Current User image
	int m_idxServerNotConnected;	// index of Server Not Connected image

// Operations
public:

protected:
	int DetermineServerIcon(CServer *pServer);

private:
	// Builds the image list
	virtual void BuildImageList();			
	
	// Add the Users attached to a particular Server running that app
	void AddServerChildren(HTREEITEM hServer, CServer *pServer);
	// Adds a single user to the tree
	HTREEITEM AddUser(CWinStation *pWinStation);


	// Add the Servers configured for a published app
//	void AddApplicationServers(HTREEITEM hApplication, CPublishedApp *pPublishedApp);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAppTreeView)
	public:
//	virtual void OnInitialUpdate();
	protected:
//	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
//	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAppTreeView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CAppTreeView)
	afx_msg LRESULT OnExtAddApplication(WPARAM, LPARAM);
	afx_msg LRESULT OnExtRemoveApplication(WPARAM, LPARAM);
	afx_msg LRESULT OnExtAppChanged(WPARAM, LPARAM);
	afx_msg LRESULT OnExtAddAppServer(WPARAM, LPARAM);
	afx_msg LRESULT OnExtRemoveAppServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminViewsReady(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateWinStation(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminAddWinStation(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRemoveWinStation(WPARAM, LPARAM);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnRClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAppTreeView

#endif  // _APPTREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\badsrvvw.cpp ===
/*******************************************************************************
*
* badsrvvw.cpp
*
* implementation of the CBadServerView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\BADSRVVW.CPP  $
*  
*     Rev 1.0   30 Jul 1997 17:10:58   butchd
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "badsrvvw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// badboy

IMPLEMENT_DYNCREATE(CBadServerView, CFormView)

CBadServerView::CBadServerView()
	: CFormView(CBadServerView::IDD)
{
	//{{AFX_DATA_INIT(CBadServerView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CBadServerView::~CBadServerView()
{
}

void CBadServerView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBadServerView)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBadServerView, CFormView)
	//{{AFX_MSG_MAP(CBadServerView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBadServerView diagnostics

#ifdef _DEBUG
void CBadServerView::AssertValid() const
{
	CFormView::AssertValid();
}

void CBadServerView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CBadServerView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\badsrvvw.h ===
/*******************************************************************************
*
* badsrvvw.h
*
* declarations for the CBadServerView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\BADSRVVW.H  $
*  
*     Rev 1.0   30 Jul 1997 17:11:00   butchd
*  Initial revision.
*
*******************************************************************************/

/////////////////////////////////////////////////////////////////////////////
// CBadServerView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CBadServerView : public CFormView
{
friend class CRightPane;

protected:
	CBadServerView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CBadServerView)

// Form Data
public:
	//{{AFX_DATA(CBadServerView)
	enum { IDD = IDD_BAD_SERVER };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBadServerView)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CBadServerView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CBadServerView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\blankvw.cpp ===
/*******************************************************************************
*
* blankvw.cpp
*
* implementation of the CBlankView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\BLANKVW.CPP  $
*  
*     Rev 1.0   30 Jul 1997 17:11:04   butchd
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "blankvw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////////////
// MESSAGE MAP: CBlankView
//
IMPLEMENT_DYNCREATE(CBlankView, CView)

BEGIN_MESSAGE_MAP(CBlankView, CView)
	//{{AFX_MSG_MAP(CBlankView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////
// F'N: CBlankView ctor
//
// - the m_id member var has no implicit meaning; it's just a place
//   to stick a number if you want to show a CBlankView someplace
//   and want a little clue as to who caused it to appear or something
//
CBlankView::CBlankView()
{


}  // end CBlankView ctor


/////////////////////////
// F'N: CBlankView dtor
//
CBlankView::~CBlankView()
{
}  // end CBlankView dtor


#ifdef _DEBUG
/////////////////////////////////
// F'N: CBlankView::AssertValid
//
void CBlankView::AssertValid() const
{
	CView::AssertValid();

}  // end CBlankView::AssertValid


//////////////////////////
// F'N: CBlankView::Dump
//
void CBlankView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CBlankView::Dump

#endif //_DEBUG


////////////////////////////
// F'N: CBlankView::OnDraw
//
// - the text "CBlankView  ID #x" is always displayed in medium
//   gray in the center of the view, where 'x' is the current
//   value of m_id
//
void CBlankView::OnDraw(CDC* pDC) 
{
	CRect rect;
	GetClientRect(&rect);

	pDC->SetTextColor(RGB(160, 160, 160));
	pDC->SetBkMode(TRANSPARENT);

//	CString szTemp;
//	szTemp.Format("CBlankView  ID #%d", m_id);

//	pDC->DrawText(szTemp, -1, &rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);
	
}  // end CBlankView::OnDraw
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\blankvw.h ===
/*******************************************************************************
*
* blankvw.h
*
* - header for the CBlankView class
* - implementation can be found in blankvw.cpp
*
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\winadmin\VCS\blankvw.h  $
*  
*     Rev 1.1   13 Oct 1997 18:40:04   donm
*  update
*  
*     Rev 1.0   30 Jul 1997 17:11:08   butchd
*  Initial revision.
*
*******************************************************************************/

//////////////////////
// FILE: 
//
//
#ifndef _BLANKVIEW_H
#define _BLANKVIEW_H


//////////////////////
// CLASS: CBlankView
//
// - this class is just a utility view that i use to fill in
//   spaces until i write up better views for them, or to test
//   simple stuff (i.e print debugging info it the view)
//
class CBlankView : public CAdminView
{
friend class CRightPane;

protected:
	CBlankView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CBlankView)

// Attributes
protected:
	
// Operations
protected:
	void Reset(void) { };

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBlankView)
	protected:
	virtual void OnDraw(CDC* pDC);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CBlankView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    LRESULT OnTabbed( WPARAM , LPARAM ) 
    {return 0;}
	// Generated message map functions
protected:
	//{{AFX_MSG(CBlankView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CBlankView

#endif  // _BLANKVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\basetree.h ===
/*******************************************************************************
*
* basetree.h
*
* - declarations for the CBaseTreeView class
* - the CBaseTreeView class is the class which the tree views are
* - derived from.
* - derived from CTreeView
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\basetree.h  $
*  
*     Rev 1.4   19 Feb 1998 17:40:04   donm
*  removed latest extension DLL support
*  
*     Rev 1.2   19 Jan 1998 16:46:04   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.1   03 Nov 1997 15:23:08   donm
*  update
*  
*     Rev 1.0   13 Oct 1997 22:32:48   donm
*  Initial revision.
*  
*******************************************************************************/

#ifndef _BASETREE_H
#define _BASETREE_H

#include "afxcview.h"

///////////////////////
// CLASS: CBaseTreeView
//
class CBaseTreeView : public CTreeView
{
friend class CTreeTabCtrl;
friend class CLeftPane;

protected:
	CBaseTreeView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CBaseTreeView)

// Attributes
protected:
	CImageList m_ImageList;	   // image list associated with the tree control
	CCriticalSection m_TreeControlCriticalSection;

	BOOL m_bInitialExpand;	// we haven't done an initial Expand on the tree because
									// there aren't any nodes beneath the root

// Operations
public:

    HTREEITEM GetNextItem( HTREEITEM hItem);

protected:

	DWORD_PTR GetCurrentNode();
	// Adds an icon's image to the image list and returns the image's index
	int AddIconToImageList(int);	
	// Adds an item to the tree
	HTREEITEM AddItemToTree(HTREEITEM, CString, HTREEITEM, int, LPARAM);
	// Locks the tree control for exclusive use and returns a reference
	// to the tree control
	CTreeCtrl& LockTreeControl() { 
		m_TreeControlCriticalSection.Lock(); 
		return GetTreeCtrl();
	}
	// Unlocks the tree control
	void UnlockTreeControl() { m_TreeControlCriticalSection.Unlock(); }
	void ForceSelChange();
	
private:

	// Builds the image list
	virtual void BuildImageList();
	
	// Collapses a tree item 
	void Collapse(HTREEITEM hItem);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBaseTreeView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CBaseTreeView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CBaseTreeView)
	afx_msg LRESULT OnExpandAll(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnCollapseAll(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnCollapseToThirdLevel(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnCollapseToRootChildren(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveWinStation(WPARAM wParam, LPARAM lParam);
	afx_msg void OnSelChange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CBaseTreeView

#endif  // _BASETREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\basetree.cpp ===
/*******************************************************************************
*
* basetree.cpp
*
* implementation of the CBaseTreeView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\basetree.cpp  $
*
*     Rev 1.4   19 Feb 1998 17:39:58   donm
*  removed latest extension DLL support
*
*     Rev 1.2   19 Jan 1998 17:03:10   donm
*  new ui behavior for domains and servers
*
*     Rev 1.1   03 Nov 1997 15:21:28   donm
*  update
*
*     Rev 1.0   13 Oct 1997 22:31:30   donm
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "admindoc.h"
#include "basetree.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////
// MESSAGE MAP: CBaseTreeView
//
IMPLEMENT_DYNCREATE(CBaseTreeView, CTreeView)

BEGIN_MESSAGE_MAP(CBaseTreeView, CTreeView)
	//{{AFX_MSG_MAP(CBaseTreeView)
	ON_MESSAGE(WM_ADMIN_EXPANDALL, OnExpandAll)
	ON_MESSAGE(WM_ADMIN_COLLAPSEALL, OnCollapseAll)
	ON_MESSAGE(WM_ADMIN_COLLAPSETOSERVERS, OnCollapseToThirdLevel)
    ON_MESSAGE(WM_ADMIN_COLLAPSETODOMAINS, OnCollapseToRootChildren)
	ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelChange)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////
// F'N: CBaseTreeView ctor
//
CBaseTreeView::CBaseTreeView()
{
	m_bInitialExpand = FALSE;

}  // end CBaseTreeView ctor


//////////////////////////
// F'N: CBaseTreeView dtor
//
CBaseTreeView::~CBaseTreeView()
{

}  // end CBaseTreeView dtor


/////////////////////////////
// F'N: CBaseTreeView::OnDraw
//
void CBaseTreeView::OnDraw(CDC* pDC)
{
	CWinAdminDoc* pDoc = (CWinAdminDoc*)GetDocument();
	ASSERT(pDoc != NULL);
	ASSERT_VALID(pDoc);
}  // end CBaseTreeView::OnDraw


#ifdef _DEBUG
//////////////////////////////////
// F'N: CBaseTreeView::AssertValid
//
void CBaseTreeView::AssertValid() const
{
	CTreeView::AssertValid();	

}  // end CBaseTreeView::AssertValid


///////////////////////////
// F'N: CBaseTreeView::Dump
//
void CBaseTreeView::Dump(CDumpContext& dc) const
{
	CTreeView::Dump(dc);

}  // end CBaseTreeView::Dump
#endif

//////////////////////////////////////
// F'N: CBaseTreeView::PreCreateWindow
//
BOOL CBaseTreeView::PreCreateWindow(CREATESTRUCT& cs)
{
	// Set the style bits for the CTreeCtrl
	cs.style |= TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT | TVS_DISABLEDRAGDROP
		| TVS_SHOWSELALWAYS;
	
	return CTreeView::PreCreateWindow(cs);

}  // end CBaseTreeView::PreCreateWindow


/////////////////////////////////////
// F'N: CBaseTreeView::BuildImageList
//
void CBaseTreeView::BuildImageList()
{
	// do nothing

}  // end CBaseTreeView::BuildImageList


//////////////////////////////////////
// F'N: CBaseTreeView::OnInitialUpdate
//
// - constructs the image list for the tree, saving indices to each icon
//   in member variables (m_idxCitrix, m_idxServer, etc.)
//
void CBaseTreeView::OnInitialUpdate()
{
	CTreeView::OnInitialUpdate();

	// build the image list for the tree control
	BuildImageList();		
	
}  // end CBaseTreeView::OnInitialUpdate


/////////////////////////////////////////
// F'N: CBaseTreeView::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CBaseTreeView::AddIconToImageList(int iconID)
{
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
	return m_ImageList.Add(hIcon);

}  // end CBaseTreeView::AddIconToImageList


////////////////////////////////////
// F'N: CBaseTreeView::AddItemToTree
//
//	Adds an item with the given attributes to the CTreeCtrl
//
HTREEITEM CBaseTreeView::AddItemToTree(HTREEITEM hParent, CString szText, HTREEITEM hInsAfter, int iImage, LPARAM lParam)
{
	HTREEITEM hItem;
	TV_ITEM tvItem = {0};
	TV_INSERTSTRUCT tvInsert;

	ASSERT(lParam);

	tvItem.mask           = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
	TCHAR temp[255];
	wcscpy(temp, szText);
	tvItem.pszText        = temp;
	tvItem.cchTextMax     = lstrlen(szText);
	tvItem.iImage         = iImage;
	tvItem.iSelectedImage = iImage;
	tvItem.lParam		  = lParam;

	tvInsert.item         = tvItem;
	tvInsert.hInsertAfter = hInsAfter;
	tvInsert.hParent      = hParent;

	hItem = GetTreeCtrl().InsertItem(&tvInsert);

	if(!m_bInitialExpand && hItem) {
		m_bInitialExpand = GetTreeCtrl().Expand(GetTreeCtrl().GetRootItem(), TVE_EXPAND);
	}
    
	return hItem;

}  // end CBaseTreeView::AddItemToTree


///////////////////////////////////
// F'N: CBaseTreeView::GetCurrentNode
//
DWORD_PTR CBaseTreeView::GetCurrentNode()
{
	LockTreeControl();
	HTREEITEM hCurr = GetTreeCtrl().GetSelectedItem();
	DWORD_PTR node = GetTreeCtrl().GetItemData(hCurr);
	UnlockTreeControl();
	
	return node;

}  // end CBaseTreeView::GetCurrentNode


///////////////////////////////////
// F'N: CBaseTreeView::OnSelChange
//
// - this f'n posts a WM_ADMIN_CHANGEVIEW message to the mainframe, passing along
//   a pointer to the newly selected tree item's info structure in lParam so
//   that the mainframe can make an intelligent decision as far as how to
//   interpret the message
//
//	Passes TRUE as wParam for WM_ADMIN_CHANGEVIEW message to signify
//	that the message was caused by a user mouse click
//
void CBaseTreeView::OnSelChange(NMHDR* pNMHDR, LRESULT* pResult)
{
	LockTreeControl();
	HTREEITEM hCurr = GetTreeCtrl().GetSelectedItem();
	DWORD_PTR value = GetTreeCtrl().GetItemData(hCurr);
	UnlockTreeControl();

	// Tell the document that the current item in the tree has changed
    CTreeNode *pNode = (CTreeNode*)value;
    
    if( pNode != NULL )
    {
	    ((CWinAdminDoc*)GetDocument())->SetCurrentView(VIEW_CHANGING);

        ((CWinAdminDoc*)GetDocument())->SetTreeCurrent( pNode->GetTreeObject(), pNode->GetNodeType());
	    
        // send a "change view" msg to the mainframe with the info structure ptr as a parm

	    CFrameWnd* pMainWnd = (CFrameWnd*)AfxGetMainWnd();        

        pMainWnd->PostMessage(WM_ADMIN_CHANGEVIEW, *pResult == 0xc0 ? TRUE : FALSE , (LPARAM)pNode);	// SendMessage causes blank pages
    }

	*pResult = 0;

}  // end CBaseTreeView::OnSelChange


///////////////////////////////////
// F'N: CBaseTreeView::ForceSelChange
//
// Called by treeview when the state of an item in the tree has changed
// which is likely to cause the current view in the right pane to change.
//
// This f'n posts a WM_ADMIN_CHANGEVIEW message to the mainframe, passing along
// a pointer to the newly selected tree item's info structure in lParam so
// that the mainframe can make an intelligent decision as far as how to
// interpret the message
//
// Puts a FALSE in wParam of the WM_ADMIN_CHANGEVIEW message which
// tells the right pane that this was not caused by a user clicking
// on the item in the tree
//
void CBaseTreeView::ForceSelChange()
{
	LockTreeControl();
	HTREEITEM hCurr = GetTreeCtrl().GetSelectedItem();
	DWORD_PTR value = GetTreeCtrl().GetItemData(hCurr);
	UnlockTreeControl();

	// Tell the document that the current item in the tree has changed
	((CWinAdminDoc*)GetDocument())->SetCurrentView(VIEW_CHANGING);
	((CWinAdminDoc*)GetDocument())->SetTreeCurrent(((CTreeNode*)value)->GetTreeObject(), ((CTreeNode*)value)->GetNodeType());

	// send a "change view" msg to the mainframe with the info structure ptr as a parm
	CFrameWnd* pMainWnd = (CFrameWnd*)AfxGetMainWnd();
	pMainWnd->PostMessage(WM_ADMIN_CHANGEVIEW, FALSE, (LPARAM)value);	// SendMessage causes blank pages

}  // end CBaseTreeView::ForceSelChange


////////////////////////////////
// F'N: CBaseTreeView::OnExpandAll
//
//	Expands all levels of the tree, starting at the root
//
LRESULT CBaseTreeView::OnExpandAll(WPARAM wParam, LPARAM lParam)
{
	LockTreeControl();
	// get a count of the items in the tree
	UINT itemCount = GetTreeCtrl().GetCount();

	// get the handle of the root item and Expand it
	HTREEITEM hTreeItem = GetTreeCtrl().GetRootItem();
	for(UINT i = 0; i < itemCount; i++)  {
		GetTreeCtrl().Expand(hTreeItem, TVE_EXPAND);
		hTreeItem = GetTreeCtrl().GetNextItem(hTreeItem, TVGN_NEXTVISIBLE);
	}

	UnlockTreeControl();

	return 0;
}  // end CBaseTreeView::OnExpandAll


////////////////////////////////
// F'N: CBaseTreeView::Collapse
//
//	Helper function to collapse a tree item
//	NOTE: This function calls itself recursively
//
void CBaseTreeView::Collapse(HTREEITEM hItem)
{
	LockTreeControl();

	CTreeCtrl &tree = GetTreeCtrl();

	// Get his first child and collapse him
	HTREEITEM hChild = tree.GetNextItem(hItem, TVGN_CHILD);
	if(hChild) Collapse(hChild);
	// Collapse him
	tree.Expand(hItem, TVE_COLLAPSE);
	// Get his first sibling and collapse him
	HTREEITEM hSibling = tree.GetNextItem(hItem, TVGN_NEXT);
	if(hSibling) Collapse(hSibling);

	UnlockTreeControl();
}  // end CBaseTreeView::Collapse


////////////////////////////////
// F'N: CBaseTreeView::OnCollapseAll
//
//	Collapses all levels of the tree, starting at the root
//
LRESULT CBaseTreeView::OnCollapseAll(WPARAM wParam, LPARAM lParam)
{
	// Call the recursive function to do all
	// the collapsing
	Collapse(GetTreeCtrl().GetRootItem());

	return 0;

}  // end CBaseTreeView::OnCollapseAll


////////////////////////////////
// F'N: CBaseTreeView::OnCollapseToThirdLevel
//
//	Collapses tree down to show just root children and their children
//
LRESULT CBaseTreeView::OnCollapseToThirdLevel(WPARAM wParam, LPARAM lParam)
{
	LockTreeControl();
	// Get the root item
	HTREEITEM hTreeItem = GetTreeCtrl().GetRootItem();
	// Get the first node
	HTREEITEM hRootChild = GetTreeCtrl().GetNextItem(hTreeItem, TVGN_CHILD);
	while(hRootChild) {
        HTREEITEM hThirdLevel = GetTreeCtrl().GetNextItem(hRootChild, TVGN_CHILD);
        while(hThirdLevel) {
		    // collapse him
		    GetTreeCtrl().Expand(hThirdLevel, TVE_COLLAPSE);
		    // go to the next one
		    hThirdLevel = GetTreeCtrl().GetNextItem(hThirdLevel, TVGN_NEXT);
        }
        hRootChild = GetTreeCtrl().GetNextItem(hRootChild, TVGN_NEXT);
	}

	UnlockTreeControl();

	return 0;

}  // end CBaseTreeView::OnCollapseToThirdLevel


////////////////////////////////
// F'N: CBaseTreeView::OnCollapseToRootChildren
//
//	Collapses tree down to show just root and it's immediate children
//
LRESULT CBaseTreeView::OnCollapseToRootChildren(WPARAM wParam, LPARAM lParam)
{
	LockTreeControl();
	// Get the root item
	HTREEITEM hTreeItem = GetTreeCtrl().GetRootItem();
	// Get the first node
	HTREEITEM hNode = GetTreeCtrl().GetNextItem(hTreeItem, TVGN_CHILD);
	while(hNode) {
        Collapse(hNode);
		// go to the next node
		hNode = GetTreeCtrl().GetNextItem(hNode, TVGN_NEXT);
	}

	UnlockTreeControl();

	return 0;

}  // end CBaseTreeView::OnCollapseToRootChildren



////////////////////////////////
// F'N: CBaseTreeView::OnDestroy
//
void CBaseTreeView::OnDestroy()
{
	LockTreeControl();

	UINT itemCount = GetTreeCtrl().GetCount();

	HTREEITEM hTreeItem = GetTreeCtrl().GetRootItem();
	for(UINT i = 0; i < itemCount; i++)  {
		CTreeNode *node = ((CTreeNode*)GetTreeCtrl().GetItemData(hTreeItem));
		delete (CTreeNode*)(GetTreeCtrl().GetItemData(hTreeItem));
		hTreeItem = GetNextItem(hTreeItem);
	}

	UnlockTreeControl();

}  // end CBaseTreeView::OnDestroy


////////////////////////////////
// F'N: CBaseTreeView::GetNextItem
//
// GetNextItem  - Get next item as if outline was completely expanded
// Returns      - The item immediately below the reference item
// hItem        - The reference item
//
HTREEITEM CBaseTreeView::GetNextItem( HTREEITEM hItem )
{
	HTREEITEM       hti;
	CTreeCtrl &tree = GetTreeCtrl();
	
	if(tree.ItemHasChildren( hItem ) )
		return tree.GetChildItem( hItem );           // return first child
    else {                // return next sibling item
		// Go up the tree to find a parent's sibling if needed.
        while( (hti = tree.GetNextSiblingItem( hItem )) == NULL ) {
			if( (hItem = tree.GetParentItem( hItem ) ) == NULL )
				return NULL;
		}
	}

	return hti;

}	// end CBaseTreeView::GetNextItem
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\bussrvvw.h ===
/*******************************************************************************
*
* busssrvvw.h
*
* declarations for the CBusyServerView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\BUSSRVVW.H  $
*  
*     Rev 1.0   30 Jul 1997 17:11:16   butchd
*  Initial revision.
*
*******************************************************************************/

/////////////////////////////////////////////////////////////////////////////
// CBusyServerView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CBusyServerView : public CFormView
{
friend class CRightPane;

protected:
	CBusyServerView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CBusyServerView)

// Form Data
public:
	//{{AFX_DATA(CBusyServerView)
	enum { IDD = IDD_BUSY_SERVER };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBusyServerView)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CBusyServerView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CBusyServerView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\bussrvvw.cpp ===
/*******************************************************************************
*
* bussrvvw.cpp
*
* implementation of the CBusyServerView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\BUSSRVVW.CPP  $
*  
*     Rev 1.0   30 Jul 1997 17:11:12   butchd
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "bussrvvw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// View for a server that we aren't done getting information about

IMPLEMENT_DYNCREATE(CBusyServerView, CFormView)

CBusyServerView::CBusyServerView()
	: CFormView(CBusyServerView::IDD)
{
	//{{AFX_DATA_INIT(CBusyServerView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CBusyServerView::~CBusyServerView()
{
}

void CBusyServerView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBusyServerView)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBusyServerView, CFormView)
	//{{AFX_MSG_MAP(CBusyServerView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBusyServerView diagnostics

#ifdef _DEBUG
void CBusyServerView::AssertValid() const
{
	CFormView::AssertValid();
}

void CBusyServerView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CBusyServerView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\bwinsvw.cpp ===
/*******************************************************************************
*
* bwinsvw.cpp
*
* implementation of the CBadWinStationView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\BWINSVW.CPP  $
*  
*     Rev 1.0   30 Jul 1997 17:11:20   butchd
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "bwinsvw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// badboy

IMPLEMENT_DYNCREATE(CBadWinStationView, CFormView)

CBadWinStationView::CBadWinStationView()
	: CFormView(CBadWinStationView::IDD)
{
	//{{AFX_DATA_INIT(CBadWinStationView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CBadWinStationView::~CBadWinStationView()
{
}

void CBadWinStationView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBadWinStationView)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBadWinStationView, CFormView)
	//{{AFX_MSG_MAP(CBadWinStationView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBadWinStationView diagnostics

#ifdef _DEBUG
void CBadWinStationView::AssertValid() const
{
	CFormView::AssertValid();
}

void CBadWinStationView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CBadWinStationView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\colsort.cpp ===
/*******************************************************************************
*
* colsort.cpp
*
* Helper functions to sort columns
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\colsort.cpp  $
*  
*     Rev 1.10   19 Feb 1998 17:40:12   donm
*  removed latest extension DLL support
*  
*     Rev 1.7   12 Feb 1998 14:20:50   donm
*  missed some State columns
*  
*     Rev 1.6   12 Feb 1998 12:59:20   donm
*  State columns wouldn't sort because they were being treated as numbers
*  
*     Rev 1.5   10 Nov 1997 14:51:30   donm
*  fixed endless recursion in SortTextItems
*  
*     Rev 1.4   07 Nov 1997 23:06:38   donm
*  CompareTCPAddress would trap if ExtServerInfo was NULL
*  
*     Rev 1.3   03 Nov 1997 15:23:22   donm
*  added descending sort/cleanup
*  
*     Rev 1.2   15 Oct 1997 19:50:34   donm
*  update
*  
*     Rev 1.1   13 Oct 1997 18:39:54   donm
*  update
*  
*     Rev 1.0   30 Jul 1997 17:11:26   butchd
*  Initial revision.
*  
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Compare function for columns of WinStations
/* no longer used since we want an alphabetical order
int CALLBACK CompareWinStation(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int retval = 0;

	if(!lParam1 || !lParam2) return 0;

	ULONG sort1 = ((CWinStation*)lParam1)->GetSortOrder();
	ULONG sort2 = ((CWinStation*)lParam2)->GetSortOrder();
	if(sort1 == sort2) {
		SDCLASS pd1 = ((CWinStation*)lParam1)->GetSdClass();
		SDCLASS pd2 = ((CWinStation*)lParam2)->GetSdClass();
		if(pd1 == pd2) retval = 0;
		else if(pd1 < pd2) retval = -1;
		else retval =  1;
	}
	else if(sort1 < sort2) retval = -1;
	else retval = 1;

    return(lParamSort ? retval : -retval);
}
*/

// Compare function for columns of Idle Times
int CALLBACK CompareIdleTime(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int retval = 0;

	if(!lParam1 || !lParam2) return 0;
	ELAPSEDTIME idle1 = ((CWinStation*)lParam1)->GetIdleTime();
	ELAPSEDTIME idle2 = ((CWinStation*)lParam2)->GetIdleTime();
	// check days first
	if(idle1.days < idle2.days) retval = -1;
	else if(idle1.days > idle2.days) retval = 1;
	// check hours
	else if(idle1.hours < idle2.hours) retval = -1;
	else if(idle1.hours > idle2.hours) retval = 1;
	// check minutes
	else if(idle1.minutes < idle2.minutes) retval = -1;
	else if(idle1.minutes > idle2.minutes) retval = 1;
	// check seconds
	else if(idle1.seconds < idle2.seconds) retval = -1;
	else if(idle1.seconds > idle2.seconds) retval = 1;

    return(lParamSort ? retval : -retval);
}


// Compare function for columns of Logon Times
int CALLBACK CompareLogonTime(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int retval = 0;

	if(!lParam1 || !lParam2) return 0;

	LARGE_INTEGER logon1 = ((CWinStation*)lParam1)->GetLogonTime();
	LARGE_INTEGER logon2 = ((CWinStation*)lParam2)->GetLogonTime();

	if(logon1.QuadPart == logon2.QuadPart) retval = 0;
	else if(logon1.QuadPart < logon2.QuadPart) retval = -1;
	else retval = 1;

    return(lParamSort ? retval : -retval);
}


// Compare function for columns of TCP/IP Addresses
int CALLBACK CompareTcpAddress(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int retval = 0;

	if(!lParam1 || !lParam2) return 0;

    ExtServerInfo *ex1 = (ExtServerInfo*)((CServer*)lParam1)->GetExtendedInfo();
    ExtServerInfo *ex2 = (ExtServerInfo*)((CServer*)lParam2)->GetExtendedInfo();

    if(!ex1 && !ex2) retval = 0;
    else if(ex1 && !ex2) retval = 1;
    else if(!ex1 && ex2) retval = -1;
    else {
	    ULONG tcp1 = ex1->RawTcpAddress;
	    ULONG tcp2 = ex2->RawTcpAddress;

	    if(tcp1 == tcp2) retval = 0;
	    else if(tcp1 < tcp2) retval = -1;
	    else retval = 1;
    }

    return(lParamSort ? retval : -retval);
}


// Compare function for columns of Module dates
int CALLBACK CompareModuleDate(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int retval = 0;

	if(!lParam1 || !lParam2) return 0;

	// Compare the dates first
	USHORT date1 = ((ExtModuleInfo*)lParam1)->Date;
	USHORT date2 = ((ExtModuleInfo*)lParam2)->Date;

	if(date1 < date2) retval = -1;
	else if(date1 > date2) retval = 1;
	// Dates are the same, compare the times
    else {
	    USHORT time1 = ((ExtModuleInfo*)lParam1)->Time;
	    USHORT time2 = ((ExtModuleInfo*)lParam2)->Time;
	    if(time1 == time2) retval = 0;
	    else if(time1 < time2) retval = -1;
	    else retval = 1;
    }

    return(lParamSort ? retval : -retval);
}


// Compare function for columns of Module versions
int CALLBACK CompareModuleVersions(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int retval = 0;

	if(!lParam1 || !lParam2) return 0;

	// Compare the low versions first
	BYTE lowversion1 = ((ExtModuleInfo*)lParam1)->LowVersion;
	BYTE lowversion2 = ((ExtModuleInfo*)lParam2)->LowVersion;

	if(lowversion1 < lowversion2) retval = -1;
	else if(lowversion1 > lowversion2) retval = 1;
	// Low versions are the same, compare high version
    else {
	    BYTE highversion1 = ((ExtModuleInfo*)lParam1)->HighVersion;
	    BYTE highversion2 = ((ExtModuleInfo*)lParam2)->HighVersion;
	    if(highversion1 == highversion2) retval = 0;
	    else if(highversion1 < highversion2) retval = -1;
	    else retval = 1;
    }

    return(lParamSort ? retval : -retval);
}


// SortTextItems	- Sort the list based on column text
// Returns		- Returns true for success
// nCol			- column that contains the text to be sorted
// bAscending		- indicate sort order
// low			- row to start scanning from - default row is 0
// high			- row to end scan. -1 indicates last row
BOOL SortTextItems( CListCtrl *pList, int nCol, BOOL bAscending,
					int low /*= 0*/, int high /*= -1*/ ){
	if( nCol >= ((CHeaderCtrl*)pList->GetDlgItem(0))->GetItemCount() )		
		return FALSE;

	if( high == -1 ) high = pList->GetItemCount() - 1;	

	int lo = low;	
	int hi = high;
	CString midItem;
	
	if( hi <= lo ) return FALSE;

	midItem = pList->GetItemText( (lo+hi)/2, nCol );

	// loop through the list until indices cross	
	while( lo <= hi )	{

		// rowText will hold all column text for one row		
		CStringArray rowText;

		// find the first element that is greater than or equal to
		// the partition element starting from the left Index.		
		if( bAscending )
			while( ( lo < high ) && ( pList->GetItemText(lo, nCol) < midItem ) )				
				++lo;		
		else
			while( ( lo < high ) && ( pList->GetItemText(lo, nCol) > midItem ) )				
				++lo;

		// find an element that is smaller than or equal to
		// the partition element starting from the right Index.		
		if( bAscending )
			while( ( hi > low ) && ( pList->GetItemText(hi, nCol) > midItem ) )
				--hi;		
		else
			while( ( hi > low ) && ( pList->GetItemText(hi, nCol) < midItem ) )				
				--hi;

		// if the indexes have not crossed, swap		
		// and if the items are not equal
		if( lo <= hi )		
		{			
			// swap only if the items are not equal
			if( pList->GetItemText(lo, nCol) != pList->GetItemText(hi, nCol))
			{				
				// swap the rows
				LV_ITEM lvitemlo, lvitemhi;				
				int nColCount =
					((CHeaderCtrl*)pList->GetDlgItem(0))->GetItemCount();
				rowText.SetSize( nColCount );				
				
				int i;				
				for( i=0; i<nColCount; i++)
					rowText[i] = pList->GetItemText(lo, i);
				lvitemlo.mask = LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
				lvitemlo.iItem = lo;				
				lvitemlo.iSubItem = 0;
				lvitemlo.stateMask = LVIS_CUT | LVIS_DROPHILITED |
					LVIS_FOCUSED | LVIS_SELECTED |
					LVIS_OVERLAYMASK | LVIS_STATEIMAGEMASK;
				
				lvitemhi = lvitemlo;
				lvitemhi.iItem = hi;				

				pList->GetItem( &lvitemlo );				
				pList->GetItem( &lvitemhi );

				for( i=0; i<nColCount; i++)					
					pList->SetItemText(lo, i, pList->GetItemText(hi, i));

				lvitemhi.iItem = lo;				
				pList->SetItem( &lvitemhi );				
				
				for( i=0; i<nColCount; i++)
					pList->SetItemText(hi, i, rowText[i]);				
				
				lvitemlo.iItem = hi;
				pList->SetItem( &lvitemlo );			
			}			
			
			++lo;			
			--hi;		
		}	
	}

	// If the right index has not reached the left side of array
	// must now sort the left partition.	
	if( low < hi )
		SortTextItems( pList, nCol, bAscending , low, hi);

	// If the left index has not reached the right side of array
	// must now sort the right partition.	
	if( lo < high )
		SortTextItems( pList, nCol, bAscending , lo, high );	

	return TRUE;
}


long myatol(CString sTemp)
{

    return((long)wcstoul(sTemp.GetBuffer(0), NULL, 10));
}


BOOL SortNumericItems( CListCtrl *pList, int nCol, BOOL bAscending,long low, long high)
{	
	if( nCol >= ((CHeaderCtrl*)pList->GetDlgItem(0))->GetItemCount() )		
		return FALSE;	

	if( high == -1 ) high = pList->GetItemCount() - 1;	
	long lo = low;
    long hi = high;

	long midItem;		

	if( hi <= lo ) return FALSE;	

	midItem = myatol(pList->GetItemText( (lo+hi)/2, nCol ));
	
	// loop through the list until indices cross	
	while( lo <= hi )	
	{ 
		// rowText will hold all column text for one row		
		CStringArray rowText;

		// find the first element that is greater than or equal to 
		// the partition element starting from the left Index.		
		if( bAscending )
			while( ( lo < high ) && (myatol(pList->GetItemText(lo, nCol)) < midItem ) )
				++lo;           		
		else
			while( ( lo < high ) && (myatol(pList->GetItemText(lo, nCol)) > midItem ) )				
				++lo;
                
		// find an element that is smaller than or equal to 
		// the partition element starting from the right Index.		
		if( bAscending )
			while( ( hi > low ) && (myatol(pList->GetItemText(hi, nCol)) > midItem ) )
				--hi;           		
		else
			while( ( hi > low ) && (myatol(pList->GetItemText(hi, nCol)) < midItem ) )				
				--hi;
				
		// if the indexes have not crossed, swap                
		// and if the items are not equal		
		if( lo <= hi )		
		{
			// swap only if the items are not equal
			if(myatol(pList->GetItemText(lo, nCol)) != myatol(pList->GetItemText(hi, nCol)) )
			{                               				
				// swap the rows
				LV_ITEM lvitemlo, lvitemhi;                				
				int nColCount =
					((CHeaderCtrl*)pList->GetDlgItem(0))->GetItemCount();

				rowText.SetSize( nColCount );

				int i;
				for( i=0; i < nColCount; i++)							
					rowText[i] = pList->GetItemText(lo, i);

                lvitemlo.mask = LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
				lvitemlo.iItem = lo;				
				lvitemlo.iSubItem = 0;
				lvitemlo.stateMask = LVIS_CUT | LVIS_DROPHILITED |
							LVIS_FOCUSED |  LVIS_SELECTED |
							LVIS_OVERLAYMASK | LVIS_STATEIMAGEMASK;
				lvitemhi = lvitemlo;
				lvitemhi.iItem = hi;
				
				pList->GetItem( &lvitemlo );
				pList->GetItem( &lvitemhi );

				for( i=0; i< nColCount; i++)
					pList->SetItemText(lo, i, pList->GetItemText(hi, i) );

				lvitemhi.iItem = lo;				
				pList->SetItem( &lvitemhi );

				for( i=0; i< nColCount; i++)							
					pList->SetItemText(hi, i, rowText[i]);

                lvitemlo.iItem = hi;				
				pList->SetItem( &lvitemlo );			
			}						
			
			++lo;
			--hi;
		}
	}		
	
	// If the right index has not reached the left side of array
	// must now sort the left partition.	
	if( low < hi )
		SortNumericItems( pList, nCol, bAscending , low, hi);

	// If the left index has not reached the right side of array
	// must now sort the right partition.	
	if( lo < high )
		SortNumericItems( pList, nCol, bAscending , lo, high );		

	return TRUE;
}


// Our lookup table has structures of this type
typedef struct _ColumnLookup {
   int View;         // The view the page is in
	int Page;			// Page that needs to be sorted
	int ColumnNumber;	// Column that need to be sorted
	int (CALLBACK *CompareFunc)(LPARAM,LPARAM,LPARAM); // Callback to send to CListCtrl.SortItems
} ColumnLookup;


// This table only includes structures for columns that aren't sorted
// using the SortTextItems() function
// NULL for the CompareFunc means that SortNumericItems() should be called
ColumnLookup ColumnTable[] = {
	// Server User's Page - CWinStation
	{ VIEW_SERVER, PAGE_USERS, USERS_COL_ID, NULL },
	{ VIEW_SERVER, PAGE_USERS, USERS_COL_IDLETIME, CompareIdleTime },
	{ VIEW_SERVER, PAGE_USERS, USERS_COL_LOGONTIME, CompareLogonTime },
	// Server WinStation's Page - CWinStation
//	{ VIEW_SERVER, PAGE_WINSTATIONS, WS_COL_WINSTATION, CompareWinStation },
	{ VIEW_SERVER, PAGE_WINSTATIONS, WS_COL_ID, NULL },
	{ VIEW_SERVER, PAGE_WINSTATIONS, WS_COL_IDLETIME, CompareIdleTime },
	{ VIEW_SERVER, PAGE_WINSTATIONS, WS_COL_LOGONTIME, CompareLogonTime },
	// Server Processes' columns - CProcess
	{ VIEW_SERVER, PAGE_PROCESSES, PROC_COL_ID, NULL },
    { VIEW_SERVER, PAGE_PROCESSES, PROC_COL_PID, NULL },
	// Server Info (Hotfix) columns - CHotfix
	{ VIEW_SERVER, PAGE_INFO, HOTFIX_COL_INSTALLEDON, NULL },
	// WinStation Processes' columns - CProcess
	{ VIEW_WINSTATION, PAGE_WS_PROCESSES, WS_PROC_COL_ID, NULL },
	{ VIEW_WINSTATION, PAGE_WS_PROCESSES, WS_PROC_COL_PID, NULL },
	// WinStation Modules columns - CModule
	{ VIEW_WINSTATION, PAGE_WS_MODULES, MODULES_COL_FILEDATETIME, CompareModuleDate },
	{ VIEW_WINSTATION, PAGE_WS_MODULES, MODULES_COL_SIZE, NULL },
	{ VIEW_WINSTATION, PAGE_WS_MODULES, MODULES_COL_VERSIONS, CompareModuleVersions },
	// All Server Servers columns - CServer
	{ VIEW_ALL_SERVERS, PAGE_AS_SERVERS, SERVERS_COL_TCPADDRESS, CompareTcpAddress },
	{ VIEW_ALL_SERVERS, PAGE_AS_SERVERS, SERVERS_COL_NUMWINSTATIONS, NULL },
	// All Server Users columns - CWinStation
	{ VIEW_ALL_SERVERS, PAGE_AS_USERS, AS_USERS_COL_ID, NULL },
	{ VIEW_ALL_SERVERS, PAGE_AS_USERS, AS_USERS_COL_IDLETIME, CompareIdleTime },
	{ VIEW_ALL_SERVERS, PAGE_AS_USERS, AS_USERS_COL_LOGONTIME, CompareLogonTime },
	// All Server WinStations columns - CWinStation
//	{ VIEW_ALL_SERVERS, PAGE_AS_WINSTATIONS, AS_WS_COL_WINSTATION, CompareWinStation },
	{ VIEW_ALL_SERVERS, PAGE_AS_WINSTATIONS, AS_WS_COL_ID, NULL },
	{ VIEW_ALL_SERVERS, PAGE_AS_WINSTATIONS, AS_WS_COL_IDLETIME, CompareIdleTime },
	{ VIEW_ALL_SERVERS, PAGE_AS_WINSTATIONS, AS_WS_COL_LOGONTIME, CompareLogonTime },
	// All Server Processes columns - CProcess
	{ VIEW_ALL_SERVERS, PAGE_AS_PROCESSES, AS_PROC_COL_ID, NULL },
	{ VIEW_ALL_SERVERS, PAGE_AS_PROCESSES, AS_PROC_COL_PID, NULL },
	// All Server Licenses columns - CLicense
	{ VIEW_ALL_SERVERS, PAGE_AS_LICENSES, AS_LICENSE_COL_USERCOUNT, NULL },
	{ VIEW_ALL_SERVERS, PAGE_AS_LICENSES, AS_LICENSE_COL_POOLCOUNT, NULL },
	// Domain Servers columns - CServer
	{ VIEW_DOMAIN, PAGE_DOMAIN_SERVERS, SERVERS_COL_TCPADDRESS, CompareTcpAddress },
	{ VIEW_DOMAIN, PAGE_DOMAIN_SERVERS, SERVERS_COL_NUMWINSTATIONS, NULL },
	// Domain Users columns - CWinStation
	{ VIEW_DOMAIN, PAGE_DOMAIN_USERS, AS_USERS_COL_ID, NULL },
	{ VIEW_DOMAIN, PAGE_DOMAIN_USERS, AS_USERS_COL_IDLETIME, CompareIdleTime },
	{ VIEW_DOMAIN, PAGE_DOMAIN_USERS, AS_USERS_COL_LOGONTIME, CompareLogonTime },
	// Domain WinStations columns - CWinStation
//	{ VIEW_DOMAIN, PAGE_DOMAIN_WINSTATIONS, AS_WS_COL_WINSTATION, CompareWinStation },
	{ VIEW_DOMAIN, PAGE_DOMAIN_WINSTATIONS, AS_WS_COL_ID, NULL },
	{ VIEW_DOMAIN, PAGE_DOMAIN_WINSTATIONS, AS_WS_COL_IDLETIME, CompareIdleTime },
	{ VIEW_DOMAIN, PAGE_DOMAIN_WINSTATIONS, AS_WS_COL_LOGONTIME, CompareLogonTime },
	// Domain Processes columns - CProcess
	{ VIEW_DOMAIN, PAGE_DOMAIN_PROCESSES, AS_PROC_COL_ID, NULL },
	{ VIEW_DOMAIN, PAGE_DOMAIN_PROCESSES, AS_PROC_COL_PID, NULL },
	// Domain Licenses columns - CLicense
	{ VIEW_DOMAIN, PAGE_DOMAIN_LICENSES, AS_LICENSE_COL_USERCOUNT, NULL },
	{ VIEW_DOMAIN, PAGE_DOMAIN_LICENSES, AS_LICENSE_COL_POOLCOUNT, NULL },
};


/////////////////////////////////////////////////////////////////////////////
// SortByColumn
//
//	Page - page to be sorted
//	List - pointer to list control to call ->SortItems member function of
//	ColumnNumber - which column is to be sorted on
//  bAscending - TRUE if ascending, FALSE if descending
//
static int insort = 0;
void SortByColumn(int View, int Page, CListCtrl *List, int ColumnNumber, BOOL bAscending)
{
	if(insort) return;

	insort = 1;
	BOOL found = FALSE;

	// Look up the type of column from the ColumnNumber in our table
	int TableSize = sizeof(ColumnTable) / sizeof(ColumnLookup);

	for(int i = 0; i < TableSize; i++) {
		if(ColumnTable[i].View == View &&
			ColumnTable[i].Page == Page &&
			ColumnTable[i].ColumnNumber == ColumnNumber) {
				if(ColumnTable[i].CompareFunc)
					List->SortItems(ColumnTable[i].CompareFunc, bAscending);
				else
					SortNumericItems(List, ColumnNumber, bAscending, 0, -1);
				found = TRUE;
				break;
		}
	}

	if(!found) SortTextItems( List, ColumnNumber, bAscending, 0, -1);

	insort = 0;

}  // end SortByColumn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\bwinsvw.h ===
/*******************************************************************************
*
* bwinsvw.h
*
* declaration of the CBadWinStationView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\BWINSVW.H  $
*  
*     Rev 1.0   30 Jul 1997 17:11:22   butchd
*  Initial revision.
*
*******************************************************************************/

/////////////////////////////////////////////////////////////////////////////
// CBadWinStationView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CBadWinStationView : public CFormView
{
friend class CRightPane;

protected:
	CBadWinStationView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CBadWinStationView)

// Form Data
public:
	//{{AFX_DATA(CBadWinStationView)
	enum { IDD = IDD_BAD_WINSTATION };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBadWinStationView)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CBadWinStationView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CBadWinStationView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\domain.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* domain.cpp
*
* implementation of the CDomain class
*
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "admindoc.h"
#include "dialogs.h"
#include <malloc.h>                     // for alloca used by Unicode conversion macros
#include <mfc42\afxconv.h>           // for Unicode conversion macros
static int _convert;

#include <winsta.h>
#include <regapi.h>
#include "..\..\inc\utilsub.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MIN_MAJOR_VERSION 4
#define MIN_MINOR_VERSION 0



//////////////////////////////////////////////////////////////////////////////////////////
//
//      CDomain Member Functions
//
//////////////////////////////////////////////////////////////////////////////////////////

CDomain::CDomain(TCHAR *name)
{
    m_Flags = 0;
    m_PreviousState = DS_NONE;
    m_State = DS_NONE;
    m_hTreeItem = NULL;
    wcscpy(m_Name, name);
    m_pBackgroundThread = NULL;    
}


CDomain::~CDomain()
{
        if(m_State == DS_ENUMERATING) StopEnumerating();

}


void CDomain::SetState(DOMAIN_STATE state)
{
        // remember the previous state
        m_PreviousState = m_State;

        m_State = state;

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
        if(p && ::IsWindow(p->GetSafeHwnd())) {
                p->SendMessage(WM_ADMIN_UPDATE_DOMAIN, 0, (LPARAM)this);
        }
}


BOOL CDomain::StartEnumerating()
{
    BOOL bResult = FALSE;
    
    LockBackgroundThread();
    
    if( m_State == DS_ENUMERATING || m_State == DS_STOPPED_ENUMERATING )
    {
        UnlockBackgroundThread( );

        return FALSE;
    }

        // Fire off the background thread for this domain
    
    if( m_pBackgroundThread == NULL )
    {
        DomainProcInfo *pProcInfo = new DomainProcInfo;
        
        if( pProcInfo != NULL )
        {
            pProcInfo->pDomain = this;
            pProcInfo->pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
            m_BackgroundContinue = TRUE;
            m_pBackgroundThread = AfxBeginThread((AFX_THREADPROC)CDomain::BackgroundThreadProc,
                                                 pProcInfo,
                                                 0,
                                                 CREATE_SUSPENDED,
                                                 NULL );

            if( m_pBackgroundThread == NULL )
            {
                ODS( L"CDomain!StartEnumerating AfxBeginThread failed running low on resources\n" );

                delete pProcInfo;

                return FALSE;
            }

            m_pBackgroundThread->m_bAutoDelete = FALSE;

            if (m_pBackgroundThread->ResumeThread() <= 1)
            {
                bResult = TRUE;
            }
        }
    }
    
    UnlockBackgroundThread();
    
    return TRUE;
}


void CDomain::StopEnumerating()
{
    // Tell the background thread to terminate and
    // wait for it to do so.
    LockBackgroundThread();

    if(m_pBackgroundThread)
    {
        CWinThread *pBackgroundThread = m_pBackgroundThread;
        HANDLE hThread = m_pBackgroundThread->m_hThread;
        
        // Clear the pointer before releasing the lock
        m_pBackgroundThread = NULL;
        
        ClearBackgroundContinue( );

        UnlockBackgroundThread();
        
        // Wait for the thread's death
        if(WaitForSingleObject(hThread, 1000) == WAIT_TIMEOUT)
        {
            TerminateThread(hThread, 0);
        }

        WaitForSingleObject(hThread, INFINITE);
        
        // delete the CWinThread object
        delete pBackgroundThread;
    }
    else
    {
        UnlockBackgroundThread();
    }
    
    
    SetState(DS_STOPPED_ENUMERATING);

    DBGMSG( L"%s stopped enumerating\n" , GetName( ) );
}


USHORT Buflength(LPWSTR buf)
{
        LPWSTR p = buf;
        USHORT length = 0;

        while(*p) {
                USHORT plength = wcslen(p) + 1;
                length += plength;
                p += plength;
        }

        return length;

}       // end Buflength


LPWSTR ConcatenateBuffers(LPWSTR buf1, LPWSTR buf2)
{
        // Make sure both buffer pointers are valid
        if(!buf1 && !buf2) return NULL;
        if(buf1 && !buf2) return buf1;
        if(!buf1 && buf2) return buf2;

        // figure out how big a buffer we'll need
        USHORT buf1Length = Buflength(buf1);
        USHORT buf2Length = Buflength(buf2);
        USHORT bufsize = buf1Length + buf2Length + 1;
        // allocate a buffer
        LPWSTR pBuffer = (LPWSTR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, bufsize * sizeof(WCHAR));
    // If we can't allocate a buffer, free the second buffer and
    // return the pointer to the first of the two buffers
    if(!pBuffer) {
        LocalFree(buf2);
        return(buf1);
    }

        LPWSTR p = pBuffer;
        // copy the contents of the first buffer into the new buffer
        memcpy((char*)p, (char*)buf1, buf1Length * sizeof(WCHAR));
        p += buf1Length;
        // copy the contents of the second buffer into the new buffer
        memcpy((char*)p, (char*)buf2, buf2Length * sizeof(WCHAR));

        LocalFree(buf1);
        LocalFree(buf2);

        return pBuffer;

}       // end ConcatenateBuffers

void CDomain::CreateServers(LPWSTR pBuffer, LPVOID _pDoc)
{    
    CWinAdminDoc *pDoc = (CWinAdminDoc*)_pDoc;
    CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
    
    LPWSTR pTemp = pBuffer;
    
    // Loop through all the WinFrame servers that we found
    while(*pTemp)
    {
        // The server's name is in pTemp
        // Find the server in our list
        CServer *pServer = pDoc->FindServerByName(pTemp);
        // If the server is in our list, set the flag to say we found it
        if(pServer)
        {
            pServer->SetBackgroundFound();

            if( pServer->GetTreeItem( ) == NULL )
            {
                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
                
                p->SendMessage(WM_ADMIN_ADD_SERVER, ( WPARAM )TVI_SORT, (LPARAM)pServer);
            }

        }
        else
        {
            // We don't want to add the current Server again
            if( lstrcmpi( pTemp , pApp->GetCurrentServerName() ) )
            {
                // Create a new server object
                CServer *pNewServer = new CServer(this, pTemp, FALSE, pDoc->ShouldConnect(pTemp));
                
                if(pNewServer != NULL )
                {
                    // Add the server object to our linked list
                    pDoc->AddServer(pNewServer);
                    
                    // Set the flag to say we found it
                    pNewServer->SetBackgroundFound();
                    
                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
                    
                    if(p && ::IsWindow(p->GetSafeHwnd()))
                    {
                        p->SendMessage(WM_ADMIN_ADD_SERVER, ( WPARAM )TVI_SORT, (LPARAM)pNewServer);                        
                        
                    }
                }
            }
        }
        // Go to the next server in the buffer
        pTemp += (wcslen(pTemp) + 1);
    } // end while (*pTemp)
    
}

/////////////////////////////////////////////////////////////////////////////
// CDomain::BackgroundThreadProc
//
// Static member function for background thread
// Looks for servers appearing and disappearing
// Called with AfxBeginThread
// Thread terminates when function returns
//
UINT CDomain::BackgroundThreadProc(LPVOID bg)
{
    // We need a pointer to the document so we can make
    // calls to member functions
    CWinAdminDoc *pDoc = (CWinAdminDoc*)((DomainProcInfo*)bg)->pDoc;
    CDomain *pDomain = ((DomainProcInfo*)bg)->pDomain;
    delete bg;
    
    CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
    
    // We want to keep track of whether or not we've enumerated - so
    // that we can update the tree when we're done
    BOOL bNotified = FALSE;
    
    // We can't send messages to the view until they're ready
    // v-nicbd  RESOLVED  In case we are exiting tsadmin, we are waiting uselessly here
    //          - 500ms lapsed is negligible in UI
    while( !pDoc->AreAllViewsReady() )
    {
        Sleep(500);
    }
    
    // Don't do this until the views are ready!
    pDomain->SetState(DS_INITIAL_ENUMERATION);
    
    // If there is an extension DLL loaded, we will allow it to enumerate
    // additional servers
    LPFNEXENUMERATEPROC EnumerateProc = pApp->GetExtEnumerationProc();
    
    // The first time we enumerate servers, we want the CServer object
    // to put the server in the views when it has enough info.
    // On subsequent enumerations, we will add the server to the views
    // here.
    BOOL bSubsequent = FALSE;
    
    while(pDomain->ShouldBackgroundContinue())
    {
        
        BOOL Enumerated = FALSE;
        
        CObList TempServerList;
        
        DBGMSGx( L"CDomain!BackgroundThreadProc %s still going thread %d\n" , pDomain->GetName( ) , GetCurrentThreadId( ) );        
        
        // Loop through all the servers and turn off the flag
        // that tells this thread that he found it on this pass
        pDoc->LockServerList();
        CObList *pServerList = pDoc->GetServerList();
        
        POSITION pos = pServerList->GetHeadPosition();
        
        while(pos)
        {
            POSITION pos2 = pos;
            
            CServer *pServer = (CServer*)pServerList->GetNext(pos);
            
            if(pServer->GetDomain() == pDomain)
            {
                pServer->ClearBackgroundFound();
                
                // We want to remove a server if we could see it
                // the last time we enumerated servers
                // NOTE: This should not cause any problems
                //       The views should no longer have items pointing
                //       to this server at this point
                //
                // Move the server object to a temporary list.
                // This is so that we can unlock the server list before
                // we call the destructor on a CServer object since the
                // destructor will end up calling SetState() which does
                // a SendMessage.  This is not good to do with the list
                // locked.
                
                if(pServer->IsServerInactive() && !pServer->IsCurrentServer())
                {                    
                    pServer = (CServer*)pServerList->GetAt(pos2);
                    // Remove it from the server list
                    DBGMSG( L"Adding %s to temp list to destroy\n" , pServer->GetName( ) );
                    
                    pServerList->RemoveAt(pos2);
                    // Add it to our temporary list
                    TempServerList.AddTail(pServer);
                }
            }
        }
        
        pDoc->UnlockServerList();
        
        // do a first loop to signal the servers' background threads that they must stop
        pos = TempServerList.GetHeadPosition();
        while(pos)
        {
            CServer *pServer = (CServer*)TempServerList.GetNext(pos);
            
            DBGMSG( L"Clearing %s backgrnd cont\n", pServer->GetName() );
            
            pServer->ClearBackgroundContinue();
        }
        // do a second loop to disconnect and delete the servers
        pos = TempServerList.GetHeadPosition();
        
        while(pos)
        {
            CServer *pServer = (CServer*)TempServerList.GetNext(pos);
            
            DBGMSG( L"Disconnecting and deleteing %s now!!!\n", pServer->GetName( ) );
            
            pServer->Disconnect( );
            
            delete pServer;
            
            ODS( L"gone.\n" );
        }
        
        TempServerList.RemoveAll();
        
        // Make sure we don't have to quit
        if(!pDomain->ShouldBackgroundContinue())
        {
            return 0;
        }
        
        // Get all the Servers now (we already got the current server)
        LPWSTR pBuffer = NULL;
        
        // Find all WinFrame servers in the domain
        pBuffer = pDomain->EnumHydraServers(/*pDomain->GetName(),*/ MIN_MAJOR_VERSION, MIN_MINOR_VERSION);
        
        // Make sure we don't have to quit
        if(!pDomain->ShouldBackgroundContinue())
        {
            if(pBuffer) LocalFree(pBuffer);
            return 0;
        }
        
        // Make sure we don't have to quit
        if(!pDomain->ShouldBackgroundContinue())
        {
            if(pBuffer) LocalFree(pBuffer);
            return 0;
        }
        
        if(pBuffer) {
            Enumerated = TRUE;
            
            pDomain->CreateServers(pBuffer, (LPVOID)pDoc);
            
            LocalFree(pBuffer);
        }       // end if(pBuffer)
        
        // Make sure we don't have to quit
        if(!pDomain->ShouldBackgroundContinue()) return 0;
        
        if(!bNotified) {
            pDomain->SetState(DS_ENUMERATING);
            bNotified = TRUE;
        }
        
        // If there is an extension DLL loaded, allow it to enumerate additional servers
        LPWSTR pExtBuffer = NULL;
        
        if(EnumerateProc) {
            pExtBuffer = (*EnumerateProc)(pDomain->GetName());
        }
        
        // If the extension DLL found servers, concatenate the two buffers
        // The ConcatenateBuffers function will delete both buffers and return a
        // pointer to the new buffer
        if(pExtBuffer) {
            Enumerated = TRUE;
            pDomain->CreateServers(pExtBuffer, (LPVOID)pDoc);
            LocalFree(pExtBuffer);
        }
        
        // Make sure we don't have to quit
        if(!pDomain->ShouldBackgroundContinue())
        {
            return 0;
        }
        
        if(Enumerated)
        {
            // Mark the current server as found
            CServer *pCurrentServer = pDoc->GetCurrentServer();
            if(pCurrentServer) pCurrentServer->SetBackgroundFound();
            // Go through the list of servers and see which ones don't have
            // the flag set saying that we found it
            CObList TempList;
            
            pDoc->LockServerList();
            pServerList = pDoc->GetServerList();
            
            POSITION pos = pServerList->GetHeadPosition();
            
            while(pos)
            {
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                
                if(pServer->GetDomain() == pDomain)
                {
                    // we check to see if this server has been initially inserted to our server list
                    // manually. If so we don't want it inserted to our templist for deletion.
                    if( !pServer->IsManualFind() &&
                        ( !pServer->IsBackgroundFound() || 
                        pServer->HasLostConnection() ||
                        !pServer->IsServerSane() ) )
                    {
                        DBGMSG( L"Removing %s background not found or lost connection\n" , pServer->GetName( ) );
                        // Set the flag to say that this server is inactive
                        pServer->SetServerInactive();
                        // Add it to our temporary list
                        TempList.AddTail(pServer);
                    }
                }
            }
            
            pDoc->UnlockServerList();
            
            pos = TempList.GetHeadPosition();
            
            CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
            
            while(pos)
            {
                CServer *pServer = (CServer*)TempList.GetNext(pos);
                // Send a message to the mainframe to remove the server
                if(p && ::IsWindow(p->GetSafeHwnd()))
                {
                    DBGMSG( L"CDomain!Bkthrd removing %s temped threads from treeview & view\n" , pServer->GetName( ) );
                    
                    // clean up old node
                    if( pServer->GetTreeItemFromFav( ) != NULL )
                    {
                        // we cannot keep a favnode around if a server node is being deleted
                        // massive AV's will occurr.  So a quick fix is to remove the favnode 
                        // if it exists and create a new server node and mark it as manually
                        // found.  This will prevent this server node from being removed in 
                        // case NetEnumServer fails to pick up this server
                        p->SendMessage( WM_ADMIN_REMOVESERVERFROMFAV , TRUE , ( LPARAM )pServer );                   
                        
                        CServer *ptServer = new CServer( pDomain , pServer->GetName( ) , FALSE , FALSE );
                        
                        if( ptServer != NULL )
                        {
                            ptServer->SetManualFind( );
                            
                            pDoc->AddServer(ptServer);
                            
                            p->SendMessage(WM_ADMIN_ADDSERVERTOFAV , 0 , (LPARAM)ptServer);
                        }
                    }
                    
                    p->SendMessage(WM_ADMIN_REMOVE_SERVER, TRUE, (LPARAM)pServer);       
                }
            }
            
            TempList.RemoveAll();
            
        } // end if(Enumerated)
        
        // We don't want to do this constantly, it eats up processor cycles to enumerate servers
        // so we'll now let the user refresh these servers manually
        // Document destructor will signal the event to wake us up if he
        // wants us to quit
        pDomain->m_WakeUpEvent.Lock( INFINITE );
        
        bSubsequent = TRUE;
    }   // end while(1)
    
    return 0;
    
}       // end CDomain::BackgroundThreadProc



/*******************************************************************************
 *
 *      EnumHydraServers - Hydra helper function (taken from utildll and modified
 *      to be used along with a version check.
 *
 *      Enumerate the Hydra servers on the network by Domain
 *      Returns all the servers whose version is >= the version passed.
 *
 *  ENTRY:
 *      pDomain (input)
 *          Specifies the domain to enumerate; NULL for current domain.
 *      verMajor (input)
 *          specifies the Major version to check for.
 *      verMinor (input)
 *          specifies the minor version to check for.
 *
 *  EXIT:
 *      (LPTSTR) Points to LocalAlloced buffer containing results of the
 *               enumeration, in multi-string format, if sucessful; NULL if
 *               error.  The caller must perform a LocalFree of this buffer
 *               when done.  If error (NULL), the error code is set for
 *               retrieval by GetLastError();
 *
 ******************************************************************************/
LPWSTR CDomain::EnumHydraServers( /*LPWSTR pDomain,*/ DWORD verMajor, DWORD verMinor )

{
    PSERVER_INFO_101 pInfo = NULL;
    DWORD dwByteCount, dwIndex, TotalEntries;
    DWORD AvailCount = 0;
    LPWSTR pTemp, pBuffer = NULL;

    /*
     * Enumerate all WF servers on the specified domain.
     */
    if ( NetServerEnum ( NULL,
                         101,
                         (LPBYTE *)&pInfo,
                         (DWORD) -1,
                         &AvailCount,
                         &TotalEntries,
                         SV_TYPE_TERMINALSERVER,
                         m_Name, /*pDomain,*/
                         NULL ) ||
         !AvailCount )
        goto done;

    //
    // Traverse list of the servers that match the major and minor versions'criteria
    // and calculate the total byte count for list of
    // servers that will be returned.
    //
    for( dwByteCount = dwIndex = 0; dwIndex < AvailCount; dwIndex++ )
    {
        if( ((pInfo[dwIndex].sv101_version_major & MAJOR_VERSION_MASK) >=
            verMajor) && (pInfo[dwIndex].sv101_version_minor >= verMinor) )
        {
            dwByteCount += (wcslen(pInfo[dwIndex].sv101_name) + 1) * 2;
        }
    }

    dwByteCount += 2;   // for ending null

    /*
     * Allocate memory.
     */
    if( (pBuffer = (LPWSTR)LocalAlloc(LPTR, dwByteCount)) == NULL )
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto done;
    }

    /*
     * Traverse list again and copy servers to buffer.
     */
    for( pTemp = pBuffer, dwIndex = 0; dwIndex < AvailCount; dwIndex++ )
    {
        if( ((pInfo[dwIndex].sv101_version_major & MAJOR_VERSION_MASK) >=
            verMajor) && (pInfo[dwIndex].sv101_version_minor >= verMinor) )
        {
            // MS Bug 1821
            if ( wcslen(pInfo[dwIndex].sv101_name) != 0 )
            {
                wcscpy(pTemp, pInfo[dwIndex].sv101_name);

                pTemp += (wcslen(pInfo[dwIndex].sv101_name) + 1);
            }
        }
    }
    *pTemp = L'\0';     // ending null
    
done:
    if( AvailCount && pInfo )
    {
        NetApiBufferFree( pInfo );
    }
    
    return(pBuffer);
    
}  // end CDomain::EnumHydraServers


/////////////////////////////////////////////////////////////////////////////
// CDomain::DisconnectAllServers
//
// Disconnect from all servers in this Domain
//
void CDomain::DisconnectAllServers()
{
        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        CObList *pServerList = pDoc->GetServerList();

    CString AString;
        CDialog dlgWait;
        dlgWait.Create(IDD_SHUTDOWN, NULL);


        pDoc->LockServerList();

    ODS( L"TSADMIN:CDomain::DisconnectAllServers about to disconnect all connected servers\n" );

    // Do a first loop to signal the server background threads that they must stop
        POSITION pos = pServerList->GetHeadPosition();
        while(pos) {
                // Get a pointer to the server
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                // If this Server is in the domain and connected, tell the server background thread to stop
                if(pServer->GetDomain() == this
                        && pServer->GetState() != SS_NOT_CONNECTED) {
            pServer->ClearBackgroundContinue();
        }
        }
    // do a second loop to disconnect the servers
        pos = pServerList->GetHeadPosition();
        while(pos) {
                // Get a pointer to the server
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                // If this Server is in the domain and connected, disconnect from it
                if ((pServer->GetDomain() == this) && (pServer->GetState() != SS_NOT_CONNECTED)) {
                        AString.Format(IDS_DISCONNECTING, pServer->GetName());
                        dlgWait.SetDlgItemText(IDC_SHUTDOWN_MSG, AString);

                        // Tell the server to connect
                pServer->Disconnect();
                }
        }

    //
    // tell domain not to connect to any more servers
    //


        pDoc->UnlockServerList();

        dlgWait.PostMessage(WM_CLOSE);

}       // end CDomain::DisconnectAllServers


/////////////////////////////////////////////////////////////////////////////
// CDomain::ConnectAllServers
//
// Connect to all servers in this Domain
//
void CDomain::ConnectAllServers()
{
        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        CObList *pServerList = pDoc->GetServerList();

        pDoc->LockServerList();

        POSITION pos = pServerList->GetHeadPosition();
        while(pos) {
                // Get a pointer to the server
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                // If this Server is int the domain and not connected, connect to it
                if(pServer->GetDomain() == this
                        && pServer->IsState(SS_NOT_CONNECTED)) {
                // Tell the server to connect
                    pServer->Connect();
                }
        }

        pDoc->UnlockServerList();

}       // end CDomain::ConnectAllServers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\dialogs.cpp ===
/*******************************************************************************
*
* dialogs.cpp
*
* implementation of all dialog classes
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\dialogs.cpp  $
*  
*     Rev 1.7   25 Apr 1998 13:43:16   donm
*  MS 2167: try to use proper Wd from registry
*  
*     Rev 1.6   19 Jan 1998 16:46:08   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.5   03 Nov 1997 19:16:10   donm
*  removed redundant message to add server to views
*  
*     Rev 1.4   03 Nov 1997 15:24:16   donm
*  fixed AV in CServerFilterDialog
*  
*     Rev 1.3   22 Oct 1997 21:07:10   donm
*  update
*  
*     Rev 1.2   18 Oct 1997 18:50:10   donm
*  update
*  
*     Rev 1.1   13 Oct 1997 18:40:16   donm
*  update
*  
*     Rev 1.0   30 Jul 1997 17:11:28   butchd
*  Initial revision.
*  
*******************************************************************************/


#include "stdafx.h"
#include "afxpriv.h"
#include "winadmin.h"
#include "admindoc.h"
#include "dialogs.h"
#include "..\..\inc\ansiuni.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSendMessageDlg dialog


CSendMessageDlg::CSendMessageDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSendMessageDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSendMessageDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CSendMessageDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSendMessageDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSendMessageDlg, CDialog)
	//{{AFX_MSG_MAP(CSendMessageDlg)
	ON_WM_HELPINFO()
	ON_COMMAND(ID_HELP,OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSendMessageDlg message handlers
void CSendMessageDlg::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CSendMessageDlg::IDD + HID_BASE_RESOURCE);
	return;
}

BOOL CSendMessageDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
 
	// Form the default the message title.
    CString DefTitleString;
    TCHAR szTime[MAX_DATE_TIME_LENGTH];

    CurrentDateTimeString(szTime);
    DefTitleString.LoadString(IDS_DEFAULT_MESSAGE_TITLE);
    wsprintf(m_szTitle, DefTitleString, ((CWinAdminApp*)AfxGetApp())->GetCurrentUserName(), szTime);

    // Initialize the title edit control and set maximum length for title
    // and message.
    SetDlgItemText(IDC_MESSAGE_TITLE, m_szTitle);
    ((CEdit *)GetDlgItem(IDC_MESSAGE_TITLE))->LimitText(MSG_TITLE_LENGTH);
    ((CEdit *)GetDlgItem(IDC_MESSAGE_MESSAGE))->LimitText(MSG_MESSAGE_LENGTH);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSendMessageDlg::OnOK() 
{
	// TODO: Add extra validation here

    // Get the message title and message text.
    GetDlgItemText(IDC_MESSAGE_TITLE, m_szTitle, MSG_TITLE_LENGTH+1);
    GetDlgItemText(IDC_MESSAGE_MESSAGE, m_szMessage, MSG_MESSAGE_LENGTH+1);
	
	CDialog::OnOK();
}

BOOL CSendMessageDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	// TODO: Add your message handler code here and/or call default
	//((CWinAdminApp*)AfxGetApp())->WinHelp(HID_BASE_CONTROL + pHelpInfo->iCtrlId, HELP_CONTEXTPOPUP);
	if(pHelpInfo->iContextType == HELPINFO_WINDOW) 
	{
	    if(pHelpInfo->iCtrlId != IDC_STATIC)
		{
	         ::WinHelp((HWND)pHelpInfo->hItemHandle,ID_HELP_FILE,HELP_WM_HELP,(ULONG_PTR)(LPVOID)aMenuHelpIDs);
		}
	}
	return (TRUE);

}


/////////////////////////////////////////////////////////////////////////////
// CShadowStartDlg dialog


CShadowStartDlg::CShadowStartDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CShadowStartDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CShadowStartDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

////////////////////////////////////////////////////////////////////////////////
// CShadowStartDlg static tables



struct {
    LPCTSTR String;
    DWORD VKCode;
} HotkeyLookupTable[] =
    {
        TEXT("0"),            '0',
        TEXT("1"),            '1',
        TEXT("2"),            '2',
        TEXT("3"),            '3',
        TEXT("4"),            '4',
        TEXT("5"),            '5',
        TEXT("6"),            '6',
        TEXT("7"),            '7',
        TEXT("8"),            '8',
        TEXT("9"),            '9',
        TEXT("A"),            'A',
        TEXT("B"),            'B',
        TEXT("C"),            'C',
        TEXT("D"),            'D',
        TEXT("E"),            'E',
        TEXT("F"),            'F',
        TEXT("G"),            'G',
        TEXT("H"),            'H',
        TEXT("I"),            'I',
        TEXT("J"),            'J',
        TEXT("K"),            'K',
        TEXT("L"),            'L',
        TEXT("M"),            'M',
        TEXT("N"),            'N',
        TEXT("O"),            'O',
        TEXT("P"),            'P',
        TEXT("Q"),            'Q',
        TEXT("R"),            'R',
        TEXT("S"),            'S',
        TEXT("T"),            'T',
        TEXT("U"),            'U',
        TEXT("V"),            'V',
        TEXT("W"),            'W',
        TEXT("X"),            'X',
        TEXT("Y"),            'Y',
        TEXT("Z"),            'Z',
        TEXT("{backspace}"),  VK_BACK,
        TEXT("{delete}"),     VK_DELETE,
        TEXT("{down}"),       VK_DOWN,
        TEXT("{end}"),        VK_END,
        TEXT("{enter}"),      VK_RETURN,
///        TEXT("{esc}"),        VK_ESCAPE,                           // KLB 07-16-95
///        TEXT("{F1}"),         VK_F1,
        TEXT("{F2}"),         VK_F2,
        TEXT("{F3}"),         VK_F3,
        TEXT("{F4}"),         VK_F4,
        TEXT("{F5}"),         VK_F5,
        TEXT("{F6}"),         VK_F6,
        TEXT("{F7}"),         VK_F7,
        TEXT("{F8}"),         VK_F8,
        TEXT("{F9}"),         VK_F9,
        TEXT("{F10}"),        VK_F10,
        TEXT("{F11}"),        VK_F11,
        TEXT("{F12}"),        VK_F12,
        TEXT("{home}"),       VK_HOME,
        TEXT("{insert}"),     VK_INSERT,
        TEXT("{left}"),       VK_LEFT,
        TEXT("{-}"),          VK_SUBTRACT,
        TEXT("{pagedown}"),   VK_NEXT,
        TEXT("{pageup}"),     VK_PRIOR,
        TEXT("{+}"),          VK_ADD,
        TEXT("{prtscrn}"),    VK_SNAPSHOT,
        TEXT("{right}"),      VK_RIGHT,
        TEXT("{spacebar}"),   VK_SPACE,
        TEXT("{*}"),          VK_MULTIPLY,
        TEXT("{tab}"),        VK_TAB,
        TEXT("{up}"),         VK_UP,
        NULL,           NULL
    };


void CShadowStartDlg::OnSelChange( )
{/*
*/
    CComboBox *pComboBox = ((CComboBox *)GetDlgItem(IDC_SHADOWSTART_HOTKEY));

    // Get the current hotkey selection.
    DWORD dwKey = ( DWORD )pComboBox->GetItemData(pComboBox->GetCurSel());

    switch (dwKey )
    {
    case VK_ADD :
    case VK_MULTIPLY:
    case VK_SUBTRACT:
        // change the text
        GetDlgItem(IDC_PRESS_KEY)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_PRESS_NUMKEYPAD)->ShowWindow(SW_SHOW);
        break;
    default :
        // change the text
        GetDlgItem(IDC_PRESS_NUMKEYPAD)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_PRESS_KEY)->ShowWindow(SW_SHOW);
        break;
    }
}
void CShadowStartDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CShadowStartDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CShadowStartDlg, CDialog)
	//{{AFX_MSG_MAP(CShadowStartDlg)
	ON_WM_HELPINFO()
    ON_CBN_SELCHANGE( IDC_SHADOWSTART_HOTKEY , OnSelChange )
	ON_COMMAND(ID_HELP,OnCommandHelp)

	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CShadowStartDlg message handlers
void CShadowStartDlg::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CShadowStartDlg::IDD + HID_BASE_RESOURCE);
	return;
}

BOOL CShadowStartDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

   	GetDlgItem(IDC_PRESS_NUMKEYPAD)->ShowWindow(SW_HIDE);
   	GetDlgItem(IDC_PRESS_KEY)->ShowWindow(SW_SHOW);

	// TODO: Add extra initialization here
    int index, match = -1;
    CComboBox *pComboBox = ((CComboBox *)GetDlgItem(IDC_SHADOWSTART_HOTKEY));

    // Initialize the hotkey combo box.
    for(int i=0; HotkeyLookupTable[i].String; i++ ) {
        if((index = pComboBox->AddString(HotkeyLookupTable[i].String)) < 0) {
//            ErrorMessage(IDP_ERROR_STARTSHADOWHOTKEYBOX);
            break;
        }
        if(pComboBox->SetItemData(index, HotkeyLookupTable[i].VKCode) < 0) {
            pComboBox->DeleteString(index);
//            ErrorMessage(IDP_ERROR_STARTSHADOWHOTKEYBOX);
            break;
        }

        //  If this is our current hotkey key, save it's index.
        if(m_ShadowHotkeyKey == (int)HotkeyLookupTable[i].VKCode) {
            match = index;
            switch ( HotkeyLookupTable[i].VKCode)
            {
            case VK_ADD :
            case VK_MULTIPLY:
            case VK_SUBTRACT:
                // change the text
               	GetDlgItem(IDC_PRESS_KEY)->ShowWindow(SW_HIDE);
               	GetDlgItem(IDC_PRESS_NUMKEYPAD)->ShowWindow(SW_SHOW);
                break;
            }
        }

    }

    // Select the current hotkey string in the combo box.
    if(match)
        pComboBox->SetCurSel(match);

    // Initialize shift state checkboxes.
    CheckDlgButton( IDC_SHADOWSTART_SHIFT,
					(m_ShadowHotkeyShift & KBDSHIFT) ?
                        TRUE : FALSE );
    CheckDlgButton( IDC_SHADOWSTART_CTRL,
                    (m_ShadowHotkeyShift & KBDCTRL) ?
                        TRUE : FALSE );
    CheckDlgButton( IDC_SHADOWSTART_ALT,
                    (m_ShadowHotkeyShift & KBDALT) ?
                        TRUE : FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CShadowStartDlg::OnOK() 
{
	// TODO: Add extra validation here
    CComboBox *pComboBox = ((CComboBox *)GetDlgItem(IDC_SHADOWSTART_HOTKEY));

    // Get the current hotkey selection.
    m_ShadowHotkeyKey = (int)pComboBox->GetItemData(pComboBox->GetCurSel());

	// Get shift state checkbox states and form hotkey shift state.
    m_ShadowHotkeyShift = 0;
    m_ShadowHotkeyShift |=
        ((CButton *)GetDlgItem(IDC_SHADOWSTART_SHIFT))->GetCheck() ?
            KBDSHIFT : 0;
    m_ShadowHotkeyShift |=
        ((CButton *)GetDlgItem(IDC_SHADOWSTART_CTRL))->GetCheck() ?
            KBDCTRL : 0;
    m_ShadowHotkeyShift |=
        ((CButton *)GetDlgItem(IDC_SHADOWSTART_ALT))->GetCheck() ?
            KBDALT : 0;
	
	CDialog::OnOK();
}


BOOL CShadowStartDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	// TODO: Add your message handler code here and/or call default
	//((CWinAdminApp*)AfxGetApp())->WinHelp(HID_BASE_CONTROL + pHelpInfo->iCtrlId, HELP_CONTEXTPOPUP);
	if(pHelpInfo->iContextType == HELPINFO_WINDOW) 
	{
		if(pHelpInfo->iCtrlId != IDC_STATIC)
		{
	         ::WinHelp((HWND)pHelpInfo->hItemHandle,ID_HELP_FILE,HELP_WM_HELP,(ULONG_PTR)(LPVOID)aMenuHelpIDs);
		}
	}

	return (TRUE);
	
}


/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg dialog


CPasswordDlg::CPasswordDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPasswordDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPasswordDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CPasswordDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPasswordDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPasswordDlg, CDialog)
	//{{AFX_MSG_MAP(CPasswordDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg message handlers

BOOL CPasswordDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	CString Prompt;

    Prompt.LoadString((m_DlgMode == PwdDlg_UserMode) ?
                            IDS_PWDDLG_USER : IDS_PWDDLG_WINSTATION );
    SetDlgItemText(IDL_CPDLG_PROMPT, Prompt);
    ((CEdit *)GetDlgItem(IDC_CPDLG_PASSWORD))->LimitText(PASSWORD_LENGTH);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPasswordDlg::OnOK() 
{
	// TODO: Add extra validation here
	// Read password.
    GetDlgItemText(IDC_CPDLG_PASSWORD, m_szPassword, PASSWORD_LENGTH+1);
	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CPreferencesDlg dialog

CPreferencesDlg::CPreferencesDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPreferencesDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPreferencesDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CPreferencesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPreferencesDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPreferencesDlg, CDialog)
	//{{AFX_MSG_MAP(CPreferencesDlg)
	ON_BN_CLICKED(IDC_PREFERENCES_PROC_MANUAL, OnPreferencesProcManual)
	ON_BN_CLICKED(IDC_PREFERENCES_PROC_EVERY, OnPreferencesProcEvery)
	ON_BN_CLICKED(IDC_PREFERENCES_STATUS_EVERY, OnPreferencesStatusEvery)
	ON_BN_CLICKED(IDC_PREFERENCES_STATUS_MANUAL, OnPreferencesStatusManual)
	ON_WM_CLOSE()
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPreferencesDlg message handlers


BOOL CPreferencesDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// TODO: Add extra initialization here
	CWinAdminApp *App = (CWinAdminApp*)AfxGetApp();
    CWinAdminDoc *pDoc = (CWinAdminDoc*)App->GetDocument();

	if(App->GetProcessListRefreshTime() == INFINITE) {
		CheckRadioButton(IDC_PREFERENCES_PROC_MANUAL, IDC_PREFERENCES_PROC_EVERY, 
			IDC_PREFERENCES_PROC_MANUAL);
		SetDlgItemInt(IDC_PREFERENCES_PROC_SECONDS, 5);
	} else {
		CheckRadioButton(IDC_PREFERENCES_PROC_MANUAL, IDC_PREFERENCES_PROC_EVERY,
			IDC_PREFERENCES_PROC_EVERY);
		SetDlgItemInt(IDC_PREFERENCES_PROC_SECONDS, App->GetProcessListRefreshTime()/1000);
	}

	GetDlgItem(IDC_PREFERENCES_PROC_SECONDS)->EnableWindow((App->GetProcessListRefreshTime() == INFINITE) ? FALSE : TRUE);
	((CEdit *)GetDlgItem(IDC_PREFERENCES_PROC_SECONDS))->LimitText(MAX_AUTOREFRESH_DIGITS-1);
	((CSpinButtonCtrl*)GetDlgItem(IDC_PREFERENCES_PROC_SPIN))->SetRange(MIN_AUTOREFRESH_VALUE, MAX_AUTOREFRESH_VALUE);

	if(App->GetStatusRefreshTime() == INFINITE) {
		CheckRadioButton(IDC_PREFERENCES_STATUS_MANUAL, IDC_PREFERENCES_STATUS_EVERY, 
			IDC_PREFERENCES_STATUS_MANUAL);
		SetDlgItemInt(IDC_PREFERENCES_STATUS_SECONDS, 1);	
	} else {
		CheckRadioButton(IDC_PREFERENCES_STATUS_MANUAL, IDC_PREFERENCES_STATUS_EVERY,
			IDC_PREFERENCES_STATUS_EVERY);
		SetDlgItemInt(IDC_PREFERENCES_STATUS_SECONDS, App->GetStatusRefreshTime()/1000);
	}

	GetDlgItem(IDC_PREFERENCES_STATUS_SECONDS)->EnableWindow((App->GetStatusRefreshTime() == INFINITE) ? FALSE : TRUE);
	((CEdit *)GetDlgItem(IDC_PREFERENCES_STATUS_SECONDS))->LimitText(MAX_AUTOREFRESH_DIGITS-1);
	((CSpinButtonCtrl*)GetDlgItem(IDC_PREFERENCES_STATUS_SPIN))->SetRange(MIN_AUTOREFRESH_VALUE, MAX_AUTOREFRESH_VALUE);

	CheckDlgButton(IDC_PREFERENCES_CONFIRM, App->AskConfirmation() ? TRUE : FALSE);
    CheckDlgButton(IDC_PREFERENCES_SAVE, App->SavePreferences() ? TRUE : FALSE);
    CheckDlgButton(IDC_PREFERENCES_PERSISTENT, pDoc->AreConnectionsPersistent() ? TRUE : FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CPreferencesDlg::OnOK() 
{
	// TODO: Add extra validation here
	CWinAdminApp *App = (CWinAdminApp*)AfxGetApp();
    CWinAdminDoc *pDoc = (CWinAdminDoc*)App->GetDocument();

	ULONG value;

	if(((CButton*)GetDlgItem(IDC_PREFERENCES_PROC_MANUAL))->GetCheck()) {
		App->SetProcessListRefreshTime(INFINITE);
		// Tell the document that it has changed so
		// that he can wakeup the process thread
		((CWinAdminDoc*)App->GetDocument())->ProcessListRefreshChanged(INFINITE);
	} else {
		value = GetDlgItemInt(IDC_PREFERENCES_PROC_SECONDS);

		if((value < MIN_AUTOREFRESH_VALUE) || (value > MAX_AUTOREFRESH_VALUE)) {
			// Invalid automatic refresh value
			CString MessageString;
			CString TitleString;
			CString FormatString;
	
			TitleString.LoadString(AFX_IDS_APP_TITLE);
			FormatString.LoadString(IDS_REFRESH_RANGE);
			
			MessageString.Format(FormatString, MIN_AUTOREFRESH_VALUE,
					MAX_AUTOREFRESH_VALUE);
			MessageBox(MessageString, TitleString, MB_ICONEXCLAMATION | MB_OK);

            GetDlgItem(IDC_PREFERENCES_PROC_SECONDS)->SetFocus();
            return;
        } else {
			// Has the value changed
			BOOL bChanged = FALSE;
			if(value*1000 != App->GetProcessListRefreshTime())
				bChanged = TRUE;
            //Save value in member variable as msec.
            App->SetProcessListRefreshTime(value * 1000);
			// Tell the document that it has changed so
			// that he can wakeup the process thread
			if(bChanged) {
				((CWinAdminDoc*)App->GetDocument())->ProcessListRefreshChanged(value * 1000);
			}
        }
	}

	if(((CButton*)GetDlgItem(IDC_PREFERENCES_STATUS_MANUAL))->GetCheck()) {
		App->SetStatusRefreshTime(INFINITE);
	} else {
		value = GetDlgItemInt(IDC_PREFERENCES_STATUS_SECONDS);

		if((value < MIN_AUTOREFRESH_VALUE) || (value > MAX_AUTOREFRESH_VALUE)) {
			// Invalid automatic refresh value
			CString MessageString;
			CString TitleString;
			CString FormatString;
	
			TitleString.LoadString(AFX_IDS_APP_TITLE);
			FormatString.LoadString(IDS_REFRESH_RANGE);
			
			MessageString.Format(FormatString, MIN_AUTOREFRESH_VALUE,
					MAX_AUTOREFRESH_VALUE);
			MessageBox(MessageString, TitleString, MB_ICONEXCLAMATION | MB_OK);

            GetDlgItem(IDC_PREFERENCES_STATUS_SECONDS)->SetFocus();
            return;
        } else {
            //Save value in member variable as msec.
            App->SetStatusRefreshTime(value * 1000);
        }
	}

    App->SetConfirmation(((CButton *)GetDlgItem(IDC_PREFERENCES_CONFIRM))->GetCheck());
    App->SetSavePreferences(((CButton *)GetDlgItem(IDC_PREFERENCES_SAVE))->GetCheck());
    pDoc->SetConnectionsPersistent(((CButton *)GetDlgItem(IDC_PREFERENCES_PERSISTENT))->GetCheck());

	CDialog::OnOK();
}


void CPreferencesDlg::OnClose() 
{
	// TODO: Add your message handler code here and/or call default
	
	CDialog::OnClose();
}


void CPreferencesDlg::OnPreferencesProcManual() 
{	
	// TODO: Add your control notification handler code here
	GetDlgItem(IDC_PREFERENCES_PROC_SECONDS)->EnableWindow(FALSE);
}


void CPreferencesDlg::OnPreferencesProcEvery() 
{
	// TODO: Add your control notification handler code here
	GetDlgItem(IDC_PREFERENCES_PROC_SECONDS)->EnableWindow(TRUE);
}


void CPreferencesDlg::OnPreferencesStatusEvery() 
{
	// TODO: Add your control notification handler code here
	GetDlgItem(IDC_PREFERENCES_STATUS_SECONDS)->EnableWindow(TRUE);
}


void CPreferencesDlg::OnPreferencesStatusManual() 
{
	// TODO: Add your control notification handler code here
	GetDlgItem(IDC_PREFERENCES_STATUS_SECONDS)->EnableWindow(FALSE);	
}


BOOL CPreferencesDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	// TODO: Add your message handler code here and/or call default
	//((CWinAdminApp*)AfxGetApp())->WinHelp(HID_BASE_CONTROL + pHelpInfo->iCtrlId, HELP_CONTEXTPOPUP);
	if(pHelpInfo->iContextType == HELPINFO_WINDOW) 
	{
		if(pHelpInfo->iCtrlId != IDC_STATIC)
		{
	         ::WinHelp((HWND)pHelpInfo->hItemHandle,ID_HELP_FILE,HELP_WM_HELP,(ULONG_PTR)(LPVOID)aMenuHelpIDs);
		}
	}

	return (TRUE);	

}


/////////////////////////////////////////////////////////////////////////////
// CStatusDlg dialog


CStatusDlg::CStatusDlg(CWinStation *pWinStation, UINT Id, CWnd* pParent /*=NULL*/)
	: CDialog(Id, pParent)
{
	m_pWinStation = pWinStation;
	//{{AFX_DATA_INIT(CStatusDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


BEGIN_MESSAGE_MAP(CStatusDlg, CDialog)
	//{{AFX_MSG_MAP(CStatusDlg)
	ON_MESSAGE(WM_STATUSSTART, OnStatusStart)
    ON_MESSAGE(WM_STATUSREADY, OnStatusReady)
    ON_MESSAGE(WM_STATUSABORT, OnStatusAbort)
    ON_MESSAGE(WM_STATUSREFRESHNOW, OnRefreshNow)
	ON_BN_CLICKED(IDC_RESETCOUNTERS, OnResetcounters)
	ON_BN_CLICKED(IDC_REFRESHNOW, OnClickedRefreshnow)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStatusDlg message handlers

BOOL CStatusDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

    /*
     * Fetch current (big) size of dialog, then calculate the window size
     * needed to show the 'little' version of the dialog.  Then, size the
     * window to the little version size and set the size flag to indicate
     * that we're 'little'.
     */
	RECT rectBigSize, rectLittleSize;

    GetWindowRect(&rectBigSize);
    m_BigSize.cx = (rectBigSize.right - rectBigSize.left) + 1;
    m_BigSize.cy = (rectBigSize.bottom - rectBigSize.top) + 1;

	// Some status dialogs don't have "More Info"
    CWnd *pWnd = GetDlgItem(IDC_MOREINFO);
	if(pWnd) {
		pWnd->GetWindowRect(&rectLittleSize);

	    m_LittleSize.cx = m_BigSize.cx;
		m_LittleSize.cy = (rectLittleSize.bottom - rectBigSize.top) + 10;

		SetWindowPos( NULL, 0, 0, m_LittleSize.cx, m_LittleSize.cy,
			          SWP_NOMOVE | SWP_NOZORDER );
		m_bWeAreLittle = TRUE;
	}

#if 0
    /*
     * Disable the 'reset counters' button if we're read-only, and set the
     * 'reset counters' flag to FALSE;
     */
    if ( m_bReadOnly )
        GetDlgItem(IDC_RESETCOUNTERS)->EnableWindow(FALSE);
    
#endif
    /*
     * Create CWSStatusThread, intialize its member variables, and start it up.
     */
	m_pWSStatusThread = new CWSStatusThread;
    if(m_pWSStatusThread) {
	    m_pWSStatusThread->m_LogonId = m_pWinStation->GetLogonId();
	    m_pWSStatusThread->m_hServer = m_pWinStation->GetServer()->GetHandle();
	    m_pWSStatusThread->m_hDlg = m_hWnd;
	    VERIFY(m_pWSStatusThread->CreateThread());
    }

    m_bResetCounters = FALSE;

	GetDlgItem(IDC_COMMON_ICOMPRESSIONRATIO2)->ShowWindow(SW_HIDE);
	GetDlgItem(IDC_COMMON_OCOMPRESSIONRATIO2)->ShowWindow(SW_HIDE);
	GetDlgItem(IDC_COMMON_IPERCENTFRAMEERRORS2)->ShowWindow(SW_HIDE);
	GetDlgItem(IDC_COMMON_OPERCENTFRAMEERRORS2)->ShowWindow(SW_HIDE);

    // If we don't have Reliable Pd loaded, default error fields to 'N/A'
    // (m_szICompressionRatio got initialized to the 'n/a' string)...
    if(!m_bReliable) {
        SetDlgItemText(IDC_COMMON_IFRAMEERRORS, m_szICompressionRatio);
        SetDlgItemText(IDC_COMMON_OFRAMEERRORS, m_szICompressionRatio);
        SetDlgItemText(IDC_COMMON_IPERCENTFRAMEERRORS, m_szICompressionRatio);
        SetDlgItemText(IDC_COMMON_OPERCENTFRAMEERRORS, m_szICompressionRatio);
        SetDlgItemText(IDC_COMMON_ITIMEOUTERRORS, m_szICompressionRatio);
        SetDlgItemText(IDC_COMMON_OTIMEOUTERRORS, m_szICompressionRatio);
    }

    // Default the Compression Ratio fields to 'N/A'.
    SetDlgItemText(IDC_COMMON_ICOMPRESSIONRATIO, m_szICompressionRatio);
    SetDlgItemText(IDC_COMMON_OCOMPRESSIONRATIO, m_szICompressionRatio);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CStatusDlg::SetInfoFields( PWINSTATIONINFORMATION pCurrent,
                             PWINSTATIONINFORMATION pNew )
{
    /*
     * If the 'reset counters' flag is set, 1-fill the current Input and Output
     * PROTOCOLCOUNTERS structures (to force all fields to update), copy the
     * pNew PROTOCOLSTATUS information into the global m_BaseStatus structure,
     * and reset the flag.
     */
    if(m_bResetCounters) {
        memset(&pCurrent->Status.Input, 0xff, sizeof(pCurrent->Status.Input));
        memset(&pCurrent->Status.Output, 0xff, sizeof(pCurrent->Status.Output));
        m_BaseStatus = pNew->Status;
        m_bResetCounters = FALSE;
    }

    /*
     * Set title and determine Pds loaded if change in connect state.
     */
    if(pCurrent->ConnectState != pNew->ConnectState)  {
        TCHAR szTitle[128];
        CString TitleFormat;
        LPCTSTR pState = NULL;

        TitleFormat.LoadString(IDS_STATUS_FORMAT);

        pState = StrConnectState( pNew->ConnectState, FALSE );
        if(pState)
        {
            wsprintf( szTitle, TitleFormat, pNew->LogonId,pState);
            SetWindowText(szTitle);
        }  

        /*
         * TODO when WinStationGetInformation can return all PDs loaded:
         * Determine Pds that are loaded and set the state of
         * associated flags and field defaults.
         */
    }

    /*
     * Set UserName and WinStationName if change.  We will also
     * set the WinStationName if there was a change in the connect state,
     * even if the WinStationName itself may not have changed, since we
     * represent connected and disconnect WinStationName fields differently.
     */
    if(lstrcmp(pCurrent->UserName, pNew->UserName))
        SetDlgItemText(IDC_COMMON_USERNAME, pNew->UserName);

    if(lstrcmp(pCurrent->WinStationName, pNew->WinStationName) ||
         (pCurrent->ConnectState != pNew->ConnectState)) {

        TCHAR szWSName[WINSTATIONNAME_LENGTH+3];

        if(pNew->ConnectState == State_Disconnected) {

            lstrcpy( szWSName, TEXT("(") );
            lstrcat( szWSName, pNew->WinStationName );
            lstrcat( szWSName, TEXT(")") );

        } else
            lstrcpy( szWSName, pNew->WinStationName );

        SetDlgItemText(IDC_COMMON_WINSTATIONNAME, szWSName);
    }

    /*
     * Set the common Input and Output numeric fields.
     */
    if(pCurrent->Status.Input.Bytes != pNew->Status.Input.Bytes)
        SetDlgItemInt(IDC_COMMON_IBYTES,
                                pNew->Status.Input.Bytes -
                                    m_BaseStatus.Input.Bytes,
                                FALSE);
    if(pCurrent->Status.Output.Bytes != pNew->Status.Output.Bytes)
        SetDlgItemInt(IDC_COMMON_OBYTES,
                                pNew->Status.Output.Bytes -
                                    m_BaseStatus.Output.Bytes,
                                FALSE);

    if(pCurrent->Status.Input.Frames != pNew->Status.Input.Frames)
        SetDlgItemInt(IDC_COMMON_IFRAMES,
                                pNew->Status.Input.Frames -
                                    m_BaseStatus.Input.Frames,
                                FALSE);
    if(pCurrent->Status.Output.Frames != pNew->Status.Output.Frames)
        SetDlgItemInt(IDC_COMMON_OFRAMES,
                                pNew->Status.Output.Frames -
                                    m_BaseStatus.Output.Frames,
                                FALSE);

    if((pCurrent->Status.Input.Bytes != pNew->Status.Input.Bytes) ||
         (pCurrent->Status.Input.Frames != pNew->Status.Input.Frames)) {

        UINT temp;

        temp = (pNew->Status.Input.Frames - m_BaseStatus.Input.Frames) ?
                ((pNew->Status.Input.Bytes - m_BaseStatus.Input.Bytes) /
                 (pNew->Status.Input.Frames - m_BaseStatus.Input.Frames)) : 0;

        if(temp != m_IBytesPerFrame)
            SetDlgItemInt(IDC_COMMON_IBYTESPERFRAME,
                                    m_IBytesPerFrame = temp, FALSE);
    }
    if((pCurrent->Status.Output.Bytes != pNew->Status.Output.Bytes) ||
         (pCurrent->Status.Output.Frames != pNew->Status.Output.Frames)) {

        UINT temp;

        temp = (pNew->Status.Output.Frames - m_BaseStatus.Output.Frames) ?
                ((pNew->Status.Output.Bytes - m_BaseStatus.Output.Bytes) /
                 (pNew->Status.Output.Frames - m_BaseStatus.Output.Frames)) : 0;

        if(temp != m_OBytesPerFrame)
            SetDlgItemInt( IDC_COMMON_OBYTESPERFRAME,
                                    m_OBytesPerFrame = temp, FALSE);
    }

    if(m_bReliable) {

        if(pCurrent->Status.Input.Errors != pNew->Status.Input.Errors)
            SetDlgItemInt(IDC_COMMON_IFRAMEERRORS,
                                    pNew->Status.Input.Errors -
                                        m_BaseStatus.Input.Errors,
                                    FALSE);
        if(pCurrent->Status.Output.Errors != pNew->Status.Output.Errors)
            SetDlgItemInt(IDC_COMMON_OFRAMEERRORS,
                                    pNew->Status.Output.Errors -
                                        m_BaseStatus.Output.Errors,
                                    FALSE);

        if((pCurrent->Status.Input.Frames != pNew->Status.Input.Frames) ||
             (pCurrent->Status.Input.Errors != pNew->Status.Input.Errors)) {

            TCHAR szTemp[10];
            int q, r;

            if((pNew->Status.Input.Errors - m_BaseStatus.Input.Errors) &&
                 (pNew->Status.Input.Frames - m_BaseStatus.Input.Frames)) {
                double temp;

                temp = ((double)(pNew->Status.Input.Errors - m_BaseStatus.Input.Errors) * 100.0)
                        / (double)(pNew->Status.Input.Frames - m_BaseStatus.Input.Frames);
                q = (int)temp;
                if ( (r = (int)((temp - (double)q) * 100.0)) == 0 )
                    r = 1;

            } else {
                /*
                 * Special case for 0 frames or 0 errors.
                 */
                q = 0;
                r = 0;
            }
            lstrnprintf(szTemp, 10, TEXT("%d.%02d%%"), q, r);

            /*
             * Only output if changed from previous.
             */
            if(lstrcmp(szTemp, m_szIPercentFrameErrors)) {
                lstrcpy(m_szIPercentFrameErrors, szTemp);
        		GetDlgItem(IDC_COMMON_IPERCENTFRAMEERRORS)->ShowWindow(SW_HIDE);
        		GetDlgItem(IDC_COMMON_IPERCENTFRAMEERRORS2)->ShowWindow(SW_SHOW);
                SetDlgItemText(IDC_COMMON_IPERCENTFRAMEERRORS2, szTemp);
            }
        }

        if((pCurrent->Status.Output.Frames != pNew->Status.Output.Frames) ||
             (pCurrent->Status.Output.Errors != pNew->Status.Output.Errors)) {

            TCHAR szTemp[10];
            int q, r;

            if((pNew->Status.Output.Errors - m_BaseStatus.Output.Errors) &&
                 (pNew->Status.Output.Frames - m_BaseStatus.Output.Frames)) {
                double temp;

                temp = ((double)(pNew->Status.Output.Errors - m_BaseStatus.Output.Errors) * 100.0)
                        / (double)(pNew->Status.Output.Frames - m_BaseStatus.Output.Frames);
                q = (int)temp;
                if ( (r = (int)((temp - (double)q) * 100.0)) == 0 )
                    r = 1;

            } else {
                /*
                 * Special case for 0 frames or 0 errors.
                 */
                q = 0;
                r = 0;
            }
            lstrnprintf(szTemp, 10, TEXT("%d.%02d%%"), q, r);

            /*
             * Only output if changed from previous.
             */
            if(lstrcmp(szTemp, m_szOPercentFrameErrors)) {
                lstrcpy(m_szOPercentFrameErrors, szTemp);
        		GetDlgItem(IDC_COMMON_OPERCENTFRAMEERRORS)->ShowWindow(SW_HIDE);
        		GetDlgItem(IDC_COMMON_OPERCENTFRAMEERRORS2)->ShowWindow(SW_SHOW);
                SetDlgItemText(IDC_COMMON_OPERCENTFRAMEERRORS2, szTemp);
            }
        }

        if(pCurrent->Status.Input.Timeouts != pNew->Status.Input.Timeouts)
            SetDlgItemInt(IDC_COMMON_ITIMEOUTERRORS,
                                    pNew->Status.Input.Timeouts -
                                        m_BaseStatus.Input.Timeouts,
										FALSE);
        if(pCurrent->Status.Output.Timeouts != pNew->Status.Output.Timeouts)
            SetDlgItemInt(IDC_COMMON_OTIMEOUTERRORS,
                                    pNew->Status.Output.Timeouts -
                                        m_BaseStatus.Output.Timeouts,
                                    FALSE);
    }

    /*
     * NOTE: for these compression ratio calculations, the "CompressedBytes" field is
     * actually 'Bytes before compression', that is, it is the byte count in the middle
     * of the WD/PD stack.  "WdBytes" are the bytes input/output at the app level (and is
     * not displayed in any WinAdmin counters).  "CompressedBytes" include any overhead
     * bytes added by the stack.  "Bytes" represent the actual number of bytes input/output
     * over the 'wire'; hence, we use Bytes for all counter display and "CompressedBytes" to
     * calculate compression ratios.
     */
    if((pNew->Status.Input.CompressedBytes || m_BaseStatus.Input.CompressedBytes) &&
         ((pCurrent->Status.Input.Bytes != pNew->Status.Input.Bytes) ||
          (pCurrent->Status.Input.CompressedBytes != pNew->Status.Input.CompressedBytes)) ) {

        TCHAR szTemp[10];
        int q, r;

        if((pNew->Status.Input.CompressedBytes - m_BaseStatus.Input.CompressedBytes)) {
            double temp;

            temp = (double)(pNew->Status.Input.CompressedBytes -
                            m_BaseStatus.Input.CompressedBytes) /
                   (double)(pNew->Status.Input.Bytes - m_BaseStatus.Input.Bytes);
            q = (int)temp;
            r = (int)((temp - (double)q) * 100.0);

        } else {
            /*
             * Special case for 0 compressed bytes (compression turned off or counters reset).
             */
            q = 0;
            r = 0;
        }
        lstrnprintf(szTemp, 10, TEXT("%d.%02d"), q, r);

        /*
         * Only output if changed from previous.
         */
        if(lstrcmp(szTemp, m_szICompressionRatio)) {
            lstrcpy(m_szICompressionRatio, szTemp);
        	GetDlgItem(IDC_COMMON_ICOMPRESSIONRATIO)->ShowWindow(SW_HIDE);
        	GetDlgItem(IDC_COMMON_ICOMPRESSIONRATIO2)->ShowWindow(SW_SHOW);
            SetDlgItemText(IDC_COMMON_ICOMPRESSIONRATIO2, szTemp);
        }
    }

    if((pNew->Status.Output.CompressedBytes || m_BaseStatus.Output.CompressedBytes) &&
         ((pCurrent->Status.Output.Bytes != pNew->Status.Output.Bytes) ||
          (pCurrent->Status.Output.CompressedBytes != pNew->Status.Output.CompressedBytes))) {

        TCHAR szTemp[10];
        int q, r;

        if((pNew->Status.Output.CompressedBytes - m_BaseStatus.Output.CompressedBytes)) {
            double temp;

            temp = (double)(pNew->Status.Output.CompressedBytes -
                            m_BaseStatus.Output.CompressedBytes) /
                   (double)(pNew->Status.Output.Bytes - m_BaseStatus.Output.Bytes);
            q = (int)temp;
            r = (int)((temp - (double)q) * 100.0);

        } else {
            /*
             * Special case for 0 compressed bytes (compression turned off or counters reset).
             */
            q = 0;
            r = 0;
        }
        lstrnprintf(szTemp, 10, TEXT("%d.%02d"), q, r);

        /*
         * Only output if changed from previous.
         */
        if(lstrcmp(szTemp, m_szOCompressionRatio)) {
            lstrcpy(m_szOCompressionRatio, szTemp);
        	GetDlgItem(IDC_COMMON_OCOMPRESSIONRATIO)->ShowWindow(SW_HIDE);
        	GetDlgItem(IDC_COMMON_OCOMPRESSIONRATIO2)->ShowWindow(SW_SHOW);
            SetDlgItemText(IDC_COMMON_OCOMPRESSIONRATIO2, szTemp);
        }
    }

}  // end CStatusDlg::SetInfoFields


void CStatusDlg::InitializeStatus()
{
    
	// Initialize structures and variables.
    memset( &m_WSInfo, 0xff, sizeof(m_WSInfo) );
    memset( &m_BaseStatus, 0, sizeof(m_BaseStatus) );
    m_IBytesPerFrame = m_OBytesPerFrame = INFINITE;
    lstrcpy(m_szICompressionRatio, TEXT("n/a"));
    lstrcpy(m_szOCompressionRatio, m_szICompressionRatio);

	// If this WinStation does not have a Reliable PD loaded,
	// set flag to skip those counters.
    PDPARAMS PdParams;
    ULONG ReturnLength;

    PdParams.SdClass = SdReliable;
    if (!WinStationQueryInformation(m_pWinStation->GetServer()->GetHandle(),
                                      m_pWinStation->GetLogonId(),
                                      WinStationPdParams,
                                      &PdParams, sizeof(PdParams),
                                      &ReturnLength ) ||
         (PdParams.SdClass != SdReliable) ) {
        m_bReliable = FALSE;
    } else {
        m_bReliable = TRUE;
    }

}  // end CStatusDlg::InitializeStatus

void CStatusDlg::OnCancel() 
{
	// TODO: Add extra cleanup here
    m_pWSStatusThread->ExitThread();	
	CDialog::OnCancel();
}

void CStatusDlg::OnResetcounters() 
{
	// TODO: Add your control notification handler code here
    m_bResetCounters = TRUE;
    OnClickedRefreshnow();
	
}

void CStatusDlg::OnClickedRefreshnow() 
{
	// TODO: Add your control notification handler code here
    /*
     * Tell the status thread to wake up now.
     */
    m_pWSStatusThread->SignalWakeUp();

//	return(0);
	
}


void CStatusDlg::PostNcDestroy()
{
	CDialog::PostNcDestroy();

	delete this;
}

BOOL CStatusDlg::PreTranslateMessage(MSG *pMsg)
{
    if ( IsDialogMessage(pMsg) )
        return(TRUE);
    else
        return( CDialog::PreTranslateMessage(pMsg) );

}  // end CStatusDlg::PreTranslateMessage


/*******************************************************************************
 *
 *  OnRefreshNow - CWSStatusDlg member function: command
 *
 *      Processes in response to main frame's WM_STATUSREFRESHNOW notification
 *      that the user has changed the status refresh options.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CStatusDlg::OnRefreshNow( WPARAM wParam,
                            LPARAM lParam )
{
    /*
     * Tell the status thread to wake up now.
     */
    m_pWSStatusThread->SignalWakeUp();

    return(0);

}  // end CWSStatusDlg::OnRefreshNow


/*******************************************************************************
 *
 *  OnStatusStart - CWSStatusDlg member function: command
 *
 *      Process the WM_STATUSSTART message to initialize the 'static'
 *      PD-related fields.
 *
 *      NOTE: the derived class must override this function to process any
 *      PD-related fields as necessary, then call / return this function.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) returns the result of the OnStatusReady member function,
 *          which is always 0, indicating operation complete.
 *
 ******************************************************************************/

LRESULT
CStatusDlg::OnStatusStart( WPARAM wParam,
                             LPARAM lParam )
{
    /*
     * Call / return the OnStatusReady function to update the standard dialog
     * info fields.
     */
    return ( OnStatusReady( wParam, lParam ) );

}  // end CWSStatusDlg::OnStatusStart


/*******************************************************************************
 *
 *  OnStatusReady - CWSStatusDlg member function: command
 *
 *      Process the WM_STATUSREADY message to update the dialog Info fields.
 *
 *      NOTE: the derived class must override this function to call it's
 *      override of the SetInfoFields function, which could then call / return
 *      this function or completely override all functionality contained here.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CStatusDlg::OnStatusReady( WPARAM wParam,
                             LPARAM lParam )
{
    /*
     * Update dialog fields with information from the CWStatusThread's
     * WINSTATIONINFORMATION structure.
     */
    SetInfoFields( &m_WSInfo, &(m_pWSStatusThread->m_WSInfo) );

    /*
     * Set our working WSInfo structure to the new one and signal the thread
     * that we're done.
     */
    m_WSInfo = m_pWSStatusThread->m_WSInfo;
    m_pWSStatusThread->SignalConsumed();

    return(0);

}  // end CWSStatusDlg::OnStatusReady


/*******************************************************************************
 *
 *  OnStatusAbort - CWSStatusDlg member function: command
 *
 *      Process the WM_STATUSABORT message to exit the thread and dialog.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CStatusDlg::OnStatusAbort( WPARAM wParam,
                             LPARAM lParam )
{
    /*
     * Call the OnCancel() member function to exit dialog and thread and
     * perform proper cleanup.
     */
    OnCancel();

    return(0);

}  // end CWSStatusDlg::OnStatusAbort


/////////////////////////////////////////////////////////////////////////////
// CAsyncStatusDlg dialog


CAsyncStatusDlg::CAsyncStatusDlg(CWinStation *pWinStation, CWnd* pParent /*=NULL*/)
	: CStatusDlg(pWinStation, CAsyncStatusDlg::IDD, pParent),
    m_hRedBrush(NULL),
    m_LEDToggleTimer(0)
{
	//{{AFX_DATA_INIT(CAsyncStatusDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	    int i;

    /*
     * Initialize member variables, our local status storage,
     * and create a modeless dialog.
     */
//    m_LogonId = LogonId;
//	  m_bReadOnly = bReadOnly;
    InitializeStatus();

    /*
     * Create a solid RED brush for painting the 'LED's when 'on'.
     */
    VERIFY( m_hRedBrush = CreateSolidBrush(RGB(255,0,0)) );

    /*
     * Create the led objects (must do BEFORE dialog create).
     */
    for ( i = 0; i < NUM_LEDS; i++ )
        m_pLeds[i] = new CLed(m_hRedBrush);

    /*
     * Finally, create the modeless dialog.
     */
    VERIFY(CStatusDlg::Create(IDD_ASYNC_STATUS));
}


/*******************************************************************************
 *
 *  ~CAsyncStatusDlg - CAsyncStatusDlg destructor
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CDialog::~CDialog documentation)
 *
 ******************************************************************************/

CAsyncStatusDlg::~CAsyncStatusDlg()
{
    int i;

    /*
     * Zap our led objects.
     */
    for ( i = 0; i < NUM_LEDS; i++ )
      if ( m_pLeds[i] )
        delete m_pLeds[i];

}  // end CAsyncStatusDlg::~CAsyncStatusDlg


/*******************************************************************************
 *
 *  InitializeStatus - CAsyncStatusDlg member function: override
 *
 *      Special case reset of the LED states in the WINSTATIONINFORMATION
 *      status structure.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAsyncStatusDlg::InitializeStatus()
{
    /*
     * Call the parent classes' InitializeStatus(), then reset the 'LED'
     * states to all 'off' & 'not toggled'.
     */
    CStatusDlg::InitializeStatus();
    m_WSInfo.Status.AsyncSignal = m_WSInfo.Status.AsyncSignalMask = 0;

}  // end CAsyncStatusDlg::InitializeStatus


/*******************************************************************************
 *
 *  SetInfoFields - CAsyncStatusDlg member function: override
 *
 *      Update the fields in the dialog with new data, if necessary.
 *
 *  ENTRY:
 *      pCurrent (input)
 *          points to WINSTATIONINFORMATION structure containing the current
 *          dialog data.
 *      pNew (input)
 *          points to WINSTATIONINFORMATION structure containing the new
 *          dialog data.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAsyncStatusDlg::SetInfoFields( PWINSTATIONINFORMATION pCurrent,
                                PWINSTATIONINFORMATION pNew )
{
    BOOL    bSetTimer = FALSE;

    /*
     * Call the parent's SetInfoFields().
     */
    CStatusDlg::SetInfoFields( pCurrent, pNew );

    /*
     * Set new LED states if state change, or set up for quick toggle if
     * no state changed, but change(s) were detected since last query.
     */
    if ( (pCurrent->Status.AsyncSignal & MS_DTR_ON) !=
         (pNew->Status.AsyncSignal & MS_DTR_ON) ) {

        pNew->Status.AsyncSignalMask &= ~EV_DTR;
        ((CLed *)GetDlgItem(IDC_ASYNC_DTR))->
            Update(pNew->Status.AsyncSignal & MS_DTR_ON);

    } else if ( pNew->Status.AsyncSignalMask & EV_DTR ) {

        pCurrent->Status.AsyncSignal ^= MS_DTR_ON;

        ((CLed *)GetDlgItem(IDC_ASYNC_DTR))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->Status.AsyncSignal & MS_RTS_ON) !=
         (pNew->Status.AsyncSignal & MS_RTS_ON) ) {

        pNew->Status.AsyncSignalMask &= ~EV_RTS;
        ((CLed *)GetDlgItem(IDC_ASYNC_RTS))->
            Update(pNew->Status.AsyncSignal & MS_RTS_ON);

    } else if ( pNew->Status.AsyncSignalMask & EV_RTS ) {

        pCurrent->Status.AsyncSignal ^= MS_RTS_ON;

        ((CLed *)GetDlgItem(IDC_ASYNC_RTS))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->Status.AsyncSignal & MS_CTS_ON) !=
         (pNew->Status.AsyncSignal & MS_CTS_ON) ) {

        pNew->Status.AsyncSignalMask &= ~EV_CTS;
        ((CLed *)GetDlgItem(IDC_ASYNC_CTS))->
            Update(pNew->Status.AsyncSignal & MS_CTS_ON);

    } else if ( pNew->Status.AsyncSignalMask & EV_CTS ) {

        pCurrent->Status.AsyncSignal ^= MS_CTS_ON;

        ((CLed *)GetDlgItem(IDC_ASYNC_CTS))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->Status.AsyncSignal & MS_RLSD_ON) !=
         (pNew->Status.AsyncSignal & MS_RLSD_ON) ) {

        pNew->Status.AsyncSignalMask &= ~EV_RLSD;
        ((CLed *)GetDlgItem(IDC_ASYNC_DCD))->
            Update(pNew->Status.AsyncSignal & MS_RLSD_ON);

    } else if ( pNew->Status.AsyncSignalMask & EV_RLSD ) {

        pCurrent->Status.AsyncSignal ^= MS_RLSD_ON;

        ((CLed *)GetDlgItem(IDC_ASYNC_DCD))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->Status.AsyncSignal & MS_DSR_ON) !=
         (pNew->Status.AsyncSignal & MS_DSR_ON) ) {

        pNew->Status.AsyncSignalMask &= ~EV_DSR;
        ((CLed *)GetDlgItem(IDC_ASYNC_DSR))->
            Update(pNew->Status.AsyncSignal & MS_DSR_ON);

    } else if ( pNew->Status.AsyncSignalMask & EV_DSR ) {

        pCurrent->Status.AsyncSignal ^= MS_DSR_ON;

        ((CLed *)GetDlgItem(IDC_ASYNC_DSR))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->Status.AsyncSignal & MS_RING_ON) !=
         (pNew->Status.AsyncSignal & MS_RING_ON) ) {

        pNew->Status.AsyncSignalMask &= ~EV_RING;
        ((CLed *)GetDlgItem(IDC_ASYNC_RI))->
            Update(pNew->Status.AsyncSignal & MS_RING_ON);

    } else if ( pNew->Status.AsyncSignalMask & EV_RING ) {

        pCurrent->Status.AsyncSignal ^= MS_RING_ON;

        ((CLed *)GetDlgItem(IDC_ASYNC_RI))->Toggle();

        bSetTimer = TRUE;
    }

    /*
     * Create our led toggle timer if needed.
     */
    if ( bSetTimer && !m_LEDToggleTimer )
        m_LEDToggleTimer = SetTimer( IDD_ASYNC_STATUS,
                                     ASYNC_LED_TOGGLE_MSEC, NULL );

    /*
     * Set ASYNC-specific numeric fields if change.
     */
    if ( pCurrent->Status.Input.AsyncFramingError != pNew->Status.Input.AsyncFramingError )
        SetDlgItemInt( IDC_ASYNC_IFRAMING,
                       pNew->Status.Input.AsyncFramingError - m_BaseStatus.Input.AsyncFramingError,
                       FALSE );
    if ( pCurrent->Status.Output.AsyncFramingError != pNew->Status.Output.AsyncFramingError )
        SetDlgItemInt( IDC_ASYNC_OFRAMING,
                       pNew->Status.Output.AsyncFramingError - m_BaseStatus.Output.AsyncFramingError,
                       FALSE );

    if ( pCurrent->Status.Input.AsyncOverrunError != pNew->Status.Input.AsyncOverrunError )
        SetDlgItemInt( IDC_ASYNC_IOVERRUN,
                       pNew->Status.Input.AsyncOverrunError - m_BaseStatus.Input.AsyncOverrunError,
                       FALSE );
    if ( pCurrent->Status.Output.AsyncOverrunError != pNew->Status.Output.AsyncOverrunError )
        SetDlgItemInt( IDC_ASYNC_OOVERRUN,
                       pNew->Status.Output.AsyncOverrunError - m_BaseStatus.Output.AsyncOverrunError,
                       FALSE );

    if ( pCurrent->Status.Input.AsyncOverflowError != pNew->Status.Input.AsyncOverflowError )
        SetDlgItemInt( IDC_ASYNC_IOVERFLOW,
                       pNew->Status.Input.AsyncOverflowError - m_BaseStatus.Input.AsyncOverflowError,
                       FALSE );
    if ( pCurrent->Status.Output.AsyncOverflowError != pNew->Status.Output.AsyncOverflowError )
        SetDlgItemInt( IDC_ASYNC_OOVERFLOW,
                       pNew->Status.Output.AsyncOverflowError - m_BaseStatus.Output.AsyncOverflowError,
                       FALSE );

    if ( pCurrent->Status.Input.AsyncParityError != pNew->Status.Input.AsyncParityError )
        SetDlgItemInt( IDC_ASYNC_IPARITY,
                       pNew->Status.Input.AsyncParityError - m_BaseStatus.Input.AsyncParityError,
                       FALSE );
    if ( pCurrent->Status.Output.AsyncParityError != pNew->Status.Output.AsyncParityError )
        SetDlgItemInt( IDC_ASYNC_OPARITY,
                       pNew->Status.Output.AsyncParityError - m_BaseStatus.Output.AsyncParityError,
                       FALSE );

}  // end CAsyncStatusDlg::SetInfoFields


void CAsyncStatusDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAsyncStatusDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAsyncStatusDlg, CDialog)
	//{{AFX_MSG_MAP(CAsyncStatusDlg)
		ON_MESSAGE(WM_STATUSSTART, OnStatusStart)
		ON_MESSAGE(WM_STATUSREADY, OnStatusReady)
		ON_MESSAGE(WM_STATUSABORT, OnStatusAbort)
		ON_MESSAGE(WM_STATUSREFRESHNOW, OnRefreshNow)
		ON_BN_CLICKED(IDC_RESETCOUNTERS, OnResetcounters)
		ON_BN_CLICKED(IDC_REFRESHNOW, OnClickedRefreshnow)
		ON_BN_CLICKED(IDC_MOREINFO, OnMoreinfo)
	    ON_WM_TIMER()
		ON_WM_NCDESTROY()
	    ON_WM_HELPINFO()
		ON_COMMAND(ID_HELP,OnCommandHelp)

	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAsyncStatusDlg message handlers
/*******************************************************************************
 *
 *  OnInitDialog - CAsyncStatusDlg member function: command (override)
 *
 *      Performs async-specific dialog intialization.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnInitDialog documentation)
 *
 ******************************************************************************/
static int LedIds[NUM_LEDS] = {
    IDC_ASYNC_DTR,
    IDC_ASYNC_RTS,
    IDC_ASYNC_CTS,
    IDC_ASYNC_DSR,
    IDC_ASYNC_DCD,
    IDC_ASYNC_RI    };

BOOL CAsyncStatusDlg::OnInitDialog()
{
    int i;

    /*
     * Perform parent's OnInitDialog() first.
     */
    CStatusDlg::OnInitDialog();

    /*
     * Subclass the led controls and default to 'off'.
     */
    for ( i = 0; i < NUM_LEDS; i++ ) {
        m_pLeds[i]->Subclass( (CStatic *)GetDlgItem(LedIds[i]) );
        m_pLeds[i]->Update(0);
    }

    return(TRUE);

}  // end CAsyncStatusDlg::OnInitDialog

void CAsyncStatusDlg::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CAsyncStatusDlg::IDD + HID_BASE_RESOURCE);
	return;
}

/*******************************************************************************
 *
 *  OnStatusStart - CAsyncStatusDlg member function: command
 *
 *      Process the WM_STATUSSTART message to initialize the 'static'
 *      PD-related fields.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CAsyncStatusDlg::OnStatusStart( WPARAM wParam,
                                LPARAM lParam )
{
    /*
     * Fetch the PD-specific information from the CWStatusThread's PDCONFIG
     * structure and initialize dialog fields.
     */
    SetDlgItemText( IDC_ASYNC_DEVICE,
                    m_pWSStatusThread->m_PdConfig.Params.Async.DeviceName );
    SetDlgItemInt( IDC_ASYNC_BAUD,
                   m_pWSStatusThread->m_PdConfig.Params.Async.BaudRate,
                   FALSE );

    /*
     * Call / return our OnStatusReady() function.
     */
    return ( OnStatusReady( wParam, lParam ) );

}  // end CAsyncStatusDlg::OnStatusStart


/*******************************************************************************
 *
 *  OnStatusReady - CAsyncStatusDlg member function: command
 *
 *      Process the WM_STATUSREADY message to update the dialog Info fields.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CAsyncStatusDlg::OnStatusReady( WPARAM wParam,
                                LPARAM lParam )
{
    /*
     * If the LED toggle timer is still active now, kill it and flag so.
     */
    if ( m_LEDToggleTimer ) {

        KillTimer(m_LEDToggleTimer);
        m_LEDToggleTimer = 0;
    }

    /*
     * Call / return the parent classes' OnStatusReady() function.
     */
    return (CStatusDlg::OnStatusReady( wParam, lParam ));

}  // end CAsyncStatusDlg::OnStatusReady


/*******************************************************************************
 *
 *  OnTimer - CAsyncStatusDlg member function: command (override)
 *
 *      Used for quick 'LED toggle'.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CWnd::OnTimer documentation)
 *
 ******************************************************************************/

void
CAsyncStatusDlg::OnTimer(UINT nIDEvent)
{
    /*
     * Process this timer event if it it our 'LED toggle' event.
     */
    if ( nIDEvent == m_LEDToggleTimer ) {

        /*
         * Toggle each led that is flagged as 'changed'.
         */
        if ( m_WSInfo.Status.AsyncSignalMask & EV_DTR )
            ((CLed *)GetDlgItem(IDC_ASYNC_DTR))->Toggle();
		
        if ( m_WSInfo.Status.AsyncSignalMask & EV_RTS )
            ((CLed *)GetDlgItem(IDC_ASYNC_RTS))->Toggle();
		
        if ( m_WSInfo.Status.AsyncSignalMask & EV_CTS )
            ((CLed *)GetDlgItem(IDC_ASYNC_CTS))->Toggle();
		
        if ( m_WSInfo.Status.AsyncSignalMask & EV_RLSD )
            ((CLed *)GetDlgItem(IDC_ASYNC_DCD))->Toggle();
		
        if ( m_WSInfo.Status.AsyncSignalMask & EV_DSR )
            ((CLed *)GetDlgItem(IDC_ASYNC_DSR))->Toggle();
		
        if ( m_WSInfo.Status.AsyncSignalMask & EV_RING )
            ((CLed *)GetDlgItem(IDC_ASYNC_RI))->Toggle();
		
        /*
         * Kill this timer event and indicate so.
         */
        KillTimer(m_LEDToggleTimer);
        m_LEDToggleTimer = 0;

    } else
        CDialog::OnTimer(nIDEvent);

}  // end CAsyncStatusDlg::OnTimer


/*******************************************************************************
 *
 *  OnNcDestroy - CAsyncStatusDlg member function: command
 *
 *      Clean up before deleting dialog object.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CWnd::OnNcDestroy documentation)
 *
 ******************************************************************************/

void
CAsyncStatusDlg::OnNcDestroy()
{
    /*
     * Delete the red brush we made.
     */
    DeleteObject(m_hRedBrush);

    /*
     * If the LED toggle timer is still active, kill it.
     */
    if ( m_LEDToggleTimer )
        KillTimer(m_LEDToggleTimer);

    /*
     * Call parent after we've cleaned up.
     */
    CStatusDlg::OnNcDestroy();

}  // end CAsyncStatusDlg::OnNcDestroy

/*******************************************************************************
 *
 *  OnStatusAbort - CWSStatusDlg member function: command
 *
 *      Process the WM_STATUSABORT message to exit the thread and dialog.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CAsyncStatusDlg::OnStatusAbort( WPARAM wParam,
                             LPARAM lParam )
{
    /*
     * Call the OnCancel() member function to exit dialog and thread and
     * perform proper cleanup.
     */
    OnCancel();

    return(0);

}  // end CWSStatusDlg::OnStatusAbort


void CAsyncStatusDlg::OnResetcounters() 
{
	// TODO: Add your control notification handler code here
    m_bResetCounters = TRUE;
    OnClickedRefreshnow();
	
}

void CAsyncStatusDlg::OnClickedRefreshnow() 
{
	// TODO: Add your control notification handler code here
    /*
     * Tell the status thread to wake up now.
     */
    m_pWSStatusThread->SignalWakeUp();

//	return(0);
	
}

void CAsyncStatusDlg::OnMoreinfo() 
{
	// TODO: Add your control notification handler code here
	CString ButtonText;

    if(m_bWeAreLittle)  {
         // We are now little size: go to big size.
        SetWindowPos(NULL, 0, 0, m_BigSize.cx, m_BigSize.cy,
                      SWP_NOMOVE | SWP_NOZORDER);

        ButtonText.LoadString(IDS_LESSINFO);
        SetDlgItemText(IDC_MOREINFO, ButtonText);

        m_bWeAreLittle = FALSE;

    } else {
        // We are now big size: go to little size.
        SetWindowPos( NULL, 0, 0, m_LittleSize.cx, m_LittleSize.cy,
                      SWP_NOMOVE | SWP_NOZORDER);

        ButtonText.LoadString(IDS_MOREINFO);
        SetDlgItemText(IDC_MOREINFO, ButtonText);

        m_bWeAreLittle = TRUE;
    }

}

/*******************************************************************************
 *
 *  OnRefreshNow - CWSStatusDlg member function: command
 *
 *      Processes in response to main frame's WM_STATUSREFRESHNOW notification
 *      that the user has changed the status refresh options.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CAsyncStatusDlg::OnRefreshNow( WPARAM wParam,
                            LPARAM lParam )
{
    /*
     * Tell the status thread to wake up now.
     */
    m_pWSStatusThread->SignalWakeUp();

    return(0);

}  // end CWSStatusDlg::OnRefreshNow


BOOL CAsyncStatusDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	// TODO: Add your message handler code here and/or call default
	//((CWinAdminApp*)AfxGetApp())->WinHelp(HID_BASE_CONTROL + pHelpInfo->iCtrlId, HELP_CONTEXTPOPUP);
	if(pHelpInfo->iContextType == HELPINFO_WINDOW) 
	{
		if(pHelpInfo->iCtrlId != IDC_STATIC)
		{
	         ::WinHelp((HWND)pHelpInfo->hItemHandle,ID_HELP_FILE,HELP_WM_HELP,(ULONG_PTR)(LPVOID)aMenuHelpIDs);
		}
	}

	return (TRUE);			

}

/////////////////////////////////////////////////////////////////////////////
// CNetworkStatusDlg dialog


CNetworkStatusDlg::CNetworkStatusDlg(CWinStation *pWinStation, CWnd* pParent /*=NULL*/)
	: CStatusDlg(pWinStation, CNetworkStatusDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNetworkStatusDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    InitializeStatus();

    VERIFY( CStatusDlg::Create(IDD_NETWORK_STATUS) );
}


void CNetworkStatusDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNetworkStatusDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNetworkStatusDlg, CDialog)
	//{{AFX_MSG_MAP(CNetworkStatusDlg)
	ON_MESSAGE(WM_STATUSSTART, OnStatusStart)
    ON_MESSAGE(WM_STATUSREADY, OnStatusReady)
    ON_MESSAGE(WM_STATUSABORT, OnStatusAbort)
    ON_MESSAGE(WM_STATUSREFRESHNOW, OnRefreshNow)
	ON_BN_CLICKED(IDC_RESETCOUNTERS, OnResetcounters)
	ON_BN_CLICKED(IDC_REFRESHNOW, OnClickedRefreshnow)
	ON_BN_CLICKED(IDC_MOREINFO, OnMoreinfo)
	ON_WM_HELPINFO()
	ON_COMMAND(ID_HELP,OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNetworkStatusDlg message handlers
/*******************************************************************************
 *
 *  OnStatusStart - CNetworkStatusDlg member function: command
 *
 *      Process the WM_STATUSSTART message to initialize the 'static'
 *      PD-related fields.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CNetworkStatusDlg::OnStatusStart( WPARAM wParam,
                                  LPARAM lParam )
{
    DEVICENAME DeviceName;
    PDCONFIG3 PdConfig3;
    LONG Status;
    ULONG ByteCount;
    HANDLE hServer;

    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
    if(pDoc->IsInShutdown()) return 0;

    if(m_pWinStation->GetSdClass() == SdOemTransport) {
        CString LabelString;
        LabelString.LoadString(IDS_DEVICE);
        SetDlgItemText(IDC_LABEL, LabelString);

        ULONG Length;
        PDCONFIG PdConfig;

        if(Status = WinStationQueryInformation(m_pWinStation->GetServer()->GetHandle(),
                            m_pWinStation->GetLogonId(),
                            WinStationPd,
                            &PdConfig,
                            sizeof(PDCONFIG),
                            &Length)) {
                wcscpy(DeviceName, PdConfig.Params.OemTd.DeviceName);
        }
    } else {
        /*
        * Fetch the registry configuration for the PD specified in the
        * CWStatusThread's PDCONFIG structure and initialize dialog fields.
        */
        hServer = RegOpenServer(m_pWinStation->GetServer()->IsCurrentServer() ? NULL : m_pWinStation->GetServer()->GetName());

        PWDNAME pWdRegistryName = m_pWinStation->GetWdRegistryName();

        if (!pWdRegistryName || (Status = RegPdQuery(hServer, 
                                pWdRegistryName,
                                TRUE,
                                m_pWSStatusThread->m_PdConfig.Create.PdName,
                                &PdConfig3, sizeof(PDCONFIG3), &ByteCount)) ) {

            // We don't currently look at the registry names on remote servers.
            // If ICA is in use on the remote server and not on this server,
            // we won't have a registry name - try "wdica" and "icawd"
            if(m_pWinStation->IsICA()) {
                if(Status = RegPdQuery(hServer, 
                                TEXT("icawd"),
                                TRUE,
                                m_pWSStatusThread->m_PdConfig.Create.PdName,
                                &PdConfig3, sizeof(PDCONFIG3), &ByteCount) ) {
                
                    Status = RegPdQuery(hServer, 
                                    TEXT("wdica"),
                                    TRUE,
                                    m_pWSStatusThread->m_PdConfig.Create.PdName,
                                    &PdConfig3, sizeof(PDCONFIG3), &ByteCount);
                }
            } 
                
            if(Status) memset(&PdConfig3, 0, sizeof(PDCONFIG3));
        }

        ULONG Length = 0;
        PWSTR pLanAdapter = NULL;
        //
        // Try the new interface first (NT5 server ?)
        //
        if (WinStationGetLanAdapterName(m_pWinStation->GetServer()->GetHandle(),
                                m_pWSStatusThread->m_PdConfig.Params.Network.LanAdapter,
                                (lstrlen(m_pWSStatusThread->m_PdConfig.Create.PdName) + 1) * sizeof(WCHAR),
                                m_pWSStatusThread->m_PdConfig.Create.PdName,
                                &Length,
                                &pLanAdapter))
        {
            //NT5 Server
            SetDlgItemText( IDC_NETWORK_LANADAPTER, pLanAdapter );
            if(pLanAdapter)
            {
                WinStationFreeMemory(pLanAdapter);
            }
        }
        else
        {
            //
            //   Check the return code indicating that the interface is not available.
            //
            DWORD dwError = GetLastError();
            if (dwError != RPC_S_PROCNUM_OUT_OF_RANGE)
            {
                //Error getting Name. 
                SetDlgItemText( IDC_NETWORK_LANADAPTER, GetUnknownString());
            }
            else    // maybe a Hydra 4 server ?
            {

                if (RegGetNetworkDeviceName(hServer, &PdConfig3, &(m_pWSStatusThread->m_PdConfig.Params),
                                             DeviceName, DEVICENAME_LENGTH +1 ) == ERROR_SUCCESS) 
                {
                    SetDlgItemText( IDC_NETWORK_LANADAPTER, DeviceName );
                    
                }
                else
                {
                    //Error
                    SetDlgItemText( IDC_NETWORK_LANADAPTER, GetUnknownString());
                }
            }
        }

        RegCloseServer(hServer);
    }

    /*
     * Call / return parent classes' OnStatusStart().
     */
    return ( CStatusDlg::OnStatusStart( wParam, lParam ) );

}  // end CNetworkStatusDlg::OnStatusStart


void CNetworkStatusDlg::OnResetcounters() 
{
    // TODO: Add your control notification handler code here
    m_bResetCounters = TRUE;
    OnClickedRefreshnow();
    
}

void CNetworkStatusDlg::OnClickedRefreshnow() 
{
    // TODO: Add your control notification handler code here
    /*
     * Tell the status thread to wake up now.
     */
    m_pWSStatusThread->SignalWakeUp();

//  return(0);
    
}

void CNetworkStatusDlg::OnMoreinfo() 
{
    // TODO: Add your control notification handler code here
    
}
void CNetworkStatusDlg::OnCommandHelp(void)
{
    AfxGetApp()->WinHelp(CNetworkStatusDlg::IDD + HID_BASE_RESOURCE);
    return;
}


/*******************************************************************************
 *
 *  OnRefreshNow - CWSStatusDlg member function: command
 *
 *      Processes in response to main frame's WM_STATUSREFRESHNOW notification
 *      that the user has changed the status refresh options.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CNetworkStatusDlg::OnRefreshNow( WPARAM wParam,
                            LPARAM lParam )
{
    /*
     * Tell the status thread to wake up now.
     */
    m_pWSStatusThread->SignalWakeUp();

    return(0);

}  // end CWSStatusDlg::OnRefreshNow

/*******************************************************************************
 *
 *  OnStatusReady - CWSStatusDlg member function: command
 *
 *      Process the WM_STATUSREADY message to update the dialog Info fields.
 *
 *      NOTE: the derived class must override this function to call it's
 *      override of the SetInfoFields function, which could then call / return
 *      this function or completely override all functionality contained here.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CNetworkStatusDlg::OnStatusReady( WPARAM wParam,
                             LPARAM lParam )
{
    /*
     * Update dialog fields with information from the CWStatusThread's
     * WINSTATIONINFORMATION structure.
     */
    SetInfoFields( &m_WSInfo, &(m_pWSStatusThread->m_WSInfo) );

    /*
     * Set our working WSInfo structure to the new one and signal the thread
     * that we're done.
     */
    m_WSInfo = m_pWSStatusThread->m_WSInfo;
    m_pWSStatusThread->SignalConsumed();

    return(0);

}  // end CWSStatusDlg::OnStatusReady


/*******************************************************************************
 *
 *  OnStatusAbort - CWSStatusDlg member function: command
 *
 *      Process the WM_STATUSABORT message to exit the thread and dialog.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CNetworkStatusDlg::OnStatusAbort( WPARAM wParam,
                             LPARAM lParam )
{
    /*
     * Call the OnCancel() member function to exit dialog and thread and
     * perform proper cleanup.
     */
    OnCancel();

    return(0);

}  // end CWSStatusDlg::OnStatusAbort


BOOL CNetworkStatusDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	// TODO: Add your message handler code here and/or call default
	//((CWinAdminApp*)AfxGetApp())->WinHelp(HID_BASE_CONTROL + pHelpInfo->iCtrlId, HELP_CONTEXTPOPUP);
	if(pHelpInfo->iContextType == HELPINFO_WINDOW) 
	{
		if(pHelpInfo->iCtrlId != IDC_STATIC)
		{
	         ::WinHelp((HWND)pHelpInfo->hItemHandle,ID_HELP_FILE,HELP_WM_HELP,(ULONG_PTR)(LPVOID)aMenuHelpIDs);
		}
	}

	return (TRUE);				
	
}


////////////////////////////////////////////////////////////////////////////////
CMyDialog::CMyDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CMyDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMyDialog)
	m_cstrServerName = _T("");
	//}}AFX_DATA_INIT
}


void CMyDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyDialog)
    DDX_Text(pDX, IDC_EDIT_FINDSERVER, m_cstrServerName);
    DDV_MaxChars(pDX, m_cstrServerName, 256);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyDialog, CDialog)
	//{{AFX_MSG_MAP(CMyDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\domainpg.cpp ===
/*******************************************************************************
*
* domainpg.cpp
*
* implementations of the Domain info pages
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\domainpg.cpp  $
*
*     Rev 1.2   19 Feb 1998 17:40:30   donm
*  removed latest extension DLL support
*
*     Rev 1.1   19 Jan 1998 16:47:36   donm
*  new ui behavior for domains and servers
*
*     Rev 1.0   03 Nov 1997 15:07:22   donm
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "admindoc.h"
#include "domainpg.h"

#include <malloc.h>                     // for alloca used by Unicode conversion macros
#include <mfc42\afxconv.h>           // for Unicode conversion macros
//USES_CONVERSION
static int _convert;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


////////////////////////////////
// MESSAGE MAP: CDomainServersPage
//
IMPLEMENT_DYNCREATE(CDomainServersPage, CFormView)

BEGIN_MESSAGE_MAP(CDomainServersPage, CFormView)
        //{{AFX_MSG_MAP(CDomainServersPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_SERVER_LIST, OnColumnclick)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_SERVER_LIST, OnServerItemChanged)
        ON_NOTIFY(NM_SETFOCUS, IDC_SERVER_LIST, OnSetfocusServerList)
        //ON_NOTIFY(NM_KILLFOCUS, IDC_SERVER_LIST, OnKillfocusServerList)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CDomainServersPage ctor
//
CDomainServersPage::CDomainServersPage()
        : CAdminPage(CDomainServersPage::IDD)
{
        //{{AFX_DATA_INIT(CDomainServersPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_pDomain = NULL;
    m_bSortAscending = TRUE;

}  // end CDomainServersPage ctor


/////////////////////////////
// F'N: CDomainServersPage dtor
//
CDomainServersPage::~CDomainServersPage()
{

}  // end CDomainServersPage dtor


////////////////////////////////////////
// F'N: CDomainServersPage::DoDataExchange
//
void CDomainServersPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDomainServersPage)
        DDX_Control(pDX, IDC_SERVER_LIST, m_ServerList);
        //}}AFX_DATA_MAP

}  // end CDomainServersPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CDomainServersPage::AssertValid
//
void CDomainServersPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CDomainServersPage::AssertValid


//////////////////////////////
// F'N: CDomainServersPage::Dump
//
void CDomainServersPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CDomainServersPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CDomainServersPage::OnSize
//
void CDomainServersPage::OnSize(UINT nType, int cx, int cy)
{
    RECT rect;
    GetClientRect(&rect);

    rect.top += LIST_TOP_OFFSET;

    if(m_ServerList.GetSafeHwnd())
            m_ServerList.MoveWindow(&rect, TRUE);

    // CFormView::OnSize(nType, cx, cy);

}  // end CDomainServersPage::OnSize


static ColumnDef ServerColumns[] = {
        CD_SERVER,
        CD_TCPADDRESS,
        CD_IPXADDRESS,
        CD_NUM_SESSIONS
};

#define NUM_DOMAIN_SERVER_COLUMNS sizeof(ServerColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CDomainServersPage::OnInitialUpdate
//
void CDomainServersPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        BuildImageList();               // builds the image list for the list control

        CString columnString;

        for(int col = 0; col < NUM_DOMAIN_SERVER_COLUMNS; col++) {
                columnString.LoadString(ServerColumns[col].stringID);
                m_ServerList.InsertColumn(col, columnString, ServerColumns[col].format, ServerColumns[col].width, col);
        }

        m_CurrentSortColumn = SERVERS_COL_SERVER;

}  // end CDomainServersPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CDomainServersPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CDomainServersPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 4, 0);

        m_idxServer = AddIconToImageList(IDI_SERVER);
        m_idxCurrentServer = AddIconToImageList(IDI_CURRENT_SERVER);
        m_idxNotSign = AddIconToImageList(IDI_NOTSIGN);
        m_idxQuestion = AddIconToImageList(IDI_QUESTIONMARK);

        m_ImageList.SetOverlayImage(m_idxNotSign, 1);
        m_ImageList.SetOverlayImage(m_idxQuestion, 2);

        m_ServerList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CDomainServersPage::BuildImageList


/////////////////////////////////////////
// F'N: CDomainServersPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CDomainServersPage::AddIconToImageList(int iconID)
{
        HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
        return m_ImageList.Add(hIcon);

}  // end CDomainServersPage::AddIconToImageList


//////////////////////////////
// F'N: CDomainServersPage::Reset
//
void CDomainServersPage::Reset(void *pDomain)
{
        ASSERT(pDomain);

    m_pDomain = (CDomain*)pDomain;
        DisplayServers();

} // end CDomainServersPage::Reset


//////////////////////////////
// F'N: CDomainServersPage::AddServer
//
void CDomainServersPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // We have to make sure the server isn't already in the list
        // Add the server to the list
        if(AddServerToList(pServer)) {
            // Tell the list to sort itself
            LockListControl();
            SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
    }

}  // end CDomainServersPage::AddServer


//////////////////////////////
// F'N: CDomainServersPage::RemoveServer
//
void CDomainServersPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        LockListControl();
        // Find out how many items in the list
        int ItemCount = m_ServerList.GetItemCount();

        // Go through the items are remove this server
        for(int item = 0; item < ItemCount; item++) {
                CServer *pListServer = (CServer*)m_ServerList.GetItemData(item);

                if(pListServer == pServer) {
                        m_ServerList.DeleteItem(item);
                        pServer->ClearAllSelected();
                        break;
                }
        }
        UnlockListControl();

}  // end CDomainServersPage::RemoveServer


//////////////////////////////
// F'N: CDomainServersPage::UpdateServer
//
void CDomainServersPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        // If we aren't connected to the server anymore, remove it from the list control
        if(pServer->IsState(SS_NOT_CONNECTED)) {
                RemoveServer(pServer);
                return;
        }

        // If we just connected to this server, add it to the list control
        if(pServer->IsState(SS_GOOD)) {
                AddServer(pServer);
                return;
        }

        LockListControl();
        // Find the Server in the list
        LV_FINDINFO FindInfo;
        FindInfo.flags = LVFI_PARAM;
        FindInfo.lParam = (LPARAM)pServer;

        // Find the Server in our list
        int item = m_ServerList.FindItem(&FindInfo, -1);
        if(item != -1) {
                // Change the icon overlay
                USHORT NewState;
                // Change the icon/overlay for the server
                // If the server isn't sane, put a not sign over the icon
                if(!pServer->IsServerSane()) NewState = STATE_NOT;
                // If we aren't done getting all the information about this server,
                // put a question mark over the icon
                else if(!pServer->IsState(SS_GOOD)) NewState = STATE_QUESTION;
                // If it is fine, we want to remove any overlays from the icon
                else NewState = STATE_NORMAL;

                // Set the tree item to the new state
                m_ServerList.SetItemState(item, NewState, 0x0F00);

                ExtServerInfo *pExtServerInfo = pServer->GetExtendedInfo();

                // TCP Address
                m_ServerList.SetItemText(item, SERVERS_COL_TCPADDRESS, pExtServerInfo->TcpAddress);

                // IPX Address
                m_ServerList.SetItemText(item, SERVERS_COL_IPXADDRESS, pExtServerInfo->IpxAddress);

                CString NumString;
                if(pExtServerInfo && (pExtServerInfo->Flags & ESF_WINFRAME)) {
                        NumString.Format(TEXT("%lu"), pExtServerInfo->ServerTotalInUse);
                } else {
                        NumString.LoadString(IDS_NOT_APPLICABLE);
                }

                m_ServerList.SetItemText(item, SERVERS_COL_NUMWINSTATIONS, NumString);
        }

        // Tell the list to sort itself
        if(m_CurrentSortColumn == SERVERS_COL_NUMWINSTATIONS
                || m_CurrentSortColumn == SERVERS_COL_TCPADDRESS
                || m_CurrentSortColumn == SERVERS_COL_IPXADDRESS)
                        SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);

        UnlockListControl();

}  // end CDomainServersPage::UpdateServer


//////////////////////////////
// F'N: CDomainServersPage::AddServerToList
//
BOOL CDomainServersPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return FALSE;

        // If we aren't currently connected to the server, don't display it
        if(!pServer->IsState(SS_GOOD)) return FALSE;

        LockListControl();
        // Find the Server in the list
        LV_FINDINFO FindInfo;
        FindInfo.flags = LVFI_PARAM;
        FindInfo.lParam = (LPARAM)pServer;

        // Find the Server in our list
        int item = m_ServerList.FindItem(&FindInfo, -1);
        if(item != -1) return FALSE;

        //////////////////////
        // Fill in the columns
        //////////////////////
        // Name - put at the end of the list
        item = m_ServerList.InsertItem(m_ServerList.GetItemCount(), pServer->GetName(),
                                                                pServer->IsCurrentServer() ? m_idxCurrentServer : m_idxServer);

        // If the server isn't sane, put a not sign over the icon
        if(!pServer->IsServerSane()) m_ServerList.SetItemState(item, STATE_NOT, 0x0F00);
        // If we aren't done getting all the information about this server,
        // put a question mark over the icon
        else if(!pServer->IsState(SS_GOOD)) m_ServerList.SetItemState(item, STATE_QUESTION, 0x0F00);

        ExtServerInfo *pExtServerInfo = pServer->GetExtendedInfo();

        // TCP Address
        m_ServerList.SetItemText(item, SERVERS_COL_TCPADDRESS, pExtServerInfo->TcpAddress);

        // IPX Address
        m_ServerList.SetItemText(item, SERVERS_COL_IPXADDRESS, pExtServerInfo->IpxAddress);

        // Connected
        CString NumString;
        if(pExtServerInfo && (pExtServerInfo->Flags & ESF_WINFRAME)) {
                NumString.Format(TEXT("%lu"), pExtServerInfo->ServerTotalInUse);
        } else {
                NumString.LoadString(IDS_NOT_APPLICABLE);
        }

        m_ServerList.SetItemText(item, SERVERS_COL_NUMWINSTATIONS, NumString);

        m_ServerList.SetItemData(item, (DWORD_PTR)pServer);

        m_ServerList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

        UnlockListControl();

    return TRUE;

}  // end CDomainServersPage::AddServerToList


/////////////////////////////////////
// F'N: CDomainServersPage::DisplayServers
//
void CDomainServersPage::DisplayServers()
{
        LockListControl();

        // Clear out the list control
        m_ServerList.DeleteAllItems();

        // Get a pointer to our document
        CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();

        // Get a pointer to the list of servers
        doc->LockServerList();
        CObList *pServerList = doc->GetServerList();

        // Iterate through the Server list
        POSITION pos = pServerList->GetHeadPosition();

        while(pos) {
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                AddServerToList(pServer);
        }  // end while(pos)

        doc->UnlockServerList();

        UnlockListControl();

}  // end CDomainServersPage::DisplayServers


//////////////////////////////
// F'N: CDomainServersPage::OnServerItemChanged
//
void CDomainServersPage::OnServerItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here
        CServer *pServer = (CServer*)m_ServerList.GetItemData(pLV->iItem);

        if(pLV->uNewState & LVIS_SELECTED) {
                pServer->SetSelected();
        }

        if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
                pServer->ClearSelected();
        }

        *pResult = 0;

}  // end CDomainServersPage::OnServerItemChanged


//////////////////////////////
// F'N: CDomainServersPage::OnColumnclick
//
void CDomainServersPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CDomainServersPage::OnColumnclick


//////////////////////////////
// F'N: CDomainServersPage::OnContextMenu
//
void CDomainServersPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_ServerList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_ServerList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_ServerList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }
                /*
                RECT rect;
                m_ServerList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_ServerList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                        return;
        }

        CMenu menu;
        menu.LoadMenu(IDR_SERVER_POPUP);
        // set the temp selected item so that handler doesn't think
        // this came from the tree
        // Get a pointer to our document
        CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();
        doc->SetTreeTemp(NULL, NODE_NONE);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CDomainServersPage::OnContextMenu


////////////////////////////////
// MESSAGE MAP: CDomainUsersPage
//
IMPLEMENT_DYNCREATE(CDomainUsersPage, CFormView)

BEGIN_MESSAGE_MAP(CDomainUsersPage, CFormView)
        //{{AFX_MSG_MAP(CDomainUsersPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_USER_LIST, OnColumnclick)
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_USER_LIST, OnUserItemChanged)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(NM_SETFOCUS, IDC_USER_LIST, OnSetfocusUserList)
        //ON_NOTIFY(NM_KILLFOCUS, IDC_USER_LIST, OnKillfocusUserList)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CDomainUsersPage ctor
//
CDomainUsersPage::CDomainUsersPage()
        : CAdminPage(CDomainUsersPage::IDD)
{
        //{{AFX_DATA_INIT(CDomainUsersPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_pDomain = NULL;
    m_bSortAscending = TRUE;

}  // end CDomainUsersPage ctor


/////////////////////////////
// F'N: CDomainUsersPage dtor
//
CDomainUsersPage::~CDomainUsersPage()
{
}  // end CDomainUsersPage dtor


////////////////////////////////////////
// F'N: CDomainUsersPage::DoDataExchange
//
void CDomainUsersPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDomainUsersPage)
        DDX_Control(pDX, IDC_USER_LIST, m_UserList);
        //}}AFX_DATA_MAP

}  // end CDomainUsersPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CDomainUsersPage::AssertValid
//
void CDomainUsersPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CDomainUsersPage::AssertValid


//////////////////////////////
// F'N: CDomainUsersPage::Dump
//
void CDomainUsersPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CDomainUsersPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CDomainUsersPage::OnSize
//
void CDomainUsersPage::OnSize(UINT nType, int cx, int cy)
{
    RECT rect;
    GetClientRect(&rect);

    rect.top += LIST_TOP_OFFSET;

    if(m_UserList.GetSafeHwnd())
            m_UserList.MoveWindow(&rect, TRUE);

    // CFormView::OnSize(nType, cx, cy);

}  // end CDomainUsersPage::OnSize


static ColumnDef UserColumns[] = {
        CD_SERVER,
        CD_USER3,
        CD_SESSION,
        CD_ID,
        CD_STATE,
        CD_IDLETIME,
        CD_LOGONTIME,
};

#define NUM_DOMAIN_USER_COLUMNS sizeof(UserColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CDomainUsersPage::OnInitialUpdate
//
void CDomainUsersPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        BuildImageList();               // builds the image list for the list control

        CString columnString;

        for(int col = 0; col < NUM_DOMAIN_USER_COLUMNS; col++) {
                columnString.LoadString(UserColumns[col].stringID);
                m_UserList.InsertColumn(col, columnString, UserColumns[col].format, UserColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_USERS_COL_SERVER;

}  // end CDomainUsersPage::OnInitialUpdate


//////////////////////////////
// F'N: CDomainUsersPage::OnUserItemChanged
//
void CDomainUsersPage::OnUserItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;

        if(pLV->uNewState & LVIS_SELECTED) {
                CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(pLV->iItem);
                pWinStation->SetSelected();
        }

        if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
                CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(pLV->iItem);
                pWinStation->ClearSelected();
        }

        *pResult = 0;

}  // end CDomainUsersPage::OnUserItemChanged

/////////////////////////////////////
// F'N: CDomainUsersPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CDomainUsersPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 2, 0);

        m_idxUser = AddIconToImageList(IDI_USER);
        m_idxCurrentUser  = AddIconToImageList(IDI_CURRENT_USER);

        m_UserList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CDomainUsersPage::BuildImageList


/////////////////////////////////////////
// F'N: CDomainUsersPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CDomainUsersPage::AddIconToImageList(int iconID)
{
        HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
        return m_ImageList.Add(hIcon);

}  // end CDomainUsersPage::AddIconToImageList


//////////////////////////////
// F'N: CDomainUsersPage::Reset
//
void CDomainUsersPage::Reset(void *pDomain)
{
        ASSERT(pDomain);

    m_pDomain = (CDomain*)pDomain;
        DisplayUsers();

} // end CDomainUsersPage::Reset


//////////////////////////////
// F'N: CDomainUsersPage::AddServer
//
void CDomainUsersPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add the server's users to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            LockListControl();
            SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
   }

} // end CDomainUsersPage::AddServer


//////////////////////////////
// F'N: CDomainUsersPage::RemoveServer
//
void CDomainUsersPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        LockListControl();

        int ItemCount = m_UserList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(item-1);
                CServer *pListServer = pWinStation->GetServer();

                if(pListServer == pServer) {
                        m_UserList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

        UnlockListControl();

} // end CDomainUsersPage::RemoveServer


//////////////////////////////
// F'N: CDomainUsersPage::UpdateServer
//
void CDomainUsersPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

} // end CDomainUsersPage::UpdateServer


//////////////////////////////
// F'N: CDomainUsersPage::UpdateWinStations
//
void CDomainUsersPage::UpdateWinStations(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
        BOOL bAnyChanged = FALSE;
        BOOL bAnyAdded = FALSE;

        // Loop through the WinStations
        pServer->LockWinStationList();
        CObList *pWinStationList = pServer->GetWinStationList();

        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

                LV_FINDINFO FindInfo;
                FindInfo.flags = LVFI_PARAM;
                FindInfo.lParam = (LPARAM)pWinStation;

                // Find the WinStation in our list
                int item = m_UserList.FindItem(&FindInfo, -1);

                // If the WinStation is new and isn't currently in the list,
                // add it to the list
                if(pWinStation->IsNew() && pWinStation->HasUser() && item == -1) {

                        AddUserToList(pWinStation);
                        bAnyAdded = TRUE;
                        continue;
                }

                // If the WinStation is no longer current,
                // remove it from the list
                if((!pWinStation->IsCurrent() || !pWinStation->HasUser()) && item != -1) {
                        // Remove the WinStation from the list
                        m_UserList.DeleteItem(item);
                        pWinStation->ClearSelected();
                        continue;
                }

                // If the WinStation info has changed, change
                // it's info in our tree
                if(pWinStation->IsChanged() && item != -1) {
                        // change the user name
                        m_UserList.SetItemText(item, AS_USERS_COL_USER, pWinStation->GetUserName());

                        // change the WinStation Name
                        // WinStation Name
                        if(pWinStation->GetName()[0])
                            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, pWinStation->GetName());
                        else {
                                CString NameString(" ");
                                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, NameString);
                        }


                        // change the Connect State
                        m_UserList.SetItemText(item, AS_USERS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));
                        // change the Idle Time
                        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

                        ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

                        if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
                        {
                                ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
                        }
                        else wcscpy(IdleTimeString, TEXT("."));

                        m_UserList.SetItemText(item, AS_USERS_COL_IDLETIME, IdleTimeString);
                        // change the Logon Time
                        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
                        // We don't want to pass a 0 logon time to DateTimeString()
                        // It will blow up if the timezone is GMT
                        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
                                DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
                                pDoc->FixUnknownString(LogonTimeString);
                        }
                        else LogonTimeString[0] = '\0';
                        // change the

                        m_UserList.SetItemText(item, AS_USERS_COL_LOGONTIME, LogonTimeString);

                        if(m_CurrentSortColumn != AS_USERS_COL_ID)
                                bAnyChanged = TRUE;

                        continue;
                }

                // If the WinStation is not in the list but now has a user, add it to the list
                if(item == -1 && pWinStation->IsCurrent() && pWinStation->HasUser()) {
                        AddUserToList(pWinStation);
                        bAnyAdded = TRUE;
                }
        }

        pServer->UnlockWinStationList();

        if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);

}  // end CDomainUsersPage::UpdateWinStations


//////////////////////////////
// F'N: CDomainUsersPage::AddUserToList
//
int CDomainUsersPage::AddUserToList(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        CServer *pServer = pWinStation->GetServer();

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return -1;


        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        LockListControl();
        //////////////////////
        // Fill in the columns
        //////////////////////
        // Server - put at the end of the list
        int item = m_UserList.InsertItem(m_UserList.GetItemCount(), pServer->GetName(),
                pWinStation->IsCurrentUser() ? m_idxCurrentUser : m_idxUser);

        // User
        m_UserList.SetItemText(item, AS_USERS_COL_USER, pWinStation->GetUserName());

        // WinStation Name
        if(pWinStation->GetName()[0])
            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, pWinStation->GetName());
        else {
                CString NameString(" ");
                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, NameString);
        }

        // Logon ID
        CString ColumnString;
        ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
        m_UserList.SetItemText(item, AS_USERS_COL_ID, ColumnString);

        // Connect State
        m_UserList.SetItemText(item, AS_USERS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

        // Idle Time
        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

        ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

        if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
        {
                ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
        }
        else wcscpy(IdleTimeString, TEXT("."));

        m_UserList.SetItemText(item, AS_USERS_COL_IDLETIME, IdleTimeString);

        // Logon Time
        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
        // We don't want to pass a 0 logon time to DateTimeString()
        // It will blow up if the timezone is GMT
        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
                DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
                pDoc->FixUnknownString(LogonTimeString);
        }
        else LogonTimeString[0] = '\0';

        m_UserList.SetItemText(item, AS_USERS_COL_LOGONTIME, LogonTimeString);

        // Attach a pointer to the CWinStation structure to the list item
        m_UserList.SetItemData(item, (DWORD_PTR)pWinStation);
        
        //bug #191727
        //m_UserList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

        UnlockListControl();

        return item;

}  // end CDomainUsersPage::AddUserToList


//////////////////////////////
// F'N: CDomainUsersPage::AddServerToList
//
BOOL CDomainUsersPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return FALSE;

        pServer->LockWinStationList();
        // Get a pointer to this server's list of WinStations
        CObList *pWinStationList = pServer->GetWinStationList();

        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

                // only show the WinStation if it has a user
                if(pWinStation->HasUser()) {
                        AddUserToList(pWinStation);
                }
        }  // end while(pos)

        pServer->UnlockWinStationList();

    return TRUE;

}  // end CDomainUsersPage::AddServerToList


//////////////////////////////
// F'N: CDomainUsersPage::OnColumnclick
//
void CDomainUsersPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CDomainUsersPage::OnColumnclick


//////////////////////////////
// F'N: CDomainUsersPage::OnContextMenu
//
void CDomainUsersPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_UserList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_UserList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }
                /*
                RECT rect;
                m_UserList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_UserList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                {
                    //
                    // ListView HitTest bug? return -1 but item display as selected.
                    // workaround for now, Al can fix this later
                    //
                    UINT iCount = m_UserList.GetItemCount( );
                    RECT rc;

                    for( Item = 0 ; Item < iCount ; Item++ )
                    {
                        if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                            break;
                        }
                    }

                    if( Item >= iCount )
                    {
                        return;
                    }

                }

                //
                // NM_RCLICK (WM_NOTIFY) then WM_CNTEXTMENU but no NM_ITEMCHANGED message
                // manually set it to selected state
                //
                CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(Item);

                if( !pWinStation )
                    return;
    
                if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                {
                    pWinStation->SetSelected();
                }
        }

        CMenu menu;
        menu.LoadMenu(IDR_USER_POPUP);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CDomainUsersPage::OnContextMenu


/////////////////////////////////////
// F'N: CDomainUsersPage::DisplayUsers
//
void CDomainUsersPage::DisplayUsers()
{
        LockListControl();

        // Clear out the list control
        m_UserList.DeleteAllItems();

        // Get a pointer to the document's list of servers
        CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

        ((CWinAdminDoc*)GetDocument())->LockServerList();
        // Iterate through the server list
        POSITION pos2 = pServerList->GetHeadPosition();

        while(pos2) {

                CServer *pServer = (CServer*)pServerList->GetNext(pos2);
                        AddServerToList(pServer);
        } // end while(pos2)

        ((CWinAdminDoc*)GetDocument())->UnlockServerList();

        UnlockListControl();

}  // end CDomainUsersPage::DisplayUsers

/////////////////////////////////////
// F'N: CDomainUsersPage::ClearSelections
//
void CDomainUsersPage::ClearSelections()
{
    
    if(m_UserList.m_hWnd != NULL)
    {
        POSITION pos = m_UserList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nItem = m_UserList.GetNextSelectedItem(pos);
            m_UserList.SetItemState(nItem,0,LVIS_SELECTED);
        }
    }
}

////////////////////////////////
// MESSAGE MAP: CDomainWinStationsPage
//
IMPLEMENT_DYNCREATE(CDomainWinStationsPage, CFormView)

BEGIN_MESSAGE_MAP(CDomainWinStationsPage, CFormView)
        //{{AFX_MSG_MAP(CDomainWinStationsPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_WINSTATION_LIST, OnColumnclick)
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_WINSTATION_LIST, OnWinStationItemChanged)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(NM_SETFOCUS, IDC_WINSTATION_LIST, OnSetfocusWinstationList)
        //ON_NOTIFY(NM_KILLFOCUS, IDC_WINSTATION_LIST, OnKillfocusWinstationList)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CDomainWinStationsPage ctor
//
CDomainWinStationsPage::CDomainWinStationsPage()
        : CAdminPage(CDomainWinStationsPage::IDD)
{
        //{{AFX_DATA_INIT(CDomainWinStationsPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_pDomain = NULL;
    m_bSortAscending = TRUE;

}  // end CDomainWinStationsPage ctor


/////////////////////////////
// F'N: CDomainWinStationsPage dtor
//
CDomainWinStationsPage::~CDomainWinStationsPage()
{

}  // end CDomainWinStationsPage dtor


////////////////////////////////////////
// F'N: CDomainWinStationsPage::DoDataExchange
//
void CDomainWinStationsPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDomainWinStationsPage)
        DDX_Control(pDX, IDC_WINSTATION_LIST, m_StationList);
        //}}AFX_DATA_MAP

}  // end CDomainWinStationsPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CDomainWinStationsPage::AssertValid
//
void CDomainWinStationsPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CDomainWinStationsPage::AssertValid


//////////////////////////////
// F'N: CDomainWinStationsPage::Dump
//
void CDomainWinStationsPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CDomainWinStationsPage::Dump

#endif //_DEBUG


////////////////////////////////////////
// F'N: CDomainWinStationsPage::OnWinStationItemChanged
//
void CDomainWinStationsPage::OnWinStationItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;

        if(pLV->uNewState & LVIS_SELECTED) {
                CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(pLV->iItem);
                pWinStation->SetSelected();
        }

        if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
                CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(pLV->iItem);
                pWinStation->ClearSelected();
        }

        *pResult = 0;

}  // end CDomainWinStationsPage::OnWinStationItemChanged


////////////////////////////////////////
// F'N: CDomainWinStationsPage::OnSize
//
void CDomainWinStationsPage::OnSize(UINT nType, int cx, int cy)
{
    RECT rect;
    GetClientRect(&rect);

    rect.top += LIST_TOP_OFFSET;

    if(m_StationList.GetSafeHwnd())
            m_StationList.MoveWindow(&rect, TRUE);

    // CFormView::OnSize(nType, cx, cy);

}  // end CDomainWinStationsPage::OnSize


static ColumnDef WinsColumns[] = {
        CD_SERVER,
        CD_SESSION2,
        CD_USER2,
        CD_ID,
        CD_STATE,
        CD_TYPE,
        CD_CLIENT_NAME,
        CD_IDLETIME,
        CD_LOGONTIME,
        CD_COMMENT
};

#define NUM_DOMAIN_WINS_COLUMNS sizeof(WinsColumns)/sizeof(ColumnDef)

////////////////////////////////////////
// F'N: CDomainWinStationsPage::OnInitialUpdate
//
void CDomainWinStationsPage::OnInitialUpdate()
{
        // Call the parent class
        CFormView::OnInitialUpdate();

        // builds the image list for the list control
        BuildImageList();

        // Add the column headings
        CString columnString;

        for(int col = 0; col < NUM_DOMAIN_WINS_COLUMNS; col++) {
                columnString.LoadString(WinsColumns[col].stringID);
                m_StationList.InsertColumn(col, columnString, WinsColumns[col].format, WinsColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_WS_COL_SERVER;

}  // end CDomainWinStationsPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CDomainWinStationsPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CDomainWinStationsPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 11, 0);

        m_idxBlank  = AddIconToImageList(IDI_BLANK);
        m_idxCitrix = AddIconToImageList(IDR_MAINFRAME);
        m_idxServer = AddIconToImageList(IDI_SERVER);
        m_idxConsole = AddIconToImageList(IDI_CONSOLE);
        m_idxNet = AddIconToImageList(IDI_NET);
        m_idxAsync = AddIconToImageList(IDI_ASYNC);
        m_idxCurrentConsole = AddIconToImageList(IDI_CURRENT_CONSOLE);
        m_idxCurrentNet = AddIconToImageList(IDI_CURRENT_NET);
        m_idxCurrentAsync = AddIconToImageList(IDI_CURRENT_ASYNC);
        m_idxDirectAsync = AddIconToImageList(IDI_DIRECT_ASYNC);
        m_idxCurrentDirectAsync = AddIconToImageList(IDI_CURRENT_DIRECT_ASYNC);

        m_StationList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CDomainWinStationsPage::BuildImageList


/////////////////////////////////////////
// F'N: CDomainWinStationsPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CDomainWinStationsPage::AddIconToImageList(int iconID)
{
        HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
        return m_ImageList.Add(hIcon);

}  // end CDomainWinStationsPage::AddIconToImageList


////////////////////////////////////////
// F'N: CDomainWinStationsPage::Reset
//
void CDomainWinStationsPage::Reset(void *pDomain)
{
        ASSERT(pDomain);

    m_pDomain = (CDomain*)pDomain;
        DisplayStations();

}  // end CDomainWinStationsPage::Reset


////////////////////////////////////////
// F'N: CDomainWinStationsPage::AddServer
//
void CDomainWinStationsPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add server's WinStations to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            LockListControl();
            SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
    }

}  // end CDomainWinStationsPage::AddServer


////////////////////////////////////////
// F'N: CDomainWinStationsPage::RemoveServer
//
void CDomainWinStationsPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        LockListControl();

        int ItemCount = m_StationList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(item-1);
                CServer *pListServer = pWinStation->GetServer();

                if(pListServer == pServer) {
                        m_StationList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

        UnlockListControl();

}  // end CDomainWinStationsPage::RemoveServer


//////////////////////////////
// F'N: CDomainWinStationsPage::UpdateServer
//
void CDomainWinStationsPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

} // end CDomainWinStationsPage::UpdateServer


////////////////////////////////////////
// F'N: CDomainWinStationsPage::UpdateWinStations
//
void CDomainWinStationsPage::UpdateWinStations(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
        BOOL bAnyChanged = FALSE;
        BOOL bAnyAdded = FALSE;

        // Loop through the WinStations
        pServer->LockWinStationList();
        CObList *pWinStationList = pServer->GetWinStationList();

        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

                LV_FINDINFO FindInfo;
                FindInfo.flags = LVFI_PARAM;
                FindInfo.lParam = (LPARAM)pWinStation;

                // Find the WinStation in our list
                int item = m_StationList.FindItem(&FindInfo, -1);

                // If the process is new and isn't currently in the list,
                // add it to the list
                if(pWinStation->IsNew() && item == -1) {

                        AddWinStationToList(pWinStation);
                        bAnyAdded = TRUE;
                        continue;
                }

                // If the WinStation is no longer current,
                // remove it from the list
                if(!pWinStation->IsCurrent() && item != -1) {
                        // Remove the WinStation from the list
                        m_StationList.DeleteItem(item);
                        pWinStation->ClearSelected();
                        continue;
                }

                // If the WinStation info has changed, change
                // it's info in our tree
                if(pWinStation->IsChanged() && item != -1) {
                        // Figure out which icon to use
                        int WhichIcon = m_idxBlank;
                        BOOL CurrentWinStation = pWinStation->IsCurrentWinStation();

                        if(pWinStation->GetState() != State_Disconnected
                        && pWinStation->GetState() != State_Idle) {
                                switch(pWinStation->GetSdClass()) {
                                        case SdAsync:
                                                if(pWinStation->IsDirectAsync())
                                                        WhichIcon = CurrentWinStation ? m_idxCurrentDirectAsync : m_idxDirectAsync;
                                                else
                                                        WhichIcon = CurrentWinStation ? m_idxCurrentAsync : m_idxAsync;
                                                break;

                                        case SdNetwork:
                                                WhichIcon = CurrentWinStation ? m_idxCurrentNet : m_idxNet;
                                                break;

                                        default:
                                                WhichIcon = CurrentWinStation ? m_idxCurrentConsole : m_idxConsole;
                                        break;
                                }
                        }

                        m_StationList.SetItem(item, 0, LVIF_IMAGE, 0, WhichIcon, 0, 0, 0L);

                        // WinStation Name
                        if(pWinStation->GetName()[0])
                                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, pWinStation->GetName());
                        else {
                                CString NameString(" ");
                                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, NameString);
                        }

                        // User
                        m_StationList.SetItemText(item, AS_WS_COL_USER, pWinStation->GetUserName());

                        // Logon ID
                        CString ColumnString;
                        ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
                        m_StationList.SetItemText(item, AS_WS_COL_ID, ColumnString);

                        // Connect State
                        m_StationList.SetItemText(item, AS_WS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

                        // Type
                        m_StationList.SetItemText(item, AS_WS_COL_TYPE, pWinStation->GetWdName());

                        // Client Name
                        m_StationList.SetItemText(item, AS_WS_COL_CLIENTNAME, pWinStation->GetClientName());

                        // Idle Time
                        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

                        ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

                        if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
                        {
                                ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
                        }
                        else wcscpy(IdleTimeString, TEXT("."));

                        m_StationList.SetItemText(item, AS_WS_COL_IDLETIME, IdleTimeString);

                        // Logon Time
                        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
                        // We don't want to pass a 0 logon time to DateTimeString()
                        // It will blow up if the timezone is GMT
                        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
                                DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
                                pDoc->FixUnknownString(LogonTimeString);
                        }
                        else LogonTimeString[0] = '\0';

                        m_StationList.SetItemText(item, AS_WS_COL_LOGONTIME, LogonTimeString);

                        // Comment
                        m_StationList.SetItemText(item, AS_WS_COL_COMMENT, pWinStation->GetComment());

                        if(m_CurrentSortColumn != AS_WS_COL_ID)
                                bAnyChanged = TRUE;
                }
        }

        pServer->UnlockWinStationList();

        if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);

} // end CDomainWinStationsPage::UpdateWinStations


////////////////////////////////////////
// F'N: CDomainWinStationsPage::AddWinStationToList
//
int CDomainWinStationsPage::AddWinStationToList(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        CServer *pServer = pWinStation->GetServer();

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return -1;

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        // Figure out which icon to use
        int WhichIcon = m_idxBlank;
        BOOL bCurrentWinStation = pWinStation->IsCurrentWinStation();

        if(pWinStation->GetState() != State_Disconnected
                && pWinStation->GetState() != State_Idle) {
                switch(pWinStation->GetSdClass()) {
                        case SdAsync:
                                if(pWinStation->IsDirectAsync())
                                        WhichIcon = bCurrentWinStation ? m_idxCurrentDirectAsync : m_idxDirectAsync;
                                else
                                        WhichIcon = bCurrentWinStation ? m_idxCurrentAsync : m_idxAsync;
                                break;

                        case SdNetwork:
                                WhichIcon = bCurrentWinStation ? m_idxCurrentNet : m_idxNet;
                                break;

                        default:
                                WhichIcon = bCurrentWinStation ? m_idxCurrentConsole : m_idxConsole;
                                break;
                }
        }

        LockListControl();
        //////////////////////
        // Fill in the columns
        //////////////////////

        // Server Name
        int item = m_StationList.InsertItem(m_StationList.GetItemCount(), pServer->GetName(), WhichIcon);
        // WinStation Name
        if(pWinStation->GetName()[0])
                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, pWinStation->GetName());
        else {
                CString NameString(" ");
                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, NameString);
        }

        // User
        m_StationList.SetItemText(item, AS_WS_COL_USER, pWinStation->GetUserName());

        // Logon ID
        CString ColumnString;
        ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
        m_StationList.SetItemText(item, AS_WS_COL_ID, ColumnString);

        // Connect State
        m_StationList.SetItemText(item, AS_WS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

        // Type
        m_StationList.SetItemText(item, AS_WS_COL_TYPE, pWinStation->GetWdName());

        // Client Name
        m_StationList.SetItemText(item, AS_WS_COL_CLIENTNAME, pWinStation->GetClientName());

        // Idle Time
        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];
        if(pWinStation->GetState() == State_Active
                && pWinStation->GetLastInputTime().QuadPart <= pWinStation->GetCurrentTime().QuadPart)
        {
            LARGE_INTEGER DiffTime = CalculateDiffTime(pWinStation->GetLastInputTime(), pWinStation->GetCurrentTime());

            ULONG_PTR d_time = ( ULONG_PTR )DiffTime.QuadPart;
            ELAPSEDTIME IdleTime;
            // Calculate the days, hours, minutes, seconds since specified time.
            IdleTime.days = (USHORT)(d_time / 86400L); // days since
            d_time = d_time % 86400L;                  // seconds => partial day
            IdleTime.hours = (USHORT)(d_time / 3600L); // hours since
            d_time  = d_time % 3600L;                  // seconds => partial hour
            IdleTime.minutes = (USHORT)(d_time / 60L); // minutes since
            IdleTime.seconds = (USHORT)(d_time % 60L);// seconds remaining
            ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
            pWinStation->SetIdleTime(IdleTime);
        }
        else wcscpy(IdleTimeString, TEXT("."));

        m_StationList.SetItemText(item, AS_WS_COL_IDLETIME, IdleTimeString);

        // Logon Time
        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
        // We don't want to pass a 0 logon time to DateTimeString()
        // It will blow up if the timezone is GMT
        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
                DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
                pDoc->FixUnknownString(LogonTimeString);
        }
        else LogonTimeString[0] = '\0';

        m_StationList.SetItemText(item, AS_WS_COL_LOGONTIME, LogonTimeString);

        // Comment
        m_StationList.SetItemText(item, AS_WS_COL_COMMENT, pWinStation->GetComment());

        // Attach a pointer to the CWinStation structure to the list item
        m_StationList.SetItemData(item, (DWORD_PTR)pWinStation);

        //bug #191727
        //m_StationList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

        UnlockListControl();

        return item;

}  // end CDomainWinStationsPage::AddWinStationToList


////////////////////////////////////////
// F'N: CDomainWinStationsPage::AddServerToList
//
BOOL CDomainWinStationsPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return FALSE;

        pServer->LockWinStationList();
        // Get a pointer to this server's list of WinStations
        CObList *pWinStationList = pServer->GetWinStationList();

        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                AddWinStationToList(pWinStation);
        }

        pServer->UnlockWinStationList();

    return TRUE;

}  // end CDomainWinStationsPage::AddServerToList


/////////////////////////////////////
// F'N: CDomainWinStationsPage::DisplayStations
//
void CDomainWinStationsPage::DisplayStations()
{
        // Clear out the list control
        m_StationList.DeleteAllItems();

        // Get a pointer to the document's list of servers
        CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

        ((CWinAdminDoc*)GetDocument())->LockServerList();
        // Iterate through the server list
        POSITION pos = pServerList->GetHeadPosition();

        while(pos) {
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                AddServerToList(pServer);
        }
        ((CWinAdminDoc*)GetDocument())->UnlockServerList();

}  // end CDomainWinStationsPage::DisplayStations


////////////////////////////////////////
// F'N: CDomainWinStationsPage::OnColumnclick
//
void CDomainWinStationsPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CDomainWinStationsPage::OnColumnclick


////////////////////////////////////////
// F'N: CDomainWinStationsPage::OnContextMenu
//
void CDomainWinStationsPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_StationList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_StationList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_StationList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }
                /*
                RECT rect;
                m_StationList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_StationList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                        return;
        }

        CMenu menu;
        menu.LoadMenu(IDR_WINSTATION_POPUP);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CDomainWinStationsPage::OnContextMenu

/////////////////////////////////////
// F'N: CDomainWinStationsPage::ClearSelections
//
void CDomainWinStationsPage::ClearSelections()
{
    
    if(m_StationList.m_hWnd != NULL)
    {
        POSITION pos = m_StationList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nItem = m_StationList.GetNextSelectedItem(pos);
            m_StationList.SetItemState(nItem,0,LVIS_SELECTED);
        }
    }
}

//////////////////////////////////
// MESSAGE MAP: CDomainProcessesPage
//
IMPLEMENT_DYNCREATE(CDomainProcessesPage, CFormView)

BEGIN_MESSAGE_MAP(CDomainProcessesPage, CFormView)
        //{{AFX_MSG_MAP(CDomainProcessesPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_PROCESS_LIST, OnColumnclick)
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_PROCESS_LIST, OnProcessItemChanged)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(NM_SETFOCUS, IDC_PROCESS_LIST, OnSetfocusProcessList)
        //ON_NOTIFY(NM_KILLFOCUS, IDC_PROCESS_LIST, OnKillfocusProcessList)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


///////////////////////////////
// F'N: CDomainProcessesPage ctor
//
CDomainProcessesPage::CDomainProcessesPage()
        : CAdminPage(CDomainProcessesPage::IDD)
{
        //{{AFX_DATA_INIT(CDomainProcessesPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_pDomain = NULL;
    m_bSortAscending = TRUE;

}  // end CDomainProcessesPage ctor


///////////////////////////////
// F'N: CDomainProcessesPage dtor
//
CDomainProcessesPage::~CDomainProcessesPage()
{
}  // end CDomainProcessesPage dtor


//////////////////////////////////////////
// F'N: CDomainProcessesPage::DoDataExchange
//
void CDomainProcessesPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDomainProcessesPage)
                // NOTE: the ClassWizard will add DDX and DDV calls here
                DDX_Control(pDX, IDC_PROCESS_LIST, m_ProcessList);
        //}}AFX_DATA_MAP

}  // end CDomainProcessesPage::DoDataExchange


#ifdef _DEBUG
///////////////////////////////////////
// F'N: CDomainProcessesPage::AssertValid
//
void CDomainProcessesPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CDomainProcessesPage::AssertValid


////////////////////////////////
// F'N: CDomainProcessesPage::Dump
//
void CDomainProcessesPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CDomainProcessesPage::Dump

#endif //_DEBUG


//////////////////////////////////////////
// F'N: CDomainProcessesPage::OnSize
//
void CDomainProcessesPage::OnSize(UINT nType, int cx, int cy)
{
    RECT rect;
    GetClientRect(&rect);

    rect.top += LIST_TOP_OFFSET;

    if(m_ProcessList.GetSafeHwnd())
            m_ProcessList.MoveWindow(&rect, TRUE);

    // CFormView::OnSize(nType, cx, cy);

}  // end CDomainProcessesPage::OnSize

static ColumnDef ProcColumns[] = {
        CD_SERVER,
        CD_USER,
        CD_SESSION,
        CD_PROC_ID,
        CD_PROC_PID,
        CD_PROC_IMAGE
};

#define NUM_DOMAIN_PROC_COLUMNS sizeof(ProcColumns)/sizeof(ColumnDef)

//////////////////////////////////////////
// F'N: CDomainProcessesPage::OnInitialUpdate
//
void CDomainProcessesPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        // Add the column headings
        CString columnString;

        for(int col = 0; col < NUM_DOMAIN_PROC_COLUMNS; col++) {
                columnString.LoadString(ProcColumns[col].stringID);
                m_ProcessList.InsertColumn(col, columnString, ProcColumns[col].format, ProcColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_PROC_COL_SERVER;

}  // end CDomainProcessesPage::OnInitialUpdate


////////////////////////////////
// F'N: CDomainProcessesPage::Reset
//
void CDomainProcessesPage::Reset(void *pDomain)
{
        ASSERT(pDomain);

        // We don't want to display processes until the user clicks
        // on the "Processes" tab
    m_pDomain = (CDomain*)pDomain;

}  // end CDomainProcessesPage::Reset


//////////////////////////////////////////
// F'N: CDomainProcessesPage::AddServer
//
void CDomainProcessesPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add the Server's processes to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            LockListControl();
            SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
    }

}  // end CDomainProcessesPage::AddServer


//////////////////////////////////////////
// F'N: CDomainProcessesPage::RemoveServer
//
void CDomainProcessesPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        LockListControl();

        int ItemCount = m_ProcessList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(item-1);
                CServer *pListServer = pProcess->GetServer();

                if(pListServer == pServer) {
                        m_ProcessList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

        UnlockListControl();

}  // end CDomainProcessesPage::RemoveServer


//////////////////////////////
// F'N: CDomainProcessesPage::UpdateServer
//
void CDomainProcessesPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

} // end CDomainProcessesPage::UpdateServer


//////////////////////////////////////////
// F'N: CDomainProcessesPage::UpdateProcesses
//
void CDomainProcessesPage::UpdateProcesses(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
        BOOL bAnyChanged = FALSE;
        BOOL bAnyAdded = FALSE;

        // Loop through the processes
        pServer->LockProcessList();
        CObList *pProcessList = pServer->GetProcessList();

        POSITION pos = pProcessList->GetHeadPosition();

        while(pos) {
                CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

                // If this is a 'system' process and we aren't currently showing them,
                // go to the next process
                if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
                        continue;

                // If this user is not an Admin, don't show him someone else's processes unless it
                // is a System process
                if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers() && !pProcess->IsSystemProcess())
                        continue;

                // If the process is new, add it to the list
                if(pProcess->IsNew()) {

                        if(AddProcessToList(pProcess) != -1)
                                bAnyAdded = TRUE;
                        continue;
                }

                LV_FINDINFO FindInfo;
                FindInfo.flags = LVFI_PARAM;
                FindInfo.lParam = (LPARAM)pProcess;

                // Find the Process in our list
                int item = m_ProcessList.FindItem(&FindInfo, -1);

                // If the process is no longer current,
                // remove it from the list
                if(!pProcess->IsCurrent() && item != -1) {
                        // Remove the Process from the list
                        m_ProcessList.DeleteItem(item);
                        pProcess->ClearSelected();
                }

                // If the process info has changed, change
                // it's info in our tree
                if(pProcess->IsChanged() && item != -1)
                {
                        // WinStation Name
                        CWinStation *pWinStation = pProcess->GetWinStation();
                        if(pWinStation)
                        {
                                if(pWinStation->GetName()[0])
                                        m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, pWinStation->GetName());
                                else
                                {
                                        CString NameString(" ");
                                        if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                                        if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                                        m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, NameString);
                                }
                        }

                        if(m_CurrentSortColumn == AS_PROC_COL_WINSTATION)
                                bAnyChanged = TRUE;
                }
        }

        pServer->UnlockProcessList();

        if(bAnyChanged || bAnyAdded) {
                LockListControl();
                SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);
                UnlockListControl();
        }

}  // end CDomainProcessesPage::UpdateProcesses


//////////////////////////////////////////
// F'N: CDomainProcessesPage::RemoveProcess
//
void CDomainProcessesPage::RemoveProcess(CProcess *pProcess)
{
        ASSERT(pProcess);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pProcess->GetServer()->GetDomain()) return;

        LockListControl();

        // Find out how many items in the list
        int ItemCount = m_ProcessList.GetItemCount();

        // Go through the items and remove this process
        for(int item = 0; item < ItemCount; item++) {
                CProcess *pListProcess = (CProcess*)m_ProcessList.GetItemData(item);

                if(pListProcess == pProcess) {
                        m_ProcessList.DeleteItem(item);
                        break;
                }
        }

        UnlockListControl();
}


//////////////////////////////////////////
// F'N: CDomainProcessesPage::AddProcessToList
//
int CDomainProcessesPage::AddProcessToList(CProcess *pProcess)
{
        ASSERT(pProcess);

        CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
        CServer *pServer = pProcess->GetServer();

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return -1;

        LockListControl();
        // Server - put at end of list
        int item = m_ProcessList.InsertItem(m_ProcessList.GetItemCount(), pProcess->GetServer()->GetName(), NULL);

        // User
        m_ProcessList.SetItemText(item, AS_PROC_COL_USER, pProcess->GetUserName());

        // WinStation Name
        CWinStation *pWinStation = pProcess->GetWinStation();
        if(pWinStation) {
                if(pWinStation->GetName()[0])
                    m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, pWinStation->GetName());
                else {
                        CString NameString(" ");
                        if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                        if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                    m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, NameString);
                }
        }

        // ID
        CString ProcString;
        ProcString.Format(TEXT("%lu"), pProcess->GetLogonId());
        m_ProcessList.SetItemText(item, AS_PROC_COL_ID, ProcString);

        // PID
        ProcString.Format(TEXT("%lu"), pProcess->GetPID());
        m_ProcessList.SetItemText(item, AS_PROC_COL_PID, ProcString);

        // Image
        m_ProcessList.SetItemText(item, AS_PROC_COL_IMAGE, pProcess->GetImageName());
        m_ProcessList.SetItemData(item, (DWORD_PTR)pProcess);

        m_ProcessList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_SELECTED | LVIS_FOCUSED );

        UnlockListControl();

        return item;

}  // end CDomainProcessesPage::AddProcessToList


////////////////////////////////
// F'N: CDomainProcessesPage::AddServerToList
//
BOOL CDomainProcessesPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return FALSE;

        CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();

        pServer->EnumerateProcesses();
        CObList *pProcessList = pServer->GetProcessList();
        pServer->LockProcessList();

        POSITION pos = pProcessList->GetHeadPosition();

        while(pos) {
                CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

                // If this is a 'system' process and we aren't currently showing them,
                // go to the next process
                if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
                        continue;

                // If this user is not an Admin, don't show him someone else's processes unless it
                // is a System process
                if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers() && !pProcess->IsSystemProcess())
                        continue;

                AddProcessToList(pProcess);
        }

        pServer->UnlockProcessList();

    return TRUE;

}  // end CDomainProcessesPage::AddServerToList


////////////////////////////////
// F'N: CDomainProcessesPage::DisplayProcesses
//
void CDomainProcessesPage::DisplayProcesses()
{
        CWaitCursor Nikki;

        LockListControl();

        // Clear out the list control
        m_ProcessList.DeleteAllItems();

        // Get a pointer to the document's list of servers
        CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

        ((CWinAdminDoc*)GetDocument())->LockServerList();
        // Iterate through the server list
        POSITION pos = pServerList->GetHeadPosition();

        while(pos) {

                CServer *pServer = (CServer*)pServerList->GetNext(pos);

                if(pServer->IsServerSane()) {
                        AddServerToList(pServer);
                }  // end if(pServer->IsServerSane())

        } // end while(pos)

        ((CWinAdminDoc*)GetDocument())->UnlockServerList();

        UnlockListControl();

}  // end CDomainProcessesPage::DisplayProcesses


//////////////////////////////////////////
// F'N: CDomainProcessesPage::OnProcessItemChanged
//
void CDomainProcessesPage::OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;

        if(pLV->uNewState & LVIS_SELECTED) {
                CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
                pProcess->SetSelected();
        }

        if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
                CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
                pProcess->ClearSelected();
        }

        *pResult = 0;

}  // end CDomainProcessesPage::OnProcessItemChanged


//////////////////////////////////////////
// F'N: CDomainProcessesPage::OnColumnclick
//
void CDomainProcessesPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CDomainProcessesPage::OnColumnclick


//////////////////////////////////////////
// F'N: CDomainProcessesPage::OnContextMenu
//
void CDomainProcessesPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_ProcessList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_ProcessList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_ProcessList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }
                /*
                RECT rect;
                m_ProcessList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_ProcessList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                        return;
        }

        CMenu menu;
        menu.LoadMenu(IDR_PROCESS_POPUP);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CDomainProcessesPage::OnContextMenu


////////////////////////////////
// MESSAGE MAP: CDomainLicensesPage
//
IMPLEMENT_DYNCREATE(CDomainLicensesPage, CFormView)

BEGIN_MESSAGE_MAP(CDomainLicensesPage, CFormView)
        //{{AFX_MSG_MAP(CDomainLicensesPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_LICENSE_LIST, OnColumnclick)
        ON_NOTIFY(NM_SETFOCUS, IDC_LICENSE_LIST, OnSetfocusLicenseList)
        //ON_NOTIFY(NM_KILLFOCUS, IDC_LICENSE_LIST, OnKillfocusLicenseList)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CDomainLicensesPage ctor
//
CDomainLicensesPage::CDomainLicensesPage()
        : CAdminPage(CDomainLicensesPage::IDD)
{
        //{{AFX_DATA_INIT(CDomainLicensesPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_pDomain = NULL;
    m_bSortAscending = TRUE;

}  // end CDomainLicensesPage ctor


/////////////////////////////
// F'N: CDomainLicensesPage dtor
//
CDomainLicensesPage::~CDomainLicensesPage()
{

}  // end CDomainLicensesPage dtor


////////////////////////////////////////
// F'N: CDomainLicensesPage::DoDataExchange
//
void CDomainLicensesPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDomainLicensesPage)
        DDX_Control(pDX, IDC_LICENSE_LIST, m_LicenseList);
        //}}AFX_DATA_MAP

}  // end CDomainLicensesPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CDomainLicensesPage::AssertValid
//
void CDomainLicensesPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CDomainLicensesPage::AssertValid


//////////////////////////////
// F'N: CDomainLicensesPage::Dump
//
void CDomainLicensesPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CDomainLicensesPage::Dump
#endif //_DEBUG


/////////////////////////////////////
// F'N: CDomainLicensesPage::OnSize
//
void CDomainLicensesPage::OnSize(UINT nType, int cx, int cy)
{
    RECT rect;
    GetClientRect(&rect);

    rect.top += LIST_TOP_OFFSET;

    if(m_LicenseList.GetSafeHwnd())
            m_LicenseList.MoveWindow(&rect, TRUE);

    // CFormView::OnSize(nType, cx, cy);

}  // end CDomainLicensesPage::OnSize


static ColumnDef LicenseColumns[] = {
        CD_SERVER,
        CD_LICENSE_DESC,
        CD_LICENSE_REG,
        CD_USERCOUNT,
        CD_POOLCOUNT,
        CD_LICENSE_NUM,
};

#define NUM_DOMAIN_LICENSE_COLUMNS sizeof(LicenseColumns)/sizeof(ColumnDef)

/////////////////////////////////////
// F'N: CDomainLicensesPage::OnInitialUpdate
//
void CDomainLicensesPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        BuildImageList();               // builds the image list for the list control

        CString columnString;

        for(int col = 0; col < NUM_DOMAIN_LICENSE_COLUMNS; col++) {
                columnString.LoadString(LicenseColumns[col].stringID);
                m_LicenseList.InsertColumn(col, columnString, LicenseColumns[col].format, LicenseColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_LICENSE_COL_SERVER;

}  // end CDomainLicensesPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CDomainLicensePage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CDomainLicensesPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 5, 0);

        m_idxBase = AddIconToImageList(IDI_BASE);
        m_idxBump = AddIconToImageList(IDI_BUMP);
        m_idxEnabler = AddIconToImageList(IDI_ENABLER);
        m_idxUnknown = AddIconToImageList(IDI_UNKNOWN);

        m_LicenseList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CDomainLicensesPage::BuildImageList


/////////////////////////////////////////
// F'N: CDomainLicensesPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CDomainLicensesPage::AddIconToImageList(int iconID)
{
        HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
        return m_ImageList.Add(hIcon);

}  // end CDomainLicensesPage::AddIconToImageList


/////////////////////////////////////
// F'N: CDomainLicensesPage::Reset
//
void CDomainLicensesPage::Reset(void *pDomain)
{
        ASSERT(pDomain);

    m_pDomain = (CDomain*)pDomain;
        DisplayLicenses();

}  // end CDomainLicensesPage::Reset


/////////////////////////////////////
// F'N: CDomainLicensesPage::AddServer
//
void CDomainLicensesPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add the Server's licenses to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_LICENSES, &m_LicenseList, m_CurrentSortColumn, m_bSortAscending);
    }

}  // end F'N: CDomainLicensesPage::AddServer


/////////////////////////////////////
// F'N: CDomainLicensesPage::RemoveServer
//
void CDomainLicensesPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        int ItemCount = m_LicenseList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CLicense *pLicense = (CLicense*)m_LicenseList.GetItemData(item-1);
                CServer *pListServer = pLicense->GetServer();

                if(pListServer == pServer) {
                        m_LicenseList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

}  // end CDomainLicensesPage::RemoveServer


//////////////////////////////
// F'N: CDomainLicensesPage::UpdateServer
//
void CDomainLicensesPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

        if(pServer->IsState(SS_GOOD))
                AddServer(pServer);

} // end CDomainLicensesPage::UpdateServer


/////////////////////////////////////
// F'N: CDomainLicensesPage::AddServerToList
//
BOOL CDomainLicensesPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return FALSE;

        int item;

        pServer->LockLicenseList();

        // Get a pointer to the Server's list of licenses
        CObList *pLicenseList = pServer->GetLicenseList();

        // Iterate through the License list
        POSITION pos = pLicenseList->GetHeadPosition();

        while(pos) {
                CLicense *pLicense = (CLicense*)pLicenseList->GetNext(pos);

                //////////////////////
                // Fill in the columns
                //////////////////////
                int WhichIcon;

                switch(pLicense->GetClass()) {
                        case LicenseBase:
                                WhichIcon = m_idxBase;
                                break;
                        case LicenseBump:
                                WhichIcon = m_idxBump;
                                break;
                        case LicenseEnabler:
                                WhichIcon = m_idxEnabler;
                                break;
                        case LicenseUnknown:
                                WhichIcon = m_idxUnknown;
                                break;
                }

                // Server Name
                item = m_LicenseList.InsertItem(m_LicenseList.GetItemCount(), pServer->GetName(), WhichIcon);

                // Description
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_DESCRIPTION, pLicense->GetDescription());

                // Registered
                CString RegString;
                RegString.LoadString(pLicense->IsRegistered() ? IDS_YES : IDS_NO);
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_REGISTERED, RegString);

                BOOL bUnlimited = (pLicense->GetClass() == LicenseBase
                        && pLicense->GetTotalCount() == 4095
                        && pServer->GetCTXVersionNum() == 0x00000040);

                // User (Total) Count
                CString CountString;
                if(bUnlimited)
                        CountString.LoadString(IDS_UNLIMITED);
                else
                        CountString.Format(TEXT("%lu"), pLicense->GetTotalCount());

                m_LicenseList.SetItemText(item, AS_LICENSE_COL_USERCOUNT, CountString);

                // Pool Count
                if(bUnlimited)
                        CountString.LoadString(IDS_NOT_APPLICABLE);
                else
                        CountString.Format(TEXT("%lu"), pLicense->GetPoolCount());
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_POOLCOUNT, CountString);

                // License Number
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_NUMBER, pLicense->GetLicenseNumber());

                m_LicenseList.SetItemData(item, (DWORD_PTR)pLicense);
        }  // end while(pos)

        m_LicenseList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );
        
        pServer->UnlockLicenseList();

    return TRUE;

}  // end CDomainLicensesPage::AddServerToList


/////////////////////////////////////
// F'N: CDomainLicensesPage::DisplayLicenses
//
void CDomainLicensesPage::DisplayLicenses()
{
        // Clear out the list control
        m_LicenseList.DeleteAllItems();

        // Get a pointer to the document's list of servers
        CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

        ((CWinAdminDoc*)GetDocument())->LockServerList();
        // Iterate through the server list
        POSITION pos = pServerList->GetHeadPosition();

        while(pos) {
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                AddServerToList(pServer);
        }

        ((CWinAdminDoc*)GetDocument())->UnlockServerList();

}  // end CDomainLicensesPage::DisplayLicenses


/////////////////////////////////////
// F'N: CDomainLicensesPage::OnColumnclick
//
void CDomainLicensesPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_LICENSES, &m_LicenseList, m_CurrentSortColumn, m_bSortAscending);

        *pResult = 0;

}  // end CDomainLicensesPage::OnColumnclick


void CDomainUsersPage::OnSetfocusUserList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CDomainUsersPage::OnSetfocusUserList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_UserList.Invalidate();

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;       
}

void CDomainProcessesPage::OnSetfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CDomainProcessesPage::OnSetfocusProcessList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_ProcessList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CDomainWinStationsPage::OnSetfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CDomainWinStationsPage::OnSetfocusWinstationList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_StationList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CDomainServersPage::OnSetfocusServerList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CDomainServersPage::OnSetfocusServerList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_ServerList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CDomainLicensesPage::OnSetfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CDomainLicensesPage::OnSetfocusLicenseList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_LicenseList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}


void CDomainUsersPage::OnKillfocusUserList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_UserList.Invalidate( );
}

void CDomainProcessesPage::OnKillfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_ProcessList.Invalidate( );
}

void CDomainWinStationsPage::OnKillfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_StationList.Invalidate( );
}

void CDomainServersPage::OnKillfocusServerList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_ServerList.Invalidate( );
}

void CDomainLicensesPage::OnKillfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_LicenseList.Invalidate( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\dialogs.h ===
/*******************************************************************************
*
* dialogs.h
*
* declarations of all the dialog classes
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\dialogs.h  $
*  
*     Rev 1.3   19 Jan 1998 16:46:10   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.2   13 Oct 1997 18:40:20   donm
*  update
*  
*     Rev 1.1   26 Aug 1997 19:14:28   donm
*  bug fixes/changes from WinFrame 1.7
*  
*     Rev 1.0   30 Jul 1997 17:11:32   butchd
*  Initial revision.
*
*******************************************************************************/

#include "threads.h"
#include "led.h"

/////////////////////////////////////////////////////////////////////////////
// CSendMessageDlg dialog

class CSendMessageDlg : public CDialog
{
// Construction
public:
	CSendMessageDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSendMessageDlg)
	enum { IDD = IDD_MESSAGE };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

    TCHAR m_szUserName[USERNAME_LENGTH+1];
    TCHAR m_szTitle[MSG_TITLE_LENGTH+1];
    TCHAR m_szMessage[MSG_MESSAGE_LENGTH+1];

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSendMessageDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSendMessageDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnCommandHelp(void);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CShadowStartDlg dialog

class CShadowStartDlg : public CDialog
{
// Construction
public:
	CShadowStartDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CShadowStartDlg)
	enum { IDD = IDD_SHADOWSTART };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	DWORD m_ShadowHotkeyShift;
	int m_ShadowHotkeyKey;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CShadowStartDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CShadowStartDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnSelChange( );
	afx_msg void OnCommandHelp(void);

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg dialog

typedef enum _PwdMode {
	PwdDlg_UserMode,
	PwdDlg_WinStationMode
} PwdMode;

class CPasswordDlg : public CDialog
{
// Construction
public:
	CPasswordDlg(CWnd* pParent = NULL);   // standard constructor
	LPCTSTR GetPassword() { return m_szPassword; }
	void SetDialogMode(PwdMode mode) { m_DlgMode = mode; }

// Dialog Data
	//{{AFX_DATA(CPasswordDlg)
	enum { IDD = IDD_CONNECT_PASSWORD };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPasswordDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	PwdMode m_DlgMode;
	TCHAR m_szPassword[PASSWORD_LENGTH+1];

	// Generated message map functions
	//{{AFX_MSG(CPasswordDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CPreferencesDlg dialog
const int MAX_AUTOREFRESH_DIGITS = 5;
const int MIN_AUTOREFRESH_VALUE = 1;
const int MAX_AUTOREFRESH_VALUE = 9999;

class CPreferencesDlg : public CDialog
{
// Construction
public:
	CPreferencesDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPreferencesDlg)
	enum { IDD = IDD_PREFERENCES };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPreferencesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

private:

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPreferencesDlg)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnPreferencesProcManual();
	afx_msg void OnPreferencesProcEvery();
	afx_msg void OnPreferencesStatusEvery();
	afx_msg void OnPreferencesStatusManual();
	afx_msg void OnClose();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CStatusDlg dialog

class CStatusDlg : public CDialog
{
// Construction
public:
	CStatusDlg(CWinStation *pWinStation, UINT Id, CWnd* pParent = NULL);   // standard constructor
	CWSStatusThread *m_pWSStatusThread;

protected:
	virtual void InitializeStatus();
    virtual void SetInfoFields( PWINSTATIONINFORMATION pCurrent,
                                PWINSTATIONINFORMATION pNew );

	// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStatusDlg)
	protected:
	virtual void PostNcDestroy();
	virtual BOOL PreTranslateMessage(MSG *pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	CWinStation *m_pWinStation;
//    ULONG m_LogonId;
    BOOL m_bReadOnly;
    WINSTATIONNAME m_WSName;
    SIZE m_LittleSize;
    SIZE m_BigSize;
    BOOL m_bWeAreLittle;
    BOOL m_bResetCounters;
    BOOL m_bReliable;
    WINSTATIONINFORMATION m_WSInfo;
    PROTOCOLSTATUS m_BaseStatus;
    UINT m_IBytesPerFrame;
    UINT m_OBytesPerFrame;
    TCHAR m_szIPercentFrameErrors[10];
    TCHAR m_szOPercentFrameErrors[10];
    TCHAR m_szICompressionRatio[10];
    TCHAR m_szOCompressionRatio[10];

	// Generated message map functions
	//{{AFX_MSG(CStatusDlg)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
    afx_msg LRESULT OnStatusStart(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnStatusReady(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnStatusAbort(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnRefreshNow(WPARAM wParam, LPARAM lParam);
	afx_msg void OnResetcounters();
	afx_msg void OnClickedRefreshnow();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CAsyncStatusDlg dialog
#define NUM_LEDS    6
#define ASYNC_LED_TOGGLE_MSEC   200

class CAsyncStatusDlg : public CStatusDlg
{
// Construction
public:
	CAsyncStatusDlg(CWinStation *pWinStation, CWnd* pParent = NULL);   // standard constructor
	~CAsyncStatusDlg();

    HBRUSH m_hRedBrush;
    UINT_PTR m_LEDToggleTimer;
    CLed *  m_pLeds[NUM_LEDS];


// Dialog Data
	//{{AFX_DATA(CAsyncStatusDlg)
	enum { IDD = IDD_ASYNC_STATUS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAsyncStatusDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void SetInfoFields( PWINSTATIONINFORMATION pCurrent,
                        PWINSTATIONINFORMATION pNew );
    void InitializeStatus();

	// Generated message map functions
	//{{AFX_MSG(CAsyncStatusDlg)
		afx_msg LRESULT OnStatusStart(WPARAM wParam, LPARAM lParam);
	    afx_msg LRESULT OnStatusReady(WPARAM wParam, LPARAM lParam);
		afx_msg LRESULT OnStatusAbort(WPARAM wParam, LPARAM lParam);
		afx_msg LRESULT OnRefreshNow(WPARAM wParam, LPARAM lParam);
		afx_msg void OnResetcounters();
		afx_msg void OnClickedRefreshnow();
		afx_msg void OnMoreinfo();
	    afx_msg void OnTimer(UINT nIDEvent);
		afx_msg void OnNcDestroy();
		virtual BOOL OnInitDialog();
	    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
		afx_msg void OnCommandHelp(void);

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CNetworkStatusDlg dialog

class CNetworkStatusDlg : public CStatusDlg
{
// Construction
public:
	CNetworkStatusDlg(CWinStation *pWinStation, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNetworkStatusDlg)
	enum { IDD = IDD_NETWORK_STATUS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetworkStatusDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNetworkStatusDlg)
	afx_msg LRESULT OnStatusStart(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnStatusReady(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnStatusAbort(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnRefreshNow(WPARAM wParam, LPARAM lParam);
	afx_msg void OnResetcounters();
	afx_msg void OnClickedRefreshnow();
	afx_msg void OnMoreinfo();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnCommandHelp(void);

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CMyDialog dialog

class CMyDialog : public CDialog
{
// Construction
public:
	CMyDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CMyDialog)
	enum { IDD = IDD_DIALOG_FINDSERVER };
	CString	m_cstrServerName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMyDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMyDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\led.h ===
/*******************************************************************************
*
* led.h
*
* interface of CLed class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\LED.H  $
*  
*     Rev 1.0   30 Jul 1997 17:11:38   butchd
*  Initial revision.
*
*******************************************************************************/

#ifndef LED_INCLUDED
////////////////////////////////////////////////////////////////////////////////
// CLed class
//
class CLed : public CStatic
{

/*
 * Member variables.
 */
	//{{AFX_DATA(CLed)
	//}}AFX_DATA
private:
    HBRUSH          m_hBrush;
    BOOL            m_bOn;

/* 
 * Implementation.
 */
public:
	CLed( HBRUSH hBrush );

/*
 * Operations.
 */
public:
    void Subclass( CStatic *pStatic );
    void Update(int nOn);
    void Toggle();

/*
 * Message map / commands.
 */
protected:
	//{{AFX_MSG(CLed)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end CLed class interface 
////////////////////////////////////////////////////////////////////////////////
#endif  // LED_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\listenvw.cpp ===
/*******************************************************************************
*
* listenvw.cpp
*
* implementation of the CListenerView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\LISTENVW.CPP  $
*  
*     Rev 1.0   30 Jul 1997 17:11:42   butchd
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "listenvw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// listener

IMPLEMENT_DYNCREATE(CListenerView, CFormView)

CListenerView::CListenerView()
	: CFormView(CListenerView::IDD)
{
	//{{AFX_DATA_INIT(CListenerView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CListenerView::~CListenerView()
{
}

void CListenerView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBadServerView)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CListenerView, CFormView)
	//{{AFX_MSG_MAP(CListenerView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CListenerView diagnostics

#ifdef _DEBUG
void CListenerView::AssertValid() const
{
	CFormView::AssertValid();
}

void CListenerView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CListenerView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\domainvw.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* domainvw.h
*
* declarations for the CDomainView class
*
*  
*******************************************************************************/

#ifndef _DOMAINVIEW_H
#define _DOMAINVIEW_H

#include "domainpg.h"

const int NUMBER_OF_DOMAIN_PAGES = 5;


////////////////////
// CLASS: CDomainView
//
class CDomainView : public CAdminView
{
friend class CRightPane;

private:
	CTabCtrl*	m_pTabs;
	CFont*      m_pTabFont;

	int m_CurrPage;

		
protected:
	CDomainView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CDomainView)

// Attributes
public:

protected:
   static PageDef pages[NUMBER_OF_DOMAIN_PAGES];

// Operations
public:
	int GetCurrentPage() { return m_CurrPage; }
protected:
	virtual void Reset(void *);

	void AddTab(int index, TCHAR* text, ULONG pageindex);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CDomainView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	// Generated message map functions
protected:
	//{{AFX_MSG(CDomainView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg LRESULT OnChangePage(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminAddServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnNextPane( WPARAM , LPARAM );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CDomainView

#endif  // _DOMAINVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\domainvw.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* domainvw.cpp
*
* implementation of the CDomainView class
*
*  
*******************************************************************************/

#include "stdafx.h"
#include "resource.h"
#include "domainvw.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


PageDef CDomainView::pages[] = {
	{ NULL, RUNTIME_CLASS( CDomainServersPage ),    IDS_TAB_SERVERS,     PAGE_DOMAIN_SERVERS,	PF_PICASSO_ONLY},
	{ NULL, RUNTIME_CLASS( CDomainUsersPage ),      IDS_TAB_USERS,       PAGE_DOMAIN_USERS,		NULL           },
	{ NULL, RUNTIME_CLASS( CDomainWinStationsPage ),IDS_TAB_WINSTATIONS, PAGE_DOMAIN_WINSTATIONS,NULL           },
	{ NULL, RUNTIME_CLASS( CDomainProcessesPage ),  IDS_TAB_PROCESSES,   PAGE_DOMAIN_PROCESSES,	NULL           },
	{ NULL, RUNTIME_CLASS( CDomainLicensesPage ),   IDS_TAB_LICENSES,    PAGE_DOMAIN_LICENSES,	PF_PICASSO_ONLY}    
};


//////////////////////////
// MESSAGE MAP: CDomainView
//
IMPLEMENT_DYNCREATE(CDomainView, CView)

BEGIN_MESSAGE_MAP(CDomainView, CView)
	//{{AFX_MSG_MAP(CDomainView)
	ON_WM_SIZE()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_WA_SERVER_CHANGEPAGE, OnChangePage)
	ON_MESSAGE(WM_ADMIN_ADD_SERVER, OnAdminAddServer)
	ON_MESSAGE(WM_ADMIN_REMOVE_SERVER, OnAdminRemoveServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER, OnAdminUpdateServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_PROCESSES, OnAdminUpdateProcesses)
	ON_MESSAGE(WM_ADMIN_REMOVE_PROCESS, OnAdminRemoveProcess)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_PROCESSES, OnAdminRedisplayProcesses)
	ON_NOTIFY(TCN_SELCHANGE, IDC_DOMAIN_TABS, OnTabSelChange)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER_INFO, OnAdminUpdateServerInfo)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_LICENSES, OnAdminRedisplayLicenses)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATIONS, OnAdminUpdateWinStations)
    ON_MESSAGE( WM_ADMIN_TABBED_VIEW , OnTabbed )
    ON_MESSAGE( WM_ADMIN_SHIFTTABBED_VIEW , OnShiftTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLTABBED_VIEW , OnCtrlTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLSHIFTTABBED_VIEW , OnCtrlShiftTabbed )
    ON_MESSAGE( WM_ADMIN_NEXTPANE_VIEW , OnNextPane )
END_MESSAGE_MAP()


///////////////////////
// F'N: CDomainView ctor
//
CDomainView::CDomainView()
{
	m_pTabs       = NULL;
	m_pTabFont    = NULL;

	m_CurrPage = PAGE_DOMAIN_USERS;

}  // end CDomainView ctor


///////////////////////
// F'N: CDomainView dtor
//
CDomainView::~CDomainView()
{
	if(m_pTabs)    delete m_pTabs;
	if(m_pTabFont) delete m_pTabFont;

}  // end CDomainView dtor


#ifdef _DEBUG
///////////////////////////////
// F'N: CDomainView::AssertValid
//
void CDomainView::AssertValid() const
{
	CView::AssertValid();

}  // end CDomainView::AssertValid


////////////////////////
// F'N: CDomainView::Dump
//
void CDomainView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CDomainView::Dump

#endif //_DEBUG


////////////////////////////
// F'N: CDomainView::OnCreate
//
int CDomainView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;

}  // end CDomainView::OnCreate


///////////////////////////////////
// F'N: CDomainView::OnInitialUpdate
//
//
void CDomainView::OnInitialUpdate() 
{
	// Determine whether we are running under Picasso
	BOOL bPicasso = ((CWinAdminApp*)AfxGetApp())->IsPicasso();

	// create the Tabs
	m_pTabs = new CMyTabCtrl;
    if(!m_pTabs) return;
	m_pTabs->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, CRect(0,0,0,0), this, IDC_DOMAIN_TABS);


	m_pTabFont = new CFont;
    if(m_pTabFont) {
	    m_pTabFont->CreateStockObject(DEFAULT_GUI_FONT);
	    m_pTabs->SetFont(m_pTabFont, TRUE);
    }

	TCHAR szTemp[40];
	CString tabString;

	int index = 0;
	for(int i = 0; i < NUMBER_OF_DOMAIN_PAGES; i++) {
		// If the page is shown under Picasso only and we're not running
		// under Picasso, skip to the next one
		if((pages[i].flags & PF_PICASSO_ONLY) && !bPicasso) continue;
		tabString.LoadString(pages[i].tabStringID);
		wcscpy(szTemp,tabString);
		AddTab(index, szTemp, i);
		pages[i].m_pPage = (CAdminPage*)pages[i].m_pRuntimeClass->CreateObject();
		pages[i].m_pPage->Create(NULL, NULL, WS_CHILD, CRect(0, 0, 0, 0), this, i, NULL);
		GetDocument()->AddView(pages[i].m_pPage);
		index++;
	}

	m_pTabs->SetCurSel(0);	

	m_CurrPage = bPicasso ? PAGE_DOMAIN_SERVERS : PAGE_DOMAIN_USERS;

	// post a changepage msg to display the page for the currently selected tab
//	PostMessage(WM_WA_SERVER_CHANGEPAGE);

}  // end CDomainView::OnInitialUpdate


//////////////////////////
// F'N: CDomainView::OnSize
//
// 
//
void CDomainView::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);
	if(m_pTabs->GetSafeHwnd())  {			// make sure the Tabs object is valid
		m_pTabs->MoveWindow(&rect, TRUE);	// size the tabs

		// for the next part (sizing of pages), we might want to add a member var
		// that keeps track of which page/tab is current... this way we could
		// only actually do a redraw (MoveWindow second parm == TRUE) for the
		// guy who is currently visible--DJM
	
		// we want to size the pages, too
		m_pTabs->AdjustRect(FALSE, &rect);

      for(int i = 0; i < NUMBER_OF_DOMAIN_PAGES; i++) {
         if(pages[i].m_pPage && pages[i].m_pPage->GetSafeHwnd())
            pages[i].m_pPage->MoveWindow(&rect, TRUE);
      }
	}

}  // end CDomainView::OnSize


//////////////////////////
// F'N: CDomainView::OnDraw
//
// - the CDomainView and it's pages draw themselves, so there isn't anything
//   to do here...
//
void CDomainView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here

}  // end CDomainView::OnDraw


/////////////////////////
// F'N: CDomainView::Reset
//
// - 'resets' the view
//
void CDomainView::Reset(void *p)
{
	CWaitCursor Nikki;
	SendMessage(WM_WA_SERVER_CHANGEPAGE);	// ???	Post

	// Clear out the selected flags for each server
	// Get a pointer to our document
	CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();

	// Get a pointer to the list of servers
	doc->LockServerList();
	CObList *pServerList = doc->GetServerList();

	// Iterate through the Server list
	POSITION pos = pServerList->GetHeadPosition();

	while(pos) {
		CServer *pServer = (CServer*)pServerList->GetNext(pos);
		pServer->ClearAllSelected();
	}

	doc->UnlockServerList();

	// This is necessary until we update on the fly
	for(int i = 0; i < NUMBER_OF_DOMAIN_PAGES; i++) {
		if(pages[i].m_pPage)
			pages[i].m_pPage->Reset(p);
	}

	((CWinAdminDoc*)GetDocument())->SetCurrentPage(m_CurrPage);

}  // end CDomainView::Reset


//////////////////////////
// F'N: CDomainView::AddTab
//
void CDomainView::AddTab(int index, TCHAR* text, ULONG pageindex)
{
	TC_ITEM tc;
	tc.mask = TCIF_TEXT | TCIF_PARAM;
	tc.pszText = text;
	tc.lParam = pageindex;

	m_pTabs->InsertItem(index, &tc);

}  // end CDomainView::AddTab


////////////////////////////////
// F'N: CDomainView::OnChangePage
//
// - changes to a new server page based on currently selected tab
// - OnChangePage needs to force recalculation of scroll bars!!!--DJM
//
// If wParam is set, sets the focus to the page. This is currently
// only done when the user clicks on a tab
//
LRESULT CDomainView::OnChangePage(WPARAM wParam, LPARAM lParam)
{
	// find out which tab is now selected
	int tab = m_pTabs->GetCurSel();
	TC_ITEM tc;
	tc.mask = TCIF_PARAM;
	m_pTabs->GetItem(tab, &tc);
	int index = (int)tc.lParam;
				
	// switch to the appropriate view
	pages[m_CurrPage].m_pPage->ModifyStyle(WS_VISIBLE, WS_DISABLED);
    pages[m_CurrPage].m_pPage->ClearSelections();

	m_CurrPage = index;
	((CWinAdminDoc*)GetDocument())->SetCurrentPage(index);
	// show the new page
	pages[index].m_pPage->ModifyStyle(WS_DISABLED, WS_VISIBLE);
	pages[index].m_pPage->ScrollToPosition(CPoint(0,0));
	pages[index].m_pPage->Invalidate();
	if(wParam) pages[index].m_pPage->SetFocus();

	// Clear out the selected flags for each server
	// Get a pointer to our document
	CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();

	// Get a pointer to the list of servers
	doc->LockServerList();
	CObList *pServerList = doc->GetServerList();

	// Iterate through the Server list
	POSITION pos = pServerList->GetHeadPosition();

	while(pos) {
		CServer *pServer = (CServer*)pServerList->GetNext(pos);
		pServer->ClearAllSelected();
	}

	doc->UnlockServerList();

	// If the new page is the processes page, we want to display the processes now
	if(index == PAGE_DOMAIN_PROCESSES) ((CDomainProcessesPage*)pages[PAGE_DOMAIN_PROCESSES].m_pPage)->DisplayProcesses();

	return 0;

}  // end CDomainView::OnChangeview


void CDomainView::OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnChangePage(0L, NULL);
	*pResult = 0;

}  // end CDomainView::OnTabSelChange


LRESULT CDomainView::OnAdminAddServer(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_DOMAIN_SERVERS].m_pPage) {
		((CDomainServersPage*)pages[PAGE_DOMAIN_SERVERS].m_pPage)->AddServer((CServer*)lParam);
	}		
	((CDomainUsersPage*)pages[PAGE_DOMAIN_USERS].m_pPage)->AddServer((CServer*)lParam);
	((CDomainWinStationsPage*)pages[PAGE_DOMAIN_WINSTATIONS].m_pPage)->AddServer((CServer*)lParam);
	((CDomainProcessesPage*)pages[PAGE_DOMAIN_PROCESSES].m_pPage)->AddServer((CServer*)lParam);

    if(pages[PAGE_DOMAIN_LICENSES].m_pPage) {
        ((CDomainLicensesPage*)pages[PAGE_DOMAIN_LICENSES].m_pPage)->AddServer((CServer*)lParam);
    }
	
	return 0;

}  // end CDomainView::OnAdminAddServer


LRESULT CDomainView::OnAdminRemoveServer(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_DOMAIN_SERVERS].m_pPage) {
		((CDomainServersPage*)pages[PAGE_DOMAIN_SERVERS].m_pPage)->RemoveServer((CServer*)lParam);
	}
	((CDomainUsersPage*)pages[PAGE_DOMAIN_USERS].m_pPage)->RemoveServer((CServer*)lParam);
	((CDomainWinStationsPage*)pages[PAGE_DOMAIN_WINSTATIONS].m_pPage)->RemoveServer((CServer*)lParam);
	((CDomainProcessesPage*)pages[PAGE_DOMAIN_PROCESSES].m_pPage)->RemoveServer((CServer*)lParam);

    if(pages[PAGE_DOMAIN_LICENSES].m_pPage) {
        ((CDomainLicensesPage*)pages[PAGE_DOMAIN_LICENSES].m_pPage)->RemoveServer((CServer*)lParam);
    }

	return 0;

}  // end CDomainView::OnAdminRemoveServer


LRESULT CDomainView::OnAdminUpdateServer(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_DOMAIN_SERVERS].m_pPage) {
		((CDomainServersPage*)pages[PAGE_DOMAIN_SERVERS].m_pPage)->UpdateServer((CServer*)lParam);
	}
	((CDomainUsersPage*)pages[PAGE_DOMAIN_USERS].m_pPage)->UpdateServer((CServer*)lParam);
	((CDomainWinStationsPage*)pages[PAGE_DOMAIN_WINSTATIONS].m_pPage)->UpdateServer((CServer*)lParam);
	((CDomainProcessesPage*)pages[PAGE_DOMAIN_PROCESSES].m_pPage)->UpdateServer((CServer*)lParam);

    if(pages[PAGE_DOMAIN_LICENSES].m_pPage) {
        ((CDomainLicensesPage*)pages[PAGE_DOMAIN_LICENSES].m_pPage)->UpdateServer((CServer*)lParam);
    }

	return 0;

}  // end CDomainView::OnAdminUpdateServer


LRESULT CDomainView::OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam)
{
	((CDomainProcessesPage*)pages[PAGE_DOMAIN_PROCESSES].m_pPage)->UpdateProcesses((CServer*)lParam);

	return 0;

}  // end CDomainView::OnAdminUpdateProcesses


LRESULT CDomainView::OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam)
{
	((CDomainProcessesPage*)pages[PAGE_DOMAIN_PROCESSES].m_pPage)->RemoveProcess((CProcess*)lParam);

	return 0;

}  // end CDomainView::OnAdminRemoveProcess


LRESULT CDomainView::OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam)
{
	((CDomainProcessesPage*)pages[PAGE_DOMAIN_PROCESSES].m_pPage)->DisplayProcesses();

	return 0;

}  // end CDomainView::OnAdminRedisplayProcesses


LRESULT CDomainView::OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam)
{
	((CDomainUsersPage*)pages[PAGE_DOMAIN_USERS].m_pPage)->UpdateWinStations((CServer*)lParam);
	((CDomainWinStationsPage*)pages[PAGE_DOMAIN_WINSTATIONS].m_pPage)->UpdateWinStations((CServer*)lParam);

	return 0;

}  // end CDomainView::OnAdminUpdateWinStations


LRESULT CDomainView::OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_DOMAIN_SERVERS].m_pPage)
		((CDomainServersPage*)pages[PAGE_DOMAIN_SERVERS].m_pPage)->UpdateServer((CServer*)lParam);

	return 0;

}  // end CDomainView::OnAdminUpdateServerInfo
 

LRESULT CDomainView::OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam)
{
    if(pages[PAGE_DOMAIN_LICENSES].m_pPage)
        ((CDomainLicensesPage*)pages[PAGE_DOMAIN_LICENSES].m_pPage)->Reset((CServer*)lParam);

	return 0;

}  // end CDomainView::OnAdminRedisplayLicenses

LRESULT CDomainView::OnTabbed( WPARAM wp , LPARAM lp )
{
    ODS( L"CDomainView::OnTabbed " );
    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );
            // 
            // treeview should've started off with initial focus
            // we should 
            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );
                int nTab = m_pTabs->GetCurSel();
                
                m_pTabs->SetFocus( );
                m_pTabs->SetCurFocus( nTab );
                
                pDoc->RegisterLastFocus( TAB_CTRL );
            }
            else if( nFocus == TAB_CTRL )
            {
                ODS( L"from tab to item\n" );
                // set focus to item in page
                pages[ m_CurrPage ].m_pPage->SetFocus( );
                pDoc->RegisterLastFocus( PAGED_ITEM );
            }
            else
            {
                ODS( L"from item to treeview\n" );
                // set focus back to treeview

                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );
            }

            pDoc->SetPrevFocus( nFocus );
        }


    }

    return 0;
}

//=-------------------------------------------------------------------------
// OnShiftTabbed is called when the user wants to go back one 
// this code is duplicated in all view classes
LRESULT CDomainView::OnShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CDomainView::OnShiftTabbed " );

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            switch( nFocus )
            {
            case TREE_VIEW:

                ODS( L"going back from tree to paged item\n" );

                pages[ m_CurrPage ].m_pPage->SetFocus( );

                pDoc->RegisterLastFocus( PAGED_ITEM );

                break;
            case TAB_CTRL:
                {
                    ODS( L"going back from tab to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );
                }
                break;
            case PAGED_ITEM:
                {
                    ODS( L"going back from paged item to tab\n" );

                    int nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                break;
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}

//=-------------------------------------------------------------------------
// ctrl + tab works the same as tab but because of our unorthodox ui
// when under a tab control it will cycle over the tabs and back to the treeview
//
LRESULT CDomainView::OnCtrlTabbed( WPARAM , LPARAM )
{
    ODS( L"CDomainView::OnCtrlTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );

                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    m_pTabs->SetCurSel( 0 );
                    
                    OnChangePage( 0 , 0 );

                    nTab = 0;
                }

                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nTab );
                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                else
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab + 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab + 1 );

                }
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}


//=----------------------------------------------------------------------------
// same as OnCtrlTab but we focus on moving in the other direction
// tree_view to last tab -- current tab to ct - 1
//
LRESULT CDomainView::OnCtrlShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CDomainView::OnCtrlShiftTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );
                
                nMaxTab = m_pTabs->GetItemCount( );
                
                m_pTabs->SetCurSel( nMaxTab - 1 );
                
                OnChangePage( 0 , 0 );
                
                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nMaxTab - 1 );                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab > 0 )
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab - 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab - 1 );
                }
                else
                {

                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}

//=----------------------------------------------------------------------------
// When the user hits F6 we need to switch between pains
LRESULT CDomainView::OnNextPane( WPARAM , LPARAM )
{
    ODS( L"CDomainView::OnNextPane\n" );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            FOCUS_STATE nPrevFocus = pDoc->GetPrevFocus( );

            if( nFocus == TREE_VIEW )
            {
                if( nPrevFocus == TAB_CTRL )
                {
                    int nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );
                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                else
                {
                    pages[ m_CurrPage ].m_pPage->SetFocus( );
                    
                    pDoc->RegisterLastFocus( PAGED_ITEM );
                }
            }
            else
            {
                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );

            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\domainpg.h ===
/*******************************************************************************
*
* domainpg.h
*
* - declarations for the Domain info pages
* - the Domain info pages are all CFormView derivatives
* based on dialog templates
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\domainpg.h  $
*  
*     Rev 1.1   19 Jan 1998 16:47:40   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.0   03 Nov 1997 15:07:28   donm
*  Initial revision.
*  
*  
*******************************************************************************/


#ifndef _DOMAINPAGES_H
#define _DOMAINPAGES_H

#include "Resource.h"
#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "winadmin.h"


//////////////////////////
// CLASS: CDomainServersPage
//
class CDomainServersPage : public CAdminPage
{
friend class CDomainView;

protected:
	CDomainServersPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CDomainServersPage)

// Form Data
public:
	//{{AFX_DATA(CDomainServersPage)
	enum { IDD = IDD_ALL_SERVER_SERVERS };
	CListCtrl	m_ServerList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxServer;		// index of Server image
	int m_idxCurrentServer;	// index of Current Server image
	int m_idxNotSign;		// index of Not Sign overlay (for non-sane servers)
	int m_idxQuestion;	// index of Question Mark overlay (for non-opened servers)

private:
    CDomain *m_pDomain;
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
	
protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayServers();			
	virtual void Reset(void *);
	BOOL AddServerToList(CServer *pServer);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainServersPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CDomainServersPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CDomainServersPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnServerItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusServerList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusServerList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CDomainServersPage


//////////////////////////
// CLASS: CDomainUsersPage
//
class CDomainUsersPage : public CAdminPage
{
friend class CDomainView;

protected:
	CDomainUsersPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CDomainUsersPage)

// Form Data
public:
	//{{AFX_DATA(CDomainUsersPage)
	enum { IDD = IDD_ALL_SERVER_USERS };
	CListCtrl	m_UserList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxUser;			// index of User image
	int m_idxCurrentUser;	// index of Current User image

private:
    CDomain *m_pDomain;
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
    virtual void ClearSelections();
protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);
	void UpdateWinStations(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayUsers();			
	virtual void Reset(void *);
	BOOL AddServerToList(CServer *pServer);
	int AddUserToList(CWinStation *pWinStation);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainUsersPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CDomainUsersPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CDomainUsersPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnUserItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusUserList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusUserList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CDomainUsersPage


//////////////////////////
// CLASS: CDomainWinStationsPage
//
class CDomainWinStationsPage : public CAdminPage
{
friend class CDomainView;

protected:
	CDomainWinStationsPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CDomainWinStationsPage)

// Form Data
public:
	//{{AFX_DATA(CDomainWinStationsPage)
	enum { IDD = IDD_ALL_SERVER_WINSTATIONS };
	CListCtrl	m_StationList;
	//}}AFX_DATA

// Attributes
public:
    
protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxBlank;			// index of Blank image
	int m_idxCitrix;		// index of Citrix image
	int m_idxServer;		// index of Server image 
	int m_idxConsole;		// index of Console image
	int m_idxNet;			// index of Net image
	int m_idxAsync;			// index of Async image
	int m_idxCurrentConsole;// index of Current Console image
	int m_idxCurrentNet;	// index of Current Net image
	int m_idxCurrentAsync;	// index of Current Async image
	int m_idxDirectAsync;	// index of Direct Async image
	int m_idxCurrentDirectAsync; // index of Current Direct Async image

private:
    CDomain *m_pDomain;
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
    virtual void ClearSelections();
protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);
	void UpdateWinStations(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayStations();			
    virtual void Reset(void *);
	BOOL AddServerToList(CServer *pServer);
	int AddWinStationToList(CWinStation *pWinStation);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainWinStationsPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CDomainWinStationsPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CDomainWinStationsPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnWinStationItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CDomainWinStationsPage


////////////////////////////
// CLASS: CDomainProcessesPage
//
class CDomainProcessesPage : public CAdminPage
{
friend class CDomainView;

protected:
	CDomainProcessesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CDomainProcessesPage)

// Form Data
public:
	//{{AFX_DATA(CDomainProcessesPage)
	enum { IDD = IDD_ALL_SERVER_PROCESSES };
	CListCtrl	m_ProcessList;
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

private:
    CDomain *m_pDomain;
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:

protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);
	void UpdateProcesses(CServer *pServer);
	void RemoveProcess(CProcess *pProcess);

private:
	virtual void Reset(void *);
	void DisplayProcesses();			
	BOOL AddServerToList(CServer *pServer);
	int AddProcessToList(CProcess *pProcess);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainProcessesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CDomainProcessesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CDomainProcessesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CDomainProcessesPage


//////////////////////////
// CLASS: CDomainLicensesPage
//
class CDomainLicensesPage : public CAdminPage
{
friend class CDomainView;

protected:
	CDomainLicensesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CDomainLicensesPage)

// Form Data
public:
	//{{AFX_DATA(CDomainLicencesPage)
	enum { IDD = IDD_DOMAIN_LICENSES };
	CListCtrl	m_LicenseList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxBase;		// index of Base image
	int m_idxBump;		// index of Bump image
	int m_idxEnabler;	// index of Enabler image 
	int m_idxUnknown;	// index of Unknown image

private:
    CDomain *m_pDomain;
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;

// Operations
public:

protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayLicenses();			
	virtual void Reset(void*);
	BOOL AddServerToList(CServer *pServer);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainLicensesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CDomainLicensesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CDomainLicensesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CDomainLicensesPage


#endif  // _DOMAINPAGES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\led.cpp ===
/*******************************************************************************
*
* led.cpp
*
* implementation of CLed class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\LED.CPP  $
*  
*     Rev 1.0   30 Jul 1997 17:11:36   butchd
*  Initial revision.
*  
*******************************************************************************/

/*
 * include files
 */
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include "led.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// CLed class construction / destruction, implementation

/*******************************************************************************
 *
 *  CLed - CLed constructor
 *
 *  ENTRY:
 *      hBrush (input)
 *          Brush to paint window with.
 *  EXIT:
 *      (Refer to MFC CStatic::CStatic documentation)
 *
 ******************************************************************************/

CLed::CLed( HBRUSH hBrush ) 
    : CStatic(),
      m_hBrush(hBrush)
{
	//{{AFX_DATA_INIT(CLed)
	//}}AFX_DATA_INIT

}  // end CLed::CLed


////////////////////////////////////////////////////////////////////////////////
//  CLed operations

/*******************************************************************************
 *
 *  Subclass - CLed member function: public operation
 *
 *      Subclass the specified object to our special blip object.
 *
 *  ENTRY:
 *      pStatic (input)
 *          Points to CStatic object to subclass.
 *  EXIT:
 *
 ******************************************************************************/

void
CLed::Subclass( CStatic *pStatic )
{
    SubclassWindow(pStatic->m_hWnd);

}  // end CLed::Subclass


/*******************************************************************************
 *
 *  Update - CLed member function: public operation
 *
 *      Update the LED to 'on' or 'off' state.
 *
 *  ENTRY:
 *      nOn (input)
 *          nonzero to set 'on' state; zero for 'off' state.
 *  EXIT:
 *
 ******************************************************************************/

void
CLed::Update( int nOn )
{
    m_bOn = nOn ? TRUE : FALSE;
    InvalidateRect(NULL);
    UpdateWindow();

}  // end CLed::Update


/*******************************************************************************
 *
 *  Toggle - CLed member function: public operation
 *
 *      Toggle the LED's on/off state.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CLed::Toggle()
{
    m_bOn = !m_bOn;
    InvalidateRect(NULL);
    UpdateWindow();

}  // end CLed::Toggle


////////////////////////////////////////////////////////////////////////////////
// CLed message map

BEGIN_MESSAGE_MAP(CLed, CStatic)
	//{{AFX_MSG_MAP(CLed)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////////////////
//  CLed commands


/*******************************************************************************
 *
 *  OnPaint - CLed member function: public operation
 *
 *      Paint the led with its brush for 'on' state.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CWnd::OnPaint documentation)
 *
 ******************************************************************************/

void
CLed::OnPaint() 
{
    RECT rect;
    CPaintDC dc(this);
    CBrush brush;

    GetClientRect(&rect);

#ifdef USING_3DCONTROLS
    (rect.right)--;
    (rect.bottom)--;
    dc.FrameRect( &rect, brush.FromHandle((HBRUSH)GetStockObject(GRAY_BRUSH)) );

    (rect.top)++;
    (rect.left)++;
    (rect.right)++;
    (rect.bottom)++;
    dc.FrameRect( &rect, brush.FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)) );

    (rect.top)++;
    (rect.left)++;
    (rect.right) -= 2;
    (rect.bottom) -= 2;
#else
    dc.FrameRect( &rect, brush.FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)) );
    (rect.top)++;
    (rect.left)++;
    (rect.right)--;
    (rect.bottom)--;
#endif
    dc.FillRect( &rect,
                 brush.FromHandle(
                    m_bOn ?
                        m_hBrush :
                        (HBRUSH)GetStockObject(LTGRAY_BRUSH)) );

}  // end CLed::OnPaint
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\listenvw.h ===
/*******************************************************************************
*
* listenvw.h
*
* declarations for the CListenerView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\LISTENVW.H  $
*  
*     Rev 1.0   30 Jul 1997 17:11:46   butchd
*  Initial revision.
*
*******************************************************************************/

/////////////////////////////////////////////////////////////////////////////
// CListenerView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CListenerView : public CFormView
{
friend class CRightPane;

protected:
	CListenerView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CListenerView)

// Form Data
public:
	//{{AFX_DATA(CListenerView)
	enum { IDD = IDD_LISTENER };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListenerView)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CListenerView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CListenerView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\procs.h ===
/*******************************************************************************
*
* procs.h
*
* declaration of ProcEnumerateProcesses
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\PROCS.H  $
*
*     Rev 1.0   30 Jul 1997 17:12:06   butchd
*  Initial revision.
*
*******************************************************************************/

#ifndef _PROCS_H
#define _PROCS_H

#include <allproc.h>

typedef struct _ENUMTOKEN
{
    ULONG       Current;
    ULONG       NumberOfProcesses;
    union
    {
        PTS_ALL_PROCESSES_INFO  ProcessArray;
        PBYTE                   pProcessBuffer;
    };
    BOOLEAN     bGAP;
}
ENUMTOKEN, *PENUMTOKEN;

BOOL WINAPI ProcEnumerateProcesses( HANDLE hServer,
                                    PENUMTOKEN pEnumToken,
                                    LPTSTR pImageName,
                                    PULONG pLogonId,
                                    PULONG pPID,
                                    PSID *ppSID );

#define MAX_PROCESSNAME 18

#endif // _PROCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\msgview.h ===
/*******************************************************************************
*
* msgvw.h
*
* - header for the CMessageView class
* - implementation can be found in msgvw.cpp
*
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\winadmin\VCS\msgview.h  $
*  
*     Rev 1.1   15 Oct 1997 21:47:26   donm
*  update
*******************************************************************************/

//////////////////////
// FILE: 
//
//
#ifndef _MSGVIEW_H
#define _MSGVIEW_H

#include "Resource.h"
#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "winadmin.h"

class CMessagePage;

//////////////////////
// CLASS: CMessageView
//
// View that display a message centered in it
// This replaces CBusyServerView, CBadServerView, CBadWinStationView, and CListenerView
//
class CMessageView : public CAdminView
{
friend class CRightPane;

protected:
	CMessageView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CMessageView)

// Attributes
protected:

private:
   WORD m_wMessageID;
//   CString m_MessageString;
//   CFont m_MessageFont;
   CMessagePage *m_pMessagePage;

// Operations
protected:
	void Reset(void *message);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMessageView)
	// Overrides
public:
	virtual void OnInitialUpdate();
protected:
	virtual void OnDraw(CDC* pDC);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CMessageView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CMessageView)
		// NOTE - the ClassWizard will add and remove member functions here.
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CMessageView


//////////////////////////
// CLASS: CMessagePage
//
class CMessagePage : public CAdminPage
{
friend class CMessageView;

protected:
	CMessagePage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CMessagePage)

// Form Data
public:
	//{{AFX_DATA(CApplicationInfoPage)
	enum { IDD = IDD_MESSAGE_PAGE };
	//}}AFX_DATA

// Attributes
public:

protected:

private:

// Operations
public:

private:
	void Reset(void *pMsg);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMessagePage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CMessagePage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    
	// Generated message map functions
	//{{AFX_MSG(CMessagePage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CMessagePage

#endif  // _MSGVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\ltpane.cpp ===
/*******************************************************************************
*
* ltpane.cpp
*
* implementation of the CLeftPane class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\ltpane.cpp  $
*  
*     Rev 1.4   19 Feb 1998 17:40:48   donm
*  removed latest extension DLL support
*  
*     Rev 1.2   19 Jan 1998 16:47:48   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.1   03 Nov 1997 15:24:40   donm
*  added Domains
*  
*     Rev 1.0   13 Oct 1997 22:33:18   donm
*  Initial revision.
*  
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "ltpane.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


////////////////////////////
// MESSAGE MAP: CLeftPane
//
IMPLEMENT_DYNCREATE(CLeftPane, CView)

BEGIN_MESSAGE_MAP(CLeftPane, CView)
	//{{AFX_MSG_MAP(CLeftPane)
	ON_MESSAGE(WM_ADMIN_EXPANDALL, OnExpandAll)
	ON_MESSAGE(WM_ADMIN_COLLAPSEALL, OnCollapseAll)
	ON_MESSAGE(WM_ADMIN_COLLAPSETOSERVERS, OnCollapseToServers)
    ON_MESSAGE(WM_ADMIN_COLLAPSETODOMAINS, OnCollapseToDomains)
	ON_MESSAGE(WM_ADMIN_ADD_SERVER, OnAdminAddServer)
	ON_MESSAGE(WM_ADMIN_REMOVE_SERVER, OnAdminRemoveServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER, OnAdminUpdateServer)
	ON_MESSAGE(WM_ADMIN_ADD_WINSTATION, OnAdminAddWinStation)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATION, OnAdminUpdateWinStation)
	ON_MESSAGE(WM_ADMIN_REMOVE_WINSTATION, OnAdminRemoveWinStation)
	ON_MESSAGE(WM_ADMIN_UPDATE_DOMAIN, OnAdminUpdateDomain)
    ON_MESSAGE(WM_ADMIN_ADD_DOMAIN, OnAdminAddDomain)
	ON_MESSAGE(WM_EXT_ADD_APPLICATION, OnExtAddApplication)
	ON_MESSAGE(WM_EXT_ADD_APP_SERVER, OnExtAddAppServer)
	ON_MESSAGE(WM_EXT_REMOVE_APP_SERVER, OnExtRemoveAppServer)
	ON_MESSAGE(WM_ADMIN_VIEWS_READY, OnAdminViewsReady)
	ON_NOTIFY(TCN_SELCHANGE, IDC_TREE_TABS, OnTabSelChange)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////
// F'N: CLeftPane cto
//
// - the view pointers are initially set to NULL
//
CLeftPane::CLeftPane()
{
	m_pTabs       = NULL;
	m_pTabFont    = NULL;

	m_pServerTreeView = NULL;
	m_pAppTreeView = NULL;

	m_CurrTreeViewType = TREEVIEW_SERVERS;
	m_CurrTreeView = (CView*)m_pServerTreeView;
}  // end CLeftPane ctor


////////////////////////////
// CLeftPane::OnDraw
//
void CLeftPane::OnDraw(CDC* pDC)
{

}  // end CLeftPane::OnDraw


/////////////////////////
// CLeftPane dtor
//
CLeftPane::~CLeftPane()
{
	if(m_pTabs)    delete m_pTabs;
	if(m_pTabFont) delete m_pTabFont;

}  // end CLeftPane dtor


#ifdef _DEBUG
/////////////////////////////////
// CLeftPane::AssertValid
//
void CLeftPane::AssertValid() const
{
	CView::AssertValid();

}  // end CLeftPane::AssertValid


//////////////////////////
// CLeftPane::Dump
//
void CLeftPane::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CLeftPane::Dump

#endif //_DEBUG


/////////////////////////////////////
// CLeftPane::OnInitialUpdate
//
// - each of the tree view objects is created
// - the CTreeView object is initially the 'active' view in the left pane
//
void CLeftPane::OnInitialUpdate() 
{
	CView::OnInitialUpdate();
	
	CFrameWnd* pMainWnd = (CFrameWnd*)AfxGetMainWnd();
	CWinAdminDoc* pDoc = (CWinAdminDoc*)pMainWnd->GetActiveDocument();

	// create the Tabs
	m_pTabs = new CTreeTabCtrl;
    if(!m_pTabs) return;
	m_pTabs->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP | TCS_BOTTOM | TCS_FORCEICONLEFT  |TCS_FOCUSNEVER, CRect(0,0,0,0), this, IDC_TREE_TABS);

	m_pTabFont = new CFont;
    if(m_pTabFont) {
	    m_pTabFont->CreateStockObject(DEFAULT_GUI_FONT);
	    m_pTabs->SetFont(m_pTabFont, TRUE);
    }

	BuildImageList();

	TCHAR szTemp[40];
	CString tabString;

	tabString.LoadString(IDS_TAB_SERVERS);
	wcscpy(szTemp,tabString);

	TC_ITEM tc;
	tc.mask = TCIF_TEXT | TCIF_IMAGE;
	tc.pszText = szTemp;
	tc.iImage = m_idxServer;
	m_pTabs->InsertItem(0, &tc);

	tabString.LoadString(IDS_PUBLISHED_APPS);    // should create a string for this tab (with spaces_
	wcscpy(szTemp,tabString);
	tc.pszText = szTemp;
	tc.iImage = m_idxApps;
	m_pTabs->InsertItem(1, &tc);

	m_pTabs->SetCurSel(0);	// set the 'Servers' tab as the current one

	m_pServerTreeView = new CAdminTreeView();
	if(m_pServerTreeView) m_pServerTreeView->Create(NULL, NULL, WS_CHILD | WS_VISIBLE | WS_BORDER, CRect(0, 0, 0, 0), m_pTabs, 0);

	m_pAppTreeView = new CAppTreeView();
	if(m_pAppTreeView) m_pAppTreeView->Create(NULL, NULL, WS_CHILD | WS_BORDER, CRect(0, 0, 0, 0), m_pTabs, 1);

	m_CurrTreeViewType = TREEVIEW_SERVERS;
	m_CurrTreeView = m_pServerTreeView;

	pDoc->AddView(m_pServerTreeView);
	pDoc->AddView(m_pAppTreeView);
	pDoc->UpdateAllViews(NULL);

}  // end CLeftPane::OnInitialUpdate


/////////////////////////////////////
// CLeftPane::BuildImageList
//
// - calls m_imageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the CTabCtrl
//
void CLeftPane::BuildImageList()
{
	m_ImageList.Create(16, 16, TRUE, 2, 0);

	m_idxServer = AddIconToImageList(IDI_SERVER);
	m_idxApps = AddIconToImageList(IDI_APPS);

	m_pTabs->SetImageList(&m_ImageList);

}  // end CLeftPane::BuildImageList


/////////////////////////////////////////
// CLeftPane::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CLeftPane::AddIconToImageList(int iconID)
{
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
	return m_ImageList.Add(hIcon);

}  // end CLeftPane::AddIconToImageList


/////////////////////////////////////////
// CLeftPane::OnTabSelChange
//
void CLeftPane::OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// find out which tab is now selected
	int index = m_pTabs->GetCurSel();
	DWORD_PTR node;
	
	// switch to the appropriate tree
	switch(index)  {
		case 0:
			// bring 'Servers' to the top
			m_pServerTreeView->ModifyStyle(WS_DISABLED, WS_VISIBLE);

			// hide the others
			m_pAppTreeView->ModifyStyle(WS_VISIBLE, WS_DISABLED);

			m_CurrTreeViewType = TREEVIEW_SERVERS;
			m_CurrTreeView = m_pServerTreeView;

			m_pServerTreeView->Invalidate();
			m_pServerTreeView->SetFocus();
			node = m_pServerTreeView->GetCurrentNode();

			break;

		case 1:
			// bring 'Published Applications' to the top
			m_pAppTreeView->ModifyStyle(WS_DISABLED, WS_VISIBLE);

			// hide the others
			m_pServerTreeView->ModifyStyle(WS_VISIBLE, WS_DISABLED);

			m_CurrTreeViewType = TREEVIEW_APPS;
			m_CurrTreeView = m_pAppTreeView;
			
			m_pAppTreeView->Invalidate();
			m_pAppTreeView->SetFocus();			
			node = m_pAppTreeView->GetCurrentNode();

			break;
   }


	// Tell the document that the current item in the tree has changed
	((CWinAdminDoc*)GetDocument())->SetCurrentView(VIEW_CHANGING);
	((CWinAdminDoc*)GetDocument())->SetTreeCurrent(((CTreeNode*)node)->GetTreeObject(), ((CTreeNode*)node)->GetNodeType());

	CFrameWnd* pMainWnd = (CFrameWnd*)AfxGetMainWnd();
	// FALSE signifies that this was not caused by a mouse click on a tree item
	pMainWnd->PostMessage(WM_ADMIN_CHANGEVIEW, FALSE, node);
	*pResult = 0;

}  // end CLeftPane::OnTabSelChange


////////////////////////////
// CLeftPane::OnSize
//
// - currently all views are sized to fit the view, whether they are 'active'
//   or not... this may change to sizing only the view that is 'active' if
//   it significantly impacts performance
//
void CLeftPane::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);
   
	if(m_pTabs)
		if(m_pTabs->GetSafeHwnd())
			m_pTabs->MoveWindow(&rect, TRUE);

	CView::OnSize(nType, cx, cy);

}  // end CLeftPane::OnSize


LRESULT CLeftPane::OnExpandAll(WPARAM wParam, LPARAM lParam)
{
	// Send to the currently visible tree
	m_CurrTreeView->SendMessage(WM_ADMIN_EXPANDALL, wParam, lParam);
	return 0;
}
}	// end CLeftPane::OnExpandAll


////////////////////////////
// CLeftPane::OnCollapseAll
//
LRESULT CLeftPane::OnCollapseAll(WPARAM wParam, LPARAM lParam)
{
	// Send to the currently visible tree
	m_CurrTreeView->SendMessage(WM_ADMIN_COLLAPSEALL, wParam, lParam);
	return 0;

}	// end CLeftPane::OnCollapseAll


////////////////////////////
// CLeftPane::OnCollapseToServers
//
LRESULT CLeftPane::OnCollapseToServers(WPARAM wParam, LPARAM lParam)
{
	// Send to the currently visible tree
	m_CurrTreeView->SendMessage(WM_ADMIN_COLLAPSETOSERVERS, wParam, lParam);
	return 0;

}	// end CLeftPane::OnCollapseToServers


////////////////////////////
// CLeftPane::OnCollapseToDomains
//
LRESULT CLeftPane::OnCollapseToDomains(WPARAM wParam, LPARAM lParam)
{
   m_pServerTreeView->SendMessage(WM_ADMIN_COLLAPSETODOMAINS, wParam, lParam);
   return 0;

}	// end CLeftPane::OnCollapseToDomains


////////////////////////////
// CLeftPane::OnCollapseToApplications
//
LRESULT CLeftPane::OnCollapseToApplications(WPARAM wParam, LPARAM lParam)
{
   if(m_pAppTreeView)
		m_pAppTreeView->SendMessage(WM_ADMIN_COLLAPSETODOMAINS, wParam, lParam);

   return 0;

}	// end CLeftPane::OnCollapseToApplications


LRESULT CLeftPane::OnAdminAddServer(WPARAM wParam, LPARAM lParam)
{
	m_pServerTreeView->SendMessage(WM_ADMIN_ADD_SERVER, wParam, lParam);
	return 0;
}


LRESULT CLeftPane::OnAdminRemoveServer(WPARAM wParam, LPARAM lParam)
{
	m_pServerTreeView->SendMessage(WM_ADMIN_REMOVE_SERVER, wParam, lParam);
	return 0;
}


LRESULT CLeftPane::OnAdminUpdateServer(WPARAM wParam, LPARAM lParam)
{
	m_pServerTreeView->SendMessage(WM_ADMIN_UPDATE_SERVER, wParam, lParam);
	return 0;
}


////////////////////////////
// CLeftPane::OnAdminAddWinStation
//
LRESULT CLeftPane::OnAdminAddWinStation(WPARAM wParam, LPARAM lParam)
{
	m_pServerTreeView->SendMessage(WM_ADMIN_ADD_WINSTATION, wParam, lParam);
	return 0;

}	// end CLeftPane::OnAdminAddWinStation


////////////////////////////
// CLeftPane::OnAdminUpdateWinStation
//
LRESULT CLeftPane::OnAdminUpdateWinStation(WPARAM wParam, LPARAM lParam)
{
	m_pServerTreeView->SendMessage(WM_ADMIN_UPDATE_WINSTATION, wParam, lParam);
	return 0;

}	// end CLeftPane::OnAdminUpdateWinStation


////////////////////////////
// CLeftPane::OnAdminRemoveWinStation
//
LRESULT CLeftPane::OnAdminRemoveWinStation(WPARAM wParam, LPARAM lParam)
{
	m_pServerTreeView->SendMessage(WM_ADMIN_REMOVE_WINSTATION, wParam, lParam);
	return 0;

}	// end CLeftPane::OnAdminRemoveWinStation


////////////////////////////
// CLeftPane::OnAdminUpdateDomain
//
LRESULT CLeftPane::OnAdminUpdateDomain(WPARAM wParam, LPARAM lParam)
{
	m_pServerTreeView->SendMessage(WM_ADMIN_UPDATE_DOMAIN, wParam, lParam);

	return 0;

}	// end CLeftPane::OnAdminUpdateDomain

////////////////////////////
// CLeftPane::OnAdminAddDomain
//
LRESULT CLeftPane::OnAdminAddDomain(WPARAM wParam, LPARAM lParam)
{
    ASSERT(lParam);

    return m_pServerTreeView->SendMessage(WM_ADMIN_ADD_DOMAIN, wParam, lParam);

}	// end CLeftPane::OnAdminAddDomain


LRESULT CLeftPane::OnExtAddApplication(WPARAM wParam, LPARAM lParam)
{
	m_pAppTreeView->SendMessage(WM_EXT_ADD_APPLICATION, wParam, lParam);
	return 0;
}


LRESULT CLeftPane::OnExtAddAppServer(WPARAM wParam, LPARAM lParam)
{
	m_pAppTreeView->SendMessage(WM_EXT_ADD_APP_SERVER, wParam, lParam);
	return 0;
}


CTreeTabCtrl::CTreeTabCtrl()
{

}


CTreeTabCtrl::~CTreeTabCtrl()
{

}

BEGIN_MESSAGE_MAP(CTreeTabCtrl, CTabCtrl)
	//{{AFX_MSG_MAP(CTreeTabCtrl)
	ON_WM_SIZE()
//	ON_NOTIFY_REFLECT(TCN_SELCHANGE, OnSelchange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CTreeTabCtrl::Initialize()
{

}


void CTreeTabCtrl::OnSize(UINT nType, int cx, int cy) 
{
  	CTabCtrl::OnSize(nType, cx, cy);
	CRect rcTabCtrl(0,0,cx,cy);

	AdjustRect(FALSE,&rcTabCtrl);

	CWnd* pWnd = GetDlgItem(0);
	if(pWnd) {
		pWnd->MoveWindow(&rcTabCtrl);
	}

	pWnd = GetDlgItem(1);
	if(pWnd) {
		pWnd->MoveWindow(&rcTabCtrl);
	}
}

#ifdef _DEBUG

void CTreeTabCtrl::AssertValid() const
{


}

void CTreeTabCtrl::Dump(CDumpContext& dc) const
{

}

#endif


void CTreeTabCtrl::OnDraw(CDC* pDC)
{


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\msgview.cpp ===
/*******************************************************************************
*
* msgview.cpp
*
* implementation of the CMessageView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\winadmin\VCS\msgview.cpp  $
*  
*     Rev 1.2   03 Nov 1997 15:27:18   donm
*  update
*  
*     Rev 1.1   15 Oct 1997 21:47:22   donm
*  update
*  
*******************************************************************************/

#include "stdafx.h"
#include "resource.h"
#include "msgview.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////
// MESSAGE MAP: CMessageView
//
IMPLEMENT_DYNCREATE(CMessageView, CView)

BEGIN_MESSAGE_MAP(CMessageView, CView)
	//{{AFX_MSG_MAP(CMessageView)
	ON_WM_SIZE()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


///////////////////////
// F'N: CMessageView ctor
//
CMessageView::CMessageView()
{
	m_pMessagePage = NULL;
	
}  // end CMessageView ctor


///////////////////////
// F'N: CMessageView dtor
//
CMessageView::~CMessageView()
{

}  // end CMessageView dtor


#ifdef _DEBUG
///////////////////////////////
// F'N: CMessageView::AssertValid
//
void CMessageView::AssertValid() const
{
	CView::AssertValid();

}  // end CMessageView::AssertValid


////////////////////////
// F'N: CMessageView::Dump
//
void CMessageView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CMessageView::Dump

#endif //_DEBUG


////////////////////////////
// F'N: CMessageView::OnCreate
//
int CMessageView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;

}  // end CMessageView::OnCreate


///////////////////////////////////
// F'N: CMessageView::OnInitialUpdate
//
//
void CMessageView::OnInitialUpdate() 
{
	m_pMessagePage = new CMessagePage;
    if(!m_pMessagePage) return;

	m_pMessagePage->Create(NULL, NULL, WS_CHILD | WS_VISIBLE, CRect(0, 0, 0, 0), this, 0, NULL);
	GetDocument()->AddView(m_pMessagePage);		

}  // end CMessageView::OnInitialUpdate


//////////////////////////
// F'N: CMessageView::OnSize
//
// - size the pages to fill the entire view
//
void CMessageView::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	if(m_pMessagePage && m_pMessagePage->GetSafeHwnd())
	  m_pMessagePage->MoveWindow(&rect, TRUE);

}  // end CMessageView::OnSize


//////////////////////////
// F'N: CMessageView::OnDraw
//
//
void CMessageView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here

}  // end CMessageView::OnDraw


/////////////////////////
// F'N: CMessageView::Reset
//
//
void CMessageView::Reset(void *p)
{
	if(m_pMessagePage) m_pMessagePage->Reset(p);

//	((CWinAdminDoc*)GetDocument())->SetCurrentPage(m_CurrPage);

}  // end CMessageView::Reset


////////////////////////////////
// MESSAGE MAP: CMessagePage
//
IMPLEMENT_DYNCREATE(CMessagePage, CFormView)

BEGIN_MESSAGE_MAP(CMessagePage, CFormView)
	//{{AFX_MSG_MAP(CMessagePage)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CMessagePage ctor
//
CMessagePage::CMessagePage()
	: CAdminPage(CMessagePage::IDD)
{
	//{{AFX_DATA_INIT(CMessagePage)
	//}}AFX_DATA_INIT

}  // end CMessagePage ctor


/////////////////////////////
// F'N: CMessagePage dtor
//
CMessagePage::~CMessagePage()
{
}  // end CMessagePage dtor


////////////////////////////////////////
// F'N: CMessagePage::DoDataExchange
//
void CMessagePage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMessagePage)
	
	//}}AFX_DATA_MAP

}  // end CMessagePage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CMessagePage::AssertValid
//
void CMessagePage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CMessagePage::AssertValid


//////////////////////////////
// F'N: CMessagePage::Dump
//
void CMessagePage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CMessagePage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CMessagePage::OnInitialUpdate
//
void CMessagePage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

}  // end CMessagePage::OnInitialUpdate


//////////////////////////////
// F'N: CMessagePage::OnSize
//
void CMessagePage::OnSize(UINT nType, int cx, int cy) 
{
    RECT rect;
	GetClientRect(&rect);

	MoveWindow(&rect, TRUE);

	// CFormView::OnSize(nType, cx, cy);

}  // end CMessagePage::OnSize


//////////////////////////////
// F'N: CMessagePage::Reset
//
void CMessagePage::Reset(void *p)
{
	CString string;
	string.LoadString((WORD)p);
	SetDlgItemText(IDC_MESSAGE, string);
	
}  // end CMessagePage::Reset
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\mainfrm.h ===
/*******************************************************************************
*
* mainfrm.h
*
* interface of the CMainFrame class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
*******************************************************************************/


class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
protected:
	CSplitterWnd m_wndSplitter;

   CWnd *m_pLeftPane;
   CWnd *m_pRightPane;
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void ActivateFrame(int nCmdShow = -1);
	//}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    static void InitWarningThread( PVOID *pvParam );

private:
    void DisconnectHelper(BOOL bTree);
    void SendMessageHelper(BOOL bTree);
    void ResetHelper(BOOL bTree);
    bool LocateServer(LPCTSTR sServerName);
	
protected:  // control bar embedded members
    CStatusBar  m_wndStatusBar;
    CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT OnAdminChangeView(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminAddServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRemoveServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateProcesses(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRemoveProcess(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminAddWinStation(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateWinStation(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRemoveWinStation(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateServerInfo(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRedisplayLicenses(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateWinStations(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateDomain(WPARAM, LPARAM);
    afx_msg LRESULT OnAdminAddDomain(WPARAM, LPARAM);
	afx_msg LRESULT OnExtAddApplication(WPARAM, LPARAM);
	afx_msg LRESULT OnExtAddAppServer(WPARAM, LPARAM);
	afx_msg LRESULT OnExtRemoveAppServer(WPARAM, LPARAM);
	afx_msg LRESULT OnExtAppChanged(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminViewsReady(WPARAM, LPARAM);
    afx_msg LRESULT OnAdminAddServerToFavorites( WPARAM , LPARAM );
    afx_msg LRESULT OnForceTreeViewFocus( WPARAM , LPARAM );
    afx_msg LRESULT OnAdminRemoveServerFromFavs( WPARAM , LPARAM );
    afx_msg LRESULT OnAdminGetTVStates( WPARAM wp , LPARAM lp );
    afx_msg LRESULT OnAdminUpdateTVStates( WPARAM , LPARAM );


	//afx_msg LRESULT OnHelp(WPARAM, LPARAM);
	afx_msg void OnExpandAll();
	afx_msg void OnRefresh();
	afx_msg void OnConnect();
	afx_msg void OnTreeConnect();
	afx_msg void OnDisconnect();
	afx_msg void OnTreeDisconnect();
	afx_msg void OnSendMessage();
	afx_msg void OnTreeSendMessage();
	afx_msg void OnShadow();
	afx_msg void OnTreeShadow();
	afx_msg void OnReset();
	afx_msg void OnTreeReset();
	afx_msg void OnStatus();
	afx_msg void OnTreeStatus();
	afx_msg void OnLogoff();
	afx_msg void OnTerminate();
	afx_msg void OnPreferences();
	afx_msg void OnCollapseAll();
	afx_msg void OnCollapseToServers();
    afx_msg void OnCollapseToDomains();
    afx_msg void OnServerConnect();
    afx_msg void OnServerDisconnect();
	afx_msg void OnTreeDomainConnectAllServers();
	afx_msg void OnTreeDomainDisconnectAllServers();
	afx_msg void OnTreeDomainFindServers();
	afx_msg void OnDomainConnectAllServers();
	afx_msg void OnDomainDisconnectAllServers();
	afx_msg void OnAllServersConnect();
	afx_msg void OnAllServersDisconnect();
	afx_msg void OnAllServersFind();
	afx_msg void OnUpdateConnect(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDisconnect(CCmdUI* pCmdUI);
	afx_msg void OnUpdateLogoff(CCmdUI* pCmdUI);
	afx_msg void OnUpdateMessage(CCmdUI* pCmdUI);
	afx_msg void OnUpdateReset(CCmdUI* pCmdUI);
	afx_msg void OnUpdateShadow(CCmdUI* pCmdUI);
	afx_msg void OnUpdateStatus(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTerminate(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTreeConnect(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTreeDisconnect(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTreeMessage(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTreeReset(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTreeShadow(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTreeStatus(CCmdUI* pCmdUI);
	afx_msg void OnShowSystemProcesses();
	afx_msg void OnUpdateShowSystemProcesses(CCmdUI* pCmdUI);
    afx_msg void OnUpdateServerAddToFavorite( CCmdUI * );
    afx_msg void OnUpdateServerRemoveFromFavorite( CCmdUI * );
    
	afx_msg void OnClose();
	afx_msg void OnHtmlHelp();
	afx_msg void OnUpdateRefresh(CCmdUI* pCmdUI);
    afx_msg void OnUpdateServerConnect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateServerDisconnect(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDomainPopupMenu(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDomainPopupFind(CCmdUI* pCmdUI);	
	afx_msg void OnUpdateDomainMenu(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEmptyFavs( CCmdUI* pCmdUI );
    afx_msg void OnAddToFavorites();
    afx_msg void OnTab( );
    afx_msg void OnShiftTab();
    afx_msg void OnCtrlTab( );
    afx_msg void OnCtrlShiftTab( );
    afx_msg void OnNextPane( );
    afx_msg void OnRemoveFromFavs( );
    afx_msg void OnFindServer( );
    afx_msg void OnDelFavNode( );
    afx_msg void OnEmptyFavorites( );

    #ifdef _STRESS_BUILD
    afx_msg void OnAddAllServersToFavorites( );
    afx_msg void OnRunStress( );
    afx_msg void OnRunStressLite( );
    #endif
    
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\procs.cpp ===
/*******************************************************************************
*
* procs.cpp
*
* implementation of ProcEnumerateProcesses function
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   BillG  $  Don Messerli
*
* $Log:   X:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\PROCS.CPP  $
*
*     Rev 1.1   02 Dec 1997 16:30:10   BillG
*  alpha update
*
*     Rev 1.0   30 Jul 1997 17:12:02   butchd
*  Initial revision.
*
*******************************************************************************/


#ifndef UNICODE
#define UNICODE
#endif
//#ifndef _X86_
//#define _X86_
//#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrsrv.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <windows.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmwksta.h>
#include <lmapibuf.h>
#include <winsta.h>

#include <procs.h>


#define MAX_PROCESSNAME 18


VOID
FetchProcessIDAndImageName(PTS_SYS_PROCESS_INFORMATION ProcessInfo,
                           PULONG pPID,
                           LPTSTR pImageName)
{
    int i;
    TCHAR ImageName[MAX_PROCESSNAME+1];
    //
    // Set the PID.
    //
    *pPID = (ULONG)(ULONG_PTR)(ProcessInfo->UniqueProcessId);


    //
    //  Fetch and convert counted UNICODE string into a NULL
    //  terminated UNICODE string.
    //
    if( !ProcessInfo->ImageName.Length == 0 )
    {
        wcsncpy( ImageName,
                 ProcessInfo->ImageName.Buffer,
                 min(MAX_PROCESSNAME, ProcessInfo->ImageName.Length/2));
    }

    ImageName[min(MAX_PROCESSNAME, ProcessInfo->ImageName.Length/2)] = 0;


    /*
     * We're UNICODE: simply copy the converted ImageName buffer
     * into the m_PLObject->m_ImageName field.
     */
    lstrcpy(pImageName, ImageName);

    _wcslwr(pImageName);

}

/*******************************************************************************
 *
 *  EnumerateProcesses - WinFrame helper function
 *
 *  Enumerate all processes in system, passing back one with each call to this
 *  routine.
 *
 *
 * ENTRY:
 *    hServer:
 *      handle of the aimed server
 *    pEnumToken
 *      pointer to the current token
 *    pImageName (output)
 *       Points to a buffer to store process name in.  NOTE: this buffer is expected
 *       to be at least MAX_PROCESSNAME+1 characters in size.
 *    pLogonId (output)
 *       Points to variable to store process LogonId in.
 *    pPID (output)
 *       Points to variable to store process PID in.
 *    ppSID (output)
 *       Points to a pointer which is set to point to the process' SID on exit.
 *
 * EXIT:
 *    TRUE - information for the next process in the system has been placed into
 *          the referenced PLObject and pSID variables.
 *    FALSE - if the enumeration is done, GetLastError() will contain the
 *              ERROR_NO_MORE_ITEMS error code.  If another (true error) is
 *              encountered, that code will be set.
 *
 ******************************************************************************/


BOOL WINAPI
ProcEnumerateProcesses( HANDLE hServer,
                        PENUMTOKEN pEnumToken,
                        LPTSTR pImageName,
                        PULONG pLogonId,
                        PULONG pPID,
                        PSID *ppSID )
{
    int i;
    PTS_SYS_PROCESS_INFORMATION ProcessInfo;
    PCITRIX_PROCESS_INFORMATION CitrixInfo;

    if ((pEnumToken == NULL)
        || (pImageName == NULL)
        || (pLogonId == NULL)
        || (pPID == NULL)
        || (ppSID == NULL)
        )
    {
        return FALSE;
    }

    /*
     * Check for done with enumeration.
     */
    if ( pEnumToken->Current == (ULONG)-1 ) {

        SetLastError(ERROR_NO_MORE_ITEMS);

        if (pEnumToken->bGAP == TRUE)    // we used the GAP (GetAllProcesses) interface
        {
            //
            // Free ProcessArray and all child pointers allocated by the client stub.
            //
            WinStationFreeGAPMemory(GAP_LEVEL_BASIC,
                                    pEnumToken->ProcessArray,
                                    pEnumToken->NumberOfProcesses);
            pEnumToken->ProcessArray = NULL;
            pEnumToken->NumberOfProcesses = 0;

            return(FALSE);
        }
        else    // we used the old Hydra 4 interface
        {
            WinStationFreeMemory(pEnumToken->pProcessBuffer);
            pEnumToken->pProcessBuffer = NULL;
            return(FALSE);
        }
    }

    /*
     * Check for beginning enumeration.
     */
    if ( pEnumToken->Current == 0 ) {

        //
        // Try the new interface first (NT5 server ?)
        //
        if (WinStationGetAllProcesses( hServer,
                                       GAP_LEVEL_BASIC,
                                       &(pEnumToken->NumberOfProcesses),
                                       (PVOID *)&(pEnumToken->ProcessArray) ) )
        {
            pEnumToken->bGAP = TRUE;
        }
        else
        {
            //
            //   Check the return code indicating that the interface is not available.
            //
            DWORD dwError = GetLastError();
            if (dwError != RPC_S_PROCNUM_OUT_OF_RANGE)
            {
                    pEnumToken->pProcessBuffer = NULL;
                return(FALSE);
            }
            else    // maybe a Hydra 4 server ?
            {

                if ( WinStationEnumerateProcesses( hServer,
                                                   (PVOID *)&(pEnumToken->pProcessBuffer)))
                {
                    pEnumToken->bGAP = FALSE;
                }
                else
                {
                                DWORD error = GetLastError();
                        if(pEnumToken->pProcessBuffer != NULL)
                    {
                        WinStationFreeMemory(pEnumToken->pProcessBuffer);
                            pEnumToken->pProcessBuffer = NULL;
                    }
                    return(FALSE);
                        }
            }
        }
    }

    if (pEnumToken->bGAP == TRUE)
    {
        ProcessInfo = (PTS_SYS_PROCESS_INFORMATION)((pEnumToken->ProcessArray)[pEnumToken->Current].pTsProcessInfo);

        FetchProcessIDAndImageName(ProcessInfo,pPID,pImageName);

        //
        // Set the SessionId
        //
        *pLogonId = ProcessInfo->SessionId;

        //
        //  set the SID
        //
        *ppSID = (pEnumToken->ProcessArray)[pEnumToken->Current].pSid;

        (pEnumToken->Current)++;

        if ( (pEnumToken->Current) >= (pEnumToken->NumberOfProcesses) )
        {
            pEnumToken->Current = (ULONG)-1;    // sets the end of enumeration
        }
    }
    else
    {

        /*
         * Parse and store the next process' information.
         */

        ProcessInfo = (PTS_SYS_PROCESS_INFORMATION)
                            &(((PUCHAR)(pEnumToken->pProcessBuffer))[pEnumToken->Current]);

        FetchProcessIDAndImageName(ProcessInfo,pPID,pImageName);

        /*
         * Point to the CITRIX_INFORMATION which follows the Threads
         */
        CitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                     (((PUCHAR)ProcessInfo) +
                      SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION +
                      (SIZEOF_TS4_SYSTEM_THREAD_INFORMATION * (int)ProcessInfo->NumberOfThreads));

        /*
         * Fetch the LogonId and point to this SID for the primary
         * thread to use (copy).
         */
        if( CitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC ) {

            *pLogonId = CitrixInfo->LogonId;
            *ppSID = CitrixInfo->ProcessSid;

        } else {

            *pLogonId = (ULONG)(-1);
            *ppSID = NULL;
       }

        /*
         * Increment the total offset count for next call.  If this is the
         * last process, set the offset to -1 so that next call will indicate
         * the end of the enumeration.
         */
        if ( ProcessInfo->NextEntryOffset != 0 )
            (pEnumToken->Current) += ProcessInfo->NextEntryOffset;
        else
            pEnumToken->Current = (ULONG)-1;
    }
    return(TRUE);

}  // end EnumerateProcesses
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\mainfrm.cpp ===
/*******************************************************************************
*
* mainfrm.cpp
*
* implementation of the CMainFrame class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
*******************************************************************************/

#include "stdafx.h"
#include "afxpriv.h"
#include "afxcview.h"
#include "winadmin.h"
#include "admindoc.h"
#include "treeview.h"
#include "rtpane.h"
#include "dialogs.h"
#include "htmlhelp.h"
#include "mainfrm.h"
#include <winsock2.h>

#include <dsrole.h>
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef _STRESS_BUILD
DWORD RunStress( PVOID pv );
DWORD RunStressLite( PVOID pv );
BOOL g_fWaitForAllServersToDisconnect = 1;
#endif

INT_PTR CALLBACK FWarnDlg( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp );
/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_MESSAGE(WM_ADMIN_CHANGEVIEW, OnAdminChangeView) 
	ON_MESSAGE(WM_ADMIN_ADD_SERVER, OnAdminAddServer)
	ON_MESSAGE(WM_ADMIN_REMOVE_SERVER, OnAdminRemoveServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER, OnAdminUpdateServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_PROCESSES, OnAdminUpdateProcesses)
	ON_MESSAGE(WM_ADMIN_REMOVE_PROCESS, OnAdminRemoveProcess)
	ON_MESSAGE(WM_ADMIN_ADD_WINSTATION, OnAdminAddWinStation)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATION, OnAdminUpdateWinStation)
	ON_MESSAGE(WM_ADMIN_REMOVE_WINSTATION, OnAdminRemoveWinStation)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER_INFO, OnAdminUpdateServerInfo)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_LICENSES, OnAdminRedisplayLicenses)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATIONS, OnAdminUpdateWinStations)
	ON_MESSAGE(WM_ADMIN_UPDATE_DOMAIN, OnAdminUpdateDomain)
    ON_MESSAGE(WM_ADMIN_ADD_DOMAIN, OnAdminAddDomain)
	ON_MESSAGE(WM_ADMIN_VIEWS_READY, OnAdminViewsReady)
    ON_MESSAGE(WM_FORCE_TREEVIEW_FOCUS , OnForceTreeViewFocus )

    ON_MESSAGE( WM_ADMIN_ADDSERVERTOFAV , OnAdminAddServerToFavorites )
    ON_MESSAGE( WM_ADMIN_REMOVESERVERFROMFAV , OnAdminRemoveServerFromFavs )
    ON_MESSAGE( WM_ADMIN_GET_TV_STATES , OnAdminGetTVStates )
    ON_MESSAGE( WM_ADMIN_UPDATE_TVSTATE , OnAdminUpdateTVStates )

	ON_COMMAND(IDM_EXPAND_ALL, OnExpandAll)
	ON_COMMAND(IDM_REFRESH, OnRefresh)
	ON_COMMAND(IDM_CONNECT, OnConnect)
	ON_COMMAND(IDM_DISCONNECT, OnDisconnect)
	ON_COMMAND(IDM_MESSAGE, OnSendMessage)
	ON_COMMAND(IDM_SHADOW, OnShadow)
	ON_COMMAND(IDM_RESET, OnReset)
	ON_COMMAND(IDM_STATUS, OnStatus)
	ON_COMMAND(IDTM_CONNECT, OnTreeConnect)
	ON_COMMAND(IDTM_DISCONNECT, OnTreeDisconnect)
	ON_COMMAND(IDTM_MESSAGE, OnTreeSendMessage)
	ON_COMMAND(IDTM_SHADOW, OnTreeShadow)
	ON_COMMAND(IDTM_RESET, OnTreeReset)
	ON_COMMAND(IDTM_STATUS, OnTreeStatus)
	ON_COMMAND(IDM_LOGOFF, OnLogoff)
	ON_COMMAND(IDM_TERMINATE, OnTerminate)
	ON_COMMAND(IDM_PREFERENCES, OnPreferences)
	ON_COMMAND(IDM_COLLAPSE_ALL, OnCollapseAll)
	ON_COMMAND(IDM_COLLAPSE_TOSERVERS, OnCollapseToServers)
    ON_COMMAND(IDM_COLLAPSE_TODOMAINS, OnCollapseToDomains)
	ON_COMMAND(IDM_SHOW_SYSTEM_PROCESSES, OnShowSystemProcesses)
    ON_COMMAND(IDM_SERVER_CONNECT, OnServerConnect)
    ON_COMMAND(IDM_SERVER_DISCONNECT, OnServerDisconnect)

    ON_COMMAND( IDTM_DOMAIN_FIND_SERVER , OnFindServer )

    ON_COMMAND(IDM_SERVER_ADDTOFAV , OnAddToFavorites )
    ON_COMMAND(IDM_SERVER_REMOVEFAV , OnRemoveFromFavs )
    ON_COMMAND( IDM_ALLSERVERS_EMPTYFAVORITES , OnEmptyFavorites )


	ON_COMMAND(IDTM_DOMAIN_CONNECT_ALL, OnTreeDomainConnectAllServers)
	ON_COMMAND(IDTM_DOMAIN_DISCONNECT_ALL, OnTreeDomainDisconnectAllServers)
	ON_COMMAND(IDTM_DOMAIN_FIND_SERVERS, OnTreeDomainFindServers)
	ON_COMMAND(IDM_DOMAIN_CONNECT_ALL, OnDomainConnectAllServers)
	ON_COMMAND(IDM_DOMAIN_DISCONNECT_ALL, OnDomainDisconnectAllServers)
	ON_COMMAND(IDM_ALLSERVERS_CONNECT, OnAllServersConnect)
	ON_COMMAND(IDM_ALLSERVERS_DISCONNECT, OnAllServersDisconnect)
	ON_COMMAND(IDM_ALLSERVERS_FIND, OnAllServersFind)
	ON_UPDATE_COMMAND_UI(IDM_CONNECT, OnUpdateConnect)
	ON_UPDATE_COMMAND_UI(IDM_DISCONNECT, OnUpdateDisconnect)
	ON_UPDATE_COMMAND_UI(IDM_LOGOFF, OnUpdateLogoff)
	ON_UPDATE_COMMAND_UI(IDM_MESSAGE, OnUpdateMessage)
	ON_UPDATE_COMMAND_UI(IDM_RESET, OnUpdateReset)
	ON_UPDATE_COMMAND_UI(IDM_SHADOW, OnUpdateShadow)
	ON_UPDATE_COMMAND_UI(IDM_STATUS, OnUpdateStatus)
	ON_UPDATE_COMMAND_UI(IDM_TERMINATE, OnUpdateTerminate)
    ON_UPDATE_COMMAND_UI(IDM_SERVER_CONNECT, OnUpdateServerConnect)
    ON_UPDATE_COMMAND_UI(IDM_SERVER_DISCONNECT, OnUpdateServerDisconnect)

    ON_UPDATE_COMMAND_UI( IDM_SERVER_ADDTOFAV , OnUpdateServerAddToFavorite )
    ON_UPDATE_COMMAND_UI( IDM_SERVER_REMOVEFAV , OnUpdateServerRemoveFromFavorite )

	ON_UPDATE_COMMAND_UI(IDTM_CONNECT, OnUpdateTreeConnect)
	ON_UPDATE_COMMAND_UI(IDTM_DISCONNECT, OnUpdateTreeDisconnect)
	ON_UPDATE_COMMAND_UI(IDTM_MESSAGE, OnUpdateTreeMessage)
	ON_UPDATE_COMMAND_UI(IDTM_RESET, OnUpdateTreeReset)
	ON_UPDATE_COMMAND_UI(IDTM_SHADOW, OnUpdateTreeShadow)
	ON_UPDATE_COMMAND_UI(IDTM_STATUS, OnUpdateTreeStatus)
	ON_UPDATE_COMMAND_UI(IDM_SHOW_SYSTEM_PROCESSES, OnUpdateShowSystemProcesses)
	ON_UPDATE_COMMAND_UI_RANGE(IDM_DOMAIN_CONNECT_ALL, IDM_DOMAIN_DISCONNECT_ALL, OnUpdateDomainMenu)
	ON_UPDATE_COMMAND_UI_RANGE(IDTM_DOMAIN_CONNECT_ALL, IDTM_DOMAIN_DISCONNECT_ALL, OnUpdateDomainPopupMenu)
	ON_UPDATE_COMMAND_UI(IDTM_DOMAIN_FIND_SERVERS, OnUpdateDomainPopupFind)
	ON_UPDATE_COMMAND_UI(IDM_REFRESH, OnUpdateRefresh)

    ON_UPDATE_COMMAND_UI( IDM_ALLSERVERS_EMPTYFAVORITES , OnUpdateEmptyFavs )

    ON_COMMAND( ID_TAB , OnTab )
    ON_COMMAND( ID_SHIFTTAB , OnShiftTab )
    ON_COMMAND( ID_CTRLTAB , OnCtrlTab )
    ON_COMMAND( ID_CTRLSHIFTTAB , OnCtrlShiftTab )
    ON_COMMAND( ID_NEXTPANE , OnNextPane )
    ON_COMMAND( ID_PREVPANE , OnNextPane )
    ON_COMMAND( ID_DELKEY , OnDelFavNode )
#ifdef _STRESS_BUILD
    ON_COMMAND( IDM_ALLSERVERS_FAVALLADD , OnAddAllServersToFavorites )
    ON_COMMAND( IDM_ALLSERVERS_RUNSTRESS , OnRunStress )
    ON_COMMAND( IDM_ALLSERVERS_RUNSTRESSLITE, OnRunStressLite )
#endif
    ON_WM_CLOSE()	
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, OnHtmlHelp)
	ON_COMMAND(ID_HELP, OnHtmlHelp)
//	ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
//	ON_COMMAND(ID_DEFAULT_HELP, CFrameWnd::OnHelpFinder)
    
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	m_pLeftPane = NULL;
	m_pRightPane = NULL;
}


CMainFrame::~CMainFrame()
{

}

void CMainFrame::OnHtmlHelp()
{
	TCHAR * pTsAdminHelp = L"ts_adm_topnode.htm";
	HtmlHelp(AfxGetMainWnd()->m_hWnd,L"TermSrv.Chm",HH_DISPLAY_TOPIC,(DWORD_PTR)pTsAdminHelp);
}


/*LRESULT CMainFrame::OnHelp(WPARAM wParam, LPARAM lParam)
{
	CFrameWnd::WinHelp(0L, HELP_FINDER);
	return TRUE;
}
*/

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
//		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
//		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	// If there is an extension DLL, call it's startup function
	LPFNEXSTARTUPPROC StartupProc = ((CWinAdminApp*)AfxGetApp())->GetExtStartupProc();
	if(StartupProc) {
		(*StartupProc)(this->GetSafeHwnd());
	}

    DWORD dwTid;

    HANDLE hThread = CreateThread( NULL , 0 , ( LPTHREAD_START_ROUTINE  )CMainFrame::InitWarningThread,  GetSafeHwnd() , 0 , &dwTid );

    CloseHandle( hThread );


	return 0;
}  // end CMainFrame::OnCreate


BOOL CMainFrame::OnCreateClient( LPCREATESTRUCT /*lpcs*/,
	CCreateContext* pContext)
{
	BOOL rtn;

	rtn  = m_wndSplitter.CreateStatic(this, 1, 2);
#ifdef PUBLISHED_APPS
	if(((CWinAdminApp*)AfxGetApp())->IsPicasso()) {
		rtn |= m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS(CLeftPane),
										CSize(((CWinAdminApp *)AfxGetApp())->GetTreeWidth(), 300), pContext);
	} else 	{
#else
    {
#endif
		rtn |= m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS(CAdminTreeView),
										CSize(((CWinAdminApp *)AfxGetApp())->GetTreeWidth(), 300), pContext);
	}

	rtn |= m_wndSplitter.CreateView(0, 1, RUNTIME_CLASS(CRightPane),
									CSize(0, 0), pContext);

	m_pLeftPane = m_wndSplitter.GetPane(0, 0);
	m_pRightPane = m_wndSplitter.GetPane(0, 1);

   	return rtn;
}  // end CMainFrame::OnCreateClient


BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
	cs.x = 3;
	cs.y = 3;
	cs.cx = 635;
	cs.cy = 444;
   
	return CFrameWnd::PreCreateWindow(cs);
}  // end CMainFrame::PreCreateWindow


/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}


void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

/////////////////////////////////////                                          
// F'N: CMainFrame::OnAdminChangeView                                            
//                                                                             
// - handles the custom message WM_ADMIN_CHANGEVIEW                              
// - this message is sent to the mainframe by CAdminTreeView when a new tree      
//   item is selected                                                          
// - lParam holds the info structure for the newly selected tree node          
//   and is handed along to CRightPane as the lParam of another                
//   WM_WA_CHANGEVIEW message, which CRightPane then handles as it            
//   sees fit                                                                  
//                                                                             
LRESULT CMainFrame::OnAdminChangeView(WPARAM wParam, LPARAM lParam)              
{      
	ASSERT(lParam);

	// tell the right pane to change his view
	m_pRightPane->SendMessage(WM_ADMIN_CHANGEVIEW, wParam, lParam);  
                                                                            
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminChangeView   


/////////////////////////////////////
// F'N: CMainFrame::OnAdminAddServer
//  
LRESULT CMainFrame::OnAdminAddServer(WPARAM wParam, LPARAM lParam)              
{      
	ASSERT(lParam);

	// tell the tree view to add server
	m_pLeftPane->SendMessage(WM_ADMIN_ADD_SERVER, wParam, lParam);  
    
	// tell the right pane to add server
	m_pRightPane->SendMessage(WM_ADMIN_ADD_SERVER, wParam, lParam);  
	
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminAddServer

/////////////////////////////////////
// F'N: CMainFrame::OnAdminRemoveServer
//                                  
// wParam - TRUE if server disappeared, FALSE if via Server Filtering
// lParam - CServer to remove
LRESULT CMainFrame::OnAdminRemoveServer(WPARAM wParam, LPARAM lParam)              
{     
	ASSERT(lParam);

    ODS( L"CMainFrame!OnAdminRemoveServer\n" );

#if 0
	if(wParam) {
		// Is this the currently selected server?
		CWinAdminDoc *doc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
		if((CObject*)lParam == doc->GetCurrentSelectedNode()) {
			CString TitleString;
			CString MessageString;

			TitleString.LoadString(AFX_IDS_APP_TITLE);
			MessageString.Format(IDS_SERVER_DISAPPEARED, ((CServer*)lParam)->GetName());
			MessageBox(MessageString, TitleString, MB_ICONEXCLAMATION | MB_OK);
		}
	}
#endif
	// tell the tree view to remove server
	m_pLeftPane->SendMessage(WM_ADMIN_REMOVE_SERVER, wParam, lParam);  

	// tell the right pane to remove server
	m_pRightPane->SendMessage(WM_ADMIN_REMOVE_SERVER, wParam, lParam);  
                                                                            
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminRemoveServer

//----------------------------------------------------------------------------
LRESULT CMainFrame::OnAdminAddServerToFavorites( WPARAM wp , LPARAM lp )
{
    ODS( L"CMainFrame::OnAdminAddServerToFavorites\n" );

    m_pLeftPane->SendMessage( WM_ADMIN_ADDSERVERTOFAV , wp , lp );

    return 0;
}

LRESULT CMainFrame::OnAdminRemoveServerFromFavs( WPARAM wp , LPARAM lp )
{
    ODS( L"CMainFrame::OnAdminRemoveServerFromFavs\n" );

    return m_pLeftPane->SendMessage( WM_ADMIN_REMOVESERVERFROMFAV , wp , lp );
}

/////////////////////////////////////
// F'N: CMainFrame::OnAdminUpdateServer
//                                  
LRESULT CMainFrame::OnAdminUpdateServer(WPARAM wParam, LPARAM lParam)              
{   
	ASSERT(lParam);

	// tell the tree view to update server
	m_pLeftPane->SendMessage(WM_ADMIN_UPDATE_SERVER, wParam, lParam);  

	// tell the right pane to update server
	m_pRightPane->SendMessage(WM_ADMIN_UPDATE_SERVER, wParam, lParam);  
                                                                            
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminUpdateServer


/////////////////////////////////////
// F'N: CMainFrame::OnAdminUpdateProcesses
//                                  
LRESULT CMainFrame::OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	// tell the right pane to update processes
	m_pRightPane->SendMessage(WM_ADMIN_UPDATE_PROCESSES, wParam, lParam);  
    
	return 0;                                                                  

}  // end CMainFrame::OnAdminUpdateProcesses


/////////////////////////////////////
// F'N: CMainFrame::OnAdminRemoveProcess
//                                  
LRESULT CMainFrame::OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	// tell the right pane to remove a process
	m_pRightPane->SendMessage(WM_ADMIN_REMOVE_PROCESS, wParam, lParam);  
    
	return 0;                                                                  

}  // end CMainFrame::OnAdminUpdateProcesses


/////////////////////////////////////
// F'N: CMainFrame::OnAdminAddWinStation
//  
LRESULT CMainFrame::OnAdminAddWinStation(WPARAM wParam, LPARAM lParam)              
{      
	ASSERT(lParam);

	// tell the tree view to add a WinStation
	m_pLeftPane->SendMessage(WM_ADMIN_ADD_WINSTATION, wParam, lParam);  
	
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminAddWinStation


/////////////////////////////////////
// F'N: CMainFrame::OnAdminUpdateWinStation
//  
LRESULT CMainFrame::OnAdminUpdateWinStation(WPARAM wParam, LPARAM lParam)              
{      
	ASSERT(lParam);

	// tell the tree view to update WinStation
	m_pLeftPane->SendMessage(WM_ADMIN_UPDATE_WINSTATION, wParam, lParam);  
    
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminUpdateWinStation


/////////////////////////////////////
// F'N: CMainFrame::OnAdminUpdateWinStations
//  
LRESULT CMainFrame::OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam)              
{   
	ASSERT(lParam);

	// tell the right pane to update WinStations
	m_pRightPane->SendMessage(WM_ADMIN_UPDATE_WINSTATIONS, wParam, lParam);  

	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminUpdateWinStations


/////////////////////////////////////
// F'N: CMainFrame::OnAdminRemoveWinStation
//  
LRESULT CMainFrame::OnAdminRemoveWinStation(WPARAM wParam, LPARAM lParam)              
{   
	ASSERT(lParam);

	// tell the tree view to remove a WinStation
	m_pLeftPane->SendMessage(WM_ADMIN_REMOVE_WINSTATION, wParam, lParam);  

	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminRemoveWinStation


/////////////////////////////////////
// F'N: CMainFrame::OnAdminUpdateDomain
//  
LRESULT CMainFrame::OnAdminUpdateDomain(WPARAM wParam, LPARAM lParam)              
{   
	ASSERT(lParam);

	// tell the tree view to update the domain
	m_pLeftPane->SendMessage(WM_ADMIN_UPDATE_DOMAIN, wParam, lParam);  

	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminUpdateDomain

/////////////////////////////////////
// F'N: CMainFrame::OnAdminAddDomain
//  
LRESULT CMainFrame::OnAdminAddDomain(WPARAM wParam, LPARAM lParam)              
{   
	ASSERT(lParam);

	return m_pLeftPane->SendMessage(WM_ADMIN_ADD_DOMAIN, wParam, lParam);  

}  // end CMainFrame::OnAdminAddDomain

/////////////////////////////////////
// F'N: CMainFrame::OnAdminUpdateServerInfo
//                                  
LRESULT CMainFrame::OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam)              
{   
	ASSERT(lParam);

	// tell the right pane to update server info
	m_pRightPane->SendMessage(WM_ADMIN_UPDATE_SERVER_INFO, wParam, lParam);  
                                                                            
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminUpdateServerInfo


/////////////////////////////////////
// F'N: CMainFrame::OnAdminRedisplayLicenses
//                                  
LRESULT CMainFrame::OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam)              
{   
	ASSERT(lParam);

	// tell the right pane to redisplay licenses
	m_pRightPane->SendMessage(WM_ADMIN_REDISPLAY_LICENSES, wParam, lParam);  
                                                                            
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminRedisplayLicenses


/////////////////////////////////////
// F'N: CMainFrame::OnAdminViewsReady
//                                  
LRESULT CMainFrame::OnAdminViewsReady(WPARAM wParam, LPARAM lParam)              
{   
	// tell the left pane that all views are ready
	m_pLeftPane->SendMessage(WM_ADMIN_VIEWS_READY, wParam, lParam);      
                                                                            
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminViewsReady


/////////////////////////////////////
// F'N: CMainFrame::OnExpandAll
//                                  
void CMainFrame::OnExpandAll() 
{
	// tell the tree view to expand all
	m_pLeftPane->SendMessage(WM_ADMIN_EXPANDALL, 0, 0);  
                                                                               	
}  // end CMainFrame::OnExpandAll


/////////////////////////////////////
// F'N: CMainFrame::OnCollapseAll
//                                  
void CMainFrame::OnCollapseAll() 
{
	// tell the tree view to collapse all
	m_pLeftPane->SendMessage(WM_ADMIN_COLLAPSEALL, 0, 0);  
	
}  // end CMainFrame::OnCollapseAll


/////////////////////////////////////
// F'N: CMainFrame::OnCollapseToServers
//                                  
void CMainFrame::OnCollapseToServers() 
{
	// tell the tree view to collapse to servers
	m_pLeftPane->SendMessage(WM_ADMIN_COLLAPSETOSERVERS, 0, 0);  
	
}  // end CMainFrame::OnCollapseToServers


/////////////////////////////////////
// F'N: CMainFrame::OnCollapseToDomains
//                                  
void CMainFrame::OnCollapseToDomains() 
{
	// tell the tree view to collapse to domains
	m_pLeftPane->SendMessage(WM_ADMIN_COLLAPSETODOMAINS, 0, 0);  
	
}  // end CMainFrame::OnCollapseToDomains


/////////////////////////////////////
// F'N: CMainFrame::OnRefresh
//                                  
void CMainFrame::OnRefresh() 
{
	// tell the document to do a refresh
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->Refresh();

}  // end CMainFrame::OnRefresh


/////////////////////////////////////
// F'N: CMainFrame::OnConnect
//                                  
void CMainFrame::OnConnect() 
{
	// We don't ask for confirmation, should we?    

	CWinAdminDoc* pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
	int view = pDoc->GetCurrentView();
	int page = pDoc->GetCurrentPage();

   // tell the document
	BOOL user = FALSE;
	if((view == VIEW_SERVER && page == PAGE_USERS)
		|| (view == VIEW_ALL_SERVERS && page == PAGE_AS_USERS)
		|| (view == VIEW_DOMAIN && page == PAGE_DOMAIN_USERS))
		user = TRUE;

	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ConnectWinStation(FALSE, user);
   
}  // end CMainFrame::OnConnect


/////////////////////////////////////
// F'N: CMainFrame::OnTreeConnect
//                                  
void CMainFrame::OnTreeConnect() 
{    
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ConnectWinStation(TRUE, FALSE);
   
}  // end CMainFrame::OnTreeConnect


/////////////////////////////////////
// F'N: CMainFrame::OnDisconnect
//                                  
void CMainFrame::OnDisconnect() 
{   
	DisconnectHelper(FALSE);

}	// end CMainFrame::OnDisconnect


/////////////////////////////////////
// F'N: CMainFrame::OnTreeDisconnect
//                                  
void CMainFrame::OnTreeDisconnect() 
{   
	DisconnectHelper(TRUE);

}	// end CMainFrame::OnTreeDisconnect


/////////////////////////////////////
// F'N: CMainFrame::OnTreeDisconnect
//                                  
void CMainFrame::DisconnectHelper(BOOL bTree)
{
	CString TitleString;
	CString MessageString;

	// Only bother the user if Confirmation is set
	if(((CWinAdminApp*)AfxGetApp())->AskConfirmation()) {

		TitleString.LoadString(AFX_IDS_APP_TITLE);
		MessageString.LoadString(IDS_WARN_DISCONNECT);

		if(IDOK != MessageBox(MessageString, TitleString, MB_ICONEXCLAMATION | MB_OKCANCEL)) {
			return;
		}
	}

	// tell the document
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->DisconnectWinStation(bTree);

}  // end CMainFrame::DisconnectHelper


/////////////////////////////////////
// F'N: CMainFrame::OnSendMessage
//                                  
void CMainFrame::OnSendMessage() 
{
	SendMessageHelper(FALSE);

}	// end CMainFrame::OnSendMessage


/////////////////////////////////////
// F'N: CMainFrame::OnTreeSendMessage
//                                  
void CMainFrame::OnTreeSendMessage() 
{
	SendMessageHelper(TRUE);

}	// end CMainFrame::OnTreeSendMessage


/////////////////////////////////////
// F'N: CMainFrame::SendMessageHelper
//                                  
void CMainFrame::SendMessageHelper(BOOL bTree)
{
	CSendMessageDlg dlg;	//AfxGetMainWnd());

	if(dlg.DoModal() != IDOK || !(*dlg.m_szMessage))
		return;

	MessageParms *pParms = new MessageParms;
	wcscpy(pParms->MessageTitle, dlg.m_szTitle);
	wcscpy(pParms->MessageBody, dlg.m_szMessage);

	// tell the document
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->SendWinStationMessage(bTree, pParms);
   
}  // end CMainFrame::SendMessageHelper


/////////////////////////////////////
// F'N: CMainFrame::OnShadow
//                                  
void CMainFrame::OnShadow() 
{
	// tell the document to Shadow the WinStation(s)
   ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ShadowWinStation(FALSE);

}  // end CMainFrame::OnShadow


/////////////////////////////////////
// F'N: CMainFrame::OnTreeShadow
//                                  
void CMainFrame::OnTreeShadow() 
{
	// tell the document to Shadow the WinStation(s)
   ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ShadowWinStation(TRUE);

}  // end CMainFrame::OnTreeShadow


/////////////////////////////////////
// F'N: CMainFrame::OnReset
//                                  
void CMainFrame::OnReset() 
{
	ResetHelper(FALSE);

}	// end CMainFrame::OnReset


/////////////////////////////////////
// F'N: CMainFrame::OnTreeReset
//                                  
void CMainFrame::OnTreeReset() 
{
	ResetHelper(TRUE);

}	// end CMainFrame::OnTreeReset


/////////////////////////////////////
// F'N: CMainFrame::ResetHelper
//                                  
void CMainFrame::ResetHelper(BOOL bTree)
{
	CString TitleString;
	CString MessageString;

	// Only bother the user if Confirmation is set
	if(((CWinAdminApp*)AfxGetApp())->AskConfirmation()) {

		TitleString.LoadString(AFX_IDS_APP_TITLE);
		MessageString.LoadString(IDS_WARN_RESET);

		if(IDOK != MessageBox(MessageString, TitleString, MB_ICONEXCLAMATION | MB_OKCANCEL)) {
			return;
		}	
	}
	
	// tell the document to reset the WinStation(s)
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ResetWinStation(bTree, TRUE);	

}  // end CMainFrame::ResetHelper


/////////////////////////////////////
// F'N: CMainFrame::OnStatus
//                                  
void CMainFrame::OnStatus() 
{
	// tell the document to reset the WinStation(s)
   ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->StatusWinStation(FALSE);

}  // end CMainFrame::OnStatus


/////////////////////////////////////
// F'N: CMainFrame::OnTreeStatus
//                                  
void CMainFrame::OnTreeStatus() 
{
	// tell the document to reset the WinStation(s)
   ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->StatusWinStation(TRUE);

}  // end CMainFrame::OnTreeStatus


/////////////////////////////////////
// F'N: CMainFrame::OnLogoff
//                                  
void CMainFrame::OnLogoff() 
{
	CString TitleString;
	CString MessageString;

	// Only bother the user if Confirmation is set
	if(((CWinAdminApp*)AfxGetApp())->AskConfirmation()) {

		TitleString.LoadString(AFX_IDS_APP_TITLE);
		MessageString.LoadString(IDS_WARN_LOGOFF);

		if(IDOK != MessageBox(MessageString, TitleString, MB_ICONEXCLAMATION | MB_OKCANCEL)) {
			return;
		}		
	}

	// tell the document to reset the WinStation(s)
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ResetWinStation(FALSE, TRUE);

}  // end CMainFrame::OnLogoff


/////////////////////////////////////
// F'N: CMainFrame::OnTerminate
//                                  
void CMainFrame::OnTerminate() 
{
	CString TitleString;
	CString MessageString;

	// Only bother the user if Confirmation is set
	if(((CWinAdminApp*)AfxGetApp())->AskConfirmation()) {

		TitleString.LoadString(AFX_IDS_APP_TITLE);
		MessageString.LoadString(IDS_WARN_TERMINATE);

		if(IDOK != MessageBox(MessageString, TitleString, MB_ICONEXCLAMATION | MB_OKCANCEL)) {
			return;
		}		
	}

	// tell the document to terminate the processes
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->TerminateProcess();

}  // end CMainFrame::OnTerminate


/////////////////////////////////////
// F'N: CMainFrame::OnServerConnect
//                                  
void CMainFrame::OnServerConnect() 
{
    // tell the document to connect to the server(s)
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ServerConnect();

}  // end CMainFrame::OnServerConnect

//------------------------------------------------------------
void CMainFrame::OnAddToFavorites( )
{
    // ok try following me
    // I'm going to call a method in CWinAdminDoc to determine the current server
    // and view.  This will then be forwarded back here via sendmsg and then
    // towards the treeview. 

    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ServerAddToFavorites( TRUE );
}

//=-----------------------------------------------------------
void CMainFrame::OnRemoveFromFavs( )
{
    ODS( L"CMainFrame::OnRemoveFromFavs\n" );
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ServerAddToFavorites( FALSE );
}

/////////////////////////////////////
// F'N: CMainFrame::OnServerDisconnect
//                                  
void CMainFrame::OnServerDisconnect() 
{
    // tell the document to connect to the server(s)
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ServerDisconnect();

}  // end CMainFrame::OnServerDisconnect


/////////////////////////////////////
// F'N: CMainFrame::OnTreeDomainConnectAllServers
//                                  
void CMainFrame::OnTreeDomainConnectAllServers()
{
    // tell the document to connect to the server(s)
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->TempDomainConnectAllServers();

}	// end CMainFrame::OnTreeDomainConnectAllServers


/////////////////////////////////////
// F'N: CMainFrame::OnTreeDomainDisconnectAllServers
//                                  
void CMainFrame::OnTreeDomainDisconnectAllServers()
{
    // tell the document to connect to the server(s)
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->TempDomainDisconnectAllServers();

}	// end CMainFrame::OnTreeDomainDisconnectAllServers


/////////////////////////////////////
// F'N: CMainFrame::OnTreeDomainFindServers
//                                  
void CMainFrame::OnTreeDomainFindServers()
{
    // tell the document to find servers in the domain
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->DomainFindServers();

}	// end CMainFrame::OnTreeDomainFindServers


/////////////////////////////////////
// F'N: CMainFrame::OnDomainConnectAllServers
//                                  
void CMainFrame::OnDomainConnectAllServers()
{
    // tell the document to connect to the server(s)
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CurrentDomainConnectAllServers();

}	// end CMainFrame::OnDomainConnectAllServers


/////////////////////////////////////
// F'N: CMainFrame::OnDomainDisconnectAllServers
//                                  
void CMainFrame::OnDomainDisconnectAllServers()
{
    // tell the document to connect to the server(s)
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CurrentDomainDisconnectAllServers();

}	// end CMainFrame::OnDomainDisconnectAllServers


/////////////////////////////////////
// F'N: CMainFrame::OnAllServersConnect
//                                  
void CMainFrame::OnAllServersConnect()
{
    // tell the document to connect to all servers
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ConnectToAllServers();

}	// end CMainFrame::OnAllServersConnect


/////////////////////////////////////
// F'N: CMainFrame::OnAllServersDisconnect
//                                  
void CMainFrame::OnAllServersDisconnect()
{
    // tell the document to disconnect from all servers
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->DisconnectFromAllServers();

}	// end CMainFrame::OnAllServersDisconnect


/////////////////////////////////////
// F'N: CMainFrame::OnAllServersFind
//                                  
void CMainFrame::OnAllServersFind()
{
    // tell the document to find all servers in all domains
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->FindAllServers();

}	// end CMainFrame::OnAllServersFind


/////////////////////////////////////
// F'N: CMainFrame::OnPreferences
//                                  
void CMainFrame::OnPreferences() 
{
	CPreferencesDlg dlg;

	dlg.DoModal();

}  // end CMainFrame::OnPreferences


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateConnect
//                                  
void CMainFrame::OnUpdateConnect(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanConnect());	

}  // end CMainFrame::OnUpdateConnect


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateDisconnect
//                                  
void CMainFrame::OnUpdateDisconnect(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanDisconnect());	

}  // end CMainFrame::OnUpdateDisconnect


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateLogoff
//                                  
void CMainFrame::OnUpdateLogoff(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanLogoff());	

}  // end CMainFrame::OnUpdateLogoff


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateMessage
//                                  
void CMainFrame::OnUpdateMessage(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanSendMessage());		

}


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateRefresh
//                                  
void CMainFrame::OnUpdateRefresh(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanRefresh());

}


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateReset
//                                  
void CMainFrame::OnUpdateReset(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanReset());	

}


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateShadow
//                                  
void CMainFrame::OnUpdateShadow(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanShadow());		

}


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateStatus
//                                  
void CMainFrame::OnUpdateStatus(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanStatus());	

}


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateTerminate
//                                  
void CMainFrame::OnUpdateTerminate(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTerminate());

}


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateServerConnect
//                                  
void CMainFrame::OnUpdateServerConnect(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanServerConnect());

}


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateServerDisconnect
//                                  
void CMainFrame::OnUpdateServerDisconnect(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanServerDisconnect());

}


void CMainFrame::OnUpdateServerAddToFavorite( CCmdUI *pCmdUI )
{
    pCmdUI->Enable( !( ( CWinAdminDoc* )( ( CWinAdminApp* )AfxGetApp() )->GetDocument() )->IsAlreadyFavorite() );
}

void CMainFrame::OnUpdateServerRemoveFromFavorite( CCmdUI *pCmdUI )
{
    pCmdUI->Enable( ( ( CWinAdminDoc* )( ( CWinAdminApp* )AfxGetApp() )->GetDocument() )->IsAlreadyFavorite() );
}
/////////////////////////////////////
// F'N: CMainFrame::OnUpdateTreeConnect
//                                  
void CMainFrame::OnUpdateTreeConnect(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempConnect());	

}  // end CMainFrame::OnUpdateTreeConnect


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateTreeDisconnect
//                                  
void CMainFrame::OnUpdateTreeDisconnect(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempDisconnect());	

}  // end CMainFrame::OnUpdateTreeDisconnect


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateTreeMessage
//                                  
void CMainFrame::OnUpdateTreeMessage(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempSendMessage());		

} // end CMainFrame::OnUpdateTreeMessage


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateTreeReset
//                                  
void CMainFrame::OnUpdateTreeReset(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempReset());	

}	// end CMainFrame::OnUpdateTreeReset


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateTreeShadow
//                                  
void CMainFrame::OnUpdateTreeShadow(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempShadow());		

}	// end CMainFrame::OnUpdateTreeShadow


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateTreeStatus
//                                  
void CMainFrame::OnUpdateTreeStatus(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempStatus());	

}	// end CMainFrame::OnUpdateTreeStatus


/////////////////////////////////////
// F'N: CMainFrame::OnShowSystemProcesses
//                                  
void CMainFrame::OnShowSystemProcesses() 
{
	int state = ((CWinAdminApp*)AfxGetApp())->ShowSystemProcesses();
	((CWinAdminApp*)AfxGetApp())->SetShowSystemProcesses(state^1);	

	// tell the right pane to redisplay processes
	m_pRightPane->SendMessage(WM_ADMIN_REDISPLAY_PROCESSES, 0, 0);  

}  // end CMainFrame::OnShowSystemProcesses()


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateShowSystemProcesses
//                                  
void CMainFrame::OnUpdateShowSystemProcesses(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(((CWinAdminApp*)AfxGetApp())->ShowSystemProcesses());		

}  // end CMainFrame::OnUpdateShowSystemProcesses


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateDomainPopupMenu
//                                  
void CMainFrame::OnUpdateDomainPopupMenu(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempDomainConnect());

}	// end CMainFrame::OnUpdateDomainPopupMenu


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateDomainPopupFind
//                                  
void CMainFrame::OnUpdateDomainPopupFind(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempDomainFindServers());

}	// end CMainFrame::OnUpdateDomainPopupFind


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateDomainMenu
//                                  
void CMainFrame::OnUpdateDomainMenu(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanDomainConnect());

}	// end CMainFrame::OnUpdateDomainMenu


/////////////////////////////////////
// F'N: CMainFrame::OnClose
//                                  
void CMainFrame::OnClose() 
{
	GetWindowPlacement(&((CWinAdminApp*)AfxGetApp())->m_Placement);	

	RECT rect;
	m_pLeftPane->GetWindowRect(&rect);   
	((CWinAdminApp*)AfxGetApp())->SetTreeWidth(rect.right-rect.left);

	CFrameWnd::OnClose();

}  // end CMainFrame::OnClose


/////////////////////////////////////
// F'N: CMainFrame::ActivateFrame
//                                  
void CMainFrame::ActivateFrame(int nCmdShow) 
{
	// TODO: Add your specialized code here and/or call the base class
    WINDOWPLACEMENT *pPlacement =
                        ((CWinAdminApp *)AfxGetApp())->GetPlacement();

    if ( pPlacement->length == -1 ) {

        /*
         * This is the first time that this is called, set the window
         * placement and show state to the previously saved state.
         */
        pPlacement->length = sizeof(WINDOWPLACEMENT);

        /*
         * If we have a previously saved placement state: set it.
         */
        if ( pPlacement->rcNormalPosition.right != -1 ) {

            if ( nCmdShow != SW_SHOWNORMAL )
                pPlacement->showCmd = nCmdShow;
            else
                nCmdShow = pPlacement->showCmd;

            SetWindowPlacement(pPlacement);
        }
    }

    /*
     * Perform the parent classes' ActivateFrame().
     */
    CFrameWnd::ActivateFrame(nCmdShow);

}	// end CMainFrame::ActivateFrame

//---------------------------------------------------------------------------
// bugid352062
// Splash message for people who hate to RTFM
//---------------------------------------------------------------------------
void CMainFrame::InitWarningThread( PVOID *pvParam )
{
    // display messagebox
    HWND hwnd = ( HWND )pvParam;
    DWORD dwSessionId;

    if( ProcessIdToSessionId( GetCurrentProcessId( ) , &dwSessionId ) )
    {
        if( dwSessionId == WTSGetActiveConsoleSessionId() )
        {
            // check if we are to show the dialog box
            // a) if the key does not exist show the dialog
            // b) if the key exist and the value is zero show the dialog
            
            HKEY hKey;

            DWORD dwStatus = RegOpenKeyEx( HKEY_CURRENT_USER , TEXT( "Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\TSADMIN" ) , 0 , KEY_READ , &hKey );

            if( dwStatus == ERROR_SUCCESS )
            {
                DWORD dwData = 0;

                DWORD dwSizeofData;

                dwSizeofData = sizeof( DWORD );

                RegQueryValueEx( hKey , TEXT( "DisableConsoleWarning" ) , 0 , NULL , ( LPBYTE )&dwData , &dwSizeofData );

                RegCloseKey( hKey );

                if( dwData != 0 )
                {
                    return;
                }
            }

            ::DialogBox( NULL , MAKEINTRESOURCE( IDD_DIALOG_FEATUREWARN ) , hwnd , ( DLGPROC )FWarnDlg );             
        }
    } 
}

//---------------------------------------------------------------------------
// Sets regkey DisableConsoleWarning
//---------------------------------------------------------------------------
INT_PTR CALLBACK FWarnDlg( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    switch( msg )
    {
    case WM_INITDIALOG:
        {
            HICON hIcon = LoadIcon( NULL , IDI_INFORMATION );
                        
            SendMessage( GetDlgItem( hwnd , IDC_FWICON ) , STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon );

            // center dialog

            RECT rParent;
            RECT rMe;

            GetWindowRect( GetParent( hwnd ) , &rParent );
            GetWindowRect( hwnd , &rMe );

            int xDelta , yDelta;

            xDelta = ( ( rParent.right - rParent.left ) - ( rMe.right - rMe.left ) ) / 2;

            if( xDelta < 0 )
            {
                xDelta = 0;
            }

            yDelta = ( ( rParent.bottom - rParent.top ) - ( rMe.bottom - rMe.top ) ) / 2;

            if( yDelta < 0 )
            {
                yDelta = 0;
            }

            SetWindowPos( hwnd , NULL ,  rParent.left + xDelta , rParent.top + yDelta , 0 , 0 , SWP_NOSIZE );
        }

    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            // check the button and save the settings
            HKEY hKey;

            DWORD dwDisp;

            DWORD dwStatus = RegCreateKeyEx( HKEY_CURRENT_USER , TEXT( "Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\TSADMIN" ) , 
                                             0 , NULL , 0 , KEY_ALL_ACCESS , NULL , &hKey , &dwDisp );

            if( dwStatus == ERROR_SUCCESS )
            {
                DWORD dwBool = 0;

                if( IsDlgButtonChecked( hwnd , IDC_CHECK_NOMORE ) == BST_CHECKED )
                {
                    dwBool = ( DWORD )-1;
                }

                RegSetValueEx( hKey , TEXT( "DisableConsoleWarning" ), 0 , REG_DWORD , ( LPBYTE )&dwBool , sizeof( dwBool ) );

                RegCloseKey( hKey );
            }

            // HKCU\Software\Microsoft\Windows NT\CurrentVersion\Terminal Server\TSADMIN\DisableConsoleWarning (REG_DWORD)
            EndDialog( hwnd , 0 );
        }
    }

    return 0;
}

//=----------------------------------------------------------------------------------------------
void CMainFrame::OnTab( )
{
    ODS( L"CMainFrame::OnTab received\n");

    // pre tabbing
    // set this state so that we can distinguish how the tabs received focus
    // we can rule out the tab key

    CWinAdminDoc* pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

    pDoc->SetOnTabFlag( );

    m_pRightPane->SendMessage( WM_ADMIN_TABBED_VIEW , 0 , 0 );

    pDoc->ResetOnTabFlag( );

    // end tabbing
 
}

//=----------------------------------------------------------------------------------------------
void CMainFrame::OnShiftTab( )
{
    ODS( L"CMainFrame::OnShiftTab received\n" );

    CWinAdminDoc* pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

    pDoc->SetOnTabFlag( );

    m_pRightPane->SendMessage( WM_ADMIN_SHIFTTABBED_VIEW , 0 , 0 );

    pDoc->ResetOnTabFlag( );
}

//=----------------------------------------------------------------------------------------------
//= this message is sent from the right pane item in the view
//
LRESULT CMainFrame::OnForceTreeViewFocus( WPARAM wp , LPARAM lp )
{
    m_pLeftPane->SetFocus( );

    return 0;
}

//=----------------------------------------------------------------------------------------------
// this is to rotate around the tabs and treeview
//
void CMainFrame::OnCtrlTab( )
{
    ODS( L"CMainFrame::OnCtrlTab received\n" );
    
    m_pRightPane->SendMessage( WM_ADMIN_CTRLTABBED_VIEW , 0 , 0 );
}

//=----------------------------------------------------------------------------------------------
// this is to rotate around the tabs and treeview in the "other" direction
//
void CMainFrame::OnCtrlShiftTab( )
{
    ODS( L"CMainFrame::OnCtrlShiftTab\n" );

    m_pRightPane->SendMessage( WM_ADMIN_CTRLSHIFTTABBED_VIEW , 0 , 0 );
}

//=-----------------------------------------------------------------------------------------
void CMainFrame::OnNextPane( )
{
    ODS( L"CMainFrame::OnNextPane\n" );
    
    m_pRightPane->SendMessage( WM_ADMIN_NEXTPANE_VIEW , 0 , 0 );
}

//=-----------------------------------------------------------------------------------------
void CMainFrame::OnDelFavNode( )
{
    ODS( L"CMainFrame::OnDelFavNode\n" );

    m_pLeftPane->SendMessage( WM_ADMIN_DELTREE_NODE , 0 , 0 );
}

//This will find the server with the given name
//and place the cursor on it. The server may be
//added to the list if it's not already there
bool CMainFrame::LocateServer(LPCTSTR sServerName)
{
    TCHAR szServerName[ 256 ];
    CString cstrTitle;
    CString cstrMsg;

    CWaitCursor wait;

    DBGMSG( L"Server to connect to is %s\n" , sServerName );

    CWinAdminDoc* pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

    // resolve name
    // check to see if its an ipv4 address

    lstrcpy( szServerName , sServerName );

    WSADATA wsaData;
    if( WSAStartup( 0x202 , &wsaData ) == 0 )
    {
        char szAnsiServerName[ 256 ];
        WideCharToMultiByte( CP_OEMCP ,
                             0 ,
                             szServerName,
                             -1,
                             szAnsiServerName , 
                             sizeof( szAnsiServerName ),
                             NULL , 
                             NULL );


        int nAddr = 0;
        nAddr = inet_addr( szAnsiServerName );

        // if this is a valid ipv4 address then lets get the host name
        // otherwise lets fall through and see if its a valid server name

        if( nAddr != 0 && nAddr != INADDR_NONE )
        {
            ODS( L"Server name is IPV4\n" );

            struct hostent *pHostEnt;
            pHostEnt = gethostbyaddr( ( char * )&nAddr , 4 , AF_INET );

            if( pHostEnt != NULL )
            {
                DWORD dwSize;
        
                TCHAR szDnsServerName[ 256 ];
                MultiByteToWideChar( CP_OEMCP ,
                                     0 ,
                                     pHostEnt->h_name ,
                                     -1,
                                     szDnsServerName,
                                     sizeof( szDnsServerName ) / sizeof( TCHAR ) );

                dwSize = sizeof( szServerName ) / sizeof( TCHAR );

                DnsHostnameToComputerName( szDnsServerName , szServerName , &dwSize );

            }
            else
            {
                // there was an error ( ip addr was probably not valid )
                // display error                    
                cstrTitle.LoadString( AFX_IDS_APP_TITLE );
                cstrMsg.LoadString( IDS_NO_SERVER );

                MessageBox( cstrMsg , cstrTitle , MB_OK | MB_ICONINFORMATION );                    

                WSACleanup();                    

                return FALSE;
            }

        }

        WSACleanup();
    }
   

    CServer *pServer = pDoc->FindServerByName( szServerName );


    if( pServer == NULL )
    {
        TCHAR szDomainName[ 256 ];

        // this means that the server is not in the list            
        // let's find out what domain this server belongs to
        DBGMSG( L"%s could not be found in the server list\n" , szServerName );

        // Verify it's a terminal server we can connect to.
        HANDLE hTerminalServer = NULL;

        hTerminalServer = WinStationOpenServer( szServerName );

        if( hTerminalServer == NULL )
        {
            DBGMSG( L"WinstationOpenServer failed with %d\n" , GetLastError( ) );
            cstrTitle.LoadString( AFX_IDS_APP_TITLE );
            cstrMsg.LoadString( IDS_NO_SERVER );
            MessageBox( cstrMsg , cstrTitle , MB_OK | MB_ICONINFORMATION ); 
            return false;
        }

        WinStationCloseServer( hTerminalServer );


        DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDsRPDIB = NULL;

        DWORD dwStatus = DsRoleGetPrimaryDomainInformation( 
                            szServerName ,
                            DsRolePrimaryDomainInfoBasic,
                            ( PBYTE * )&pDsRPDIB );

        DBGMSG( L"DsRoleGetPrimaryDomainInformation returned 0x%x\n" , dwStatus );

        
        if( dwStatus == ERROR_SUCCESS && pDsRPDIB != NULL )
        {
            lstrcpy( szDomainName , pDsRPDIB->DomainNameFlat );

            DsRoleFreeMemory( pDsRPDIB );
        }

        if( dwStatus != ERROR_SUCCESS )
        {
            // otherwise the server probably does not exist or its on 
            // a non-trusted domain
            LPTSTR pBuffer = NULL;
 
            cstrTitle.LoadString( AFX_IDS_APP_TITLE );
            // cstrMsg.LoadString( IDS_NO_SERVER );
            
            ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,                                          //ignored
                    dwStatus    ,                                //message ID
                    MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ), //message language
                    (LPTSTR)&pBuffer,                              //address of buffer pointer
                    0,                                             //minimum buffer size
                    NULL );

            if( pBuffer != NULL )
            {                
                cstrMsg.Format( IDS_NOSERVER_REASON , pBuffer );

                LocalFree( pBuffer );
            }
            else
            {
                cstrMsg.Format( IDS_NOSERVER_REASON , TEXT("" ) );
            }
            
            MessageBox( cstrMsg , cstrTitle , MB_OK | MB_ICONINFORMATION );
            return false;
        }
        else
        {
            // find the domain

            BOOL bFound = FALSE;

            CObList *pDomainList = pDoc->GetDomainList();

            POSITION pos = pDomainList->GetHeadPosition();
             
             while( pos )
             {
                 CDomain *pDomain = ( CDomain* )pDomainList->GetNext( pos );

                 if( lstrcmpi( pDomain->GetName( ) , szDomainName ) == 0 )
                 {
                     bFound = TRUE;

                     CServer *pServer = new CServer( pDomain , szServerName , FALSE , FALSE );

                     if( pServer == NULL )
                     {
                         break;
                     }

                     pServer->SetManualFind();
                     // add server to list
                     pDoc->AddServer( pServer );

                     SendMessage( WM_ADMIN_ADD_SERVER , ( WPARAM )TVI_SORT , ( LPARAM )pServer );

                     m_pLeftPane->SendMessage( WM_ADMIN_GOTO_SERVER , 0 , ( LPARAM )pServer ); 
                     
                     break;                        
                 }                     
             }
             if( !bFound )
             {
                 CDomain *pDomain = new CDomain( szDomainName );
                 
                 if( pDomain == NULL )
                     return false;

                 pDoc->AddDomain( pDomain );
                 
                 m_pLeftPane->SendMessage( WM_ADMIN_ADD_DOMAIN , (WPARAM)NULL , ( LPARAM )pDomain );

                 CServer *pServer = new CServer( pDomain , szServerName , FALSE , FALSE );

                 if( pServer == NULL )
                     return false;

                 pServer->SetManualFind();
                 // add server to list
                 pDoc->AddServer( pServer );

                 SendMessage( WM_ADMIN_ADD_SERVER , ( WPARAM )TVI_SORT , ( LPARAM )pServer );

                 m_pLeftPane->SendMessage( WM_ADMIN_GOTO_SERVER , 0 , ( LPARAM )pServer ); 
             }
        }
    }
    else
    {
        // scroll to server
        DBGMSG( L"Server %s is in the list\n",szServerName );

        if( pServer->IsState(SS_DISCONNECTING) )
        {
            TCHAR buf[ 256 ];
            ODS( L"but it's gone away so we're not jumping to server\n" );
            cstrTitle.LoadString( AFX_IDS_APP_TITLE );
            cstrMsg.LoadString( IDS_CURRENT_DISCON );

            wsprintf( buf , cstrMsg , szServerName );
            MessageBox( buf , cstrTitle , MB_OK | MB_ICONINFORMATION );

            return false;
        }

        if( pServer->GetTreeItem( ) == NULL )
        {
            ODS( L"this server has no association to the tree add it now\n" );

            SendMessage( WM_ADMIN_ADD_SERVER , ( WPARAM )TVI_SORT , ( LPARAM )pServer );
        }

        m_pLeftPane->SendMessage( WM_ADMIN_GOTO_SERVER , 0 , ( LPARAM )pServer );  
    }   

    return true;
}

//=-----------------------------------------------------------------------------------------
void CMainFrame::OnFindServer( )
{
    CMyDialog dlg;

    if( dlg.DoModal( ) == IDOK )
    {
        if (LocateServer(dlg.m_cstrServerName));
            m_pLeftPane->SendMessage(WM_ADMIN_CONNECT_TO_SERVER, 0, 0);
    }
}

//=-----------------------------------------------------------------
LRESULT CMainFrame::OnAdminGetTVStates( WPARAM wp , LPARAM lp )
{
    ODS( L"CMainFrame::OnAdminGetTVStates\n" );
    return m_pLeftPane->SendMessage( WM_ADMIN_GET_TV_STATES , 0 , 0 );
}

//=-----------------------------------------------------------------
LRESULT CMainFrame::OnAdminUpdateTVStates( WPARAM , LPARAM )
{
    ODS( L"CMainFrame::OnAdminUpdateTVStates\n" );
    return m_pLeftPane->SendMessage( WM_ADMIN_UPDATE_TVSTATE , 0 , 0 );
}

//=-----------------------------------------------------------------
void CMainFrame::OnEmptyFavorites(  )
{
    ODS( L"CMainFrame!OnEmptyFavorites\n" );

    m_pLeftPane->SendMessage( IDM_ALLSERVERS_EMPTYFAVORITES , 0 , 0 );   

}

void CMainFrame::OnUpdateEmptyFavs( CCmdUI* pCmdUI )
{
    BOOL b = ( BOOL )m_pLeftPane->SendMessage( WM_ISFAVLISTEMPTY , 0 , 0 );

    pCmdUI->Enable( !b );
}
//=-----------------------------------------------------------------
#ifdef _STRESS_BUILD
void CMainFrame::OnAddAllServersToFavorites( )
{
    ODS( L"!OnAddAllServersToFavorites -- if you're seeing this you're running a special stress build\n" );
    
    // loop through every server and add to fav's
    CWinAdminDoc* pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

    CObList *pServerList = pDoc->GetServerList();
    
    POSITION pos = pServerList->GetHeadPosition();

    while( pos )
    {
        CServer *pServer = ( CServer* )pServerList->GetNext( pos );

        if( pServer != NULL &&
            !pServer->IsState( SS_DISCONNECTING ) &&
            pServer->GetTreeItemFromFav() == NULL )
        {
            m_pLeftPane->SendMessage( WM_ADMIN_ADDSERVERTOFAV , 0 , ( LPARAM )pServer );
        }
    }
}


//=-----------------------------------------------------------------
void CMainFrame::OnRunStress( )
{
    ODS( L"OnRunStress! Stress starting...\n" );

    AfxBeginThread((AFX_THREADPROC)RunStress , ( PVOID )m_pLeftPane );

}

//=-----------------------------------------------------------------
void CMainFrame::OnRunStressLite( )
{
    ODS( L"OnRunStressLite! Stress lite starting...\n" );

    AfxBeginThread((AFX_THREADPROC)RunStressLite , ( PVOID )m_pLeftPane );

}

//=-----------------------------------------------------------------
DWORD RunStressLite( PVOID pv )
{
    CWnd *pLeftPane = ( CWnd * )pv;

    CWinAdminDoc* pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
    
    CObList *pDomainList = pDoc->GetDomainList();

    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

    // get all domains to start enumerating

    pDoc->FindAllServers( );
    
    int nStress = 0;
    
    while( 1 )
    {
    
        DBGMSG( L"Stress lite run #%d\n" , nStress );

        Sleep( 2 * 1000 * 60 );

        // add all servers to favorites

        ODS( L"STRES RUN! Adding all servers to favorites\n" );

        p->SendMessage(  WM_COMMAND , ( WPARAM )IDM_ALLSERVERS_FAVALLADD ,  ( LPARAM )p->GetSafeHwnd( ) );

        pLeftPane->SendMessage( WM_ADMIN_EXPANDALL , 0 , 0 );

        // wait 1 minutes

        Sleep( 1 * 1000 * 60 );

        // remove all servers from favorites
        ODS( L"STRESS RUN! emptying favorites\n" );

        pLeftPane->SendMessage( IDM_ALLSERVERS_EMPTYFAVORITES , 1 , 0 ); 

        nStress++;

        // start over ( no end );
    }


}

//=-----------------------------------------------------------------
DWORD RunStress( PVOID pv )
{
    CWnd *pLeftPane = ( CWnd * )pv;

    CWinAdminDoc* pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
    
    CObList *pDomainList = pDoc->GetDomainList();

    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

        
    // select each domain connect to each domain

    POSITION pos = pDomainList->GetHeadPosition();

    while( pos )
    {
        // Get a pointer to the domain

        CDomain *pDomain = (CDomain*)pDomainList->GetNext(pos);

        // If this domain isn't currently enumerating servers, tell it to

        if( !pDomain->GetThreadPointer( ) )
        {           
            // refresh server
            if( lstrcmpi( pDomain->GetName( ) , L"ASIA" ) == 0 ||
                lstrcmpi( pDomain->GetName( ) , L"HAIFA" ) == 0 )            
            {
                DBGMSG( L"STRESS RUN! Enumerating %s\n", pDomain->GetName( ) );
                
                pDomain->StartEnumerating();
            }
        }

    }
    
    while( 1 )
    {
        // wait a half a second.

        Sleep( 1 * 10 * 1000 );

        // pLeftPane->SendMessage( WM_ADMIN_COLLAPSEALL , 0 , 0 );

        // connect to them all

        ODS( L"\nSTRESS RUN! Connecting to all servers\n\n" );
        
        p->SendMessage( WM_COMMAND , ( WPARAM )IDM_ALLSERVERS_CONNECT,( LPARAM )p->GetSafeHwnd( ) );
        // pDoc->ConnectToAllServers();

        Sleep( 1 * 30 * 1000 );

        // pLeftPane->SendMessage( WM_ADMIN_EXPANDALL , 0 , 0 );

        // disconnect them all

        ODS( L"\nSTRESS RUN! Disconnecting from all servers\n\n" );

        p->SendMessage( WM_COMMAND , ( WPARAM )IDM_ALLSERVERS_DISCONNECT,( LPARAM )p->GetSafeHwnd( ) );

        // pDoc->DisconnectFromAllServers( );

        ODS( L"\nSTRESS RUN! waiting for completion\n\n" );

        while( g_fWaitForAllServersToDisconnect );

        ODS( L"\nSTRESS RUN! done completing\n\n" );

        // pLeftPane->SendMessage( WM_ADMIN_COLLAPSEALL , 0 , 0 );

        // add all to favorites

        ODS( L"\nSTRESS RUN! Adding all servers to favorites\n\n" );

        p->SendMessage(  WM_COMMAND , ( WPARAM )IDM_ALLSERVERS_FAVALLADD ,  ( LPARAM )p->GetSafeHwnd( ) );

        // pLeftPane->SendMessage( WM_ADMIN_EXPANDALL , 0 , 0 );

        // connect to them all

        Sleep( 1 * 60 * 1000 );

        ODS( L"\nSTRESS RUN! Connecting phase 2 to all servers\n\n" );
 
        // pDoc->ConnectToAllServers();
        p->SendMessage( WM_COMMAND , ( WPARAM )IDM_ALLSERVERS_CONNECT,( LPARAM )p->GetSafeHwnd( ) );

        Sleep( 1 * 30 * 1000 );

        ODS( L"\nSTRESS RUN! Disconnecting phase 2 from all servers\n\n" );

        // pDoc->DisconnectFromAllServers( );
        p->SendMessage( WM_COMMAND , ( WPARAM )IDM_ALLSERVERS_DISCONNECT,( LPARAM )p->GetSafeHwnd( ) );

        while( g_fWaitForAllServersToDisconnect );

        // remove from favs

        ODS( L"STRESS RUN! emptying favorites\n" );

        pLeftPane->SendMessage( IDM_ALLSERVERS_EMPTYFAVORITES , 1 , 0 ); 
    }
     
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\ltpane.h ===
/*******************************************************************************
*
* ltpane.h
*
* - declarations for the CLeftPane class
* - the LeftPane class is a public CView derivative that maintains
*   two tree views, swapping them
*   in and out of it's space as necessary (actually the views are
*   disabled/hidden and enabled/shown, but you get the idea...)
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\ltpane.h  $
*  
*     Rev 1.3   16 Feb 1998 16:01:20   donm
*  modifications to support pICAsso extension
*  
*     Rev 1.2   19 Jan 1998 16:47:50   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.1   03 Nov 1997 15:24:44   donm
*  added Domains
*  
*     Rev 1.0   13 Oct 1997 22:33:20   donm
*  Initial revision.
*******************************************************************************/

#ifndef _LEFTPANE_H
#define _LEFTPANE_H

#include "treeview.h"	// CAdminTreeView
#include "apptree.h"    // CAppTreeView

class CLeftPane;


class CTreeTabCtrl : public CTabCtrl
{

friend class CLeftPane;

protected:
	CTreeTabCtrl();           // protected constructor used by dynamic creation
	void Initialize();

// Attributes
protected:

// Operations
public:

protected:
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTreeTabCtrl)
	public:
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CTreeTabCtrl();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CTreeTabCtrl)
	afx_msg void OnSize(UINT nType, int cx, int cy);
//	afx_msg void OnSelchange(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

};

//////////////////////
// CLASS: CLeftPane
//
class CLeftPane : public CView
{
friend class CTreeTabCtrl;
friend class CAdminTreeView;
friend class CAppTreeView;

private:
	CTreeTabCtrl*	m_pTabs;
	CFont*      m_pTabFont;

protected:
	CLeftPane();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CLeftPane)

// Attributes
protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxServer;		// index of Servers icon image 
   int m_idxApps;			// index of Apps icon image

	CAdminTreeView*	m_pServerTreeView;
   CAppTreeView*		m_pAppTreeView;

	TREEVIEW m_CurrTreeViewType;	// keeps track of currently 'active' view in the left pane
	CView *m_CurrTreeView;

// Operations
public:
	TREEVIEW GetCurrentTreeViewType() { return m_CurrTreeViewType; }
	CView *GetCurrentTreeView() { return m_CurrTreeView; }

protected:

private:
	// Builds the image list
	void BuildImageList();			
	// Adds an icon's image to the image list and returns the image's index
	int AddIconToImageList(int);	

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLeftPane)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CLeftPane();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CLeftPane)
	afx_msg LRESULT OnExpandAll(WPARAM, LPARAM);
	afx_msg LRESULT OnCollapseAll(WPARAM, LPARAM);
	afx_msg LRESULT OnCollapseToServers(WPARAM, LPARAM);
    afx_msg LRESULT OnCollapseToDomains(WPARAM, LPARAM);
	afx_msg LRESULT OnCollapseToApplications(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminAddServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRemoveServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminAddWinStation(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateWinStation(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRemoveWinStation(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateDomain(WPARAM, LPARAM);
    afx_msg LRESULT OnAdminAddDomain(WPARAM, LPARAM);
	afx_msg LRESULT OnExtAddApplication(WPARAM, LPARAM);
	afx_msg LRESULT OnExtRemoveApplication(WPARAM, LPARAM);
	afx_msg LRESULT OnExtAppChanged(WPARAM, LPARAM);
	afx_msg LRESULT OnExtAddAppServer(WPARAM, LPARAM);
	afx_msg LRESULT OnExtRemoveAppServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminViewsReady(WPARAM, LPARAM lParam);
	afx_msg void OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnRClick(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CLeftPane



#endif  // _LEFTPANE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\servervw.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* servervw.h
*
* declarations for the CServerView class
*
*  
*******************************************************************************/

#ifndef _SERVERVIEW_H
#define _SERVERVIEW_H

#include "servpgs.h"

const int NUMBER_OF_PAGES = 4;


////////////////////
// CLASS: CServerView
//
class CServerView : public CAdminView
{
friend class CRightPane;
friend class CAdminPage;

private:
	CTabCtrl*	m_pTabs;
	CFont*      m_pTabFont;

	int m_CurrPage;


	CServer* m_pServer;	// pointer to current server's info
		
protected:
	CServerView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CServerView)

// Attributes
public:

protected:
   static PageDef pages[NUMBER_OF_PAGES];

// Operations
public:
	int GetCurrentPage() { return m_CurrPage; }
protected:
	virtual void Reset(void *pServer);

	void AddTab(int index, TCHAR* text, ULONG pageindex);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CServerView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    // Generated message map functions
protected:
	//{{AFX_MSG(CServerView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT OnChangePage(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam);
	afx_msg void OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg LRESULT OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnNextPane( WPARAM , LPARAM );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CServerView

#endif  // _SERVERVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\resource.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by winadmin.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_WINADMTYPE                  129
#define IDI_SERVER                      131
#define IDD_SERVER_WINSTATIONS          132
#define IDD_SERVER_PROCESSES            133
#define IDI_BLANK                       134
#define IDD_SERVER_USERS                134
#define IDI_CONSOLE                     135
#define IDD_SERVER_LICENSES             135
#define IDD_DIALOG_FEATUREWARN          136
#define IDI_NET                         138
#define IDI_WORLD                       143
#define IDI_USER                        146
#define IDI_ENABLER                     149
#define IDI_QUESTIONMARK                151
#define IDI_REDSLASH                    152
#define IDD_WINSTATION_INFO             153
#define IDD_WINSTATION_PROCESSES        154
#define IDD_PREFERENCES                 156
#define IDD_SERVER_INFO                 157
#define IDI_NOTSIGN                     160
#define IDI_BASE                        161
#define IDI_BUMP                        162
#define IDI_UNKNOWN                     163
#define IDI_CHECK                       169
#define IDI_CURRENT_SERVER              170
#define IDI_CURRENT_USER                171
#define IDI_CURRENT_CONSOLE             172
#define IDI_CURRENT_NET                 173
#define IDI_ASYNC                       174
#define IDI_CURRENT_ASYNC               175
#define IDR_WINSTATION_POPUP            176
#define IDI_DIRECT_ASYNC                177
#define IDI_CURRENT_DIRECT_ASYNC        178
#define IDR_WINSTATION_TREE_POPUP       179
#define IDR_USER_POPUP                  180
#define IDR_PROCESS_POPUP               181
#define IDD_SHUTDOWN                    183
#define IDI_APPS                        185
#define IDI_GENERIC_APP                 186
#define IDI_APP_USER                    188
#define IDI_GLOBALGROUP                 189
#define IDI_LOCALGROUP                  190
#define IDI_DOMAIN                      191
#define IDI_CURRENT_DOMAIN              192
#define IDR_SERVER_POPUP                203
#define IDI_DOMAIN_NOT_CONNECTED        205
#define IDI_SERVER_NOT_CONNECTED        206
#define IDI_EXPLICIT                    209
#define IDI_ANONYMOUS                   210
#define IDB_APP_USERS                   211
#define IDR_DOMAIN_POPUP                212
#define IDR_ALLSERVERS_POPUP            213
#define IDD_DIALOG_SHADOWWARN           214
#define IDC_FWICON                      215
#define IDC_CHECK_NOMORE                216
#define IDD_SHADOWSTART                 240
#define IDC_SHADOWSTART_HOTKEY          241
#define IDC_SHADOWSTART_SHIFT           242
#define IDC_SHADOWSTART_CTRL            243
#define IDC_SHADOWSTART_ALT             244
#define IDD_MESSAGE                     250
#define IDC_MESSAGE_TITLE               251
#define IDC_MESSAGE_MESSAGE             252
#define IDD_DIALOG_FINDSERVER           253
#define IDC_EDIT_FINDSERVER             254
#define IDC_COMMON_USERNAME             300
#define IDC_COMMON_WINSTATIONNAME       301
#define IDC_COMMON_IBYTES               302
#define IDC_COMMON_OBYTES               303
#define IDC_COMMON_IFRAMES              304
#define IDC_COMMON_OFRAMES              305
#define IDC_COMMON_IBYTESPERFRAME       306
#define IDC_COMMON_OBYTESPERFRAME       307
#define IDC_COMMON_IFRAMEERRORS         308
#define IDC_COMMON_OFRAMEERRORS         309
#define IDC_COMMON_IPERCENTFRAMEERRORS  310
#define IDC_COMMON_OPERCENTFRAMEERRORS  311
#define IDC_COMMON_ITIMEOUTERRORS       312
#define IDC_COMMON_OTIMEOUTERRORS       313
#define IDC_COMMON_ICOMPRESSIONRATIO    314
#define IDC_COMMON_OCOMPRESSIONRATIO    315
#define IDC_REFRESHNOW                  320
#define IDC_RESETCOUNTERS               321
#define IDC_MOREINFO                    322
#define IDD_ASYNC_STATUS                350
#define IDC_ASYNC_DEVICE                351
#define IDC_ASYNC_BAUD                  352
#define IDC_ASYNC_DTR                   353
#define IDC_ASYNC_RTS                   354
#define IDC_ASYNC_CTS                   355
#define IDC_ASYNC_DSR                   356
#define IDC_ASYNC_DCD                   357
#define IDC_ASYNC_RI                    358
#define IDC_ASYNC_IFRAMING              359
#define IDC_ASYNC_IOVERRUN              360
#define IDC_ASYNC_IOVERFLOW             361
#define IDC_ASYNC_IPARITY               362
#define IDC_ASYNC_OFRAMING              363
#define IDC_ASYNC_OOVERRUN              364
#define IDC_ASYNC_OOVERFLOW             365
#define IDC_ASYNC_OPARITY               366
#define IDD_NETWORK_STATUS              370
#define IDC_NETWORK_LANADAPTER          371
#define IDC_NASI_PORTNAME               391
#define IDC_COMMON_IPERCENTFRAMEERRORS2 392
#define IDC_COMMON_OPERCENTFRAMEERRORS2 393
#define IDC_COMMON_ICOMPRESSIONRATIO2   394
#define IDC_COMMON_OCOMPRESSIONRATIO2   395
#define IDC_PRESS_NUMKEYPAD             396
#define IDC_PRESS_KEY                   397
#define IDD_CONNECT_PASSWORD            440
#define IDL_CPDLG_PROMPT                441
#define IDD_ALL_SERVER_LICENSES         441
#define IDC_CPDLG_PASSWORD              442
#define IDD_ALL_SERVER_PROCESSES        442
#define IDD_ALL_SERVER_USERS            443
#define IDD_ALL_SERVER_WINSTATIONS      444
#define IDD_ALL_SERVER_SERVERS          445
#define IDD_LISTENER                    447
#define IDD_WINSTATION_NOINFO           448
#define IDD_WINSTATION_CACHE            450
#define IDD_MESSAGE_PAGE                457
#define IDD_DOMAIN_LICENSES             458
#define IDD_WINSTATION_MODULES          461
#define IDS_NO_SERVER                   462
#define IDS_NOSERVER_REASON             463
#define IDS_CURRENT_DISCON              464
#define IDC_WINSTATION_LIST             1000
#define IDC_USER_LIST                   1001
#define IDC_LICENSE_LIST                1002
#define IDC_WINSTATION_PROCESS_LIST     1005
#define IDC_WINSTATION_MODULE_LIST      1006
#define IDC_PREFERENCES_PROC_MANUAL     1007
#define IDC_PREFERENCES_PROC_EVERY      1008
#define IDC_PREFERENCES_PROC_SECONDS    1009
#define IDC_PREFERENCES_PROC_SPIN       1010
#define IDC_PREFERENCES_STATUS_MANUAL   1011
#define IDC_PREFERENCES_STATUS_EVERY    1012
#define IDC_PREFERENCES_STATUS_SECONDS  1013
#define IDC_PREFERENCES_STATUS_SPIN     1014
#define IDC_PREFERENCES_CONFIRM         1015
#define IDC_PREFERENCES_SAVE            1016
#define IDC_PREFERENCES_HELP            1017
#define IDC_WS_INFO_USERNAME            1018
#define IDC_WS_INFO_CLIENTNAME          1019
#define IDC_WS_INFO_BUILD               1020
#define IDC_WS_INFO_DIR                 1021
#define IDC_WS_INFO_SERVER_BUFFERS      1022
#define IDC_WS_INFO_ADDRESS             1023
#define IDC_WS_INFO_PRODUCT_ID          1024
#define IDC_WS_INFO_CLIENT_BUFFERS      1025
#define IDC_WS_INFO_MODEM_NAME          1026
#define IDC_SERVER_LIST                 1028
#define IDC_WSINFO_HELP                 1035
#define IDC_WS_INFO_CLIENT_LICENSE      1036
#define IDC_WS_INFO_SERIAL_NUMBER       1038
#define IDC_PROCESS_LIST                1040
#define IDC_CITRIX_VERSION              1042
#define IDC_CITRIX_BUILD                1043
#define IDC_SERVICE_PACK                1045
#define IDC_HOTFIX_LIST                 1046
#define IDC_INSTALL_DATE                1047
#define IDC_LOCAL_INSTALLED             1050
#define IDC_LOCAL_INUSE                 1051
#define IDC_LOCAL_AVAILABLE             1052
#define IDC_POOL_INSTALLED              1053
#define IDC_POOL_INUSE                  1054
#define IDC_POOL_AVAILABLE              1055
#define IDC_WS_INFO_COLOR_DEPTH         1056
#define IDC_WS_INFO_RESOLUTION          1057
#define IDC_XXX                         1058
#define IDC_WS_INFO_CACHE               1059
#define IDC_TOTAL_INSTALLED             1060
#define IDC_TOTAL_INUSE                 1061
#define IDC_TOTAL_AVAILABLE             1062
#define IDC_BITMAP_SIZE                 1063
#define IDC_BITMAP_MINIMUM              1064
#define IDC_BITMAP_SIG_LEVEL            1065
#define IDC_TRACE                       1066
#define IDC_TCP_LOAD                    1068
#define IDC_IPX_LOAD                    1069
#define IDC_NETBIOS_LOAD                1070
#define IDC_TCP_LABEL                   1071
#define IDC_IPX_LABEL                   1072
#define IDC_NETBIOS_LABEL               1073
#define IDC_LABEL                       1076
#define IDC_SHUTDOWN_MSG                1077
#define IDC_HOTFIX_LABEL                1078
#define IDC_PRODUCT_NAME                1079
#define IDC_PRODUCT_VERSION             1080
#define IDC_LOAD_BALANCING_GROUP        1081
#define IDC_APPLICATION_SERVER_LIST     1082
#define IDC_APPLICATION_USER_LIST       1083
#define IDC_APPSERVER_USER_LIST         1085
#define IDC_APPLICATION_SECURITY_LIST   1086
#define IDC_MESSAGE                     1087
#define IDC_APP_TYPE                    1088
#define IDC_HIDE_TITLE_BAR              1089
#define IDC_APPUSERS_LABEL              1090
#define IDC_PREFERENCES_PERSISTENT      1091
#define IDC_MAXIMIZE_WINDOW             1092
#define IDC_ENCRYPTION_LEVEL            1093
#define IDC_APPLICATION_LIST            1094
#define IDC_APP_LIST                    1095
#define IDC_SERVER_TABS                 2001
#define IDC_WINSTATION_TABS             2002
#define IDC_ALL_SERVERS_TABS            2002
#define IDC_TREE_TABS                   2002
#define IDC_HOTFIX_LABEL2               2003
#define IDC_ALL_APPLICATION_TABS        2003
#define IDC_DOMAIN_TABS                 2004
#define IDV_BLANKVIEW                   3001
#define IDV_ALLSERVERSVIEW              3002
#define IDV_SERVERVIEW                  3003
#define IDV_WINSTATIONVIEW              3004
#define IDV_BADSERVERVIEW               3009
#define IDP_SERVER_WINSTATIONSPAGE      4001
#define IDP_SERVER_PROCESSESPAGE        4002
#define IDP_SERVER_USERSPAGE            4003
#define IDP_SERVER_LICENSESPAGE         4004
#define IDP_WINSTATION_INFOPAGE         4005
#define IDP_WINSTATION_PROCESSESPAGE    4006
#define IDP_SERVER_INFOPAGE             4007
#define IDP_ALL_SERVERS_SERVERSPAGE     4008
#define IDP_ALL_SERVERS_USERSPAGE       4009
#define IDP_ALL_SERVERS_LICENSESPAGE    4010
#define IDP_ALL_SERVERS_PROCESSESPAGE   4011
#define IDP_ALL_SERVERS_WINSTATIONSPAGE 4012
#define IDP_WINSTATION_NOINFOPAGE       4015
#define IDP_WINSTATION_CACHEPAGE        4017
#define IDP_WINSTATION_DISCINFOPAGE     4018
#define IDP_LISTENER                    4019
#define WM_ADMIN_TABBED_VIEW            4050
#define WM_FORCE_TREEVIEW_FOCUS         4051
#define WM_ADMIN_SHIFTTABBED_VIEW       4052
#define WM_ADMIN_CTRLTABBED_VIEW        4053
#define WM_ADMIN_CTRLSHIFTTABBED_VIEW   4054
#define WM_ADMIN_NEXTPANE_VIEW          4055
#define WM_ADMIN_CHANGEVIEW             5000
#define WM_ADMIN_EXPANDALL              5001
#define WM_WA_SERVER_CHANGEPAGE         5002
#define WM_ADMIN_COLLAPSEALL            5004
#define WM_ADMIN_COLLAPSETOSERVERS      5005
#define WM_STATUSABORT                  5006
#define WM_STATUSSTART                  5007
#define WM_STATUSREADY                  5008
#define WM_STATUSREFRESHNOW             5009
#define WM_ADMIN_ADD_SERVER             5010
#define WM_ADMIN_REMOVE_SERVER          5011
#define WM_ADMIN_UPDATE_SERVER          5012
#define WM_ADMIN_ADD_WINSTATION         5013
#define WM_ADMIN_REMOVE_WINSTATION      5014
#define WM_ADMIN_UPDATE_WINSTATION      5015
#define WM_ADMIN_UPDATE_PROCESSES       5016
#define WM_ISFAVLISTEMPTY               5017
#define WM_ADMIN_REDISPLAY_PROCESSES    5019
#define WM_ADMIN_UPDATE_SERVER_INFO     5020
#define WM_ADMIN_REDISPLAY_LICENSES     5021
#define WM_ADMIN_UPDATE_WINSTATIONS     5022
#define WM_ADMIN_REMOVE_PROCESS         5023
#define WM_ADMIN_ADD_APPLICATION        5024
#define WM_ADMIN_COLLAPSETODOMAINS      5025
#define WM_ADMIN_UPDATE_DOMAIN          5026
#define WM_ADMIN_VIEWS_READY            5027
#define WM_ADMIN_COLLAPSETOAPPS         5028

#define WM_ADMIN_ADDSERVERTOFAV         5029
#define WM_ADMIN_REMOVESERVERFROMFAV    5030
#define WM_ADMIN_GOTO_SERVER            5031
#define WM_ADMIN_DELTREE_NODE           5032
#define WM_ADMIN_GET_TV_STATES          5033
#define WM_ADMIN_UPDATE_TVSTATE         5034
#define WM_ADMIN_ADD_DOMAIN             5035
#define WM_ADMIN_CONNECT_TO_SERVER      5036

#define IDM_REFRESH                     32771
#define IDM_CONNECT                     32772
#define IDM_DISCONNECT                  32773
#define IDM_MESSAGE                     32774
#define IDM_SHADOW                      32775
#define IDM_RESET                       32776
#define IDM_STATUS                      32777
#define IDM_LOGOFF                      32778
#define IDM_TERMINATE                   32779
#define IDM_EXPAND_ALL                  32780
#define IDM_PREFERENCES                 32799
#define IDM_COLLAPSE_ALL                32800
#define IDM_COLLAPSE_TOSERVERS          32801
#define IDM_SHOW_SYSTEM_PROCESSES       32803
#define IDM_COLLAPSE_TODOMAINS          32808

#define IDM_SERVER_ADDTOFAV             32809

#define IDM_SERVER_CONNECT              32810
#define IDM_SERVER_DISCONNECT           32811
#define IDTM_CONNECT                    32812
#define IDTM_DISCONNECT                 32813
#define IDTM_MESSAGE                    32814
#define IDTM_SHADOW                     32815
#define IDTM_RESET                      32816
#define IDTM_STATUS                     32817
#define IDTM_DOMAIN_CONNECT_ALL         32818
#define IDTM_DOMAIN_DISCONNECT_ALL      32819
#define IDTM_DOMAIN_FIND_SERVERS        32820
#define IDTM_ALLSERVERS_CONNECT         32821
#define IDTM_ALLSERVERS_DISCONNECT      32822
#define IDTM_ALLSERVERS_FIND            32823
#define IDM_ALLSERVERS_FIND             32824
#define IDM_ALLSERVERS_CONNECT          32825
#define IDM_ALLSERVERS_DISCONNECT       32826
#define IDM_DOMAIN_FIND_SERVERS         32829
#define IDM_DOMAIN_CONNECT_ALL          32830
#define IDM_DOMAIN_DISCONNECT_ALL       32831

#define IDTM_DOMAIN_FIND_SERVER         32832
#define IDM_ALLSERVERS_EMPTYFAVORITES   32833 

#define ID_CTRLTAB                      32834
#define ID_SHIFTTAB                     32835
#define ID_TAB                          32836
#define ID_CTRLSHIFTTAB                 32900
#define IDM_COLLAPSE_TOAPPS             33000
#define IDS_TREEROOT                    61204
#define IDS_TAB_PROPERTIES              61205
#define IDS_TAB_SECURITY                61206
#define IDS_TAB_CLIENT_SETTINGS         61207
#define IDS_TAB_WINSTATIONS             61208
#define IDS_TAB_PROCESSES               61209
#define IDS_TAB_INFO                    61210
#define IDS_TAB_INFORMATION             61210
#define IDS_COL_WINSTATION              61211
#define IDS_COL_USER                    61212
#define IDS_COL_ID                      61213
#define IDS_COL_TYPE                    61214
#define IDS_COL_COMMENT                 61215
#define IDS_COL_STATE                   61216
#define IDS_COL_IDLETIME                61217
#define IDS_COL_LOGONTIME               61218
#define IDS_TAB_SERVERS                 61219
#define IDS_TAB_USERS                   61220
#define IDS_TAB_LICENSES                61222
#define IDS_COL_CLIENT_NAME             61223
#define IDS_COL_LICENSE_NUMBER          61224
#define IDS_COL_LICENSE_DESC            61225
#define IDS_COL_LOCALCOUNT              61226
#define IDS_COL_USERCOUNT               61226
#define IDS_COL_POOLCOUNT               61227
#define IDS_COL_TOTALCOUNT              61228
#define IDS_COL_PID                     61229
#define IDS_COL_IMAGE                   61230
#define IDS_COL_FILENAME                61231
#define IDS_COL_FILEDATETIME            61232
#define IDS_COL_SIZE                    61233
#define IDS_COL_VERSIONS                61234
#define IDS_DEFAULT_MESSAGE_TITLE       61235
#define IDS_WARN_DISCONNECT             61236
#define IDS_WARN_RESET                  61237
#define IDS_WARN_LOGOFF                 61238
#define IDS_PWDDLG_USER                 61239
#define IDS_PWDDLG_WINSTATION           61240
#define IDS_REFRESH_RANGE               61241
#define IDS_DISCONNECTED                61242
#define IDS_COL_SERVER                  61243
#define IDS_IDLE                        61244
#define IDS_COL_TCPADDRESS              61248
#define IDS_COL_IPXADDRESS              61249
#define IDS_COL_NUM_WINSTATIONS         61250
#define IDS_SYSTEM_CONSOLE_NAME         61252
#define IDS_STATUS_FORMAT               61253
#define IDS_WARN_TERMINATE              61254
#define IDS_SERVER_DISAPPEARED          61255
#define IDS_COL_HOTFIX                  61256
#define IDS_COL_INSTALLED_BY            61257
#define IDS_COL_INSTALLED_ON            61258
#define IDS_CLIENT_CACHE                61259
#define IDS_CLIENT_RESOLUTION           61260
#define IDS_ERR_USER_LOGOFF             61261
#define IDS_ERR_MESSAGE                 61262
#define IDS_ERR_DISCONNECT              61263
#define IDS_ERR_RESET                   61264
#define IDS_ERR_CONNECT                 61265
#define IDS_ERR_SHADOW                  61266
#define IDS_ERR_SHADOW_DISABLED         61267
#define IDS_ERR_SHADOW_DISCONNECTED_NOTIFY_ON 61268
#define IDS_TAB_CACHE                   61269
#define IDS_NONE                        61270
#define IDS_MOREINFO                    61271
#define IDS_LESSINFO                    61272
#define IDS_NO_LOAD_LICENSE             61273
#define IDS_COL_LICENSE_REGISTERED      61274
#define IDS_YES                         61275
#define IDS_NO                          61276
#define IDS_NOT_APPLICABLE              61277
#define IDS_DEVICE                      61278
#define IDS_EMBEDDED                    61279
#define IDS_DISCONNECTING               61280
#define IDS_SHUTDOWN_BGTHREAD           61281
#define IDS_SHUTDOWN_PROCTHREAD         61282
#define IDS_SHUTDOWN_PREFS              61283
#define IDS_SHUTDOWN_NOTIFY             61284
#define IDS_DONE                        61285
#define IDS_LISTENER                    61286
#define IDS_NO_LICENSE_PRIVILEGES       61287
#define IDS_PRODUCT_VERSION             61288
#define IDS_NO_EXTENSION_DLL            61289
#define IDS_NOT_AUTHENTICATED           61295
#define IDS_GATHERING_SERVER_INFO       61296
#define IDS_LISTENER_MSG                61297
#define IDS_INACTIVE_MSG                61298
#define IDS_PUBLISHED_APPS              61299
#define IDS_COL_COMMAND_LINE            61300
#define IDS_COL_WORKING_DIR             61301
#define IDS_COL_TCP_LOAD                61302
#define IDS_COL_IPX_LOAD                61303
#define IDS_COL_NETBIOS_LOAD            61304
#define IDS_EXPLICIT                    61305
#define IDS_ANONYMOUS                   61306
#define IDS_COL_USER_GROUP              61307
#define IDS_COL_USER_TYPE               61308
#define IDS_SYSTEM_IDLE_PROCESS         61309
#define IDS_SHUTDOWN_DOMAINTHREADS      61310
#define IDS_DOMAIN_FINDING_SERVERS      61311
#define IDS_CLICK_TO_CONNECT            61312
#define IDS_UNLIMITED                   61313
#define IDS_COLLAPSE_TODOMAINS          61319
#define IDS_TAB_MODULES                 61321
#define IDS_BUFFERS_FORMAT              61322
#define IDS_ERROR_NOT_TS                61323
#define IDS_CANNOT_TERMINATE            61324
#define ID_HELP1                        61325
#define IDS_CONNQ                       61326
#define ID_ENTER                        61327
#define ID_NEXTPANE                     61328
#define ID_PREVPANE                     61329
#define IDS_THISCOMPUTER                61330
#define IDS_FAVSERVERS                  61333
#define IDM_SERVER_REMOVEFAV            61334
#define ID_DELKEY                       61335
#define IDS_DOMAIN_DBLCLK_MSG           61336
#define IDM_ALLSERVERS_FAVALLADD        61337
#define IDM_ALLSERVERS_RUNSTRESS        61338
#define IDM_ALLSERVERS_RUNSTRESSLITE    61339
#define IDS_EMPTYFOLDER                 61340




// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        215
#define _APS_NEXT_COMMAND_VALUE         32837
#define _APS_NEXT_CONTROL_VALUE         1097
#define _APS_NEXT_SYMED_VALUE           174
#endif
#endif


//
// MUI localized strings for
// start menu, etc. DO NOT CHANGE THESE VALUES
// without updating tsoc.inx
//
#define IDS_TSADMIN_STARTMENU_NAME                10000
#define IDS_TSADMIN_STARTMENU_TIP                 10001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\server.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* server.cpp
*
* implementation of the CServer class
*
*  
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"

#include "admindoc.h"
#include "dialogs.h"

#include <malloc.h>			// for alloca used by Unicode conversion macros
#include <afxconv.h>		// for Unicode conversion macros
static int _convert;

#include <winsta.h>
#include <regapi.h>
#include "..\..\inc\utilsub.h"

#include "procs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////////////////////////
//
//	CServer Member Functions
//
//////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CServer::CServer
//
// Constructor for the server class
CServer::CServer(CDomain *pDomain, TCHAR *name, BOOL bFoundLater, BOOL bConnect)
{
    ASSERT(name);

	m_ServerFlags = ULONG(0);
    m_pDomain = pDomain;
	if(bFoundLater) SetFoundLater();	
	//m_State = SS_NONE;
	m_PreviousState = SS_NONE;
	m_hTreeItem = NULL;
    m_hThisServer = NULL;
    m_hFavTree = NULL;
    m_pBackgroundThread = NULL;
    m_bThreadAlive = FALSE;
	m_pExtensionInfo = NULL;
	m_pExtServerInfo = NULL;
	m_pRegistryInfo = NULL;
    m_fManualFind = FALSE;

	// Don't call SetState because we don't want to send a message to the views
	m_State = SS_NOT_CONNECTED;

	// save off the server name
	wcscpy(m_Name, name);

	// Dummy up an ExtServerInfo structure
	// This is to make it easier for code that tries
	// to access this structure before the extension DLL
	// has provided it
	m_pExtServerInfo = ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetDefaultExtServerInfo();

	if(bConnect) Connect();

}	// end CServer::CServer


/////////////////////////////////////////////////////////////////////////////
// CServer::~CServer
//
// Destructor for the server class
CServer::~CServer()
{
	// Disconnect();   
    m_hTreeItem = NULL;
    m_hFavTree = NULL;
    m_hThisServer = NULL;

}	// end CServer::~CServer


/////////////////////////////////////////////////////////////////////////////
// CServer::RemoveWinStationProcesses
//
// remove all the processes for a given WinStation
void CServer::RemoveWinStationProcesses(CWinStation *pWinStation)
{
	ASSERT(pWinStation);

	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

	CObList TempList;

	LockProcessList();
	
	POSITION pos = m_ProcessList.GetHeadPosition();
	while(pos) {
		POSITION pos2 = pos;
		CProcess *pProcess = (CProcess*)m_ProcessList.GetNext(pos);
		if(pProcess->GetWinStation() == pWinStation) {
			// Add the process to our temporary list
			TempList.AddTail(pProcess);
			// Remove the process from the list of processes
			pProcess = (CProcess*)m_ProcessList.GetAt(pos2);
			m_ProcessList.RemoveAt(pos2);
		}
	}
			
	UnlockProcessList();
	
	pos = TempList.GetHeadPosition();
	while(pos) {
		POSITION pos2 = pos;

		CProcess *pProcess = (CProcess*)TempList.GetNext(pos);

		// Send a message to remove the Process from the view
		CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
		if(p && ::IsWindow(p->GetSafeHwnd())) {
			p->SendMessage(WM_ADMIN_REMOVE_PROCESS, 0, (LPARAM)pProcess);
		}
		delete pProcess;

	}

	TempList.RemoveAll();

}	// end CServer::RemoveWinStationProcesses


/////////////////////////////////////////////////////////////////////////////
// CServer::ClearAllSelected
//
// Clears the WAF_SELECTED bit in all of this server's lists
//
void CServer::ClearAllSelected()
{
	// Clear the WinStation list WAF_SELECTED flags
	// Iterate through the WinStation list
    LockWinStationList( );

	POSITION pos = m_WinStationList.GetHeadPosition();

	while(pos) {
		CWinStation *pWinStation = (CWinStation*)m_WinStationList.GetNext(pos);
		pWinStation->ClearSelected();
	}

    m_NumWinStationsSelected = 0;

    UnlockWinStationList( );

	
    LockProcessList();
	// Clear the Process list PF_SELECTED flags
	// Iterate through the Process list
	pos = m_ProcessList.GetHeadPosition();
	while(pos) {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetNext(pos);
		pProcess->ClearSelected();
	}

	m_NumProcessesSelected = 0;

    UnlockProcessList( );

}	// end CServer::ClearAllSelected


//Function - htol - start
//===========================================================================
//
//Description: converts a hex string to a uLONG, handles "0x..."
//
//
//Parameters:
//
//Return Value:
//
//Global Variables Affected:
//
//Remarks: (Side effects, Assumptions, Warnings...)
//
//
//---------------------------------------------------------------------------
WCHAR hextable[] = L"0123456789ABCDEF";

ULONG htol(WCHAR *hexString)
{
	ULONG retValue = 0L;

	// convert the string to upper case
	_wcsupr(hexString);

	WCHAR *p = hexString;

	while (*p == L' ')
		p++;

	while(*p)
	{
		if(*p == L'X')
		{
			retValue = 0L;
		} else if ((*p == L' ') || (*p == L'\n') || (*p == L'\r'))
			break;
		else if(*p == L'.') {
			// skip over a decimal point
		}
		else
		{
			retValue <<= 4;
			for(int i = 0; i < 16; i++)
			{
				if(hextable[i] == *p)
				{
					retValue += i;
					break;
				}
			}
		}
		*p++;
	}

	return retValue;
}


static TCHAR szMicrosoftKey[] = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion");
static TCHAR szInstallDate[] = TEXT("InstallDate");
static TCHAR szCSDVersion[] = TEXT("CSDVersion");
static TCHAR szCurrentVersion[] = TEXT("CurrentVersion");
static TCHAR szCurrentBuildNumber[] = TEXT("CurrentBuildNumber");
static TCHAR szCurrentProductName[] = TEXT("ProductName");
static TCHAR szHotfixKey[] = TEXT("HOTFIX");
static TCHAR szValid[] = TEXT("Valid");
static TCHAR szInstalledOn[] = TEXT("Installed On");
static TCHAR szInstalledBy[] = TEXT("Installed By");
#define REG_CONTROL_CITRIX	REG_CONTROL L"\\Citrix"

/////////////////////////////////////////////////////////////////////////////
// CServer::BuildRegistryInfo
//
// Go out and fill in the registry info structure
BOOL CServer::BuildRegistryInfo()
{
	DWORD dwType, dwSize;
	HKEY hKeyServer;
	HKEY hKey;

	if(!IsServerSane()) return FALSE;

	m_pRegistryInfo = new ServerRegistryInfo;
	if(!m_pRegistryInfo) return FALSE;
    memset(m_pRegistryInfo, 0, sizeof(ServerRegistryInfo));

	TCHAR Buffer[128];
	Buffer[0] = TEXT('\\');
	Buffer[1] = TEXT('\\');
	Buffer[2] = TEXT('\0');
	wcscpy(Buffer+2, m_Name);

    /*
     *  Connect to the server's registry
     *  (avoid using RPC when the server is the local machine.)
     */

    if(RegConnectRegistry(IsCurrentServer() ? NULL : Buffer, HKEY_LOCAL_MACHINE, &hKeyServer) != ERROR_SUCCESS)
        return FALSE;

    /*
     * Fetch MS information.
     */
	if(RegOpenKeyEx(hKeyServer, szMicrosoftKey, 0,	KEY_READ, &hKey) != ERROR_SUCCESS) {
		RegCloseKey(hKeyServer);
		return FALSE;
	}

	dwSize = sizeof(m_pRegistryInfo->InstallDate);
	if(RegQueryValueEx(hKey, szInstallDate, NULL, &dwType, (LPBYTE)&m_pRegistryInfo->InstallDate,
					&dwSize) != ERROR_SUCCESS) {
        m_pRegistryInfo->InstallDate = 0xFFFFFFFF;
	}

    // REMARK: we should check the returned codes for every RegQueryValueEx
	dwSize = sizeof(m_pRegistryInfo->ServicePackLevel);
	RegQueryValueEx(hKey, szCSDVersion, NULL, &dwType, (LPBYTE)&m_pRegistryInfo->ServicePackLevel, &dwSize);
	
	dwSize = sizeof(m_pRegistryInfo->MSVersion);
	RegQueryValueEx(hKey, szCurrentVersion, NULL, &dwType, (LPBYTE)&m_pRegistryInfo->MSVersion, &dwSize);
	
	m_pRegistryInfo->MSVersionNum = _wtol(m_pRegistryInfo->MSVersion);

	dwSize = sizeof(m_pRegistryInfo->MSBuild);
	RegQueryValueEx(hKey, szCurrentBuildNumber, NULL, &dwType, (LPBYTE)&m_pRegistryInfo->MSBuild, &dwSize);
	
	dwSize = sizeof(m_pRegistryInfo->MSProductName);
	RegQueryValueEx(hKey, szCurrentProductName, NULL, &dwType, (LPBYTE)&m_pRegistryInfo->MSProductName, &dwSize);
	
	HKEY hKeyHotfix;

	if(RegOpenKeyEx(hKey, szHotfixKey, 0, KEY_READ, &hKeyHotfix) == ERROR_SUCCESS) {
		DWORD Index = 0;
		FILETIME LastWriteTime;
		dwSize = sizeof(Buffer) / sizeof( TCHAR );
		while(RegEnumKeyEx(hKeyHotfix, Index, Buffer, &dwSize, NULL, NULL, NULL,
			&LastWriteTime) == ERROR_SUCCESS) {
			HKEY hKeySingleHotfix;
			if(RegOpenKeyEx(hKeyHotfix, Buffer, 0, KEY_READ, &hKeySingleHotfix) == ERROR_SUCCESS) {
				// Create a CHotFix object
				CHotfix *pHotfix = new CHotfix;

                if(pHotfix) {
				    // Copy the Hotfix name
				    // Get rid of the WF: if it's there
				    if(wcsncmp(Buffer, TEXT("WF:"), 3) == 0) {
					    wcscpy(pHotfix->m_Name, &Buffer[3]);
				    }
				    else wcscpy(pHotfix->m_Name, Buffer);

				    // Get the Valid entry
				    dwSize = sizeof(&pHotfix->m_Valid);
				    if(RegQueryValueEx(hKeySingleHotfix, szValid, NULL, &dwType, (LPBYTE)&pHotfix->m_Valid,
					    	&dwSize) != ERROR_SUCCESS) {
					    pHotfix->m_Valid = 0L;
				    }

				    // Get the Installed On entry			
				    dwSize = sizeof(&pHotfix->m_InstalledOn);
				    if(RegQueryValueEx(hKeySingleHotfix, szInstalledOn, NULL, &dwType, (LPBYTE)&pHotfix->m_InstalledOn,
					    	&dwSize) != ERROR_SUCCESS) {
					    pHotfix->m_InstalledOn = 0xFFFFFFFF;
				    }

				    // Get the Installed By entry
				    dwSize = sizeof(pHotfix->m_InstalledBy);
				    if(RegQueryValueEx(hKeySingleHotfix, szInstalledBy, NULL, &dwType, (LPBYTE)pHotfix->m_InstalledBy,
					    	&dwSize) != ERROR_SUCCESS) {
					    pHotfix->m_InstalledBy[0] = '\0';
				    }

				    pHotfix->m_pServer = this;

				    m_HotfixList.AddTail(pHotfix);

				    RegCloseKey(hKeySingleHotfix);
			    }
            }

		    dwSize = sizeof(Buffer) / sizeof( TCHAR );
			Index++;
		}

		RegCloseKey(hKeyHotfix);
	}

	RegCloseKey(hKey);

    if (m_pRegistryInfo->MSVersionNum < 5)   // only for TS 4.0
    {
        /*
         * Fetch Citrix information.
         */
	    // Look in the new location
	    LONG result = RegOpenKeyEx(hKeyServer, REG_CONTROL_TSERVER, 0, KEY_READ, &hKey);

	    if(result != ERROR_SUCCESS) {
		    // Look in the old location
		    result = RegOpenKeyEx(hKeyServer, REG_CONTROL_CITRIX, 0, KEY_READ, &hKey);	
	    }

	    if(result != ERROR_SUCCESS) {
	        RegCloseKey(hKeyServer);
		    return FALSE;
	    }

	    dwSize = sizeof(m_pRegistryInfo->CTXProductName);
	    RegQueryValueEx(hKey, REG_CITRIX_PRODUCTNAME, NULL, &dwType, (LPBYTE)m_pRegistryInfo->CTXProductName, &dwSize);
	
	    dwSize = sizeof(m_pRegistryInfo->CTXVersion);
	    RegQueryValueEx(hKey, REG_CITRIX_PRODUCTVERSION, NULL, &dwType, (LPBYTE)m_pRegistryInfo->CTXVersion, &dwSize);

	    m_pRegistryInfo->CTXVersionNum = htol(m_pRegistryInfo->CTXVersion);

	    dwSize = sizeof(m_pRegistryInfo->CTXBuild);
	    RegQueryValueEx(hKey, REG_CITRIX_PRODUCTBUILD, NULL, &dwType, (LPBYTE)m_pRegistryInfo->CTXBuild, &dwSize);

        RegCloseKey(hKey);

    }
    else    // for NT 5.0 and beyond, do not query the registry
    {
        //REMARK: we should get rid of all this.
        wcscpy(m_pRegistryInfo->CTXProductName, m_pRegistryInfo->MSProductName);
        wcscpy(m_pRegistryInfo->CTXVersion, m_pRegistryInfo->MSVersion);
    	m_pRegistryInfo->CTXVersionNum = m_pRegistryInfo->MSVersionNum;
        wcscpy(m_pRegistryInfo->CTXBuild, m_pRegistryInfo->MSBuild);
    }

	RegCloseKey(hKeyServer);

	// Set the flag to say the info is valid
	SetRegistryInfoValid();

	return TRUE;

}	// end CServer::BuildRegistryInfo

/////////////////////////////////////////////////////////////////////////////
// CServer::AddWinStation
//
// Add a WinStation to the Server's WinStationList in
// sorted order
// NOTE: The list should be NOT be locked by the caller
//
void CServer::AddWinStation(CWinStation *pNewWinStation)
{
    ASSERT(pNewWinStation);

	LockWinStationList();

    ODS( L"CServer!AddWinStation\n" );

	BOOLEAN bAdded = FALSE;
	POSITION pos, oldpos;
	int Index;

	// Traverse the WinStationList and insert this new WinStation,
	// keeping the list sorted by Sort Order, then Protocol.
    for(Index = 0, pos = m_WinStationList.GetHeadPosition(); pos != NULL; Index++) {
        oldpos = pos;
        CWinStation *pWinStation = (CWinStation*)m_WinStationList.GetNext(pos);

        if((pWinStation->GetSortOrder() > pNewWinStation->GetSortOrder())
			|| ((pWinStation->GetSortOrder() == pNewWinStation->GetSortOrder()) &&
			(pWinStation->GetSdClass() > pNewWinStation->GetSdClass()))) {
            // The new object belongs before the current list object.
            m_WinStationList.InsertBefore(oldpos, pNewWinStation);
			bAdded = TRUE;
            break;
        }
    }

    // If we haven't yet added the WinStation, add it now to the tail
    // of the list.
    if(!bAdded) {
        m_WinStationList.AddTail(pNewWinStation);
	}

	UnlockWinStationList();

}  // end CServer::AddWinStation


/////////////////////////////////////////////////////////////////////////////
// CServer::Connect
//
// Connect to the server
//
BOOL CServer::Connect()
{	
    m_NumProcessesSelected = 0;
    m_NumWinStationsSelected = 0;
    m_pExtServerInfo = NULL;
    BOOL bResult = FALSE;
    
    if(m_State != SS_NOT_CONNECTED )
    {        
        return FALSE;
    }
    
    // Fire off the background thread for this server 
    LockThreadAlive();
    if(m_pBackgroundThread == NULL) 
    {        
        ServerProcInfo *pProcInfo = new ServerProcInfo;
        if(pProcInfo)
        {
            pProcInfo->pServer = this;
            pProcInfo->pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
            m_BackgroundContinue = TRUE;
            m_bThreadAlive = FALSE;
            m_pBackgroundThread = AfxBeginThread((AFX_THREADPROC)CServer::BackgroundThreadProc, 
                pProcInfo,
                THREAD_PRIORITY_NORMAL,
                0,
                CREATE_SUSPENDED,
                NULL
                );
            
            if( m_pBackgroundThread == NULL )
            {
                ODS( L"CServer!Connect possibly low resources no thread created\n" );
                
                delete pProcInfo;
                
                return FALSE;
            }
            m_pBackgroundThread->m_bAutoDelete = FALSE;
            if (m_pBackgroundThread->ResumeThread() <= 1)
            {
                bResult = TRUE;
            }
        }
    }   
    
    UnlockThreadAlive();
    
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CServer::Disconnect
//
// Disconnect from the server
//
void CServer::Disconnect()
{
    // not a good idea for an ods

    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

	SetState(SS_DISCONNECTING);

	// If there is an extension DLL, let it cleanup anything it added to this Server
	LPFNEXSERVERCLEANUPPROC CleanupProc = ((CWinAdminApp*)AfxGetApp())->GetExtServerCleanupProc();
	if(CleanupProc && m_pExtensionInfo) {
		(*CleanupProc)(m_pExtensionInfo);
		m_pExtensionInfo = NULL;
	}

	// Tell the background thread to terminate and
	// wait for it to do so.

    LockThreadAlive();

	ClearBackgroundContinue();

    if( !m_pBackgroundThread )
    {
        // Either there is no background thread at all,
        // or some other thread is taking care of terminating it.
        // Just do nothing.

        //ODS( L"TSADMIN:CServer::Disconnect UnlockThreadAlive\n" );

        UnlockThreadAlive();
    }
    else
    {
	    if( m_bThreadAlive )
        {
            // the thread is alive. Tell him to exit.

            // keep temporary pointer and handle
            CWinThread *pBackgroundThread = m_pBackgroundThread;

            HANDLE hThread = m_pBackgroundThread->m_hThread;

            // Clear the pointer before releasing the lock
	        m_pBackgroundThread = NULL;

			// Give the thread a chance to exit
			UnlockThreadAlive();


			// Force him out of waiting for an event if he is		
			ULONG WSEventFlags;

			if(IsHandleGood())
            {
                ODS( L"TSADMIN:CServer::Disconnect Handle is good flush events\n" );

                WinStationWaitSystemEvent(m_Handle, WEVENT_FLUSH, &WSEventFlags);
            }

            if( hThread )    // It should always be TRUE
            {
			    // If this server object is waiting for RPC to timeout,
			    // just kill the thread
			    if( m_PreviousState == SS_NOT_CONNECTED )
                {
                    ODS( L"TSADMIN:CServer::Disconnect Previous state not connected termthread\n" );

				    if( WaitForSingleObject( hThread , 100 ) == WAIT_TIMEOUT )
                    {
					    TerminateThread(hThread, 0);
				    }
			    }
		    
			    // For all other threads, wait a second and then kill it
			    else if( WaitForSingleObject( hThread , 1000 ) == WAIT_TIMEOUT )
                {
                    ODS( L"TSADMIN CServer!Disconnect prevstate was !not_connected termthread\n" );

				    TerminateThread(hThread, 0);
			    }

			    WaitForSingleObject(hThread, INFINITE);
            }
            else
            {
                ASSERT(FALSE);
            }

            // delete the CWinThread object 

            ODS( L"TSADMIN:CServer::Disconnect delete CWinThread Object m_bThread == TRUE\n" );
            delete pBackgroundThread;    
	    }
        else
        {
            // the thread is dead or will be dead very soon. Just do the cleanup.
            ODS( L"TSADMIN:CServer::Disconnect delete CWinThread Object m_bThread == FALSE\n" );
            delete m_pBackgroundThread;     
	        m_pBackgroundThread = NULL;
			UnlockThreadAlive();

        }
    }

	if(IsHandleGood())
    { 
        ODS( L"TSADMIN:CServer::Disconnect WinStationCloseServer\n" );
		WinStationCloseServer(m_Handle);
		m_Handle = NULL;
	}

    LockWinStationList();

    CObList TempList;

	// Iterate through the WinStation list
	// Move all the WinStations to a temporary list so that
	// we don't have to have the WinStationList locked while
	// sending the WM_ADMIN_REMOVE_WINSTATION message to the views.

	POSITION pos = m_WinStationList.GetHeadPosition();

	while(pos)
    {
		CWinStation *pWinStation = (CWinStation*)m_WinStationList.GetNext(pos);
        TempList.AddTail(pWinStation);		
	}

	m_WinStationList.RemoveAll();

    UnlockWinStationList();
	
    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

    pos = TempList.GetHeadPosition();

    while(pos)
    {
        CWinStation *pWinStation = (CWinStation*)TempList.GetNext(pos);

		if(p && ::IsWindow(p->GetSafeHwnd()))
        { 
            ODS( L"TSADMIN:CServer::Disconnect Remove WinStation\n" );
			p->SendMessage(WM_ADMIN_REMOVE_WINSTATION, 0, (LPARAM)pWinStation);		
		}

		delete pWinStation;
    }

    TempList.RemoveAll();

	LockProcessList();

	pos = m_ProcessList.GetHeadPosition();

	while(pos)
    {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetNext(pos);

        ODS( L"TSADMIN:CServer::Disconnect Delete process\n" );

		delete pProcess;
	}

	m_ProcessList.RemoveAll();
	
    UnlockProcessList();

	LockLicenseList();
	
    pos = m_LicenseList.GetHeadPosition();

	while(pos)
    {
		CLicense *pLicense = (CLicense*)m_LicenseList.GetNext(pos);

        ODS( L"TSADMIN:CServer::Disconnect remove license\n" );

		delete pLicense;
	}

	m_LicenseList.RemoveAll();
	
    UnlockLicenseList();

    //
	
    pos = m_UserSidList.GetHeadPosition();

	while(pos)
    {
		CUserSid *pUserSid = (CUserSid*)m_UserSidList.GetNext(pos);

        ODS( L"TSADMIN:CServer::Disconnect remove sids\n" );

		delete pUserSid;
	}

	m_UserSidList.RemoveAll();

	pos = m_HotfixList.GetHeadPosition();

	while(pos)
    {
		CHotfix *pHotfix = (CHotfix*)m_HotfixList.GetNext(pos);

        ODS( L"TSADMIN:CServer::Disconnect Remove hotfixes\n" );

		delete pHotfix;
	}

	m_HotfixList.RemoveAll();

	if( m_pRegistryInfo )
    {
		delete m_pRegistryInfo;

        ODS( L"TSADMIN:CServer::Disconnect delete reginfo\n" );

		m_pRegistryInfo = NULL;
	}
    
    // ODS( L"TSADMIN:CServer::Disconnect Set state not connected\n" );

	SetState(SS_NOT_CONNECTED);
}

/////////////////////////////////////////////////////////////////////////////
// CServer::DoDetail
//
// Go get detailed information about this server
//
void CServer::DoDetail()
{
	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

	SetState(SS_GETTING_INFO);

	ULONG Entries;
	PLOGONID pLogonId;

	if(!ShouldBackgroundContinue()) return;

    // We need to access the registry information for the server
    // at this time because we must not administer WF 2.00 servers
    // (RPC structures are incompatible).  If we cannot access the
    // server's registry, or the multi-user version is 2.00, we bail
    // from this server.
    if ( !BuildRegistryInfo() || (GetCTXVersionNum() == 0x200) || (GetCTXVersionNum() == 0) )
    {
		ClearHandleGood();
		SetLostConnection();
		SetState(SS_BAD);

        ODS( L"CServer::DoDetail - Setting to lost connection\n" );

		CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();
		if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd())) pFrameWnd->SendMessage(WM_ADMIN_REMOVE_SERVER, 0, (LPARAM)this);
		ClearBackgroundContinue();
		return;
    }

	// Find all the WinStations
    BOOL fWinEnum;

    fWinEnum = WinStationEnumerate(m_Handle, &pLogonId, &Entries);

    DBGMSG( L"CServer!DoDetail WinEnum last reported error 0x%x\n", GetLastError( ) );

	if(!fWinEnum )
    {
        
		ClearHandleGood();
		SetLostConnection();
		SetState(SS_BAD);
		ClearBackgroundContinue();
		return;
	}

	if(!ShouldBackgroundContinue()) {
		if(pLogonId) WinStationFreeMemory(pLogonId);
		return;
	}

	// Get information about the WinStations
	if(pLogonId)
    {
		for(ULONG i = 0; i < Entries; i++)
        {
            // Create a new WinStation object
			CWinStation *pWinStation = new CWinStation(this, &pLogonId[i]);
            if(pWinStation)
            {
                // If the queries weren't successful, ignore this WinStation
			    if(!pWinStation->QueriesSuccessful())
                {
                    ODS( L"CServer::DoDetail!QueriesSuccessful failed\n" );
    				delete pWinStation;
	    		}
                else
                {
		    		AddWinStation(pWinStation);
			    	pWinStation->SetNew();
			    }
            }

			if( !ShouldBackgroundContinue() )
            {
				if(pLogonId) WinStationFreeMemory(pLogonId);
				return;
			}
		}

		WinStationFreeMemory(pLogonId);
	}

	if(!ShouldBackgroundContinue()) return;

	// If there is an extension DLL loaded, allow it to add it's own info for this Server
	LPFNEXSERVERINITPROC InitProc = ((CWinAdminApp*)AfxGetApp())->GetExtServerInitProc();
	if(InitProc) {
		m_pExtensionInfo = (*InitProc)(m_Name, m_Handle);
      if(m_pExtensionInfo) {
         LPFNEXGETSERVERINFOPROC GetInfoProc = ((CWinAdminApp*)AfxGetApp())->GetExtGetServerInfoProc();
         if(GetInfoProc) {
            m_pExtServerInfo = (*GetInfoProc)(m_pExtensionInfo);
			// If this server is running WinFrame or Picasso, set flag
			if(m_pExtServerInfo->Flags & ESF_WINFRAME) SetWinFrame();
         }
      }
	}

	QueryLicenses();

	SetState(SS_GOOD);

	// Send a message to the views to tell it the state of this
	// server has changed
	CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
	if(p && ::IsWindow(p->GetSafeHwnd())) { 
		p->SendMessage(WM_ADMIN_UPDATE_SERVER_INFO, 0, (LPARAM)this);
		p->SendMessage(WM_ADMIN_UPDATE_WINSTATIONS, 0, (LPARAM)this);
	}

}  // end CServer::DoDetail


/////////////////////////////////////////////////////////////////////////////
// CServer::FindProcessByPID
//
// returns a pointer to a CProcess from m_ProcessList given a PID
CProcess* CServer::FindProcessByPID(ULONG Pid)
{
	LockProcessList();
		
	POSITION pos = m_ProcessList.GetHeadPosition();
			
	while(pos) {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetNext(pos);
		if(pProcess->GetPID() == Pid) {
			UnlockProcessList();
			return pProcess;
		}
	}

	UnlockProcessList();

	return NULL;

}	// end CServer::FindProcessByPID


/////////////////////////////////////////////////////////////////////////////
// CServer::EnumerateProcesses
//
// Enumerate this server's processes
BOOL CServer::EnumerateProcesses()
{
    ENUMTOKEN EnumToken;
	ULONG PID;
	ULONG LogonId;
	TCHAR ImageName[MAX_PROCESSNAME+1];
	PSID pSID;
    
    EnumToken.Current = 0;
    EnumToken.NumberOfProcesses = 0;
    EnumToken.ProcessArray = NULL;
    EnumToken.bGAP = TRUE;

	if(!IsHandleGood()) return 0;

	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
	
	LockProcessList();

	// Loop processes through and turn off current flag and new flag
	// Delete any processes that aren't current
	POSITION pos = m_ProcessList.GetHeadPosition();
	while(pos) {
		POSITION pos2 = pos;
		CProcess *pProcess = (CProcess*)m_ProcessList.GetNext(pos);
		if(!pProcess->IsCurrent()) {
			pProcess = (CProcess*)m_ProcessList.GetAt(pos2);
			m_ProcessList.RemoveAt(pos2);
			delete pProcess;
		} else {
			pProcess->ClearCurrent();
			pProcess->ClearNew();
			pProcess->ClearChanged();	// !
		}
	}

	UnlockProcessList();

	// Should we quit?
	if(!pDoc->ShouldProcessContinue()) {
		return FALSE;
	}

	while(ProcEnumerateProcesses(m_Handle,  
                                 &EnumToken, 
                                 ImageName,
                                 &LogonId, 
                                 &PID, 
                                 &pSID )) {

		CProcess *pProcess = new CProcess(PID, 
                                          LogonId, 
                                          this,
										  pSID, 
                                          FindWinStationById(LogonId), 
                                          ImageName);
        
        if(pProcess) {                                        
		    // If this process is in the list, we need to see if it has changed
		    CProcess *pOldProcess = FindProcessByPID(PID);
		    if(pOldProcess && pProcess->GetWinStation()) {
			    // Flag the process as current
			    pOldProcess->SetCurrent();
			    // Update any info that has changed
			    pOldProcess->Update(pProcess);
			    // We don't need this process object anymore
			    delete pProcess;
		    }
		    // It is a new process, add it to the list
		    else if(pProcess->GetWinStation()) { 
			    pProcess->SetNew();
			    LockProcessList();
			    m_ProcessList.AddTail(pProcess);
			    UnlockProcessList();
		    }
		    // This process doesn't have a WinStation, delete it
		    else {
			    delete pProcess;
		    }
        }

		// Should we quit?
		if(!pDoc->ShouldProcessContinue()) {
			// We have to call this one last time with an offset of -1 to
			// make the function free up the memory allocated by the client side stub.

			EnumToken.Current = (ULONG)-1;
			ProcEnumerateProcesses(m_Handle,  
                                   &EnumToken, 
                                   ImageName,
                                   &LogonId, 
                                   &PID, 
                                   &pSID );

			return FALSE;
		}
	}

	return TRUE;

}	// end CServer::EnumerateProcesses


/////////////////////////////////////////////////////////////////////////////
// CServer::ClearProcesses
//
// Clear out the list of processes
void CServer::ClearProcesses()
{
	LockProcessList();
	POSITION pos = m_ProcessList.GetHeadPosition();

	while(pos) {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetNext(pos);
		delete pProcess;
	}

	m_ProcessList.RemoveAll();
	UnlockProcessList();

}	// end CServer::ClearProcesses


/////////////////////////////////////////////////////////////////////////////
// CServer::FindWinStationById
//
CWinStation* CServer::FindWinStationById(ULONG Id)
{
	LockWinStationList();
		
	POSITION pos = m_WinStationList.GetHeadPosition();
			
	while(pos) {
		CWinStation *pWinStation = (CWinStation*)m_WinStationList.GetNext(pos);
		if(pWinStation->GetLogonId() == Id) {
			UnlockWinStationList();
			return pWinStation;
		}
	}

	UnlockWinStationList();

	return NULL;

}	// end CServer::FindWinStationById


/////////////////////////////////////////////////////////////////////////////
// CServer::BackgroundThreadProc
//
UINT CServer::BackgroundThreadProc(LPVOID pParam)
{
	ASSERT(pParam);
    ODS( L"CServer::BackgroundThreadProc\n" );

	// We need a pointer to the document so we can make
	// calls to member functions
	CWinAdminDoc *pDoc = (CWinAdminDoc*)((ServerProcInfo*)pParam)->pDoc;
	CServer *pServer = ((ServerProcInfo*)pParam)->pServer;

	HANDLE hServer;

	delete (ServerProcInfo*)pParam;

	// Make sure we don't have to quit
    if(!pServer->ShouldBackgroundContinue()) {
        return 0;
    }

	pServer->SetThreadAlive();

    // In case the server is disconnected we wait uselessly here

	while(!pDoc->AreAllViewsReady()) Sleep(500);    

	// Make sure we don't have to quit
    if(!pServer->ShouldBackgroundContinue())
    {
		pServer->ClearThreadAlive();
        return 0;
    }

	if(!pServer->IsCurrentServer())
    {
		// open the server and save the handle
		hServer = WinStationOpenServer(pServer->GetName());
		pServer->SetHandle(hServer);
		// Make sure we don't have to quit
        if(!pServer->ShouldBackgroundContinue())
        {
			pServer->ClearThreadAlive();

            return 0;
        }
		if(hServer == NULL)
        {
			DWORD Error = GetLastError();

            DBGMSG( L"CServer!BackgroundThreadProc WinStationOpenServer failed with 0x%x\n", Error );

			if(Error == RPC_S_SERVER_UNAVAILABLE)
            {
				pServer->ClearBackgroundFound();

				pServer->SetLostConnection();

                pServer->ClearManualFind( );
				
                CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

                

				if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
                {
                    ODS( L"Server backgrnd thread declares this server RPC_S_SERVER_UNAVAILABLE\n" );
                    pFrameWnd->SendMessage(WM_ADMIN_REMOVE_SERVER, 0, (LPARAM)pServer);

                    if( pServer->GetTreeItemFromFav() != NULL )
                    {
                        pFrameWnd->SendMessage( WM_ADMIN_REMOVESERVERFROMFAV , 0 , ( LPARAM )pServer );
                    }
                }
			}
            else
            {
				pServer->SetState(SS_BAD);
			}

			pServer->ClearThreadAlive();

            

			return 0;
		}

		pServer->SetHandleGood();
		pServer->SetState(SS_OPENED);
		
	}
    else
    {
		hServer = SERVERNAME_CURRENT;
		pServer->SetHandle(SERVERNAME_CURRENT);
		pServer->SetHandleGood();
		pServer->SetState(SS_OPENED);
	}

    
	// Make sure we don't have to quit
	if(!pServer->ShouldBackgroundContinue()) {
		pServer->ClearThreadAlive();
		return 0;
	}

	// If we found this server after initial enum,
	// we need to add it to the views now

    CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

	if(pServer->WasFoundLater())
    {        
        if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
        {
            pFrameWnd->SendMessage(WM_ADMIN_ADD_SERVER, ( WPARAM )TVI_SORT, (LPARAM)pServer);
        }
    }
    
	// Make sure we don't have to quit
	if(!pServer->ShouldBackgroundContinue()) {
		pServer->ClearThreadAlive();
		return 0;
	}
	
	pServer->DoDetail();
	
	// Now go into our loop waiting for WinStation Events
	while(1) {
		ULONG WSEventFlags;
		ULONG Entries;
		PLOGONID pLogonId;

		// Make sure we don't have to quit
		if(!pServer->ShouldBackgroundContinue()) {
			pServer->ClearThreadAlive();
			return 0;
		}

		// Wait for the browser to tell us something happened
        
		if(!WinStationWaitSystemEvent(hServer, WEVENT_ALL, &WSEventFlags))
        {
			if(GetLastError() != ERROR_OPERATION_ABORTED)
            {
                ODS( L"CServer::BackgroundThreadProc ERROR_OPERATION_ABORTED\n" );
				pServer->ClearHandleGood();
				pServer->SetState(SS_BAD);
				pServer->SetLostConnection();
				pServer->ClearThreadAlive();
                pServer->ClearManualFind( );
				return 1;
			}
		}

        ODS( L"CServer::BackgroundThreadProc -- some system event has taken place\n" );

		// Make sure we don't have to quit
		if(!pServer->ShouldBackgroundContinue()) {
			pServer->ClearThreadAlive();
            ODS( L"CServer::BackgroundThreadProc -* backgrnd thread should not continue\n" );
			return 0;
		}

		// Loop through this Server's WinStations and clear the current flag
		pServer->LockWinStationList();
		CObList *pWinStationList = pServer->GetWinStationList();
		POSITION pos = pWinStationList->GetHeadPosition();
		while(pos) {
			CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
			pWinStation->ClearCurrent();
			pWinStation->ClearNew();
			pWinStation->ClearChanged();
		}
		
		pServer->UnlockWinStationList();

		// Find all the WinStations
        BOOL fWinEnum = WinStationEnumerate(hServer, &pLogonId, &Entries);

        DBGMSG( L"CServer!BackgroundThread WinEnum last reported error 0x%x\n", GetLastError( ) );

		if(!fWinEnum )
        {
            ODS( L"CServer!BackgroundThread -- server is no longer valid\n" );

			pServer->ClearHandleGood();

			pServer->SetLostConnection();
			pServer->SetState(SS_BAD);
			pServer->ClearThreadAlive();
            pServer->ClearManualFind( );
			return 1;
		}
		
		// Make sure we don't have to quit
		if(!pServer->ShouldBackgroundContinue()) {
			if(pLogonId) WinStationFreeMemory(pLogonId);
			pServer->ClearThreadAlive();
            ODS( L"CServer!BackgroundThreadProc -# backgrnd thread should not continue\n" );
			return 0;
		}

		if(pLogonId)
        {
            // Get information about the WinStations
			for(ULONG i = 0; i < Entries; i++)
            {
                // Look for this WinStation in the list
				CWinStation *pWinStation = pServer->FindWinStationById(pLogonId[i].LogonId);
				if(pWinStation)
                {
                    // Mark this WinStation as current
					pWinStation->SetCurrent();

					// We found the WinStation in the list
					// Create a new CWinStation object - he will get his information
					CWinStation *pTempWinStation = new CWinStation(pServer, &pLogonId[i]);

                    if(pTempWinStation)
                    {
                        // If any information has changed, send a message to update the views
					    if(pWinStation->Update(pTempWinStation))
                        {
                            CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

	    					if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
                            {
                                pFrameWnd->SendMessage(WM_ADMIN_UPDATE_WINSTATION, 0, (LPARAM)pWinStation);
                            }

		    			}

			    		// We don't need the temporary CWinStation object anymore
				    	delete pTempWinStation;
                    }
				}
                else
                {
                    // We didn't find it in our list
					// We don't want to add it to our list if the WinStation is down
					if(pLogonId[i].State != State_Down && pLogonId[i].State != State_Init)
                    {
                        // Create a new CWinStation object
						CWinStation *pNewWinStation = new CWinStation(pServer, &pLogonId[i]);
                        if(pNewWinStation)
                        {
                            pServer->AddWinStation(pNewWinStation);
						    pNewWinStation->SetNew();
						    CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

						    if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
                            {
                                pFrameWnd->SendMessage(WM_ADMIN_ADD_WINSTATION, 0, (LPARAM)pNewWinStation);
                            }

                        }
				    }
				}
			}

			WinStationFreeMemory(pLogonId);

			// Send a message to the views to update their WinStations
			CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

			if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
            {
                pFrameWnd->SendMessage(WM_ADMIN_UPDATE_WINSTATIONS, 0, (LPARAM)pServer);
            }


			// Loop through the WinStations for this server and move
			// any that aren't current to a temporary list
			CObList TempList;

			pServer->LockWinStationList();
			CObList *pWinStationList = pServer->GetWinStationList();
			POSITION pos = pWinStationList->GetHeadPosition();
			while(pos)
            {
				POSITION pos2 = pos;
				CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
				if(!pWinStation->IsCurrent())
                {
					// Add the WinStation to our temporary list
					TempList.AddTail(pWinStation);
					// Remove the WinStation from the list of WinStations
					pWinStation = (CWinStation*)pWinStationList->GetAt(pos2);
					pWinStationList->RemoveAt(pos2);
				}
			}
			
			pServer->UnlockWinStationList();

			pos = TempList.GetHeadPosition();
			while(pos)
            {
				POSITION pos2 = pos;

				CWinStation *pWinStation = (CWinStation*)TempList.GetNext(pos);

				// Send a message to remove the WinStation from the tree view
				CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

                if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
                {
					pFrameWnd->SendMessage(WM_ADMIN_REMOVE_WINSTATION, 0, (LPARAM)pWinStation);
				}
		
				delete pWinStation;
			}

			TempList.RemoveAll();

		}  // end if(pLogonId)

		// If there is an extension DLL loaded, allow it to update info for this Server
		LPFNEXSERVEREVENTPROC EventProc = ((CWinAdminApp*)AfxGetApp())->GetExtServerEventProc();
		if(EventProc) {
			// Returns TRUE if anything changed
			if((*EventProc)(pServer->GetExtensionInfo(), WSEventFlags)) {
				pServer->QueryLicenses();

				CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

				if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
                {
                    pFrameWnd->SendMessage(WM_ADMIN_REDISPLAY_LICENSES, 0, (LPARAM)pServer);
                }

			}
		}

		// Tell the Server view to show the new load and license counts
		CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

		if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd())) 
        {
            pFrameWnd->SendMessage(WM_ADMIN_UPDATE_SERVER_INFO, 0, (LPARAM)pServer);
        }

		// Make sure we don't have to quit
		if(!pServer->ShouldBackgroundContinue())
        {
			pServer->ClearThreadAlive();
            ODS( L"CServer::BackgroundThreadProc -@ backgrnd thread should not continue\n" );
			return 0;
		}

	}  // end while(1)

}	// end CServer::BackgroundThreadProc


/////////////////////////////////////////////////////////////////////////////
// CServer::QueryLicenses
//
void CServer::QueryLicenses()
{
	ULONG NumLicenses;
	ExtLicenseInfo *pExtLicenseInfo = NULL;

	// If there is an extension DLL loaded, get this server's list of licenses
	LPFNEXGETSERVERLICENSESPROC LicenseProc = ((CWinAdminApp*)AfxGetApp())->GetExtGetServerLicensesProc();
	if(LicenseProc && m_pExtensionInfo) {

		LockLicenseList();

		// Iterate through the License list
		POSITION pos = m_LicenseList.GetHeadPosition();

		while(pos) {
			CLicense *pLicense = (CLicense*)m_LicenseList.GetNext(pos);
			delete pLicense;
		}
	
		m_LicenseList.RemoveAll();

		UnlockLicenseList();

		pExtLicenseInfo = (*LicenseProc)(m_pExtensionInfo, &NumLicenses);
		
		if(pExtLicenseInfo) {
			ExtLicenseInfo *pExtLicense = pExtLicenseInfo;

			for(ULONG lic = 0; lic < NumLicenses; lic++) {
				CLicense *pLicense = new CLicense(this, pExtLicense);
                if(pLicense) {
				    AddLicense(pLicense);
                }
			    pExtLicense++;
                
			}
	
			// Get the extension DLL's function to free the license info
			LPFNEXFREESERVERLICENSESPROC LicenseFreeProc = ((CWinAdminApp*)AfxGetApp())->GetExtFreeServerLicensesProc();
			if(LicenseFreeProc) {
				(*LicenseFreeProc)(pExtLicenseInfo);
			} else {
				TRACE0("WAExGetServerLicenses exists without WAExFreeServerLicenseInfo\n");
				ASSERT(0);
			}
		}
	}

}	// end CServer::QueryLicenses


/////////////////////////////////////////////////////////////////////////////
// CServer::AddLicense
//
// Add a License to the Server's LicenseList in
// sorted order
// NOTE: The list should be NOT be locked by the caller
//
void CServer::AddLicense(CLicense *pNewLicense)
{
    ASSERT(pNewLicense);

	LockLicenseList();

	BOOLEAN bAdded = FALSE;
	POSITION pos, oldpos;
	int Index;

	// Traverse the LicenseList and insert this new License,
	// keeping the list sorted by Class, then Name.
    for(Index = 0, pos = m_LicenseList.GetHeadPosition(); pos != NULL; Index++) {
        oldpos = pos;
        CLicense *pLicense = (CLicense*)m_LicenseList.GetNext(pos);

        if((pLicense->GetClass() > pNewLicense->GetClass())
			|| ((pLicense->GetClass() == pNewLicense->GetClass()) &&
            lstrcmpi(pLicense->GetSerialNumber(), pNewLicense->GetSerialNumber()) > 0)) {

            // The new object belongs before the current list object.
            m_LicenseList.InsertBefore(oldpos, pNewLicense);
			bAdded = TRUE;
            break;
        }
    }

    // If we haven't yet added the License, add it now to the tail
    // of the list.
    if(!bAdded) {
        m_LicenseList.AddTail(pNewLicense);
	}

	UnlockLicenseList();

}  // end CServer::AddLicense


/////////////////////////////////////////////////////////////////////////////
// CServer::SetState
//
void CServer::SetState(SERVER_STATE State)
{
	m_PreviousState = m_State; 

	m_State = State;

	if(m_State != m_PreviousState)
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

		CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();
                
		if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
        {
            pFrameWnd->SendMessage(WM_ADMIN_UPDATE_SERVER, 0, (LPARAM)this);
        }
	}

}	// end CServer::SetState
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\servervw.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* servervw.cpp
*
* implementation of the CServerView class
*
*
*******************************************************************************/

#include "stdafx.h"
#include "resource.h"
#include "servervw.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////
// MESSAGE MAP: CServerView
//
IMPLEMENT_DYNCREATE(CServerView, CView)

BEGIN_MESSAGE_MAP(CServerView, CView)
	//{{AFX_MSG_MAP(CServerView)
	ON_WM_SIZE()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_ADMIN_UPDATE_PROCESSES, OnAdminUpdateProcesses)
	ON_NOTIFY(TCN_SELCHANGE, IDC_SERVER_TABS, OnTabSelChange)
	ON_MESSAGE(WM_ADMIN_REMOVE_PROCESS, OnAdminRemoveProcess)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_PROCESSES, OnAdminRedisplayProcesses)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER_INFO, OnAdminUpdateServerInfo)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_LICENSES, OnAdminRedisplayLicenses)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATIONS, OnAdminUpdateWinStations)
    ON_MESSAGE( WM_ADMIN_TABBED_VIEW , OnTabbed )
    ON_MESSAGE( WM_ADMIN_SHIFTTABBED_VIEW , OnShiftTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLTABBED_VIEW , OnCtrlTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLSHIFTTABBED_VIEW , OnCtrlShiftTabbed )
    ON_MESSAGE( WM_ADMIN_NEXTPANE_VIEW , OnNextPane )
END_MESSAGE_MAP()

PageDef CServerView::pages[NUMBER_OF_PAGES] = {
	{ NULL, RUNTIME_CLASS( CUsersPage ),				IDS_TAB_USERS,		PAGE_USERS,			NULL },
	{ NULL, RUNTIME_CLASS( CServerWinStationsPage ),	IDS_TAB_WINSTATIONS,PAGE_WINSTATIONS,	NULL },
	{ NULL, RUNTIME_CLASS( CServerProcessesPage ),		IDS_TAB_PROCESSES,	PAGE_PROCESSES,		NULL },
	{ NULL, RUNTIME_CLASS( CServerLicensesPage ),		IDS_TAB_LICENSES,	PAGE_LICENSES,		PF_PICASSO_ONLY }
	// { NULL, RUNTIME_CLASS( CServerInfoPage ),			IDS_TAB_INFORMATION,PAGE_INFO,			NULL }
};


///////////////////////
// F'N: CServerView ctor
//
CServerView::CServerView()
{
	m_pTabs = NULL;
	m_pTabFont = NULL;
	m_pServer = NULL;	

	m_CurrPage = PAGE_USERS;

}  // end CServerView ctor


///////////////////////
// F'N: CServerView dtor
//
CServerView::~CServerView()
{
	if(m_pTabs)    delete m_pTabs;
	if(m_pTabFont) delete m_pTabFont;

}  // end CServerView dtor


#ifdef _DEBUG
///////////////////////////////
// F'N: CServerView::AssertValid
//
void CServerView::AssertValid() const
{
	CView::AssertValid();

}  // end CServerView::AssertValid


////////////////////////
// F'N: CServerView::Dump
//
void CServerView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CServerView::Dump

#endif //_DEBUG


////////////////////////////
// F'N: CServerView::OnCreate
//
int CServerView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;

}  // end CServerView::OnCreate


///////////////////////////////////
// F'N: CServerView::OnInitialUpdate
//
// - pointers to the pages of the sheet are obtained
//
void CServerView::OnInitialUpdate() 
{
	// create the CServerTabs
	m_pTabs = new CMyTabCtrl;
    if(!m_pTabs) return;
	m_pTabs->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, CRect(0,0,0,0), this, IDC_SERVER_TABS);

	m_pTabFont = new CFont;
    if(m_pTabFont) {
	    m_pTabFont->CreateStockObject(DEFAULT_GUI_FONT);
	    m_pTabs->SetFont(m_pTabFont, TRUE);
    }

	TCHAR szTemp[40];
	CString tabString;

	int index = 0;
	for(int i = 0; i < NUMBER_OF_PAGES; i++) {
		// If the page is shown under Picasso only and we're not running
		// under Picasso, skip to the next one
		if((pages[i].flags & PF_PICASSO_ONLY) && !((CWinAdminApp*)AfxGetApp())->IsPicasso()) continue;
		tabString.LoadString(pages[i].tabStringID);
		wcscpy(szTemp,tabString);
		AddTab(index, szTemp, i);
		pages[i].m_pPage = (CAdminPage*)pages[i].m_pRuntimeClass->CreateObject();
		pages[i].m_pPage->Create(NULL, NULL, WS_CHILD, CRect(0, 0, 0, 0), this, i, NULL);

		GetDocument()->AddView(pages[i].m_pPage);
		index++;
	}

	m_pTabs->SetCurSel(0);	

	m_CurrPage = PAGE_USERS;
	((CWinAdminDoc*)GetDocument())->SetCurrentPage(PAGE_USERS);

	OnChangePage(NULL, NULL);

}  // end CServerView::OnInitialUpdate


//////////////////////////
// F'N: CServerView::OnSize
//
// - size the pages to fill the entire view
//
void CServerView::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);
	if(m_pTabs->GetSafeHwnd())  {			// make sure the CServerTabs object is valid
		m_pTabs->MoveWindow(&rect, TRUE);	// size the tabs

		// for the next part (sizing of pages), we might want to add a member var
		// that keeps track of which page/tab is current... this way we could
		// only actually do a redraw (MoveWindow second parm == TRUE) for the
		// guy who is currently visible--DJM
	
		// we want to size the pages, too
		m_pTabs->AdjustRect(FALSE, &rect);

      for(int i = 0; i < NUMBER_OF_PAGES; i++) {
         if(pages[i].m_pPage && pages[i].m_pPage->GetSafeHwnd())
            pages[i].m_pPage->MoveWindow(&rect, TRUE);
      }
	}
}  // end CServerView::OnSize


//////////////////////////
// F'N: CServerView::OnDraw
//
// - the CServerView and it's pages draw themselves, so there isn't anything
//   to do here...
//
void CServerView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here

}  // end CServerView::OnDraw


/////////////////////////
// F'N: CServerView::Reset
//
// - 'resets' the view by taking a pointer to a CServer object and filling in 
//   the various property pages with info appropriate to that server
//
void CServerView::Reset(void *pServer)
{
	((CServer*)pServer)->ClearAllSelected();

	m_pServer = (CServer*)pServer;

	if(((CWinAdminApp*)AfxGetApp())->IsPicasso())
    {
		int PreviousTab = m_pTabs->GetCurSel();

		BOOLEAN bWinFrame = ((CServer*)pServer)->IsWinFrame();
		// Delete all the tabs
		m_pTabs->DeleteAllItems();

		// If this server isn't a WinFrame server, the current page might not be
		// applicable
		int CurrentPage = m_CurrPage;
		if(!bWinFrame && CurrentPage == PAGE_LICENSES)
        {
            CurrentPage = PAGE_INFO;
        }
		
		// create tabs only for pages we want to show for this server
		int index = 0;
		TCHAR szTemp[40];
		CString tabString;
		int CurrentTab = 0;

		for(int i = 0; i < NUMBER_OF_PAGES; i++)
        {	
			if((pages[i].flags & PF_PICASSO_ONLY) && !bWinFrame)
            {
                continue;
            }

			tabString.LoadString(pages[i].tabStringID);

			wcscpy(szTemp,tabString);

			AddTab(index, szTemp, i);

			if(pages[i].page == CurrentPage)
            {
                CurrentTab = index;
            }

			index++;
		}
				
		m_pTabs->SetCurSel(CurrentTab);
		if(PreviousTab == CurrentTab && CurrentPage != m_CurrPage)
			OnChangePage(NULL, NULL);
	}

	((CWinAdminDoc*)GetDocument())->SetCurrentPage(m_CurrPage);

	// Reset pages
	for(int i = 0; i < NUMBER_OF_PAGES; i++)
    {       
        if(pages[i].m_pPage != NULL )
        {
            pages[i].m_pPage->Reset((CServer*)pServer);
        }
	}

}  // end CServerView::Reset


//////////////////////////
// F'N: CServerView::AddTab
//
void CServerView::AddTab(int index, TCHAR* text, ULONG pageindex)
{
	TC_ITEM tc;
	tc.mask = TCIF_TEXT | TCIF_PARAM;
	tc.pszText = text;
	tc.lParam = pageindex;

	m_pTabs->InsertItem(index, &tc);

}  // end CServerView::AddTab


////////////////////////////////
// F'N: CServerView::OnChangePage
//
// - changes to a new server page based on currently selected tab
// - OnChangePage needs to force recalculation of scroll bars!!!--DJM
//
LRESULT CServerView::OnChangePage(WPARAM wParam, LPARAM lParam)
{
	// find out which tab is now selected
	int tab = m_pTabs->GetCurSel();
	TC_ITEM tc;
	tc.mask = TCIF_PARAM;
	m_pTabs->GetItem(tab, &tc);
	int index = (int)tc.lParam;
						
	// hide the current page
	pages[m_CurrPage].m_pPage->ModifyStyle(WS_VISIBLE, WS_DISABLED);
    pages[m_CurrPage].m_pPage->ClearSelections();

	m_CurrPage = index;
	((CWinAdminDoc*)GetDocument())->SetCurrentPage(m_CurrPage);
	// show the new page
	pages[index].m_pPage->ModifyStyle(WS_DISABLED, WS_VISIBLE);
	pages[index].m_pPage->ScrollToPosition(CPoint(0,0));
	pages[index].m_pPage->Invalidate();	

	if(m_pServer) m_pServer->ClearAllSelected();

	return 0;

}  // end CServerView::OnChangeview

void CServerView::OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnChangePage( 0 , 0 );
	*pResult = 0;

}  // end CServerView::OnTabSelChange


LRESULT CServerView::OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam)
{
   ((CServerProcessesPage*)pages[PAGE_PROCESSES].m_pPage)->UpdateProcesses();

	return 0;

}  // end CServerView::OnAdminUpdateProcesses


LRESULT CServerView::OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam)
{
   ((CServerProcessesPage*)pages[PAGE_PROCESSES].m_pPage)->DisplayProcesses();

	return 0;

}  // end CServerView::OnAdminRedisplayProcesses


LRESULT CServerView::OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam)
{
	((CServerProcessesPage*)pages[PAGE_PROCESSES].m_pPage)->RemoveProcess((CProcess*)lParam);

	return 0;

}  // end CServerView::OnAdminRemoveProcess


LRESULT CServerView::OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam)
{
	((CUsersPage*)pages[PAGE_USERS].m_pPage)->UpdateWinStations((CServer*)lParam);
	((CServerWinStationsPage*)pages[PAGE_WINSTATIONS].m_pPage)->UpdateWinStations((CServer*)lParam);

	return 0;
}  // end CServerView::OnAdminUpdateWinStations


LRESULT CServerView::OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam)
{
/*	((CServerInfoPage*)pages[PAGE_INFO].m_pPage)->DisplayInfo(); */

	if(pages[PAGE_LICENSES].m_pPage)
		((CServerLicensesPage*)pages[PAGE_LICENSES].m_pPage)->DisplayLicenseCounts();


   return 0;

}  // end CServerView::OnAdminUpdateServerInfo


LRESULT CServerView::OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_LICENSES].m_pPage)
		((CServerLicensesPage*)pages[PAGE_LICENSES].m_pPage)->Reset((CServer*)lParam);

	return 0;

}  // end CServerView::OnAdminRedisplayLicenses

LRESULT CServerView::OnTabbed( WPARAM wp , LPARAM lp )
{
    ODS( L"CServerView::OnTabbed " );
    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );
            // 
            // treeview should've started off with initial focus
            // we should 
            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );
                int nTab = m_pTabs->GetCurSel();
                
                m_pTabs->SetFocus( );
                m_pTabs->SetCurFocus( nTab );
                
                pDoc->RegisterLastFocus( TAB_CTRL );
            }
            else if( nFocus == TAB_CTRL )
            {
                ODS( L"from tab to item\n" );
                // set focus to item in page
                pages[ m_CurrPage ].m_pPage->SetFocus( );
                pDoc->RegisterLastFocus( PAGED_ITEM );
            }
            else
            {
                ODS( L"from item to treeview\n" );
                // set focus back to treeview

                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );
            }

            pDoc->SetPrevFocus( nFocus );
        }


    }

    return 0;
}

//=-------------------------------------------------------------------------
// OnShiftTabbed is called when the user wants to go back one 
// this code is duplicated in all view classes
LRESULT CServerView::OnShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CServerView::OnShiftTabbed " );

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            switch( nFocus )
            {
            case TREE_VIEW:

                ODS( L"going back from tree to paged item\n" );

                pages[ m_CurrPage ].m_pPage->SetFocus( );

                pDoc->RegisterLastFocus( PAGED_ITEM );

                break;
            case TAB_CTRL:
                {
                    ODS( L"going back from tab to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );
                }
                break;
            case PAGED_ITEM:
                {
                    ODS( L"going back from paged item to tab\n" );

                    int nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                break;
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}

//=-------------------------------------------------------------------------
// ctrl + tab works the same as tab but because of our unorthodox ui
// when under a tab control it will cycle over the tabs and back to the treeview
//
LRESULT CServerView::OnCtrlTabbed( WPARAM , LPARAM )
{
    ODS( L"CServerView::OnCtrlTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );

                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    m_pTabs->SetCurSel( 0 );
                    
                    OnChangePage( 0 , 0 );

                    nTab = 0;
                }

                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nTab );
                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                else
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab + 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab + 1 );

                }
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}


//=----------------------------------------------------------------------------
// same as OnCtrlTab but we focus on moving in the other direction
// tree_view to last tab -- current tab to ct - 1
//
LRESULT CServerView::OnCtrlShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CServerView::OnCtrlShiftTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );
                
                nMaxTab = m_pTabs->GetItemCount( );
                
                m_pTabs->SetCurSel( nMaxTab - 1 );
                
                OnChangePage( 0 , 0 );
                
                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nMaxTab - 1 );                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab > 0 )
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab - 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab - 1 );
                }
                else
                {

                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}

//=----------------------------------------------------------------------------
// When the user hits F6 we need to switch between pains
LRESULT CServerView::OnNextPane( WPARAM , LPARAM )
{
    ODS( L"CServerView::OnNextPane\n" );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            FOCUS_STATE nPrevFocus = pDoc->GetPrevFocus( );

            if( nFocus == TREE_VIEW )
            {
                if( nPrevFocus == TAB_CTRL )
                {
                    int nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );
                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                else
                {
                    pages[ m_CurrPage ].m_pPage->SetFocus( );
                    
                    pDoc->RegisterLastFocus( PAGED_ITEM );
                }
            }
            else
            {
                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );

            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\rtpane.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* rtpane.cpp
*
* implementation of the CRightPane class
*
*  
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "rtpane.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


////////////////////////////
// MESSAGE MAP: CRightPane
//
IMPLEMENT_DYNCREATE(CRightPane, CView)

BEGIN_MESSAGE_MAP(CRightPane, CView)
	//{{AFX_MSG_MAP(CRightPane)
	ON_WM_SIZE()
	ON_MESSAGE(WM_ADMIN_CHANGEVIEW, OnAdminChangeView)
	ON_MESSAGE(WM_ADMIN_ADD_SERVER, OnAdminAddServer)
	ON_MESSAGE(WM_ADMIN_REMOVE_SERVER, OnAdminRemoveServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER, OnAdminUpdateServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_PROCESSES, OnAdminUpdateProcesses)
	ON_MESSAGE(WM_ADMIN_REMOVE_PROCESS, OnAdminRemoveProcess)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_PROCESSES, OnAdminRedisplayProcesses)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER_INFO, OnAdminUpdateServerInfo)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_LICENSES, OnAdminRedisplayLicenses)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATIONS, OnAdminUpdateWinStations)
    ON_MESSAGE(WM_ADMIN_TABBED_VIEW , OnTabbedView)
    ON_MESSAGE(WM_ADMIN_SHIFTTABBED_VIEW , OnShiftTabbedView )
    ON_MESSAGE( WM_ADMIN_CTRLTABBED_VIEW , OnCtrlTabbedView )
    ON_MESSAGE( WM_ADMIN_CTRLSHIFTTABBED_VIEW , OnCtrlShiftTabbedView )
    ON_MESSAGE( WM_ADMIN_NEXTPANE_VIEW , OnNextPane )
    ON_WM_SETFOCUS()    
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


RightPaneView CRightPane::views[NUMBER_OF_VIEWS] = {
	{ NULL, RUNTIME_CLASS( CBlankView ) },
	{ NULL, RUNTIME_CLASS( CAllServersView ) },
    { NULL, RUNTIME_CLASS( CDomainView ) },
	{ NULL, RUNTIME_CLASS( CServerView ) },
	{ NULL, RUNTIME_CLASS( CMessageView ) },
	{ NULL, RUNTIME_CLASS( CWinStationView ) },
};


/////////////////////////
// CRightPane ctor
//
// - the view pointers are initially set to NULL
// - the default view type is BLANK
//
CRightPane::CRightPane()
{
	m_CurrViewType = VIEW_BLANK;

}  // end CRightPane ctor


////////////////////////////
// CRightPane::OnDraw
//
void CRightPane::OnDraw(CDC* pDC)
{
   

}  // end CRightPane::OnDraw


/////////////////////////
// CRightPane dtor
//
CRightPane::~CRightPane()
{
}  // end CRightPane ctor


#ifdef _DEBUG
/////////////////////////////////
// CRightPane::AssertValid
//
void CRightPane::AssertValid() const
{
	CView::AssertValid();

}  // end CView::AssertValid


//////////////////////////
// CRightPane::Dump
//
void CRightPane::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CRightPane::Dump

#endif //_DEBUG


/////////////////////////////////////
// CRightPane::OnInitialUpdate
//
// - each of the default view objects is created
// - the CBlankView object is initially the 'active' view in the right pane
//
void CRightPane::OnInitialUpdate() 
{
	CView::OnInitialUpdate();
	
	CFrameWnd* pMainWnd = (CFrameWnd*)AfxGetMainWnd();
	CWinAdminDoc* pDoc = (CWinAdminDoc*)pMainWnd->GetActiveDocument();

	for(int vw = 0; vw < NUMBER_OF_VIEWS; vw++) {
		views[vw].m_pView = (CAdminView*)views[vw].m_pRuntimeClass->CreateObject();
      views[vw].m_pView->Create(NULL, NULL, WS_CHILD, CRect(0, 0, 0, 0), this, vw);
		pDoc->AddView(views[vw].m_pView);
	}

	pDoc->UpdateAllViews(NULL);
	
}  // end CRightPane::OnInitialUpdate


////////////////////////////
// CRightPane::OnSize
//
// - currently all views are sized to fit the view, whether they are 'active'
//   or not... this may change to sizing only the view that is 'active' if
//   it significantly impacts performance
//
void CRightPane::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	for(int i = 0; i < NUMBER_OF_VIEWS; i++) {
		if(views[i].m_pView && views[i].m_pView->GetSafeHwnd())
			views[i].m_pView->MoveWindow(&rect, TRUE);
	}

	CView::OnSize(nType, cx, cy);

}  // end CRightPane::OnSize


/////////////////////////////////////
// CRightPane::OnAdminChangeView
//
// - if the new view type is different from the current
//   view type, the new view type is made 'active', reset, and invalidated
// - if the new view type is the same as the current
//   view type, the current view is simply reset using the new
//   object pointer and then invalidated
//
//	lParam contains pointer to CTreeNode of current item in tree
//  wParam is TRUE if message caused by user clicking on tree item
//
LRESULT CRightPane::OnAdminChangeView(WPARAM wParam, LPARAM lParam)
{	
	CTreeNode* pNode = (CTreeNode*)lParam;
	((CWinAdminDoc*)GetDocument())->SetCurrentPage(PAGE_CHANGING);

    ODS( L"CRightPane::OnAdminChangeView\n" );

    if( pNode == NULL )
    {
        ODS( L"CRightPane!OnAdminChangeView pNode invalid\n" );

        return 0;
    }

	void *resetParam = pNode->GetTreeObject();

	VIEW newView = VIEW_BLANK;

	switch(pNode->GetNodeType()) {

        case NODE_THIS_COMP: // FALL THROUGH
        case NODE_FAV_LIST:
            resetParam = pNode;
            newView = VIEW_ALL_SERVERS;            
            break;


		case NODE_ALL_SERVERS:
			newView = VIEW_ALL_SERVERS;            
            ODS( L"CRightPane::OnAdminChangeView = VIEW_ALL_SERVERS\n" );
			break;

        case NODE_DOMAIN:
			{
				CDomain *pDomain = (CDomain*)pNode->GetTreeObject();
				// If we haven't fired off a background thread for this
				// domain yet, do it now
				if(!pDomain->GetThreadPointer()) {
					newView = VIEW_MESSAGE;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_MESSAGE\n" );
                    // todo change message to let the user know that a dblclk action is required to
                    // start the enumeration process.
					resetParam = (void*)IDS_DOMAIN_DBLCLK_MSG;
					// pDomain->StartEnumerating();
				}
				else if(pDomain->IsState(DS_INITIAL_ENUMERATION))
				{
					newView = VIEW_MESSAGE;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_MESSAGE\n" );
					resetParam = (void*)IDS_DOMAIN_FINDING_SERVERS;
				}
                else
                {
                    newView = VIEW_DOMAIN;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_DOMAIN\n" );
                }
			}
            break;

		case NODE_SERVER:
			{
                CServer *pServer = (CServer*)pNode->GetTreeObject();
                if(!pServer->GetThreadPointer()) {
					newView = VIEW_MESSAGE;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_MESSAGE !pServer->GetThreadPointer\n" );
					// If we just disconnected from this server, we don't
					// want to reconnect
					if( ( pServer->IsState( SS_NOT_CONNECTED ) || pServer->IsPreviousState(SS_DISCONNECTING) ) && !wParam)
                    {
						resetParam = (void*)IDS_CLICK_TO_CONNECT;
					}
                    else
                    {
						resetParam = (void*)IDS_GATHERING_SERVER_INFO;
						pServer->Connect();
					}
                }
				else if(!pServer->IsServerSane())
                {
					newView = VIEW_MESSAGE;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_MESSAGE !pServer->IsServerSane\n" );
					resetParam = (void*)IDS_NOT_AUTHENTICATED;
				}
				else if(!pServer->IsState(SS_GOOD))
                {
					newView = VIEW_MESSAGE;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_MESSAGE !pServer->IsState(SS_GOOD)\n" );
					resetParam = (void*)IDS_GATHERING_SERVER_INFO;
				}
				else
                {
                    newView = VIEW_SERVER;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_SERVER default\n" );
                }
			}
			break;

		case NODE_WINSTATION:
			{
				CWinStation *pWinStation = (CWinStation*)pNode->GetTreeObject();
				if(pWinStation->IsConnected() || pWinStation->IsState(State_Disconnected) ||
					pWinStation->IsState(State_Shadow))
                {
					newView = VIEW_WINSTATION;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_WINSTATION\n" );
                }
				else if(pWinStation->IsState(State_Listen))
                {
					newView = VIEW_MESSAGE;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_MESSAGE\n" );
					resetParam = (void *)IDS_LISTENER_MSG;
				}
				else
                {
					newView = VIEW_MESSAGE;	
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_MESSAGE\n" );
					resetParam = (void *)IDS_INACTIVE_MSG;
				}
			}
			break;
	}

	if(m_CurrViewType != newView)
    {
        //views[newView].m_pView->Reset(resetParam);
		views[m_CurrViewType].m_pView->ModifyStyle(WS_VISIBLE, WS_DISABLED);	 
		m_CurrViewType = newView;
		
		views[newView].m_pView->ModifyStyle(WS_DISABLED, WS_VISIBLE);
		views[newView].m_pView->Reset(resetParam);
		views[newView].m_pView->Invalidate();
	}
    else
    {
		views[newView].m_pView->Reset(resetParam);  
	}


	((CWinAdminDoc*)GetDocument())->SetCurrentView(newView);
	
	return 0;

}  // end CRightPane::OnAdminChangeView


/////////////////////////////////////
// CRightPane::OnAdminAddServer
//
LRESULT CRightPane::OnAdminAddServer(WPARAM wParam, LPARAM lParam)
{	
	ASSERT(lParam);

	// We only want to send this along if "All Listed Servers"
	// or "Domain" is the current view
	if(m_CurrViewType == VIEW_ALL_SERVERS || m_CurrViewType == VIEW_DOMAIN)
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_ADD_SERVER, wParam, lParam);

	return 0;

}  // end CRightPane::OnAdminAddServer


/////////////////////////////////////
// CRightPane::OnAdminRemoveServer
//
LRESULT CRightPane::OnAdminRemoveServer(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	// ODS( L"CRightPane::OnAdminRemoveServer\n" );
    // We only want to send this along if "All Listed Servers" or "Domain"
	// is the current view
	if(m_CurrViewType == VIEW_ALL_SERVERS || m_CurrViewType == VIEW_DOMAIN)
    {
        // ODS( L"view is ALL_SERVERS OR DOMAIN\n" );
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_REMOVE_SERVER, wParam, lParam);
    }

	return 0;

}  // end CRightPane::OnAdminRemoveServer


/////////////////////////////////////
// CRightPane::OnAdminUpdateServer
//
LRESULT CRightPane::OnAdminUpdateServer(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	// We only want to send this along if "All Listed Servers" or Domain
	// the current view
    
	if(m_CurrViewType == VIEW_ALL_SERVERS || m_CurrViewType == VIEW_DOMAIN)
    {        
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_UPDATE_SERVER, wParam, lParam);
    }
      
	return 0;

}  // end CRightPane::OnAdminUpdateServer


/////////////////////////////////////
// CRightPane::OnAdminUpdateProcesses
//
LRESULT CRightPane::OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	BOOL bSendMessage = FALSE;

	void *pCurrentSelectedNode = ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode();

	switch(m_CurrViewType) {
		case VIEW_ALL_SERVERS:
			bSendMessage = TRUE;
			break;

		case VIEW_DOMAIN:
			if((CDomain*)((CServer*)lParam)->GetDomain() == (CDomain*)pCurrentSelectedNode)
				bSendMessage = TRUE;
			break;
		
		case VIEW_SERVER:
			if((void*)lParam == pCurrentSelectedNode)
				bSendMessage = TRUE;
			break;

		case VIEW_WINSTATION:
			if((CServer*)lParam == (CServer*)((CWinStation*)pCurrentSelectedNode)->GetServer())
				bSendMessage = TRUE;
			break;
	}		
	
	if(bSendMessage) {
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_UPDATE_PROCESSES, wParam, lParam);
	}

	return 0;                                                                  

}  // end CRightPane::OnAdminUpdateProcesses


/////////////////////////////////////
// CRightPane::OnAdminRemoveProcess
//
LRESULT CRightPane::OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	// We only want to send this along if "All Listed Servers", VIEW_DOMAIN, or VIEW_SERVER is
	// the current view
	if(m_CurrViewType == VIEW_ALL_SERVERS || m_CurrViewType == VIEW_DOMAIN || m_CurrViewType == VIEW_WINSTATION) {
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_REMOVE_PROCESS, wParam, lParam);
		return 0;
	}

	void *pCurrentSelectedNode = ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode();

	if(m_CurrViewType == VIEW_SERVER && ((CServer*)((CProcess*)lParam)->GetServer() == (CServer*)pCurrentSelectedNode))
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_REMOVE_PROCESS, wParam, lParam);

	return 0;                                                                  

}  // end CRightPane::OnAdminUpdateProcesses


/////////////////////////////////////
// CRightPane::OnAdminRedisplayProcesses
//
LRESULT CRightPane::OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

    void *pCurrentSelectedNode = NULL;

    if(m_CurrViewType == VIEW_ALL_SERVERS || m_CurrViewType == VIEW_DOMAIN
			|| m_CurrViewType == VIEW_SERVER || m_CurrViewType == VIEW_WINSTATION)
    {
        if( m_CurrViewType == VIEW_ALL_SERVERS )
        {
            pCurrentSelectedNode = ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode();
        }

		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_REDISPLAY_PROCESSES, ( WPARAM )m_CurrViewType , ( LPARAM )pCurrentSelectedNode );
    }

   return 0;                                                                  

}  // end CRightPane::OnAdminRedisplayProcesses


/////////////////////////////////////
// CRightPane::OnAdminUpdateWinStations
//
LRESULT CRightPane::OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);
	BOOL bSendMessage = FALSE;

	void *pCurrentSelectedNode = ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode();

	switch(m_CurrViewType) {

		case VIEW_ALL_SERVERS:
            ODS( L"CRightPane::OnAdminUpdateWinStations -- VIEW_ALL_SERVERS\n" );
            bSendMessage = TRUE;
            break;
        case VIEW_DOMAIN:
            ODS( L"CRightPane::OnAdminUpdateWinStations -- VIEW_DOMAIN\n" );
			if((CDomain*)((CServer*)lParam)->GetDomain() == (CDomain*)pCurrentSelectedNode)
				bSendMessage = TRUE;
			break;
		
		case VIEW_SERVER:
            ODS( L"CRightPane::OnAdminUpdateWinStations -- VIEW_SERVER\n" );
			if((void*)lParam == pCurrentSelectedNode)
				bSendMessage = TRUE;
			break;
        
		case VIEW_WINSTATION:
            ODS( L"CRightPane::OnAdminUpdateWinStations -- VIEW_WINSTATION\n" );
			if((CServer*)lParam == (CServer*)((CWinStation*)pCurrentSelectedNode)->GetServer())
				bSendMessage = TRUE;
			break;
	}		
	
	if(bSendMessage) {
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_UPDATE_WINSTATIONS, wParam, lParam);
	}

	return 0;                                                                  

}  // end CRightPane::OnAdminUpdateWinStations


/////////////////////////////////////
// CRightPane::OnAdminUpdateServerInfo
//
LRESULT CRightPane::OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	BOOL bSendMessage = FALSE;

	void *pCurrentSelectedNode = ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode();

	switch(m_CurrViewType) {
		case VIEW_DOMAIN:
			if((CDomain*)((CServer*)lParam)->GetDomain() == (CDomain*)pCurrentSelectedNode)
				bSendMessage = TRUE;
			break;
		
		case VIEW_SERVER:
			if((void*)lParam == pCurrentSelectedNode)
				bSendMessage = TRUE;
			break;

		case VIEW_WINSTATION:
			if((CServer*)lParam == (CServer*)((CWinStation*)pCurrentSelectedNode)->GetServer())
				bSendMessage = TRUE;
			break;
	}		
	
	if(bSendMessage) {
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_UPDATE_SERVER_INFO, wParam, lParam);
	}

	return 0;

}  // end CRightPane::OnAdminUpdateServerInfo


/////////////////////////////////////
// CRightPane::OnAdminRedisplayLicenses
//
LRESULT CRightPane::OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	if(m_CurrViewType == VIEW_ALL_SERVERS)
      views[VIEW_ALL_SERVERS].m_pView->SendMessage(WM_ADMIN_REDISPLAY_LICENSES, wParam, lParam);

    else if(m_CurrViewType == VIEW_DOMAIN && (CDomain*)((CServer*)lParam)->GetDomain() == (CDomain*)((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode())
		views[VIEW_DOMAIN].m_pView->SendMessage(WM_ADMIN_REDISPLAY_LICENSES, wParam, lParam);

	else if(m_CurrViewType == VIEW_SERVER && (CServer*)lParam == (CServer*)((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode())
		views[VIEW_SERVER].m_pView->SendMessage(WM_ADMIN_REDISPLAY_LICENSES, wParam, lParam);

	return 0;

}  // end CRightPane::OnAdminRedisplayLicenses


/////////////////////////////////////
// CRightPane::OnSetFocus
//
void CRightPane::OnSetFocus(CWnd* pOldWnd) 
{
	CView::OnSetFocus(pOldWnd);
	
	views[m_CurrViewType].m_pView->SetFocus();
	
}   // end CRightPane::OnSetFocus

LRESULT CRightPane::OnTabbedView(WPARAM wParam, LPARAM lParam)
{
    return views[ m_CurrViewType ].m_pView->SendMessage( WM_ADMIN_TABBED_VIEW , 0 , 0 );
}

LRESULT CRightPane::OnShiftTabbedView( WPARAM , LPARAM )
{
    return views[ m_CurrViewType ].m_pView->SendMessage( WM_ADMIN_SHIFTTABBED_VIEW , 0 , 0 );
}

LRESULT CRightPane::OnCtrlTabbedView( WPARAM , LPARAM )
{
    return views[ m_CurrViewType ].m_pView->SendMessage( WM_ADMIN_CTRLTABBED_VIEW , 0 , 0 );
}

LRESULT CRightPane::OnCtrlShiftTabbedView( WPARAM , LPARAM )
{
    return views[ m_CurrViewType ].m_pView->SendMessage( WM_ADMIN_CTRLSHIFTTABBED_VIEW , 0 , 0 );
}

LRESULT CRightPane::OnNextPane( WPARAM , LPARAM )
{
    return views[ m_CurrViewType ].m_pView->SendMessage( WM_ADMIN_NEXTPANE_VIEW , 0 , 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\rtpane.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* rtpane.h
*
* - declarations for the CRightPane class
* - the RightPane class is a public CView derivative that maintains
*   one of each of the default view type objects, swapping them
*   in and out of it's space as necessary (actually the views are
*   disabled/hidden and enabled/shown, but you get the idea...)
*
*******************************************************************************/

#ifndef _RIGHTPANE_H
#define _RIGHTPANE_H

#include "blankvw.h"	// CBlankView
#include "allsrvvw.h"	// CAllServersView
#include "domainvw.h"   // CDomainView
#include "servervw.h"	// CServerView
#include "winsvw.h"		// CWinStationView
#include "msgview.h"    // CMessageView

const int NUMBER_OF_VIEWS = 6;

typedef struct _rpview {
	CAdminView *m_pView;
	CRuntimeClass *m_pRuntimeClass;
} RightPaneView;


//////////////////////
// CLASS: CRightPane
//
class CRightPane : public CView
{
protected:
	CRightPane();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CRightPane)

// Attributes
protected:
   
	VIEW m_CurrViewType;	// keeps track of currently 'active' view in the right pane
   static RightPaneView views[NUMBER_OF_VIEWS];

// Operations
public:
	VIEW GetCurrentViewType() { return m_CurrViewType; }

protected:
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRightPane)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CRightPane();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    
	// Generated message map functions
protected:
	//{{AFX_MSG(CRightPane)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg LRESULT OnAdminChangeView(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminAddServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRemoveServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateProcesses(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRemoveProcess(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRedisplayProcesses(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateServerInfo(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRedisplayLicenses(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateWinStations(WPARAM, LPARAM);
    afx_msg LRESULT OnTabbedView(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnShiftTabbedView( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlTabbedView( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlShiftTabbedView( WPARAM , LPARAM );
    afx_msg LRESULT OnNextPane( WPARAM , LPARAM );
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    //}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CRightPane

#endif  // _RIGHTPANE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\servpgs.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* servpgs.cpp
*
* implementations for the server info pages
*
*  
*******************************************************************************/

#include "stdafx.h"
#include "afxpriv.h"
#include "winadmin.h"
#include "servpgs.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////////////////
// MESSAGE MAP: CUsersPage
//
IMPLEMENT_DYNCREATE(CUsersPage, CFormView)

BEGIN_MESSAGE_MAP(CUsersPage, CFormView)
	//{{AFX_MSG_MAP(CUsersPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_USER_LIST, OnUserItemChanged)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_USER_LIST, OnColumnClick)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(NM_SETFOCUS, IDC_USER_LIST, OnSetfocusUserList)
   	//ON_NOTIFY(NM_KILLFOCUS, IDC_USER_LIST, OnKillfocusUserList)

	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


IMPLEMENT_DYNCREATE(CAdminPage, CFormView)

CAdminPage::CAdminPage(UINT id)
   : CFormView(id)
{

}

CAdminPage::CAdminPage()
	: CFormView((UINT)0)
{

}

/////////////////////////////
// F'N: CUsersPage ctor
//
CUsersPage::CUsersPage()
	: CAdminPage(CUsersPage::IDD)
{
	//{{AFX_DATA_INIT(CUsersPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pServer = NULL;
    m_bSortAscending = TRUE;

}  // end CUsersPage ctor


/////////////////////////////
// F'N: CUsersPage dtor
//
CUsersPage::~CUsersPage()
{

}  // end CUsersPage dtor


////////////////////////////////////////
// F'N: CUsersPage::DoDataExchange
//
void CUsersPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CUsersPage)
	DDX_Control(pDX, IDC_USER_LIST, m_UserList);
	//}}AFX_DATA_MAP

}  // end CUsersPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CUsersPage::AssertValid
//
void CUsersPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CUsersPage::AssertValid


//////////////////////////////
// F'N: CUsersPage::Dump
//
void CUsersPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CUsersPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CUsersPage::OnSize
//
void CUsersPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	rect.top += LIST_TOP_OFFSET;

	if(m_UserList.GetSafeHwnd())
		m_UserList.MoveWindow(&rect, TRUE);

	//CFormView::OnSize(nType, cx, cy);

}  // end CUsersPage::OnSize


static ColumnDef UserColumns[] = {
	CD_USER3,
	CD_SESSION,
	CD_ID,
	CD_STATE,
	CD_IDLETIME,
	CD_LOGONTIME
};

#define NUM_USER_COLUMNS sizeof(UserColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CUsersPage::OnInitialUpdate
//
void CUsersPage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

	BuildImageList();		// builds the image list for the list control

	CString columnString;

	for(int col = 0; col < NUM_USER_COLUMNS; col++) {
		columnString.LoadString(UserColumns[col].stringID);
		m_UserList.InsertColumn(col, columnString, UserColumns[col].format, UserColumns[col].width, col);
	}

	m_CurrentSortColumn = USERS_COL_USER;

}  // end CUsersPage::OnInitialUpdate


//////////////////////////////
// F'N: CUsersPage::OnUserItemChanged
//
void CUsersPage::OnUserItemChanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;
	
	if(pLV->uNewState & LVIS_SELECTED) {
		CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(pLV->iItem);
		pWinStation->SetSelected();
	}
	
	if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
		CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(pLV->iItem);
		pWinStation->ClearSelected();
	}

	*pResult = 0;

}  // end CUsersPage::OnUserItemChanged

/////////////////////////////////////
// F'N: CUsersPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CUsersPage::BuildImageList()
{
	m_ImageList.Create(16, 16, TRUE, 2, 0);

	m_idxUser = AddIconToImageList(IDI_USER);
	m_idxCurrentUser  = AddIconToImageList(IDI_CURRENT_USER);

	m_UserList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CUsersPage::BuildImageList


/////////////////////////////////////////
// F'N: CUsersPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CUsersPage::AddIconToImageList(int iconID)
{
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
	return m_ImageList.Add(hIcon);

}  // end CUsersPage::AddIconToImageList


//////////////////////////////
// F'N: CUsersPage::Reset
//
void CUsersPage::Reset(void *pServer)
{
	m_pServer = (CServer*)pServer;
	DisplayUsers();

}  // end CUsersPage::Reset


//////////////////////////////
// F'N: CUsersPage::UpdateWinStations
//
void CUsersPage::UpdateWinStations(CServer *pServer)
{
	if(pServer != m_pServer) return;

	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
	BOOL bAnyChanged = FALSE;
	BOOL bAnyAdded = FALSE;

	// Loop through the WinStations
	m_pServer->LockWinStationList();
	CObList *pWinStationList = m_pServer->GetWinStationList();

	POSITION pos = pWinStationList->GetHeadPosition();

	while(pos) {
		CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

		LV_FINDINFO FindInfo;
		FindInfo.flags = LVFI_PARAM;
		FindInfo.lParam = (LPARAM)pWinStation;

		// Find the WinStation in our list
		int item = m_UserList.FindItem(&FindInfo, -1);

		// If the process is new and isn't currently in the list,
		// add it to the list
		if(pWinStation->IsNew() && pWinStation->HasUser() && item == -1) {

			AddUserToList(pWinStation);
			bAnyAdded = TRUE;
			continue;
		}

		// If the WinStation is no longer current or no longer has a user,
		// remove it from the list
		if((!pWinStation->IsCurrent() || !pWinStation->HasUser()) && item != -1) {
			// Remove the WinStation from the list
			m_UserList.DeleteItem(item);
			pWinStation->ClearSelected();
			continue;
		}

		// If the WinStation info has changed, change
		// it's info in our tree
		if(pWinStation->IsChanged() && item != -1) {
			// change the user name
			m_UserList.SetItemText(item, USERS_COL_USER, pWinStation->GetUserName());
			// change the WinStation Name

			// WinStation Name
			if(pWinStation->GetName()[0])
			    m_UserList.SetItemText(item, USERS_COL_WINSTATION, pWinStation->GetName());
			else {
				CString NameString(" ");
				if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
				if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
			    m_UserList.SetItemText(item, USERS_COL_WINSTATION, NameString);
			}

			// change the Connect State
			m_UserList.SetItemText(item, USERS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));
			// change the Idle Time
			TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

			ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

			if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
			{
				ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
			}
			else wcscpy(IdleTimeString, TEXT("."));

			m_UserList.SetItemText(item, USERS_COL_IDLETIME, IdleTimeString);
			// change the Logon Time
			TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
			// We don't want to pass a 0 logon time to DateTimeString()
			// It will blow up if the timezone is GMT
			if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
				DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
				pDoc->FixUnknownString(LogonTimeString);
			}
			else LogonTimeString[0] = '\0';
			// change the 

			m_UserList.SetItemText(item, USERS_COL_LOGONTIME, LogonTimeString);

			if(m_CurrentSortColumn != USERS_COL_ID)
				bAnyChanged = TRUE;

			continue;
		}

		// If the WinStation is not in the list but now has a user, add it to the list
		if(item == -1 && pWinStation->IsCurrent() && pWinStation->HasUser()) {
			AddUserToList(pWinStation);
			bAnyAdded = TRUE;
		}
	}

	m_pServer->UnlockWinStationList();

	if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_SERVER, PAGE_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);

}  // end CUsersPage::UpdateWinStations


//////////////////////////////
// F'N: CUsersPage::AddUserToList
//
int CUsersPage::AddUserToList(CWinStation *pWinStation)
{
    int item = -1;

    if( pWinStation != NULL )
    {
	    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

	    LockListControl();
	    //////////////////////
	    // Fill in the columns
	    //////////////////////
	    
	    // User - put at the end of the list
	    item = m_UserList.InsertItem(m_UserList.GetItemCount(), pWinStation->GetUserName(), 
		    pWinStation->IsCurrentUser() ? m_idxCurrentUser : m_idxUser);

	    // WinStation Name
	    if(pWinStation->GetName()[0])
	        m_UserList.SetItemText(item, USERS_COL_WINSTATION, pWinStation->GetName());
	    else {
		    CString NameString(" ");
		    if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
		    if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
	        m_UserList.SetItemText(item, USERS_COL_WINSTATION, NameString);
	    }

	    // Logon ID
	    CString ColumnString;
	    ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
	    m_UserList.SetItemText(item, USERS_COL_ID, ColumnString);

	    // Connect State
	    m_UserList.SetItemText(item, USERS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

	    // Idle Time
	    TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

	    ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

	    if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
	    {
		    ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
	    }
	    else wcscpy(IdleTimeString, TEXT("."));

	    m_UserList.SetItemText(item, USERS_COL_IDLETIME, IdleTimeString);

	    // Logon Time
	    TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
	    // We don't want to pass a 0 logon time to DateTimeString()
	    // It will blow up if the timezone is GMT
	    if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
		    DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
		    pDoc->FixUnknownString(LogonTimeString);
	    }
	    else LogonTimeString[0] = '\0';

	    m_UserList.SetItemText(item, USERS_COL_LOGONTIME, LogonTimeString);

	    // Attach a pointer to the CWinStation structure to the list item
	    m_UserList.SetItemData(item, (DWORD_PTR)pWinStation);

        // m_UserList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

	    UnlockListControl();
    }

	return item;

}  // end CUsersPage::AddUserToList


/////////////////////////////////////
// F'N: CUsersPage::DisplayUsers
//
void CUsersPage::DisplayUsers()
{
	LockListControl();

	// Clear out the list control
	m_UserList.DeleteAllItems();

	m_pServer->LockWinStationList();
	// Get a pointer to this server's list of WinStations
	CObList *pWinStationList = m_pServer->GetWinStationList();

	// Iterate through the WinStation list
	POSITION pos = pWinStationList->GetHeadPosition();

	while(pos) {
		CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

		// only show the WinStation if it has a user
		if(pWinStation->HasUser()) {
			AddUserToList(pWinStation);
		}
	}	// end while(pos)

    //bug #191727
    //m_UserList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

	m_pServer->UnlockWinStationList();

	UnlockListControl();

}  // end CUsersPage::DisplayUsers


//////////////////////////////
// F'N: CUsersPage::OnColumnClick
//
void CUsersPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
    
    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	LockListControl();
	SortByColumn(VIEW_SERVER, PAGE_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);
	UnlockListControl();

	*pResult = 0;

}  // end CUsersPage::OnColumnClick


//////////////////////////////
// F'N: CUsersPage::OnContextMenu
//
void CUsersPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen) 
{
	// TODO: Add your message handler code here
	UINT flags;
	UINT Item;
	CPoint ptClient = ptScreen;
	ScreenToClient(&ptClient);

	// If we got here from the keyboard,
	if(ptScreen.x == -1 && ptScreen.y == -1) {
		
		UINT iCount = m_UserList.GetItemCount( );
		
		RECT rc;

		for( Item = 0 ; Item < iCount ; Item++ )
		{
			if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
			{
				m_UserList.GetItemRect( Item , &rc , LVIR_ICON );

				ptScreen.x = rc.left;

				ptScreen.y = rc.bottom + 5;

				ClientToScreen( &ptScreen );

				break;
			}
		}

		if(ptScreen.x == -1 && ptScreen.y == -1) 
		{
			return;
		}
			/*
		m_UserList.GetClientRect(&rect);
		ptScreen.x = (rect.right - rect.left) / 2;
		ptScreen.y = (rect.bottom - rect.top) / 2;
		ClientToScreen(&ptScreen);
		*/
	}
	else {
		Item = m_UserList.HitTest(ptClient, &flags);
        if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
        {
            //
            // ListView HitTest bug? return -1 but item display as selected.
            // workaround for now, Al can fix this later
            //
            UINT iCount = m_UserList.GetItemCount( );
            RECT rc;

            for( Item = 0 ; Item < iCount ; Item++ )
            {
                if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                {
                    break;
                }
            }

            if( Item >= iCount )
            {
                return;
            }

        }

        //
        // NM_RCLICK (WM_NOTIFY) then WM_CNTEXTMENU but no NM_ITEMCHANGED message
        // manually set it to selected state
        //
        CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(Item);

        if( !pWinStation )
            return;

        if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
        {
            pWinStation->SetSelected();
        }
	}

	CMenu menu;
	menu.LoadMenu(IDR_USER_POPUP);
	menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
			TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
	menu.DestroyMenu();
	
}  // end CUsersPage::OnContextMenu

/////////////////////////////////////
// F'N: CUsersPage::ClearSelections
//
void CUsersPage::ClearSelections()
{
    
    if(m_UserList.m_hWnd != NULL)
    {
        POSITION pos = m_UserList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nItem = m_UserList.GetNextSelectedItem(pos);
            m_UserList.SetItemState(nItem,0,LVIS_SELECTED);
        }
    }
}

////////////////////////////////
// MESSAGE MAP: CServerWinStationsPage
//
IMPLEMENT_DYNCREATE(CServerWinStationsPage, CFormView)

BEGIN_MESSAGE_MAP(CServerWinStationsPage, CFormView)
	//{{AFX_MSG_MAP(CServerWinStationsPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_WINSTATION_LIST, OnWinStationItemChanged)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_WINSTATION_LIST, OnColumnClick)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(NM_SETFOCUS, IDC_WINSTATION_LIST, OnSetfocusWinstationList)
    //ON_NOTIFY(NM_KILLFOCUS, IDC_WINSTATION_LIST, OnKillfocusWinstationList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CServerWinStationsPage ctor
//
CServerWinStationsPage::CServerWinStationsPage()
	: CAdminPage(CServerWinStationsPage::IDD)
{
	//{{AFX_DATA_INIT(CServerWinStationsPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pServer = NULL;
    m_bSortAscending = TRUE;

}  // end CServerWinStationsPage ctor


/////////////////////////////
// F'N: CServerWinStationsPage dtor
//
CServerWinStationsPage::~CServerWinStationsPage()
{

}  // end CServerWinStationsPage dtor


////////////////////////////////////////
// F'N: CServerWinStationsPage::DoDataExchange
//
void CServerWinStationsPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerWinStationsPage)
	DDX_Control(pDX, IDC_WINSTATION_LIST, m_StationList);
	//}}AFX_DATA_MAP

}  // end CServerWinStationsPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CServerWinStationsPage::AssertValid
//
void CServerWinStationsPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CServerWinStationsPage::AssertValid


//////////////////////////////
// F'N: CServerWinStationsPage::Dump
//
void CServerWinStationsPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CServerWinStationsPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CServerWinStationsPage::OnWinStationItemChanged
//
void CServerWinStationsPage::OnWinStationItemChanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;

	if(pLV->uNewState & LVIS_SELECTED) {
		CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(pLV->iItem);
		pWinStation->SetSelected();
	}
	
	if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
		CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(pLV->iItem);
		pWinStation->ClearSelected();
	}

	*pResult = 0;

}  // end CServerWinStationsPage::OnWinStationItemChanged


//////////////////////////////
// F'N: CServerWinStationsPage::OnSize
//
void CServerWinStationsPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	rect.top += LIST_TOP_OFFSET;

	if(m_StationList.GetSafeHwnd())
		m_StationList.MoveWindow(&rect, TRUE);

	// CFormView::OnSize(nType, cx, cy);

}  // end CServerWinStationsPage::OnSize


static ColumnDef WinsColumns[] = {
	CD_SESSION2,
	CD_USER2,
	CD_ID,
	CD_STATE,
	CD_TYPE,
	CD_CLIENT_NAME,
	CD_IDLETIME,
	CD_LOGONTIME,
	CD_COMMENT
};

#define NUM_WINS_COLUMNS sizeof(WinsColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CServerWinStationsPage::OnInitialUpdate
//
void CServerWinStationsPage::OnInitialUpdate() 
{
	// Call the parent class
	CFormView::OnInitialUpdate();

	// builds the image list for the list control
	BuildImageList();		

	// Add the column headings
	CString columnString;

	for(int col = 0; col < NUM_WINS_COLUMNS; col++) {
		columnString.LoadString(WinsColumns[col].stringID);
		m_StationList.InsertColumn(col, columnString, WinsColumns[col].format, WinsColumns[col].width, col);
	}
	m_CurrentSortColumn = WS_COL_WINSTATION;


}  // end CServerWinStationsPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CServerWinStationsPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CServerWinStationsPage::BuildImageList()
{
	m_ImageList.Create(16, 16, TRUE, 11, 0);

	m_idxBlank  = AddIconToImageList(IDI_BLANK);
	m_idxCitrix = AddIconToImageList(IDR_MAINFRAME);
	m_idxServer = AddIconToImageList(IDI_SERVER);
	m_idxConsole = AddIconToImageList(IDI_CONSOLE);
	m_idxNet = AddIconToImageList(IDI_NET);
	m_idxAsync = AddIconToImageList(IDI_ASYNC);
	m_idxCurrentConsole = AddIconToImageList(IDI_CURRENT_CONSOLE);
	m_idxCurrentNet = AddIconToImageList(IDI_CURRENT_NET);
	m_idxCurrentAsync = AddIconToImageList(IDI_CURRENT_ASYNC);
	m_idxDirectAsync = AddIconToImageList(IDI_DIRECT_ASYNC);
	m_idxCurrentDirectAsync = AddIconToImageList(IDI_CURRENT_DIRECT_ASYNC);
	
	m_StationList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CServerWinStationsPage::BuildImageList


/////////////////////////////////////////
// F'N: CServerWinStationsPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CServerWinStationsPage::AddIconToImageList(int iconID)
{
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
	return m_ImageList.Add(hIcon);

}  // end CServerWinStationsPage::AddIconToImageList


//////////////////////////////
// F'N: CServerWinStationsPage::Reset
//
void CServerWinStationsPage::Reset(void *pServer)
{
	m_pServer = (CServer*)pServer;
	DisplayStations();

}  // end CServerWinStationsPage::Reset


//////////////////////////////
// F'N: CServerWinStationsPage::UpdateWinStations
//
void CServerWinStationsPage::UpdateWinStations(CServer *pServer)
{
	if(pServer != m_pServer) return;

	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
	BOOL bAnyChanged = FALSE;
	BOOL bAnyAdded = FALSE;

	// Loop through the WinStations
	m_pServer->LockWinStationList();
	CObList *pWinStationList = m_pServer->GetWinStationList();

	POSITION pos = pWinStationList->GetHeadPosition();

	while(pos) {
		CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

		LV_FINDINFO FindInfo;
		FindInfo.flags = LVFI_PARAM;
		FindInfo.lParam = (LPARAM)pWinStation;

		// Find the WinStation in our list
		int item = m_StationList.FindItem(&FindInfo, -1);

		// If the process is new and not currently in the list,
		// add it to the list
		if(pWinStation->IsNew() && item == -1) {

			AddWinStationToList(pWinStation);
			bAnyAdded = TRUE;
			continue;
		}


		// If the WinStation is no longer current,
		// remove it from the list
		if(!pWinStation->IsCurrent() && item != -1) {
			// Remove the WinStation from the list
			m_StationList.DeleteItem(item);
			pWinStation->ClearSelected();
			continue;
		}

		// If the WinStation info has changed, change
		// it's info in our tree
		if(pWinStation->IsChanged() && item != -1) {

			// Figure out which icon to use
			int WhichIcon = m_idxBlank;
			BOOL CurrentWinStation = pWinStation->IsCurrentWinStation();
					
			if(pWinStation->GetState() != State_Disconnected 
			&& pWinStation->GetState() != State_Idle) {
				switch(pWinStation->GetSdClass()) {
					case SdAsync:
						if(pWinStation->IsDirectAsync())
							WhichIcon = CurrentWinStation ? m_idxCurrentDirectAsync : m_idxDirectAsync;
						else
							WhichIcon = CurrentWinStation ? m_idxCurrentAsync : m_idxAsync;
						break;

					case SdNetwork:
						WhichIcon = CurrentWinStation ? m_idxCurrentNet : m_idxNet;
						break;

					default:
						WhichIcon = CurrentWinStation ? m_idxCurrentConsole : m_idxConsole;
					break;
				}
			}

			m_StationList.SetItem(item, 0, LVIF_IMAGE, 0, WhichIcon, 0, 0, 0L);

			// WinStation Name
			if(pWinStation->GetName()[0])
				m_StationList.SetItemText(item, WS_COL_WINSTATION, pWinStation->GetName());
			else {
				CString NameString(" ");
				if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
				if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
				m_StationList.SetItemText(item, WS_COL_WINSTATION, NameString);
			}

			// User
			m_StationList.SetItemText(item, WS_COL_USER, pWinStation->GetUserName());

			// Logon ID
			CString ColumnString;
			ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
			m_StationList.SetItemText(item, WS_COL_ID, ColumnString);

			// Connect State
			m_StationList.SetItemText(item, WS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

			// Type
			m_StationList.SetItemText(item, WS_COL_TYPE, pWinStation->GetWdName());

			// Client Name
			m_StationList.SetItemText(item, WS_COL_CLIENTNAME, pWinStation->GetClientName());

			// Idle Time
			TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

			ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

			if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
			{
				ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
			}
			else wcscpy(IdleTimeString, TEXT("."));

			m_StationList.SetItemText(item, WS_COL_IDLETIME, IdleTimeString);
	
			// Logon Time
			TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
			// We don't want to pass a 0 logon time to DateTimeString()
			// It will blow up if the timezone is GMT
			if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
				DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
				pDoc->FixUnknownString(LogonTimeString);
			}
			else LogonTimeString[0] = '\0';

			m_StationList.SetItemText(item, WS_COL_LOGONTIME, LogonTimeString);

			// Comment
			m_StationList.SetItemText(item, WS_COL_COMMENT, pWinStation->GetComment());

			if(m_CurrentSortColumn != WS_COL_ID)
				bAnyChanged = TRUE;
		}
	}

	m_pServer->UnlockWinStationList();

	if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_SERVER, PAGE_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);

}


//////////////////////////////
// F'N: CServerWinStationsPage::AddWinStationToList
//
int CServerWinStationsPage::AddWinStationToList(CWinStation *pWinStation)
{
	CServer *pServer = pWinStation->GetServer();

	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

	// Figure out which icon to use
	int WhichIcon = m_idxBlank;
	BOOL CurrentWinStation = pWinStation->IsCurrentWinStation();
					
	if(pWinStation->GetState() != State_Disconnected 
		&& pWinStation->GetState() != State_Idle) {
		switch(pWinStation->GetSdClass()) {
			case SdAsync:
				if(pWinStation->IsDirectAsync())
					WhichIcon = CurrentWinStation ? m_idxCurrentDirectAsync : m_idxDirectAsync;
				else
					WhichIcon = CurrentWinStation ? m_idxCurrentAsync : m_idxAsync;
				break;
	
			case SdNetwork:
				WhichIcon = CurrentWinStation ? m_idxCurrentNet : m_idxNet;
				break;

			default:
				WhichIcon = CurrentWinStation ? m_idxCurrentConsole : m_idxConsole;
				break;
		}
	}

	//////////////////////
	// Fill in the columns
	//////////////////////
	LockListControl();

	int item;
	// WinStation Name
	if(pWinStation->GetName()[0])
		item = m_StationList.InsertItem(m_StationList.GetItemCount(), pWinStation->GetName(), WhichIcon);
	else {
		CString NameString(" ");
		if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
		if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
		item = m_StationList.InsertItem(m_StationList.GetItemCount(), NameString, WhichIcon);
	}

	// User
	m_StationList.SetItemText(item, WS_COL_USER, pWinStation->GetUserName());

	// Logon ID
	CString ColumnString;
	ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
	m_StationList.SetItemText(item, WS_COL_ID, ColumnString);

	// Connect State
	m_StationList.SetItemText(item, WS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

	// Type
	m_StationList.SetItemText(item, WS_COL_TYPE, pWinStation->GetWdName());

	// Client Name
	m_StationList.SetItemText(item, WS_COL_CLIENTNAME, pWinStation->GetClientName());

	// Idle Time
	TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

	ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

	if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
	{
		ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
	}
	else wcscpy(IdleTimeString, TEXT("."));

	m_StationList.SetItemText(item, WS_COL_IDLETIME, IdleTimeString);

	// Logon Time
	TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
	// We don't want to pass a 0 logon time to DateTimeString()
	// It will blow up if the timezone is GMT
	if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
		DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
		pDoc->FixUnknownString(LogonTimeString);
	}
	else LogonTimeString[0] = '\0';

	m_StationList.SetItemText(item, WS_COL_LOGONTIME, LogonTimeString);

	// Comment
	m_StationList.SetItemText(item, WS_COL_COMMENT, pWinStation->GetComment());

	// Attach a pointer to the CWinStation structure to the list item
	m_StationList.SetItemData(item, (DWORD_PTR)pWinStation);

    // m_StationList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

	UnlockListControl();
	return item;

}  // end CServerWinStationsPage::AddWinStationToList


/////////////////////////////////////
// F'N: CServerWinStationsPage::DisplayStations
//
void CServerWinStationsPage::DisplayStations()
{
	LockListControl();

	// Clear out the list control
	m_StationList.DeleteAllItems();

	m_pServer->LockWinStationList();
	// Get a pointer to this server's list of WinStations
	CObList *pWinStationList = m_pServer->GetWinStationList();

	// Iterate through the WinStation list
	POSITION pos2 = pWinStationList->GetHeadPosition();

	while(pos2) {
		CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos2);

		AddWinStationToList(pWinStation);
	}
    
    //bug #191727
    //m_StationList.SetItemState( m_StationList.GetItemCount() - 1 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

    // We don't want the same order as the tree list, but an alphabetical order instead
	SortByColumn(VIEW_SERVER, PAGE_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);

	m_pServer->UnlockWinStationList();

	UnlockListControl();

}  // end CServerWinStationsPage::DisplayStations


//////////////////////////////
// F'N: CServerWinStationsPage::OnColumnClick
//
void CServerWinStationsPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	LockListControl();
	SortByColumn(VIEW_SERVER, PAGE_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);
	UnlockListControl();

	*pResult = 0;

}  // end CServerWinStationsPage::OnColumnClick


//////////////////////////////
// F'N: CServerWinStationsPage::OnContextMenu
//
void CServerWinStationsPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen) 
{
	// TODO: Add your message handler code here
	UINT flags;
	UINT Item;
	CPoint ptClient = ptScreen;
	ScreenToClient(&ptClient);

	// If we got here from the keyboard,
	if(ptScreen.x == -1 && ptScreen.y == -1) {
		
		UINT iCount = m_StationList.GetItemCount( );
		
		RECT rc;

		for( Item = 0 ; Item < iCount ; Item++ )
		{
			if( m_StationList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
			{
				m_StationList.GetItemRect( Item , &rc , LVIR_ICON );

				ptScreen.x = rc.left;

				ptScreen.y = rc.bottom + 5;

				ClientToScreen( &ptScreen );

				break;
			}
		}

		if(ptScreen.x == -1 && ptScreen.y == -1) 
		{
			return;
		}
		/*
		RECT rect;
		m_StationList.GetClientRect(&rect);
		ptScreen.x = (rect.right - rect.left) / 2;
		ptScreen.y = (rect.bottom - rect.top) / 2;
		ClientToScreen(&ptScreen);
		*/
	}
	else {
		Item = m_StationList.HitTest(ptClient, &flags);
		if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
			return;
	}

	CMenu menu;
	menu.LoadMenu(IDR_WINSTATION_POPUP);
	menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
			TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
	menu.DestroyMenu();
	
}  // end CServerWinStationsPage::OnContextMenu

/////////////////////////////////////
// F'N: CServerWinStationsPage::ClearSelections
//
void CServerWinStationsPage::ClearSelections()
{
    
    if(m_StationList.m_hWnd != NULL)
    {
        POSITION pos = m_StationList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nItem = m_StationList.GetNextSelectedItem(pos);
            m_StationList.SetItemState(nItem,0,LVIS_SELECTED);
        }
    }
}

//////////////////////////////////
// MESSAGE MAP: CServerProcessesPage
//
IMPLEMENT_DYNCREATE(CServerProcessesPage, CFormView)

BEGIN_MESSAGE_MAP(CServerProcessesPage, CFormView)
	//{{AFX_MSG_MAP(CServerProcessesPage)
		ON_WM_SIZE()
		ON_NOTIFY(LVN_COLUMNCLICK, IDC_PROCESS_LIST, OnColumnClick)
		ON_NOTIFY(LVN_ITEMCHANGED, IDC_PROCESS_LIST, OnProcessItemChanged)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(NM_SETFOCUS, IDC_PROCESS_LIST, OnSetfocusProcessList)
    //ON_NOTIFY(NM_KILLFOCUS, IDC_PROCESS_LIST, OnKillfocusProcessList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


///////////////////////////////
// F'N: CServerProcessesPage ctor
//
CServerProcessesPage::CServerProcessesPage()
	: CAdminPage(CServerProcessesPage::IDD)
{
	//{{AFX_DATA_INIT(CServerProcessesPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pServer = NULL;
    m_bSortAscending = TRUE;

}  // end CServerProcessesPage ctor


///////////////////////////////
// F'N: CServerProcessesPage dtor
//
CServerProcessesPage::~CServerProcessesPage()
{

}  // end CServerProcessesPage dtor


//////////////////////////////////////////
// F'N: CServerProcessesPage::DoDataExchange
//
void CServerProcessesPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerProcessesPage)
	DDX_Control(pDX, IDC_PROCESS_LIST, m_ProcessList);
	//}}AFX_DATA_MAP

}  // end CServerProcessesPage::DoDataExchange


#ifdef _DEBUG
///////////////////////////////////////
// F'N: CServerProcessesPage::AssertValid
//
void CServerProcessesPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CServerProcessesPage::AssertValid


////////////////////////////////
// F'N: CServerProcessesPage::Dump
//
void CServerProcessesPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CServerProcessesPage::Dump

#endif //_DEBUG


///////////////////////////////
// F'N: CServerProcessesPage::Reset
//
void CServerProcessesPage::Reset(void *pServer)
{
	m_pServer = (CServer*)pServer;
	m_pServer->EnumerateProcesses();
	DisplayProcesses();

}  // end CServerProcessesPage::Reset


///////////////////////////////
// F'N: CServerProcessesPage::OnSize
//
void CServerProcessesPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	rect.top += LIST_TOP_OFFSET;

	if(m_ProcessList.GetSafeHwnd())
		m_ProcessList.MoveWindow(&rect, TRUE);

	// CFormView::OnSize(nType, cx, cy);

}  // end CServerProcessesPage::OnSize


static ColumnDef ProcColumns[] = {
	CD_USER,
	CD_SESSION,
	CD_PROC_ID,
	CD_PROC_PID,
	CD_PROC_IMAGE
};

#define NUM_PROC_COLUMNS sizeof(ProcColumns)/sizeof(ColumnDef)

///////////////////////////////
// F'N: CServerProcessesPage::OnInitialUpdate
//
void CServerProcessesPage::OnInitialUpdate() 
{
	// Call the parent class
	CFormView::OnInitialUpdate();

	// Add the column headings
	CString columnString;

	for(int col = 0; col < NUM_PROC_COLUMNS; col++) {
		columnString.LoadString(ProcColumns[col].stringID);
		m_ProcessList.InsertColumn(col, columnString, ProcColumns[col].format, ProcColumns[col].width, col);
	}

	m_CurrentSortColumn = PROC_COL_USER;

}  // end CServerProcessesPage::OnInitialUpdate


///////////////////////////////
// F'N: CServerProcessesPage::UpdateProcesses
//
void CServerProcessesPage::UpdateProcesses()
{
	CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
	BOOL bAnyChanged = FALSE;
	BOOL bAnyAdded = FALSE;

	LockListControl();

	// Loop through the processes
	m_pServer->LockProcessList();
	CObList *pProcessList = m_pServer->GetProcessList();

	POSITION pos = pProcessList->GetHeadPosition();

	while(pos) {
		CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

		// If this is a 'system' process and we aren't currently showing them,
		// go to the next process
		if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
			continue;

		// If this user is not an Admin, don't show him someone else's processes unless it
		// is a System process
		if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers() && !pProcess->IsSystemProcess())
			continue;

		// If the process is new, add it to the list
		if(pProcess->IsNew()) {

			AddProcessToList(pProcess);
			bAnyAdded = TRUE;
			continue;
		}

		LV_FINDINFO FindInfo;
		FindInfo.flags = LVFI_PARAM;
		FindInfo.lParam = (LPARAM)pProcess;

		// Find the Process in our list
		int item = m_ProcessList.FindItem(&FindInfo, -1);

		// If the process is no longer current,
		// remove it from the list
		if(!pProcess->IsCurrent() && item != -1) {
			// Remove the Process from the list
			m_ProcessList.DeleteItem(item);
			pProcess->ClearSelected();
		}

   		// If the process info has changed, change
		// it's info in our tree
		if(pProcess->IsChanged() && item != -1) 
		{
			// WinStation Name
			CWinStation *pWinStation = pProcess->GetWinStation();
			if(pWinStation)
			{
				if(pWinStation->GetName()[0])
					m_ProcessList.SetItemText(item, PROC_COL_WINSTATION, pWinStation->GetName());
				else
				{
					CString NameString(" ");
					if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
					if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
					m_ProcessList.SetItemText(item, PROC_COL_WINSTATION, NameString);
				}
			}

			if(m_CurrentSortColumn == PROC_COL_WINSTATION)
				bAnyChanged = TRUE;
		}
	}

	m_pServer->UnlockProcessList();

	if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_SERVER, PAGE_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);

	UnlockListControl();

}  // end CServerProcessesPage::UpdateProcesses


//////////////////////////////////////////
// F'N: CServerProcessesPage::RemoveProcess
//
void CServerProcessesPage::RemoveProcess(CProcess *pProcess)
{
	ASSERT(pProcess);

    // If the server isn't the server the process is running on,
	// there's nothing to do        
    if(m_pServer != pProcess->GetServer()) return;

	LockListControl();

	// Find out how many items in the list
	int ItemCount = m_ProcessList.GetItemCount();

	// Go through the items and remove this process
	for(int item = 0; item < ItemCount; item++) {
		CProcess *pListProcess = (CProcess*)m_ProcessList.GetItemData(item);
		
		if(pListProcess == pProcess) {
			m_ProcessList.DeleteItem(item);
			break;
		}
	}

	UnlockListControl();
}

///////////////////////////////
// F'N: CServerProcessesPage::AddProcessToList
//
int CServerProcessesPage::AddProcessToList(CProcess *pProcess)
{
	CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();

	LockListControl();
	// User - put at the end of the list
	int item = m_ProcessList.InsertItem(m_ProcessList.GetItemCount(), pProcess->GetUserName(), NULL);

	// WinStation Name
	CWinStation *pWinStation = pProcess->GetWinStation();
	if(pWinStation) {
		if(pWinStation->GetName()[0])
		    m_ProcessList.SetItemText(item, PROC_COL_WINSTATION, pWinStation->GetName());
		else {
			CString NameString(" ");
			if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
			if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
		    m_ProcessList.SetItemText(item, PROC_COL_WINSTATION, NameString);
		}
	}
	
	// ID
	CString ProcString;
	ProcString.Format(TEXT("%lu"), pProcess->GetLogonId());
	m_ProcessList.SetItemText(item, PROC_COL_ID, ProcString);

	// PID
	ProcString.Format(TEXT("%lu"), pProcess->GetPID());
	m_ProcessList.SetItemText(item, PROC_COL_PID, ProcString);

	// Image
	m_ProcessList.SetItemText(item, PROC_COL_IMAGE, pProcess->GetImageName());

	m_ProcessList.SetItemData(item, (DWORD_PTR)pProcess);

    // m_ProcessList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

	UnlockListControl();

	return item;

}  // end CServerProcessesPage::AddProcessToList


///////////////////////////////
// F'N: CServerProcessesPage::DisplayProcesses
//
void CServerProcessesPage::DisplayProcesses()
{
	CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();

	LockListControl();

	// Clear out the list control
	m_ProcessList.DeleteAllItems();

	m_pServer->LockProcessList();
	CObList *pProcessList = m_pServer->GetProcessList();

	POSITION pos = pProcessList->GetHeadPosition();

	while(pos) {
		CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

		// If this is a 'system' process and we aren't currently showing them,
		// go to the next process
		if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
			continue;

		// If this user is not an Admin, don't show him someone else's processes unless it is
		// a System process
		if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers() && !pProcess->IsSystemProcess())
			continue;

		AddProcessToList(pProcess);
	}

    m_ProcessList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );
	
	m_pServer->UnlockProcessList();

	SortByColumn(VIEW_SERVER, PAGE_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);

	UnlockListControl();

}  // end CServerProcessesPage::DisplayProcesses


///////////////////////////////
// F'N: CServerProcessesPage::OnProcessItemChanged
//
void CServerProcessesPage::OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;

	if(pLV->uNewState & LVIS_SELECTED) {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
		pProcess->SetSelected();
	}
	
	if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
		pProcess->ClearSelected();
	}

	*pResult = 0;

}  // end CServerProcessesPage::OnProcessItemChanged


///////////////////////////////
// F'N: CServerProcessesPage::OnColumnClick
//
void CServerProcessesPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	LockListControl();
	SortByColumn(VIEW_SERVER, PAGE_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);
	UnlockListControl();

	*pResult = 0;

}  // end CServerProcessesPage::OnColumnClick


//////////////////////////////
// F'N: CServerProcessesPage::OnContextMenu
//
void CServerProcessesPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen) 
{
	// TODO: Add your message handler code here
	UINT flags;
	UINT Item;
	CPoint ptClient = ptScreen;
	ScreenToClient(&ptClient);

	// If we got here from the keyboard,
	if(ptScreen.x == -1 && ptScreen.y == -1) {
		
		UINT iCount = m_ProcessList.GetItemCount( );
		
		RECT rc;

		for( Item = 0 ; Item < iCount ; Item++ )
		{
			if( m_ProcessList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
			{
				m_ProcessList.GetItemRect( Item , &rc , LVIR_ICON );

				ptScreen.x = rc.left;

				ptScreen.y = rc.bottom + 5;

				ClientToScreen( &ptScreen );

				break;
			}
		}

		if(ptScreen.x == -1 && ptScreen.y == -1) 
		{
			return;
		}
		
		/*
		RECT rect;
		m_ProcessList.GetClientRect(&rect);
		ptScreen.x = (rect.right - rect.left) / 2;
		ptScreen.y = (rect.bottom - rect.top) / 2;
		ClientToScreen(&ptScreen);
		*/
	}
	else {
		Item = m_ProcessList.HitTest(ptClient, &flags);
		if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
			return;
	}

	CMenu menu;
	menu.LoadMenu(IDR_PROCESS_POPUP);
	menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
			TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
	menu.DestroyMenu();
	
}  // end CServerProcessesPage::OnContextMenu


////////////////////////////////
// MESSAGE MAP: CServerLicensesPage
//
IMPLEMENT_DYNCREATE(CServerLicensesPage, CFormView)

BEGIN_MESSAGE_MAP(CServerLicensesPage, CFormView)
	//{{AFX_MSG_MAP(CServerLicensesPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LICENSE_LIST, OnColumnClick)
	ON_NOTIFY(NM_SETFOCUS, IDC_LICENSE_LIST, OnSetfocusLicenseList)
    //ON_NOTIFY(NM_KILLFOCUS, IDC_LICENSE_LIST, OnKillfocusLicenseList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CServerLicensesPage ctor
//
CServerLicensesPage::CServerLicensesPage()
	: CAdminPage(CServerLicensesPage::IDD)
{
	//{{AFX_DATA_INIT(CServerLicensesPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pServer = NULL;
    m_bSortAscending = TRUE;

}  // end CServerLicensesPage ctor


/////////////////////////////
// F'N: CServerLicensesPage dtor
//
CServerLicensesPage::~CServerLicensesPage()
{
}  // end CServerLicensesPage dtor


////////////////////////////////////////
// F'N: CServerLicensesPage::DoDataExchange
//
void CServerLicensesPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerLicensesPage)
	DDX_Control(pDX, IDC_LICENSE_LIST, m_LicenseList);
	//}}AFX_DATA_MAP

}  // end CServerLicensesPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CServerLicensesPage::AssertValid
//
void CServerLicensesPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CServerLicensesPage::AssertValid


//////////////////////////////
// F'N: CServerLicensesPage::Dump
//
void CServerLicensesPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CServerLicensesPage::Dump
#endif //_DEBUG


/////////////////////////////
// F'N: CServerLicensesPage::OnSize
//
void CServerLicensesPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetWindowRect(&rect);

	CWnd *pWnd = GetDlgItem(IDC_LOCAL_AVAILABLE);
	if(pWnd) {
		RECT rect2;
		pWnd->GetWindowRect(&rect2);
		rect.top = rect2.bottom + 5;
	}

	ScreenToClient(&rect);
	if(m_LicenseList.GetSafeHwnd())
		m_LicenseList.MoveWindow(&rect, TRUE);

	// CFormView::OnSize(nType, cx, cy);
}  // end CServerLicensesPage::OnSize


static ColumnDef LicenseColumns[] = {
	CD_LICENSE_DESC,
	CD_LICENSE_REG,
	CD_USERCOUNT,
	CD_POOLCOUNT,
	CD_LICENSE_NUM
};

#define NUM_LICENSE_COLUMNS sizeof(LicenseColumns)/sizeof(ColumnDef)

/////////////////////////////
// F'N: CServerLicensesPage::OnInitialUpdate
//
void CServerLicensesPage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

	BuildImageList();		// builds the image list for the list control

	CString columnString;

	for(int col = 0; col < NUM_LICENSE_COLUMNS; col++) {
		columnString.LoadString(LicenseColumns[col].stringID);
		m_LicenseList.InsertColumn(col, columnString, LicenseColumns[col].format, LicenseColumns[col].width, col);
	}

	m_CurrentSortColumn = LICENSE_COL_DESCRIPTION;

}  // end CServerLicensesPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CServerLicensePage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CServerLicensesPage::BuildImageList()
{
	m_ImageList.Create(16, 16, TRUE, 5, 0);

	m_idxBase = AddIconToImageList(IDI_BASE);
	m_idxBump = AddIconToImageList(IDI_BUMP);
	m_idxEnabler = AddIconToImageList(IDI_ENABLER);
	m_idxUnknown = AddIconToImageList(IDI_UNKNOWN);
	m_idxBlank = AddIconToImageList(IDI_BLANK);

	m_LicenseList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CServerLicensesPage::BuildImageList


/////////////////////////////////////////
// F'N: CServerLicensesPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CServerLicensesPage::AddIconToImageList(int iconID)
{
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
	return m_ImageList.Add(hIcon);

}  // end CServerLicensesPage::AddIconToImageList


/////////////////////////////
// F'N: CServerLicensesPage::Reset
//
void CServerLicensesPage::Reset(void *pServer)
{
	m_pServer = (CServer*)pServer;
	DisplayLicenseCounts();
	DisplayLicenses();

}  // end CServerLicensesPage::Reset


/////////////////////////////////////
// F'N: CServerLicensesPage::DisplayLicenseCounts
//
void CServerLicensesPage::DisplayLicenseCounts()
{
	// Fill in the static text fields
	CString LicenseString;

	if(m_pServer->IsWinFrame()) {
		// If the user is not an admin, the values are garbage (show N/A)
		CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
		if(!((CWinAdminApp*)AfxGetApp())->IsUserAdmin()) {
			LicenseString.LoadString(IDS_NOT_APPLICABLE);
			SetDlgItemText(IDC_LOCAL_INSTALLED, LicenseString);        
			SetDlgItemText(IDC_LOCAL_INUSE, LicenseString);
			SetDlgItemText(IDC_LOCAL_AVAILABLE, LicenseString);
			SetDlgItemText(IDC_POOL_INSTALLED, LicenseString);
			SetDlgItemText(IDC_POOL_INUSE, LicenseString);
			SetDlgItemText(IDC_POOL_AVAILABLE, LicenseString);
			SetDlgItemText(IDC_TOTAL_INSTALLED, LicenseString);
			SetDlgItemText(IDC_TOTAL_INUSE, LicenseString);
			SetDlgItemText(IDC_TOTAL_AVAILABLE, LicenseString);
		} else {
			ExtServerInfo *pExtServerInfo = m_pServer->GetExtendedInfo();
			if(pExtServerInfo) {
				BOOL bUnlimited = FALSE;
				if((pExtServerInfo->Flags & ESF_UNLIMITED_LICENSES) > 0) {
					bUnlimited = TRUE;
				}

				if(bUnlimited)
					LicenseString.LoadString(IDS_UNLIMITED);
				else
					LicenseString.Format(TEXT("%lu"), pExtServerInfo->ServerLocalInstalled);
				SetDlgItemText(IDC_LOCAL_INSTALLED, LicenseString);
				LicenseString.Format(TEXT("%lu"), pExtServerInfo->ServerLocalInUse);
				SetDlgItemText(IDC_LOCAL_INUSE, LicenseString);

				if(bUnlimited) {
					LicenseString.LoadString(IDS_UNLIMITED);
					SetDlgItemText(IDC_LOCAL_AVAILABLE, LicenseString);
					SetDlgItemText(IDC_TOTAL_INSTALLED, LicenseString);
					SetDlgItemText(IDC_TOTAL_AVAILABLE, LicenseString);

					LicenseString.LoadString(IDS_NOT_APPLICABLE);
					SetDlgItemText(IDC_POOL_INSTALLED, LicenseString);
					SetDlgItemText(IDC_POOL_INUSE, LicenseString);
					SetDlgItemText(IDC_POOL_AVAILABLE, LicenseString);
					
				} else {
					LicenseString.Format(TEXT("%lu"), pExtServerInfo->ServerLocalAvailable);
					SetDlgItemText(IDC_LOCAL_AVAILABLE, LicenseString);
					LicenseString.Format(TEXT("%lu"), pExtServerInfo->ServerPoolInstalled);
					SetDlgItemText(IDC_POOL_INSTALLED, LicenseString);
					LicenseString.Format(TEXT("%lu"), pExtServerInfo->ServerPoolInUse);
					SetDlgItemText(IDC_POOL_INUSE, LicenseString);
					LicenseString.Format(TEXT("%lu"), pExtServerInfo->ServerPoolAvailable);
					SetDlgItemText(IDC_POOL_AVAILABLE, LicenseString);
					LicenseString.Format(TEXT("%lu"), 
						pExtServerInfo->ServerPoolInstalled + pExtServerInfo->ServerLocalInstalled);
					SetDlgItemText(IDC_TOTAL_INSTALLED, LicenseString);
					LicenseString.Format(TEXT("%lu"), 
						pExtServerInfo->ServerPoolAvailable + pExtServerInfo->ServerLocalAvailable);
					SetDlgItemText(IDC_TOTAL_AVAILABLE, LicenseString);
				}

				LicenseString.Format(TEXT("%lu"), 
					pExtServerInfo->ServerPoolInUse + pExtServerInfo->ServerLocalInUse);
				SetDlgItemText(IDC_TOTAL_INUSE, LicenseString);
			}
		}
	}

}  // end CServerLicensesPage::DisplayLicenseCounts()


/////////////////////////////////////
// F'N: CServerLicensesPage::DisplayLicenses
//
void CServerLicensesPage::DisplayLicenses()
{
	// Clear out the list control
	m_LicenseList.DeleteAllItems();

	if(m_pServer->IsWinFrame()) {
		ExtServerInfo *pExtServerInfo = m_pServer->GetExtendedInfo();
		if(pExtServerInfo && ((pExtServerInfo->Flags & ESF_NO_LICENSE_PRIVILEGES) > 0)) {
    		CString AString;
	    	AString.LoadString(IDS_NO_LICENSE_PRIVILEGES);
		    m_LicenseList.InsertItem(0, AString, m_idxBlank);
		    return;
	    }
    }

	m_pServer->LockLicenseList();
	// Get a pointer to this server's list of Licenses
	CObList *pLicenseList = m_pServer->GetLicenseList();

	// Iterate through the License list
	POSITION pos = pLicenseList->GetHeadPosition();

	while(pos) {
		CLicense *pLicense = (CLicense*)pLicenseList->GetNext(pos);

		//////////////////////
		// Fill in the columns
		//////////////////////
		int WhichIcon;

		switch(pLicense->GetClass()) {
			case LicenseBase:
				WhichIcon = m_idxBase;
				break;
			case LicenseBump:
				WhichIcon = m_idxBump;
				break;
			case LicenseEnabler:
				WhichIcon = m_idxEnabler;
				break;
			case LicenseUnknown:
				WhichIcon = m_idxUnknown;
				break;
		}

		// License Description
		int item = m_LicenseList.InsertItem(m_LicenseList.GetItemCount(), pLicense->GetDescription(), WhichIcon);

		// Registered
		CString RegString;
		RegString.LoadString(pLicense->IsRegistered() ? IDS_YES : IDS_NO);
		m_LicenseList.SetItemText(item, LICENSE_COL_REGISTERED, RegString);

		BOOL bUnlimited = (pLicense->GetClass() == LicenseBase
			&& pLicense->GetTotalCount() == 4095
			&& m_pServer->GetCTXVersionNum() == 0x00000040);

		// User (Total)  Count
		CString CountString;
		if(bUnlimited)
			CountString.LoadString(IDS_UNLIMITED);
		else
			CountString.Format(TEXT("%lu"), pLicense->GetTotalCount());
		m_LicenseList.SetItemText(item, LICENSE_COL_USERCOUNT, CountString);

		// Pool Count
		if(bUnlimited)
			CountString.LoadString(IDS_NOT_APPLICABLE);
		else
			CountString.Format(TEXT("%lu"), pLicense->GetPoolCount());
		m_LicenseList.SetItemText(item, LICENSE_COL_POOLCOUNT, CountString);

		// License Number
		m_LicenseList.SetItemText(item, LICENSE_COL_NUMBER, pLicense->GetLicenseNumber());

		m_LicenseList.SetItemData(item, (DWORD_PTR)pLicense);
	}	// end while(pos)

	m_pServer->UnlockLicenseList();

}  // end CServerLicensesPage::DisplayLicenses


/////////////////////////////
// F'N: CServerLicensesPage::OnColumnClick
//
void CServerLicensesPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	SortByColumn(VIEW_SERVER, PAGE_LICENSES, &m_LicenseList, m_CurrentSortColumn, m_bSortAscending);

	*pResult = 0;

}  // end CServerLicensesPage::OnColumnClick


////////////////////////////////
// MESSAGE MAP: CServerInfoPage
//
IMPLEMENT_DYNCREATE(CServerInfoPage, CFormView)

BEGIN_MESSAGE_MAP(CServerInfoPage, CFormView)
	//{{AFX_MSG_MAP(CServerInfoPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_HOTFIX_LIST, OnColumnClick)
	ON_NOTIFY(NM_SETFOCUS, IDC_HOTFIX_LIST, OnSetfocusHotfixList)
    //ON_NOTIFY(NM_KILLFOCUS, IDC_HOTFIX_LIST, OnKillfocusHotfixList)
	ON_COMMAND(ID_HELP1, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CServerInfoPage ctor
//
CServerInfoPage::CServerInfoPage()
	: CAdminPage(CServerInfoPage::IDD)
{
	//{{AFX_DATA_INIT(CServerInfoPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pServer = NULL;
    m_bSortAscending = TRUE;

}  // end CUsersPage ctor


/////////////////////////////
// F'N: CServerInfoPage dtor
//
CServerInfoPage::~CServerInfoPage()
{

}  // end CServerInfoPage dtor


////////////////////////////////////////
// F'N: CServerInfoPage::DoDataExchange
//
void CServerInfoPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerInfoPage)
	DDX_Control(pDX, IDC_HOTFIX_LIST, m_HotfixList);	
	//}}AFX_DATA_MAP

}  // end CServerInfoPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CServerInfoPage::AssertValid
//
void CServerInfoPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CServerInfoPage::AssertValid


//////////////////////////////
// F'N: CServerInfoPage::Dump
//
void CServerInfoPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CServerInfoPage::Dump

#endif //_DEBUG


/////////////////////////////
// F'N: CServerInfoPage::OnSize
//
void CServerInfoPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetWindowRect(&rect);

	int control = IDC_HOTFIX_LABEL;
	
	if(m_pServer && m_pServer->IsWinFrame()) control = IDC_HOTFIX_LABEL2;

	CWnd *pWnd = GetDlgItem(control);
	if(pWnd) {
		RECT rect2;
		pWnd->GetWindowRect(&rect2);
		rect.top = rect2.bottom + 5;
	}

	ScreenToClient(&rect);

	if(m_HotfixList.GetSafeHwnd())
		m_HotfixList.MoveWindow(&rect, TRUE);

	// CFormView::OnSize(nType, cx, cy);

}  // end CServerInfoPage::OnSize


/////////////////////////////
// F'N: CServerInfoPage::OnCommandHelp
//
void CServerInfoPage::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CServerInfoPage::IDD + HID_BASE_RESOURCE);

} // CServerInfoPage::OnCommandHelp


static ColumnDef HotfixColumns[] = {
	CD_HOTFIX,
	CD_INSTALLED_BY,
	CD_INSTALLED_ON
};

#define NUM_HOTFIX_COLUMNS sizeof(HotfixColumns)/sizeof(ColumnDef)

/////////////////////////////
// F'N: CServerInfoPage::OnInitialUpdate
//
void CServerInfoPage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

	BuildImageList();

	CString columnString;

	for(int col = 0; col < NUM_HOTFIX_COLUMNS; col++) {
		columnString.LoadString(HotfixColumns[col].stringID);
		m_HotfixList.InsertColumn(col, columnString, HotfixColumns[col].format, HotfixColumns[col].width, col);
	}

	m_CurrentSortColumn = HOTFIX_COL_NAME;

}  // end CServerInfoPage::OnInitialUpdate


/////////////////////////////
// F'N: CServerInfoPage::BuildImageList
//
void CServerInfoPage::BuildImageList()
{
	m_StateImageList.Create(16, 16, TRUE, 1, 0);
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(IDI_NOTSIGN));
	m_StateImageList.Add(hIcon);

    if( hIcon != NULL )
    {
        m_HotfixList.SetImageList(&m_StateImageList, LVSIL_STATE);
    }

}  // end CServerInfoPage::BuildImageList


/////////////////////////////
// F'N: CServerInfoPage::Reset
//
void CServerInfoPage::Reset(void *pServer)
{
	m_pServer = (CServer*)pServer;
	int control = IDC_HOTFIX_LABEL;
	// If the server is a WinFrame server,
	// we want to show the load balancing stuff and
	// make the hotfix list smaller
	if(m_pServer && m_pServer->IsWinFrame()) {
		GetDlgItem(IDC_LOAD_BALANCING_GROUP)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_TCP_LABEL)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_TCP_LOAD)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_IPX_LABEL)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_IPX_LOAD)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_NETBIOS_LABEL)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_NETBIOS_LOAD)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_HOTFIX_LABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_HOTFIX_LABEL2)->ShowWindow(SW_SHOW);
		control = IDC_HOTFIX_LABEL2;
	} else {
		GetDlgItem(IDC_LOAD_BALANCING_GROUP)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TCP_LABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TCP_LOAD)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_IPX_LABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_IPX_LOAD)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_NETBIOS_LABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_NETBIOS_LOAD)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_HOTFIX_LABEL)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_HOTFIX_LABEL2)->ShowWindow(SW_HIDE);
	}

	// Resize the list control
	RECT rect;
	GetWindowRect(&rect);

	CWnd *pWnd = GetDlgItem(control);
	if(pWnd) {
		RECT rect2;
		pWnd->GetWindowRect(&rect2);
		rect.top = rect2.bottom + 5;
	}

	ScreenToClient(&rect);

	if(m_HotfixList.GetSafeHwnd())
		m_HotfixList.MoveWindow(&rect, TRUE);

	Invalidate();

	DisplayInfo();

}  // end CServerInfoPage::Reset


/////////////////////////////
// F'N: CServerInfoPage::OnColumnClick
//
void CServerInfoPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	SortByColumn(VIEW_SERVER, PAGE_INFO, &m_HotfixList, m_CurrentSortColumn, m_bSortAscending);

	*pResult = 0;

} // end CServerInfoPage::OnColumnClick

void CServerInfoPage::TSAdminDateTimeString(
    LONG   InstallDate,
    LPTSTR TimeString,
    BOOL   LongDate
    )
{
    // 
    // buffer is wide enough
    CTime tmpTime((time_t) InstallDate);
    SYSTEMTIME stime;       

    // Why not use GetAsSystemTime method ?

	stime.wYear =   (WORD)tmpTime.GetYear( ) ;
	stime.wMonth =  (WORD)tmpTime.GetMonth( ) ;
	stime.wDayOfWeek = (WORD)tmpTime.GetDayOfWeek( ) ;
	stime.wDay =    (WORD)tmpTime.GetDay( ) ;
	stime.wHour =   (WORD)tmpTime.GetHour( ) ;
	stime.wMinute = (WORD)tmpTime.GetMinute( ) ;
	stime.wSecond = (WORD)tmpTime.GetSecond( ) ;

    LPTSTR lpTimeStr;	
    int nLen;			

	//Get DateFormat
    nLen = GetDateFormat(
			LOCALE_USER_DEFAULT,
			LongDate ? DATE_LONGDATE : DATE_SHORTDATE,
			&stime,
			NULL,
			NULL,
			0);
	lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));

    if( lpTimeStr != NULL )
    {
	    nLen = GetDateFormat(
			    LOCALE_USER_DEFAULT,
			    LongDate ? DATE_LONGDATE : DATE_SHORTDATE,
			    &stime,
			    NULL,
			    lpTimeStr,
			    nLen);
	    wcscpy(TimeString, lpTimeStr);
	    wcscat(TimeString, L" ");	
	    GlobalFree(lpTimeStr);
        lpTimeStr = NULL;
		    
	    //Get Time Format
	    nLen = GetTimeFormat(
			    LOCALE_USER_DEFAULT,
			    NULL,
			    &stime,
			    NULL,
			    NULL,
			    0);
	    lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));

        if( lpTimeStr != NULL )
        {
	        nLen = GetTimeFormat(
			        LOCALE_USER_DEFAULT,
			        NULL,
			        &stime,
			        NULL,
			        lpTimeStr,
			        nLen);
	        wcscat(TimeString, lpTimeStr);
	        GlobalFree(lpTimeStr);
        }
    }
}

#define PST 60*60*8

/////////////////////////////////////
// F'N: CServerInfoPage::DisplayInfo
//
void CServerInfoPage::DisplayInfo()
{
	m_HotfixList.DeleteAllItems();

	if(!m_pServer->IsRegistryInfoValid()) {
		if(!m_pServer->BuildRegistryInfo()) return;
	}

	CString InfoString, FormatString;

    FormatString.LoadString(IDS_PRODUCT_VERSION);

    if (m_pServer->GetMSVersionNum() < 5)
    {
	    SetDlgItemText(IDC_PRODUCT_NAME, m_pServer->GetCTXProductName());
	    InfoString.Format( FormatString,
                           m_pServer->GetMSVersion(),
		                   m_pServer->GetCTXBuild() );
    }
    else
    {
	    SetDlgItemText(IDC_PRODUCT_NAME, m_pServer->GetMSProductName());
	    InfoString.Format( FormatString,
                           m_pServer->GetMSVersion(),
		                   m_pServer->GetMSBuild() );
    }

	SetDlgItemText(IDC_PRODUCT_VERSION, InfoString);

	LONG InstallDate = (LONG)m_pServer->GetInstallDate();

    if (InstallDate != 0xFFFFFFFF)
    {
        // The install date in the registry appears to be saved in
        // Pacific Standard Time.  Subtract the difference between the
        // current time zone and PST from the install date
        InstallDate -= (PST - _timezone);

        TCHAR TimeString[MAX_DATE_TIME_LENGTH];

        TSAdminDateTimeString(InstallDate, TimeString);

        SetDlgItemText(IDC_INSTALL_DATE, TimeString);
    }
	SetDlgItemText(IDC_SERVICE_PACK, m_pServer->GetServicePackLevel());

	if(m_pServer->IsWinFrame()) {
		ExtServerInfo *pExtServerInfo = m_pServer->GetExtendedInfo();
		if(pExtServerInfo && ((pExtServerInfo->Flags & ESF_LOAD_BALANCING) > 0)) {
			GetDlgItem(IDC_TCP_LABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_IPX_LABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_NETBIOS_LABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_TCP_LOAD)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_NETBIOS_LOAD)->ShowWindow(SW_SHOW);

			CString LoadLevelString;
			if(pExtServerInfo->TcpLoadLevel == 0xFFFFFFFF) {
				LoadLevelString.LoadString(IDS_NOT_APPLICABLE);
			}
			else LoadLevelString.Format(TEXT("%lu"), pExtServerInfo->TcpLoadLevel);
			SetDlgItemText(IDC_TCP_LOAD, LoadLevelString);

			if(pExtServerInfo->IpxLoadLevel == 0xFFFFFFFF) {
				LoadLevelString.LoadString(IDS_NOT_APPLICABLE);
			}
			else LoadLevelString.Format(TEXT("%lu"), pExtServerInfo->IpxLoadLevel);
			SetDlgItemText(IDC_IPX_LOAD, LoadLevelString);

			if(pExtServerInfo->NetbiosLoadLevel == 0xFFFFFFFF) {
				LoadLevelString.LoadString(IDS_NOT_APPLICABLE);
			}
			else LoadLevelString.Format(TEXT("%lu"), pExtServerInfo->NetbiosLoadLevel);
			SetDlgItemText(IDC_NETBIOS_LOAD, LoadLevelString);
		} else {
			GetDlgItem(IDC_TCP_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_IPX_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_NETBIOS_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_TCP_LOAD)->ShowWindow(SW_HIDE);
			CString NoString;
			NoString.LoadString(IDS_NO_LOAD_LICENSE);
			SetDlgItemText(IDC_IPX_LOAD, NoString);
			GetDlgItem(IDC_NETBIOS_LOAD)->ShowWindow(SW_HIDE);
		}
	}

	// Get a pointer to this Server's list of Hotfixes
	CObList *pHotfixList = m_pServer->GetHotfixList();

	// Iterate through the Hotfix list
	POSITION pos = pHotfixList->GetHeadPosition();

	while(pos) {
		CHotfix *pHotfix = (CHotfix*)pHotfixList->GetNext(pos);

		//////////////////////
		// Fill in the columns
		//////////////////////
			
		// Hotfix Name - put at the end of the list
		int item = m_HotfixList.InsertItem(m_HotfixList.GetItemCount(), pHotfix->m_Name, NULL);

		// If this hotfix is not marked as Valid, put a not-sign next to it's name
		if(!pHotfix->m_Valid) 
			m_HotfixList.SetItemState(item, 0x1000, 0xF000);

		// Installed by
		m_HotfixList.SetItemText(item, HOTFIX_COL_INSTALLEDBY, pHotfix->m_InstalledBy);

		// Installed on
        if (pHotfix->m_InstalledOn != 0xFFFFFFFF)
        {

            TCHAR TimeString[MAX_DATE_TIME_LENGTH];

            TSAdminDateTimeString(pHotfix->m_InstalledOn, TimeString);

            if (TimeString != NULL)     
            {
		        m_HotfixList.SetItemText(item, HOTFIX_COL_INSTALLEDON, TimeString);
            }
        }

		m_HotfixList.SetItemData(item, (DWORD_PTR)pHotfix);
	}

}  // end CServerInfoPage::DisplayInfo


void CUsersPage::OnSetfocusUserList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    ODS( L"CUsersPage::OnSetfocusUserListt\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_UserList.Invalidate();

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CServerWinStationsPage::OnSetfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    ODS( L"CServerWinStationsPage::OnSetfocusWinstationList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_StationList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}


void CServerProcessesPage::OnSetfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	ODS( L"CServerProcessesPage::OnSetfocusProcessList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_ProcessList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CServerLicensesPage::OnSetfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	ODS( L"CServerLicensesPage::OnSetfocusLicenseList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_LicenseList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CServerInfoPage::OnSetfocusHotfixList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	ODS( L"ServerInfoPage::OnSetfocusHotfixList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_HotfixList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CServerInfoPage::OnKillfocusHotfixList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	m_HotfixList.Invalidate( );

    *pResult = 0;
}

void CUsersPage::OnKillfocusUserList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_UserList.Invalidate( );
}

void CServerWinStationsPage::OnKillfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_StationList.Invalidate( );
}

void CServerProcessesPage::OnKillfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_ProcessList.Invalidate( );
}

void CServerLicensesPage::OnKillfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    *pResult = 0;

    m_LicenseList.Invalidate( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\stdafx.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include <lm.h>
#include <dsgetdc.h>


#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


#ifdef DBG

extern bool g_fDebug;

#define ODS( x ) \
    if( g_fDebug ) OutputDebugString( x );\

#define DBGMSG( x , y ) \
    {\
    TCHAR tchErr[260]; \
    if( g_fDebug ){ \
    wsprintf( tchErr , x , y ); \
    ODS( tchErr ); \
    }\
    }\

#define DBGMSGx( x , y , z ) \
    {\
    TCHAR tchErr[ 260 ]; \
    if( g_fDebug ){ \
    wsprintf( tchErr , x , y , z ); \
    ODS( tchErr ); \
    }\
    }\

#else
#define ODS
#define DBGMSG
#define DBGMSGx
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\stdafx.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//	WinAdmin.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\threads.h ===
/*******************************************************************************
*
* threads.h
*
* declarations of the thread classes
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\THREADS.H  $
*  
*     Rev 1.0   30 Jul 1997 17:12:48   butchd
*  Initial revision.
*
*******************************************************************************/

////////////////////////////////////////////////////////////////////////////////
// CThread class
//
class CThread
{

/*
 * Member variables.
 */
protected:
    HANDLE m_hThread;
    DWORD m_dwThreadID;

/*
 * Implementation
 */
public:
    virtual ~CThread();
//    void* operator new(size_t nSize);
//    void operator delete(void* p);
protected:
    CThread();
    static DWORD __stdcall ThreadEntryPoint(LPVOID lpParam);
    virtual DWORD RunThread() = 0;

/*
 * Operations: primary thread
 */
public:
    HANDLE CreateThread( DWORD cbStack = 0,
                         DWORD fdwCreate = 0 );

};  // end CThread class interface
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// CWSStatusThread structures, defines, and typedefs
//
#define MAX_STATUS_SEMAPHORE_COUNT 1
#define MAX_SLEEP_COUNT 10


////////////////////////////////////////////////////////////////////////////////
// CWSStatusThread class
//
class CWSStatusThread : public CThread
{

/*
 * Member variables.
 */
public:
    ULONG m_LogonId;
	HANDLE m_hServer;
    HWND m_hDlg;
    WINSTATIONINFORMATION m_WSInfo;
    PDCONFIG m_PdConfig;
protected:
    HANDLE m_hWakeUp;
    HANDLE m_hConsumed;
    BOOL m_bExit;

/*
 * Implementation
 */
public:
    CWSStatusThread();
protected:
    virtual ~CWSStatusThread();
    virtual DWORD RunThread();

/*
 * Operations: primary thread.
 */
public:
    void SignalWakeUp();
    void SignalConsumed();
    void ExitThread();

/*
 * Operations: secondary thread.
 */
protected:
    BOOL WSPdQuery();
    BOOL WSInfoQuery();

};  // end CWSStatusThread class interface
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\threads.cpp ===
/*******************************************************************************
*
* threads.cpp
*
* implementation of threads classes
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\winadmin\VCS\threads.cpp  $
*  
*     Rev 1.1   26 Aug 1997 19:15:14   donm
*  bug fixes/changes from WinFrame 1.7
*  
*     Rev 1.0   30 Jul 1997 17:12:44   butchd
*  Initial revision.
*  
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "threads.h"
#include "led.h"

////////////////////////////////////////////////////////////////////////////////
// CThread class construction / destruction, implementation

/*******************************************************************************
 *
 *  CThread - CThread constructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CThread::CThread()
{
    m_hThread = NULL;
    m_dwThreadID = 0;

}  // end CThread::CThread


/*******************************************************************************
 *
 *  ~CThread - CThread destructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CThread::~CThread()
{
}  // end CThread::~CThread


/*******************************************************************************
 *
 *  operator new - CThread operator override
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/
#if 0
void *
CThread::operator new(size_t nSize)
{
    return( ::malloc(nSize) );

}  // end CThread::operator new
#endif

/*******************************************************************************
 *
 *  operator delete - CThread operator override
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/
#if 0
void
CThread::operator delete(void *p)
{
    ::free(p);

}  // end CThread::operator delete
#endif

////////////////////////////////////////////////////////////////////////////////
// CThread operations: primary thread

/*******************************************************************************
 *
 *  CreateThread - CThread implementation function
 *
 *      Class wrapper for the Win32 CreateThread API.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

HANDLE
CThread::CreateThread( DWORD cbStack,
                       DWORD fdwCreate )
{
    /*
     * Simple wrapper for Win32 CreateThread API.
     */
    return( m_hThread = ::CreateThread( NULL, cbStack, ThreadEntryPoint,
            (LPVOID)this, fdwCreate, &m_dwThreadID ) );

}  // end CThread::CreateThread


////////////////////////////////////////////////////////////////////////////////
// CThread operations: secondary thread

/*******************************************************************************
 *
 *  ThreadEntryPoint - CThread implementation function
 *                     (SECONDARY THREAD)
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

DWORD __stdcall
CThread::ThreadEntryPoint(LPVOID lpParam)
{
    CThread *pThread;
    DWORD dwResult;

    /* 
     * (lpParam is actually the 'this' pointer)
     */
    pThread = (CThread*)lpParam;
    VERIFY(pThread != NULL);

    /*
     * Run the thread.
     */
    dwResult = pThread->RunThread();

    /*
     * Return the result.
     */    
    return(dwResult);

}  // end CThread::ThreadEntryPoint
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// CWSStatusThread class construction / destruction, implementation

/*******************************************************************************
 *
 *  CWSStatusThread - CWSStatusThread constructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CWSStatusThread::CWSStatusThread()
{
    /*
     * Create the semaphore when the CWSStatusThread object is created and
     * initialize the m_bExit and m_bResetCounter flags to FALSE.
     */
    VERIFY( m_hWakeUp = CreateSemaphore( NULL, 0,
                                         MAX_STATUS_SEMAPHORE_COUNT,
                                         NULL ) );
    VERIFY( m_hConsumed = CreateSemaphore( NULL, 0,
                                           MAX_STATUS_SEMAPHORE_COUNT,
                                           NULL ) );
    m_bExit = FALSE;

}  // end CWSStatusThread::CWSStatusThread


/*******************************************************************************
 *
 *  ~CWSStatusThread - CWSStatusThread destructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CWSStatusThread::~CWSStatusThread()
{
    /*
     * Close the semaphores when the CWSStatusThread object is destroyed.
     */
    VERIFY( CloseHandle(m_hWakeUp) );
    VERIFY( CloseHandle(m_hConsumed) );

}  // end CWSStatusThread::~CWSStatusThread


/*******************************************************************************
 *
 *  RunThread - CWSStatusThread secondary thread main function loop
 *              (SECONDARY THREAD)
 *
 *  ENTRY:
 *  EXIT:
 *      (DWORD) exit status for the secondary thread.
 *
 ******************************************************************************/

DWORD
CWSStatusThread::RunThread()
{
    /* 
     * Query for PD and WinStation information to initialize dialog with.
     */
    if ( !WSPdQuery() || !WSInfoQuery() ) {

        /*
         * We can't query the WinStation information: tell the primary
         * thread that we've aborted, and exit this thread.
         */
        PostMessage(m_hDlg, WM_STATUSABORT, 0, 0);
        return(1);

    } else {

        /*
         * Tell the primary thread (modeless dialog window) that we've
         * got the initial information.
         */
        PostMessage(m_hDlg, WM_STATUSSTART, 0, 0);
        WaitForSingleObject(m_hConsumed, INFINITE);

        /* 
         * Always check for exit request each time we wake up and exit
         * the thread if the exit flag is set.
         */
        if ( m_bExit )
            return(0);
    }

    /*
     * Loop till exit requested.
     */
    for ( ; ; ) {

        /* 
         * Block the thread until time to refresh or we're woken up.
         */
        WaitForSingleObject( m_hWakeUp, ((CWinAdminApp*)AfxGetApp())->GetStatusRefreshTime());
        if ( m_bExit )
            return(0);

        /* 
         * Query for WinStation information.
         */
        if ( !WSInfoQuery() || (m_WSInfo.ConnectState == State_Disconnected) ) {

            /*
             * Either we can't query the WinStation or it has become
             * disconnected: tell the primary thread that we've aborted,
             * and exit this thread.
             */
            PostMessage(m_hDlg, WM_STATUSABORT, 0, 0);
            return(1);

        } else {

            /*
             * Tell the dialog that we've got some new query information.
             */
            PostMessage(m_hDlg, WM_STATUSREADY, 0, 0);
            WaitForSingleObject(m_hConsumed, INFINITE);
            if ( m_bExit )
                return(0);
        }
    }

}  // end CWSStatusThread::RunThread


////////////////////////////////////////////////////////////////////////////////
// CWSStatusThread operations: primary thread

/*******************************************************************************
 *
 *  SignalWakeUp - CWSStatusThread member function: public operation
 *
 *      Release the m_hWakeUp semaphore to start another status query.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CWSStatusThread::SignalWakeUp()
{
    ReleaseSemaphore(m_hWakeUp, 1, NULL);

}  // end CWSStatusThread::SignalWakeUp


/*******************************************************************************
 *
 *  SignalConsumed - CWSStatusThread member function: public operation
 *
 *      Release the m_hConsumed semaphore to allow secondary thread to continue
 *      running.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CWSStatusThread::SignalConsumed()
{
    ReleaseSemaphore( m_hConsumed, 1, NULL );

}  // end CWSStatusThread::SignalConsumed


/*******************************************************************************
 *
 *  ExitThread - CWSStatusThread member function: public operation
 *
 *      Tell the secondary thread to exit and cleanup after.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CWSStatusThread::ExitThread()
{
    DWORD dwReturnCode;
    int i;
    CWaitCursor Nikki;

    /*
     * If the thread was not created properly, just delete object and return.
     */
    if ( !m_hThread ) {
        delete this;
        return;
    }

    /*
     * Set the m_bExit flag to TRUE and bump both the consumed and wake up
     * semaphores to cause RunThread() (the thread's main instructon loop)
     * to exit.
     */
    m_bExit = TRUE;
    SignalWakeUp();
    SignalConsumed();

    /*
     * Wait a while for the thread to exit.
     */
    for ( i = 0, GetExitCodeThread( m_hThread, &dwReturnCode );
          (i < MAX_SLEEP_COUNT) && (dwReturnCode == STILL_ACTIVE); i++ ) {

        Sleep(100);
        GetExitCodeThread( m_hThread, &dwReturnCode );
    }

    /*
     * If the thread has still not exited, terminate it.
     */
    if ( dwReturnCode == STILL_ACTIVE ) {

        TerminateThread( m_hThread, 1 );

#ifdef _DEBUG
//    TRACE2( "WSSTATUS: Forced Terminate of thread monitoring LogonID %lu after %u 100msec exit waits.\n",
//            m_LogonId, MAX_SLEEP_COUNT );
#endif

    }

    /*
     * Close the thread handle and delete this CWSStatusThread object
     */
    VERIFY( CloseHandle(m_hThread) );
    delete this;

}  // end CWSStatusThread::ExitThread


////////////////////////////////////////////////////////////////////////////////
// CWSStatusThread operations: secondary thread

/*******************************************************************************
 *
 *  WSPdQuery - CWSStatusThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Query the Pd information for the WinStation object referenced by
 *      the m_LogonId member variable.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL) TRUE if query was sucessful; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CWSStatusThread::WSPdQuery()
{
	ULONG ReturnLength;

	/*
	 * Query the PD information.
	 */
	memset( &m_PdConfig, 0, sizeof(PDCONFIG) );
	if ( !WinStationQueryInformation(	m_hServer,
													m_LogonId,
													WinStationPd,
													&m_PdConfig, sizeof(PDCONFIG),
													&ReturnLength ) )
		goto BadWSQueryInfo;

	if(!WinStationQueryInformation(m_hServer,
											m_LogonId,
											WinStationPd,
											&m_PdConfig, sizeof(PDCONFIG),
											&ReturnLength ) )
		goto BadWSQueryInfo;

	return(TRUE);

 /*--------------------------------------
 * Error clean-up and return...
 */
BadWSQueryInfo:
    return(FALSE);

}  // end CWSStatusThread::WSPdQuery


/*******************************************************************************
 *
 *  WSInfoQuery - CWSStatusThread member function: private operation
 *                (SECONDARY THREAD)
 *
 *      Query the WinStation information for the WinStation object referenced
 *      by the m_LogonId member variable.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL) TRUE if query was sucessful; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CWSStatusThread::WSInfoQuery()
{
    ULONG ReturnLength;

    /*
     * Query the WinStation information.
     */
	TRACE0(">>> CWSStatusThread::WSInfoQuery WinStationQueryInformation\n");
    if ( !WinStationQueryInformation( m_hServer,
                                      m_LogonId,
                                      WinStationInformation,
                                      &m_WSInfo, sizeof(WINSTATIONINFORMATION),
                                      &ReturnLength ) )
        goto BadWSQueryInfo;
	TRACE0("<<< CWSStatusThread::WSInfoQuery WinStationQueryInformation (success)\n");

    return(TRUE);

/*--------------------------------------
 * Error clean-up and return...
 */
BadWSQueryInfo:
	TRACE0("<<< CWSStatusThread::WSInfoQuery WinStationQueryInformation (error)\n");
    return(FALSE);

}  // end CWSStatusThread::WSInfoQuery


///////////////////////////////////////////////////////////////////////////////
// CLed class construction / destruction, implementation

/*******************************************************************************
 *
 *  CLed - CLed constructor
 *
 *  ENTRY:
 *      hBrush (input)
 *          Brush to paint window with.
 *  EXIT:
 *      (Refer to MFC CStatic::CStatic documentation)
 *
 ******************************************************************************/

CLed::CLed( HBRUSH hBrush ) 
    : CStatic(),
      m_hBrush(hBrush)
{
	//{{AFX_DATA_INIT(CLed)
	//}}AFX_DATA_INIT

}  // end CLed::CLed


////////////////////////////////////////////////////////////////////////////////
//  CLed operations

/*******************************************************************************
 *
 *  Subclass - CLed member function: public operation
 *
 *      Subclass the specified object to our special blip object.
 *
 *  ENTRY:
 *      pStatic (input)
 *          Points to CStatic object to subclass.
 *  EXIT:
 *
 ******************************************************************************/

void
CLed::Subclass( CStatic *pStatic )
{
    SubclassWindow(pStatic->m_hWnd);

}  // end CLed::Subclass


/*******************************************************************************
 *
 *  Update - CLed member function: public operation
 *
 *      Update the LED to 'on' or 'off' state.
 *
 *  ENTRY:
 *      nOn (input)
 *          nonzero to set 'on' state; zero for 'off' state.
 *  EXIT:
 *
 ******************************************************************************/

void
CLed::Update( int nOn )
{
    m_bOn = nOn ? TRUE : FALSE;
    InvalidateRect(NULL);
    UpdateWindow();

}  // end CLed::Update


/*******************************************************************************
 *
 *  Toggle - CLed member function: public operation
 *
 *      Toggle the LED's on/off state.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CLed::Toggle()
{
    m_bOn = !m_bOn;
    InvalidateRect(NULL);
    UpdateWindow();

}  // end CLed::Toggle


////////////////////////////////////////////////////////////////////////////////
// CLed message map

BEGIN_MESSAGE_MAP(CLed, CStatic)
	//{{AFX_MSG_MAP(CLed)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////////////////
//  CLed commands


/*******************************************************************************
 *
 *  OnPaint - CLed member function: public operation
 *
 *      Paint the led with its brush for 'on' state.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CWnd::OnPaint documentation)
 *
 ******************************************************************************/

void
CLed::OnPaint() 
{
    RECT rect;
    CPaintDC dc(this);
    CBrush brush;

    GetClientRect(&rect);

#ifdef USING_3DCONTROLS
    (rect.right)--;
    (rect.bottom)--;
    dc.FrameRect( &rect, brush.FromHandle((HBRUSH)GetStockObject(GRAY_BRUSH)) );

    (rect.top)++;
    (rect.left)++;
    (rect.right)++;
    (rect.bottom)++;
    dc.FrameRect( &rect, brush.FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)) );

    (rect.top)++;
    (rect.left)++;
    (rect.right) -= 2;
    (rect.bottom) -= 2;
#else
    dc.FrameRect( &rect, brush.FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)) );
    (rect.top)++;
    (rect.left)++;
    (rect.right)--;
    (rect.bottom)--;
#endif
    dc.FillRect( &rect,
                 brush.FromHandle(
                    m_bOn ?
                        m_hBrush :
                        (HBRUSH)GetStockObject(LTGRAY_BRUSH)) );

}  // end CLed::OnPaint
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\treeview.cpp ===
/*******************************************************************************
*
* treeview.cpp
*
* implementation of the CAdminTreeView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\treeview.cpp  $
*  
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "admindoc.h"
#include "treeview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern DWORD g_dwTreeViewExpandedStates;
/////////////////////////////
// MESSAGE MAP: CAdminTreeView
//
IMPLEMENT_DYNCREATE(CAdminTreeView, CBaseTreeView)

BEGIN_MESSAGE_MAP(CAdminTreeView, CBaseTreeView)
//{{AFX_MSG_MAP(CAdminTreeView)
ON_MESSAGE(WM_ADMIN_ADD_SERVER, OnAdminAddServer)
ON_MESSAGE(WM_ADMIN_REMOVE_SERVER, OnAdminRemoveServer)
ON_MESSAGE(WM_ADMIN_UPDATE_SERVER, OnAdminUpdateServer)
ON_MESSAGE(WM_ADMIN_ADD_WINSTATION, OnAdminAddWinStation)
ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATION, OnAdminUpdateWinStation)
ON_MESSAGE(WM_ADMIN_REMOVE_WINSTATION, OnAdminRemoveWinStation)
ON_MESSAGE(WM_ADMIN_UPDATE_DOMAIN, OnAdminUpdateDomain)
ON_MESSAGE(WM_ADMIN_ADD_DOMAIN, OnAdminAddDomain)
ON_MESSAGE(WM_ADMIN_VIEWS_READY, OnAdminViewsReady)
ON_MESSAGE( WM_ADMIN_ADDSERVERTOFAV , OnAdminAddServerToFavs )
ON_MESSAGE( WM_ADMIN_REMOVESERVERFROMFAV , OnAdminRemoveServerFromFavs )
ON_MESSAGE( WM_ADMIN_GOTO_SERVER , OnAdminGotoServer )
ON_MESSAGE( WM_ADMIN_DELTREE_NODE , OnAdminDelFavServer )
ON_MESSAGE( WM_ADMIN_GET_TV_STATES , OnGetTVStates )
ON_MESSAGE( WM_ADMIN_UPDATE_TVSTATE , OnUpdateTVState )
ON_MESSAGE( IDM_ALLSERVERS_EMPTYFAVORITES , OnEmptyFavorites )
ON_MESSAGE( WM_ISFAVLISTEMPTY , OnIsFavListEmpty )
ON_MESSAGE( WM_ADMIN_CONNECT_TO_SERVER, OnAdminConnectToServer )
ON_WM_CONTEXTMENU()

/*
ON_WM_LBUTTONUP( )
ON_WM_MOUSEMOVE( )
ON_WM_TIMER( )
ON_NOTIFY( TVN_BEGINDRAG , AFX_IDW_PANE_FIRST , OnBeginDrag )
*/


ON_NOTIFY( NM_RCLICK , AFX_IDW_PANE_FIRST , OnRClick )

ON_WM_LBUTTONDBLCLK()
ON_COMMAND( ID_ENTER , OnEnterKey )
ON_WM_SETFOCUS( )

//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////
// F'N: CAdminTreeView ctor
//
CAdminTreeView::CAdminTreeView()
{
    m_pimgDragList = NULL;
    m_hDragItem = NULL;
    
}  // end CAdminTreeView ctor


//////////////////////////
// F'N: CAdminTreeView dtor
//
CAdminTreeView::~CAdminTreeView()
{
    
}  // end CAdminTreeView dtor

#ifdef _DEBUG
//////////////////////////////////
// F'N: CAdminTreeView::AssertValid
//
void CAdminTreeView::AssertValid() const
{
    CBaseTreeView::AssertValid();	  
    
}  // end CAdminTreeView::AssertValid


///////////////////////////
// F'N: CAdminTreeView::Dump
//
void CAdminTreeView::Dump(CDumpContext& dc) const
{
    CBaseTreeView::Dump(dc);
    
}  // end CAdminTreeView::Dump
#endif


/////////////////////////////////////
// F'N: CAdminTreeView::BuildImageList
//
// - calls m_imageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the CTreeCtrl
//
void CAdminTreeView::BuildImageList()
{
    m_ImageList.Create(16, 16, TRUE, 19, 0);
    
    m_idxBlank  = AddIconToImageList(IDI_BLANK);
    m_idxCitrix = AddIconToImageList(IDI_WORLD);
    m_idxServer = AddIconToImageList(IDI_SERVER);
    m_idxConsole = AddIconToImageList(IDI_CONSOLE);
    m_idxNet = AddIconToImageList(IDI_NET);
    m_idxNotSign = AddIconToImageList(IDI_NOTSIGN);
    m_idxQuestion = AddIconToImageList(IDI_QUESTIONMARK);
    m_idxUser = AddIconToImageList(IDI_USER);
    m_idxAsync = AddIconToImageList(IDI_ASYNC);
    m_idxCurrentServer = AddIconToImageList(IDI_CURRENT_SERVER);
    m_idxCurrentNet = AddIconToImageList(IDI_CURRENT_NET);
    m_idxCurrentConsole = AddIconToImageList(IDI_CURRENT_CONSOLE);
    m_idxCurrentAsync = AddIconToImageList(IDI_CURRENT_ASYNC);
    m_idxDirectAsync = AddIconToImageList(IDI_DIRECT_ASYNC);
    m_idxCurrentDirectAsync = AddIconToImageList(IDI_CURRENT_DIRECT_ASYNC);
    m_idxDomain = AddIconToImageList(IDI_DOMAIN);
    m_idxCurrentDomain = AddIconToImageList(IDI_CURRENT_DOMAIN);
    m_idxDomainNotConnected = AddIconToImageList(IDI_DOMAIN_NOT_CONNECTED);
    m_idxServerNotConnected = AddIconToImageList(IDI_SERVER_NOT_CONNECTED);
    
    // Overlay for Servers we can't talk to
    m_ImageList.SetOverlayImage(m_idxNotSign, 1);
    // Overlay for Servers we are currently gathering information about
    m_ImageList.SetOverlayImage(m_idxQuestion, 2);
    
    GetTreeCtrl().SetImageList(&m_ImageList, TVSIL_NORMAL);
    
}  // end CAdminTreeView::BuildImageList


/////////////////////////////////////////
// F'N: CAdminTreeView::DetermineWinStationText
//
//	determines the appropriate text to display for
//	a WinStation in the tree
//
void CAdminTreeView::DetermineWinStationText(CWinStation *pWinStation, TCHAR *NameToDisplay)
{
    ASSERT(pWinStation);
    ASSERT(NameToDisplay);
    
    CString NameString;
    const TCHAR *pState = StrConnectState(pWinStation->GetState(), FALSE);
    
    switch(pWinStation->GetState()) {
    case State_Active:			// user logged on to WinStation
    case State_Connected:		// WinStation connected to client
    case State_ConnectQuery:	// in the process of connecting to client
    case State_Shadow:          // shadowing another WinStation
        if(wcslen(pWinStation->GetUserName())) {
            NameString.Format(TEXT("%s (%s)"), pWinStation->GetName(), pWinStation->GetUserName());
            wcscpy(NameToDisplay, NameString);
        }
        else
        {
            if( pWinStation->GetState() == State_ConnectQuery )
            {
                CString ConnQ;
                ConnQ.LoadString( IDS_CONNQ );
                
                wcscpy( NameToDisplay , ConnQ );
            }
            else
            {
                wcscpy(NameToDisplay, pWinStation->GetName());
            }
        }
        break;
    case State_Disconnected:	// WinStation logged on without client
        if(wcslen(pWinStation->GetUserName())) {
            NameString.Format(TEXT("%s (%s)"), pState, pWinStation->GetUserName());
        }
        else NameString.Format(TEXT("%s (%lu)"), pState, pWinStation->GetLogonId());
        wcscpy(NameToDisplay, NameString);
        break;
    case State_Idle:			// waiting for client to connect
        if(pWinStation->GetServer()->GetCTXVersionNum() < 0x200) {
            NameString.Format(TEXT("%s (%s)"), pWinStation->GetName(), pState);
            wcscpy(NameToDisplay, NameString);
        } else {
            NameString.Format(TEXT("%s (%lu)"), pState, pWinStation->GetLogonId());
            wcscpy(NameToDisplay, NameString);
        }
        break;
    case State_Down:			// WinStation is down due to error
        NameString.Format(TEXT("%s (%lu)"), pState, pWinStation->GetLogonId());
        wcscpy(NameToDisplay, NameString);
        break;
    case State_Listen:			// WinStation is listening for connection
        {
            CString ListenString;
            ListenString.LoadString(IDS_LISTENER);
            NameString.Format(TEXT("%s (%s)"), pWinStation->GetName(), ListenString);
            wcscpy(NameToDisplay, NameString);
        }
        break;
    case State_Reset:			// WinStation is being reset
    case State_Init:			// WinStation in initialization
        wcscpy(NameToDisplay, pWinStation->GetName());
        break;
    }
    
}  // end CAdminTreeView::DetermineWinStationText


/////////////////////////////////////////
// F'N: CAdminTreeView::DetermineWinStationIcon
//
//	determines which icon to display for a WinStation
//	in the tree
//
int CAdminTreeView::DetermineWinStationIcon(CWinStation *pWinStation)
{
    ASSERT(pWinStation);
    
    int WhichIcon = m_idxBlank;
    BOOL CurrentWinStation = pWinStation->IsCurrentWinStation();
    
    if(pWinStation->GetState() != State_Disconnected 
        && pWinStation->GetState() != State_Idle) {
        switch(pWinStation->GetSdClass()) {
        case SdAsync:
            if(pWinStation->IsDirectAsync())
                WhichIcon = CurrentWinStation ? m_idxCurrentDirectAsync : m_idxDirectAsync;
            else
                WhichIcon = CurrentWinStation ? m_idxCurrentAsync : m_idxAsync;
            break;
            
        case SdNetwork:
            WhichIcon = CurrentWinStation ? m_idxCurrentNet : m_idxNet;
            break;
            
        default:
            WhichIcon = CurrentWinStation ? m_idxCurrentConsole : m_idxConsole;
            break;
        }
    }
    
    return WhichIcon;
    
}  // end CAdminTreeView::DetermineWinStationIcon


/////////////////////////////////////////
// F'N: CAdminTreeView::DetermineDomainIcon
//
//	determines which icon to display for a Domain
//	in the tree
//
int CAdminTreeView::DetermineDomainIcon(CDomain *pDomain)
{
    ASSERT(pDomain);
    
    int WhichIcon = m_idxDomain;
    
    if(pDomain->IsCurrentDomain()) return m_idxCurrentDomain;
    
    if(pDomain->GetState() != DS_ENUMERATING && pDomain->GetState() != DS_INITIAL_ENUMERATION)
        WhichIcon = m_idxDomainNotConnected;
    
    return WhichIcon;
    
}  // end CAdminTreeView::DetermineDomainIcon


/////////////////////////////////////////
// F'N: CAdminTreeView::DetermineServerIcon
//
//	determines which icon to display for a Server
//	in the tree
//
int CAdminTreeView::DetermineServerIcon(CServer *pServer)
{
    ASSERT(pServer);
    
    int WhichIcon = m_idxServer;
    
    // Is this the current server?
    if(pServer->IsCurrentServer()) {
        if(pServer->IsState(SS_NONE) || pServer->IsState(SS_NOT_CONNECTED))
            WhichIcon = m_idxServerNotConnected;
        else
            WhichIcon = m_idxCurrentServer;
    } else {  // not the current server
        if(pServer->IsState(SS_NONE) || pServer->IsState(SS_NOT_CONNECTED))
            WhichIcon = m_idxServerNotConnected;
    }
    
    return WhichIcon;
    
}  // end CAdminTreeView::DetermineServerIcon


/////////////////////////////////////////
// F'N: CAdminTreeView::AddServerChildren
//
//	Adds the WinStations attached to a given Server
//	to the tree
//
void CAdminTreeView::AddServerChildren(HTREEITEM hServer, CServer *pServer  , NODETYPE nt)
{
    ASSERT(hServer);
    ASSERT(pServer);
    
    if(pServer->IsServerSane()) {
        
        LockTreeControl();
        
        HTREEITEM hLastNode = hServer;
        
        pServer->LockWinStationList();
        
        // Get a pointer to the server's list of WinStations
        CObList *pWinStationList = pServer->GetWinStationList();
        
        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();
        
        while(pos)
        {
            CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
            
            // Figure out which icon to use
            int WhichIcon = DetermineWinStationIcon(pWinStation);
            
            // Figure out what text to display
            TCHAR NameToDisplay[128];
            DetermineWinStationText(pWinStation, NameToDisplay);
            
            CTreeNode *pNode = new CTreeNode(NODE_WINSTATION, pWinStation);
            
            if( pNode != NULL )
            {
                pNode->SetSortOrder(pWinStation->GetSortOrder());
                
                hLastNode = AddItemToTree(hServer, NameToDisplay, hLastNode, WhichIcon, (LPARAM)pNode);
                
                if( hLastNode == NULL )
                {
                    delete pNode;
                }
            }
            
            // The WinStation wants to know his tree item handle
            
            if( nt == NODE_FAV_LIST )
            {
                pWinStation->SetTreeItemForFav(hLastNode);
            }
            else if( nt == NODE_SERVER )
            {
                pWinStation->SetTreeItem(hLastNode);
            }
            else if( nt == NODE_THIS_COMP )
            {
                pWinStation->SetTreeItemForThisComputer( hLastNode );
            }
        }
        
        pServer->UnlockWinStationList();
        
        UnlockTreeControl();
        
    }  // end if(pServer->IsServerSane())
    
    
}  // end CAdminTreeView::AddServerChildren


/////////////////////////////////////////
// F'N: CAdminTreeView::AddDomainToTree
//
//	Adds a domain to the tree
//
HTREEITEM CAdminTreeView::AddDomainToTree(CDomain *pDomain)
{
    ASSERT(pDomain);
    
    LockTreeControl();
    
    HTREEITEM hDomain;
    
    // this points to this computer root
    HTREEITEM hR2 = GetTreeCtrl().GetRootItem();
    
    // this points to favorite list
    hR2 = GetTreeCtrl().GetNextItem( hR2 , TVGN_NEXT );
    
    // this points to All servers
    HTREEITEM hRoot = GetTreeCtrl().GetNextItem( hR2 , TVGN_NEXT );
    // Add the domain to the tree
    // Create a CTreeNode object with info about this tree node
    CTreeNode* pNode = new CTreeNode(NODE_DOMAIN, pDomain);
    if(pNode) {
        hDomain = AddItemToTree(hRoot, pDomain->GetName(), TVI_SORT, DetermineDomainIcon(pDomain), (LPARAM)pNode);
        if(!hDomain) delete pNode;
        // Change the icon/overlay for the domain
        if(pDomain->GetState() == DS_INITIAL_ENUMERATION) 
            GetTreeCtrl().SetItemState(hDomain, STATE_QUESTION, 0x0F00);
        
        // The domain wants to know his tree item handle
        pDomain->SetTreeItem(hDomain);
    }
    
    UnlockTreeControl();
    
    return(hDomain);
    
}	// end CAdminTreeView::AddDomainToTree


//////////////////////////////////
// F'N: CAdminTreeView::OnAdminViewsReady
//
LRESULT CAdminTreeView::OnAdminViewsReady(WPARAM wParam, LPARAM lParam)
{
    LockTreeControl();
    
    // Get a pointer to our document
    CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();
    
    // We want to remember the tree item of the current server for later
    HTREEITEM hCurrentServer = NULL;
    
    HTREEITEM hThisComputerRootItem = NULL;
    HTREEITEM hThisComputer = NULL;
    HTREEITEM hFavRoot = NULL;
    
    // add enum for fav node
    CString cstrThisComputer;
    CString cstrFavSrv;
    
    CNodeType *pNodeType = new CNodeType( NODE_THIS_COMP );
    
    // ok to pass in null
    
    CTreeNode *pThisComp = new CTreeNode( NODE_THIS_COMP , pNodeType );
    
    if( pThisComp != NULL )
    {
        cstrThisComputer.LoadString( IDS_THISCOMPUTER );
        
        hThisComputerRootItem = AddItemToTree( NULL , cstrThisComputer , TVI_ROOT , m_idxDomain , ( LPARAM )pThisComp );
    }
    
    // ok to overrun
    
    pNodeType = new CNodeType( NODE_FAV_LIST );
    
    // it's ok to pass null here
    
    CTreeNode *pFavNode = new CTreeNode( NODE_FAV_LIST , pNodeType );
    
    if( pFavNode != NULL )
    {
        cstrFavSrv.LoadString( IDS_FAVSERVERS );
        
        hFavRoot = AddItemToTree( NULL , cstrFavSrv , TVI_ROOT , m_idxCitrix, ( LPARAM )pFavNode );
    }
    
    // add the root to the tree
    CString citrix;
    citrix.LoadString(IDS_TREEROOT);
    CTreeNode* pRootNode = new CTreeNode(NODE_ALL_SERVERS, NULL);
    if(!pRootNode) {
        UnlockTreeControl();
        return 0;
    }
    
    HTREEITEM hRoot = AddItemToTree(NULL, citrix, TVI_ROOT, m_idxCitrix, (LPARAM)pRootNode);   
    
    if(!hRoot) delete pRootNode;
    
    // set up some 'placeholder'-style vars
    HTREEITEM hCurrParent     = hRoot;
    HTREEITEM hLastConnection = hRoot;
    HTREEITEM hLastNode       = hRoot;
    HTREEITEM hDomain = NULL;
    
    // Get a pointer to the list of domains
    CObList *pDomainList = doc->GetDomainList();
    POSITION dpos = pDomainList->GetHeadPosition();
    
    while(dpos) {
        CDomain *pDomain = (CDomain*)pDomainList->GetNext(dpos);
        AddDomainToTree(pDomain);
    }
    
    // Get a pointer to the list of servers
    doc->LockServerList();
    CObList *pServerList = doc->GetServerList();
    
    // Iterate through the server list
    POSITION pos = pServerList->GetHeadPosition();
    
    CServer *pCurrentServer;
    
    while(pos) {
        // Go to the next server in the list
        CServer *pServer = (CServer*)pServerList->GetNext(pos);
        
        if( pServer == NULL )
        {
            continue;
        }
        
        // If this Server's domain isn't in the tree, add it
        CDomain *pDomain = pServer->GetDomain();
        if(pDomain != NULL )
        {
            hDomain = pDomain->GetTreeItem();
            ASSERT(hDomain);
        }
        else
        {
            // server is not in a domain
            hDomain = hRoot;
        }
        
        // Add the server to the tree
        // Create a CTreeNode object with info about this tree node
        CTreeNode* pNode = new CTreeNode(NODE_SERVER, pServer);
        if(pNode) {
            
            if( !pServer->IsCurrentServer() )
            {
                // If the server is the current server, use a different icon
                hLastConnection = AddItemToTree(hDomain, 
                    pServer->GetName(), 
                    hLastConnection,
                    DetermineServerIcon(pServer), 
                    (LPARAM)pNode);
                if(!hLastConnection) delete pNode;
                // The server wants to know his tree item handle
                pServer->SetTreeItem(hLastConnection);
                // If the server isn't sane, put a not sign over the icon
                if(!pServer->IsServerSane()) GetTreeCtrl().SetItemState(hLastConnection, STATE_NOT, 0x0F00);
                // If we aren't done getting all the information about this server,
                // put a question mark over the icon
                else if(pServer->IsState(SS_GETTING_INFO)) GetTreeCtrl().SetItemState(hLastConnection, STATE_QUESTION, 0x0F00);
                
                AddServerChildren(hLastConnection, pServer , NODE_SERVER );
            }
            
            // Remember if this is the current server
            else
            {
                hCurrentServer = hLastConnection;
                
                /* Add this item under the this computer root */
                
                hThisComputer = AddItemToTree( hThisComputerRootItem ,
                    pServer->GetName() ,
                    TVI_FIRST ,
                    DetermineServerIcon(pServer),
                    (LPARAM)pNode );
                
                CTreeNode* pItem = new CTreeNode(NODE_SERVER, pServer);
                
                // uncomment this line if you want this computer to be part of the domain tree list
                /*
                hLastConnection = AddItemToTree( hDomain, 
                pServer->GetName(), 
                hLastConnection,
                DetermineServerIcon(pServer), 
                (LPARAM)pItem);
                */
                
                pServer->SetTreeItemForThisComputer( hThisComputer );
                
                // uncomment this line if you want this computer to be part of the domain tree list
                // pServer->SetTreeItem( hLastConnection );
                
                if( !pServer->IsServerSane() )
                {
                    GetTreeCtrl().SetItemState(hThisComputer, STATE_NOT, 0x0F00);
                    // uncomment this line if you want this computer to be part of the domain tree list
                    // GetTreeCtrl().SetItemState(hLastConnection, STATE_NOT, 0x0F00);
                }                    
                
                // uncomment this line if you want this computer to be part of the domain tree list
                // AddServerChildren( hLastConnection, pServer , NODE_SERVER );
                
                AddServerChildren( hThisComputer , pServer , NODE_SERVER );                
            }
            
        }
    }  // end while(pos)
    
    doc->UnlockServerList();
    
    // We want to show the main server in this computer node
    
    //GetTreeCtrl().Expand(hRoot, TVE_EXPAND);
    
    GetTreeCtrl().Expand( hThisComputerRootItem , TVE_COLLAPSE );
    
    /*
    LRESULT lResult = 0xc0;
    // We want to default to having the current server being the
    // currently selected item in the tree and be expanded
    
      if( hThisComputerRootItem != NULL && ( g_dwTreeViewExpandedStates & TV_THISCOMP ) )
      {
      if( hThisComputer != NULL )
      {
		    GetTreeCtrl().SelectItem(hThisComputer);
            GetTreeCtrl().Expand(hThisComputer, TVE_EXPAND);
            // GetTreeCtrl().Expand(hDomain, TVE_EXPAND);        
            //lResult = 0xc0;
            OnSelChange( NULL , &lResult );
            }
            }
            
              if( hFavRoot != NULL && ( g_dwTreeViewExpandedStates & TV_FAVS ) )
              {
              GetTreeCtrl().SelectItem( hFavRoot );
              GetTreeCtrl().Expand( hFavRoot , TVE_EXPAND );
              OnSelChange( NULL , &lResult );
              }
              
                if( hRoot != NULL && ( g_dwTreeViewExpandedStates & TV_ALLSERVERS ) )
                {
                GetTreeCtrl().SelectItem( hRoot );
                GetTreeCtrl().Expand( hRoot , TVE_EXPAND );
                OnSelChange( NULL , &lResult );
                }
                
    */
    UnlockTreeControl();
    
    return 0;
    
}  // end CAdminTreeView::OnAdminViewsReady


////////////////////////////////
// F'N: CAdminTreeView::OnAdminAddServer
//
//	Message Handler to add a Server to the tree
//	Pointer to CServer to add is in lParam
//
LRESULT CAdminTreeView::OnAdminAddServer(WPARAM wParam, LPARAM lParam)
{      
    ASSERT(lParam);
    
    CServer *pServer = (CServer*)lParam;
    
    LockTreeControl();
    
    CTreeCtrl &tree = GetTreeCtrl();
    
    // If this Server's domain isn't in the tree, add it
    HTREEITEM hDomain = NULL;
    CDomain *pDomain = pServer->GetDomain();
    if(pDomain) {
        hDomain = pDomain->GetTreeItem();
        ASSERT(hDomain);
    } else {
        // server is not in a domain
        hDomain = tree.GetRootItem();
    }
    
    // First make sure the server isn't already in the tree
    // Get the first server under the domain
    HTREEITEM hItem = tree.GetNextItem(hDomain, TVGN_CHILD);
    while(hItem) {
        // Get the data attached to the tree item
        CTreeNode *node = (CTreeNode*)tree.GetItemData(hItem);
        if(node) {
            // Is this the server we want to add
            CServer *pServer = (CServer*)node->GetTreeObject();
            if(pServer == (CServer*)lParam) {
                UnlockTreeControl();
                return 0;
            }
        }
        hItem = tree.GetNextItem(hItem, TVGN_NEXT);
    }
    
    // Add the server to the tree
    // Create a CTreeNode object with info about this tree node
    CTreeNode* pNode = new CTreeNode(NODE_SERVER, pServer);
    if(pNode)
    {
        // If the server is the current server, use a different icon
        
        HTREEITEM hServer = AddItemToTree(hDomain, pServer->GetName(), (HTREEITEM)wParam,
            DetermineServerIcon(pServer), (LPARAM)pNode);
        if( !hServer )
        {
            delete pNode;
        }
        // The server wants to know his tree item handle
        pServer->SetTreeItem(hServer);
        // If the server isn't sane, put a not sign over the icon
        if( !pServer->IsServerSane() )
        {
            tree.SetItemState(hServer, STATE_NOT, 0x0F00);
        }
        // If we aren't done getting all the information about this server,
        // put a question mark over the icon
        else if(pServer->IsState(SS_GETTING_INFO))
        {
            tree.SetItemState(hServer, STATE_QUESTION, 0x0F00);
        }
        
        AddServerChildren(hServer, pServer , NODE_SERVER );
    }
    
    UnlockTreeControl();
    
    return 0;                                                                  
    
}  // end CAdminTreeView::OnAdminAddServer

//----------------------------------------------------------------------
// ok if you traced me to here you are almost there
// 1) now we need to update the server item and place it under the favorites
// folder
// 2) inform the server child items that it will have a new parent
//
LRESULT CAdminTreeView::OnAdminAddServerToFavs( WPARAM wp , LPARAM lp )
{
    CServer *pServer = ( CServer* )lp;
    
    if( pServer == NULL )
    {
        ODS( L"CAdminTreeView::OnAdminAddServerToFavs invalid arg\n");
        return ( LRESULT )-1;
    }
    
    LockTreeControl( );
    
    if( pServer->IsServerInactive() || pServer->IsState( SS_DISCONNECTING ) )
    {
        UnlockTreeControl( );
        
        return 0;
    }
    
    CTreeCtrl &tree = GetTreeCtrl();
    
    HTREEITEM hFavs = GetTreeCtrl().GetRootItem( );
    HTREEITEM hItem;
    
    hFavs = tree.GetNextItem( hFavs , TVGN_NEXT );
    
    hItem = tree.GetNextItem( hFavs , TVGN_CHILD );
    
    
    // check for duplicate entry
    
    while( hItem != NULL )
    {
        // Get the data attached to the tree item
        CTreeNode *pTreenode = (CTreeNode*)tree.GetItemData( hItem );
        
        if( pTreenode != NULL )
        {
            // Is this the server we want to add
            CServer *pSvr = (CServer*)pTreenode->GetTreeObject();
            
            if( pSvr == pServer )
            {
                UnlockTreeControl();
                
                return 0;
            }
        }
        
        hItem = tree.GetNextItem(hItem, TVGN_NEXT);
    }
    
    CTreeNode* pNode = new CTreeNode(NODE_SERVER, pServer);
    
    if( pNode != NULL )
    {
        HTREEITEM hServer = AddItemToTree( hFavs,
            pServer->GetName(),
            TVI_SORT,
            DetermineServerIcon(pServer),
            (LPARAM)pNode);
        
        
        if( hServer == NULL )
        {
            delete pNode;
        }
        
        // The server wants to know his tree item handle
        pServer->SetTreeItemForFav( hServer );
        
        // If the server isn't sane, put a not sign over the icon
        if( !pServer->IsServerSane() )
        {
            tree.SetItemState(hServer, STATE_NOT, 0x0F00);
        }
        // If we aren't done getting all the information about this server,
        // put a question mark over the icon
        else if( pServer->IsState( SS_GETTING_INFO ) )
        {
            tree.SetItemState(hServer, STATE_QUESTION, 0x0F00);
        }
        
        AddServerChildren( hServer , pServer , NODE_FAV_LIST );
    }
    
    UnlockTreeControl();
    
    tree.Invalidate( );
    
    return 0;
}
//=----------------------------------------------------------------------------------
LRESULT CAdminTreeView::OnAdminRemoveServerFromFavs( WPARAM wp , LPARAM lp )
{        
    LockTreeControl();
    
    CServer *pServer = ( CServer* )lp;
    
    DBGMSG( L"CAdminTreeView::OnAdminRemoveServerFromFavs -- %s\n" , pServer->GetName( ) );
    
    HTREEITEM hFavServer = pServer->GetTreeItemFromFav();
    
#ifdef _STRESS_BUILD
    DBGMSG( L"Handle to hFavServer 0x%x\n" , hFavServer );
#endif
    
    if( hFavServer == NULL )
    {
        UnlockTreeControl();
        
        return 0;
    }	
    
    // Get the data attached to this tree node
    
    
    CTreeNode *pNode = (CTreeNode*)GetTreeCtrl().GetItemData( hFavServer );
    
    if( pNode != NULL && pNode->GetNodeType( ) == NODE_SERVER )
    {
        // Is this the server we want to update
        CServer *pTreeServer = ( CServer* )pNode->GetTreeObject();
        
        if( pTreeServer != pServer)
        {
            UnlockTreeControl();
            return 0;
        }
    }
    else
    {
        UnlockTreeControl();
        
        return 0;
    }
    
    // Loop through it's children and delete their data
    
    pServer->LockWinStationList( );
    
    HTREEITEM hChild = GetTreeCtrl().GetNextItem( hFavServer , TVGN_CHILD );
    
    while( hChild != NULL )
    {
        CTreeNode *pChildNode = ( CTreeNode* )GetTreeCtrl().GetItemData( hChild );
        
        if( pChildNode != NULL && pChildNode->GetNodeType( ) == NODE_WINSTATION )
        {
            // Tell the WinStation it is no longer in the tree
            CWinStation *pWinStation = ( CWinStation* )pChildNode->GetTreeObject();
            
            if( pWinStation != NULL )
            {
                pWinStation->SetTreeItemForFav(NULL);
            }
            
            delete pChildNode;
        }
        
        hChild = GetTreeCtrl().GetNextItem( hChild , TVGN_NEXT );
    }
    
    // Delete the data attached to the tree item
    delete pNode;
    
    // Let the server know he is no longer in the tree
    pServer->SetTreeItemForFav(NULL);
    
    GetTreeCtrl().DeleteItem( hFavServer );
    
    pServer->UnlockWinStationList( );
    
    UnlockTreeControl();
    
    return 0;
}
////////////////////////////////
// F'N: CAdminTreeView::OnAdminRemoveServer
//
//	Message Handler to remove a Server from the tree
//	Pointer to CServer of server to remove is in lParam
//
LRESULT CAdminTreeView::OnAdminRemoveServer(WPARAM wParam, LPARAM lParam)              
{   
    ASSERT(lParam);
    
    CServer *pServer = (CServer*)lParam;
    
    HTREEITEM hServer = pServer->GetTreeItem();
    if(!hServer) return 0;
    
    LockTreeControl();
    
    // Get the data attached to this tree node
    CTreeNode *node = (CTreeNode*)GetTreeCtrl().GetItemData(hServer);
    if(node) {
        // Is this the server we want to update
        CServer *pTreeServer = (CServer*)node->GetTreeObject();
        // Make sure the tree node is correct
        if(pTreeServer != pServer) {
            UnlockTreeControl();
            return 0;
        }
    }
    else {
        UnlockTreeControl();
        return 0;
    }
    
    // Loop through it's children and delete their data
    HTREEITEM hChild = GetTreeCtrl().GetNextItem(hServer, TVGN_CHILD);
    while(hChild) {
        CTreeNode *ChildNode = (CTreeNode*)GetTreeCtrl().GetItemData(hChild);
        if(ChildNode) {
            // Tell the WinStation it is no longer in the tree
            CWinStation *pWinStation = (CWinStation*)ChildNode->GetTreeObject();
            if(pWinStation) 
                pWinStation->SetTreeItem(NULL);
            delete ChildNode;
        }
        hChild = GetTreeCtrl().GetNextItem(hChild, TVGN_NEXT);
    }
    
    // Delete the data attached to the tree item
    delete node;
    // Let the server know he is no longer in the tree
    pServer->SetTreeItem(NULL);
    // Remove the server from the tree
    // This SHOULD remove all it's children
    GetTreeCtrl().DeleteItem(hServer);
    
    
    // TODO
    // if this means that CServer does not exist we need to remove this from the favorite list
    
    UnlockTreeControl();
    
    return 0;                                                                  
    
}  // end CAdminTreeView::OnAdminRemoveServer


   /*=--------------------------------------------------------------------------------------
   OnAdminUpdateServer
   
     Message handler to update a Server in the tree
     Pointer to CServer to update is in lParam
     
       Updates server item in favorites folder
       and if server item is this computer it gets updated as well.
       
*=------------------------------------------------------------------------------------*/
LRESULT CAdminTreeView::OnAdminUpdateServer(WPARAM wParam, LPARAM lParam)
{      
    ASSERT(lParam);
    
    LockTreeControl( );
    // If favorite folders is expanded don't forget to update the tree item
    
    CServer *pServer = (CServer*)lParam;
    
    HTREEITEM hServer = pServer->GetTreeItem();
    
    if( hServer != NULL )
    {
        UpdateServerTreeNodeState( hServer , pServer , NODE_SERVER );
    }
    
    hServer = pServer->GetTreeItemFromFav( );
    
    if( hServer != NULL )
    {
        UpdateServerTreeNodeState( hServer , pServer , NODE_FAV_LIST );
    }
    
    hServer = pServer->GetTreeItemFromThisComputer( );
    
    if( hServer != NULL )
    {        
        UpdateServerTreeNodeState( hServer , pServer , NODE_THIS_COMP );
    }
    
    UnlockTreeControl( );
    
    return 0;
}

/*=--------------------------------------------------------------------------------------

  UpdateServerTreeNodeState
  
    hServer -- tree item that needs updating
    pServer -- server object
    
*=------------------------------------------------------------------------------------*/
LRESULT CAdminTreeView::UpdateServerTreeNodeState( HTREEITEM hServer , CServer *pServer , NODETYPE  nt )
{
    LockTreeControl( );
    
    if( hServer == NULL )
    {
        UnlockTreeControl( );
        
        return 0;
    }
    
    // Get the data attached to this tree node
    
    CTreeNode *node = (CTreeNode*)GetTreeCtrl().GetItemData(hServer);
    if( node != NULL && node->GetNodeType( ) == NODE_SERVER  )
    {
        // Is this the server we want to update
        CServer *pTreeServer = (CServer*)node->GetTreeObject();
        // Make sure the tree node is correct
        if(pTreeServer != pServer) 
        {
            UnlockTreeControl();
            
            return 0;
        }
        
    }
    else
    {
        UnlockTreeControl();
        
        return 0;
    }
    
    UINT NewState;
    // Remember the previous state
    UINT PreviousState = GetTreeCtrl().GetItemState(hServer, 0x0F00);
    // Change the icon/overlay for the server
    // If the server isn't sane, put a not sign over the icon
    if(!pServer->IsServerSane()) NewState = STATE_NOT;
    // If we aren't done getting all the information about this server,
    // put a question mark over the icon
    else if(pServer->IsState(SS_GETTING_INFO)) NewState = STATE_QUESTION;
    // If it is fine, we want to remove any overlays from the icon
    else NewState = STATE_NORMAL;
    
    // Set the tree item to the new state
    GetTreeCtrl().SetItemState(hServer, NewState, 0x0F00);
    
    // If this Server was not opened and now is GOOD,
    // add it's children to the tree
    if(PreviousState != STATE_NORMAL && pServer->IsState(SS_GOOD)) {
        int ServerIcon = DetermineServerIcon(pServer);
        GetTreeCtrl().SetItemImage(hServer, ServerIcon, ServerIcon);
        AddServerChildren(hServer, pServer , nt );
        // If this server is the server the user is sitting at and is
        // the currently selected tree item, expand it
        if(hServer == GetTreeCtrl().GetSelectedItem() && pServer->IsCurrentServer()) {
            GetTreeCtrl().Expand(hServer, TVE_EXPAND);
        }
    }
    else if(pServer->GetPreviousState() == SS_DISCONNECTING && pServer->IsState(SS_NOT_CONNECTED)) {
        int ServerIcon = DetermineServerIcon(pServer);
        GetTreeCtrl().SetItemImage(hServer, ServerIcon, ServerIcon);
    }
    
    // If we changed the state of this server and it is the currently
    // selected node in the tree, we need to send a message to change
    // the view
    if(NewState != PreviousState && hServer == GetTreeCtrl().GetSelectedItem()) {
        ForceSelChange();
    }
    
    UnlockTreeControl();
    
    return 0;                                                                  
    
}  // end CAdminTreeView::OnAdminUpdateServer


LRESULT CAdminTreeView::OnAdminAddWinStation(WPARAM wParam, LPARAM lParam)
{
    ASSERT(lParam);
    
    ODS( L"**CAdminTreeView::OnAdminAddWinStation\n" );
    
    CWinStation *pWinStation = (CWinStation*)lParam;
    
    
    // Get the HTREEITEM of the Server this WinStation is attached to
    // TODO:
    // update the server item in the favorite list
    
    HTREEITEM hServer = pWinStation->GetServer()->GetTreeItem();
    
    
    if( hServer != NULL )
    {
        AddWinStation( pWinStation , hServer , ( BOOL )wParam , NODE_NONE );
    }
    
    hServer = pWinStation->GetServer( )->GetTreeItemFromFav( );
    
    if( hServer != NULL )
    {
        AddWinStation( pWinStation , hServer , ( BOOL )wParam , NODE_FAV_LIST );
    }
    
    hServer = pWinStation->GetServer( )->GetTreeItemFromThisComputer( );
    
    if( hServer != NULL )
    {
        AddWinStation( pWinStation , hServer , ( BOOL )wParam , NODE_THIS_COMP );
    }
    
    return 0;
}

////////////////////////////////
// F'N: CAdminTreeView::OnAdminAddWinStation
//
//	Message handler to add a WinStation to the tree
//	lParam = pointer to CWinStation to add
//	wParam is TRUE if this is replacing a WinStation that was currently selected
//
LRESULT CAdminTreeView::AddWinStation( CWinStation * pWinStation , HTREEITEM hServer , BOOL bSel , NODETYPE nt )
{   	
    ODS( L"**CAdminTreeView::AddWinStation\n" );
    
    HTREEITEM hWinStation;
    
    LockTreeControl();
    
    // Figure out which icon to use
    int WhichIcon = DetermineWinStationIcon(pWinStation);
    
    // Figure out what text to display
    TCHAR NameToDisplay[128];			
    DetermineWinStationText(pWinStation, NameToDisplay);
    
    CTreeNode *pNode = new CTreeNode(NODE_WINSTATION, pWinStation);
    if(pNode) {
        pNode->SetSortOrder(pWinStation->GetSortOrder());
        
        // We have to insert this WinStation in sorted order
        // Get the first WinStation item attached to this server
        HTREEITEM hChild = GetTreeCtrl().GetNextItem(hServer, TVGN_CHILD);
        HTREEITEM hLastChild = TVI_FIRST;
        BOOL bAdded = FALSE;
        
        while(hChild)
        {
            CTreeNode *ChildNode = (CTreeNode*)GetTreeCtrl().GetItemData(hChild);
            if(ChildNode)
            {
                // Does it belong before this tree node?
                CWinStation *pTreeWinStation = (CWinStation*)ChildNode->GetTreeObject();
                if((pTreeWinStation->GetSortOrder() > pWinStation->GetSortOrder())
                    || ((pTreeWinStation->GetSortOrder() == pWinStation->GetSortOrder()) &&
                    (pTreeWinStation->GetSdClass() > pWinStation->GetSdClass())))
                {
                    hWinStation = AddItemToTree(hServer, NameToDisplay, hLastChild, WhichIcon, (LPARAM)pNode);
                    
                    if(!hWinStation)
                    {
                        delete pNode;
                    }
                    
                    // The WinStation wants to know his tree item handle
                    
                    if( nt == NODE_FAV_LIST )
                    {
                        pWinStation->SetTreeItemForFav( hWinStation );
                    }
                    else if( nt == NODE_THIS_COMP )
                    {
                        pWinStation->SetTreeItemForThisComputer( hWinStation );
                    }
                    else
                    {
                        pWinStation->SetTreeItem(hWinStation);
                    }
                    
                    bAdded = TRUE;
                    break;
                }
            }
            hLastChild = hChild;
            hChild = GetTreeCtrl().GetNextItem(hChild, TVGN_NEXT);
        }
        
        // If we didn't add it yet, add it at the end
        if(!bAdded)
        {
            hWinStation = AddItemToTree(hServer, NameToDisplay, hLastChild, WhichIcon, (LPARAM)pNode);
            
            if( hWinStation == NULL )
            {
                delete pNode;
            }
            
            // The WinStation wants to know his tree item handle
            if( nt == NODE_FAV_LIST )
            {
                pWinStation->SetTreeItemForFav( hWinStation );
            }
            else if( nt == NODE_THIS_COMP )
            {
                pWinStation->SetTreeItemForThisComputer( hWinStation );
            }
            else
            {
                pWinStation->SetTreeItem(hWinStation);
            }
            
        }
        
        // If this is replacing a WinStation in the tree that was the currently selected
        // tree item, make this new item in the tree the currently selected item
        if( bSel ) {
            GetTreeCtrl().SelectItem(hWinStation);
        }
    }
    
    UnlockTreeControl();
    
    return 0;
    
}  // end CAdminTreeView::OnAdminAddWinStation


////////////////////////////////
// F'N: CAdminTreeView::OnAdminUpdateWinStation
//
//	Message handler to update a WinStation in the tree
//	lParam = pointer to CWinStation to update
//

LRESULT CAdminTreeView::OnAdminUpdateWinStation(WPARAM wParam, LPARAM lParam)
{
    ODS( L"CAdminTreeView::OnAdminUpdateWinStation\n" );
    
    ASSERT(lParam);
    
    CWinStation *pWinStation = (CWinStation*)lParam;
    
    
    HTREEITEM hWinStation = pWinStation->GetTreeItem();
    
    if( hWinStation != NULL )
    {
        UpdateWinStation( hWinStation , pWinStation );
    }
    
    hWinStation = pWinStation->GetTreeItemFromFav( );
    
    if( hWinStation != NULL )
    {
        UpdateWinStation( hWinStation , pWinStation );
    }
    
    hWinStation = pWinStation->GetTreeItemFromThisComputer( );
    
    if( hWinStation != NULL )
    {
        UpdateWinStation( hWinStation , pWinStation );
    }
    
    return 0;
}



LRESULT CAdminTreeView::UpdateWinStation( HTREEITEM hWinStation , CWinStation *pWinStation )
{      
    ODS( L"CAdminTreeView::UpdateWinStation\n" );
    
    LockTreeControl();
    
    // Get the data attached to this tree node
    CTreeNode *node = (CTreeNode*)GetTreeCtrl().GetItemData(hWinStation);
    if(node) {
        // Is this the WinStation we want to update
        CWinStation *pTreeWinStation = (CWinStation*)node->GetTreeObject();
        // Make sure the tree node is correct
        if(pTreeWinStation != pWinStation) {
            UnlockTreeControl();
            return 0;
        }
    } else {
        UnlockTreeControl();
        return 0;
    }
    
    // If the sort order of this WinStation has changed,
    // we have to remove it from the tree and add it back in
    if(node->GetSortOrder() != pWinStation->GetSortOrder())
    {
        OnAdminRemoveWinStation( 0 , ( LPARAM )pWinStation );
        
        /*GetTreeCtrl().DeleteItem(hWinStation);
        
          pWinStation->SetTreeItem(NULL);
        */
        
        OnAdminAddWinStation((GetTreeCtrl().GetSelectedItem() == hWinStation), ( LPARAM )pWinStation );
        
        UnlockTreeControl();
        return 0;
    }
    
    int WhichIcon = DetermineWinStationIcon(pWinStation);
    GetTreeCtrl().SetItemImage(hWinStation, WhichIcon, WhichIcon);
    
    TCHAR NameToDisplay[128];			
    DetermineWinStationText(pWinStation, NameToDisplay);
    GetTreeCtrl().SetItemText(hWinStation, NameToDisplay);
    
    UnlockTreeControl();
    
    return 0;
    
}  // end CAdminTreeView::OnAdminUpdateWinStation


////////////////////////////////
// F'N: CAdminTreeView::OnAdminRemoveWinStation
//
//	Message handler to remove a WinStation from the tree
//	lParam = pointer to CWinStation to remove
LRESULT CAdminTreeView::OnAdminRemoveWinStation(WPARAM wParam, LPARAM lParam)
{   
    ODS( L"CAdminTreeView::OnAdminRemoveWinStation\n" );
    
    ASSERT(lParam);
    
    //TODO:
    // remove winstaion from favorite list
    
    CWinStation *pWinStation = (CWinStation*)lParam;
    
    HTREEITEM hWinStation;
    
    hWinStation = pWinStation->GetTreeItem();
    
    if( hWinStation != NULL )
    {
        RemoveWinstation( hWinStation , pWinStation );
        
        pWinStation->SetTreeItem( NULL );
    }
    
    hWinStation = pWinStation->GetTreeItemFromFav( );
    
    if( hWinStation != NULL )
    {
        RemoveWinstation( hWinStation , pWinStation );
        
        pWinStation->SetTreeItemForFav( NULL );
    }
    
    hWinStation = pWinStation->GetTreeItemFromThisComputer( );
    
    if( hWinStation != NULL )
    {
        RemoveWinstation( hWinStation , pWinStation );
        
        pWinStation->SetTreeItemForThisComputer( NULL );
    }
    
    return 0;
    
}

LRESULT CAdminTreeView::RemoveWinstation( HTREEITEM hWinStation , CWinStation *pWinStation )
{
    BOOL CurrentInTree = FALSE;
    
    LockTreeControl();
    
    // Get the data attached to this tree node
    CTreeNode *node = ( CTreeNode * )GetTreeCtrl().GetItemData(hWinStation);
    
    if( node != NULL )
    {
        // Is this the WinStation we want to update
        CWinStation *pTreeWinStation = (CWinStation*)node->GetTreeObject();
        // Make sure the tree node is correct
        if(pTreeWinStation != pWinStation)
        {
            UnlockTreeControl();
            return 0;
        }
    }
    else
    {
        UnlockTreeControl();
        return 0;
    }
    
    // Delete the data attached to the tree item
    delete node;
    // Let the WinStation know he is no longer in the tree
    
    // Is this WinStation currently selected in the tree?
    CurrentInTree = ( GetTreeCtrl().GetSelectedItem() == hWinStation );
    
    // Remove the WinStation from the tree
    GetTreeCtrl().DeleteItem( hWinStation );
    
    // If this WinStation is the currently selected node in the tree,
    // make it not so
    // This may not be necessary!
    if( CurrentInTree )
    {
        ((CWinAdminDoc*)GetDocument())->SetCurrentView(VIEW_CHANGING);
    }
    
    UnlockTreeControl();
    
    return 0;
    
}  // end CAdminTreeView::OnAdminRemoveWinStation


////////////////////////////////
// F'N: CAdminTreeView::OnAdminUpdateDomain
//
//	Message handler to update a Domain in the tree
//	Pointer to CDomain to update is in lParam
//
LRESULT CAdminTreeView::OnAdminUpdateDomain(WPARAM wParam, LPARAM lParam)
{   
    ASSERT(lParam);
    
    CDomain *pDomain = (CDomain*)lParam;
    
    HTREEITEM hDomain = pDomain->GetTreeItem();
    if(!hDomain) return 0;
    
    LockTreeControl();
    
    // Get the data attached to this tree node
    CTreeNode *node = (CTreeNode*)GetTreeCtrl().GetItemData(hDomain);
    if(node) {
        // Is this the domain we want to update
        CDomain *pTreeDomain = (CDomain*)node->GetTreeObject();
        // Make sure the tree node is correct
        if(pTreeDomain != pDomain) {
            UnlockTreeControl();
            return 0;
        }
    } else {
        UnlockTreeControl();
        return 0;
    }
    
    UINT NewState;
    // Remember the previous state
    UINT PreviousState = GetTreeCtrl().GetItemState(hDomain, 0x0F00);
    // Change the icon/overlay for the domain
    if(pDomain->GetState() == DS_INITIAL_ENUMERATION) NewState = STATE_QUESTION;
    // If it is fine, we want to remove any overlays from the icon
    else NewState = STATE_NORMAL;
    
    // Set the tree item to the new state
    GetTreeCtrl().SetItemState(hDomain, NewState, 0x0F00);
    
    // If the new state is STATE_NORMAL, change the icon
    if(NewState == STATE_NORMAL) {
        int DomainIcon = DetermineDomainIcon(pDomain);
        GetTreeCtrl().SetItemImage(hDomain, DomainIcon, DomainIcon);			
    }
    
    // If we changed the state of this domain and it is the currently
    // selected node in the tree, we need to send a message to change
    // the view
    if(NewState != PreviousState && hDomain == GetTreeCtrl().GetSelectedItem()) {
        ForceSelChange();
    }
    
    if(pDomain->GetState() == DS_ENUMERATING) GetTreeCtrl().Expand(hDomain, TVE_EXPAND);
    
    UnlockTreeControl();
    
    return 0;                                                                  
    
}  // end CAdminTreeView::OnAdminUpdateDomain

////////////////////////////////
// F'N: CAdminTreeView::OnAdminAddDomain
//
//	Message handler to update a Domain in the tree
//	Pointer to CDomain to update is in lParam
//
LRESULT CAdminTreeView::OnAdminAddDomain(WPARAM wParam, LPARAM lParam)
{   
    ASSERT(lParam);
    
    if(lParam)
    {
        CDomain *pDomain = (CDomain*)lParam;
        return (LRESULT)AddDomainToTree(pDomain);
    }

    return 0;

} // end CAdminTreeView::OnAdminAddDomain

////////////////////////////////
// F'N: CAdminTreeView::OnContextMenu
//
//	Message handler called when user wants a context menu
//	This happens when the user clicks the right mouse button,
//	presses Shift-F10, or presses the menu key on a Windows keyboard
//
void CAdminTreeView::OnContextMenu(CWnd* pWnd, CPoint ptScreen) 
{
    LockTreeControl();
    
    // Get a pointer to our document
    CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();
    
    CTreeCtrl &tree = GetTreeCtrl();
    
    // TODO: Add your message handler code here
    HTREEITEM hItem;
    CPoint ptClient = ptScreen;
    ScreenToClient(&ptClient);
    
    // If we got here from the keyboard,
    if(ptScreen.x == -1 && ptScreen.y == -1) {
        hItem = tree.GetSelectedItem();
        
        RECT rect;
        tree.GetItemRect(hItem, &rect, TRUE);
        
        ptScreen.x = rect.left + (rect.right -  rect.left)/2;
        ptScreen.y = rect.top + (rect.bottom - rect.top)/2;
        
        tree.ClientToScreen(&ptScreen);
        
    }
    else {
        // we shouldn't get here from the mouse
        // but sometimes we do, so handle it gracefully
        UnlockTreeControl();
        return;
    }
    
    // Pop-up the menu for WinStations
    CTreeNode *pNode = (CTreeNode*)tree.GetItemData(hItem);
    ((CWinAdminDoc*)GetDocument())->SetTreeTemp(pNode->GetTreeObject(), (pNode->GetNodeType()));
    
    if(pNode) {
        CMenu menu;
        UINT nIDResource = 0;
        
        switch(pNode->GetNodeType()) {
        case NODE_ALL_SERVERS:
            nIDResource = IDR_ALLSERVERS_POPUP;
            break;
            
        case NODE_DOMAIN:
            nIDResource = IDR_DOMAIN_POPUP;
            break;
            
        case NODE_SERVER:
            nIDResource = IDR_SERVER_POPUP;
            break;
            
        case NODE_WINSTATION:
            nIDResource = IDR_WINSTATION_TREE_POPUP;
            break;
        }
        
        if(nIDResource)
        {
            if(menu.LoadMenu(nIDResource))
            {
                CMenu *pMenu = menu.GetSubMenu(0);
                
                pMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
            }
        }
        
    } // end if(pNode)
    
    UnlockTreeControl();
    
} // end CAdminTreeView::OnContextMenu


////////////////////////////////
// F'N: CAdminTreeView::OnRClick
//
// The Tree Common Control sends a WM_NOTIFY of NM_RCLICK when
// the user presses the right mouse button in the tree
//
void CAdminTreeView::OnRClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    CPoint ptScreen(::GetMessagePos());
    
    LockTreeControl();
    
    // Get a pointer to our document
    CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();
    
    CTreeCtrl &tree = GetTreeCtrl();
    
    // TODO: Add your message handler code here
    UINT flags;
    HTREEITEM hItem;
    CPoint ptClient = ptScreen;
    ScreenToClient(&ptClient);
    
    hItem = tree.HitTest(ptClient, &flags);
    if((NULL == hItem) || !(TVHT_ONITEM & flags)) {
        UnlockTreeControl();
        return;
    }
    
    // Pop-up the menu
    CTreeNode *pNode = (CTreeNode*)tree.GetItemData(hItem);
    ((CWinAdminDoc*)GetDocument())->SetTreeTemp(pNode->GetTreeObject(), (pNode->GetNodeType()));
    
    if(pNode) {
        CMenu menu;
        UINT nIDResource = 0;
        
        tree.SelectItem( hItem );
        
        switch(pNode->GetNodeType()) {
        case NODE_ALL_SERVERS:
            nIDResource = IDR_ALLSERVERS_POPUP;
            break;
            
        case NODE_DOMAIN:
            nIDResource = IDR_DOMAIN_POPUP;
            break;
            
        case NODE_SERVER:
            nIDResource = IDR_SERVER_POPUP;
            break;
            
        case NODE_WINSTATION:
            nIDResource = IDR_WINSTATION_TREE_POPUP;
            break;
        }
        
        if(menu.LoadMenu( nIDResource ) )
        {
            CMenu *pMenu = menu.GetSubMenu(0);
            
            if( pMenu != NULL )
            {               
                pMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
            }
        }
        
        
    } // end if(pNode)
    
    UnlockTreeControl();
    
}	// end CAdminTreeView::OnRClick



//A false result means the server is disconnected
BOOL CAdminTreeView::ConnectToServer(CTreeCtrl* tree, HTREEITEM* hItem)
{
    CTreeNode *pNode = (CTreeNode*)tree->GetItemData(*hItem);
    
    if(pNode != NULL && *hItem == tree->GetSelectedItem() )
    {
        if( pNode->GetNodeType() == NODE_SERVER)
        {
            // Is this server in the "just disconnected" state
            CServer *pServer = (CServer*)pNode->GetTreeObject();
            // If both previous state and state are SS_NOT_CONNECTED,
            // we know the user just disconnected from this server
            if(pServer && pServer->IsState(SS_NOT_CONNECTED))
                return false;
        }
        else if( pNode->GetNodeType( ) == NODE_DOMAIN )
        {
            CDomain *pDomain = ( CDomain * )pNode->GetTreeObject( );
            
            if( pDomain != NULL && pDomain->GetThreadPointer() == NULL )
                pDomain->StartEnumerating();                
        }
    }

    return true;
}

////////////////////////////////
// F'N: CAdminTreeView::OnLButtonDown
//
void CAdminTreeView::OnLButtonDblClk(UINT nFlags, CPoint ptClient) 
{
    LockTreeControl();
    
    CTreeCtrl &tree = GetTreeCtrl();
    
    UINT flags;
    
    // Figure out what they clicked on
    HTREEITEM hItem = tree.HitTest(ptClient, &flags);
    if((NULL != hItem) && (TVHT_ONITEM & flags)) 
    {
        if (!ConnectToServer(&tree, &hItem))
        {
            LRESULT Result = 0xc0;
            OnSelChange(NULL, &Result);
        }
    }

    UnlockTreeControl();
    
    CTreeView::OnLButtonDblClk(nFlags, ptClient);
}


LRESULT CAdminTreeView::OnAdminConnectToServer( WPARAM wp , LPARAM lp )
{
    OnEnterKey();
    return 0;
}

void CAdminTreeView::OnEnterKey( )
{
    LockTreeControl();
    
    CTreeCtrl &tree = GetTreeCtrl();
    
    // Figure out what's selected
    HTREEITEM hItem = tree.GetSelectedItem( );
    
    if (!ConnectToServer(&tree, &hItem))
    {
        LRESULT Result = 0xc0;
        OnSelChange(NULL, &Result);
    }

    UnlockTreeControl();
}

void CAdminTreeView::OnSetFocus( CWnd *pOld )
{
    CWnd::OnSetFocus( pOld );
    
    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();
    
    pDoc->RegisterLastFocus( TREE_VIEW );
    
}

//=---------------------------------------------------------------------------------------
// wp is the node type to expand on
// this computer
// favorite item
// domain item

LRESULT CAdminTreeView::OnAdminGotoServer( WPARAM wp , LPARAM lp )
{
    // todo use wp correctly
    
    CServer *pServer = ( CServer * )lp;
    
    if( pServer == NULL )
    {
        ODS( L"CAdminTreeView::OnAdminGotoServer invalid server arg\n" );
        return 0 ;
    }
    
    LockTreeControl( );
    
    CTreeCtrl &tree = GetTreeCtrl( );
    
    HTREEITEM hTreeItem = pServer->GetTreeItem( );
    
    if( hTreeItem != NULL )
    {
        ODS( L"CAdminTreeView!OnAdminGotoServer - Server treeitem was found\n" );
        
        tree.SelectItem(hTreeItem);
        
        tree.Expand(hTreeItem, TVE_EXPAND);
    }
    
    UnlockTreeControl( );
    
    return 0;
}

//=---------------------------------------------------------------------------------------
// wp and lp not used
//
LRESULT CAdminTreeView::OnAdminDelFavServer( WPARAM wp , LPARAM lp )
{
    // get the current treenode
    // determine if its a fav folder or if its parent a fav folder
    // if so get the server and kill it
    LockTreeControl( );
    
    CTreeCtrl &tree = GetTreeCtrl( );
    
    HTREEITEM hTreeItem = tree.GetSelectedItem();
    
    do
    {
        if( hTreeItem == NULL )
        {
            break;
        }
        
        HTREEITEM hTreeRoot = tree.GetRootItem( );
        
        if( hTreeRoot == NULL )
        {
            break;
        }
        
        // get fav folder
        
        HTREEITEM hTreeFavRoot =  tree.GetNextItem( hTreeRoot , TVGN_NEXT );
        
        if( hTreeFavRoot == NULL )
        {
            break;
        }
        
        
        if( hTreeFavRoot == hTreeItem )
        {
            // not a cool thing here ignore
            break;
        }
        
        hTreeRoot = tree.GetNextItem( hTreeItem , TVGN_PARENT );
        
        if( hTreeFavRoot == hTreeRoot )
        {
            // yes we're talking about a fav node that the user wants to delete
            
            CTreeNode *pNode = ( CTreeNode* )tree.GetItemData( hTreeItem );
            
            if( pNode != NULL && pNode->GetNodeType() == NODE_SERVER )
            {                
                CServer *pServer = ( CServer* )pNode->GetTreeObject();
                
                // sanity check
                if( pServer != NULL && pServer->GetTreeItemFromFav() == hTreeItem )
                {
                    OnAdminRemoveServerFromFavs( 0 , ( LPARAM )pServer );
                }
            }
        }
        
        
    }while( 0 );
    
    UnlockTreeControl( );
    
    return 0;
}

//=-------------------------------------------------------------
LRESULT CAdminTreeView::OnGetTVStates( WPARAM ,  LPARAM )
{
    ODS( L"CAdminTreeView::OnGetTVStates\n" );
    
    DWORD dwStates = 0;
    
    // find out the tri-states
    HTREEITEM hRoot;
    
    LockTreeControl( );
    
    CTreeCtrl &tree = GetTreeCtrl( );
    
    
    hRoot = tree.GetRootItem( ); // this computer
    
    if( hRoot != NULL )
    {
        if( tree.GetItemState( hRoot , TVIS_EXPANDED ) & TVIS_EXPANDED  )
        {
            dwStates = TV_THISCOMP;
        }
        
        hRoot = tree.GetNextItem( hRoot , TVGN_NEXT ); // favorites
        
        if( hRoot != NULL && tree.GetItemState( hRoot , TVIS_EXPANDED ) & TVIS_EXPANDED  )
        {
            dwStates |= TV_FAVS;
        }
        
        hRoot = tree.GetNextItem( hRoot , TVGN_NEXT ); // all servers
        
        if( hRoot != NULL && tree.GetItemState( hRoot , TVIS_EXPANDED ) & TVIS_EXPANDED  )
        {
            dwStates |= TV_ALLSERVERS;
        }
    }
    
    UnlockTreeControl( );
    
    return ( LRESULT )dwStates;
}

//=-------------------------------------------------------------
LRESULT CAdminTreeView::OnUpdateTVState( WPARAM , LPARAM )
{
    LRESULT lResult = 0xc0;
    HTREEITEM hThisComputerRootItem = GetTreeCtrl().GetRootItem( );
    HTREEITEM hFavRoot = GetTreeCtrl().GetNextItem( hThisComputerRootItem , TVGN_NEXT );
    HTREEITEM hRoot = GetTreeCtrl().GetNextItem( hFavRoot , TVGN_NEXT );
    // We want to default to having the current server being the
    // currently selected item in the tree and be expanded
    
    if( hThisComputerRootItem != NULL && ( g_dwTreeViewExpandedStates & TV_THISCOMP ) )
    {
        HTREEITEM hThisComputer = GetTreeCtrl().GetNextItem( hThisComputerRootItem , TVGN_CHILD );
        
        if( hThisComputer != NULL )
        {
            GetTreeCtrl().SelectItem(hThisComputer);
            GetTreeCtrl().Expand(hThisComputer, TVE_EXPAND);
            // GetTreeCtrl().Expand(hDomain, TVE_EXPAND);        
            //lResult = 0xc0;
            OnSelChange( NULL , &lResult );
        }
    }
    
    if( hFavRoot != NULL && ( g_dwTreeViewExpandedStates & TV_FAVS ) )
    {
        GetTreeCtrl().SelectItem( hFavRoot );
        GetTreeCtrl().Expand( hFavRoot , TVE_EXPAND );
        OnSelChange( NULL , &lResult );
    }
    
    if( hRoot != NULL && ( g_dwTreeViewExpandedStates & TV_ALLSERVERS ) )
    {
        GetTreeCtrl().SelectItem( hRoot );
        GetTreeCtrl().Expand( hRoot , TVE_EXPAND );
        OnSelChange( NULL , &lResult );
    }
    
    return 0;
}

//=-------------------------------------------------------------
void CAdminTreeView::OnBeginDrag( NMHDR *pNMHDR , LRESULT *pResult )
{
    ODS( L"CAdminTreeView::OnBeginDrag\n" );
    
    RECT rc;
    
    NMTREEVIEW *pTV = ( NMTREEVIEW * )pNMHDR;
    
    if( pTV != NULL )
    {
        
        if( m_pimgDragList != NULL )
        {
            // this should never happen
            ODS( L"There is a possible leak CAdminTreeView!OnBeginDrag\n" );
            
            delete m_pimgDragList;
            
            m_pimgDragList = NULL;
        }
        
        if( pTV->itemNew.hItem != NULL )
        {
            m_pimgDragList = GetTreeCtrl().CreateDragImage( pTV->itemNew.hItem );
        }
        
        if( m_pimgDragList != NULL )
        {            
            GetTreeCtrl().GetItemRect( pTV->itemNew.hItem , &rc , FALSE );
            
            CPoint cp( pTV->ptDrag.x - rc.left , pTV->ptDrag.y - rc.top );
            
            /*
            HCURSOR  hCursor = ::LoadCursor( NULL, IDC_CROSS );
            
              ICONINFO iconinfo;
              
                ::GetIconInfo( ( HICON )hCursor , &iconinfo );
            */
            
            
            m_pimgDragList->BeginDrag( 0 , CPoint( 0 , 0 ) );            
            
            /*
            cp.x -= iconinfo.xHotspot;
            cp.y -= iconinfo.yHotspot;
            
              m_pimgDragList->SetDragCursorImage(  0 , cp );
            */
            
            m_pimgDragList->DragEnter( &GetTreeCtrl( ) , cp );
            
            SetCapture();
            
            // this is for us to check when we're not in the client area
            m_nTimer = SetTimer( 1 , 50 , NULL );
            
            //ShowCursor( FALSE );
            
            m_hDragItem = pTV->itemNew.hItem;
            
            
        }
    }
    
    *pResult = 0;
}

//=-------------------------------------------------------------
void CAdminTreeView::OnTimer( UINT nIDEvent )
{
    UINT uflags;
    
    POINT pt;
    
    CTreeCtrl &cTree = GetTreeCtrl( );
    
    GetCursorPos(&pt);
    
    cTree.ScreenToClient( &pt );
    
    if( m_nTimer == 0 )
    {
        return;
    }
    
    HTREEITEM hItem;
    
    HTREEITEM hTreeItem = cTree.HitTest( CPoint( pt.x , pt.y ) , &uflags );
    
    if( uflags & TVHT_ABOVE )
    {
        ODS( L"scrolling up...\n" );
        
        hItem = cTree.GetFirstVisibleItem( );
        
        hItem = cTree.GetNextItem( hItem , TVGN_PREVIOUSVISIBLE  );
        
        if( hItem != NULL )
        {
            cTree.Invalidate( );
            
            cTree.EnsureVisible( hItem );
        }
        
    }
    else if( uflags & TVHT_BELOW )
    {
        ODS( L"scrolling down...\n" );
        
        hItem = cTree.GetFirstVisibleItem( );
        
        hItem = cTree.GetNextItem( hItem , TVGN_NEXT );
        
        if( hItem != NULL )
        {
            cTree.EnsureVisible( hItem );
        }
        
    }
    
}

//=-------------------------------------------------------------
void CAdminTreeView::OnLButtonUp( UINT uFlags , CPoint cp )
{
    ODS( L"CAdminTreeView::OnLButtonUp\n" );
    
    if( m_hDragItem != NULL && m_pimgDragList != NULL )
    {
        m_pimgDragList->DragLeave( &GetTreeCtrl( ) );
        
        m_pimgDragList->EndDrag( );
        
        m_pimgDragList->DeleteImageList( );
        
        delete m_pimgDragList;
        
        m_pimgDragList = NULL;
        
        KillTimer( m_nTimer );
        
        m_nTimer = 0;
        
        ReleaseCapture( );
        
        Invalidate( );
        
        // ShowCursor( TRUE );
    }
}


//=-------------------------------------------------------------        
void CAdminTreeView::OnMouseMove( UINT uFlags , CPoint cp )
{
    if( m_pimgDragList != NULL )
    {
        UINT uflags;
        
        HTREEITEM hTreeItem = GetTreeCtrl( ).HitTest( cp , &uflags );
        
        if( hTreeItem != GetTreeCtrl( ).GetDropHilightItem( ) )
        {
            ODS( L"CAdminTreeView::OnMouseMove NOT!!\n");
            m_pimgDragList->DragLeave( &GetTreeCtrl( ) );
            
            GetTreeCtrl( ).SelectDropTarget( NULL );
            GetTreeCtrl( ).SelectDropTarget( hTreeItem );
            
            m_pimgDragList->DragEnter( &GetTreeCtrl( ) , cp );
        }
        else
        {
            m_pimgDragList->DragMove( cp );
        }
    }
}

//=-------------------------------------------------------------
LRESULT CAdminTreeView::OnEmptyFavorites( WPARAM wp, LPARAM )
{
    ODS( L"CAdminTreeView!OnEmptyFavorites\n" );
    
    // check to see if there are any items in the view
    
    LockTreeControl( );
    
    CTreeCtrl &tree = GetTreeCtrl( );
    
    int nRet;
    
    HTREEITEM hTreeRoot = tree.GetRootItem( );
    
    do
    {
        if( hTreeRoot == NULL )
        {
            break;    
        }
        
        // get fav folder
        
        HTREEITEM hTreeFavRoot =  tree.GetNextItem( hTreeRoot , TVGN_NEXT );
        
        if( hTreeFavRoot == NULL )
        {
            break;
        }
        
        HTREEITEM hItem = tree.GetNextItem( hTreeFavRoot , TVGN_CHILD );
        
        if( hItem == NULL )
        {
            break;
        }
        
        // warn the user about losing the entire favorite list
        
        CString cstrMsg;
        CString cstrTitle;
        
        cstrMsg.LoadString( IDS_EMPTYFOLDER );
        cstrTitle.LoadString( AFX_IDS_APP_TITLE );
        
        
        
#ifdef _STRESS_BUILD
        if( ( BOOL )wp != TRUE )
        {
#endif
            
            
            nRet = MessageBox( cstrMsg ,
                cstrTitle ,
                MB_YESNO | MB_ICONINFORMATION );
            
#ifdef _STRESS_BUILD
        }
        else
        {
            nRet = IDYES;
        }
#endif
        
        
        if( nRet == IDYES )
        {
            // loop through every item and remove the item
            HTREEITEM hNextItem = hItem;
            
            while( hItem != NULL )
            {
                CTreeNode *pNode = (CTreeNode*)tree.GetItemData(hItem);
                
                hNextItem = tree.GetNextItem( hItem , TVGN_NEXT );
                
                if( pNode != NULL )
                {
                    // Is it the same item as is selected
                    if( pNode->GetNodeType() == NODE_SERVER )
                    {                    
                        CServer *pServer = (CServer*)pNode->GetTreeObject();
                        
                        // skip this server if its being disconnected
                        
                        if( !pServer->IsState( SS_DISCONNECTING ) )
                        {
                            SendMessage( WM_ADMIN_REMOVESERVERFROMFAV , 0 , ( LPARAM )pServer );
                        }
                    }
                }
                
                hItem = hNextItem;                
            }
        }
        
    }while( 0 );
    
    UnlockTreeControl( );
    
    
    return 0;
}

//=----------------------------------------------------------------
LRESULT CAdminTreeView::OnIsFavListEmpty( WPARAM wp , LPARAM lp )
{
    LockTreeControl( );
    
    CTreeCtrl &tree = GetTreeCtrl( );
    
    HTREEITEM hTreeRoot = tree.GetRootItem( );
    
    BOOL bEmpty = TRUE;
    
    do
    {
        if( hTreeRoot == NULL )
        {            
            break;    
        }
        
        // get fav folder
        
        HTREEITEM hTreeFavRoot =  tree.GetNextItem( hTreeRoot , TVGN_NEXT );
        
        if( hTreeFavRoot == NULL )
        {            
            break;
        }
        
        HTREEITEM hItem = tree.GetNextItem( hTreeFavRoot , TVGN_CHILD );
        
        if( hItem == NULL )
        {
            break;
        }
        
        bEmpty = FALSE;
        
    } while( 0 );
    
    UnlockTreeControl( );
    
    return ( LRESULT )bEmpty;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\treeview.h ===
/*******************************************************************************
*
* treeview.h
*
* - declarations for the CAdminTreeView class
* - the CAdminTreeView class lives in the left pane of the mainframe's splitter
* - derived from CTreeView
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\treeview.h  $
*  
*     Rev 1.6   19 Feb 1998 17:42:36   donm
*  removed latest extension DLL support
*  
*     Rev 1.4   19 Jan 1998 16:49:24   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.3   03 Nov 1997 15:21:42   donm
*  added Domains
*  
*     Rev 1.2   13 Oct 1997 18:42:02   donm
*  update
*  
*     Rev 1.9   29 Jul 1997 10:11:48   butchd
*  update
*  
*     Rev 1.8   14 Mar 1997 17:13:24   donm
*  update
*  
*     Rev 1.7   11 Mar 1997 17:26:10   donm
*  update
*  
*     Rev 1.6   26 Feb 1997 15:29:34   donm
*  update
*  
*     Rev 1.5   14 Feb 1997 08:57:46   donm
*  update
*  
*     Rev 1.4   04 Feb 1997 18:13:58   donm
*  update
*  
*     Rev 1.3   03 Feb 1997 16:35:40   donm
*  update
*  
*     Rev 1.2   29 Jan 1997 18:39:02   donm
*  update
*******************************************************************************/

#ifndef _TREEVIEW_H
#define _TREEVIEW_H

#include "afxcview.h"
#include "basetree.h"

///////////////////////
// CLASS: CAdminTreeView
//
class CAdminTreeView : public CBaseTreeView
{
friend class CTreeTabCtrl;
friend class CLeftPane;

protected:
	CAdminTreeView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAdminTreeView)

// Attributes
protected:
	int m_idxBlank;		// index of Blank icon image
	int m_idxCitrix;	// index of Citrix icon image
	int m_idxServer;	// index of Server icon image 
	int m_idxConsole;	// index of Console icon image
	int m_idxNet;		// index of Net icon image
	int m_idxNotSign;	// index of Not Sign overlay (for non-sane servers)
	int m_idxQuestion;	// index of Question Mark overlay (for non-opened servers)
	int m_idxUser;		// index of User icon image
	int m_idxAsync;		// index of Async icon image (modem)
	int m_idxCurrentServer;	// index of Current Server image
	int m_idxCurrentNet;	// index of Current Net image
	int m_idxCurrentConsole;// index of Current Console image
	int m_idxCurrentAsync;	// index of Current Async image
	int m_idxDirectAsync;	// index of Direct Async image
	int m_idxCurrentDirectAsync; // index of Current Direct Async image
    int m_idxDomain;        // index of Domain image
    int m_idxCurrentDomain; // index of Current Domain image
	int m_idxDomainNotConnected;  // index of Domain Not Connected image
	int m_idxServerNotConnected;  // index of Server Not Connected image
    
    CImageList *m_pimgDragList;
    HTREEITEM m_hDragItem;
    UINT_PTR m_nTimer;

// Operations
public:

protected:

private:
    // Builds the image list
    virtual void BuildImageList();			
	
    // Add the WinStations attached to a particular Server
    void AddServerChildren(HTREEITEM hServer, CServer *pServer , NODETYPE );
    // Add a Domain to the tree
    HTREEITEM AddDomainToTree(CDomain *pDomain);
    // Determines what text to use for a WinStation in the tree
    void DetermineWinStationText(CWinStation *pWinStation, TCHAR *text);
    // Determines which icon to use for a WinStation in the tree
    int DetermineWinStationIcon(CWinStation *pWinStation);
    // Determine which icon to use for a Domain in the tree
    int DetermineDomainIcon(CDomain *pDomain);
    // Determine which icon to use for a Server in the tree
    int DetermineServerIcon(CServer *pServer);
    BOOL ConnectToServer(CTreeCtrl* tree, HTREEITEM* hItem);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAdminTreeView)
    public:
//	virtual void OnInitialUpdate();
    protected:
//	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
//	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAdminTreeView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    LRESULT UpdateServerTreeNodeState( HTREEITEM , CServer * , NODETYPE );
    LRESULT RemoveWinstation( HTREEITEM , CWinStation * );
    LRESULT UpdateWinStation( HTREEITEM , CWinStation * );
    LRESULT AddWinStation( CWinStation * , HTREEITEM , BOOL , NODETYPE );

	// Generated message map functions
protected:
	//{{AFX_MSG(CAdminTreeView)
	afx_msg LRESULT OnAdminAddServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminAddWinStation(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateWinStation(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveWinStation(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateDomain(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAdminAddDomain(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminViewsReady(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAdminAddServerToFavs( WPARAM , LPARAM );
    afx_msg LRESULT OnAdminRemoveServerFromFavs( WPARAM , LPARAM );
    afx_msg LRESULT OnAdminGotoServer( WPARAM , LPARAM );
    afx_msg LRESULT OnAdminDelFavServer( WPARAM wp , LPARAM lp );
    afx_msg LRESULT OnGetTVStates( WPARAM ,  LPARAM );
    afx_msg LRESULT OnUpdateTVState( WPARAM , LPARAM );
    afx_msg LRESULT OnEmptyFavorites( WPARAM , LPARAM );
    afx_msg LRESULT OnIsFavListEmpty( WPARAM , LPARAM );
    afx_msg LRESULT OnAdminConnectToServer( WPARAM , LPARAM );



	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnRClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);    
    afx_msg void OnEnterKey( );
    afx_msg void OnSetFocus( CWnd *pOld );
    afx_msg void OnBeginDrag(  NMHDR * , LRESULT * );
    afx_msg void OnLButtonUp( UINT , CPoint );
    afx_msg void OnMouseMove( UINT , CPoint );
    afx_msg void OnTimer( UINT nIDEvent );



	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAdminTreeView

#endif  // _TREEVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\servpgs.h ===
/*******************************************************************************
*
* servpgs.h
*
* - declarations for the Server info pages
* - the server info pages are all CFormView derivatives
*   based on dialog templates
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\winadmin\VCS\servpgs.h  $
*  
*     Rev 1.2   03 Nov 1997 15:30:16   donm
*  added descending sort
*  
*     Rev 1.1   13 Oct 1997 18:39:42   donm
*  update
*  
*     Rev 1.0   30 Jul 1997 17:12:32   butchd
*  Initial revision.
*  
*******************************************************************************/

#ifndef _SERVERPAGES_H
#define _SERVERPAGES_H

#include "Resource.h"
#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "winadmin.h"

//////////////////////////
// CLASS: CUsersPage
//
class CUsersPage : public CAdminPage
{
friend class CServerView;

protected:
	CUsersPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CUsersPage)

// Form Data
public:
	//{{AFX_DATA(CUsersPage)
	enum { IDD = IDD_SERVER_USERS };
	CListCtrl	m_UserList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxUser;			// index of User image
	int m_idxCurrentUser;	// index of Current User image

private:
	CServer* m_pServer;		// pointer to current server's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
	void UpdateWinStations(CServer *pServer);
    virtual void ClearSelections();
private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayUsers();			
	virtual void Reset(void *pServer);
	int AddUserToList(CWinStation *pWinStation);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CUsersPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CUsersPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CUsersPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnUserItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusUserList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusUserList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CUsersPage

//////////////////////////
// CLASS: CServerWinStationsPage
//
class CServerWinStationsPage : public CAdminPage
{
friend class CServerView;

protected:
	CServerWinStationsPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CServerWinStationsPage)

// Form Data
public:
	//{{AFX_DATA(CServerWinStationsPage)
	enum { IDD = IDD_SERVER_WINSTATIONS };
	CListCtrl	m_StationList;
	//}}AFX_DATA

// Attributes
public:
    
protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxBlank;			// index of Blank image
	int m_idxCitrix;		// index of Citrix image
	int m_idxServer;		// index of Server image 
	int m_idxConsole;		// index of Console image
	int m_idxNet;			// index of Net image
	int m_idxAsync;			// index of Async image
	int m_idxCurrentNet;	// index of Current Net image
	int m_idxCurrentConsole;// index of Current Console image
	int m_idxCurrentAsync;	// index of Current Async image
	int m_idxDirectAsync;	// index of Direct Async image
	int m_idxCurrentDirectAsync; // index of Current Direct Async image

private:
	CServer* m_pServer;	// pointer to current server's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
	void UpdateWinStations(CServer *pServer);
    virtual void ClearSelections();
private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayStations();			
	virtual void Reset(void *pServer);
	int AddWinStationToList(CWinStation *pWinStation);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerWinStationsPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CServerWinStationsPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CServerWinStationsPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnWinStationItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CServerWinStationsPage

////////////////////////////
// CLASS: CServerProcessesPage
//
class CServerProcessesPage : public CAdminPage
{
friend class CServerView;

protected:
	CServerProcessesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CServerProcessesPage)

// Form Data
public:
	//{{AFX_DATA(CServerProcessesPage)
	enum { IDD = IDD_SERVER_PROCESSES };
	CListCtrl	m_ProcessList;
	//}}AFX_DATA

// Attributes
public:

private:
	CServer *m_pServer;
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
	void UpdateProcesses();
	void RemoveProcess(CProcess *pProcess);

private:
	void DisplayProcesses();			
	virtual void Reset(void *pServer);
	int AddProcessToList(CProcess *pProcess);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerProcessesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CServerProcessesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CServerProcessesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CServerProcessesPage


//////////////////////////
// CLASS: CServerLicensesPage
//
class CServerLicensesPage : public CAdminPage
{
friend class CServerView;

protected:
	CServerLicensesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CServerLicensesPage)

// Form Data
public:
	//{{AFX_DATA(CServerLicencesPage)
	enum { IDD = IDD_SERVER_LICENSES };
	CListCtrl	m_LicenseList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control
	
	int m_idxBase;		// index of Base image
	int m_idxBump;		// index of Bump image
	int m_idxEnabler;	// index of Enabler image 
	int m_idxUnknown;	// index of Unknown image
	int m_idxBlank;		// index of Blank image

private:
	CServer* m_pServer;	// pointer to current server's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;

// Operations
public:

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayLicenses();			
	void DisplayLicenseCounts();
	virtual void Reset(void *pServer);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerLicensesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CServerLicensesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CServerLicensesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CServerLicensesPage


//////////////////////////
// CLASS: CServerInfoPage
//
class CServerInfoPage : public CAdminPage
{
friend class CServerView;

protected:
	CServerInfoPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CServerInfoPage)

// Form Data
public:
	//{{AFX_DATA(CServerInfoPage)
	enum { IDD = IDD_SERVER_INFO };
	CListCtrl	m_HotfixList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_StateImageList; 

	int m_idxNotSign;	// index of Not Sign image (for non-valid hotfixes - state)

private:
	CServer* m_pServer;	// pointer to current server's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;

// Operations
public:

private:
	void DisplayInfo();
	virtual void Reset(void *pServer);
	void BuildImageList();			// builds the image list;
        void TSAdminDateTimeString(LONG InstallDate, LPTSTR TimeString, BOOL LongDate=FALSE);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerInfoPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CServerInfoPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CServerInfoPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusHotfixList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusHotfixList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnCommandHelp(void);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CServerInfoPage


#endif  // _SERVERPAGES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\waextend.h ===
/*******************************************************************************
*
* waextend.h
*
* Declarations for structures passed between WinAdmin and ADMINEX.DLL
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   unknown  $  Don Messerli
*
* $Log:   R:\nt\private\utils\citrix\winutils\tsadmin\vcs\waextend.h  $
*  
*     Rev 1.5   22 Feb 1998 15:53:34   unknown
*  Removed winframe.h dependency
*  
*     Rev 1.4   16 Feb 1998 16:02:54   donm
*  modifications to support pICAsso extension
*  
*     Rev 1.1   22 Oct 1997 21:56:54   donm
*  update
*  
*     Rev 1.0   15 Oct 1997 19:19:58   donm
*  Initial revision.
*  
*******************************************************************************/


#ifndef _WAEXTEND_H
#define _WAEXTEND_H

class CAppServer;

// Messages sent by the extension DLL
#define EXT_MESSAGE_BASE			WM_USER + 1000
	
#define WM_EXT_ADD_APPLICATION		EXT_MESSAGE_BASE
#define WM_EXT_ADD_APP_SERVER       EXT_MESSAGE_BASE + 1
#define WM_EXT_APP_CHANGED			EXT_MESSAGE_BASE + 2
#define WM_EXT_REMOVE_APPLICATION   EXT_MESSAGE_BASE + 3
#define WM_EXT_REMOVE_APP_SERVER    EXT_MESSAGE_BASE + 4

// Flags for ExtServerInfo
const ULONG ESF_WINFRAME = 0x0001;			// Server is running Picasso or WinFrame 1.7
const ULONG ESF_LOAD_BALANCING = 0x0002;	// Server is load balancing
const ULONG ESF_NO_LICENSE_PRIVILEGES = 0x0004;	// User doesn't have privileges to enumerate licenses
const ULONG ESF_UNLIMITED_LICENSES = 0x0008;	// Server has an unlimited user license installed

// Information about a Server
// For the All Server Servers Page
typedef struct _ExtServerInfo {
	// TCP/IP Address of the server as an ASCII string
	TCHAR TcpAddress[50];
	// Raw TCP/IP Address of the server
	ULONG RawTcpAddress;
	// IPX Address of the server
	TCHAR IpxAddress[50];
	ULONG TcpLoadLevel;
	ULONG IpxLoadLevel;
	ULONG NetbiosLoadLevel;
	// License Counts
	ULONG ServerPoolInstalled;
    ULONG ServerPoolInUse;
    ULONG ServerPoolAvailable;
    ULONG ServerLocalInstalled;
    ULONG ServerLocalInUse;
    ULONG ServerLocalAvailable;
    ULONG ServerTotalInstalled;
    ULONG ServerTotalInUse;
    ULONG ServerTotalAvailable;
    ULONG NetworkPoolInstalled;
    ULONG NetworkPoolInUse;
    ULONG NetworkPoolAvailable;
    ULONG NetworkLocalInstalled;
    ULONG NetworkLocalInUse;
    ULONG NetworkLocalAvailable;
    ULONG NetworkTotalInstalled;
    ULONG NetworkTotalInUse;
    ULONG NetworkTotalAvailable;
	// Flags
	ULONG Flags;
} ExtServerInfo;

// Flags for ExtWinStationInfo


// WinStation Extra Info
typedef struct _ExtWinStationInfo {
	ULONG CacheTiny;
	ULONG CacheLowMem;
	ULONG CacheXms;
	ULONG CacheDASD;
	ULONG DimCacheSize;
	ULONG DimBitmapMin;
	ULONG DimSignatureLevel;
	// Flags
	ULONG Flags;
} ExtWinStationInfo;

// Global Extra Info
typedef struct _ExtGlobalInfo {
	// License Counts
    ULONG NetworkPoolInstalled;
    ULONG NetworkPoolInUse;
    ULONG NetworkPoolAvailable;
    ULONG NetworkLocalInstalled;
    ULONG NetworkLocalInUse;
    ULONG NetworkLocalAvailable;
    ULONG NetworkTotalInstalled;
    ULONG NetworkTotalInUse;
    ULONG NetworkTotalAvailable;
} ExtGlobalInfo;

typedef enum _LICENSECLASS {
    LicenseBase,
    LicenseBump,
    LicenseEnabler,
    LicenseUnknown
} LICENSECLASS;

const ULONG ELF_POOLING = 0x0001;
const ULONG ELF_REGISTERED = 0x0002;

typedef struct _ExtLicenseInfo {
	LICENSECLASS Class;
	ULONG PoolLicenseCount;
	ULONG LicenseCount;
	WCHAR RegSerialNumber[26];
	WCHAR LicenseNumber[36];
	WCHAR Description[65];
	ULONG Flags;
} ExtLicenseInfo;

typedef struct _ExtModuleInfo {
	USHORT Date;
	USHORT Time;
	ULONG Size;
	BYTE LowVersion;
	BYTE HighVersion;
	TCHAR Name[13];
} ExtModuleInfo;

typedef struct _ExtAddTreeNode {
	CObject *pObject;
	CObject *pParent;
	HTREEITEM hParent;
	TCHAR Name[256];
} ExtAddTreeNode;

enum AATYPE {
	AAT_USER,
	AAT_LOCAL_GROUP,
	AAT_GLOBAL_GROUP
};


// Published App flags					
const ULONG AF_QUERYSUCCESS				= 0x00000001;
const ULONG AF_ANONYMOUS				= 0x00000002;
const ULONG AF_INHERIT_CLIENT_SIZE		= 0x00000004;
const ULONG AF_INHERIT_CLIENT_COLORS	= 0x00000008;
const ULONG AF_HIDE_TITLE_BAR			= 0x00000010;
const ULONG AF_MAXIMIZE					= 0x00000020;
const ULONG AF_CURRENT                  = 0x00000040;

// A mask to use to clear all flags set with data from the APPCONFIG structure
const ULONG AF_CONFIG_MASK = AF_ANONYMOUS  | AF_INHERIT_CLIENT_SIZE | AF_INHERIT_CLIENT_COLORS
							 | AF_HIDE_TITLE_BAR | AF_MAXIMIZE;

// Published Application States (for m_State)
enum APP_STATE {
	PAS_NONE,
	PAS_GETTING_INFORMATION,
	PAS_GOOD
};

// Flags that get sent in wParam of WM_EXT_APP_CHANGED message
// telling what has changed
const WPARAM ACF_STATE		= 0x0001;
const WPARAM ACF_CONFIG		= 0x0002;
const WPARAM ACF_ALLOWED 	= 0x0004;

// Published App Window Color Values
const ULONG APP_16_COLOR	= 0x0001;
const ULONG APP_256_COLOR	= 0x0002;
const ULONG APP_64K_COLOR	= 0x0004;
const ULONG APP_16M_COLOR	= 0x0008;

class CPublishedApp : public CObject
{
public:
	// Constructor
	CPublishedApp(TCHAR *name);
	// Destructor
	~CPublishedApp();
	// Query Servers
	void QueryServers();
	// Update with new information
	BOOL Update();
	// Returns the name of the published app
	TCHAR *GetName() { return m_Name; }
	// Returns the handle to this app's tree item
	HTREEITEM GetTreeItem() { return m_hTreeItem; }
	// Sets the tree item handle
	void SetTreeItem(HTREEITEM handle) { m_hTreeItem = handle; }
	// Returns a pointer to this app's server list
	CObList *GetServerList() { return &m_ServerList; }
	// Locks the server list
	void LockServerList() { m_ServerListCriticalSection.Lock(); }
	// Unlock the server list
	void UnlockServerList() { m_ServerListCriticalSection.Unlock(); }
	// Locks the allowed user list
	void LockAllowedUserList() { m_AllowedUserListCriticalSection.Lock(); }
	// Unlock the allowed user list
	void UnlockAllowedUserList() { m_AllowedUserListCriticalSection.Unlock(); }
	// Returns a pointer to this app's allowed user list
	CObList *GetAllowedUserList() { return &m_AllowedUserList; }
	// returns a pointer to a given CAppServer object if it is in our list
	CAppServer *FindServerByName(TCHAR *pServerName);
	// Returns TRUE if we successfully queried this application
	BOOLEAN WasQuerySuccessful() { return (m_Flags & AF_QUERYSUCCESS) > 0; }
	// Sets the query success flag
	void SetQuerySuccess() { m_Flags |= AF_QUERYSUCCESS; }
    // Returns TRUE if current flag is set
    BOOLEAN IsCurrent() { return (m_Flags & AF_CURRENT) > 0; }
    // Sets the current flag
    void SetCurrent() { m_Flags |= AF_CURRENT; }
    // Clears the current flag
    void ClearCurrent() { m_Flags &= ~AF_CURRENT; }
	// Returns TRUE if application is anonymous
	BOOLEAN IsAnonymous() { return (m_Flags & AF_ANONYMOUS) > 0; }
	// Returns TRUE if application inherits client size
	BOOLEAN InheritsClientSize() { return (m_Flags & AF_INHERIT_CLIENT_SIZE) > 0; }
	// Returns TRUE if application inherits client color
	BOOLEAN InheritsClientColors() { return (m_Flags & AF_INHERIT_CLIENT_COLORS) > 0; }
	// Returns TRUE if application wants title bar hidden
	BOOLEAN IsTitleBarHidden() { return (m_Flags & AF_HIDE_TITLE_BAR) > 0; }
	// Returns TRUE if the application wants to be maximized
	BOOLEAN IsMaximize() { return (m_Flags & AF_MAXIMIZE) > 0; }
	// Returns the Window Scale
	ULONG GetWindowScale() { return m_WindowScale; }
	// Returns the Window Width
	ULONG GetWindowWidth() { return m_WindowWidth; }
	// Returns the Window Height
	ULONG GetWindowHeight() { return m_WindowHeight; }
	// Returns the Window Color
	ULONG GetWindowColor() { return m_WindowColor; }
	// Returns the State
	APP_STATE GetState() { return m_State; }
	// Sets the State
	void SetState(APP_STATE state) { m_State = state; }
	// Checks the State
	BOOLEAN IsState(APP_STATE state) { return(m_State == state); }

private:
	void RemoveAppServer(CAppServer *pAppServer);

	static UINT BackgroundThreadProc(LPVOID);
	CWinThread *m_pBackgroundThread;
	BOOL m_BackgroundContinue;

	// Name of the published application
	TCHAR m_Name[256];
	// Handle to the tree item for this app in the tree view
	HTREEITEM m_hTreeItem;
	// List of application's server
	CObList m_ServerList;
	// Critical section for locking the server list
	CCriticalSection m_ServerListCriticalSection;
	// Critical section for locking the allowed user list
	CCriticalSection m_AllowedUserListCriticalSection;
	// List of application's allowed users
	CObList m_AllowedUserList;
	// State
	APP_STATE m_State;

	ULONG m_WindowScale;
	ULONG m_WindowWidth;
	ULONG m_WindowHeight;
	ULONG m_WindowColor;

	ULONG m_AppConfigCRC;
	ULONG m_SrvAppConfigCRC;
	ULONG m_UserAndGroupListCRC;

	// Flags
	ULONG m_Flags;
};

// AppServer flags
const ULONG ASF_NOT_RESPONDING = 0x00000001;
const ULONG ASF_UPDATE_PENDING = 0x00000002;
const ULONG ASF_ACCESS_DENIED =  0x00000004;
const ULONG ASF_IS_CURRENT_SERVER = 0x00000008;
const ULONG ASF_CURRENT = 0x00000010;

class CAppServer : public CObject
{
public:
	// Constructor
	CAppServer(PVOID pConfig, CPublishedApp *pPublishedApp);
	// Destructor
	~CAppServer();
	// Returns TRUE if this is the server that the app is being run from
	BOOL IsCurrentServer() { return ((m_Flags & ASF_IS_CURRENT_SERVER) > 0); }
	// Returns the Published App this server is associated with
	CPublishedApp *GetPublishedApp() { return m_pPublishedApp; }
	// Returns the name of the server
	TCHAR *GetName() { return m_Name; }
	// Returns the Initial Program
	TCHAR *GetInitialProgram() { return m_InitialProgram; }
	// Returns the Working Directory
	TCHAR *GetWorkDirectory() { return m_WorkDirectory; }
	// Sets the tree item
	void SetTreeItem(HTREEITEM h) { m_hTreeItem = h; }
	// Gets the tree item
	HTREEITEM GetTreeItem() { return m_hTreeItem; }
	// Sets the current flag
	void SetCurrent() { m_Flags |= ASF_CURRENT; }
	// Is the current flag set?
	BOOL IsCurrent() { return ((m_Flags & ASF_CURRENT) > 0); }
	// Clears the current flag
	void ClearCurrent() { m_Flags &= ~ASF_CURRENT; }
	// Has the configuration for this AppServer changed
	BOOL HasConfigChanged(PVOID);

private:
	CPublishedApp *m_pPublishedApp;
	TCHAR m_Name[20];
	TCHAR m_InitialProgram[257];
	TCHAR m_WorkDirectory[257];
	HTREEITEM m_hTreeItem;
	ULONG m_Flags;
};

class CAppAllowed : public CObject
{
public:
	// constructor
	CAppAllowed(TCHAR *name, AATYPE type) { wcscpy(m_Name, name);  m_Type = type; }
	AATYPE GetType() { return m_Type; }

	TCHAR m_Name[257];

private:
	AATYPE m_Type;
};

#endif  // _WAEXTEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\winspgs.cpp ===
/*******************************************************************************
*
* winspgs.cpp
*
* implementations for the WinStation info pages
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\winspgs.cpp  $
*  
*     Rev 1.5   25 Apr 1998 14:32:24   donm
*  removed hardcoded 'bytes'
*  
*     Rev 1.4   16 Feb 1998 16:03:32   donm
*  modifications to support pICAsso extension
*  
*     Rev 1.3   03 Nov 1997 15:18:36   donm
*  Added descending sort
*  
*     Rev 1.2   13 Oct 1997 18:39:04   donm
*  update
*  
*     Rev 1.1   26 Aug 1997 19:15:50   donm
*  bug fixes/changes from WinFrame 1.7
*  
*     Rev 1.0   30 Jul 1997 17:13:38   butchd
*  Initial revision.
*  
*******************************************************************************/

#include "stdafx.h"
#include "afxpriv.h"
#include "winadmin.h"
#include "admindoc.h"
#include "winspgs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////////////////
// MESSAGE MAP: CWinStationInfoPage
//
IMPLEMENT_DYNCREATE(CWinStationInfoPage, CFormView)

BEGIN_MESSAGE_MAP(CWinStationInfoPage, CFormView)
	//{{AFX_MSG_MAP(CWinStationInfoPage)
    //ON_WM_SETFOCUS( )
	ON_WM_SIZE()
	ON_COMMAND(ID_HELP1,OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CWinStationInfoPage ctor
//
CWinStationInfoPage::CWinStationInfoPage()
	: CAdminPage(CWinStationInfoPage::IDD)
{
	//{{AFX_DATA_INIT(CWinStationInfoPage)
	//}}AFX_DATA_INIT

    m_pWinStation = NULL;

}  // end CWinStationInfoPage ctor

/*
void CWinStationInfoPage::OnSetFocus( )
{

  */
/////////////////////////////
// F'N: CWinStationInfoPage dtor
//
CWinStationInfoPage::~CWinStationInfoPage()
{

}  // end CWinStationInfoPage dtor


////////////////////////////////////////
// F'N: CWinStationInfoPage::DoDataExchange
//
void CWinStationInfoPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWinStationInfoPage)
	//}}AFX_DATA_MAP

}  // end CWinStationInfoPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CWinStationInfoPage::AssertValid
//
void CWinStationInfoPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CWinStationInfoPage::AssertValid


//////////////////////////////
// F'N: CWinStationInfoPage::Dump
//
void CWinStationInfoPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CWinStationInfoPage::Dump

#endif //_DEBUG

//////////////////////////////
// F'N: CWinStationInfoPage::OnCommandHelp
//
void CWinStationInfoPage::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CWinStationInfoPage::IDD + HID_BASE_RESOURCE);
}  // end CWinStationInfoPage::OnCommandHelp

//////////////////////////////
// F'N: CWinStationInfoPage::OnInitialUpdate
//
void CWinStationInfoPage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();    

}  // end CWinStationInfoPage::OnInitialUpdate


//////////////////////////////
// F'N: CWinStationInfoPage::OnSize
//
void CWinStationInfoPage::OnSize(UINT nType, int cx, int cy) 
{

	//CFormView::OnSize(nType, cx, cy);
    

}  // end CWinStationInfoPage::OnSize


//////////////////////////////
// F'N: CWinStationInfoPage::Reset
//
void CWinStationInfoPage::Reset(void *pWinStation)
{
	m_pWinStation = (CWinStation*)pWinStation;
	DisplayInfo();

}  // end CWinStationInfoPage::Reset


/////////////////////////////////////
// F'N: CWinStationInfoPage::DisplayInfo
//
//
void CWinStationInfoPage::DisplayInfo()
{
	// We don't want to display info for the console
	// Even though this page is not shown for the console,
	// Reset() is still called and therefore, so is this function
	if(m_pWinStation->IsSystemConsole()) return;

	if(!m_pWinStation->AdditionalDone()) m_pWinStation->QueryAdditionalInformation();

	SetDlgItemText(IDC_WS_INFO_USERNAME, m_pWinStation->GetUserName());
	SetDlgItemText(IDC_WS_INFO_CLIENTNAME, m_pWinStation->GetClientName());

	CString BuildString;
	BuildString.Format(TEXT("%lu"), m_pWinStation->GetClientBuildNumber());
	SetDlgItemText(IDC_WS_INFO_BUILD, BuildString);

	SetDlgItemText(IDC_WS_INFO_DIR, m_pWinStation->GetClientDir());

	CString IDString;
	IDString.Format(TEXT("%u"), m_pWinStation->GetClientProductId());
	SetDlgItemText(IDC_WS_INFO_PRODUCT_ID, IDString);

	IDString.Format(TEXT("%lu"), m_pWinStation->GetClientSerialNumber());
	SetDlgItemText(IDC_WS_INFO_SERIAL_NUMBER, IDString);

	SetDlgItemText(IDC_WS_INFO_ADDRESS, m_pWinStation->GetClientAddress());

	CString BufferString;
	CString FormatString;
	FormatString.LoadString(IDS_BUFFERS_FORMAT);
	
	BufferString.Format(FormatString, m_pWinStation->GetHostBuffers(), m_pWinStation->GetBufferLength());
	SetDlgItemText(IDC_WS_INFO_SERVER_BUFFERS, BufferString);

	BufferString.Format(FormatString, m_pWinStation->GetClientBuffers(), m_pWinStation->GetBufferLength());
	SetDlgItemText(IDC_WS_INFO_CLIENT_BUFFERS, BufferString);

	SetDlgItemText(IDC_WS_INFO_MODEM_NAME, m_pWinStation->GetModemName());
	SetDlgItemText(IDC_WS_INFO_CLIENT_LICENSE, m_pWinStation->GetClientLicense());

	SetDlgItemText(IDC_WS_INFO_COLOR_DEPTH, m_pWinStation->GetColors());

	IDString.Format(IDS_CLIENT_RESOLUTION, m_pWinStation->GetHRes(), m_pWinStation->GetVRes());
	SetDlgItemText(IDC_WS_INFO_RESOLUTION, IDString);

	if(!m_pWinStation->GetEncryptionLevelString(&BuildString)) {
		BuildString.LoadString(IDS_NOT_APPLICABLE);
	}

	SetDlgItemText(IDC_ENCRYPTION_LEVEL, BuildString);
    

}  // end CWinStationInfoPage::DisplayInfo


////////////////////////////////
// MESSAGE MAP: CWinStationNoInfoPage
//
IMPLEMENT_DYNCREATE(CWinStationNoInfoPage, CFormView)

BEGIN_MESSAGE_MAP(CWinStationNoInfoPage, CFormView)
	//{{AFX_MSG_MAP(CWinStationNoInfoPage)
    ON_WM_SIZE( )
    ON_WM_SETFOCUS( )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//=---------------------------------------------------
void CWinStationNoInfoPage::OnSetFocus( CWnd * pOld )
{
    ODS( L"CWinStationNoInfoPage::OnSetFocus\n" );

    CWnd::OnSetFocus( pOld );
}

/////////////////////////////
// F'N: CWinStationNoInfoPage ctor
//
CWinStationNoInfoPage::CWinStationNoInfoPage()
	: CAdminPage(CWinStationNoInfoPage::IDD)
{
	//{{AFX_DATA_INIT(CWinStationNoInfoPage)
	//}}AFX_DATA_INIT

}  // end CWinStationNoInfoPage ctor

void CWinStationNoInfoPage::OnSize( UINT nType, int cx, int cy) 
{
    //eat it.
}

/////////////////////////////
// F'N: CWinStationNoInfoPage dtor
//
CWinStationNoInfoPage::~CWinStationNoInfoPage()
{
}  // end CWinStationNoInfoPage dtor


////////////////////////////////////////
// F'N: CWinStationNoInfoPage::DoDataExchange
//
void CWinStationNoInfoPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWinStationNoInfoPage)
	//}}AFX_DATA_MAP

}  // end CWinStationNoInfoPage::DoDataExchange

#ifdef _DEBUG
/////////////////////////////////////
// F'N: CWinStationNoInfoPage::AssertValid
//
void CWinStationNoInfoPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CWinStationNoInfoPage::AssertValid


//////////////////////////////
// F'N: CWinStationNoInfoPage::Dump
//
void CWinStationNoInfoPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CWinStationNoInfoPage::Dump

#endif //_DEBUG


////////////////////////////////
// MESSAGE MAP: CWinStationModulesPage
//
IMPLEMENT_DYNCREATE(CWinStationModulesPage, CFormView)

BEGIN_MESSAGE_MAP(CWinStationModulesPage, CFormView)
	//{{AFX_MSG_MAP(CWinStationModulesPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_WINSTATION_MODULE_LIST, OnColumnClick)
	ON_NOTIFY(NM_SETFOCUS, IDC_WINSTATION_MODULE_LIST, OnSetfocusModuleList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CWinStationModulesPage ctor
//
CWinStationModulesPage::CWinStationModulesPage()
	: CAdminPage(CWinStationModulesPage::IDD)
{
	//{{AFX_DATA_INIT(CWinStationModulesPage)
	//}}AFX_DATA_INIT

    m_pWinStation = NULL;
    m_bSortAscending = TRUE;
	m_pExtModuleInfo = NULL;

}  // end CWinStationModulesPage ctor


/////////////////////////////
// F'N: CWinStationModulesPage dtor
//
CWinStationModulesPage::~CWinStationModulesPage()
{
	if(m_pExtModuleInfo) delete[] m_pExtModuleInfo;

}  // end CWinStationModulesPage dtor


////////////////////////////////////////
// F'N: CWinStationModulesPage::DoDataExchange
//
void CWinStationModulesPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWinStationModulesPage)
	DDX_Control(pDX, IDC_WINSTATION_MODULE_LIST, m_ModuleList);	
	//}}AFX_DATA_MAP

}  // end CWinStationModulesPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CWinStationModulesPage::AssertValid
//
void CWinStationModulesPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CWinStationModulesPage::AssertValid


//////////////////////////////
// F'N: CWinStationModulesPage::Dump
//
void CWinStationModulesPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CWinStationModulesPage::Dump

#endif //_DEBUG


static ColumnDef ModuleColumns[] = {
{	IDS_COL_FILENAME,				LVCFMT_LEFT,	150 },
{	IDS_COL_FILEDATETIME,			LVCFMT_LEFT,	100 },
{	IDS_COL_SIZE,					LVCFMT_RIGHT,	100 },
{	IDS_COL_VERSIONS,				LVCFMT_RIGHT,	60	}
};

#define NUM_MODULE_COLUMNS sizeof(ModuleColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CWinStationModulesPage::OnInitialUpdate
//
void CWinStationModulesPage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

	BuildImageList();		// builds the image list for the list control

	CString columnString;
	for(int col = 0; col < NUM_MODULE_COLUMNS; col++) {
		columnString.LoadString(ModuleColumns[col].stringID);
		m_ModuleList.InsertColumn(col, columnString, ModuleColumns[col].format, ModuleColumns[col].width, col);
	}

	m_CurrentSortColumn = MODULES_COL_FILENAME;

}  // end CWinStationModulesPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CWinStationModulesPage::BuildImageList
//
// - calls m_imageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CWinStationModulesPage::BuildImageList()
{
	m_imageList.Create(16, 16, TRUE, 1, 0);

	m_idxBlank  = AddIconToImageList(IDI_BLANK);
	
	m_ModuleList.SetImageList(&m_imageList, LVSIL_SMALL);

}  // end CWinStationModulesPage::BuildImageList


/////////////////////////////////////////
// F'N: CWinStationModulesPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_imageList, and returns
//   the newly-added icon's index in the image list
//
int CWinStationModulesPage::AddIconToImageList(int iconID)
{
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
	return m_imageList.Add(hIcon);

}  // end CWinStationModulesPage::AddIconToImageList


//////////////////////////////
// F'N: CWinStationModulesPage::OnColumnClick
//
void CWinStationModulesPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	SortByColumn(VIEW_WINSTATION, PAGE_WS_MODULES, &m_ModuleList, m_CurrentSortColumn, m_bSortAscending);

	*pResult = 0;

}  // end CWinStationModulesPage::OnColumnClick


//////////////////////////////
// F'N: CWinStationModulesPage::OnSetfocusModuleList
//
void CWinStationModulesPage::OnSetfocusModuleList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	m_ModuleList.Invalidate();	
	*pResult = 0;

}	// end CWinStationModulesPage::OnSetfocusModuleList


//////////////////////////////
// F'N: CWinStationModulesPage::OnSize
//
void CWinStationModulesPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	rect.top += LIST_TOP_OFFSET;

	if(m_ModuleList.GetSafeHwnd())
		m_ModuleList.MoveWindow(&rect, TRUE);

	//CFormView::OnSize(nType, cx, cy);

}  // end CWinStationModulesPage::OnSize


//////////////////////////////
// F'N: CWinStationModulesPage::Reset
//
void CWinStationModulesPage::Reset(void *pWinStation)
{
	m_pWinStation = (CWinStation*)pWinStation;
	if(m_pExtModuleInfo) delete[] m_pExtModuleInfo;
	m_pExtModuleInfo = NULL;

	DisplayModules();

}  // end CWinStationModulesPage::Reset


/////////////////////////////////////
// F'N: CWinStationModulesPage::DisplayModules
//
//
void CWinStationModulesPage::DisplayModules()
{
	// We don't want to display modules for the console
	// Even though this page is not shown for the console,
	// Reset() is still called and therefore, so is this function
	if(m_pWinStation->IsSystemConsole()) return;

	// Clear out the list control
	m_ModuleList.DeleteAllItems();

	if(!m_pWinStation->AdditionalDone()) m_pWinStation->QueryAdditionalInformation();

	// If this is an ICA WinStation, display the module information
	if(m_pWinStation->GetExtendedInfo()) {
		ExtModuleInfo *pExtModuleInfo = m_pWinStation->GetExtModuleInfo();
		if(pExtModuleInfo) {
			ULONG NumModules = m_pWinStation->GetNumModules();
			ExtModuleInfo *pModule = pExtModuleInfo;

			for(ULONG module = 0; module < NumModules; module++) {
				// Filename - put at the end of the list
				int item = m_ModuleList.InsertItem(m_ModuleList.GetItemCount(), pModule->Name, m_idxBlank);

				// File date and time
				FILETIME fTime;
				TCHAR szDateTime[MAX_DATE_TIME_LENGTH];
				if(!DosDateTimeToFileTime(pModule->Date, pModule->Time, &fTime))
					wcscpy(szDateTime, TEXT("              "));
				else
					DateTimeString((LARGE_INTEGER *)&fTime, szDateTime);

				m_ModuleList.SetItemText(item, MODULES_COL_FILEDATETIME, szDateTime);

				// File size
				CString SizeString;
				if(pModule->Size) SizeString.Format(TEXT("%lu"), pModule->Size);
				else SizeString.LoadString(IDS_EMBEDDED);
				m_ModuleList.SetItemText(item, MODULES_COL_SIZE, SizeString);

				// Versions
				CString VersionString;
				VersionString.Format(TEXT("%u - %u"), pModule->LowVersion, pModule->HighVersion);
				m_ModuleList.SetItemText(item, MODULES_COL_VERSIONS, VersionString);

				m_ModuleList.SetItemData(item, (DWORD_PTR)pModule);
				pModule++;
			}
		}		
	}

}  // end CWinStationModulesPage::DisplayModules


////////////////////////////////
// MESSAGE MAP: CWinStationProcessesPage
//
IMPLEMENT_DYNCREATE(CWinStationProcessesPage, CFormView)

BEGIN_MESSAGE_MAP(CWinStationProcessesPage, CFormView)
	//{{AFX_MSG_MAP(CWinStationProcessesPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_WINSTATION_PROCESS_LIST, OnColumnClick)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_WINSTATION_PROCESS_LIST, OnProcessItemChanged)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(NM_SETFOCUS, IDC_WINSTATION_PROCESS_LIST, OnSetfocusWinstationProcessList)
    // ON_NOTIFY(NM_KILLFOCUS , IDC_WINSTATION_PROCESS_LIST , OnKillFocusWinstationProcessList )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////
// F'N: CWinStationProcessesPage ctor
//
CWinStationProcessesPage::CWinStationProcessesPage()
	: CAdminPage(CWinStationProcessesPage::IDD)
{
	//{{AFX_DATA_INIT(CWinStationProcessesPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pWinStation = NULL;
    m_bSortAscending = TRUE;

}  // end CWinStationProcessesPage ctor


/////////////////////////////
// F'N: CWinStationProcessesPage dtor
//
CWinStationProcessesPage::~CWinStationProcessesPage()
{
}  // end CWinStationProcessesPage dtor


////////////////////////////////////////
// F'N: CWinStationProcessesPage::DoDataExchange
//
void CWinStationProcessesPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWinStationProcessesPage)
	DDX_Control(pDX, IDC_WINSTATION_PROCESS_LIST, m_ProcessList);
	//}}AFX_DATA_MAP

}  // end CWinStationProcessesPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CWinStationProcessesPage::AssertValid
//
void CWinStationProcessesPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CWinStationProcessesPage::AssertValid


//////////////////////////////
// F'N: CWinStationProcessesPage::Dump
//
void CWinStationProcessesPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CWinStationProcessesPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CWinStationProcessesPage::OnSize
//
void CWinStationProcessesPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

    

	rect.top += LIST_TOP_OFFSET;

	if(m_ProcessList.GetSafeHwnd())
		m_ProcessList.MoveWindow(&rect, TRUE);

    //CFormView::OnSize(nType, cx, cy);

	

}  // end CWinStationProcessesPage::OnSize


static ColumnDef ProcColumns[] = {
    CD_PROC_ID,
    CD_PROC_PID,
    CD_PROC_IMAGE
};

#define NUM_PROC_COLUMNS sizeof(ProcColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CWinStationProcessesPage::OnInitialUpdate
//
void CWinStationProcessesPage::OnInitialUpdate() 
{
	// Call the parent class
	CFormView::OnInitialUpdate();

	CString columnString;

	for(int col = 0; col < NUM_PROC_COLUMNS; col++) {
		columnString.LoadString(ProcColumns[col].stringID);
		m_ProcessList.InsertColumn(col, columnString, ProcColumns[col].format, ProcColumns[col].width, col);
	}

	m_CurrentSortColumn = WS_PROC_COL_ID;

	// This is a major kludge!!!!
	// This is the last view created
	// We want to tell the document that all the
	// views have been created.
	// This is to allow background threads to start
	// doing their thing.
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->SetMainWnd(AfxGetMainWnd());
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->SetAllViewsReady();

}  // end CWinStationProcessesPage::OnInitialUpdate


//////////////////////////////
// F'N: CWinStationProcessesPage::Reset
//
void CWinStationProcessesPage::Reset(void *pWinStation)
{
	m_pWinStation = (CWinStation*)pWinStation;
	DisplayProcesses();

}  // end CWinStationProcessesPage::Reset


//////////////////////////////
// F'N: CWinStationProcessesPage::UpdateProcesses
//
void CWinStationProcessesPage::UpdateProcesses()
{
	CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
	BOOL bAnyChanged = FALSE;
	BOOL bAnyAdded = FALSE;

	CServer *pServer = m_pWinStation->GetServer();

	// Loop through the processes
	pServer->LockProcessList();
	CObList *pProcessList = pServer->GetProcessList();

	POSITION pos = pProcessList->GetHeadPosition();

	while(pos) {
		CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

		// If this is a 'system' process and we aren't currently showing them,
		// go to the next process
		if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
			continue;

		// If this user is not an Admin, don't show him someone else's processes
		if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers())
			continue;

		// We only want to show process for this WinStation
		if(pProcess->GetLogonId() == m_pWinStation->GetLogonId()) {
			// If the process is new, add it to the list
			if(pProcess->IsNew()) {
				AddProcessToList(pProcess);
				bAnyAdded = TRUE;
				continue;
			}

			LV_FINDINFO FindInfo;
			FindInfo.flags = LVFI_PARAM;
			FindInfo.lParam = (LPARAM)pProcess;

			// Find the Process in our list
			int item = m_ProcessList.FindItem(&FindInfo, -1);

			// If the process is no longer current,
			// remove it from the list
			if(!pProcess->IsCurrent() && item != -1) {
				// Remove the Process from the list
				m_ProcessList.DeleteItem(item);
			}
		}
	}

	pServer->UnlockProcessList();

	if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_WINSTATION, PAGE_WS_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);

}  // end CWinStationProcessesPage::UpdateProcesses


//////////////////////////////////////////
// F'N: CWinStationProcessesPage::RemoveProcess
//
void CWinStationProcessesPage::RemoveProcess(CProcess *pProcess)
{
	// Find out how many items in the list
	int ItemCount = m_ProcessList.GetItemCount();

	// Go through the items and remove this process
	for(int item = 0; item < ItemCount; item++) {
		CProcess *pListProcess = (CProcess*)m_ProcessList.GetItemData(item);
		
		if(pListProcess == pProcess) {
			m_ProcessList.DeleteItem(item);
			break;
		}
	}

}   // end CWinStationProcessPage::RemoveProcess


//////////////////////////////
// F'N: CWinStationProcessesPage::AddProcessToList
//
int CWinStationProcessesPage::AddProcessToList(CProcess *pProcess)
{
	CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();

	// ID
	CString ProcString;
	ProcString.Format(TEXT("%lu"), pProcess->GetLogonId());
	int item = m_ProcessList.InsertItem(m_ProcessList.GetItemCount(), ProcString, NULL);

	// PID
	ProcString.Format(TEXT("%lu"), pProcess->GetPID());
	m_ProcessList.SetItemText(item, WS_PROC_COL_PID, ProcString);

	// Image
	m_ProcessList.SetItemText(item, WS_PROC_COL_IMAGE, pProcess->GetImageName());

	m_ProcessList.SetItemData(item, (DWORD_PTR)pProcess);
	
	return item;

}  // end CWinStationProcessesPage::AddProcessToList


/////////////////////////////////////
// F'N: CWinStationProcessesPage::DisplayProcesses
//
void CWinStationProcessesPage::DisplayProcesses()
{
	CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();

	// Clear out the list control
	m_ProcessList.DeleteAllItems();

	CServer *pServer = m_pWinStation->GetServer();

	pServer->EnumerateProcesses();
	CObList *pProcessList = pServer->GetProcessList();
	pServer->LockProcessList();

	POSITION pos = pProcessList->GetHeadPosition();

	while(pos) {
		CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

		// If this is a 'system' process and we aren't currently showing them,
		// go to the next process
		if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
			continue;

		// If this user is not an Admin, don't show him someone else's processes
		if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers())
			continue;

		// We only want to show process for this WinStation
		if(pProcess->GetLogonId() == m_pWinStation->GetLogonId()) {
	
			AddProcessToList(pProcess);
		}
	}

    m_ProcessList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );
	
	pServer->UnlockProcessList();
	
}  // end CWinStationProcessesPage::DisplayProcesses


//////////////////////////////
// F'N: CWinStationProcessesPage::OnProcessItemChanged
//
void CWinStationProcessesPage::OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;
	
	if(pLV->uNewState & LVIS_SELECTED) {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
		pProcess->SetSelected();
	}
	
	if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
		pProcess->ClearSelected();
	}

	*pResult = 0;

}  // end CWinStationProcessesPage::OnProcessItemChanged


//////////////////////////////
// F'N: CWinStationProcessesPage::OnColumnClick
//
void CWinStationProcessesPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	SortByColumn(VIEW_WINSTATION, PAGE_WS_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);

	*pResult = 0;

}  // end CWinStationProcessesPage::OnColumnClick


//////////////////////////////
// F'N: CWinStationProcessesPage::OnContextMenu
//
void CWinStationProcessesPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen) 
{
	// TODO: Add your message handler code here
	UINT flags;
	UINT Item;
	CPoint ptClient = ptScreen;
	ScreenToClient(&ptClient);

	// If we got here from the keyboard,
	if(ptScreen.x == -1 && ptScreen.y == -1) {
		
		UINT iCount = m_ProcessList.GetItemCount( );
		
		RECT rc;

		for( Item = 0 ; Item < iCount ; Item++ )
		{
			if( m_ProcessList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
			{
				m_ProcessList.GetItemRect( Item , &rc , LVIR_ICON );

				ptScreen.x = rc.left;

				ptScreen.y = rc.bottom + 5;

				ClientToScreen( &ptScreen );

				break;
			}
		}

		if(ptScreen.x == -1 && ptScreen.y == -1) 
		{
			return;
		}
		/*
		RECT rect;
		m_ProcessList.GetClientRect(&rect);
		ptScreen.x = (rect.right - rect.left) / 2;
		ptScreen.y = (rect.bottom - rect.top) / 2;
		ClientToScreen(&ptScreen);
		*/
	}
	else {
		Item = m_ProcessList.HitTest(ptClient, &flags);
		if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
			return;
	}

	CMenu menu;
	menu.LoadMenu(IDR_PROCESS_POPUP);
	menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
			TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
	menu.DestroyMenu();
	
}  // end CServerProcessesPage::OnContextMenu


void CWinStationProcessesPage::OnSetfocusWinstationProcessList(NMHDR* pNMHDR, LRESULT* pResult) 
{	
    ODS( L"CWinStationProcessesPage::OnSetfocusWinstationProcessList\n");

	CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_ProcessList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CWinStationProcessesPage::OnKillFocusWinstationProcessList( NMHDR* , LRESULT* pResult) 
{
    m_ProcessList.Invalidate( );

    *pResult = 0;
}


////////////////////////////////
// MESSAGE MAP: CWinStationCachePage
//
IMPLEMENT_DYNCREATE(CWinStationCachePage, CFormView)

BEGIN_MESSAGE_MAP(CWinStationCachePage, CFormView)
	//{{AFX_MSG_MAP(CWinStationCachePage)
	ON_WM_SIZE()
	ON_COMMAND(ID_HELP1,OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CWinStationCachePage ctor
//
CWinStationCachePage::CWinStationCachePage()
	: CAdminPage(CWinStationCachePage::IDD)
{
	//{{AFX_DATA_INIT(CWinStationCachePage)
	//}}AFX_DATA_INIT

    m_pWinStation = NULL;

}  // end CWinStationCachePage ctor


/////////////////////////////
// F'N: CWinStationCachePage dtor
//
CWinStationCachePage::~CWinStationCachePage()
{
}  // end CWinStationCachePage dtor


////////////////////////////////////////
// F'N: CWinStationCachePage::DoDataExchange
//
void CWinStationCachePage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWinStationCachePage)
	//}}AFX_DATA_MAP

}  // end CWinStationCachePage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CWinStationCachePage::AssertValid
//
void CWinStationCachePage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CWinStationCachePage::AssertValid


//////////////////////////////
// F'N: CWinStationCachePage::Dump
//
void CWinStationCachePage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CWinStationCachePage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CWinStationCachePage::OnInitialUpdate
//
void CWinStationCachePage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

}  // end CWinStationCachePage::OnInitialUpdate

//////////////////////////////
// F'N: CWinStationCachePage::OnCommandHelp
//
void CWinStationCachePage::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CWinStationCachePage::IDD + HID_BASE_RESOURCE);
 
}  // end CWinStationCachePage::OnCommandHelp

//////////////////////////////
// F'N: CWinStationCachePage::OnSize
//
void CWinStationCachePage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	rect.top += LIST_TOP_OFFSET;

	// CFormView::OnSize(nType, cx, cy);
}  // end CWinStationCachePage::OnSize


//////////////////////////////
// F'N: CWinStationCachePage::Reset
//
void CWinStationCachePage::Reset(void *pWinStation)
{
	m_pWinStation = (CWinStation*)pWinStation;
	DisplayCache();

}  // end CWinStationCachePage::Reset


/////////////////////////////////////
// F'N: CWinStationCachePage::DisplayCache
//
//
void CWinStationCachePage::DisplayCache()
{
	// We don't want to display info for the console
	// Even though this page is not shown for the console,
	// Reset() is still called and therefore, so is this function
	if(m_pWinStation->IsSystemConsole()) return;

	if(!m_pWinStation->AdditionalDone()) m_pWinStation->QueryAdditionalInformation();

	ExtWinStationInfo *pExtWinStationInfo = m_pWinStation->GetExtendedInfo();

	if(pExtWinStationInfo)
	{
		CString IDString;
		IDString.Format(IDS_CLIENT_CACHE, 
			(pExtWinStationInfo->CacheTiny + pExtWinStationInfo->CacheLowMem) / 1024,
			pExtWinStationInfo->CacheTiny / 1024,
			pExtWinStationInfo->CacheXms / 1024,
			pExtWinStationInfo->CacheDASD / 1024);

		SetDlgItemText(IDC_WS_INFO_CACHE, IDString);

		// divide by 1024 to get Megabytes
		FLOAT DimCacheSize = (FLOAT)(pExtWinStationInfo->DimCacheSize / 1024);
		// If it is more than a Gigabyte, we need to divide by 1024 again
		if(DimCacheSize > 1024*1024) {
			IDString.Format(TEXT("%3.2fGB"), DimCacheSize / (1024*1024));
		}
		else if(DimCacheSize > 1024) {
			IDString.Format(TEXT("%3.2fMB"), DimCacheSize / 1024);
		}
		else if(DimCacheSize) {
			IDString.Format(TEXT("%fKB"), DimCacheSize);
		}
		else IDString.LoadString(IDS_NONE);

		SetDlgItemText(IDC_BITMAP_SIZE, IDString);

		IDString.Format(TEXT("%luK"), pExtWinStationInfo->DimBitmapMin / 1024);
		SetDlgItemText(IDC_BITMAP_MINIMUM, IDString);
	
		IDString.Format(TEXT("%lu"), pExtWinStationInfo->DimSignatureLevel);
		SetDlgItemText(IDC_BITMAP_SIG_LEVEL, IDString);
	}

}  // end CWinStationCachePage::DisplayCache
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\winadmin.cpp ===
/*******************************************************************************
*
* winadmin.cpp
*
* Defines the class behaviors for the application.
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\winadmin.cpp  $
*
*     Rev 1.6   19 Feb 1998 17:42:44   donm
*  removed latest extension DLL support
*
*     Rev 1.4   05 Nov 1997 14:31:02   donm
*  update
*
*     Rev 1.3   13 Oct 1997 22:19:42   donm
*  update
*
*     Rev 1.0   30 Jul 1997 17:13:08   butchd
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include <regapi.h>

#include "mainfrm.h"
#include "admindoc.h"
#include "treeview.h"
#include "rtpane.h"
#include "blankvw.h"
#include "winsvw.h"
#include "servervw.h"
#include <winsvc.h>

#ifdef DBG
bool g_fDebug = false;
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//BOOL AreWeRunningTerminalServices(void);

/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp

BEGIN_MESSAGE_MAP(CWinAdminApp, CWinApp)
        //{{AFX_MSG_MAP(CWinAdminApp)
        ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
                // NOTE - the ClassWizard will add and remove mapping macros here.
                //    DO NOT EDIT what you see in these blocks of generated code!
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp construction

CWinAdminApp::CWinAdminApp()
{
        // TODO: add construction code here,
        // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWinAdminApp object

CWinAdminApp theApp;

static TCHAR szExtensionDLLName[] = TEXT("ADMINEX.DLL");
static TCHAR szICABrowserServiceName[] = TEXT("ICABrowser");
static CHAR szStart[] = "WAExStart";
static CHAR szEnd[] = "WAExEnd";
static CHAR szServerEnumerate[] = "WAExServerEnumerate";
static CHAR szWinStationInit[] = "WAExWinStationInit";
static CHAR szWinStationInfo[] = "WAExWinStationInfo";
static CHAR szWinStationCleanup[] = "WAExWinStationCleanup";
static CHAR szServerInit[] = "WAExServerInit";
static CHAR szServerCleanup[] = "WAExServerCleanup";
static CHAR szGetServerInfo[] = "WAExGetServerInfo";
static CHAR szServerEvent[] = "WAExServerEvent";
static CHAR szGetGlobalInfo[] = "WAExGetGlobalInfo";
static CHAR szGetServerLicenses[] = "WAExGetServerLicenses";
static CHAR szGetWinStationInfo[] = "WAExGetWinStationInfo";
static CHAR szGetWinStationModules[] = "WAExGetWinStationModules";
static CHAR szFreeServerLicenses[] = "WAExFreeServerLicenses";
static CHAR szFreeWinStationModules[] = "WAExFreeWinStationModules";


/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp initialization
//
BOOL CWinAdminApp::InitInstance()
{
    
#ifdef DBG

    // to avoid excessive debug spewage delete this key on checked builds

    HKEY hKey;

    LONG lStatus;
    DWORD dwDebugValue;
    DWORD dwSize = sizeof( DWORD );

    
    
    lStatus = RegOpenKeyEx( HKEY_CURRENT_USER,
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\TSADMIN",
        0 ,
        KEY_READ,
        &hKey );

    if( lStatus == ERROR_SUCCESS )
    {
        lStatus = RegQueryValueEx( hKey ,
            L"Debug",
            NULL,
            NULL,
            ( LPBYTE )&dwDebugValue,
            &dwSize );

        if( lStatus == ERROR_SUCCESS )
        {
            if( dwDebugValue != 0 )
            {
                g_fDebug = true;
            }
        }

        RegCloseKey( hKey );
    }       

#endif
    
    
    // Read the preferences from the registry
    ReadPreferences();
    
    // Check to see if this user is an Admin
    m_Admin = TestUserForAdmin(FALSE);
    
    // Set pointers to extension DLL's procedures to NULL
    m_lpfnWAExStart = NULL;
    m_lpfnWAExEnd = NULL;
    m_lpfnWAExServerEnumerate = NULL;
    m_lpfnWAExWinStationInit = NULL;
    m_lpfnWAExWinStationCleanup = NULL;
    m_lpfnWAExServerInit = NULL;
    m_lpfnWAExServerCleanup = NULL;
    m_lpfnWAExGetServerInfo = NULL;
    m_lpfnWAExGetGlobalInfo = NULL;
    m_lpfnWAExGetServerLicenses = NULL;
    m_lpfnWAExGetWinStationInfo = NULL;
    m_lpfnWAExGetWinStationModules = NULL;
    m_lpfnWAExFreeServerLicenses = NULL;
    m_lpfnWAExFreeWinStationModules = NULL;
    
    // Check to see if we are running under Picasso
    m_Picasso = FALSE;
    
    if(IsBrowserRunning()) {
        // Attempt to load our extension DLL
        m_hExtensionDLL = LoadLibrary(szExtensionDLLName);
        if(m_hExtensionDLL) {
            // Get all the addresses of the procedures
            m_lpfnWAExStart = (LPFNEXSTARTUPPROC)::GetProcAddress(m_hExtensionDLL, szStart);
            m_lpfnWAExEnd = (LPFNEXSHUTDOWNPROC)::GetProcAddress(m_hExtensionDLL, szEnd);
            m_lpfnWAExServerEnumerate = (LPFNEXENUMERATEPROC)::GetProcAddress(m_hExtensionDLL, szServerEnumerate);
            m_lpfnWAExWinStationInit = (LPFNEXWINSTATIONINITPROC)::GetProcAddress(m_hExtensionDLL, szWinStationInit);
            m_lpfnWAExWinStationInfo = (LPFNEXWINSTATIONINFOPROC)::GetProcAddress(m_hExtensionDLL, szWinStationInfo);
            m_lpfnWAExWinStationCleanup = (LPFNEXWINSTATIONCLEANUPPROC)::GetProcAddress(m_hExtensionDLL, szWinStationCleanup);
            m_lpfnWAExServerInit = (LPFNEXSERVERINITPROC)::GetProcAddress(m_hExtensionDLL, szServerInit);
            m_lpfnWAExServerCleanup = (LPFNEXSERVERCLEANUPPROC)::GetProcAddress(m_hExtensionDLL, szServerCleanup);
            m_lpfnWAExGetServerInfo = (LPFNEXGETSERVERINFOPROC)::GetProcAddress(m_hExtensionDLL, szGetServerInfo);
            m_lpfnWAExServerEvent = (LPFNEXSERVEREVENTPROC)::GetProcAddress(m_hExtensionDLL, szServerEvent);
            m_lpfnWAExGetGlobalInfo = (LPFNEXGETGLOBALINFOPROC)::GetProcAddress(m_hExtensionDLL, szGetGlobalInfo);
            m_lpfnWAExGetServerLicenses = (LPFNEXGETSERVERLICENSESPROC)::GetProcAddress(m_hExtensionDLL, szGetServerLicenses);
            m_lpfnWAExGetWinStationInfo = (LPFNEXGETWINSTATIONINFOPROC)::GetProcAddress(m_hExtensionDLL, szGetWinStationInfo);
            m_lpfnWAExGetWinStationModules = (LPFNEXGETWINSTATIONMODULESPROC)::GetProcAddress(m_hExtensionDLL, szGetWinStationModules);
            m_lpfnWAExFreeServerLicenses = (LPFNEXFREESERVERLICENSESPROC)::GetProcAddress(m_hExtensionDLL, szFreeServerLicenses);
            m_lpfnWAExFreeWinStationModules = (LPFNEXFREEWINSTATIONMODULESPROC)::GetProcAddress(m_hExtensionDLL, szFreeWinStationModules);
            
            m_Picasso = TRUE;
        } else {
            // Picasso is running, but we couldn't load the extension DLL.
            // Tell the user that added functionality will not be available
            CString MessageString;
            CString TitleString;
            TitleString.LoadString(AFX_IDS_APP_TITLE);
            MessageString.LoadString(IDS_NO_EXTENSION_DLL);
            ::MessageBox(NULL, MessageString, TitleString, MB_ICONEXCLAMATION | MB_OK);
        }
    }
    
    // Get information about the WinStation we are running from
    QueryCurrentWinStation(m_CurrentWinStationName, m_CurrentUserName,
        &m_CurrentLogonId, &m_CurrentWSFlags);
    
    // Load the system console string for rapid comparison in various
    // refresh cycles.
    lstrcpy( m_szSystemConsole , L"Console" );
    /*
    LoadString( m_hInstance, IDS_SYSTEM_CONSOLE_NAME,
    m_szSystemConsole, WINSTATIONNAME_LENGTH );
    */
    
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.
    
#ifdef _AFXDLL
    Enable3dControls();                     // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();       // Call this when linking to MFC statically
#endif
    
    //      LoadStdProfileSettings();  // Load standard INI file options (including MRU)
    
    // Get the current server name
    DWORD cchBuffer = MAX_COMPUTERNAME_LENGTH + 1;
    if(!GetComputerName(m_CurrentServerName, &cchBuffer)) {
        DWORD Error = GetLastError();
    }
    
    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.
    CSingleDocTemplate* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,
        RUNTIME_CLASS(CWinAdminDoc),
        RUNTIME_CLASS(CMainFrame),       // main SDI frame window
        m_Picasso ? RUNTIME_CLASS(CBaseTreeView) : RUNTIME_CLASS(CAdminTreeView));
    AddDocTemplate(pDocTemplate);
    
    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);
    
    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;
    
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp::ExitInstance
//
int CWinAdminApp::ExitInstance()
{
        // write out the preferences
        WritePreferences();

        // if we loaded the extension DLL, unload it
        if(m_hExtensionDLL) FreeLibrary(m_hExtensionDLL);

        return 0;
}

static TCHAR szWinAdminAppKey[] = REG_SOFTWARE_TSERVER TEXT("\\TSADMIN");
static TCHAR szPlacement[] = TEXT("Placement");
static TCHAR szPlacementFormat[] = TEXT("%u,%u,%d,%d,%d,%d,%d,%d,%d,%d");
static TCHAR szConfirmation[] = TEXT("Confirmation");
static TCHAR szSaveSettings[] = TEXT("SaveSettingsOnExit");
static TCHAR szShowSystemProcesses[] = TEXT("ShowSystemProcesses");
static TCHAR szShowAllServers[] = TEXT("ShowAllServers");
static TCHAR szListRefreshTime[] = TEXT("ListRefreshTime");
static TCHAR szStatusRefreshTime[] = TEXT("StatusRefreshTime");
static TCHAR szShadowHotkeyKey[] = TEXT("ShadowHotkeyKey");
static TCHAR szShadowHotkeyShift[] = TEXT("ShadowHotkeyShift");
static TCHAR szTreeWidth[] = TEXT("TreeWidth");


/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp::ReadPreferences
//
void CWinAdminApp::ReadPreferences()
{
        HKEY hKeyWinAdmin;
        DWORD dwType, cbData, dwValue;
        TCHAR szValue[128];

        // Set default values for everything
        m_Confirmation = 1;
        m_SavePreferences = 1;
        m_ProcessListRefreshTime = 5000;
        m_StatusRefreshTime = 1000;
        m_ShowSystemProcesses = TRUE;
        m_ShowAllServers = FALSE;
        m_ShadowHotkeyKey = VK_MULTIPLY;
        m_ShadowHotkeyShift = KBDCTRL;
   m_TreeWidth = 200;
        m_Placement.rcNormalPosition.right = -1;

        // Open registry key for our application
        DWORD Disposition;
        if(RegCreateKeyEx(HKEY_CURRENT_USER, szWinAdminAppKey, 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                KEY_READ, NULL, &hKeyWinAdmin, &Disposition) != ERROR_SUCCESS) return;

        // Read the previous WINDOWPLACEMENT.
        cbData = sizeof(szValue);
        if((RegQueryValueEx(hKeyWinAdmin, szPlacement, NULL, &dwType,
                (LPBYTE)szValue, &cbData) != ERROR_SUCCESS) ||
                !(*szValue) ||
                (swscanf( szValue, szPlacementFormat,
                   &m_Placement.flags, &m_Placement.showCmd,
                   &m_Placement.ptMinPosition.x, &m_Placement.ptMinPosition.y,
                   &m_Placement.ptMaxPosition.x, &m_Placement.ptMaxPosition.y,
                   &m_Placement.rcNormalPosition.left,
                   &m_Placement.rcNormalPosition.top,
                   &m_Placement.rcNormalPosition.right,
                   &m_Placement.rcNormalPosition.bottom ) != 10) ) {
                // Flag to use the default window placement.
                m_Placement.rcNormalPosition.right = -1;
        }

        /*
         * Flag for initial showing of main window in our override of
         * CFrameWnd::ActivateFrame() (in our CMainFrame class).
         */
        m_Placement.length = (UINT)-1;

        // Read the Confirmation flag
        cbData = sizeof(m_Confirmation);
        if(RegQueryValueEx(hKeyWinAdmin, szConfirmation, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_Confirmation = dwValue;
        }

        // Read the Save Preferences flag
        cbData = sizeof(m_SavePreferences);
        if(RegQueryValueEx(hKeyWinAdmin, szSaveSettings, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_SavePreferences = dwValue;
        }

        // Read the Show System Processes flag
        cbData = sizeof(m_ShowSystemProcesses);
        if(RegQueryValueEx(hKeyWinAdmin, szShowSystemProcesses, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_ShowSystemProcesses = dwValue;
        }
#if 0
        // Read the Show All Servers flag
        cbData = sizeof(m_ShowAllServers);
        if(RegQueryValueEx(hKeyWinAdmin, szShowAllServers, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_ShowAllServers = dwValue;
        }
#endif
        // Read the Process List Refresh Time
        cbData = sizeof(m_ProcessListRefreshTime);
        if(RegQueryValueEx(hKeyWinAdmin, szListRefreshTime, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_ProcessListRefreshTime = dwValue;
        }

        // Read the Status Dialog Refresh Time
        cbData = sizeof(m_StatusRefreshTime);
        if(RegQueryValueEx(hKeyWinAdmin, szStatusRefreshTime, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_StatusRefreshTime = dwValue;
        }

        // Read the Shadow Hotkey Key
        cbData = sizeof(m_ShadowHotkeyKey);
        if(RegQueryValueEx(hKeyWinAdmin, szShadowHotkeyKey, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_ShadowHotkeyKey = dwValue;
        }

        // Read the Shadow Hotkey Shift
        cbData = sizeof(m_ShadowHotkeyShift);
        if(RegQueryValueEx(hKeyWinAdmin, szShadowHotkeyShift, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_ShadowHotkeyShift = dwValue;
        }

        // CPR 1698: (Upgrade check for SouthBeach build 129 WINADMIN saved
        // profile).  If the m_nShadowHotkeyKey is VK_ESCAPE (no longer allowed),
        // set the hotkey to CTRL-* (the new default).
        if(m_ShadowHotkeyKey == VK_ESCAPE) {
                m_ShadowHotkeyKey = VK_MULTIPLY;
                m_ShadowHotkeyShift = KBDCTRL;
        }

        // Read the Tree Width
        cbData = sizeof(m_TreeWidth);
        if(RegQueryValueEx(hKeyWinAdmin, szTreeWidth, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_TreeWidth = dwValue;
        }

        RegCloseKey(hKeyWinAdmin);

}       // end CWinAdminApp::ReadPreferences


/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp::WritePreferences
//
void CWinAdminApp::WritePreferences()
{
        HKEY hKeyWinAdmin;
        DWORD dwValue;
        TCHAR szValue[128];

        // Open registry key for our application
        DWORD Disposition;
        if(RegCreateKeyEx(HKEY_CURRENT_USER, szWinAdminAppKey, 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                KEY_WRITE, NULL, &hKeyWinAdmin, &Disposition) != ERROR_SUCCESS) return;

        // Always write the Save Settings on Exit entry
        dwValue = m_SavePreferences;
        RegSetValueEx(hKeyWinAdmin, szSaveSettings, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));


        // If the user didn't want to save settings, we're done
        if(!m_SavePreferences) {
                RegCloseKey(hKeyWinAdmin);
                return;
        }

        // Write the WINDOWPLACEMENT
        m_Placement.flags = 0;
//      if(m_pMainWnd->IsZoomed())
//              m_Placement.flags |= WPF_RESTORETOMAXIMIZED;

        wsprintf(szValue, szPlacementFormat, m_Placement.flags, m_Placement.showCmd,
                m_Placement.ptMinPosition.x, m_Placement.ptMinPosition.y,
                m_Placement.ptMaxPosition.x, m_Placement.ptMaxPosition.y,
                m_Placement.rcNormalPosition.left,
                m_Placement.rcNormalPosition.top,
                m_Placement.rcNormalPosition.right,
                m_Placement.rcNormalPosition.bottom);

        RegSetValueEx(hKeyWinAdmin, szPlacement, 0, REG_SZ,
                (LPBYTE)szValue, (lstrlen(szValue) + 1) * sizeof(TCHAR));

        // Write the Confirmation flag
        dwValue = m_Confirmation;
        RegSetValueEx(hKeyWinAdmin, szConfirmation, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Write the Show System Processes flag
        dwValue = m_ShowSystemProcesses;
        RegSetValueEx(hKeyWinAdmin, szShowSystemProcesses, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Write the Show All Servers flag
        dwValue = m_ShowAllServers;
        RegSetValueEx(hKeyWinAdmin, szShowAllServers, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Write the Process List Refresh Time
        dwValue = m_ProcessListRefreshTime;
        RegSetValueEx(hKeyWinAdmin, szListRefreshTime, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Write the Status Dialog Refresh Time
        dwValue = m_StatusRefreshTime;
        RegSetValueEx(hKeyWinAdmin, szStatusRefreshTime, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Write the Shadow Hotkey Key
        dwValue = m_ShadowHotkeyKey;
        RegSetValueEx(hKeyWinAdmin, szShadowHotkeyKey, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Write the Shadow Hotkey Shift state
        dwValue = m_ShadowHotkeyShift;
        RegSetValueEx(hKeyWinAdmin, szShadowHotkeyShift, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Write the Tree Width
        dwValue = m_TreeWidth;
        RegSetValueEx(hKeyWinAdmin, szTreeWidth, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Close the registry key
        RegCloseKey(hKeyWinAdmin);

}       // end CWinAdminApp::WritePreferences


/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp::IsBrowserRunning
//
BOOL CWinAdminApp::IsBrowserRunning()
{
        SC_HANDLE managerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        SC_HANDLE serviceHandle = OpenService(managerHandle, szICABrowserServiceName, SERVICE_QUERY_STATUS);

        SERVICE_STATUS serviceStatus;
        QueryServiceStatus(serviceHandle, (LPSERVICE_STATUS)&serviceStatus);

        CloseServiceHandle(serviceHandle);
        CloseServiceHandle(managerHandle);

        if(serviceStatus.dwCurrentState != SERVICE_RUNNING) return FALSE;
        else return TRUE;

}  // end CWinAdminApp::IsBrowserRunning


/*******************************************************************************
 *
 *  OnAppAbout - CWinAdminApp member function: command
 *
 *      Display the about box dialog (uses Shell32 generic About dialog).
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

// Typedef for the ShellAbout function
typedef void (WINAPI *LPFNSHELLABOUT)(HWND, LPCTSTR, LPCTSTR, HICON);

void CWinAdminApp::OnAppAbout()
{
    HMODULE    hMod;
    LPFNSHELLABOUT lpfn;

    if ( hMod = ::LoadLibrary( TEXT("SHELL32") ) )
    {
        if (lpfn = (LPFNSHELLABOUT)::GetProcAddress( hMod,
#ifdef UNICODE
                                                     "ShellAboutW"
#else
                                                     "ShellAboutA"
#endif // UNICODE
                                                            ))
        {
        (*lpfn)( m_pMainWnd->m_hWnd, (LPCTSTR)m_pszAppName,
                 (LPCTSTR)TEXT(""), LoadIcon(IDR_MAINFRAME) );
        }
        ::FreeLibrary(hMod);
    }
    else
    {
        ::MessageBeep( MB_ICONEXCLAMATION );
    }

}  // end CWinadminApp::OnAppAbout

/*******************************************************************************
 *
 *  AreWeRunningTerminalServices
 *
 *      Check if we are running terminal server
 *
 *  ENTRY:
 *
 *  EXIT: BOOL: True if we are running Terminal Services False if we
 *              are not running Terminal Services
 *
 *
 ******************************************************************************/
/*
BOOL AreWeRunningTerminalServices(void)
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_OR );

    return VerifyVersionInfo(
        &osVersionInfo,
        VER_SUITENAME,
        dwlConditionMask
        );
}
*/

/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp commands


//=---------------------------------------------------------
BEGIN_MESSAGE_MAP( CMyTabCtrl , CTabCtrl )
    ON_WM_SETFOCUS( )
END_MESSAGE_MAP( )

void CMyTabCtrl::OnSetFocus( CWnd *pOldWnd )
{
    ODS( L"CMyTabCtrl::OnSetFocus\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();        

    if( pDoc != NULL )
    {
        ODS( L"\tTabctrl has focus\n" );

        pDoc->RegisterLastFocus( TAB_CTRL );
    }

    CTabCtrl::OnSetFocus( pOldWnd );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\winadmin.h ===
/*******************************************************************************
*
* winadmin.h
*
* main header file for the WINADMIN application
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\winadmin.h  $
*
*     Rev 1.12   25 Apr 1998 13:43:14   donm
*  MS 2167: try to use proper Wd from registry
*
*     Rev 1.11   19 Feb 1998 17:42:52   donm
*  removed latest extension DLL support
*
*     Rev 1.9   19 Jan 1998 16:49:28   donm
*  new ui behavior for domains and servers
*
*     Rev 1.8   03 Nov 1997 15:28:02   donm
*  added Domains
*
*     Rev 1.7   22 Oct 1997 21:09:10   donm
*  update
*
*     Rev 1.6   17 Oct 1997 18:07:28   donm
*  update
*
*     Rev 1.5   15 Oct 1997 19:52:48   donm
*  update
*
*     Rev 1.4   13 Oct 1997 23:07:14   donm
*  update
*
*     Rev 1.3   13 Oct 1997 22:20:02   donm
*  update
*
*     Rev 1.2   26 Aug 1997 19:16:24   donm
*  bug fixes/changes from WinFrame 1.7
*
*     Rev 1.1   31 Jul 1997 16:52:52   butchd
*  update
*
*     Rev 1.0   30 Jul 1997 17:13:12   butchd
*  Initial revision.
*
*******************************************************************************/

#ifndef _WINADMIN_H
#define _WINADMIN_H

#ifndef __AFXWIN_H__
        #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include <afxmt.h>
#include <winsta.h>
#include <time.h>
#include <utildll.h>
#include "waextend.h"

// Classes defined in this file
class CTreeNode;
class CWinStation;
class CModule;
class CLicense;
class CServer;
class CWinAdminApp;
class CProcess;
class CHotFix;
class CDomain;
class CWd;

// Server icon overlay states
const USHORT STATE_NORMAL = 0x0000;
const USHORT STATE_NOT = 0x0100;
const USHORT STATE_QUESTION = 0x0200;

const USHORT MSG_TITLE_LENGTH = 64;
const USHORT MSG_MESSAGE_LENGTH = 256;

const USHORT LIST_TOP_OFFSET = 4;

const int KBDSHIFT      = 0x01;
const int KBDCTRL       = 0x02;
const int KBDALT        = 0x04;


enum VIEW {
        VIEW_BLANK,
        VIEW_ALL_SERVERS,
    VIEW_DOMAIN,
        VIEW_SERVER,
        VIEW_MESSAGE,
        VIEW_WINSTATION,
        VIEW_CHANGING
};

const int PAGE_CHANGING = 0xFFFF;

enum AS_PAGE {
// All Servers Pages
        PAGE_AS_SERVERS,
        PAGE_AS_USERS,
        PAGE_AS_WINSTATIONS,
        PAGE_AS_PROCESSES,
        PAGE_AS_LICENSES
};

enum DOMAIN_PAGE {
    PAGE_DOMAIN_SERVERS,
    PAGE_DOMAIN_USERS,
    PAGE_DOMAIN_WINSTATIONS,
    PAGE_DOMAIN_PROCESSES,
    PAGE_DOMAIN_LICENSES
};

enum SERVER_PAGE {
// Server Pages
        PAGE_USERS,
        PAGE_WINSTATIONS,
        PAGE_PROCESSES,
        PAGE_LICENSES,
        PAGE_INFO
};

enum WINS_PAGE {
// WinStation Pages
        PAGE_WS_PROCESSES,
        PAGE_WS_INFO,
        PAGE_WS_MODULES,
        PAGE_WS_CACHE,
        PAGE_WS_NO_INFO
};

// The column enums have to be here so that colsort.cpp can get to them
// Server User's columns
enum USERSCOLUMNS {
        USERS_COL_USER,
        USERS_COL_WINSTATION,
        USERS_COL_ID,
        USERS_COL_STATE,
        USERS_COL_IDLETIME,
        USERS_COL_LOGONTIME
};

// Server WinStation's columns
enum STATIONCOLUMNS {
        WS_COL_WINSTATION,
        WS_COL_USER,
        WS_COL_ID,
        WS_COL_STATE,
        WS_COL_TYPE,
        WS_COL_CLIENTNAME,
        WS_COL_IDLETIME,
        WS_COL_LOGONTIME,
        WS_COL_COMMENT
};

// Server Processes' columns
enum PROCESSCOLUMNS {
        PROC_COL_USER,
        PROC_COL_WINSTATION,
        PROC_COL_ID,
        PROC_COL_PID,
        PROC_COL_IMAGE
};

// Server Licenses' columns
enum LICENSECOLUMNS {
        LICENSE_COL_DESCRIPTION,
        LICENSE_COL_REGISTERED,
        LICENSE_COL_USERCOUNT,
        LICENSE_COL_POOLCOUNT,
        LICENSE_COL_NUMBER
};

// Server Hotfix columns
enum HOTFIXCOLUMNS {
        HOTFIX_COL_NAME,
        HOTFIX_COL_INSTALLEDBY,
        HOTFIX_COL_INSTALLEDON
};

// WinStation Processes columns
enum WS_PROCESSCOLUMNS {
        WS_PROC_COL_ID,
        WS_PROC_COL_PID,
        WS_PROC_COL_IMAGE
};

// WinStation Modules columns
enum MODULESCOLUMNS {
        MODULES_COL_FILENAME,
        MODULES_COL_FILEDATETIME,
        MODULES_COL_SIZE,
        MODULES_COL_VERSIONS
};

// All Server Servers columns
enum SERVERSCOLUMNS {
        SERVERS_COL_SERVER,
        SERVERS_COL_TCPADDRESS,
        SERVERS_COL_IPXADDRESS,
        SERVERS_COL_NUMWINSTATIONS
};

// All Server Users columns
enum AS_USERS_COLUMNS {
        AS_USERS_COL_SERVER,
        AS_USERS_COL_USER,
        AS_USERS_COL_WINSTATION,
        AS_USERS_COL_ID,
        AS_USERS_COL_STATE,
        AS_USERS_COL_IDLETIME,
        AS_USERS_COL_LOGONTIME
};

// All Server WinStations columns
enum AS_STATIONCOLUMNS {
        AS_WS_COL_SERVER,
        AS_WS_COL_WINSTATION,
        AS_WS_COL_USER,
        AS_WS_COL_ID,
        AS_WS_COL_STATE,
        AS_WS_COL_TYPE,
        AS_WS_COL_CLIENTNAME,
        AS_WS_COL_IDLETIME,
        AS_WS_COL_LOGONTIME,
        AS_WS_COL_COMMENT
};

// All Server Processes columns
enum AS_PROCESSCOLUMNS {
        AS_PROC_COL_SERVER,
        AS_PROC_COL_USER,
        AS_PROC_COL_WINSTATION,
        AS_PROC_COL_ID,
        AS_PROC_COL_PID,
        AS_PROC_COL_IMAGE
};

// All Server Licenses columns
enum AS_LICENSECOLUMNS {
        AS_LICENSE_COL_SERVER,
        AS_LICENSE_COL_DESCRIPTION,
        AS_LICENSE_COL_REGISTERED,
        AS_LICENSE_COL_USERCOUNT,
        AS_LICENSE_COL_POOLCOUNT,
        AS_LICENSE_COL_NUMBER
};

// in colsort.cpp
void SortByColumn(int View, int Page, CListCtrl *list, int ColumnNumber, BOOL bAscending);

// Extension Startup Function
typedef void (WINAPI *LPFNEXSTARTUPPROC) (HWND);
// Extension Shutdown Function
typedef void (WINAPI *LPFNEXSHUTDOWNPROC) (void);
// Extension Server Enumerate Function
typedef LPWSTR (WINAPI *LPFNEXENUMERATEPROC) (LPWSTR);
// Extension WinStation Init Function
typedef void* (WINAPI *LPFNEXWINSTATIONINITPROC) (HANDLE, ULONG);
// Extension WinStation Additional Info Function
typedef void (WINAPI *LPFNEXWINSTATIONINFOPROC) (void*, int);
// Extension WinStation Cleanup Function
typedef void (WINAPI *LPFNEXWINSTATIONCLEANUPPROC) (void*);
// Extension Server Init Function
typedef void* (WINAPI *LPFNEXSERVERINITPROC) (TCHAR*, HANDLE);
// Extension Server Cleanup Function
typedef void (WINAPI *LPFNEXSERVERCLEANUPPROC) (void*);
// Extension Server Event Function
typedef BOOL (WINAPI *LPFNEXSERVEREVENTPROC) (void*, ULONG);
// Extension Get Server Info
typedef ExtServerInfo* (WINAPI *LPFNEXGETSERVERINFOPROC) (void *);
// Extension Get Server License Info
typedef ExtLicenseInfo* (WINAPI *LPFNEXGETSERVERLICENSESPROC) (void*, ULONG*);
// Extension Get Global Info
typedef ExtGlobalInfo* (WINAPI *LPFNEXGETGLOBALINFOPROC) (void);
// Extension Get WinStation Info
typedef ExtWinStationInfo* (WINAPI *LPFNEXGETWINSTATIONINFOPROC) (void *);
// Extension Get WinStation Modules
typedef ExtModuleInfo* (WINAPI *LPFNEXGETWINSTATIONMODULESPROC) (void*, ULONG*);
// Extension Free Server License Info
typedef void (WINAPI *LPFNEXFREESERVERLICENSESPROC) (ExtLicenseInfo*);
// Extension Free WinStation Modules
typedef void (WINAPI *LPFNEXFREEWINSTATIONMODULESPROC) (ExtModuleInfo*);

/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp:
// See WinAdmin.cpp for the implementation of this class
//
class CWinAdminApp : public CWinApp
{
public:
        // constructor
        CWinAdminApp();
        // Returns the Current User Name
        TCHAR *GetCurrentUserName() { return m_CurrentUserName; }
        // Returns the Current WinStation Name
        PWINSTATIONNAME GetCurrentWinStationName() { return m_CurrentWinStationName; }
        // Returns the Current Server Name
        TCHAR *GetCurrentServerName() { return m_CurrentServerName; }
        // Returns the Current Logon Id
        ULONG GetCurrentLogonId() { return m_CurrentLogonId; }
        // Returns the Current WinStation Flags
        ULONG GetCurrentWSFlags() { return m_CurrentWSFlags; }
        // Returns TRUE if the current user has Admin privileges?
        BOOL IsUserAdmin() { return m_Admin; }
        // Returns TRUE if we are running under Picasso
        BOOL IsPicasso() { return m_Picasso; }
        // Returns TRUE if we should show system processes
        BOOL ShowSystemProcesses() { return m_ShowSystemProcesses; }
        // Sets the show system processes variable
        void SetShowSystemProcesses(BOOL show) { m_ShowSystemProcesses = show; }
        // Returns TRUE if we should ask user for confirmation of Actions
        BOOL AskConfirmation() { return m_Confirmation; }
        // Sets the confirmation variable
        void SetConfirmation(BOOL conf) { m_Confirmation = conf; }
        // Returms TRUE if we should save the preferences upon exit
        BOOL SavePreferences() { return m_SavePreferences; }
        // Sets the save preferences variable
        void SetSavePreferences(BOOL pref) { m_SavePreferences = pref; }
        // Returns the Process List Refresh Time
        UINT GetProcessListRefreshTime() { return m_ProcessListRefreshTime; }
        // Sets the Process List Refresh Time
        void SetProcessListRefreshTime(UINT pt) { m_ProcessListRefreshTime = pt; }
        // Returns the Status Dialog Refresh Time
        UINT GetStatusRefreshTime() { return m_StatusRefreshTime; }
        // Sets the Status Dialog Refresh Time
        void SetStatusRefreshTime(UINT st) { m_StatusRefreshTime = st; }
        // Returns a pointer to the document
        CDocument *GetDocument() { return m_Document; }
        // Sets the m_Document variable
        void SetDocument(CDocument *doc) { m_Document = doc; }
        // Should we Show All Servers - based on menu item toggle
        BOOL GetShowAllServers() { return m_ShowAllServers; }
        // Set the Show All Servers variable
        void SetShowAllServers(BOOL sa) { m_ShowAllServers = sa; }
        // Returns the value of shadow hotkey key
        int GetShadowHotkeyKey() { return m_ShadowHotkeyKey; }
        // Sets the value of shadow hotkey key
        void SetShadowHotkeyKey(int key) { m_ShadowHotkeyKey = key; }
        // Returns the value of shadow hotkey shift state
        DWORD GetShadowHotkeyShift() { return m_ShadowHotkeyShift; }
        // Sets the value of shadow hotkey shift state
        void SetShadowHotkeyShift(DWORD shift) { m_ShadowHotkeyShift = shift; }
        // Get the tree width
        int GetTreeWidth() { return m_TreeWidth; }
        // Set the tree width
        void SetTreeWidth(int width) { m_TreeWidth = width; }
        // Get the window placement
        WINDOWPLACEMENT *GetPlacement() { return &m_Placement; }

        // Returns the address of the extension DLL's startup function
        LPFNEXSTARTUPPROC GetExtStartupProc() { return m_lpfnWAExStart; }
        // Returns the address of the extension DLL's shutdown function
        LPFNEXSHUTDOWNPROC GetExtShutdownProc() { return m_lpfnWAExEnd; }
        // Returns the address of the extension DLL's server enumeration function
        LPFNEXENUMERATEPROC GetExtEnumerationProc() { return m_lpfnWAExServerEnumerate; }
        // Returns the address of the extension DLL's WinStation Init function
        LPFNEXWINSTATIONINITPROC GetExtWinStationInitProc() { return m_lpfnWAExWinStationInit; }
        // Returns the address of the extension DLL's WinStation Info function
        LPFNEXWINSTATIONINFOPROC GetExtWinStationInfoProc() { return m_lpfnWAExWinStationInfo; }
        // Returns the address of the extension DLL's WinStation Cleanup function
        LPFNEXWINSTATIONCLEANUPPROC GetExtWinStationCleanupProc() { return m_lpfnWAExWinStationCleanup; }
        // Returns the address of the extension DLL's Server Init function
        LPFNEXSERVERINITPROC GetExtServerInitProc() { return m_lpfnWAExServerInit; }
        // Returns the address of the extension DLL's Server Cleanup function
        LPFNEXSERVERCLEANUPPROC GetExtServerCleanupProc() { return m_lpfnWAExServerCleanup; }
        // Returns the address of the extension DLL's Get Server Info function
        LPFNEXGETSERVERINFOPROC GetExtGetServerInfoProc() { return m_lpfnWAExGetServerInfo; }
        // Returns the address of the extension DLL's Get Server License Info function
        LPFNEXGETSERVERLICENSESPROC GetExtGetServerLicensesProc() { return m_lpfnWAExGetServerLicenses; }
        // Returns the address of the extension DLL's Server Event function
        LPFNEXSERVEREVENTPROC GetExtServerEventProc() { return m_lpfnWAExServerEvent; }
        // Returns the address of the extension DLL's Get Global Info function
        LPFNEXGETGLOBALINFOPROC GetExtGetGlobalInfoProc() { return m_lpfnWAExGetGlobalInfo; }
        // Returns the address of the extension DLL's Get WinStation Info Function
        LPFNEXGETWINSTATIONINFOPROC GetExtGetWinStationInfoProc() { return m_lpfnWAExGetWinStationInfo; }
        // Returns the address of the extension DLL's Get WinStation Module Info function
        LPFNEXGETWINSTATIONMODULESPROC GetExtGetWinStationModulesProc() { return m_lpfnWAExGetWinStationModules; }
        // Returns the address of the extension DLL's Free Server License Info function
        LPFNEXFREESERVERLICENSESPROC GetExtFreeServerLicensesProc() { return m_lpfnWAExFreeServerLicenses; }
        // Returns the address of the extension DLL's Free WinStation Modules function
        LPFNEXFREEWINSTATIONMODULESPROC GetExtFreeWinStationModulesProc() { return m_lpfnWAExFreeWinStationModules; }

        void BeginOutstandingThread() { ::InterlockedIncrement(&m_OutstandingThreads); }
        void EndOutstandingThread()     { ::InterlockedDecrement(&m_OutstandingThreads); }

        // make this guy public for speed ?
        TCHAR m_szSystemConsole[WINSTATIONNAME_LENGTH+1];
        // make this guy public so the MainFrm can get at it
        WINDOWPLACEMENT m_Placement;

private:
        void ReadPreferences();
        void WritePreferences();
        BOOL IsBrowserRunning();
        LONG m_OutstandingThreads;      // the number of outstanding threads
        TCHAR m_CurrentUserName[USERNAME_LENGTH+1];
        WINSTATIONNAME m_CurrentWinStationName;
        TCHAR m_CurrentServerName[MAX_COMPUTERNAME_LENGTH + 1];
        ULONG m_CurrentLogonId;
        ULONG m_CurrentWSFlags;
        BOOL m_Admin;                           // does the user have Admin privileges?
        BOOL m_Picasso;                 // are we running under Picasso?
        UINT m_ShowSystemProcesses;
        UINT m_ShowAllServers;
        int m_ShadowHotkeyKey;
        DWORD m_ShadowHotkeyShift;
        int m_TreeWidth;
        HINSTANCE m_hExtensionDLL;      // handle to the extension DLL if loaded

        // functions in the extension DLL
        LPFNEXSTARTUPPROC m_lpfnWAExStart;
        LPFNEXSHUTDOWNPROC m_lpfnWAExEnd;
        LPFNEXENUMERATEPROC m_lpfnWAExServerEnumerate;
        LPFNEXWINSTATIONINITPROC m_lpfnWAExWinStationInit;
        LPFNEXWINSTATIONINFOPROC m_lpfnWAExWinStationInfo;
        LPFNEXWINSTATIONCLEANUPPROC m_lpfnWAExWinStationCleanup;
        LPFNEXSERVERINITPROC m_lpfnWAExServerInit;
        LPFNEXSERVERCLEANUPPROC m_lpfnWAExServerCleanup;
        LPFNEXGETSERVERINFOPROC m_lpfnWAExGetServerInfo;
        LPFNEXGETSERVERLICENSESPROC m_lpfnWAExGetServerLicenses;
        LPFNEXSERVEREVENTPROC m_lpfnWAExServerEvent;
        LPFNEXGETGLOBALINFOPROC m_lpfnWAExGetGlobalInfo;
        LPFNEXGETWINSTATIONINFOPROC m_lpfnWAExGetWinStationInfo;
        LPFNEXGETWINSTATIONMODULESPROC m_lpfnWAExGetWinStationModules;
        LPFNEXFREESERVERLICENSESPROC m_lpfnWAExFreeServerLicenses;
        LPFNEXFREEWINSTATIONMODULESPROC m_lpfnWAExFreeWinStationModules;

        // user preferences
        UINT m_Confirmation;            // ask user for confirmation
        UINT m_SavePreferences;         // save preferences upon exit
        UINT m_ProcessListRefreshTime;
        UINT m_StatusRefreshTime;

        CDocument *m_Document;

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CWinAdminApp)
        public:
        virtual BOOL InitInstance();
        virtual int ExitInstance();
        //}}AFX_VIRTUAL

// Implementation

        //{{AFX_MSG(CWinAdminApp)
        afx_msg void OnAppAbout();
                // NOTE - the ClassWizard will add and remove member functions here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

enum NODETYPE {
        NODE_ALL_SERVERS,
        NODE_DOMAIN,
        NODE_SERVER,
        NODE_WINSTATION,
        NODE_PUBLISHED_APPS,
        NODE_APPLICATION,
        NODE_APP_SERVER,

        NODE_FAV_LIST,
        NODE_THIS_COMP,
        NODE_NONE
};

class CNodeType : public CObject
{
public:
    CNodeType( NODETYPE m )
    {
        m_nodetype = m;
    }

    ~CNodeType()
    {
        ODS( L"CNodeType I'm going away\n" );
    }

    NODETYPE m_nodetype;
};

class CTreeNode : public CObject
{
public:
        // constructor
        CTreeNode(NODETYPE NodeType, CObject* pObject) { m_NodeType = NodeType; m_pTreeObject = pObject; }
        // Returns the node type
        NODETYPE GetNodeType() { return m_NodeType; }
        // Returns the object pointed to by this node
        CObject *GetTreeObject() { return m_pTreeObject; }
        // Returns the sort order stored in the object
        ULONG GetSortOrder() { return m_SortOrder; }
        // Sets the sort order stored with the object
        void SetSortOrder(ULONG order) { m_SortOrder = order; }

        virtual ~CTreeNode( )
        {
            if( m_NodeType == NODE_FAV_LIST ||  m_NodeType == NODE_THIS_COMP )
            {
                if( m_pTreeObject != NULL )
                {
                    delete m_pTreeObject;
                }
                
            }            
        }

private:
        NODETYPE m_NodeType;
        CObject* m_pTreeObject;
        ULONG m_SortOrder;
};

// structure passed to the Server's BackgroundThreadProc
typedef struct _ServerProcInfo {
        CDocument *pDoc;
        CServer *pServer;
} ServerProcInfo;

// structure for storing User SID
class CUserSid : public CObject
{
public:
        USHORT m_SidCrc;
        TCHAR m_UserName[USERNAME_LENGTH+1];
};

// Information we get from the registry of the server
typedef struct _ServerRegistryInfo {
        ULONG InstallDate;
        TCHAR ServicePackLevel[128];
        TCHAR MSVersion[128];
        DWORD MSVersionNum;
        TCHAR MSBuild[128];
    TCHAR MSProductName[128];
        TCHAR CTXProductName[128];
        TCHAR CTXVersion[128];
        DWORD CTXVersionNum;
        TCHAR CTXBuild[128];
} ServerRegistryInfo;


class CHotfix : public CObject
{
public:
        TCHAR m_Name[10];
        TCHAR m_InstalledBy[USERNAME_LENGTH + 1];
        ULONG m_InstalledOn;
        ULONG m_Valid;
        CServer *m_pServer;
};

typedef struct _EncLevel {
    WORD StringID;
    DWORD RegistryValue;
    WORD Flags;
} EncryptionLevel;

typedef LONG (WINAPI *LPFNEXTENCRYPTIONLEVELSPROC) (WDNAME *pWdName, EncryptionLevel **);

class CWd : public CObject
{
public:
        // constructor
        CWd(PWDCONFIG2 pWdConfig, PWDNAME pRegistryName);
        // destructor
        ~CWd();

        BOOL GetEncryptionLevelString(DWORD Value, CString *pString);
        TCHAR *GetName() { return m_WdName; }
        TCHAR *GetRegistryName() { return m_RegistryName; }

private:
        HINSTANCE   m_hExtensionDLL;
        WDNAME m_WdName;
        WDNAME m_RegistryName;
        LPFNEXTENCRYPTIONLEVELSPROC m_lpfnExtEncryptionLevels;
    EncryptionLevel *m_pEncryptionLevels;
    LONG m_NumEncryptionLevels;
};

// structure passed to a Domain's background thread process
typedef struct _DomainProcInfo {
    LPVOID pDoc;
    CDomain *pDomain;
} DomainProcInfo;

// Flags for CDomain objects
const ULONG DF_CURRENT_DOMAIN           = 0x00000001;

// States of CDomain objects
enum DOMAIN_STATE {
        DS_NONE,                                // seed value for m_State and m_PreviousState
        DS_NOT_ENUMERATING,             // not enumerating (m_pBackgroundThread == NULL)
        DS_INITIAL_ENUMERATION, // enumerating servers for the first time
        DS_ENUMERATING,                 // enumerating
        DS_STOPPED_ENUMERATING, // no longer enumerating
};

class CDomain : public CObject
{
public:
        // constructor
        CDomain(TCHAR *name);
        // destructor
        ~CDomain();

    TCHAR *GetName() { return m_Name; }

        // Returns the state of this domain object
        DOMAIN_STATE GetState() { return m_State; }
        // Sets the state of this domain object
        void SetState(DOMAIN_STATE State);
        // Returns the previous state of this domain object
        DOMAIN_STATE GetPreviousState() { return m_PreviousState; }
        // Returns TRUE if m_State is set to a given state
        BOOLEAN IsState(DOMAIN_STATE State) { return (m_State == State); }
        // Returns TRUE if m_PreviousState is set to a given state
        BOOLEAN IsPreviousState(DOMAIN_STATE State) { return (m_PreviousState == State); }

        // Returns the tree item handle
        HTREEITEM GetTreeItem() { return m_hTreeItem; }
        // Sets the tree item handle
        void SetTreeItem(HTREEITEM handle) { m_hTreeItem = handle; }

        BOOLEAN IsCurrentDomain() { return (m_Flags & DF_CURRENT_DOMAIN) > 0; }
        void SetCurrentDomain() { m_Flags |= DF_CURRENT_DOMAIN; }
        void ClearCurrentDomain() { m_Flags &= ~DF_CURRENT_DOMAIN; }

        BOOL StartEnumerating();
        void StopEnumerating();
        void SetEnumEvent() { if(m_pBackgroundThread) m_WakeUpEvent.SetEvent(); }

        void LockBackgroundThread() { m_ThreadCriticalSection.Lock(); }
        void UnlockBackgroundThread() { m_ThreadCriticalSection.Unlock(); }

        // returns TRUE as long as the background thread should keep running
        BOOL ShouldBackgroundContinue() { return m_BackgroundContinue; }

    void ClearBackgroundContinue() { m_BackgroundContinue = FALSE; }

    // Returns the pointer to the domain's background thread
    CWinThread *GetThreadPointer() { return m_pBackgroundThread; }

        LPWSTR EnumHydraServers( /*LPWSTR pDomain,*/ DWORD verMajor, DWORD verMinor );

        void CreateServers(LPWSTR pBuffer, LPVOID pDoc);

        // Connect to all servers in this Domain
        void ConnectAllServers();

        // Disconnect from all servers in this Domain
        void DisconnectAllServers();

private:

        // the state of the domain object
        DOMAIN_STATE m_State;
        DOMAIN_STATE m_PreviousState;
        // the name of the domain
    TCHAR m_Name[50];
    HTREEITEM m_hTreeItem;

        // Background thread to update document when servers
        // appear and disapper
        // Called with AfxBeginThread
        static UINT BackgroundThreadProc(LPVOID);
        CWinThread *m_pBackgroundThread;
        BOOL m_BackgroundContinue;
        // Event to wakeup background thread so that
        // he can exit (WaitForSingleEvent instead of Sleep)
        CEvent m_WakeUpEvent;
        // Critical section to protect accesses to m_pBackgroundThread
        CCriticalSection m_ThreadCriticalSection;

    ULONG m_Flags;

};


// Flags for CServer objects
const ULONG SF_BACKGROUND_FOUND     = 0x00000001;
const ULONG SF_SERVER_INACTIVE      = 0x00000002;
const ULONG SF_REGISTRY_INFO        = 0x00000004;
const ULONG SF_HANDLE_GOOD          = 0x00000008;
const ULONG SF_SELECTED             = 0x00000010;
const ULONG SF_UNDEFINED_0040       = 0x00000020;
const ULONG SF_UNDEFINED_0080       = 0x00000040;
const ULONG SF_LOST_CONNECTION      = 0x00000080;
const ULONG SF_FOUND_LATER          = 0x00000100;
const ULONG SF_WINFRAME             = 0x00000200;
const ULONG SF_CONNECTED            = 0x00000400;

// How many times we will let a load level query timeout
// before we set it to N/A
const USHORT MAX_LL_TIMEOUTS = 10;

// States of CServer objects
enum SERVER_STATE {
        SS_NONE,                        // seed value for m_State and m_PreviousState
        SS_NOT_CONNECTED,       // not connected yet or disconnected
        SS_OPENED,                      // opened RPC connection
        SS_GETTING_INFO,        // getting information about the server
        SS_GOOD,                        // server information is good
        SS_DISCONNECTING,       // in the process of disconnecting
        SS_BAD                          // could not open the server
};


class CServer : public CObject
{
public:

    // constructor
    CServer(CDomain *pDomain, TCHAR *name, BOOL bFoundLater, BOOL bConnect);        // FoundLater is TRUE if found as new server after initial server enum
    // destructor
    ~CServer();

    // Functions to check,set,and clear m_ServerFlags
    BOOLEAN IsServerSane() { return (m_State != SS_BAD); }

    BOOLEAN IsManualFind( ) { return m_fManualFind; }
    void SetManualFind( ) { m_fManualFind = TRUE; }
    void ClearManualFind( ) { m_fManualFind = FALSE; }

    BOOLEAN IsBackgroundFound() { return (m_ServerFlags & SF_BACKGROUND_FOUND) > 0; }
    void SetBackgroundFound() { m_ServerFlags |= SF_BACKGROUND_FOUND; }
    void ClearBackgroundFound() { m_ServerFlags &= ~SF_BACKGROUND_FOUND; }

    BOOLEAN IsServerInactive() { return (m_ServerFlags & SF_SERVER_INACTIVE) > 0; }
    void SetServerInactive() { m_ServerFlags |= SF_SERVER_INACTIVE;  m_BackgroundContinue = FALSE; }
    void ClearServerInactive() { m_ServerFlags &= ~SF_SERVER_INACTIVE; }
    BOOLEAN IsServerActive() { return (m_ServerFlags & SF_SERVER_INACTIVE) == 0; }

    BOOLEAN IsRegistryInfoValid() { return (m_ServerFlags & SF_REGISTRY_INFO) > 0; }
    void SetRegistryInfoValid() { m_ServerFlags |= SF_REGISTRY_INFO; }
    void ClearRegistryInfoValid() { m_ServerFlags &= ~SF_REGISTRY_INFO; }

    BOOLEAN IsHandleGood() { return (m_ServerFlags & SF_HANDLE_GOOD) > 0; }
    void SetHandleGood() { m_ServerFlags |= SF_HANDLE_GOOD; }
    void ClearHandleGood() { m_ServerFlags &= ~SF_HANDLE_GOOD; }

    BOOLEAN IsSelected() { return (m_ServerFlags & SF_SELECTED) > 0; }
    void SetSelected() { m_ServerFlags |= SF_SELECTED; }
    void ClearSelected() { m_ServerFlags &= ~SF_SELECTED; }

    BOOLEAN HasLostConnection() { return (m_ServerFlags & SF_LOST_CONNECTION) > 0; }
    void SetLostConnection() { m_ServerFlags |= SF_LOST_CONNECTION; }
    void ClearLostConnection() { m_ServerFlags &= ~SF_LOST_CONNECTION; }

    BOOLEAN WasFoundLater() { return (m_ServerFlags & SF_FOUND_LATER) > 0; }
    void SetFoundLater() { m_ServerFlags |= SF_FOUND_LATER; }
    void ClearFoundLater() { m_ServerFlags &= ~SF_FOUND_LATER; }

    BOOLEAN IsWinFrame() { return (m_ServerFlags & SF_WINFRAME) > 0; }
    void SetWinFrame() { m_ServerFlags |= SF_WINFRAME; }
    void ClearWinFrame() { m_ServerFlags &= ~SF_WINFRAME; }

    // Returns the state of this server object
    SERVER_STATE GetState() { return m_State; }
    // Sets the state of this server object
    void SetState(SERVER_STATE State);
    // Returns the previous state of this server object
    SERVER_STATE GetPreviousState() { return m_PreviousState; }
    // Returns TRUE if m_State is set to a given state
    BOOLEAN IsState(SERVER_STATE State) { return (m_State == State); }
    // Returns TRUE if m_PreviousState is set to a given state
    BOOLEAN IsPreviousState(SERVER_STATE State) { return (m_PreviousState == State); }
    // Add a WinStation to WinStationList in sorted order
    void AddWinStation(CWinStation *pWinStation);
    // Returns a pointer to the WinStation linked list
    CObList *GetWinStationList() { return &m_WinStationList; }
    // Locks the WinStation linked list
    void LockWinStationList() { m_WinStationListCriticalSection.Lock(); }
    // Unlocks the WinStation linked list
    void UnlockWinStationList() { m_WinStationListCriticalSection.Unlock(); }

    void LockThreadAlive() { m_ThreadCriticalSection.Lock(); }
    void UnlockThreadAlive() { m_ThreadCriticalSection.Unlock(); }
    void SetThreadAlive() { LockThreadAlive(); m_bThreadAlive = TRUE; UnlockThreadAlive(); }
    void ClearThreadAlive() { LockThreadAlive(); m_bThreadAlive = FALSE; UnlockThreadAlive(); }

    // Returns a pointer to the Process linked list
    CObList *GetProcessList() { return &m_ProcessList; }
    // Locks the Process linked list
    void LockProcessList() { m_ProcessListCriticalSection.Lock(); }
    // Unlocks the Process linked list
    void UnlockProcessList() { m_ProcessListCriticalSection.Unlock(); }

    // Returns a pointer to the License linked list
    CObList *GetLicenseList() { return &m_LicenseList; }
    // Locks the License linked list
    void LockLicenseList() { m_LicenseListCriticalSection.Lock(); }
    // Unlocks the License linked list
    void UnlockLicenseList() { m_LicenseListCriticalSection.Unlock(); }

    // Returns a pointer to the User Sid linked list
    CObList *GetUserSidList() { return &m_UserSidList; }
    // Returns a pointer to the Hotfix linked list
    CObList *GetHotfixList() { return &m_HotfixList; }
    // Get the server's handle
    HANDLE GetHandle() { return m_Handle; }
    // Set the handle
    void SetHandle(HANDLE hIn) { m_Handle = hIn; }
    // Go get detailed information about the server
    void DoDetail();
    // Get this server's addresses from the browser
    void QueryAddresses();
    // Enumerate this server's processes
    BOOL EnumerateProcesses();
    // Clear out the list of processes
    void ClearProcesses();
    // Get the name of the server
    TCHAR *GetName() { return m_Name; }
    // Returns TRUE if this is the server that the app is being run from
    BOOL IsCurrentServer() { return (lstrcmpi(m_Name, ((CWinAdminApp*)AfxGetApp())->GetCurrentServerName()) == 0); }
    // Clears the WAF_SELECTED bit in all of this server's lists
    void ClearAllSelected();
    // returns TRUE as long as the background thread should keep running
    BOOL ShouldBackgroundContinue() { return m_BackgroundContinue; }
    // turns off the background continue boolean
    void ClearBackgroundContinue() { m_BackgroundContinue = FALSE; }
    // returns a pointer to a CWinStation from m_WinStationList
    CWinStation *FindWinStationById(ULONG Id);
    // returns a pointer to a CProcess from m_ProcessList given a PID
    CProcess *FindProcessByPID(ULONG Pid);
    // returns the number of connected WinStations
    ULONG GetNumWinStations() { return m_NumWinStations; }
    // Sets the number of connected WinStations
    void SetNumWinStations(ULONG num) { m_NumWinStations = num; }
    // Go out and fill in the registry info structure
    BOOL BuildRegistryInfo();
    // Returns the Install Date
    ULONG GetInstallDate() { return m_pRegistryInfo->InstallDate; }
    // Returns the Service Pack Level
    TCHAR *GetServicePackLevel() { return m_pRegistryInfo->ServicePackLevel; }
    // Returns the handle to this server's tree item
    TCHAR *GetMSVersion() { return m_pRegistryInfo->MSVersion; }
    // Returns the MS product version number (binary)
    DWORD GetMSVersionNum() { return m_pRegistryInfo->MSVersionNum; }
    // Returns the MS product build
    TCHAR *GetMSBuild() { return m_pRegistryInfo->MSBuild; }
    // Returns the MS product name
    TCHAR *GetMSProductName() { return m_pRegistryInfo->MSProductName; }
    // Returns the 'Citrix' product name
    TCHAR *GetCTXProductName() { return m_pRegistryInfo->CTXProductName; }
    // Returns the 'Citrix' product version
    TCHAR *GetCTXVersion() { return m_pRegistryInfo->CTXVersion; }
    // Returns the 'Citrix' product version number (binary)
    DWORD GetCTXVersionNum() { return m_pRegistryInfo->CTXVersionNum; }
    // Returns the 'Citrix' product build
    TCHAR *GetCTXBuild() { return m_pRegistryInfo->CTXBuild; }
   
    // Sets the pointer to the info from the extension DLL
    void SetExtensionInfo(void *p) { m_pExtensionInfo = p; }
    // Returns the pointer to the info from the extension DLL
    void *GetExtensionInfo() { return m_pExtensionInfo; }
    // Returns a pointer to the info from the extension DLL
    ExtServerInfo *GetExtendedInfo() { return m_pExtServerInfo; }

    // Manipulate the number selected counts
    UINT GetNumWinStationsSelected() { return m_NumWinStationsSelected; }
    UINT GetNumProcessesSelected() { return m_NumProcessesSelected; }
    void IncrementNumWinStationsSelected() { m_NumWinStationsSelected++; }
    void IncrementNumProcessesSelected() { m_NumProcessesSelected++; }
    void DecrementNumWinStationsSelected() { if(m_NumWinStationsSelected) m_NumWinStationsSelected--; }
    void DecrementNumProcessesSelected() { if(m_NumProcessesSelected) m_NumProcessesSelected--; }

    void RemoveWinStationProcesses(CWinStation *pWinStation); // remove all the processes for a given WinStation
    void QueryLicenses();
    CDomain *GetDomain() { return m_pDomain; }
    // Returns the pointer to the server's background thread
    CWinThread *GetThreadPointer() { return m_pBackgroundThread; }
    BOOL Connect();
    void Disconnect();
    
    // Returns the tree item handle
    HTREEITEM GetTreeItem() { return m_hTreeItem; }
    HTREEITEM GetTreeItemFromFav( ) { return m_hFavTree; }
    HTREEITEM GetTreeItemFromThisComputer( ) { return m_hThisServer; }

    // Sets the tree item handle
    void SetTreeItem(HTREEITEM handle) { m_hTreeItem = handle; }
    void SetTreeItemForFav( HTREEITEM handle ) { m_hFavTree = handle; }
    void SetTreeItemForThisComputer( HTREEITEM handle ) { m_hThisServer = handle; }


private:
    void AddLicense(CLicense *pNewLicense);

    // the state of the server object
    SERVER_STATE m_State;
    SERVER_STATE m_PreviousState;
    // the name of the server
    TCHAR m_Name[50];
    // Number of WinStations (store here for sorting)
    ULONG m_NumWinStations;
    // Handle to the tree item for this server in the tree view
    HTREEITEM m_hThisServer;
    HTREEITEM m_hTreeItem;
    HTREEITEM m_hFavTree;
    // Which domain this server is in
    CDomain *m_pDomain;

    // handle from WinStationOpenServer
    HANDLE m_Handle;

    CObList m_WinStationList;
    CCriticalSection m_WinStationListCriticalSection;

    CObList m_ProcessList;
    CCriticalSection m_ProcessListCriticalSection;

    CObList m_LicenseList;
    CCriticalSection m_LicenseListCriticalSection;

    CObList m_UserSidList;
    CObList m_HotfixList;

    // Pointer to registry info structure
    ServerRegistryInfo *m_pRegistryInfo;

    // Background thread to update document when WinStations
    // appear, disappear, and change state
    // Called with AfxBeginThread
    static UINT BackgroundThreadProc(LPVOID);
    CWinThread *m_pBackgroundThread;
    BOOL m_BackgroundContinue;
    // We need a critical section to wrap accesses to m_bThreadAlive
    CCriticalSection m_ThreadCriticalSection;
    BOOL m_bThreadAlive;

    // Keep track of how many of each thing are selected
    UINT m_NumWinStationsSelected;
    UINT m_NumProcessesSelected;

    ULONG m_ServerFlags;

    BOOLEAN m_fManualFind;

    // Pointer to information stored by the extension DLL
    void *m_pExtensionInfo;
    // Pointer to extended info from the extension DLL
    ExtServerInfo *m_pExtServerInfo;
};


class CLicense : public CObject
{
public:
        // constructor
        CLicense(CServer *pServer, ExtLicenseInfo *pLicenseInfo);
        // Return the serial number (what we sort on)
        TCHAR *GetSerialNumber() { return m_RegSerialNumber; }
        // Return the license number (what we display)
        TCHAR *GetLicenseNumber() { return m_LicenseNumber; }
        // Return the license class
        LICENSECLASS GetClass() { return m_Class; }
        // Return the description
        TCHAR *GetDescription() { return m_Description; }
        // Return the local count
        ULONG GetLocalCount() { return ((m_PoolCount == 0xFFFFFFFF) ? m_LicenseCount : m_LicenseCount - m_PoolCount); }
        // Return the pooled count
        ULONG GetPoolCount() { return ((m_PoolCount == 0xFFFFFFFF) ? 0 : m_PoolCount); }
        // Return the total count
        ULONG GetTotalCount() { return m_LicenseCount; }
        // Return TRUE if this license is registers
        BOOLEAN IsRegistered() { return((m_Flags & ELF_REGISTERED) > 0); }
        // Return TRUE if pooling is enabled
        BOOLEAN IsPoolingEnabled() { return(m_PoolCount != 0xFFFFFFFF); }
        // Returns a pointer to the server this license is for
        CServer *GetServer() { return m_pServer; }

private:
        LICENSECLASS m_Class;
        ULONG m_LicenseCount;
        ULONG m_PoolLicenseCount;
        WCHAR m_RegSerialNumber[26];
        WCHAR m_LicenseNumber[36];
        WCHAR m_Description[65];
        ULONG m_Flags;
        ULONG m_PoolCount;
        CServer *m_pServer;
};


typedef struct _MessageParms {
        TCHAR MessageTitle[MSG_TITLE_LENGTH + 1];
        TCHAR MessageBody[MSG_MESSAGE_LENGTH + 1];
        CWinStation* pWinStation;
} MessageParms;


typedef struct _ResetParms {
        CWinStation *pWinStation;
        BOOL bReset;    // TRUE if reset, FALSE if logoff
} ResetParms;


// Flags for CWinStation objects
const ULONG WF_SELECTED                 = 0x00000001;
const ULONG WF_CAN_BE_SHADOWED          = 0x00000002;
const ULONG WF_DIRECT_ASYNC             = 0x00000004;
const ULONG WF_CURRENT                  = 0x00000008;
const ULONG WF_HAS_USER                 = 0x00000010;
const ULONG WF_ADDITIONAL_DONE          = 0x00000020;
const ULONG WF_QUERIES_SUCCESSFUL       = 0x00000040;
const ULONG WF_CHANGED                  = 0x00000080;   // Changed during last enumeration
const ULONG WF_NEW                      = 0x00000100;   // New this enumeration


class CWinStation : public CObject
{
public:
        // constructor
        CWinStation(CServer *pServer, PLOGONID pLogonId);
        // destructor
        ~CWinStation();
        // Updates this WinStation with new data from another CWinStation
        BOOL Update(CWinStation *pWinStation);
        // Returns a pointer to this guy's server
        CServer *GetServer() { return m_pServer; }
        // Returns the logon Id
        ULONG GetLogonId() { return m_LogonId; }
        // Returns the name of the WinStation
        PWINSTATIONNAME GetName() { return m_Name; }
        // Sets the name
        void SetName(PWINSTATIONNAME name) { wcscpy(m_Name, name); }
        // Returns the state
        WINSTATIONSTATECLASS GetState() { return m_State; }
        // Sets the state
        void SetState(WINSTATIONSTATECLASS state) { m_State = state; }
        // Returns TRUE if m_State is set to a given state
        BOOLEAN IsState(WINSTATIONSTATECLASS state) { return (m_State == state); }
    // Returns the sort order
        ULONG GetSortOrder() { return m_SortOrder; }
        // Sets the sort order
        void SetSortOrder(ULONG sort) { m_SortOrder = sort; }
        // Returns the comment
        TCHAR *GetComment() { return m_Comment; }
        // Sets the comment
        void SetComment(TCHAR *comment) { wcscpy(m_Comment, comment); }
        // Returns the user name
        TCHAR *GetUserName() { return m_UserName; }
        // Sets the user name
        void SetUserName(TCHAR *name) { wcscpy(m_UserName, name); }
        // Returns the SdClass
        SDCLASS GetSdClass() { return m_SdClass; }
        // Sets the SdClass
        void SetSdClass(SDCLASS pd) { m_SdClass = pd; }
        // Returns the Logon Time
        LARGE_INTEGER GetLogonTime() { return m_LogonTime; }
        // Sets the Logon Time
        void SetLogonTime(LARGE_INTEGER t) { m_LogonTime = t; }
        // Returns the Last Input Time
        LARGE_INTEGER GetLastInputTime() { return m_LastInputTime; }
        // Sets the Last Input Time
        void SetLastInputTime(LARGE_INTEGER t) { m_LastInputTime = t; }
        // Returns the Current Time
        LARGE_INTEGER GetCurrentTime() { return m_CurrentTime; }
        // Set the Current Time
        void SetCurrentTime(LARGE_INTEGER t) { m_CurrentTime = t; }
        // Returns the IdleTime
        ELAPSEDTIME GetIdleTime() { return m_IdleTime; }
        // Sets the IdleTime variable
        void SetIdleTime(ELAPSEDTIME it) { m_IdleTime = it; }
        // Returns the WdName
        PWDNAME GetWdName() { return m_WdName; }
        // Sets the WdName
        void SetWdName(PWDNAME wdname) { wcscpy(m_WdName, wdname); }
        // Returns the Wd Structure
        CWd *GetWd() { return m_pWd; }
        // Sets the Wd Structure
        void SetWd(CWd *pwd) { m_pWd = pwd; }
        // Returns the PdName
        PPDNAME GetPdName() { return m_PdName; }
        // Returns the Client Name
        TCHAR *GetClientName() { return m_ClientName; }
        // Sets the Client Name
        void SetClientName(TCHAR *name) { wcscpy(m_ClientName, name); }
        //returns the client digital product id
                TCHAR* GetClientDigProductId() { return m_clientDigProductId; }
        //sets the client digital product id
        void SetClientDigProductId( TCHAR* prodid) { wcscpy(m_clientDigProductId, prodid); }
        // Returns the Client Build Number
        ULONG GetClientBuildNumber() { return m_ClientBuildNumber; }
        // Returns the Client Directory
        TCHAR *GetClientDir() { return m_ClientDir; }
        // Returns the Modem Name
        TCHAR *GetModemName() { return m_ModemName; }
        // Returns the Client License
        TCHAR *GetClientLicense() { return m_ClientLicense; }
        // Returns the Client Product Id
        USHORT GetClientProductId() { return m_ClientProductId; }
        // Returns the Client Serial Number
        ULONG GetClientSerialNumber() { return m_ClientSerialNumber; }
        // Returns the Client Address
        TCHAR *GetClientAddress() { return m_ClientAddress; }
        // Returns the number of host buffers
        USHORT GetHostBuffers() { return m_HostBuffers; }
        // Returns the number of client buffers
        USHORT GetClientBuffers() { return m_ClientBuffers; }
        // Returns the buffer length
        USHORT GetBufferLength() { return m_BufferLength; }
    // Gets additional information about the WinStation
    void QueryAdditionalInformation();
        // Shadow this WinStation
        void Shadow();
        // connect to this WinStation
        void Connect(BOOL bUser);
        // show status dialog
        void ShowStatus();
        // Are there outstanding threads?
        BOOL HasOutstandingThreads() { return(m_OutstandingThreads > 0); }
        // Is this WinStation down?
        BOOL IsDown() { return(m_State == State_Down || m_State == State_Init); }
        // Is this WinStation connected?
        BOOL IsConnected() { return(m_State == State_Connected || m_State == State_Active); }
        // Is this WinStation disconnected?
        BOOL IsDisconnected() { return(m_State == State_Disconnected); }
        // Is this WinStation active?
        BOOL IsActive() { return(m_State == State_Active); }
        // Is this WinStation idle?
        BOOL IsIdle() { return(m_State == State_Idle); }
        // Is this WinStation a listener?
        BOOL IsListener() { return(m_State == State_Listen); }
        // Is this the system console
        BOOL IsSystemConsole() { return(0 == lstrcmpi(m_Name, ((CWinAdminApp*)AfxGetApp())->m_szSystemConsole)); }
        // Returns TRUE if this WinStation is on the current server
        BOOL IsOnCurrentServer() { return m_pServer->IsCurrentServer(); }
        // Returns TRUE if the current user is logged in on this WinStation
        BOOL IsCurrentUser() { return(m_pServer->IsCurrentServer() && m_LogonId == ((CWinAdminApp*)AfxGetApp())->GetCurrentLogonId()); }
        //BOOL IsCurrentUser() { return(m_pServer->IsCurrentServer() && (lstrcmpi(m_UserName, ((CWinAdminApp*)AfxGetApp())->GetCurrentUserName()) == 0)); }
        // Returns TRUE if this is the current WinStation
        BOOL IsCurrentWinStation() { return(m_pServer->IsCurrentServer() && m_LogonId == ((CWinAdminApp*)AfxGetApp())->GetCurrentLogonId()); }
        // Returns the handle to this WinStations's tree item
        HTREEITEM GetTreeItem() { return m_hTreeItem; }
        HTREEITEM GetTreeItemFromFav( ) { return m_hFavTree; }
        HTREEITEM GetTreeItemFromThisComputer( ) { return m_hTreeThisComputer; }
        // Sets the tree item handle
        void SetTreeItem(HTREEITEM handle) { m_hTreeItem = handle; }
        void SetTreeItemForFav( HTREEITEM handle ) { m_hFavTree = handle; }
        void SetTreeItemForThisComputer( HTREEITEM handle ) { m_hTreeThisComputer = handle; }
        // Returns the number of colors
        TCHAR *GetColors() { return m_Colors; }
        // Returns the vertical resolution
        USHORT GetVRes() { return m_VRes; }
        // Returns the horizontal resolution
        USHORT GetHRes() { return m_HRes; }
    // Returns the protocol
    USHORT GetProtocolType() { return m_ProtocolType; }
    // Returns the encryption level
    BYTE GetEncryptionLevel() { return m_EncryptionLevel; }
    // Sets the encryption level
    void SetEncryptionLevel(BYTE level) { m_EncryptionLevel = level; }

        // Fills in the CString with the description of the Encryption level
        BOOL GetEncryptionLevelString(CString *pString) {
                if(m_pWd) {
                        return m_pWd->GetEncryptionLevelString(m_EncryptionLevel, pString);
                }
                else return FALSE;
        }
        // Returns the name of the Wd in the registry
        TCHAR *GetWdRegistryName() { return (m_pWd) ? m_pWd->GetRegistryName() : NULL; }

        // Returns the time of the last update to this WinStation's data
        clock_t GetLastUpdateClock() { return m_LastUpdateClock; }
        void SetLastUpdateClock() { m_LastUpdateClock = clock(); }

    // Is this an ICA WinStation?
    BOOL IsICA() { return(m_ProtocolType == PROTOCOL_ICA); }

        // Can this WinStation be shadowed
        BOOL CanBeShadowed() { return((m_WinStationFlags & WF_CAN_BE_SHADOWED) > 0); }
        void SetCanBeShadowed() { m_WinStationFlags |= WF_CAN_BE_SHADOWED; }
        void ClearCanBeShadowed() { m_WinStationFlags &= ~WF_CAN_BE_SHADOWED; }

        BOOLEAN IsDirectAsync() { return (m_WinStationFlags & WF_DIRECT_ASYNC) > 0; }
        void SetDirectAsync() { m_WinStationFlags |= WF_DIRECT_ASYNC; }
        void ClearDirectAsync() { m_WinStationFlags &= ~WF_DIRECT_ASYNC; }

        BOOLEAN IsCurrent() { return (m_WinStationFlags & WF_CURRENT) > 0; }
        void SetCurrent() { m_WinStationFlags |= WF_CURRENT; }
        void ClearCurrent() { m_WinStationFlags &= ~WF_CURRENT; }

        BOOLEAN IsChanged() { return (m_WinStationFlags & WF_CHANGED) > 0; }
        void SetChanged() { m_WinStationFlags |= WF_CHANGED; }
        void ClearChanged() { m_WinStationFlags &= ~WF_CHANGED; }

        BOOLEAN IsNew() { return (m_WinStationFlags & WF_NEW) > 0; }
        void SetNew() { m_WinStationFlags |= WF_NEW; }
        void ClearNew() { m_WinStationFlags &= ~WF_NEW; }

        BOOLEAN IsSelected() { return (m_WinStationFlags & WF_SELECTED) > 0; }
        void SetSelected() 
        { 
            if (!IsSelected()) 
            { 
                m_WinStationFlags |= WF_SELECTED; 
                m_pServer->IncrementNumWinStationsSelected(); 
            } 
        }
        
        void ClearSelected() 
        { 
            if (IsSelected()) 
            {
                m_WinStationFlags &= ~WF_SELECTED; 
                m_pServer->DecrementNumWinStationsSelected(); 
            }
        }

        BOOLEAN HasUser() { return (m_WinStationFlags & WF_HAS_USER) > 0; }
        void SetHasUser() { m_WinStationFlags |= WF_HAS_USER; }
        void ClearHasUser() { m_WinStationFlags &= ~WF_HAS_USER; }

        BOOLEAN AdditionalDone() { return (m_WinStationFlags & WF_ADDITIONAL_DONE) > 0; }
        void SetAdditionalDone() { m_WinStationFlags |= WF_ADDITIONAL_DONE; }
        void ClearAdditionalDone() { m_WinStationFlags &= ~WF_ADDITIONAL_DONE; }

        BOOL QueriesSuccessful() { return (m_WinStationFlags & WF_QUERIES_SUCCESSFUL) > 0; }
        void SetQueriesSuccessful() { m_WinStationFlags |= WF_QUERIES_SUCCESSFUL; }
        void ClearQueriesSuccessful() { m_WinStationFlags &= ~WF_QUERIES_SUCCESSFUL; }

        // Sets the pointer to the info from the extension DLL
        void SetExtensionInfo(void *p) { m_pExtensionInfo = p; }
        // Returns the pointer to the info from the extension DLL
        void *GetExtensionInfo() { return m_pExtensionInfo; }
    // Sets the pointer to the info from the extension DLL
    void SetExtendedInfo(ExtWinStationInfo *p) { m_pExtWinStationInfo = p; }
        // Returns a pointer to the info from the extension DLL
        ExtWinStationInfo *GetExtendedInfo() { return m_pExtWinStationInfo; }
        // Returns a pointer to the module info from the extension DLL
        ExtModuleInfo *GetExtModuleInfo() { return m_pExtModuleInfo; }
    // Sets the pointer to the module info from the extension DLL
    void SetExtModuleInfo(ExtModuleInfo *m) { m_pExtModuleInfo = m; }
        // Returns the number of modules
        ULONG GetNumModules() { return m_NumModules; }

        void BeginOutstandingThread() {
                                ::InterlockedIncrement(&m_OutstandingThreads);
                                //((CWinAdminApp*)AfxGetApp())->BeginOutStandingThread());
        }

        void EndOutstandingThread()     {
                                ::InterlockedDecrement(&m_OutstandingThreads);
                                //((CWinAdminApp*)AfxGetApp())->EndOutStandingThread());
        }

        // static member function to send a message to a WinStation
        // Called with AfxBeginThread
        static UINT SendMessage(LPVOID);
        // static member function to disconnect a WinStation
        // Called with AfxBeginThread
        static UINT Disconnect(LPVOID);
        // static member function to reset a WinStation
        // Called with AfxBeginThread
        static UINT Reset(LPVOID);

private:
        CServer* m_pServer;
        CWd* m_pWd;
        ULONG m_LogonId;
        WINSTATIONNAME m_Name;
        WINSTATIONSTATECLASS m_State;
        ULONG m_SortOrder;
        TCHAR m_Comment[WINSTATIONCOMMENT_LENGTH + 1];
        TCHAR m_UserName[USERNAME_LENGTH + 1];
        SDCLASS m_SdClass;
        LARGE_INTEGER m_LogonTime;
        LARGE_INTEGER m_LastInputTime;
        LARGE_INTEGER m_CurrentTime;
        ELAPSEDTIME m_IdleTime;
        WDNAME m_WdName;
        PDNAME m_PdName;
        TCHAR m_ClientName[CLIENTNAME_LENGTH + 1];
        ULONG m_ClientBuildNumber;
        TCHAR m_ClientDir[256];
        TCHAR m_ModemName[256];
        TCHAR m_ClientLicense[30];
        USHORT m_ClientProductId;
        ULONG m_ClientSerialNumber;
        TCHAR m_ClientAddress[30];
        USHORT m_HostBuffers;
        USHORT m_ClientBuffers;
        USHORT m_BufferLength;
        LONG m_OutstandingThreads;      // the number of outstanding threads

        HTREEITEM m_hTreeItem;          // tree item for this WinStation in the servers tree view
        HTREEITEM m_hFavTree;
        HTREEITEM m_hTreeThisComputer;
        USHORT m_VRes;                          // Vertical resolution
        USHORT m_HRes;                          // Horizontal resolution
        TCHAR m_Colors[4];                      // Number of colors (as an ASCII string)
        clock_t m_LastUpdateClock;      // Tick count when we last update this WinStation's info
        USHORT m_ProtocolType;      // Protocol - PROTOCOL_ICA or PROTOCOL_RDP
        BYTE m_EncryptionLevel;         // security level of encryption pd

        ULONG m_WinStationFlags;

        // Pointer to information stored by the extension DLL
        void *m_pExtensionInfo;
        ExtWinStationInfo *m_pExtWinStationInfo;
        ExtModuleInfo *m_pExtModuleInfo;
        ULONG m_NumModules;
        TCHAR m_clientDigProductId[CLIENT_PRODUCT_ID_LENGTH];
};

// Process flags
const ULONG PF_SYSTEM           = 0x00000001;
const ULONG PF_SELECTED         = 0x00000002;
const ULONG PF_TERMINATING      = 0x00000004;   // Currently trying to terminate it
const ULONG PF_CHANGED          = 0x00000008;   // Changed during last enumeration
const ULONG PF_CURRENT          = 0x00000010;   // Still active during last enumeration
const ULONG PF_NEW              = 0x00000020;   // New this enumeration

class CProcess : public CObject
{
public:
        // Constructor
        CProcess(ULONG PID,
             ULONG LogonId,
             CServer *pServer,
             PSID pSID,
             CWinStation *pWinStation,
             TCHAR *ImageName);

        // Updates a process with new information from another process
        BOOL Update(CProcess *pProcess);
        // Returns a pointer to the server that this Process if running on
        CServer *GetServer() { return m_pServer; }
        // Sets the Server
        void SetServer(CServer *pServer) { m_pServer = pServer; }
        // Returns a pointer to the WinStation that owns this process
        CWinStation *GetWinStation() { return m_pWinStation; }
        // Sets the Winstation
        void SetWinStation(CWinStation *pWinStation) { m_pWinStation = pWinStation; }
        // Returns the PID of this process
        ULONG GetPID() { return m_PID; }

        // Returns the LogonId for this process
        ULONG GetLogonId() { return m_LogonId; }
        // Returns a pointer to the image name
        TCHAR *GetImageName() { return m_ImageName; }
        // Returns a pointer to the user name
        TCHAR *GetUserName() { return m_UserName; }
        // Returns TRUE if this process belongs to the current user
        // BOOL IsCurrentUsers() { return (m_pServer->IsCurrentServer()
        //                                                         && wcscmp(m_UserName, ((CWinAdminApp*)AfxGetApp())->GetCurrentUserName())==0); }

        BOOL IsCurrentUsers() { return(m_pServer->IsCurrentServer() && m_LogonId == ((CWinAdminApp*)AfxGetApp())->GetCurrentLogonId()); }


        BOOLEAN IsSystemProcess() { return (m_Flags & PF_SYSTEM) > 0; }
        void SetSystemProcess() { m_Flags |= PF_SYSTEM; }
        void ClearSystemProcess() { m_Flags &= ~PF_SYSTEM; }

        BOOLEAN IsSelected() { return (m_Flags & PF_SELECTED) > 0; }
        void SetSelected() { m_Flags |= PF_SELECTED; m_pServer->IncrementNumProcessesSelected(); }
        void ClearSelected() { m_Flags &= ~PF_SELECTED; m_pServer->DecrementNumProcessesSelected(); }

        BOOLEAN IsTerminating() { return (m_Flags & PF_TERMINATING) > 0; }
        void SetTerminating() { m_Flags |= PF_TERMINATING; }
        void ClearTerminating() { m_Flags &= ~PF_TERMINATING; }

        BOOLEAN IsCurrent() { return (m_Flags & PF_CURRENT) > 0; }
        void SetCurrent() { m_Flags |= PF_CURRENT; }
        void ClearCurrent() { m_Flags &= ~PF_CURRENT; }

        BOOLEAN IsChanged() { return (m_Flags & PF_CHANGED) > 0; }
        void SetChanged() { m_Flags |= PF_CHANGED; }
        void ClearChanged() { m_Flags &= ~PF_CHANGED; }

        BOOLEAN IsNew() { return (m_Flags & PF_NEW) > 0; }
        void SetNew() { m_Flags |= PF_NEW; }
        void ClearNew() { m_Flags &= ~PF_NEW; }

private:
        // Determine whether or not this is a system process
        BOOL QuerySystemProcess();
        // Determine which user owns a process
        void DetermineProcessUser(PSID pSid);

        ULONG m_PID;
        ULONG m_LogonId;
        USHORT m_SidCrc;
        TCHAR m_ImageName[20];//[MAX_PROCESSNAME+1];
        TCHAR m_UserName[USERNAME_LENGTH+1];
        CServer *m_pServer;
        CWinStation *m_pWinStation;
        ULONG m_Flags;
};

class CAdminView : public CView
{
public:
        virtual void Reset(void *) { }
        virtual LRESULT OnTabbed( WPARAM , LPARAM ){ return 0;}
};

//=------------------------------------------------
class CMyTabCtrl : public CTabCtrl
{    
public:
    CMyTabCtrl()
    {
        
    }
protected:
    afx_msg void OnSetFocus( CWnd* );
    DECLARE_MESSAGE_MAP()
};
//=------------------------------------------------

class CAdminPage : public CFormView
{
friend class CServerView;
friend class CWinStationView;
friend class CAllServersView;
friend class CDomainView;

public:
   CAdminPage(UINT nIDTemplate);
   CAdminPage();
   DECLARE_DYNCREATE(CAdminPage)

   virtual void Reset(void *) { }
   virtual void ClearSelections() { }
};


typedef struct _columndefs {
        UINT stringID;
        int format;
   int width;
} ColumnDef;

// Commonly used column definitions
#define CD_SERVER               {       IDS_COL_SERVER,                 LVCFMT_LEFT,    115             }
#define CD_USER                 {       IDS_COL_USER,                   LVCFMT_LEFT,    100     }
#define CD_USER2                {       IDS_COL_USER,                   LVCFMT_LEFT,    80              }
#define CD_USER3                {       IDS_COL_USER,                   LVCFMT_LEFT,    90              }
#define CD_SESSION              {       IDS_COL_WINSTATION,             LVCFMT_LEFT,    80              }
#define CD_SESSION2             {       IDS_COL_WINSTATION,             LVCFMT_LEFT,    100     }
#define CD_ID                   {       IDS_COL_ID,                             LVCFMT_RIGHT,   30              }
#define CD_STATE                {       IDS_COL_STATE,                  LVCFMT_LEFT,    50              }
#define CD_TYPE                 {       IDS_COL_TYPE,                   LVCFMT_LEFT,    80              }
#define CD_CLIENT_NAME  {       IDS_COL_CLIENT_NAME,    LVCFMT_LEFT,    80              }
#define CD_IDLETIME             {       IDS_COL_IDLETIME,               LVCFMT_RIGHT,   80              }
#define CD_LOGONTIME    {       IDS_COL_LOGONTIME,              LVCFMT_LEFT,    90              }
#define CD_COMMENT              {       IDS_COL_COMMENT,                LVCFMT_LEFT,    200             }
// Server Columns
#define CD_TCPADDRESS   {       IDS_COL_TCPADDRESS,             LVCFMT_LEFT,    90              }
#define CD_IPXADDRESS   {       IDS_COL_IPXADDRESS,             LVCFMT_LEFT,    110             }
#define CD_NUM_SESSIONS {       IDS_COL_NUM_WINSTATIONS, LVCFMT_RIGHT,  70              }
// License Columns
#define CD_LICENSE_DESC {       IDS_COL_LICENSE_DESC,   LVCFMT_LEFT,    200             }
#define CD_LICENSE_REG  {       IDS_COL_LICENSE_REGISTERED,             LVCFMT_CENTER,  80      }
#define CD_USERCOUNT    {       IDS_COL_USERCOUNT,      LVCFMT_RIGHT,   80              }
#define CD_POOLCOUNT    {       IDS_COL_POOLCOUNT,      LVCFMT_RIGHT,   80              }
#define CD_LICENSE_NUM  {       IDS_COL_LICENSE_NUMBER, LVCFMT_LEFT,    240             }
// Process Columns
#define CD_PROC_ID      {       IDS_COL_ID,                             LVCFMT_RIGHT,   30              }
#define CD_PROC_PID     {       IDS_COL_PID,                    LVCFMT_RIGHT,   50              }
#define CD_PROC_IMAGE   {       IDS_COL_IMAGE,                  LVCFMT_LEFT,    100             }
// Hotfix Columns
#define CD_HOTFIX               {       IDS_COL_HOTFIX,                 LVCFMT_LEFT,    90              }
#define CD_INSTALLED_BY {       IDS_COL_INSTALLED_BY,   LVCFMT_LEFT,    90              }
#define CD_INSTALLED_ON {       IDS_COL_INSTALLED_ON,   LVCFMT_LEFT,    150             }


// Definitions of PageDef flags
const UINT PF_PICASSO_ONLY = 0x0001;
const UINT PF_NO_TAB = 0x0002;

typedef struct _pagedef {
   CAdminPage *m_pPage;
   CRuntimeClass *m_pRuntimeClass;
   UINT tabStringID;
   int page;
   UINT flags;
} PageDef;
//defines for help

//=================================================================================

#define ID_HELP_FILE L"tsadmin.hlp"

//==================================================================================
#define HIDC_MESSAGE_TITLE                      0x500FB
#define HIDC_SHADOWSTART_HOTKEY                 0x500F1
#define HIDC_SHADOWSTART_SHIFT                  0x500F2
#define HIDC_SHADOWSTART_CTRL                   0x500F3
#define HIDC_SHADOWSTART_ALT                    0x500F4
#define HIDC_MESSAGE_TITLE                      0x500FB
#define HIDC_MESSAGE_MESSAGE                    0x500FC
#define HIDC_COMMON_USERNAME                    0x5012C
#define HIDC_COMMON_WINSTATIONNAME              0x5012D
#define HIDC_COMMON_IBYTES                      0x5012E
#define HIDC_COMMON_OBYTES                      0x5012F
#define HIDC_COMMON_IFRAMES                     0x50130
#define HIDC_COMMON_OFRAMES                     0x50131
#define HIDC_COMMON_IBYTESPERFRAME              0x50132
#define HIDC_COMMON_OBYTESPERFRAME              0x50133
#define HIDC_COMMON_IFRAMEERRORS                0x50134
#define HIDC_COMMON_OFRAMEERRORS                0x50135
#define HIDC_COMMON_IPERCENTFRAMEERRORS         0x50136
#define HIDC_COMMON_OPERCENTFRAMEERRORS         0x50137
#define HIDC_COMMON_ITIMEOUTERRORS              0x50138
#define HIDC_COMMON_OTIMEOUTERRORS              0x50139
#define HIDC_COMMON_ICOMPRESSIONRATIO           0x5013A
#define HIDC_COMMON_OCOMPRESSIONRATIO           0x5013B
#define HIDC_REFRESHNOW                         0x50140
#define HIDC_RESETCOUNTERS                      0x50141
#define HIDC_MOREINFO                           0x50142
#define HIDC_ASYNC_DEVICE                       0x5015F
#define HIDC_ASYNC_BAUD                         0x50160
#define HIDC_ASYNC_DTR                          0x50161
#define HIDC_ASYNC_RTS                          0x50162
#define HIDC_ASYNC_CTS                          0x50163
#define HIDC_ASYNC_DSR                          0x50164
#define HIDC_ASYNC_DCD                          0x50165
#define HIDC_ASYNC_RI                           0x50166
#define HIDC_ASYNC_IFRAMING                     0x50167
#define HIDC_ASYNC_IOVERRUN                     0x50168
#define HIDC_ASYNC_IOVERFLOW                    0x50169
#define HIDC_ASYNC_IPARITY                      0x5016A
#define HIDC_ASYNC_OFRAMING                     0x5016B
#define HIDC_ASYNC_OOVERRUN                     0x5016C
#define HIDC_ASYNC_OOVERFLOW                    0x5016D
#define HIDC_ASYNC_OPARITY                      0x5016E
#define HIDC_NETWORK_LANADAPTER                 0x50173
#define HIDC_PREFERENCES_PROC_MANUAL            0x503EF
#define HIDC_PREFERENCES_PROC_EVERY             0x503F0
#define HIDC_PREFERENCES_PROC_SECONDS           0x503F1
#define HIDC_PREFERENCES_STATUS_MANUAL          0x503F3
#define HIDC_PREFERENCES_STATUS_EVERY           0x503F4
#define HIDC_PREFERENCES_STATUS_SECONDS         0x503F5
#define HIDC_PREFERENCES_CONFIRM                0x503F7
#define HIDC_PREFERENCES_SAVE                   0x503F8
#define HIDC_PREFERENCES_REMEMBER                       0X50443

#define HIDD_SERVER_WINSTATIONS                 0x20084
#define HIDD_SERVER_PROCESSES                   0x20085
#define HIDD_SERVER_USERS                       0x20086
#define HIDD_SERVER_LICENSES                    0x20087
#define HIDD_WINSTATION_INFO                    0x20099
#define HIDD_WINSTATION_PROCESSES               0x2009A
#define HIDD_PREFERENCES                        0x2009C
#define HIDD_SERVER_INFO                        0x2009D
#define HIDD_MESSAGE                            0x200FA
#define HIDD_ASYNC_STATUS                       0x2015E
#define HIDD_NETWORK_STATUS                     0x20172
#define HIDD_CONNECT_PASSWORD                   0x201B8
#define HIDD_ALL_SERVER_PROCESSES               0x201BA
#define HIDD_ALL_SERVER_USERS                   0x201BB
#define HIDD_ALL_SERVER_SESSIONS                0x201BC
#define HIDD_BAD_SERVER                         0x201BE
#define HIDD_LISTENER                           0x201BF
#define HIDD_WINSTATION_NOINFO                  0x201C0
#define HIDD_BUSY_SERVER                        0x201C1
#define HIDD_WINSTATION_CACHE                   0x201C2
#define HIDD_BAD_WINSTATION                     0x201C3

//==========================================================================================




//Global variable for help

static const DWORD aMenuHelpIDs[] =
{
    IDC_MESSAGE_TITLE, HIDC_MESSAGE_TITLE,
        IDC_MESSAGE_MESSAGE,HIDC_MESSAGE_MESSAGE,
        IDC_SHADOWSTART_HOTKEY,HIDC_SHADOWSTART_HOTKEY,
        IDC_SHADOWSTART_SHIFT ,HIDC_SHADOWSTART_SHIFT,
        IDC_SHADOWSTART_CTRL ,HIDC_SHADOWSTART_CTRL,
    IDC_SHADOWSTART_ALT ,HIDC_SHADOWSTART_ALT,
        IDC_COMMON_USERNAME ,HIDC_COMMON_USERNAME,
    IDC_COMMON_WINSTATIONNAME  ,HIDC_COMMON_WINSTATIONNAME,
    IDC_COMMON_IBYTES,HIDC_COMMON_IBYTES,
        IDC_COMMON_OBYTES  ,HIDC_COMMON_OBYTES,
    IDC_COMMON_IFRAMES ,HIDC_COMMON_IFRAMES,
    IDC_COMMON_OFRAMES ,HIDC_COMMON_OFRAMES,
    IDC_COMMON_IBYTESPERFRAME ,HIDC_COMMON_IBYTESPERFRAME,
        IDC_COMMON_OBYTESPERFRAME ,HIDC_COMMON_OBYTESPERFRAME,
    IDC_COMMON_IFRAMEERRORS  ,HIDC_COMMON_IFRAMEERRORS,
        IDC_COMMON_OFRAMEERRORS ,HIDC_COMMON_OFRAMEERRORS,
    IDC_COMMON_IPERCENTFRAMEERRORS ,HIDC_COMMON_IPERCENTFRAMEERRORS,
    IDC_COMMON_OPERCENTFRAMEERRORS ,HIDC_COMMON_OPERCENTFRAMEERRORS,
        IDC_COMMON_ITIMEOUTERRORS ,HIDC_COMMON_ITIMEOUTERRORS,
    IDC_COMMON_OTIMEOUTERRORS,HIDC_COMMON_OTIMEOUTERRORS,
    IDC_COMMON_ICOMPRESSIONRATIO ,HIDC_COMMON_ICOMPRESSIONRATIO,
    IDC_COMMON_OCOMPRESSIONRATIO ,HIDC_COMMON_OCOMPRESSIONRATIO,
    IDC_REFRESHNOW ,HIDC_REFRESHNOW,
    IDC_RESETCOUNTERS,HIDC_RESETCOUNTERS,
    IDC_MOREINFO,HIDC_MOREINFO,
    IDC_ASYNC_DEVICE,  HIDC_ASYNC_DEVICE ,
    IDC_ASYNC_BAUD  ,HIDC_ASYNC_BAUD  ,
    IDC_ASYNC_DTR ,  HIDC_ASYNC_DTR ,
    IDC_ASYNC_RTS  , HIDC_ASYNC_RTS  ,
    IDC_ASYNC_CTS  ,  HIDC_ASYNC_CTS  ,
    IDC_ASYNC_DSR ,  HIDC_ASYNC_DSR    ,
    IDC_ASYNC_DCD  , HIDC_ASYNC_DCD     ,
    IDC_ASYNC_RI  ,  HIDC_ASYNC_RI       ,
    IDC_ASYNC_IFRAMING ,  HIDC_ASYNC_IFRAMING  ,
    IDC_ASYNC_IOVERRUN , HIDC_ASYNC_IOVERRUN    ,
    IDC_ASYNC_IOVERFLOW ,    HIDC_ASYNC_IOVERFLOW,
    IDC_ASYNC_IPARITY  , HIDC_ASYNC_IPARITY       ,
    IDC_ASYNC_OFRAMING ,   HIDC_ASYNC_OFRAMING     ,
    IDC_ASYNC_OOVERRUN ,   HIDC_ASYNC_OOVERRUN      ,
    IDC_ASYNC_OOVERFLOW ,  HIDC_ASYNC_OOVERFLOW      ,
    IDC_ASYNC_OPARITY    ,  HIDC_ASYNC_OPARITY        ,
    IDC_NETWORK_LANADAPTER,     HIDC_NETWORK_LANADAPTER,
    IDC_PREFERENCES_PROC_MANUAL ,HIDC_PREFERENCES_PROC_MANUAL ,
    IDC_PREFERENCES_PROC_EVERY   , HIDC_PREFERENCES_PROC_EVERY ,
    IDC_PREFERENCES_PROC_SECONDS  , HIDC_PREFERENCES_PROC_SECONDS,
    IDC_PREFERENCES_STATUS_MANUAL  ,  HIDC_PREFERENCES_STATUS_MANUAL,
    IDC_PREFERENCES_STATUS_EVERY    , HIDC_PREFERENCES_STATUS_EVERY,
    IDC_PREFERENCES_STATUS_SECONDS   ,  HIDC_PREFERENCES_STATUS_SECONDS ,
    IDC_PREFERENCES_STATUS_SECONDS    ,HIDC_PREFERENCES_STATUS_SECONDS   ,
    IDC_PREFERENCES_CONFIRM     ,HIDC_PREFERENCES_CONFIRM           ,
        IDD_WINSTATION_NOINFO,HIDD_WINSTATION_NOINFO,
        IDC_PREFERENCES_SAVE , HIDC_PREFERENCES_SAVE,
        IDC_PREFERENCES_PERSISTENT ,HIDC_PREFERENCES_REMEMBER,
};

/////////////////////////////////////////////////////////////////////////////
#endif // _WINADMIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\winspgs.h ===
/*******************************************************************************
*
* winspgs.h
*
* - declarations for the WinStation info pages
* - the server info pages are all CFormView derivatives
*   based on dialog templates
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\winspgs.h  $
*  
*     Rev 1.4   16 Feb 1998 16:03:40   donm
*  modifications to support pICAsso extension
*  
*     Rev 1.3   03 Nov 1997 15:18:38   donm
*  Added descending sort
*  
*     Rev 1.2   13 Oct 1997 18:39:08   donm
*  update
*  
*     Rev 1.1   26 Aug 1997 19:15:54   donm
*  bug fixes/changes from WinFrame 1.7
*  
*     Rev 1.0   30 Jul 1997 17:13:42   butchd
*  Initial revision.
*  
*******************************************************************************/

#ifndef _WINSTATIONPAGES_H
#define _WINSTATIONPAGES_H

#include "Resource.h"
#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "winadmin.h"

//////////////////////////
// CLASS: CWinStationInfoPage
//
class CWinStationInfoPage : public CAdminPage
{
friend class CWinStationView;

protected:
	CWinStationInfoPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWinStationInfoPage)

// Form Data
public:
	//{{AFX_DATA(CWinStationInfoPage)
	enum { IDD = IDD_WINSTATION_INFO };
	//}}AFX_DATA

// Attributes
public:

protected:

private:
	CWinStation* m_pWinStation;	// pointer to current WinStation's info

// Operations
public:

private:
	void DisplayInfo();			
	virtual void Reset(void *pWinStation);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinStationInfoPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CWinStationInfoPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CWinStationInfoPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnCommandHelp(void);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CWinStationInfoPage


//////////////////////////
// CLASS: CWinStationModulesPage
//
class CWinStationModulesPage : public CAdminPage
{
friend class CWinStationView;

protected:
	CWinStationModulesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWinStationModulesPage)

// Form Data
public:
	//{{AFX_DATA(CWinStationModulesPage)
	enum { IDD = IDD_WINSTATION_MODULES };
	CListCtrl	m_ModuleList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_imageList;	// image list associated with the tree control

	int m_idxBlank;		// index of Blank image
	int m_idxArrow;		// index of Arrow image

private:
	CWinStation* m_pWinStation;	// pointer to current WinStation's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	ExtModuleInfo *m_pExtModuleInfo;

// Operations
public:

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayModules();			
	virtual void Reset(void *pWinStation);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinStationModulesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CWinStationModulesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CWinStationModulesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusModuleList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CWinStationModulesPage


//////////////////////////
// CLASS: CWinStationNoInfoPage
//
class CWinStationNoInfoPage : public CAdminPage
{
friend class CWinStationView;

protected:
	CWinStationNoInfoPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWinStationNoInfoPage)

// Form Data
public:
	//{{AFX_DATA(CWinStationInfoPage)
	enum { IDD = IDD_WINSTATION_NOINFO };
	//}}AFX_DATA

// Attributes
public:

protected:

private:
	
// Operations
public:

private:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinStationInfoPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CWinStationNoInfoPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CWinStationNoInfoPage)
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnSetFocus( CWnd * );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CWinStationNoInfoPage


//////////////////////////
// CLASS: CWinStationProcessesPage
//
class CWinStationProcessesPage : public CAdminPage
{
friend class CWinStationView;

protected:
	CWinStationProcessesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWinStationProcessesPage)

// Form Data
public:
	//{{AFX_DATA(CWinStationProcessesPage)
	enum { IDD = IDD_WINSTATION_PROCESSES };
	CListCtrl	m_ProcessList;
	//}}AFX_DATA

// Attributes
public:

protected:

private:
	CWinStation* m_pWinStation;	// pointer to current WinStation's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;

// Operations
public:
	void UpdateProcesses();
	void RemoveProcess(CProcess *pProcess);

private:
	void DisplayProcesses();			
	virtual void Reset(void *pWinStation);
	int AddProcessToList(CProcess *pProcess);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinStationProcessesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CWinStationProcessesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CWinStationProcessesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusWinstationProcessList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillFocusWinstationProcessList( NMHDR* pNMHDR, LRESULT* pResult );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CWinStationProcessesPage


//////////////////////////
// CLASS: CWinStationCachePage
//
class CWinStationCachePage : public CAdminPage
{
friend class CWinStationView;

protected:
	CWinStationCachePage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWinStationCachePage)

// Form Data
public:
	//{{AFX_DATA(CWinStationCachePage)
	enum { IDD = IDD_WINSTATION_CACHE };
	//}}AFX_DATA

// Attributes
public:

protected:

private:
	CWinStation* m_pWinStation;	// pointer to current WinStation's info

// Operations
public:

private:
	void DisplayCache();			
	virtual void Reset(void *pWinStation);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinStationCachePage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CWinStationCachePage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CWinStationCachePage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnCommandHelp(void);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CWinStationCachePage

#endif  // _SERVERPAGES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\winsvw.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* winsvw.cpp
*
* implementation of the CWinStationView class
*
*  
*******************************************************************************/

#include "stdafx.h"
#include "resource.h"
#include "winsvw.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////
// MESSAGE MAP: CWinStationView
//
IMPLEMENT_DYNCREATE(CWinStationView, CView)

BEGIN_MESSAGE_MAP(CWinStationView, CView)
	//{{AFX_MSG_MAP(CWinStationView)
	ON_WM_SIZE()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_ADMIN_UPDATE_PROCESSES, OnAdminUpdateProcesses)
	ON_MESSAGE(WM_ADMIN_REMOVE_PROCESS, OnAdminRemoveProcess)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_PROCESSES, OnAdminRedisplayProcesses)
	ON_NOTIFY(TCN_SELCHANGE, IDC_WINSTATION_TABS, OnTabSelChange)
    ON_MESSAGE( WM_ADMIN_TABBED_VIEW , OnTabbed )
    ON_MESSAGE( WM_ADMIN_SHIFTTABBED_VIEW , OnShiftTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLTABBED_VIEW , OnCtrlTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLSHIFTTABBED_VIEW , OnCtrlShiftTabbed )
    ON_MESSAGE( WM_ADMIN_NEXTPANE_VIEW , OnNextPane )

END_MESSAGE_MAP()


PageDef CWinStationView::pages[NUMBER_OF_WINS_PAGES] = {
	{ NULL, RUNTIME_CLASS( CWinStationProcessesPage ),	IDS_TAB_PROCESSES,	PAGE_WS_PROCESSES,	NULL },
	{ NULL, RUNTIME_CLASS( CWinStationInfoPage ),		IDS_TAB_INFORMATION,PAGE_WS_INFO,		NULL },
	{ NULL, RUNTIME_CLASS( CWinStationModulesPage ),	IDS_TAB_MODULES,	PAGE_WS_MODULES,	PF_PICASSO_ONLY },
	{ NULL, RUNTIME_CLASS( CWinStationCachePage ),		IDS_TAB_CACHE,		PAGE_WS_CACHE,		PF_PICASSO_ONLY },
	{ NULL, RUNTIME_CLASS( CWinStationNoInfoPage ),		0,					PAGE_WS_NO_INFO,	PF_NO_TAB },
};


///////////////////////
// F'N: CWinStationView ctor
//
CWinStationView::CWinStationView()
{
	m_pTabs       = NULL;
	m_pTabFont    = NULL;

	m_CurrPage = PAGE_WS_PROCESSES;

}  // end CWinStationView ctor


///////////////////////
// F'N: CWinStationView dtor
//
CWinStationView::~CWinStationView()
{
	if(m_pTabs)    delete m_pTabs;
	if(m_pTabFont) delete m_pTabFont;

}  // end CWinStationView dtor


#ifdef _DEBUG
///////////////////////////////
// F'N: CWinStationView::AssertValid
//
void CWinStationView::AssertValid() const
{
	CView::AssertValid();

}  // end CWinStationView::AssertValid


////////////////////////
// F'N: CWinStationView::Dump
//
void CWinStationView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CWinStationView::Dump

#endif //_DEBUG


////////////////////////////
// F'N: CWinStationView::OnCreate
//
int CWinStationView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;

}  // end CWinStationView::OnCreate


///////////////////////////////////
// F'N: CWinStationView::OnInitialUpdate
//
// - pointers to the pages of the sheet are obtained
//
void CWinStationView::OnInitialUpdate() 
{
	// create the tab control
	m_pTabs = new CMyTabCtrl;
    if(!m_pTabs) return;
	m_pTabs->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, CRect(0,0,0,0), this, IDC_WINSTATION_TABS);

	m_pTabFont = new CFont;
    if(m_pTabFont) {
	    m_pTabFont->CreateStockObject(DEFAULT_GUI_FONT);
	    m_pTabs->SetFont(m_pTabFont, TRUE);
    }

	TCHAR szTemp[40];
	CString tabString;
	int index = 0;
	for(int i = 0; i < NUMBER_OF_WINS_PAGES; i++) {
		// If the page is shown under Picasso only and we're not running
		// under Picasso, skip to the next one
		if((pages[i].flags & PF_PICASSO_ONLY) && !((CWinAdminApp*)AfxGetApp())->IsPicasso()) continue;
		if(!(pages[i].flags & PF_NO_TAB)) {
			tabString.LoadString(pages[i].tabStringID);
			wcscpy(szTemp,tabString);
			AddTab(index, szTemp, i);
			index++;
		}
		pages[i].m_pPage = (CAdminPage*)pages[i].m_pRuntimeClass->CreateObject();
		pages[i].m_pPage->Create(NULL, NULL, WS_CHILD, CRect(0, 0, 0, 0), this, i, NULL);
		GetDocument()->AddView(pages[i].m_pPage);		
	}

	m_pTabs->SetCurSel(0);

	m_CurrPage = PAGE_WS_PROCESSES;
	((CWinAdminDoc*)GetDocument())->SetCurrentPage(PAGE_WS_PROCESSES);
	
	OnChangePage(NULL, NULL);
	
}  // end CWinStationView::OnInitialUpdate


//////////////////////////
// F'N: CWinStationView::OnSize
//
// - size the pages to fill the entire view
//
void CWinStationView::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;

	GetClientRect(&rect);
	if(m_pTabs->GetSafeHwnd())  {			// make sure the tabs object is valid
		m_pTabs->MoveWindow(&rect, TRUE);	// size the tabs

		// for the next part (sizing of pages), we might want to add a member var
		// that keeps track of which page/tab is current... this way we could
		// only actually do a redraw (MoveWindow second parm == TRUE) for the
		// guy who is currently visible--DJM
	
		// we want to size the pages, too
		m_pTabs->AdjustRect(FALSE, &rect);

      for(int i = 0; i < NUMBER_OF_WINS_PAGES; i++) {
         if(pages[i].m_pPage && pages[i].m_pPage->GetSafeHwnd())
            pages[i].m_pPage->MoveWindow(&rect, TRUE);
      }
	}
}  // end CWinStationView::OnSize


//////////////////////////
// F'N: CWinStationView::OnDraw
//
// - the CWinStationView and it's pages draw themselves, so there isn't anything
//   to do here...
//
void CWinStationView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here

}  // end CWinStationView::OnDraw


/////////////////////////
// F'N: CWinStationView::Reset
//
// - 'resets' the view by taking a pointer to a CWinStation object and filling in 
//   the various property pages with info appropriate to that WinStation
//
void CWinStationView::Reset(void *pWinStation)
{
	if(!((CWinStation*)pWinStation)->AdditionalDone()) ((CWinStation*)pWinStation)->QueryAdditionalInformation();

	for(int i = 0; i < NUMBER_OF_WINS_PAGES; i++) {
		if(pages[i].m_pPage)
			pages[i].m_pPage->Reset((CWinStation*)pWinStation);
	}

	if(((CWinAdminApp*)AfxGetApp())->IsPicasso()) {
		
		if((((CWinStation*)pWinStation)->GetState() == State_Disconnected
			|| !((CWinStation*)pWinStation)->GetExtendedInfo()) 
			&& !((CWinStation*)pWinStation)->IsSystemConsole()) {
			// Delete the 'Cache' tab
			m_pTabs->DeleteItem(3);
			// Delete the 'Modules' tab
			m_pTabs->DeleteItem(2);
			// If the 'Cache' tab was current, make the 'Processes' tab current
			if(m_pTabs->GetCurSel() == 0xFFFFFFFF) {
				m_pTabs->SetCurSel(0);
				OnChangePage(0,0);
			}
		} else if(m_pTabs->GetItemCount() == 2) {
			TCHAR szTemp[40];
			CString tabString;
			tabString.LoadString(IDS_TAB_MODULES);
			wcscpy(szTemp,tabString);
			AddTab(2, szTemp, 2);
			tabString.LoadString(IDS_TAB_CACHE);
			wcscpy(szTemp,tabString);
			AddTab(3, szTemp, 3);
		}
	}

	((CWinAdminDoc*)GetDocument())->SetCurrentPage(m_CurrPage);
	// We want to fake a ChangePage if we are on page 1 or page 2
	if(m_pTabs->GetCurSel() > 0)
		OnChangePage(0,0);

}  // end CWinStationView::Reset


//////////////////////////
// F'N: CWinStationView::AddTab
//
void CWinStationView::AddTab(int index, TCHAR* text, ULONG pageindex)
{
	TC_ITEM tc;
	tc.mask = TCIF_TEXT | TCIF_PARAM;
	tc.pszText = text;
	tc.lParam = pageindex;

	m_pTabs->InsertItem(index, &tc);

}  // end CWinStationView::AddTab


////////////////////////////////
// F'N: CWinStationView::OnChangePage
//
// - changes to a new WinStation page based on currently selected tab
// - OnChangePage needs to force recalculation of scroll bars!!!--DJM
//
LRESULT CWinStationView::OnChangePage(WPARAM wParam, LPARAM lParam)
{
	// find out which tab is now selected
	int index = m_pTabs->GetCurSel();
	int newpage = index;

	CWinStation *pWinStation = 
		(CWinStation*)((CWinAdminDoc*)GetDocument())->GetCurrentSelectedNode();

	if(index != PAGE_WS_PROCESSES && pWinStation->IsSystemConsole()) {
		newpage = PAGE_WS_NO_INFO;
	}

	// hide the current page
	pages[m_CurrPage].m_pPage->ModifyStyle(WS_VISIBLE, WS_DISABLED);	 

	m_CurrPage = newpage;

    if( pages[ newpage ].flags != PF_NO_TAB )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        pDoc->RegisterLastFocus( TAB_CTRL );
    }

	((CWinAdminDoc*)GetDocument())->SetCurrentPage(newpage);
	// show the new page
	pages[newpage].m_pPage->ModifyStyle(WS_DISABLED, WS_VISIBLE);
	pages[newpage].m_pPage->ScrollToPosition(CPoint(0,0));
    
	pages[newpage].m_pPage->Invalidate();
//    pages[newpage].m_pPage->SetFocus();
	

	return 0;

}  // end CWinStationView::OnChangeview


//////////////////////////
// F'N: CWinStationView::OnTabSelChange
//
void CWinStationView::OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnChangePage( 0, 0);
	*pResult = 0;

}  // end CWinStationView::OnTabSelChange


//////////////////////////
// F'N: CWinStationView::OnAdminUpdateProcesses
//
LRESULT CWinStationView::OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam)
{
   ((CWinStationProcessesPage*)pages[PAGE_WS_PROCESSES].m_pPage)->UpdateProcesses();	

	return 0;

}  // end CWinStationView::OnAdminUpdateProcesses


//////////////////////////
// F'N: CWinStationView::OnAdminRemoveProcess
//
LRESULT CWinStationView::OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam)
{
   ((CWinStationProcessesPage*)pages[PAGE_WS_PROCESSES].m_pPage)->RemoveProcess((CProcess*)lParam);

	return 0;

}  // end CWinStationView::OnAdminRemoveProcess


//////////////////////////
// F'N: CWinStationView::OnAdminRedisplayProcesses
//
LRESULT CWinStationView::OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam)
{
	((CWinStationProcessesPage*)pages[PAGE_WS_PROCESSES].m_pPage)->DisplayProcesses();	

	return 0;

}  // end CWinStationView::OnAdminRedisplayProcesses



LRESULT CWinStationView::OnTabbed( WPARAM wp , LPARAM lp )
{
    ODS( L"CWinStationView::OnTabbed " );
    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );
            
            
            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );

                int nTab = m_pTabs->GetCurSel();
                
                m_pTabs->SetFocus( );

                m_pTabs->SetCurFocus( nTab );
                
                if( pages[ m_CurrPage ].flags == PF_NO_TAB )
                {
                    pDoc->RegisterLastFocus( PAGED_ITEM );
                }
                else
                {
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
            }
            else if( nFocus == TAB_CTRL )
            {
                ODS( L"from tab to item\n" );
                
                // set focus to item in page

                if( pages[ m_CurrPage ].flags == PF_NO_TAB )
                {
                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );                    
                }
                else
                {
                    pages[ m_CurrPage ].m_pPage->SetFocus( );

                    pDoc->RegisterLastFocus( PAGED_ITEM );
                }
            }
            else
            {
                ODS( L"from item to treeview\n" );

                // set focus back to treeview

                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );
            }

            pDoc->SetPrevFocus( nFocus );
        }


    }

    return 0;
}

//=-------------------------------------------------------------------------
// OnShiftTabbed is called when the user wants to go back one 
// this code is duplicated in all view classes
LRESULT CWinStationView::OnShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CWinStationView::OnShiftTabbed " );

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            switch( nFocus )
            {
            case TREE_VIEW:                

                if( pages[ m_CurrPage].flags == PF_NO_TAB )
                {
                    ODS( L"going back from tree to noinfo tab\n" );

                    int nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                else
                {
                    ODS( L"going back from tree to paged item\n" );
                    pages[ m_CurrPage ].m_pPage->SetFocus( );

                    pDoc->RegisterLastFocus( PAGED_ITEM );
                }

                break;
            case TAB_CTRL:
                {
                    ODS( L"going back from tab to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );
                }
                break;
            case PAGED_ITEM:
                {
                    ODS( L"going back from paged item to tab\n" );

                    int nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                break;
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}

//=-------------------------------------------------------------------------
// ctrl + tab works the same as tab but because of our unorthodox ui
// when under a tab control it will cycle over the tabs and back to the treeview
//
LRESULT CWinStationView::OnCtrlTabbed( WPARAM , LPARAM )
{
    ODS( L"CWinStationView::OnCtrlTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );

                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    m_pTabs->SetCurSel( 0 );
                    
                    OnChangePage( 0 , 0 );

                    nTab = 0;
                }

                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nTab );
                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                else
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab + 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab + 1 );

                }
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}


//=----------------------------------------------------------------------------
// same as OnCtrlTab but we focus on moving in the other direction
// tree_view to last tab -- current tab to ct - 1
//
LRESULT CWinStationView::OnCtrlShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CWinStationView::OnCtrlShiftTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );
                
                nMaxTab = m_pTabs->GetItemCount( );
                
                m_pTabs->SetCurSel( nMaxTab - 1 );
                
                OnChangePage( 0 , 0 );
                
                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nMaxTab - 1 );                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab > 0 )
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab - 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab - 1 );
                }
                else
                {

                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}

//=----------------------------------------------------------------------------
// When the user hits F6 we need to switch between pains
LRESULT CWinStationView::OnNextPane( WPARAM , LPARAM )
{
    ODS( L"CWinStationView::OnNextPane\n" );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            FOCUS_STATE nPrevFocus = pDoc->GetPrevFocus( );

            if( nFocus == TREE_VIEW )
            {
                if( nPrevFocus == TAB_CTRL )
                {
                    int nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );
                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                else
                {
                    pages[ m_CurrPage ].m_pPage->SetFocus( );
                    
                    pDoc->RegisterLastFocus( PAGED_ITEM );
                }
            }
            else
            {
                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );

            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tsadmin\winsvw.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* winsvw.h
*
* declarations for the CWinStationView class
*
*  
*******************************************************************************/

#ifndef _WINSTATIONVIEW_H
#define _WINSTATIONVIEW_H

#include "winspgs.h"

const int NUMBER_OF_WINS_PAGES = 5;


////////////////////
// CLASS: CWinStationView
//
class CWinStationView : public CAdminView
{
friend class CRightPane;

private:
	CTabCtrl*	m_pTabs;
	CFont*      m_pTabFont;

	int m_CurrPage;

protected:
	CWinStationView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWinStationView)

// Attributes
public:

protected:
   static PageDef pages[NUMBER_OF_WINS_PAGES];

// Operations
protected:
	virtual void Reset(void *pWinStation);

	void AddTab(int index, TCHAR* text, ULONG pageindex);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinStationView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CWinStationView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    
	// Generated message map functions
protected:
	//{{AFX_MSG(CWinStationView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT OnChangePage(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg void OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LRESULT OnTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnNextPane( WPARAM , LPARAM );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CWinStationView

#endif  // _WINSTATIONVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\appsvdoc.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* appsvdoc.h
*
* interface of the CWinStationListObjectHint and CAppServerDoc classes
*
* copyright notice: Copyright 1994, Citrix Systems Inc.
*
* $Author:   donm  $  Butch Davis
*
* $Log:   N:\nt\private\utils\citrix\winutils\tscfg\VCS\appsvdoc.h  $
*  
*     Rev 1.20   14 Feb 1998 11:23:22   donm
*  fixed memory leak by avoiding CDocManager::OpenDocumentFile
*  
*     Rev 1.19   10 Dec 1997 15:59:16   donm
*  added ability to have extension DLLs
*  
*     Rev 1.18   25 Mar 1997 08:59:50   butchd
*  update
*  
*     Rev 1.17   10 Mar 1997 16:58:30   butchd
*  update
*  
*     Rev 1.16   24 Sep 1996 16:21:22   butchd
*  update
*
*******************************************************************************/


////////////////////////////////////////////////////////////////////////////////
// CWinStationListObjectHint class
//
class CWinStationListObjectHint : public CObject
{
    DECLARE_DYNAMIC(CWinStationListObjectHint)

/*
 * Member variables.
 */
public:
    int m_WSLIndex;
    PWSLOBJECT m_pWSLObject;

/*
 * Implementation.
 */
public:
    CWinStationListObjectHint();

};  // end CWinStationListObjectHint class interface
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// CAppServerDoc class
//
class CAppServerDoc : public CDocument  
{
    DECLARE_SERIAL(CAppServerDoc)

/*
 * Member variables.
 */
public:
    BOOL m_bAdmin;
protected:
    BOOL m_bReadOnly;
    CObList m_WinStationList;
    PSECURITY_DESCRIPTOR m_pSecurityDescriptor;

/*
 * Implementation
 */
protected:
    CAppServerDoc();
    virtual ~CAppServerDoc();

/*
 * Overrides of MFC CDocument class
 */
protected:
    BOOL OnNewDocument();
    void SetTitle( LPCTSTR lpszTitle );

/*
 * Operations
 */
public:
    BOOL IsExitAllowed();
    BOOL IsAddAllowed(int nIndex);
    BOOL IsCopyAllowed(int nIndex);
    BOOL IsRenameAllowed(int nIndex);
    BOOL IsEditAllowed(int nIndex);
    BOOL IsDeleteAllowed(int nIndex);
    BOOL IsEnableAllowed( int nIndex, BOOL bEnable );
    int GetWSLCount();
    PWSLOBJECT GetWSLObject(int nIndex);
    int GetWSLIndex(PWINSTATIONNAME pWSName);
    PWSLOBJECT GetWSLObjectNetworkMatch( PDNAME PdName,
                                         WDNAME WdName,
                                         ULONG LanAdapter );
    BOOL IsAsyncDeviceAvailable( LPCTSTR pDeviceName,
                                 PWINSTATIONNAME pWSName );
    BOOL IsOemTdDeviceAvailable( LPCTSTR pDeviceName,
                                 PPDNAME pPdName,
                                 PWINSTATIONNAME pWSName );
    BOOL IsWSNameUnique( PWINSTATIONNAME pWinStationName );
    int AddWinStation(int WSLIndex);
    int CopyWinStation(int WSLIndex);
    int RenameWinStation(int WSLIndex);
    int EditWinStation(int WSLIndex);
    BOOL DeleteWinStation(int WSLIndex);
    void EnableWinStation( int WSLIndex, BOOL bEnable );
    void SecurityPermissions(int WSLIndex);
protected:
    BOOL LoadWSL(LPCTSTR pszAppServer);
    BOOL RefreshWSLObjectState( int nIndex, PWSLOBJECT pWSLObject );
    void DeleteWSLContents();
    int InsertInWSL( PWINSTATIONNAME pWSName,
                     PWINSTATIONCONFIG2 pWSConfig,
					 void *pExtObject,
                     PWSLOBJECT * ppObject );
    void RemoveFromWSL(int nIndex);
    void UpdateAllViewsWithItem( CView* pSourceView, UINT nItemIndex,
                                 PWSLOBJECT pWSLObject );
    void InUseMessage(PWINSTATIONNAME pWSName);
    BOOL HasWSConfigChanged( PWINSTATIONCONFIG2 pOriginalWSConfig,
                             PWINSTATIONCONFIG2 pNewWSConfig,
							 void *pOldExtObject,
							 void *pNewExtObject,
							 PWDNAME pWdName);
    BOOL HasPDConfigChanged( PWINSTATIONCONFIG2 pOriginalWSConfig,
                             PWINSTATIONCONFIG2 pNewWSConfig );
	BOOL HasExtensionObjectChanged( PWDNAME pWdName,
									void *pOldExtObject,
									void *pNewExtObject);
    void DeleteExtensionObject( void *, PWDNAME pWdName);
    LONG RegistryQuery( PWINSTATIONNAME pWinStationName,
                        PWINSTATIONCONFIG2 pWsConfig, PWDNAME pWdName,
                        void **pExtObject);
    LONG RegistryCreate(PWINSTATIONNAME pWinStationName, BOOLEAN bCreate,
                        PWINSTATIONCONFIG2 pWsConfig, PWDNAME pWdName,
                        void *pExtObject);
    LONG RegistryDelete(PWINSTATIONNAME pWinStationName, PWDNAME pWdName,
                        void *pExtObject);

/*
 * Message map / commands.
 */
protected:
    //{{AFX_MSG(CAppServerDoc)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  // end CAppServerDoc class interface
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\anasidlg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* anasidlg.cpp
*
* implementation of CAdvancedNASIDlg dialog class
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\ANASIDLG.CPP  $
*  
*     Rev 1.2   29 Nov 1995 13:59:40   butchd
*  update
*  
*     Rev 1.1   16 Nov 1995 17:11:30   butchd
*  update
*  
*     Rev 1.0   09 Jul 1995 15:11:08   butchd
*  Initial revision.
*  
*******************************************************************************/

/*
 * include files
 */
#include "stdafx.h"
#include "wincfg.h"
#include "anasidlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

////////////////////////////////////////////////////////////////////////////////
// CAdvancedNASIDlg class construction / destruction, implementation

/*******************************************************************************
 *
 *  CAdvancedNASIDlg - CAdvancedNASIDlg constructor
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CDialog::CDialog documentation)
 *
 ******************************************************************************/

CAdvancedNASIDlg::CAdvancedNASIDlg()
    : CBaseDialog(CAdvancedNASIDlg::IDD)
{
    //{{AFX_DATA_INIT(CAdvancedNASIDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

}  // end CAdvancedNASIDlg::CAdvancedNASIDlg


////////////////////////////////////////////////////////////////////////////////
// CAdvancedNASIDlg operations

/*******************************************************************************
 *
 *  SetFields - CAdvancedNASIDlg member function: private operation
 *
 *      Set the dialog fields.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedNASIDlg::SetFields()
{
    /*
     * Set the session type radio button.
     */
    CheckRadioButton( IDC_NASI_ADVANCED_PRIVATESESSION,
                      IDC_NASI_ADVANCED_GLOBALSESSION,
                      IDC_NASI_ADVANCED_PRIVATESESSION +
                        (m_NASIConfig.GlobalSession ? 1 : 0) );

    /*
     * Set the File Server and Session Name fields.
     */
    SetDlgItemText( IDC_NASI_ADVANCED_FILESERVER,
                    m_NASIConfig.FileServer );
    SetDlgItemText( IDC_NASI_ADVANCED_SESSIONNAME,
                    m_NASIConfig.SessionName );


}  // end CAdvancedNASIDlg::SetFields


/*******************************************************************************
 *
 *  GetFields - CAdvancedNASIDlg member function: private operation
 *
 *      Fetch and validate the dialog fields.
 *
 *  ENTRY:
 *  EXIT:
 *      (BOOL)
 *          Returns TRUE if all fields were valid; FALSE otherwise.  If FALSE,
 *          will have output an error message and set the focus back to the
 *          field in error for the user to correct.
 *
 ******************************************************************************/

BOOL
CAdvancedNASIDlg::GetFields()
{
    m_NASIConfig.GlobalSession = 
        (BOOLEAN)( IDC_NASI_ADVANCED_PRIVATESESSION -
                   GetCheckedRadioButton( IDC_NASI_ADVANCED_PRIVATESESSION,
                                          IDC_NASI_ADVANCED_GLOBALSESSION ) );

    GetDlgItemText( IDC_NASI_ADVANCED_FILESERVER,
                    m_NASIConfig.FileServer, lengthof(m_NASIConfig.FileServer) );

    GetDlgItemText( IDC_NASI_ADVANCED_SESSIONNAME,
                    m_NASIConfig.SessionName, lengthof(m_NASIConfig.SessionName) );

    /*
     * If no Session Name has been entered, output error message and
     * reset focus to field for correction.
     */
    if ( !*m_NASIConfig.SessionName ) {

        ERROR_MESSAGE((IDP_INVALID_NASI_SESSIONNAME_EMPTY))

        GotoDlgCtrl(GetDlgItem(IDC_NASI_ADVANCED_SESSIONNAME));
        return(FALSE);
    }

    return(TRUE);

}  // end CAdvancedNASIDlg::GetFields


////////////////////////////////////////////////////////////////////////////////
// CAdvancedNASIDlg message map

BEGIN_MESSAGE_MAP(CAdvancedNASIDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CAdvancedNASIDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


////////////////////////////////////////////////////////////////////////////////
// CAdvancedNASIDlg commands

/*******************************************************************************
 *
 *  OnInitDialog - CAdvancedNASIDlg member function: command (override)
 *
 *      Performs the dialog intialization.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnInitDialog documentation)
 *
 ******************************************************************************/

BOOL
CAdvancedNASIDlg::OnInitDialog()
{
    int i;

    /*
     * Call the parent classes' OnInitDialog to perform default dialog
     * initialization.
     */    
    CBaseDialog::OnInitDialog();

    /*
     * Initalize all dialog fields.
     */
    SetFields();

    if ( m_bReadOnly ) {

        /*                          
         * Document is 'read-only': disable all dialog controls and labels
         * except for CANCEL & HELP buttons.
         */
        for ( i=IDL_NASI_ADVANCED_SESSIONTYPE;
              i <=IDC_NASI_ADVANCED_SESSIONNAME; i++ )
            GetDlgItem(i)->EnableWindow(FALSE);
        GetDlgItem(IDOK)->EnableWindow(FALSE);
    }

    /*
     * Limit edit text.
     */
    ((CEdit *)GetDlgItem(IDC_NASI_ADVANCED_FILESERVER))->
        LimitText(NASIFILESERVER_LENGTH);
    ((CEdit *)GetDlgItem(IDC_NASI_ADVANCED_SESSIONNAME))->
        LimitText(NASISESSIONNAME_LENGTH);

    return(TRUE);

}  // end CAdvancedNASIDlg::OnInitDialog


/*******************************************************************************
 *
 *  OnOK - CAdvancedNASIDlg member function: command (override)
 *
 *      Read all control contents back into the Async config structure
 *      before closing the dialog.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnOk documentation)
 *
 ******************************************************************************/

void
CAdvancedNASIDlg::OnOK()
{
    /*
     * Fetch the field contents.  Return (don't close dialog) if a problem
     * was found.
     */
    if ( !GetFields() )
        return;

    /*
     * Call the parent classes' OnOk to complete dialog closing
     * and destruction.
     */
    CBaseDialog::OnOK();

}  // end CAdvancedNASIDlg::OnOK
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\appsvdoc.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* appsvdoc.cpp
*
* implementation of the CAppServerDoc class
*
* copyright notice: Copyright 1994, Citrix Systems Inc.
*
* $Author:   donm  $  Butch Davis
*
* $Log:   N:\nt\private\utils\citrix\winutils\tscfg\VCS\appsvdoc.cpp  $
*  
*     Rev 1.54   18 Apr 1998 15:31:08   donm
*  Added capability bits
*  
*     Rev 1.53   14 Feb 1998 11:23:04   donm
*  fixed memory leak by avoiding CDocManager::OpenDocumentFile
*  
*     Rev 1.52   31 Dec 1997 09:13:50   donm
*  uninitialized variable in RegistryDelete
*  
*     Rev 1.51   10 Dec 1997 15:59:14   donm
*  added ability to have extension DLLs
*  
*     Rev 1.50   19 Jun 1997 19:21:08   kurtp
*  update
*  
*     Rev 1.49   25 Mar 1997 08:59:46   butchd
*  update
*  
*     Rev 1.48   18 Mar 1997 15:51:18   butchd
*  ignore system console registry entry
*  
*     Rev 1.47   10 Mar 1997 16:58:26   butchd
*  update
*  
*     Rev 1.46   04 Mar 1997 09:46:46   butchd
*  update
*  
*     Rev 1.45   04 Mar 1997 08:35:12   butchd
*  update
*  
*     Rev 1.44   28 Feb 1997 17:59:22   butchd
*  update
*  
*     Rev 1.43   11 Dec 1996 09:50:18   butchd
*  update
*  
*     Rev 1.42   24 Sep 1996 16:21:18   butchd
*  update
*
*******************************************************************************/

/*
 * include files
 */
#include "stdafx.h"
#include "wincfg.h"

#include "security.h"
#include "appsvdoc.h"
#include "rowview.h"
#include "appsvvw.h"
#include "ewsdlg.h"
#include <string.h>
#include <hydra\regapi.h>      // for WIN_ENABLEWINSTATION registry entry name

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CWincfgApp *pApp;
extern "C" LPCTSTR WinUtilsAppName;
extern "C" HWND WinUtilsAppWindow;
extern "C" HINSTANCE WinUtilsAppInstance;

PTERMLOBJECT GetWdListObject( PWDNAME pWdName);

/*
 * Global command line variables.
 */


////////////////////////////////////////////////////////////////////////////////
// CWinStationListObjectHint implemetation / construction

IMPLEMENT_DYNAMIC(CWinStationListObjectHint, CObject)

CWinStationListObjectHint::CWinStationListObjectHint()
{
}


////////////////////////////////////////////////////////////////////////////////
// CAppServerDoc implementation / construction, destruction

IMPLEMENT_SERIAL(CAppServerDoc, CDocument, 0 /*schema*/)

/*******************************************************************************
 *
 *  CAppServerDoc - CAppServerDoc constructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CAppServerDoc::CAppServerDoc()
    : m_bReadOnly(FALSE),
      m_pSecurityDescriptor(NULL)
{
}  // end CAppServerDoc::CAppServerDoc


/*******************************************************************************
 *
 *  ~CAppServerDoc - CAppServerDoc destructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CAppServerDoc::~CAppServerDoc()
{
    /*
     * Free up all WSL objects currently in use.
     */
    DeleteWSLContents();

}  // end CAppServerDoc::~CAppServerDoc


////////////////////////////////////////////////////////////////////////////////
// CAppServerDoc class overrides

/*******************************************************************************
 *
 *  OnOpenDocument - CAppServerDoc member function: CDocument class override
 *
 *      Reads the specified AppServer's registry and initializes the
 *      'document' contents.
 *
 *  ENTRY:
 *      pszPathName (input)
 *          Name of the AppServer to access.
 *
 *  EXIT:
 *      TRUE - sucessful initialization of 'document'.
 *      FALSE - 'document' was not properly initialized.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::OnNewDocument( /*LPCTSTR pszPathName*/ )
{
    POSITION pos;

    /*
     * If this user doesn't have ALL access to the WinStation registry (ie, not
     * an admin), set the 'admin' flag to FALSE and 'read only' flag to TRUE
     * to only display the user's current WinStation in the WinStation list;
     * otherwise set 'admin' flag to TRUE to allow all WinStations to be
     * displayed, with the 'read only' state being determined from the previous
     * AppServer check, above.
     */
    if ( RegWinStationAccessCheck(SERVERNAME_CURRENT, KEY_ALL_ACCESS) ) {

        m_bAdmin = FALSE;
        m_bReadOnly = TRUE;

    } else {

        m_bAdmin = TRUE;
    }

    /*
     * Obtain the user's current WinStation information.
     */
    if ( !QueryCurrentWinStation( pApp->m_CurrentWinStation,
                                  pApp->m_CurrentUserName,
                                  &(pApp->m_CurrentLogonId),
                                  &(pApp->m_CurrentWSFlags) ) ) {

        STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_CURRENT, GetLastError(),
                                 IDP_ERROR_QUERYCURRENTWINSTATION ))
        return(FALSE);
    }

    /* 
     * Load the WSL with registry information for this AppServer.
     */
    if ( !LoadWSL(NULL/*pszPathName*/) )
        return(FALSE);

    /*
     * Reset the view for this document.
     */
    ((CAppServerView *)GetNextView( pos = GetFirstViewPosition() ))->
                                                        ResetView( TRUE );

    return ( TRUE );

}  // end CAppServerDoc::OnOpenDocument


/*******************************************************************************
 *
 *  SetTitle - CAppServerDoc member function: override
 *
 *      Override default to set our title the way that we want.
 *
 *  ENTRY:
 *      lpszTitle (input)
 *          Title to set (this is ignored).
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerDoc::SetTitle( LPCTSTR lpszTitle )
{
    /*
     * Set our document's title, including the READONLY (User Mode)
     * string if needed.
     */
    if ( m_bReadOnly ) {
        CString ReadOnly;
        ReadOnly.LoadString( IDS_READONLY );
        CString sz = pApp->m_szCurrentAppServer + ReadOnly;
        CDocument::SetTitle(sz);

    } else
        CDocument::SetTitle(pApp->m_szCurrentAppServer);

}  // end CAppServerDoc::SetTitle


////////////////////////////////////////////////////////////////////////////////
// CAppServerDoc public operations

/*******************************************************************************
 *
 *  IsExitAllowed - CAppServerDoc member function: public operation
 *
 *      Indicate whether or not the application can be exited, based on whether
 *      or not there are operations pending.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      TRUE - no operations are pending: the application can be exited.
 *      FALSE - operations are pending: the application cannot be exited.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::IsExitAllowed()
{
    return (TRUE);

}  // end CAppServerDoc::IsExitAllowed


/*******************************************************************************
 *
 *  IsAddAllowed - CAppServerDoc member function: public operation
 *
 *      Indicate whether or not the WSLObject associated with the specified
 *      list index can be referenced for adding a new WinStation.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL) TRUE if the WSLObject can be referenced for add; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::IsAddAllowed( int nIndex )
{
    /* 
     * If this document is 'read only' then add is not allowed.
     * Otherwise, it's OK.
     */
    if ( m_bReadOnly )
        return(FALSE);
    else
        return(TRUE);

}  // end CAppServerDoc::IsAddAllowed


/*******************************************************************************
 *
 *  IsCopyAllowed - CAppServerDoc member function: public operation
 *
 *      Indicate whether or not the WSLObject associated with the specified
 *      list index can be copied.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL) TRUE if the WSLObject can be copied; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::IsCopyAllowed( int nIndex )
{
    PWSLOBJECT pWSLObject;

    /* 
     * If this document is 'read only' or no items yet,
     * then copy is not allowed.
     */
    if ( m_bReadOnly ||
         !(pWSLObject = GetWSLObject(nIndex)) )
        return(FALSE);

    /*
     * If this WinStation is the main CONSOLE, or is not a single instance
     * type, we can't copy.
     */
    if ( !lstrcmpi(pWSLObject->m_WinStationName, pApp->m_szSystemConsole) ||
         !(pWSLObject->m_Flags & WSL_SINGLE_INST) )
        return(FALSE);

    /*
     * The copy is allowed.
     */
    return(TRUE);

}  // end CAppServerDoc::IsCopyAllowed


/*******************************************************************************
 *
 *  IsRenameAllowed - CAppServerDoc member function: public operation
 *
 *      Indicate whether or not the WSLObject associated with the specified
 *      list index can be renamed.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL) TRUE if the WSLObject can be renamed; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::IsRenameAllowed( int nIndex )
{
    PWSLOBJECT pWSLObject;

    /* 
     * If this document is 'read only' or no items yet,
     * then rename is not allowed.
     */
    if ( m_bReadOnly ||
         !(pWSLObject = GetWSLObject(nIndex)) )
        return(FALSE);

    /*
     * If this WinStation is the main CONSOLE, we can't rename.
     */
    if ( !lstrcmpi( pWSLObject->m_WinStationName, pApp->m_szSystemConsole ) )
        return(FALSE);

    /*
     * The rename is allowed.
     */
    return(TRUE);

}  // end CAppServerDoc::IsRenameAllowed


/*******************************************************************************
 *
 *  IsDeleteAllowed - CAppServerDoc member function: public operation
 *
 *      Indicate whether or not the WSLObject associated with the specified
 *      list index can be deleted.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL) TRUE if the WSLObject can be deleted; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::IsDeleteAllowed( int nIndex )
{
    PWSLOBJECT pWSLObject;

    /* 
     * If this document is 'read only' or no items yet,
     * then delete is not allowed.
     */
    if ( m_bReadOnly ||
         !(pWSLObject = GetWSLObject(nIndex)) )
        return(FALSE);

    /*
     * If this WinStation is the main CONSOLE, we can't delete.
     */
    if ( !lstrcmpi( pWSLObject->m_WinStationName, pApp->m_szSystemConsole ) )
        return(FALSE);

    /*
     * The delete is allowed.
     */
    return(TRUE);

}  // end CAppServerDoc::IsDeleteAllowed


/*******************************************************************************
 *
 *  IsEditAllowed - CAppServerDoc member function: public operation
 *
 *      Indicate whether or not the WSLObject associated with the specified
 *      list index can be edited.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL) TRUE if the WSLObject can be edited; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::IsEditAllowed( int nIndex )
{
    /* 
     * If no items yet, then edit is not allowed.
     * Otherwise, it's OK.
     */
    if ( !GetWSLObject(nIndex) )
        return(FALSE);
    else
        return(TRUE);

}  // end CAppServerDoc::IsEditAllowed


/*******************************************************************************
 *
 *  IsEnableAllowed - CAppServerDoc member function: public operation
 *
 *      Indicate whether or not the WinStation(s) associated with the specified
 *      WSLObject can be enabled/disabled.
 *
 *  ENTRY:
 *      bEnable (input)
 *          TRUE: check for enable allowed; FALSE: check for disable allowed.
 *  EXIT:
 *      (BOOL) TRUE if the WinStation(s) can be enabled/disabled;
 *              FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::IsEnableAllowed( int nIndex,
                                BOOL bEnable )
{
    PWSLOBJECT pWSLObject;

    /* 
     * If this document is 'read only' no items yet,
     * then enable/disable is not allowed.
     */
    if ( m_bReadOnly ||
         !(pWSLObject = GetWSLObject(nIndex)) )
        return(FALSE);

    /*
     * If this WinStation is the main CONSOLE, we can't enable/disable.
     */
    if ( !lstrcmpi( pWSLObject->m_WinStationName, pApp->m_szSystemConsole ) )
        return(FALSE);

    /*
     * Make sure that the WSL is 'in sync' with the registry.  Return
     * 'enable/disable not allowed' if error.
     */
    if ( !RefreshWSLObjectState( nIndex, pWSLObject ) )
        return(FALSE);

    /*
     * If this WSLObject indicates that the WinStation(s) are already enabled
     * and enable allow is requested, or WSLObject indicates that the
     * WinStation(s) are already disabled and disable allow is requested,
     * return FALSE (can't enable/disable).
     */
    if ( (bEnable && (pWSLObject->m_Flags & WSL_ENABLED)) ||
         (!bEnable && !(pWSLObject->m_Flags & WSL_ENABLED)) )
        return(FALSE);

    /*
     * The enable/disable is allowed.
     */
    return(TRUE);

}  // end CAppServerDoc::IsEnableAllowed


/*******************************************************************************
 *
 *  GetWSLCount - CAppServerDoc member function: public operation
 *
 *      Return the number of WinStationList elements defined in this document.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (int) number of WinStationsList elements present in this document.
 *
 ******************************************************************************/

int
CAppServerDoc::GetWSLCount()
{
    return( m_WinStationList.GetCount() );

}  // end CAppServerDoc::GetWSLCount


/*******************************************************************************
 *
 *  GetWSLObject - CAppServerDoc member function: public operation
 *
 *      Retrieves the WinStation object from the WinStationObjectList that
 *      resides at the specified index.
 *
 *  ENTRY:
 *      nIndex (input)
 *          WinStationObjectList index of the WinStation to retrieve.
 *
 *  EXIT:
 *      PWLSOBJECT - pointer to WinStationListObject for the indexed
 *                      WinStation.  NULL if list is empty.
 *
 ******************************************************************************/

PWSLOBJECT
CAppServerDoc::GetWSLObject( int nIndex )
{
    if ( !GetWSLCount() )
        return(NULL);
    else
        return ( (PWSLOBJECT)m_WinStationList.GetAt( 
                     m_WinStationList.FindIndex( nIndex )) );

}  // end CAppServerDoc::GetWSLObject


/*******************************************************************************
 *
 *  GetWSLIndex - CAppServerDoc member function: public operation
 *
 *      Retrieves the WinStation List index of WinStation list object that
 *      matches the specified WSName.
 *
 *  ENTRY:
 *      pWSName (input)
 *          Points to WINSTATIONNAME to compare with list objects.
 *
 *  EXIT:
 *      int - Index of the specified WSL object in the list.
 *      -1 if an object containing the specified WSName was not found.
 *
 ******************************************************************************/

int
CAppServerDoc::GetWSLIndex( PWINSTATIONNAME pWSName )
{
    POSITION pos;
    int nIndex = 0;

    /*
     * Traverse the WinStationList.
     */
    for ( pos = m_WinStationList.GetHeadPosition(); pos != NULL; nIndex++ ) {

        PWSLOBJECT pObject = (PWSLOBJECT)m_WinStationList.GetNext(pos);

        /*
         * If this is the specified WSL object, return the current index.
         */
        if ( !lstrcmpi(pObject->m_WinStationName, pWSName) )
            return(nIndex);
    }
    
    /*
     * WSLObject not found in the list.
     */
    return(-1);

}  // end CAppServerDoc::GetWSLIndex


/*******************************************************************************
 *
 *  GetWSLObjectNetworkMatch - CAppServerDoc member function: public operation
 *
 *      Retrieves the WinStation list object (if any) from the WinStationList
 *      that contains the specified PdName, WdName, and LanAdapter.
 *
 *  ENTRY:
 *      PdName (input)
 *          PdName to compare.
 *      WdName (input)
 *          WdName to compare.
 *      LanAdapter (input)
 *          LanAdapter # to compare.
 *  EXIT:
 *      PWLSOBJECT - pointer to WinStationList object if the PdName, WdName,
 *                  and LanAdapter all matched an existing WSL entry.
 *                  NULL if no match was found.
 *
 ******************************************************************************/

PWSLOBJECT
CAppServerDoc::GetWSLObjectNetworkMatch( PDNAME PdName,
                                         WDNAME WdName,
                                         ULONG LanAdapter )
{
    POSITION pos;

    /*
     * Traverse the WinStationList.
     */
    for ( pos = m_WinStationList.GetHeadPosition(); pos != NULL; ) {

        PWSLOBJECT pObject = (PWSLOBJECT)m_WinStationList.GetNext(pos);

        /*
         * If PdName, WdName, and LanAdapter fields match, return this
         * PWSLOBJECT.
         */
        if ( !lstrcmp( pObject->m_PdName, PdName ) &&
             !lstrcmp( pObject->m_WdName, WdName ) &&
             (pObject->m_LanAdapter == LanAdapter) )
            return(pObject);                
    }
    
    /*
     * No match found.
     */
    return(NULL);

}  // end CAppServerDoc::GetWSLObjectNetworkMatch


/*******************************************************************************
 *
 *  IsAsyncDeviceAvailable - CAppServerDoc member function: public operation
 *
 *      Determines if the specified Async device is available for use in
 *      configuring a new WinStation.  Availability in this context is
 *      determined by whether or not the device is already configured for
 *      use in an Async WinStation.
 *
 *  ENTRY:
 *      pDeviceName (input)
 *          Points to the Async device name (NOT decorated) to check for
 *          availablility.
 *      pWSName (input)
 *          Points to WINSTATIONNAME of current WinStation being edited.
 *
 *  EXIT:
 *      TRUE if the Async device is available for use; FALSE if another
 *      WinStation is already configured to use it.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::IsAsyncDeviceAvailable( LPCTSTR pDeviceName,
                                       PWINSTATIONNAME pWSName )
{
    POSITION pos;
    ASYNCCONFIG AsyncConfig;

    /*
     * Traverse the WinStationList.
     */
    for ( pos = m_WinStationList.GetHeadPosition(); pos != NULL; ) {

        PWSLOBJECT pObject = (PWSLOBJECT)m_WinStationList.GetNext(pos);

        /*
         * If this is an async WinStation, the device is the same as the
         * one we're checking, but this is not the current WinStation being
         * edited, return FALSE.
         */
        if ( pObject->m_SdClass == SdAsync ) {

            ParseDecoratedAsyncDeviceName( pObject->m_DeviceName, &AsyncConfig );

            if ( !lstrcmpi(AsyncConfig.DeviceName, pDeviceName) &&
                 lstrcmpi(pWSName, pObject->m_WinStationName) )
                return(FALSE);
        }
    }
    
    /*
     * The Async device is not configured in any Async WinStations.
     */
    return(TRUE);

}  // end CAppServerDoc::IsAsyncDeviceAvailable


/*******************************************************************************
 *
 *  IsOemTdDeviceAvailable - CAppServerDoc member function: public operation
 *
 *      Determines if the specified OEM Transport device is available for use
 *      in configuring a new WinStation.  Availability in this context is
 *      determined by whether or not the device is already configured for
 *      use in a WinStation for the Oem Td.
 *
 *  ENTRY:
 *      pDeviceName (input)
 *          Points to device name to check against other WinStations of
 *          the specified OEM Transport.
 *      pPdName (input)
 *          Points to PDNAME of the OEM Transport.
 *      pWSName (input)
 *          Points to WINSTATIONNAME of current WinStation being edited.
 *
 *  EXIT:
 *      TRUE if the OEM Transport device is available for use; FALSE if another
 *      WinStation of the specified OEM Transport is already configured to
 *      use it.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::IsOemTdDeviceAvailable( LPCTSTR pDeviceName,
                                       PPDNAME pPdName,
                                       PWINSTATIONNAME pWSName )
{
    POSITION pos;

    /*
     * Traverse the WinStationList.
     */
    for ( pos = m_WinStationList.GetHeadPosition(); pos != NULL; ) {

        PWSLOBJECT pObject = (PWSLOBJECT)m_WinStationList.GetNext(pos);

        /*
         * If this is a OEM Transport WinStation of the specified OEM Transport,
         * the device is the same as the one we're checking, but this is not the
         * current WinStation being edited, return FALSE.
         */
        if ( (pObject->m_SdClass == SdOemTransport) &&
             !lstrcmpi(pObject->m_PdName, pPdName) &&
             !lstrcmpi(pObject->m_DeviceName, pDeviceName) &&
             lstrcmpi(pWSName, pObject->m_WinStationName) ) {

                return(FALSE);
        }
    }
    
    /*
     * The OEM Transport device is not configured in any current WinStations
     * of the same OEM Transport.
     */
    return(TRUE);

}  // end CAppServerDoc::IsOemTdDeviceAvailable


/*******************************************************************************
 *
 *  IsWSNameUnique - CAppServerDoc member function: public operation
 *
 *      Determine if the entered WinStation name is unique.
 *
 *  ENTRY:
 *      pWinStationName (input)
 *          Points to WINSTATIONNAME to check for uniqueness.
 *
 *  EXIT:
 *      TRUE if the specified WinStation name is unique; FALSE if not.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::IsWSNameUnique( PWINSTATIONNAME pWinStationName )
{
    POSITION pos;
    WINSTATIONNAME WSRoot;
    PWINSTATIONNAME pWSRoot;

    /*
     * Traverse the WinStationList.
     */
    for ( pos = m_WinStationList.GetHeadPosition(); pos != NULL; ) {

        PWSLOBJECT pObject = (PWSLOBJECT)m_WinStationList.GetNext(pos);

        /*
         * Make sure that we only compare the 'root' names.
         */
        lstrcpy(WSRoot, pObject->m_WinStationName);
        pWSRoot = lstrtok(WSRoot, TEXT("#"));

        /*
         * If the roots match, return FALSE.
         */
        if ( !lstrcmpi(pWinStationName, pWSRoot) )
            return(FALSE);
    }
    
    /*
     * WinStation name is unique.
     */
    return(TRUE);

}  // end CAppServerDoc::IsWSNameUnique()


/*******************************************************************************
 *
 *  AddWinStation - CAppServerDoc member function: public operation
 *
 *      Add a new WinStation.
 *
 *  ENTRY:
 *      WSLIndex (input)
 *          WSL index of the currently selected WinStation, to provide some
 *          defaults for the new WinStation.
 *  EXIT:
 *      (int) WSL index of the added WinStation's list item; -1 if error.
 *
 ******************************************************************************/

int
CAppServerDoc::AddWinStation(int WSLIndex)
{
    LONG Status;
    int nIndex = -1;
    CEditWinStationDlg EWSDlg(this);
    WINSTATIONNAME WSName;
    PWSLOBJECT pWSLObject;
    LPCTSTR pszFailedCall = NULL;

    /*
     * Zero out the WinStation name and config structure.
     */
    memset(WSName, 0, sizeof(WSName));
    memset(&EWSDlg.m_WSConfig, 0, sizeof(WINSTATIONCONFIG2));

    /*
     * Get current WinStation object to anticipate defaults for the new
     * WinStation and assure that the WSL is 'in sync' with the registry.
     */
    if ( !RefreshWSLObjectState( WSLIndex,
                                 pWSLObject = GetWSLObject(WSLIndex)) )
        goto BadRefreshWSLObjectState;

    /*
     * Set the config structure's Pd name field to allow Edit
     * dialog to form default config structure contents.
     */
    EWSDlg.m_WSConfig.Create.fEnableWinStation = 1;
    if ( pWSLObject ) {
        EWSDlg.m_WSConfig.Pd[0].Create.SdClass = pWSLObject->m_SdClass;
        lstrcpy( EWSDlg.m_WSConfig.Pd[0].Create.PdName, pWSLObject->m_PdName );
    }

    /*
     * Initialize the additional dialog member variables.
     */
    EWSDlg.m_pWSName = WSName;
    EWSDlg.m_DlgMode = EWSDlgAdd;
	EWSDlg.m_pExtObject = NULL;

    /*
     * Invoke the dialog.
     */
    if ( EWSDlg.DoModal() == IDOK ) {

        CWaitCursor wait;

        /*
         * Add a new WSLObject to the WSL.
         */
        if ( (nIndex =
              InsertInWSL( WSName, &EWSDlg.m_WSConfig, EWSDlg.m_pExtObject, &pWSLObject )) == -1 )
            goto BadInsertInWSL;

        /*
         * Fetch the default WinStation security descriptor.
         */
        if ( (Status = GetDefaultWinStationSecurity(&m_pSecurityDescriptor))
                                            != ERROR_SUCCESS ) {

            pszFailedCall = pApp->m_pszGetDefaultWinStationSecurity;
            goto BadGetDefaultWinStationSecurity;
        }

        /*
         * Create the registry entry.
         */
		if((Status = RegistryCreate(WSName, 
									TRUE,
									&EWSDlg.m_WSConfig,
									pWSLObject->m_WdName,
									pWSLObject->m_pExtObject))) {

            pszFailedCall = pApp->m_pszRegWinStationCreate;
            goto BadRegCreate;
        }    

        /*
         * Set the WinStation security in registry.
         */
        if ( m_pSecurityDescriptor &&
             (Status = RegWinStationSetSecurity(
                            SERVERNAME_CURRENT, 
                            WSName,
                            m_pSecurityDescriptor,
                            GetSecurityDescriptorLength(m_pSecurityDescriptor) )) ) {

            pszFailedCall = pApp->m_pszRegWinStationSetSecurity;
            goto BadRegSetSecurity;
        }

        /*
         * If we're not 'registry only', tell Session Manager
         * to re-read registry.
         */
#ifdef WINSTA
        if ( !pApp->m_nRegistryOnly ) {

            _WinStationReadRegistry(SERVERNAME_CURRENT);

            /*
             * If this is a modem winstation and it's enabled,
             * issue the 'must reboot' message and flag the
             * winstation as 'must reboot'.
             */
            if ( *EWSDlg.m_WSConfig.Pd[0].Params.Async.ModemName &&
                 EWSDlg.m_WSConfig.Create.fEnableWinStation ) {

                QuestionMessage( MB_OK | MB_ICONEXCLAMATION,
                                 IDP_NOTICE_REBOOTFORMODEM_ADD, WSName );
                pWSLObject->m_Flags |= WSL_MUST_REBOOT;
            }
        }
#endif // WINSTA

        /*
         * A new WSLObject was added: update the entire view.
         */
        UpdateAllViews(NULL, 0, NULL);

        /*
         * Return the new WSLObject's index.
         */
        return(nIndex);

    } else {
        
        /*
         * User canceled the Add; just return the previously given index.
         */
		DeleteExtensionObject(EWSDlg.m_pExtObject, EWSDlg.m_WSConfig.Wd.WdName);
        return(WSLIndex);
    }

/*==============================================================================
 * Error returns
 *============================================================================*/
BadRegSetSecurity:
    RegWinStationDelete( SERVERNAME_CURRENT, WSName );
BadRegCreate:
BadGetDefaultWinStationSecurity:
BadInsertInWSL:
BadRefreshWSLObjectState:
    if ( nIndex != -1 )
        RemoveFromWSL(nIndex);

    if ( pszFailedCall ) {

        STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, Status,
                                 IDP_ERROR_ADDWINSTATION, WSName,
                                 pszFailedCall ))
    }
    return(-1);

}  // end CAppServerDoc::AddWinStation


/*******************************************************************************
 *
 *  CopyWinStation - CAppServerDoc member function: public operation
 *
 *      Copy a given WinStation into a new one.
 *
 *  ENTRY:
 *      WSLIndex (input)
 *          WSL index of the currently selected WinStation, to provide most
 *          defaults for the new WinStation.
 *  EXIT:
 *      (int) WSL index of the added WinStation's list item; -1 if error.
 *
 ******************************************************************************/

int
CAppServerDoc::CopyWinStation(int WSLIndex)
{
    LONG Status;
    ULONG Length;
    int nIndex = -1;
    PWSLOBJECT pWSLObject;
    WINSTATIONNAME WSName;
    WINSTATIONNAME OriginalWSName;
    CEditWinStationDlg EWSDlg(this);
    LPCTSTR pszFailedCall = NULL;
    
    /*
     * Get current WinStation object to obtain defaults for the new
     * WinStation and assure that the WSL is 'in sync' with the registry.
     */
    if ( !RefreshWSLObjectState( WSLIndex,
                                 pWSLObject = GetWSLObject(WSLIndex)) )
        goto BadRefreshWSLObjectState;

    lstrcpy( WSName, pWSLObject->m_WinStationName );

    /*
     * Get the WinStation's config structure and initialize the WSName
     * array.
     */

	if((Status = RegistryQuery(	pWSLObject->m_WinStationName, 
								&EWSDlg.m_WSConfig, 
								pWSLObject->m_WdName, 
								&EWSDlg.m_pExtObject))) {

        pszFailedCall = pApp->m_pszRegWinStationQuery;
        goto BadRegWinStationQuery;
    }
    lstrcpy( OriginalWSName, pWSLObject->m_WinStationName );

    /*
     * If this is an Async WinStation class, null the DeviceName field, since
     * the device used by an Async WinStation must be unique.
     */
    if ( pWSLObject->m_SdClass == SdAsync )
        *(EWSDlg.m_WSConfig.Pd[0].Params.Async.DeviceName) = TEXT('\0');

    /*
     * Initialize dialog variables and invoke the Edit WinStation dialog
     * in it's 'copy' mode.
     */
    EWSDlg.m_pWSName = WSName;
    EWSDlg.m_DlgMode = EWSDlgCopy;

    /*
     * Invoke the dialog.
     */
    if ( EWSDlg.DoModal() == IDOK ) {

        CWaitCursor wait;

        /*
         * Add a new WSLObject to the WSL.
         */
        if ( (nIndex =
              InsertInWSL( WSName, &EWSDlg.m_WSConfig, EWSDlg.m_pExtObject, &pWSLObject )) == -1 )
            goto BadInsertInWSL;

        /*
         * Fetch the original WinStation's security descriptor.
         */
        if ( (Status = GetWinStationSecurity( OriginalWSName,
                                              &m_pSecurityDescriptor))
                                                != ERROR_SUCCESS ) {

            pszFailedCall = pApp->m_pszGetWinStationSecurity;
            goto BadGetWinStationSecurity;
        }

        /*
         * Create the registry entry.
         */
		 if((Status = RegistryCreate(	WSName,
                                   	   	TRUE,
                                        &EWSDlg.m_WSConfig,
										EWSDlg.m_WSConfig.Wd.WdName,
										EWSDlg.m_pExtObject)) ) {

            pszFailedCall = pApp->m_pszRegWinStationCreate;
            goto BadRegCreate;
        }

        /*
         * Set the WinStation security in registry.
         */
        if ( m_pSecurityDescriptor &&
             (Status = RegWinStationSetSecurity( 
                                SERVERNAME_CURRENT, 
                                WSName,
                                m_pSecurityDescriptor,
                                GetSecurityDescriptorLength(m_pSecurityDescriptor) )) ) {

            pszFailedCall = pApp->m_pszRegWinStationSetSecurity;
            goto BadRegSetSecurity;
        }

        /*
         * If we're not 'registry only', tell Session Manager
         * to re-read registry.
         */
#ifdef WINSTA
        if ( !pApp->m_nRegistryOnly ) {

            _WinStationReadRegistry(SERVERNAME_CURRENT);

            /*
             * If this is a modem winstation and it's enabled,
             * issue the 'must reboot' message and flag the
             * winstation as 'must reboot'.
             */
            if ( *EWSDlg.m_WSConfig.Pd[0].Params.Async.ModemName &&
                 EWSDlg.m_WSConfig.Create.fEnableWinStation ) {

                QuestionMessage( MB_OK | MB_ICONEXCLAMATION,
                                 IDP_NOTICE_REBOOTFORMODEM_ADD, WSName );
                pWSLObject->m_Flags |= WSL_MUST_REBOOT;
            }
        }
#endif // WINSTA

        /*
         * A new WSLObject was added: update the entire view.
         */
        UpdateAllViews(NULL, 0, NULL);

        /*
         * Return the new WSLObject's index.
         */
        return(nIndex);

    } else {
        
        /*
         * User canceled the Copy; just return the previously given index.
         */
		DeleteExtensionObject(EWSDlg.m_pExtObject, EWSDlg.m_WSConfig.Wd.WdName);

        return(WSLIndex);
    }

/*==============================================================================
 * Error returns
 *============================================================================*/
BadRegSetSecurity:
    RegWinStationDelete( SERVERNAME_CURRENT, WSName );
BadRegCreate:
BadGetWinStationSecurity:
BadInsertInWSL:
BadRegWinStationQuery:
BadRefreshWSLObjectState:
    if ( nIndex != -1 )
        RemoveFromWSL(nIndex);

    if ( pszFailedCall ) {

        STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, Status,
                                 IDP_ERROR_COPYWINSTATION, WSName,
                                 pszFailedCall ))
    }
    return(-1);

}  // end CAppServerDoc::CopyWinStation


/*******************************************************************************
 *
 *  RenameWinStation - CAppServerDoc member function: public operation
 *
 *      Rename a WinStation.
 *
 *  ENTRY:
 *      WSLIndex (input)
 *          WSL index of the WinStation to rename.
 *  EXIT:
 *      (int) WSL index of the renamed WinStation's list item; -1 if error.
 *
 ******************************************************************************/

int
CAppServerDoc::RenameWinStation(int WSLIndex)
{
    LONG Status;
    ULONG Length;
    int nIndex = -1;
    CEditWinStationDlg EWSDlg(this);
    PWSLOBJECT pOldWSLObject, pNewWSLObject;
    WINSTATIONNAME OldWSName, NewWSName;
    LPCTSTR pszFailedCall = NULL;
	void *pExtObject = NULL;

    /*
     * Get current WinStation object and assure that the WSL is 'in sync'
     * with the registry.
     */
    if ( !RefreshWSLObjectState( WSLIndex,
                                 pOldWSLObject = GetWSLObject(WSLIndex)) )
        goto BadRefreshWSLObjectState;

    lstrcpy(OldWSName, pOldWSLObject->m_WinStationName);

    /*
     * Fetch the WinStation's configuration structure.
     */
	if((Status = RegistryQuery(	pOldWSLObject->m_WinStationName, 
								&EWSDlg.m_WSConfig, 
								pOldWSLObject->m_WdName, 
								&pExtObject))) {

        pszFailedCall = pApp->m_pszRegWinStationQuery;
        goto BadRegWinStationQuery;
    }
    lstrcpy(NewWSName, pOldWSLObject->m_WinStationName);

	/*
	 * copy the pExtObject into the one for the EWSDlg
	 */
	if(pExtObject) {
		PTERMLOBJECT pObject = GetWdListObject(pOldWSLObject->m_WdName);

		if(pObject && pObject->m_hExtensionDLL && pObject->m_lpfnExtDupObject) {
		 	EWSDlg.m_pExtObject = (*pObject->m_lpfnExtDupObject)(pExtObject);
		}
	} else {
		EWSDlg.m_pExtObject = NULL;
	}

    /*
     * Initialize the dialog's member variables.
     */
    EWSDlg.m_pWSName = NewWSName;
    EWSDlg.m_DlgMode = EWSDlgRename;

    /*
     * Invoke the dialog.
     */
    if ( EWSDlg.DoModal() == IDOK ) {

        CWaitCursor wait;

        /*
         * Add a new WSLObject to the WSL.
         */
        if ( (nIndex =
              InsertInWSL(NewWSName, &EWSDlg.m_WSConfig, EWSDlg.m_pExtObject, &pNewWSLObject)) == -1 )
            goto BadInsertInWSL;

        /*
         * Fetch the original WinStation's security descriptor.
         */
        if ( (Status = GetWinStationSecurity( OldWSName,
                                              &m_pSecurityDescriptor))
                                                != ERROR_SUCCESS ) {

            pszFailedCall = pApp->m_pszGetWinStationSecurity;
            goto BadGetWinStationSecurity;
        }

        /*
         * Create the new registry entry.
         */
		 if((Status = RegistryCreate(	NewWSName,
										TRUE,
										&EWSDlg.m_WSConfig,
										EWSDlg.m_WSConfig.Wd.WdName,
										EWSDlg.m_pExtObject))) {

            pszFailedCall = pApp->m_pszRegWinStationCreate;
            goto BadRegCreate;
        }

        /*
         * Set the WinStation security in registry.
         */
        if ( m_pSecurityDescriptor &&
             (Status = RegWinStationSetSecurity(
                                SERVERNAME_CURRENT, 
                                NewWSName,
                                m_pSecurityDescriptor,
                                GetSecurityDescriptorLength(m_pSecurityDescriptor) )) ) {

            pszFailedCall = pApp->m_pszRegWinStationSetSecurity;
            goto BadRegSetSecurity;
        }

        /*
         * Delete the old registry entry.
         */
        if ( (Status = RegistryDelete(OldWSName, EWSDlg.m_WSConfig.Wd.WdName, pExtObject)) ) {

            pszFailedCall = pApp->m_pszRegWinStationDelete;
            goto BadRegDelete;
        }

        /*
         * Remove old WSLObject from the WSL and recalculate the
         * new WSLObject's index (may have changed).
         */
        RemoveFromWSL( GetWSLIndex(OldWSName) );
        nIndex = GetWSLIndex(NewWSName);

        /*
         * If we're not 'registry only', tell Session Manager
         * to re-read registry and output 'in use' message if
         * necessary.
         */
#ifdef WINSTA
        if ( !pApp->m_nRegistryOnly ) {

            _WinStationReadRegistry(SERVERNAME_CURRENT);

            /*
             * Issue appropriate messages if the winstation being renamed
             * was enabled.
             */
            if ( EWSDlg.m_WSConfig.Create.fEnableWinStation ) {

                if ( *EWSDlg.m_WSConfig.Pd[0].Params.Async.ModemName ) {

                    QuestionMessage( MB_OK | MB_ICONEXCLAMATION,
                                     IDP_NOTICE_REBOOTFORMODEM_RENAME,
                                     OldWSName, NewWSName );
                    pNewWSLObject->m_Flags |= WSL_MUST_REBOOT;

                } else {

                    InUseMessage(OldWSName);
                }
            }
        }
#endif // WINSTA

        /*
         * A new WSLObject was added: update the entire view.
         */
        UpdateAllViews(NULL, 0, NULL);

        /*
         * Return the new WSLObject's index.
         */
        return(nIndex);

    } else {
        
        /*
         * User canceled the Rename; just return the previously given index.
         */
		DeleteExtensionObject(pExtObject, EWSDlg.m_WSConfig.Wd.WdName);
		DeleteExtensionObject(EWSDlg.m_pExtObject, EWSDlg.m_WSConfig.Wd.WdName);
        return(WSLIndex);
    }

/*==============================================================================
 * Error returns
 *============================================================================*/
BadRegDelete:
BadRegSetSecurity:
    RegWinStationDelete( SERVERNAME_CURRENT, NewWSName );
BadRegCreate:
BadGetWinStationSecurity:
BadInsertInWSL:
BadRegWinStationQuery:
BadRefreshWSLObjectState:
    if ( nIndex != -1 )
        RemoveFromWSL(nIndex);

    if ( pszFailedCall ) {

        STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, Status,
                                 IDP_ERROR_RENAMEWINSTATION, OldWSName,
                                 pszFailedCall ))
    }
    return(-1);

}  // end CAppServerDoc::RenameWinStation


/*******************************************************************************
 *
 *  EditWinStation - CAppServerDoc member function: public operation
 *
 *      Edit a WinStation.
 *
 *  ENTRY:
 *      WSLIndex (input)
 *          WSL index of the WinStation to edit.
 *  EXIT:
 *      (int) WSL index of the edited WinStation's list item; -1 if error.
 *
 ******************************************************************************/

int
CAppServerDoc::EditWinStation(int WSLIndex)
{
    LONG Status;
    ULONG Length;
    int nIndex = -1;
    BOOL bQueueOperationSuccess = TRUE, bAllowAbort = TRUE;
    CEditWinStationDlg EWSDlg(this);
    PWSLOBJECT pWSLObject;
    WINSTATIONCONFIG2 WSConfig;
    LPCTSTR pszFailedCall = NULL;
    WINSTATIONNAME WSName;
	void *pExtObject = NULL;

    /*
     * Get current WinStation object and assure that the WSL is 'in sync'
     * with the registry.
     */
    if ( !RefreshWSLObjectState( WSLIndex,
                                 pWSLObject = GetWSLObject(WSLIndex) ) )
        goto BadRefreshWSLObjectState;

    lstrcpy( WSName, pWSLObject->m_WinStationName );

    /*
     * Fetch the WinStation's configuration structure and save a copy for
     * update comparison.
     */
    memset( &WSConfig, 0, sizeof(WINSTATIONCONFIG2) );
    memset( &EWSDlg.m_WSConfig, 0, sizeof(WINSTATIONCONFIG2) );

	if((Status = RegistryQuery(	WSName, 
								&WSConfig, 
								pWSLObject->m_WdName, 
								&pExtObject))) {

        pszFailedCall = pApp->m_pszRegWinStationQuery;
        goto BadRegWinStationQuery;
    }
    memcpy( &EWSDlg.m_WSConfig, &WSConfig, sizeof(WINSTATIONCONFIG2) );

	/*
	 * copy the pExtObject into the one for the EWSDlg
	 */
	if(pExtObject) {
		PTERMLOBJECT pObject = GetWdListObject(pWSLObject->m_WdName);

		if(pObject && pObject->m_hExtensionDLL && pObject->m_lpfnExtDupObject) {
		 	EWSDlg.m_pExtObject = (*pObject->m_lpfnExtDupObject)(pExtObject);
		}
	} else {
		EWSDlg.m_pExtObject = NULL;
	}

    /*
     * Initialize the dialog's member variables.
     */
    EWSDlg.m_pWSName = WSName;
    EWSDlg.m_DlgMode = m_bReadOnly ? EWSDlgView : EWSDlgEdit;

    /*
     * Invoke the dialog & update if changes.
     */
    if ( (EWSDlg.DoModal() == IDOK) &&
         (EWSDlg.m_DlgMode == EWSDlgEdit) &&
         HasWSConfigChanged(&WSConfig, &EWSDlg.m_WSConfig, pExtObject, EWSDlg.m_pExtObject, EWSDlg.m_WSConfig.Wd.WdName) ) {

        BOOL bUpdateAll = FALSE,
             bDestructive = FALSE,
             bAsyncDeviceChanged = ((pWSLObject->m_SdClass == SdAsync) &&
                                    lstrcmpi(WSConfig.Pd[0].Params.Async.DeviceName,
                                             EWSDlg.m_WSConfig.Pd[0].Params.Async.DeviceName)),
             bAsyncModemChanged = ((pWSLObject->m_SdClass == SdAsync) &&
                                   lstrcmpi(WSConfig.Pd[0].Params.Async.ModemName,
                                            EWSDlg.m_WSConfig.Pd[0].Params.Async.ModemName)),
             bNetworkDeviceChanged = ((pWSLObject->m_SdClass == SdNetwork) &&
                                      (WSConfig.Pd[0].Params.Network.LanAdapter !=
                                       EWSDlg.m_WSConfig.Pd[0].Params.Network.LanAdapter)),
             bEnabledStateChanged = (WSConfig.Create.fEnableWinStation !=
                                     EWSDlg.m_WSConfig.Create.fEnableWinStation),
             bEnabled = EWSDlg.m_WSConfig.Create.fEnableWinStation,
             bWasEnabled = WSConfig.Create.fEnableWinStation;

        /*
         * If the winstation is being disabled or the device (or modem) has changed
         * and folks are connected, the update will cause all instances to be destroyed.
         * Let user know this so that the update can be canceled.  Also allow
         * normal confirmation if just disabling the winstation and no users are
         * presently connected.
         */
        if ( !bEnabled || bAsyncDeviceChanged || bAsyncModemChanged || bNetworkDeviceChanged ) {

            if ( pApp->m_nConfirmation ) {

                int id;
                UINT nType = 0;
                long count = QueryLoggedOnCount(WSName);
                    
                if ( !bEnabled && bWasEnabled ) {

                    nType = MB_YESNO | 
                            (count ? MB_ICONEXCLAMATION : MB_ICONQUESTION);
                    id = count ?
                            ((count == 1) ?
                                IDP_CONFIRM_WINSTATIONDISABLE_1USER :
                                IDP_CONFIRM_WINSTATIONDISABLE_NUSERS) :
                            IDP_CONFIRM_WINSTATIONDISABLE;

                } else if ( bAsyncDeviceChanged && count ) {

                    nType = MB_YESNO | MB_ICONEXCLAMATION;
                    id = IDP_CONFIRM_DEVICECHANGED;

                } else if ( bAsyncModemChanged && count ) {

                    nType = MB_YESNO | MB_ICONEXCLAMATION;
                    id = IDP_CONFIRM_MODEMCHANGED;

                } else if ( bNetworkDeviceChanged && count ) {

                    nType = MB_YESNO | MB_ICONEXCLAMATION;
                    id = ((count == 1) ? IDP_CONFIRM_ADAPTERCHANGED_1USER :
                                        IDP_CONFIRM_ADAPTERCHANGED_NUSERS);
                }
                if ( nType && (QuestionMessage(nType, id, WSName ) == IDNO) )
                    goto CancelChanges;
            }
            bDestructive = TRUE;
        }

        CWaitCursor wait;

        /*
         * Special case for Async WinStation.
         */
        if ( pWSLObject->m_SdClass == SdAsync ) {

            /*
             * If a modem has been added or removed from the WinStation,
             * delete the current WSLObject and add a new WSLObject to the list.
             */
            if ( bAsyncModemChanged ) {

                RemoveFromWSL(WSLIndex);
                if ( (WSLIndex = InsertInWSL( WSName,
                                              &EWSDlg.m_WSConfig,
											  EWSDlg.m_pExtObject,
                                              &pWSLObject )) == -1 ) {

                    LoadWSL(pApp->m_szCurrentAppServer);
                    goto BadInsertInWSL;
                }
                bUpdateAll = TRUE;
            }

            /*
             * Make sure that the WSL device name is current.
             */
            FormDecoratedAsyncDeviceName(
                            pWSLObject->m_DeviceName,
                            &(EWSDlg.m_WSConfig.Pd[0].Params.Async) );
        }

        /*
         * Special case for OEM Transport WinStation.
         */
        if ( pWSLObject->m_SdClass == SdOemTransport ) {

            /*
             * Make sure that the WSL device name is current.
             */
            lstrcpy( pWSLObject->m_DeviceName,
                     EWSDlg.m_WSConfig.Pd[0].Params.OemTd.DeviceName );
        }

        /*
         * Update WSL fields.
         */
        lstrcpy( pWSLObject->m_WdName, EWSDlg.m_WSConfig.Wd.WdName );
        lstrcpy( pWSLObject->m_Comment, EWSDlg.m_WSConfig.Config.Comment );
        pWSLObject->m_Flags = ((pWSLObject->m_Flags & ~WSL_ENABLED) |
            (EWSDlg.m_WSConfig.Create.fEnableWinStation ? WSL_ENABLED : 0));

        /*
         * Update registry entry.
         */
        if ( (Status = RegistryCreate(
                                WSName,
                                FALSE,
                                &EWSDlg.m_WSConfig,
								EWSDlg.m_WSConfig.Wd.WdName,
                                EWSDlg.m_pExtObject)) ) {

            pszFailedCall = pApp->m_pszRegWinStationCreate;
            goto BadRegWinStationCreate;
        }

        /*
         * If we're not 'registry only', tell Session Manager
         * to re-read registry and output 'in use' message if
         * necessary.
         */
#ifdef WINSTA
        if ( !pApp->m_nRegistryOnly ) {

            _WinStationReadRegistry(SERVERNAME_CURRENT);

            /*
             * If the state is now 'enabled' AND
             *      1) the modem has changed, OR
             *      2) a modem is now configured AND
             *          a) the state was 'disabled' OR
             *          b) the COM port has changed
             * Then issue the 'must reboot' message and set must reboot flag.
             * Otherwise, if this is not a destructive action, issue in use message if needed
             * and make sure the must reboot flag is cleared.
             */
            if ( bEnabled &&
                 (bAsyncModemChanged ||
                  (*EWSDlg.m_WSConfig.Pd[0].Params.Async.ModemName &&
                   (!bWasEnabled || bAsyncDeviceChanged))) ) {

                QuestionMessage( MB_OK | MB_ICONEXCLAMATION,
                                 IDP_NOTICE_REBOOTFORMODEM_EDIT, WSName );
                pWSLObject->m_Flags |= WSL_MUST_REBOOT;

            } else if ( !bDestructive ) {

                InUseMessage(WSName);
                pWSLObject->m_Flags &= ~WSL_MUST_REBOOT;
            }
        }
#endif // WINSTA

        /*
         * Update view.
         */
        if ( bUpdateAll )
            UpdateAllViews( NULL, 0, NULL );
        else
            UpdateAllViewsWithItem( NULL, WSLIndex, pWSLObject );
    } else {
		/*
	 	 * We didn't need to write any changes to the registry
		 * Delete the extension objects we created
		 */
		DeleteExtensionObject(pExtObject, WSConfig.Wd.WdName);
		DeleteExtensionObject(EWSDlg.m_pExtObject, EWSDlg.m_WSConfig.Wd.WdName);
	}

CancelChanges:
    return(WSLIndex);

/*==============================================================================
 * Error returns
 *============================================================================*/
BadRegWinStationCreate:
BadInsertInWSL:
BadRegWinStationQuery:
BadRefreshWSLObjectState:
    if ( pszFailedCall ) {

        STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, Status,
                                 IDP_ERROR_EDITWINSTATION, WSName,
                                 pszFailedCall ))
    }
    return(-1);

}  // end CAppServerDoc::EditWinStation


/*******************************************************************************
 *
 *  DeleteWinStation - CAppServerDoc member function: public operation
 *
 *      Delete a WinStation.
 *
 *  ENTRY:
 *      WSLIndex (input)
 *          WSL index of the WinStation to delete.
 *  EXIT:
 *      (BOOL) TRUE if WinStation was deleted; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::DeleteWinStation(int WSLIndex)
{
    PWSLOBJECT pWSLObject;
    WINSTATIONNAME WSName;
    LONG Status, LoggedOnCount = 0;
    ULONG Length;
    LPCTSTR pszFailedCall = NULL;
    WINSTATIONCONFIG2 WSConfig;
	void *pExtObject;

    /*
     * Get current WinStation object and assure that the WSL is 'in sync'
     * with the registry.
     */
    if ( !RefreshWSLObjectState( WSLIndex,
                                 pWSLObject = GetWSLObject(WSLIndex)) )
        goto BadRefreshWSLObjectState;

    lstrcpy( WSName, pWSLObject->m_WinStationName );

    memset( &WSConfig, 0, sizeof(WINSTATIONCONFIG2) );

	if((Status = RegistryQuery(	WSName, 
								&WSConfig, 
								pWSLObject->m_WdName, 
								&pExtObject))) {

        pszFailedCall = pApp->m_pszRegWinStationQuery;
        goto BadRegWinStationQuery;
    }

    /*
     * Confirm delete if requested.
     */
    if ( pApp->m_nConfirmation ) {

        long count = QueryLoggedOnCount(WSName);
        UINT nType = MB_YESNO;
        int id;

        if ( count == 0 ) {
            nType |= MB_ICONQUESTION;
            id = IDP_CONFIRM_WINSTATIONDELETE;
        } else if ( count == 1 ) {
            nType |= MB_ICONEXCLAMATION;
            id = IDP_CONFIRM_WINSTATIONDELETE_1USER;
        } else {
            nType |= MB_ICONEXCLAMATION;
            id = IDP_CONFIRM_WINSTATIONDELETE_NUSERS;
        }

        if ( QuestionMessage( nType, id, WSName ) == IDNO )
            goto DontDelete;
    }

    {
    CWaitCursor wait;

    /*
     * Delete the registry entry.
     */
    if ( (Status = RegistryDelete(WSName, WSConfig.Wd.WdName, pExtObject)) ) {

        pszFailedCall = pApp->m_pszRegWinStationDelete;
        goto BadRegDelete;
    }

    /*
     * Remove WSLObject from the list.
     */
    RemoveFromWSL(WSLIndex);

    /*
     * If we're not 'registry only', tell Session Manager
     * to re-read registry.
     */
#ifdef WINSTA
    if ( !pApp->m_nRegistryOnly ) {

        _WinStationReadRegistry(SERVERNAME_CURRENT);
    }
#endif // WINSTA

    /*
     * A WSLObject was removed: update the entire view.
     */
    UpdateAllViews(NULL, 0, NULL);
    }

DontDelete:
    return(TRUE);

/*==============================================================================
 * Error returns
 *============================================================================*/
BadRegDelete:
BadRegWinStationQuery:
BadRefreshWSLObjectState:
    if ( pszFailedCall ) {

        STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, Status,
                                 IDP_ERROR_DELETEWINSTATION, WSName,
                                 pszFailedCall ))
    }
    return(FALSE);

}  // CAppServerDoc::DeleteWinStation


/*******************************************************************************
 *
 *  EnableWinStation - CAppServerDoc member function: public operation
 *
 *      Enable or Disable specified WinStation(s).
 *
 *  ENTRY:
 *      WSLIndex (input)
 *          WSL index of the WinStation(s) to enable or disable.
 *      bEnable (input)
 *          TRUE to enable WinStation(s); FALSE to disable WinStation(s).
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerDoc::EnableWinStation( int WSLIndex,
                                 BOOL bEnable )
{
    LONG Status;
    ULONG Length;
    PWSLOBJECT pWSLObject;
    WINSTATIONNAME WSName;
    WINSTATIONCONFIG2 WSConfig;
    LPCTSTR pszFailedCall = NULL;

    /*
     * Get current WinStation object and assure that the WSL is 'in sync'
     * with the registry.
     */
    if ( !RefreshWSLObjectState( WSLIndex,
                                 pWSLObject = GetWSLObject(WSLIndex) ) )
        goto BadRefreshWSLObjectState;

    lstrcpy( WSName, pWSLObject->m_WinStationName );

    /*
     * Fetch the WinStation's configuration structure.
     */
    if ( (Status = RegWinStationQuery(
                        SERVERNAME_CURRENT,
                        pWSLObject->m_WinStationName,
                        &WSConfig,
                        sizeof(WINSTATIONCONFIG2), &Length)) ) {

        pszFailedCall = pApp->m_pszRegWinStationQuery;
        goto BadRegWinStationQuery;
    }

    /*
     * Confirm disable if requested.
     */
    if ( !bEnable && pApp->m_nConfirmation ) {

        long count = QueryLoggedOnCount(WSName);
        UINT nType = MB_YESNO;
        int id;

        if ( count == 0 ) {
            nType |= MB_ICONQUESTION;
            id = IDP_CONFIRM_WINSTATIONDISABLE;
        } else if ( count == 1 ) {
            nType |= MB_ICONEXCLAMATION;
            id = IDP_CONFIRM_WINSTATIONDISABLE_1USER;
        } else {
            nType |= MB_ICONEXCLAMATION;
            id = IDP_CONFIRM_WINSTATIONDISABLE_NUSERS;
        }

        if ( QuestionMessage( nType, id, WSName ) == IDNO )
            goto DontDisable;
    }

    {
    CWaitCursor wait;

    /*
     * Update registry entry.
     */
    WSConfig.Create.fEnableWinStation = (bEnable ? 1 : 0);
    if ( (Status = RegWinStationCreate(
                            SERVERNAME_CURRENT,
                            WSName,
                            FALSE,
                            &WSConfig,
                            sizeof(WSConfig))) ) {

        pszFailedCall = pApp->m_pszRegWinStationCreate;
        goto BadRegWinStationCreate;
    }

    /*
     * Update WSLObject state.
     */
    pWSLObject->m_Flags = (pWSLObject->m_Flags & ~WSL_ENABLED) |
                            (bEnable ? WSL_ENABLED : 0);

    /*
     * If we're not 'registry only', tell Session Manager
     * to re-read registry.
     */
#ifdef WINSTA
    if ( !pApp->m_nRegistryOnly ) {

        _WinStationReadRegistry(SERVERNAME_CURRENT);

        /*
         * If we're enabling a modem winstation, issue the 'must reboot' message and
         * set 'must reboot flag.  Otherwise, make sure the must reboot flag is cleared.
         */
        if ( bEnable && *WSConfig.Pd[0].Params.Async.ModemName ) {

            QuestionMessage( MB_OK | MB_ICONEXCLAMATION,
                             IDP_NOTICE_REBOOTFORMODEM_ENABLE, WSName );
            pWSLObject->m_Flags |= WSL_MUST_REBOOT;

        } else {

            pWSLObject->m_Flags &= ~WSL_MUST_REBOOT;
        }
    }
#endif // WINSTA

    /*
     * Update this WSL in the view.
     */
    UpdateAllViewsWithItem( NULL, WSLIndex, pWSLObject );
    }

DontDisable:
    return;

/*==============================================================================
 * Error returns
 *============================================================================*/
BadRegWinStationCreate:
BadRegWinStationQuery:
BadRefreshWSLObjectState:
    if ( pszFailedCall ) {

        STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, Status,
                                 bEnable ?
                                    IDP_ERROR_ENABLEWINSTATION :
                                    IDP_ERROR_DISABLEWINSTATION,
                                 WSName,
                                 pszFailedCall ))
    }
    return;

}  // end CAppServerDoc::EnableWinStation


/*******************************************************************************
 *
 *  SecurityPermissions - CAppServerDoc member function: public operation
 *
 *      View/Edit WinStation security permissions.
 *
 *  ENTRY:
 *      WSLIndex (input)
 *          WSL index of the selected WinStation.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerDoc::SecurityPermissions(int WSLIndex)
{
    PWSLOBJECT pWSLObject;

    /*
     * If no items yet, return immediately.
     */
    if ( !(pWSLObject = GetWSLObject(WSLIndex)) )
        return;

    /*
     * Get current WinStation object and assure that the WSL is 'in sync'
     * with the registry.
     */
    if ( !RefreshWSLObjectState(WSLIndex, pWSLObject) )
        return;                                    

    if ( CallPermissionsDialog( pApp->m_pMainWnd->m_hWnd,
                                m_bAdmin,
                                pWSLObject->m_WinStationName ) &&
         (lstrcmpi(pWSLObject->m_WinStationName, pApp->m_szSystemConsole) != 0) ) {

        /*
         * If we're not 'registry only', tell Session Manager
         * to re-read registry and output 'in use' message if
         * necessary.
         */
#ifdef WINSTA
        if ( !pApp->m_nRegistryOnly ) {
            _WinStationReadRegistry(SERVERNAME_CURRENT);

            InUseMessage(pWSLObject->m_WinStationName);
        }
#endif // WINSTA
    }

}  // end CAppServerDoc::SecurityPermissions


////////////////////////////////////////////////////////////////////////////////
// CAppServerDoc private operations


/*******************************************************************************
 *
 *  LoadWSL - CAppServerDoc member function: private operation
 *
 *      Reset the WSL to 'empty' and read the specified AppServer's WinStation
 *      registry information to load up the WSL.
 *
 *  ENTRY:
 *      pszAppServer (input)
 *          Name of the AppServer to access.
 *
 *  EXIT:
 *      (BOOL) TRUE if the load was successful; FALSE if error.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::LoadWSL( LPCTSTR pszAppServer )
{
    LONG Status;
    ULONG Index, ByteCount, Entries, LogonId;
    WINSTATIONNAME WSName;
	void *pExtObject = NULL;

    /*
     * Insure that the WSL is empty.
     */
    DeleteWSLContents();

    Index = 0;
    for ( Index = 0, Entries = 1, ByteCount = sizeof(WINSTATIONNAME);
          (Status =
           RegWinStationEnumerate( SERVERNAME_CURRENT, &Index, &Entries,
                                   WSName, &ByteCount )) == ERROR_SUCCESS;
          ByteCount = sizeof(WINSTATIONNAME) ) {

        WINSTATIONCONFIG2 WSConfig;
        PWSLOBJECT pWSLObject;
        ULONG Length;

        /*
         * Ignore system console.
         */
        if ( !lstrcmpi(WSName, pApp->m_szSystemConsole) )
            continue;

        if ( (Status = RegistryQuery(WSName, &WSConfig, WSConfig.Wd.WdName, 
                            &pExtObject)) ) {
            
            STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, Status,
                                     IDP_ERROR_REGWINSTATIONQUERY,
                                     WSName ))
            continue;
        }

        /*
         * Insert a WinStation object into the WinStationList.
         */
        if ( InsertInWSL( WSName, &WSConfig, pExtObject, &pWSLObject ) == -1 ) {
            DeleteWSLContents();
            return(FALSE);
        }

        /*
         * If this was an enabled modem WinStation and it has not been
         * created by the system, flag as 'must reboot' (configured TAPI
         * winstation that requires system reboot before being activated).
         */
#ifdef WINSTA
        if ( (pWSLObject->m_SdClass == SdAsync) &&
             (pWSLObject->m_Flags & WSL_ENABLED) &&
             !(pWSLObject->m_Flags & WSL_DIRECT_ASYNC) &&
             !LogonIdFromWinStationName(SERVERNAME_CURRENT, WSName, &LogonId) )
            pWSLObject->m_Flags |= WSL_MUST_REBOOT;
#endif // WINSTA
    }

    return(TRUE);

}  // end CAppServerDoc::LoadWSL


/*******************************************************************************
 *
 *  RefreshWSLObjectState - CAppServerDoc member function: private operation
 *
 *      Make sure that the state of the specified WSL matches the WinStation
 *      state in the registry.
 *
 *  ENTRY:
 *      nIndex (input)
 *          Index of WSL being refreshed.
 *      pWSLObject (input/output)
 *          Points to the WSLOBJECT containing the WinStation(s) being
 *          refreshed.
 *  EXIT:
 *      (BOOL) TRUE if the refresh was successful; FALSE if error.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::RefreshWSLObjectState( int nIndex,
                                      PWSLOBJECT pWSLObject )
{
    ULONG State;
    LONG Status;

    /*
     * Check for invalid WSLObject (return TRUE if so).
     */
    if ( pWSLObject == NULL )
        return(TRUE);

#ifdef UNICODE
    Status = RegWinStationQueryNumValue( SERVERNAME_CURRENT,
                                         pWSLObject->m_WinStationName,
                                         WIN_ENABLEWINSTATION,
                                         &State );
#else
    /*
     * Note: this function does not have a ANSI version: must convert the
     * ANSI WINSTATIONNAME(A) into UNICODE WINSTATIONNAME(W) and call
     * the UNICODE RegWinStationQueryNumValueW() API.
     */
    WINSTATIONNAMEW WSNameW;

    mbstowcs( WSNameW, pWSLObject->m_WinStationName, sizeof(WSNameW) );
    Status = RegWinStationQueryNumValueW( SERVERNAME_CURRENT,
                                          WSNameW,
                                          WIN_ENABLEWINSTATION,
                                          &State );
#endif
    if ( Status != ERROR_SUCCESS ) {

        STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, Status,
                                 IDP_ERROR_REFRESHWINSTATIONSTATE,
                                 pWSLObject->m_WinStationName ))
        return(FALSE);
    }

    if ( (State && !(pWSLObject->m_Flags & WSL_ENABLED)) ||
         (!State && (pWSLObject->m_Flags & WSL_ENABLED)) ) {

        POSITION pos;

        /*
         * The registry state does not match the WSL's state: update the
         * WSL and cause the view to redraw it immediately.
         */
        pWSLObject->m_Flags = (pWSLObject->m_Flags & ~WSL_ENABLED) |
                                (State ? WSL_ENABLED : 0);
        UpdateAllViewsWithItem( NULL, nIndex, NULL );
        GetNextView( pos = GetFirstViewPosition() )->UpdateWindow();
    }

    return(TRUE);

}  // end CAppServerDoc::RefreshWSLObjectState


/*******************************************************************************
 *
 *  DeleteWSLContents - CAppServerDoc member function: private operation
 *
 *      Make sure that the WinStationObjectList is empty.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerDoc::DeleteWSLContents()
{
    POSITION pos1, pos2;
    PWSLOBJECT pObject;

    /*
     * Clean up the WinStationList.
     */
    for ( pos1 = m_WinStationList.GetHeadPosition(); (pos2 = pos1) != NULL; ) {
        m_WinStationList.GetNext( pos1 );
        pObject = (PWSLOBJECT)m_WinStationList.GetAt( pos2 );
        m_WinStationList.RemoveAt( pos2 );
        delete ( pObject );
    }

}  // end CAppServerDoc::DeleteWSLContents


/*******************************************************************************
 *
 *  InsertInWSL - CAppServerDoc member function: private operation
 *
 *      Create a new WinStationList object and insert it into the WinStationList
 *      (if needed).
 *
 *  ENTRY:
 *      pWSName (input)
 *          Points to name of WinStation.
 *      pConfig (input)
 *          Points to WinStation's WINSTATIONCONFIG2 structure.
 *  	pExtObject (input)
 *			Points to the extension DLL's data for the WinStation
 *      ppObject (output)
 *          Points to a PWSLOBJECT pointer which is to receive the PWSLOBJECT
 *          for the new WinStationList object.
 *  EXIT:
 *      (int)
 *          index of the WinStationList object in the WinStationList; -1 if
 *          error.
 *
 ******************************************************************************/

int
CAppServerDoc::InsertInWSL( PWINSTATIONNAME pWSName,
                            PWINSTATIONCONFIG2 pWSConfig,
							void *pExtObject,
                            PWSLOBJECT * ppObject )
{
    int Index = 0;
    BOOL bAdded;
    POSITION oldpos, pos;
    PWSLOBJECT pObject, pListObject;

    /*
     * Create a new WinStationList object and initialize.
     */
    if ( !(pObject = new CWinStationListObject) ) {

        ERROR_MESSAGE((IDP_ERROR_WSLISTALLOC))
        return(-1);
    }
    lstrcpy( pObject->m_WinStationName, pWSName );
    lstrlwr(pObject->m_WinStationName);
    pObject->m_Flags = pWSConfig->Create.fEnableWinStation ? WSL_ENABLED : 0;
    pObject->m_Flags |= (pWSConfig->Pd[0].Create.PdFlag & PD_SINGLE_INST) ? WSL_SINGLE_INST : 0;
    lstrcpy( pObject->m_PdName, pWSConfig->Pd[0].Create.PdName );
    pObject->m_SdClass = pWSConfig->Pd[0].Create.SdClass;
    lstrcpy( pObject->m_WdName, pWSConfig->Wd.WdName );
    lstrcpy( pObject->m_Comment, pWSConfig->Config.Comment );
	pObject->m_pExtObject = pExtObject;
    pObject->m_pWdListObject = GetWdListObject(pObject->m_WdName);

    if ( pObject->m_SdClass == SdAsync ) {

        FormDecoratedAsyncDeviceName( pObject->m_DeviceName,
                                      &(pWSConfig->Pd[0].Params.Async) );

    } else if ( pObject->m_SdClass == SdOemTransport ) {

        lstrcpy( pObject->m_DeviceName,
                 pWSConfig->Pd[0].Params.OemTd.DeviceName );

    } else {

        *(pObject->m_DeviceName) = TEXT('\0');
    }

    pObject->m_Flags |= (pObject->m_SdClass == SdAsync) ?
                        ( *(pWSConfig->Pd[0].Params.Async.ModemName) ?
                            0 : WSL_DIRECT_ASYNC ) : 0;
    pObject->m_LanAdapter = (pObject->m_SdClass == SdNetwork) ?
                             pWSConfig->Pd[0].Params.Network.LanAdapter : 0;

    /*
     * Traverse the WinStationList and insert this new WinStation,
     * keeping the list sorted by SdClass, then PdName, then DirectAsync
     * flag (effects SdAsync types) / LanAdapter # (effects SdNetwork
     * types), then WinStationName.
     */
    for ( Index = 0, bAdded = FALSE,
          pos = m_WinStationList.GetHeadPosition();
                                       pos != NULL; Index++ ) {

        oldpos = pos;
        pListObject = (PWSLOBJECT)m_WinStationList.GetNext( pos );

        if ( (pListObject->m_SdClass > pObject->m_SdClass) ||

             ((pListObject->m_SdClass == pObject->m_SdClass) &&
              lstrcmpi( pListObject->m_PdName,
                        pObject->m_PdName ) > 0) ||

             ((pListObject->m_SdClass == pObject->m_SdClass) &&
              !lstrcmpi( pListObject->m_PdName,
                         pObject->m_PdName ) &&
              ((pListObject->m_Flags & WSL_DIRECT_ASYNC) >
               (pObject->m_Flags & WSL_DIRECT_ASYNC))) ||

              ((pListObject->m_SdClass == pObject->m_SdClass) &&
               !lstrcmpi( pListObject->m_PdName,
                          pObject->m_PdName ) &&
               (pListObject->m_LanAdapter > pObject->m_LanAdapter)) ||

               ((pListObject->m_SdClass == pObject->m_SdClass) &&
                !lstrcmpi( pListObject->m_PdName,
                           pObject->m_PdName ) &&
                ((pListObject->m_Flags & WSL_DIRECT_ASYNC) ==
                 (pObject->m_Flags & WSL_DIRECT_ASYNC)) &&
                (pListObject->m_LanAdapter == pObject->m_LanAdapter) &&
                (lstrcmpi( pListObject->m_WinStationName,
                           pObject->m_WinStationName ) > 0)) ) {

            /*
             * The new object belongs before the current list object.
             */
            m_WinStationList.InsertBefore( oldpos, pObject );
            bAdded = TRUE;
            break;
        }
    }

    /*
     * If we haven't yet added the WinStation, add it now to the tail
     * of the list.
     */
    if ( !bAdded )
        m_WinStationList.AddTail( pObject );

    /*
     * Set the ppObject referenced PWSLOBJECT pointer to the new PWSLOBJECT
     * pointer and return the index of the new WinStationList object.
     */
    *ppObject = pObject;
    return( Index );

}  // end CAppServerDoc::InsertInWSL


/*******************************************************************************
 *
 *  RemoveFromWSL - CAppServerDoc member function: private operation
 *
 *      Remove from the WSL the WSLObject associated with the specified
 *      index, and delete the removed WSLObject.
 *
 *  ENTRY:
 *      nIndex (input)
 *          WSL index of the WSLObject to remove / delete.
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerDoc::RemoveFromWSL( int nIndex )
{
    POSITION pos;
    PWSLOBJECT pWSLObject;

    /*
     * Return immediately if invalid index.
     */            
    if ( nIndex < 0 )
        return;

    pWSLObject = (PWSLOBJECT)m_WinStationList.GetAt( 
                             (pos = m_WinStationList.FindIndex(nIndex)));
    m_WinStationList.RemoveAt(pos);
    
    delete pWSLObject;

}  // end CAppServerDoc::RemoveFromWSL


/*******************************************************************************
 *
 *  UpdateAllViewsWithItem - CAppServerDoc member function: private operation
 *
 *      Update all views of this document with a changed WinStation item.
 *
 *  ENTRY:
 *
 *      pSourceView (input)
 *          Points to document view to update (all views if NULL).
 *
 *      nItemIndex (input)
 *          Document's item (WinStation) index that is causing the update
 *          to occur.
 *
 *      pWSLObject (input)
 *          Pointer to the Document's WinStation list object pointer (may be
 *          NULL). 
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerDoc::UpdateAllViewsWithItem( CView* pSourceView,
                                       UINT nItemIndex,
                                       PWSLOBJECT pWSLObject )
{
    CWinStationListObjectHint hint;

    hint.m_WSLIndex = nItemIndex;
    hint.m_pWSLObject = pWSLObject;

    UpdateAllViews( pSourceView, 0, &hint );

}  // end CAppServerDoc::UpdateAllViewsWithItem


/*******************************************************************************
 *
 *  InUseMessage - CAppServerDoc member function: private operation
 *
 *      If needed, output an appropriate 'in use' message for the specified
 *      WinStation.
 *
 *  ENTRY:
 *      pWSName (input)
 *          Points WinStation name to output message for.
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerDoc::InUseMessage( PWINSTATIONNAME pWSName )
{
    long count;

    if ( (count = QueryLoggedOnCount(pWSName)) ) {

            QuestionMessage(
                MB_OK | MB_ICONINFORMATION,
                    (count == 1) ?
                        IDP_NOTICE_WSINUSE_1USER :
                        IDP_NOTICE_WSINUSE_NUSERS,
                    pWSName );
    }

}  // end CAppServerDoc::InUseMessage


/*******************************************************************************
 *
 *  HasWSConfigChanged - CAppServerDoc member function: private operation
 *
 *      Determine if WINSTATIONCONFIG2 structure has changed, calling our
 *      HasPDConfigChanged method to handle goofy PdConfig2 regapi behavior 
 *      (straight memcmp won't work).
 *
 *  ENTRY:
 *      pOldConfig (input)
 *          Points to the original WINSTATIONCONFIG2 structure.
 *      pNewConfig (input)
 *          Points to the new WINSTATIONCONFIG2 structure.
 *		pOldExtObject (input)
 *			Points to the original extension DLLs object
 *		pNewExtObject (input)
 *			Points to the new extension DLLs object
 *  EXIT:
 *      TRUE if original and new config structures differ;
 *      FALSE if no changes are detected.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::HasWSConfigChanged( 	PWINSTATIONCONFIG2 pOldConfig,
                                   	PWINSTATIONCONFIG2 pNewConfig,
                                   	void *pOldExtObject,
                                  	void *pNewExtObject,
								  	PWDNAME pWdName)
{
    BOOL bChanged = FALSE;

    if ( memcmp( &pOldConfig->Create, 
                 &pNewConfig->Create, 
                 sizeof(WINSTATIONCREATE) )         ||

         HasPDConfigChanged(pOldConfig, pNewConfig) ||

		 HasExtensionObjectChanged(pWdName, pOldExtObject, pNewExtObject) ||

         memcmp( &pOldConfig->Wd, 
                 &pNewConfig->Wd, 
                 sizeof(WDCONFIG) )                 ||

         memcmp( &pOldConfig->Cd, 
                 &pNewConfig->Cd, 
                 sizeof(CDCONFIG) )                 ||

         memcmp( &pOldConfig->Config, 
                 &pNewConfig->Config, 
                 sizeof(WINSTATIONCONFIG) ) ) {

        bChanged = TRUE;
    }

    return(bChanged);

}  // end CAppServerDoc::HasWSConfigChanged


/*******************************************************************************
 *
 *  HasPDConfigChanged - CAppServerDoc member function: private operation
 *
 *      Determine if the PDConfig structures have changed, with special
 *      compare logic to handle goofy PdConfig2 regapi behavior (straight
 *      memcmp won't work).
 *
 *  ENTRY:
 *      pOldConfig (input)
 *          Points to the original WINSTATIONCONFIG2 structure.
 *      pNewConfig (input)
 *          Points to the new WINSTATIONCONFIG2 structure.
 *  EXIT:
 *      TRUE if original and new config structures differ;
 *      FALSE if no changes are detected.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::HasPDConfigChanged( PWINSTATIONCONFIG2 pOldConfig,
                                   PWINSTATIONCONFIG2 pNewConfig )
{
    BOOL bChanged = FALSE;
    int i;

    for ( i = 0; i < MAX_PDCONFIG; i++ ) {

        if ( (pOldConfig->Pd[i].Create.SdClass != 
              pNewConfig->Pd[i].Create.SdClass)     ||
             memcmp( &pOldConfig->Pd[i].Params,
                     &pNewConfig->Pd[i].Params,
                     sizeof(PDPARAMS) ) ) {

            bChanged = TRUE;
            break;
        }
    }

    return(bChanged);

}  // end CAppServerDoc::HasPDConfigChanged


/*******************************************************************************
 *
 *  HasExtensionObjectChanged - CAppServerDoc member function: private operation
 *
 *      Determine if the object maintained by the extension DLL has changed
 *
 *  ENTRY:
 *		pOldExtObject (input)
 *			Points to the original extension DLLs object
 *		pNewExtObject (input)
 *			Points to the new extension DLLs object
 *  EXIT:
 *      TRUE if original and new objects differ;
 *      FALSE if no changes are detected.
 *
 ******************************************************************************/

BOOL
CAppServerDoc::HasExtensionObjectChanged( PWDNAME pWdName, void *pOldExtObject,
                                   void *pNewExtObject)
{
    BOOL bChanged = FALSE;

 	if(!pOldExtObject && !pNewExtObject) return FALSE;
	if(!pOldExtObject || !pNewExtObject) return TRUE;

	/*
	 * Ask the extension DLL if the objects are the same.
	 * Extension DLL returns TRUE if the objects are the same
	 * and FALSE if they are not,
	 * Therefore, we must NOT the value before returning it
	 */
	PTERMLOBJECT pObject = GetWdListObject(pWdName);

	if(pObject && pObject->m_hExtensionDLL && pObject->m_lpfnExtCompareObjects) {
	 	return !(*pObject->m_lpfnExtCompareObjects)(pOldExtObject, pNewExtObject);
	}
	
	/*
	 * If for some reason, we can't ask the extension DLL, play it safe and
	 * assume that the object has changed
	 */
	return TRUE;

}


/*******************************************************************************
 *
 *  CAppServerDoc::DeleteExtensionObject
 *
 *      Tells the extension DLL to delete an object we no longer need
 *
 *  ENTRY:
 *      pExtObject (input)
 *          Points to the extension object
 *      pWdName (input)
 *          Points to the name of the Wd (this is used to determine
 *			which extension DLL owns the object)
 *  EXIT:
 *      none
 *
 ******************************************************************************/														
void CAppServerDoc::DeleteExtensionObject(void *pExtObject, PWDNAME pWdName)
{
	if(pExtObject) {
		/*
		 * Tell the extension DLL to delete this object
		 */
		PTERMLOBJECT pObject = GetWdListObject(pWdName);

		if(pObject && pObject->m_hExtensionDLL && pObject->m_lpfnExtDeleteObject) {
		 	(*pObject->m_lpfnExtDeleteObject)(pExtObject);
		}
	}

}	// end CAppServerDoc::DeleteExtensionObject


/*******************************************************************************
 *
 *  CAppServerDoc::RegistryQuery
 *
 *      Queries the registry for the information about a WinStation AND
 *		queries the extension DLL for it's information about the WinStation
 *
 *  ENTRY:
 *      pWinStationName (input)
 *          Points to the name of the WinStation
 *      pWsConfig (output)
 *          Where to put the query results
 *		pWdName (input)
 *          Points to the name of the Wd (this is used to determine
 *			which extension DLL owns the object)
 *		pExtObject (output)
 *			This pointer will point to the extension DLL's object
 *			for this WinStation		 	
 *  EXIT:
 *      ERROR_SUCCESS if successful
 *      Registry error code, if not
 *
 ******************************************************************************/
LONG CAppServerDoc::RegistryQuery(PWINSTATIONNAME pWinStationName, PWINSTATIONCONFIG2 pWsConfig, PWDNAME pWdName, void **pExtObject)
{				
	LONG Status;
	ULONG Length;

	/*
	 * Query the registry for WinStation data
	 */
    if((Status = RegWinStationQuery( SERVERNAME_CURRENT,
                                       pWinStationName,
                                       pWsConfig,
                                       sizeof(WINSTATIONCONFIG2), &Length)) ) {
		return Status;
	}

	// Ask the extension DLL for it's data
	PTERMLOBJECT pObject = GetWdListObject(pWdName);		

	if(pObject && pObject->m_hExtensionDLL && pObject->m_lpfnExtRegQuery) {
        	*pExtObject = (*pObject->m_lpfnExtRegQuery)(pWinStationName, &pWsConfig->Pd[0]);
			if(!pExtObject) Status = ERROR_INVALID_FUNCTION;
    }
	else *pExtObject = NULL;

	return Status;

}	// end CAppServerDoc::RegistryQuery


/*******************************************************************************
 *
 *  CAppServerDoc::RegistryCreate
 *
 *      Create/Update the registry for a WinStation AND
 *		tell the extension DLL to store it's information about the WinStation
 *
 *  ENTRY:
 *      pWinStationName (input)
 *          Points to the name of the WinStation
 *      pWsConfig (input)
 *          Points to the data for this WinStation
 *		pWdName (input)
 *          Points to the name of the Wd (this is used to determine
 *			which extension DLL owns the object)
 *		pExtObject (input)
 *			Points to the extension DLL's data for this WinStation
 *  EXIT:
 *      ERROR_SUCCESS if successful
 *      Registry error code, if not
 *
 ******************************************************************************/
LONG CAppServerDoc::RegistryCreate(PWINSTATIONNAME pWinStationName, BOOLEAN bCreate, PWINSTATIONCONFIG2 pWsConfig, PWDNAME pWdName, void *pExtObject)
{
	LONG Status;

    if((Status = RegWinStationCreate( SERVERNAME_CURRENT,
                                            pWinStationName,
                                            bCreate,
                                            pWsConfig,
                                            sizeof(WINSTATIONCONFIG2))) ) {
		return Status;
	}

	if(pExtObject) {
		/*
		 * Tell the extension DLL to write it's data
		 */
		PTERMLOBJECT pObject = GetWdListObject(pWdName);

		if(pObject && pObject->m_hExtensionDLL && pObject->m_lpfnExtRegCreate) {
		 	Status = (*pObject->m_lpfnExtRegCreate)(pWinStationName, pExtObject, bCreate);
		}
	}
    
    return Status;

}	// end CAppServerDoc::RegistryCreate


/*******************************************************************************
 *
 *  CAppServerDoc::RegistryDelete
 *
 *      Deletes a WinStation's data from the registry AND
 *		tells the extension DLL to delete it's data for the WinStation from
 *		the registry (or wherever he stores it)
 *
 *  ENTRY:
 *      pWinStationName (input)
 *          Points to the name of the WinStation
 *		pWdName (input)
 *          Points to the name of the Wd (this is used to determine
 *			which extension DLL owns the object)
 *		pExtObject (input)
 *			Points to the extension DLL's data for this WinStation
 *  EXIT:
 *      ERROR_SUCCESS if successful
 *      Registry error code, if not
 *
 ******************************************************************************/
LONG CAppServerDoc::RegistryDelete(PWINSTATIONNAME pWinStationName, PWDNAME pWdName, void *pExtObject)
{
	LONG Status;
    LONG ExtStatus = ERROR_SUCCESS;


	/*
	 * Tell the extension DLL to delete it's data first.
	 * This is done because it could be a subkey under the WinStation's data
	 * in the Registry.  RegWinStationDelete calls RegDeleteKey which
	 * cannot delete subkeys under Windows NT.
	*/
	if(pExtObject) {
		/*
		 * Tell the extension DLL to delete it's data
		 */
		PTERMLOBJECT pObject = GetWdListObject(pWdName);

		if(pObject && pObject->m_hExtensionDLL && pObject->m_lpfnExtRegDelete) {
		 	ExtStatus = (*pObject->m_lpfnExtRegDelete)(pWinStationName, pExtObject);
		}
	}

    Status = RegWinStationDelete( SERVERNAME_CURRENT, pWinStationName);
    
	if(ExtStatus) return ExtStatus;
    return Status;

}	// end CAppServerDoc::RegistryDelete


///////////////////////////////////////////////////////////////////////////////
// CAppServerDoc message map

BEGIN_MESSAGE_MAP(CAppServerDoc, CDocument)
    //{{AFX_MSG_MAP(CAppServerDoc)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


////////////////////////////////////////////////////////////////////////////////
// CAppServerDoc commands



/*******************************************************************************
 *
 *  CWinStationListObject constructor
 *
 *
 *  ENTRY:
 *      none
 *  EXIT:
 *      constructors don't have return types
 *
 ******************************************************************************/
CWinStationListObject::CWinStationListObject()
{
	m_pExtObject = NULL;

}	// end CWinStationListObject::CWinStationListObject


/*******************************************************************************
 *
 *  CWinStationListObject destructor
 *
 *      Tells the extension DLL to delete the object associated with this guy
 *
 *  ENTRY:
 *      none
 *  EXIT:
 *      destructors don't have return types
 *
 ******************************************************************************/
CWinStationListObject::~CWinStationListObject()
{
	if(m_pExtObject) {
		PTERMLOBJECT pObject = GetWdListObject(m_WdName);		

	    if(pObject && pObject->m_hExtensionDLL && pObject->m_lpfnExtDeleteObject) {
        	(*pObject->m_lpfnExtDeleteObject)(m_pExtObject);
    	}
	}	
}	// end CWinStationListObject::~CWinStationListObject


/*******************************************************************************
 *
 *  GetWdListObject - 
 *
 *      Returns a pointer to the Wd list object for the specified WD
 *
 *  ENTRY:
 *      pWdName (input)
 *          Points to the name of the Wd
 *  EXIT:
 *      pointer to Wd List Object
 *      NULL if not found
 *
 ******************************************************************************/
PTERMLOBJECT GetWdListObject(PWDNAME pWdName)
{
    POSITION pos;
    PTERMLOBJECT pObject;

    /*
     * Traverse the WD list
     */
    for ( pos = pApp->m_WdList.GetHeadPosition(); pos != NULL; ) {

        pObject = (PTERMLOBJECT)pApp->m_WdList.GetNext( pos );

        if ( !lstrcmp( pObject->m_WdConfig.Wd.WdName, pWdName ) ) {
            return(pObject);
        }
    }

    return(NULL);

}  // end GetWdListObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\appsvvw.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* appsvvw.cpp
*
* implementation of the CAppServerView class
*
* copyright notice: Copyright 1994, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   M:\nt\private\utils\citrix\winutils\wincfg\VCS\appsvvw.cpp  $
*  
*     Rev 1.24   22 Oct 1997 09:43:52   butchd
*  MS changes: added r-button popup menu
*  
*     Rev 1.23   19 Jun 1997 19:21:12   kurtp
*  update
*  
*     Rev 1.22   25 Mar 1997 08:59:52   butchd
*  update
*  
*     Rev 1.21   21 Mar 1997 16:25:52   butchd
*  update
*  
*     Rev 1.20   04 Mar 1997 08:35:16   butchd
*  update
*  
*     Rev 1.19   24 Sep 1996 16:21:24   butchd
*  update
*  
*     Rev 1.18   13 Sep 1996 17:57:06   butchd
*  update
*  
*     Rev 1.17   12 Sep 1996 16:15:52   butchd
*  update
*
*******************************************************************************/

/*
 * include files
 */
#include "stdafx.h"
#include "wincfg.h"

#include "rowview.h"
#include "appsvdoc.h"
#include "appsvvw.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CWincfgApp *pApp;


////////////////////////////////////////////////////////////////////////////////
// CAppServerView class implementation / construction, destruction

IMPLEMENT_DYNCREATE(CAppServerView, CRowView)

/*******************************************************************************
 *
 *  CAppServerView - CAppServerView constructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CAppServerView::CAppServerView()
{
    m_nActiveRow = 0;
    m_bThumbTrack = FALSE;     // Turn off thumbtrack scrolling

}  // end CAppServerView::CAppServerView


/*******************************************************************************
 *
 *  CAppServerView - CAppServerView destructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CAppServerView::~CAppServerView()
{
}  // end CAppServerView::~CAppServerView


////////////////////////////////////////////////////////////////////////////////
// CAppServerView class override member functions

/*******************************************************************************
 *
 *  GetDocument - CAppServerDoc member function: CView class override
 *
 *      Return a pointer to this view's document.
 *
 *  (Refer to the MFC CView::GetDocument documentation)
 *
 ******************************************************************************/

CAppServerDoc*
CAppServerView::GetDocument()
{
    VERIFY ( m_pDocument->IsKindOf( RUNTIME_CLASS(CAppServerDoc) ) );
    return ( (CAppServerDoc*)m_pDocument );

}  // end CAppServerView::GetDocument


/*******************************************************************************
 *
 *  OnUpdate - CAppServerDoc member function: CView class override
 *
 *      Respond to a change in this view's document.
 *
 *  (Refer to the MFC CView::OnUpdate documentation)
 *
 ******************************************************************************/

void
CAppServerView::OnUpdate( CView* pSender,
                          LPARAM lHint,
                          CObject* pHint )
{
    /*
     * OnUpdate() is called whenever the document has changed and,
     * Therefore, the view needs to redisplay some or all of itself.
     */
    if ( (pHint != NULL) &&
         (pHint->IsKindOf(RUNTIME_CLASS(CWinStationListObjectHint))) ) {

        CWinStationListObjectHint *pWSLOHint =
                            (CWinStationListObjectHint *)pHint;

        /*
         * If the hint's WinStation object pointer is not NULL, determine
         * if the view's fields need to expand, resetting the view if so.
         * Otherwise, just update the WinStation's row.
         */
        if ( pWSLOHint->m_pWSLObject &&
             CalculateFieldMaximums( pWSLOHint->m_pWSLObject,
                                     NULL, FALSE ) )
            ResetView(FALSE);
        else
            UpdateRow(pWSLOHint->m_WSLIndex);

    } else
        
        /*
         * Reset the entire view with new field calculations.
         */
        ResetView(TRUE);

}  // end CAppServerView::OnUpdate


/*******************************************************************************
 *
 *  GetRowWidthHeight -
 *      CAppServerView member function: CRowView class override
 *
 *      Get the view row width and height (based on current font).
 *
 *  ENTRY:
 *
 *      pDC (input)
 *          Points to the current CDC device-context object for the view.
 *
 *      nRowWidth (input)
 *          (REFERENCE) the variable to set to the current row width, in
 *          device units.
 *
 *      nRowHeight (input)
 *          (REFERENCE) the variable to set to the current row height, in
 *          device units.
 *
 *  EXIT:
 *
 ******************************************************************************/
 
void
CAppServerView::GetRowWidthHeight( CDC* pDC,
                                   int& nRowWidth,
                                   int& nRowHeight )
{
    int nDeviceTechnology;

    /*
     * If the previous CalculateFieldMaximums() calculations were made for
     * a different device type than this CDC is associated with, we must call
     * it again (with the CDC given here).
     *
     * BUGBUG: What about print-preview?  May need to compare mapping
     * modes (etc...) as well as device technology.  This may not work as is...
     */
    if ( (nDeviceTechnology = pDC->GetDeviceCaps( TECHNOLOGY )) !=
         m_nLatestDeviceTechnology ) {

        CalculateFieldMaximums( NULL, pDC, TRUE );
        m_nLatestDeviceTechnology = nDeviceTechnology;
    }

    /*
     * Set the row width.
     */
    nRowWidth = m_tmTotalWidth;

    /*
     * Always allow enough room for the bitmap height (plus one pixel spacing
     * on top and bottom) regardless of the font height.
     */
    if ( m_tmFontHeight > (BITMAP_HEIGHT + 2) )
        nRowHeight = m_tmFontHeight;
    else
        nRowHeight = BITMAP_HEIGHT + 2;

}  // end CAppServerView::GetRowWidthHeight


/*******************************************************************************
 *
 *  GetActiveRow -
 *      CAppServerView member function: CRowView class override
 *
 *      Get the currently active (highlighted) row in this view.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (int)
 *          active row for the view (from m_nActiveRow member variable).
 *
 ******************************************************************************/

int
CAppServerView::GetActiveRow()
{
    return (m_nActiveRow);
}  // end CAppServerView::GetActiveRow


/*******************************************************************************
 *
 *  GetRowCount -
 *      CAppServerView member function: CRowView class override
 *
 *      Get the total number of rows in the current view.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (int)
 *          number of rows (# of WinStationList items) in the document.
 *
 ******************************************************************************/

int
CAppServerView::GetRowCount()
{
    return ( GetDocument()->GetWSLCount() );

}  // end CAppServerView::GetRowCount


/*******************************************************************************
 *
 *  ChangeSelectionNextRow -
 *      CAppServerView member function: CRowView class override
 *
 *      Get the total number of rows in the current view.
 *
 *  ENTRY:
 *
 *      bNext (input)
 *          if TRUE, changes the view to select the next row;
 *          otherwise (FALSE), changes view to select previous row.
 *          This function won't do next or previous if boundry error would
 *          occur (list overrun or underrun).
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::ChangeSelectionNextRow( BOOL bNext )
{
    if ( bNext ) {

        if ( m_nActiveRow < (GetRowCount() - 1) )
            UpdateRow( ++m_nActiveRow );

    } else {

        if ( m_nActiveRow > 0 )
            UpdateRow( --m_nActiveRow );
    }
}  // end CAppServerView::ChangeSelectionNextRow


/*******************************************************************************
 *
 *  ChangeSelectionToRow -
 *      CAppServerView member function: CRowView class override
 *
 *      Cause the specified view row to be selected.
 *
 *  ENTRY:
 *
 *      nRow (input)
 *          view row to select.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::ChangeSelectionToRow( int nRow )
{
    UpdateRow( m_nActiveRow = nRow );
}  // end CAppServerView::ChangeSelectionToRow


/*******************************************************************************
 *
 *  OnDrawRow -
 *      CAppServerView member function: CRowView class override
 *
 *      Draw the specified row on the view.
 *
 *  ENTRY:
 *
 *      pDC (input)
 *          Points to the current CDC device-context object for the view
 *          to draw with (containing DC to draw into).
 *
 *      nRow (input)
 *          view row to draw (for obtaining document information).
 *
 *      y (input)
 *          y-position (in device coordinates) to draw the row at.
 *
 *      bSelected (input)
 *          TRUE if the row is currently selected (for highlighting);
 *          FALSE otherwise.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnDrawRow( CDC* pDC,
                           int nRow,
                           int y,
                           BOOL bSelected )
{
    int x;
    CFont * pOldFont;
    CBrush BackgroundBrush;

    /*
     * Select the app's font into the DC.
     */
    pOldFont = pDC->SelectObject(&(pApp->m_font));

    /*
     * Get the data for the specific WinStation list item.
     */
    PWSLOBJECT pWSLObject = GetDocument()->GetWSLObject(nRow);
    if ( !pWSLObject )
        return;

    /*
     * Prepare for highlighting or un-highlighting the check, depending
     * on whether it is the currently selected check or not.  And
     * paint the background (behind the text) accordingly.
     */

    /*
     * save colors for drawing selected item on the screen
     */
    COLORREF crOldText = 0;
    COLORREF crOldBackground = 0;

    if ( !pDC->IsPrinting() ) {

        /*                        
         * Create the proper background and text colors based on whether
         * WinStation selection state, operation state, and enabled/disabled.
         */
        if ( bSelected ) {

            BackgroundBrush.CreateSolidBrush( GetSysColor(COLOR_HIGHLIGHT) );
            crOldBackground = pDC->SetBkColor( GetSysColor(COLOR_HIGHLIGHT) );
            crOldText = pDC->SetTextColor( GetSysColor(COLOR_HIGHLIGHTTEXT) );

        } else {

            BackgroundBrush.CreateSolidBrush( GetSysColor(COLOR_WINDOW) );
            crOldBackground = pDC->SetBkColor( GetSysColor(COLOR_WINDOW) );
            crOldText = pDC->SetTextColor(
                                GetSysColor( pWSLObject->m_Flags & WSL_ENABLED ?
                                                COLOR_WINDOWTEXT : COLOR_GRAYTEXT ) );
        }

        /*
         * Fill the row with background color.
         */
        CRect rectSelection;
        pDC->GetClipBox( &rectSelection );
        rectSelection.top = y;
        rectSelection.bottom = y + m_nRowHeight;
        pDC->FillRect( &rectSelection, &BackgroundBrush );
    }

    /*
     * Display the class bitmap.
     */
    {
    CDC BitmapDC;
    CBitmap Bitmap, *pOldBitmap;
    UINT BitmapID;
    TEXTMETRIC tm;
    
    switch ( pWSLObject->m_SdClass ) {

        case SdAsync:
            BitmapID = (pWSLObject->m_Flags & WSL_ENABLED) ?
                        ((pWSLObject->m_Flags & WSL_DIRECT_ASYNC) ?
                         IDB_ASYNCDE :
                         ((pWSLObject->m_Flags & WSL_MUST_REBOOT) ? 
                                IDB_ASYNCMER : IDB_ASYNCME)) :
                        ((pWSLObject->m_Flags & WSL_DIRECT_ASYNC) ?
                         IDB_ASYNCDD : IDB_ASYNCMD);
            break;

        case SdNetwork:
            BitmapID = (pWSLObject->m_Flags & WSL_ENABLED) ?
                         IDB_NETWORKE : IDB_NETWORKD;
            break;

        case SdNasi:
            BitmapID = (pWSLObject->m_Flags & WSL_ENABLED) ?
                         IDB_NASIE : IDB_NASID;
            break;

        case SdConsole:
            BitmapID = (pWSLObject->m_Flags & WSL_ENABLED) ?
                         IDB_CONSOLEE : IDB_CONSOLED;
            break;

        case SdOemTransport:
            BitmapID = (pWSLObject->m_Flags & WSL_ENABLED) ?
                         IDB_OEMTDE : IDB_OEMTDD;
            break;
    }

    Bitmap.LoadBitmap( BitmapID );
    BitmapDC.CreateCompatibleDC( pDC );
    pOldBitmap = BitmapDC.SelectObject( &Bitmap );
    pDC->GetTextMetrics(&tm);
    pDC->BitBlt( BITMAP_X, (tm.tmHeight > (BITMAP_HEIGHT + 2)) ?
                           (y + ((tm.tmHeight - BITMAP_HEIGHT) / 2)) : (y + 1),
                 BITMAP_WIDTH, BITMAP_HEIGHT, &BitmapDC,
                 0, 0, (bSelected ? MERGEPAINT : SRCAND) );
    BitmapDC.SelectObject( pOldBitmap );
    }

    x = BITMAP_END + m_tmSpacerWidth;

    /*
     * Display the WinStation Name.
     */
    pDC->TextOut( x, y,
                  pWSLObject->m_WinStationName,
                  lstrlen(pWSLObject->m_WinStationName) );

    /*
     * Display the Transport Name (1st Pd).
     */
    pDC->TextOut( (x += m_tmMaxWSNameWidth + m_tmSpacerWidth),
                  y, pWSLObject->m_PdName,
                  lstrlen(pWSLObject->m_PdName) );

    /*
     * Display the Wd Name (Type).
     */
    pDC->TextOut( (x += m_tmMaxPdNameWidth + m_tmSpacerWidth),
                  y, pWSLObject->m_WdName,
                  lstrlen(pWSLObject->m_WdName) );

    /*
     * Display the WinStation Comment (including prefixed device name for
     * SdAsync and single-instance PdOemTransport display).
     */
    {
    TCHAR szBuffer[WINSTATIONCOMMENT_LENGTH + lengthof(pWSLObject->m_DeviceName) + 2];

    if ( (pWSLObject->m_SdClass == SdAsync) ||
         ((pWSLObject->m_SdClass == SdOemTransport) &&
          (pWSLObject->m_Flags & WSL_SINGLE_INST)) ) {

        lstrcpy( szBuffer, pWSLObject->m_DeviceName );
        lstrcat( szBuffer, TEXT(": ") );
    } else {
        szBuffer[0] = TEXT('\0');
    }
    lstrcat( szBuffer, pWSLObject->m_Comment );
    pDC->TextOut( (x += m_tmMaxWdNameWidth + m_tmSpacerWidth),
                  y, szBuffer, lstrlen(szBuffer) );
    }

    /*
     * Restore the DC.
     */
    if ( !pDC->IsPrinting() ) {

        pDC->SetBkColor(crOldBackground);
        pDC->SetTextColor(crOldText);
    }

    /*
     * Restore the old font.
     */
    pDC->SelectObject(pOldFont);

}  // end CAppServerView::OnDrawRow


/*******************************************************************************
 *
 *  OnDrawHeaderBar -
 *      CAppServerView member function: CRowView class override
 *
 *      Draw the view's header bar.
 *
 *  ENTRY:
 *
 *      pDC (input)
 *          Points to the current CDC device-context object for the header bar.
 *
 *      y (input)
 *          y-position (in device coordinates) to draw header bar text at.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnDrawHeaderBar( CDC* pDC,
                                 int y )
{
    /*
     * Select the header bar font, background drawing mode, text color, and
     * background color.
     */
    HGDIOBJ hOldFont = pDC->SelectObject( m_pHeaderBar->GetFont() );
    int nOldMode = pDC->SetBkMode( TRANSPARENT );
    COLORREF crTextColor = pDC->SetTextColor( GetSysColor( COLOR_BTNTEXT ) );
    COLORREF crBkColor = pDC->SetBkColor( GetSysColor( COLOR_BTNFACE ) );

    /*
     * Modify the window (DC) viewport origin to account for the current
     * horizontal scrolling state of the attached view.
     */
    CPoint ptVpOrg = -GetDeviceScrollPosition();
    ptVpOrg.y = 0;
    pDC->SetViewportOrg( ptVpOrg );

    /*
     * Display header text and dividing bars.
     */
    CString str;
    int x = BITMAP_END + m_tmSpacerWidth;

    /*
     * Display the WinStation Name header
     */
    str.LoadString( IDS_HEADER_WINSTATIONNAME );
    pDC->TextOut( x, y, str, lstrlen(str) );
    pDC->MoveTo( x-3, y );
    pDC->LineTo( x-3, y + m_tmFontHeight );

    /*
     * Display the Transport header.
     */
    str.LoadString( IDS_HEADER_TRANSPORTNAME );
    pDC->TextOut( (x += m_tmMaxWSNameWidth + m_tmSpacerWidth),
                  y, str, lstrlen(str) );
    pDC->MoveTo( x-3, y );
    pDC->LineTo( x-3, y + m_tmFontHeight );

    /*
     * Display the Type header
     */
    str.LoadString( IDS_HEADER_TYPENAME );
    pDC->TextOut( (x += m_tmMaxPdNameWidth + m_tmSpacerWidth),
                  y, str, lstrlen(str) );
    pDC->MoveTo( x-3, y );
    pDC->LineTo( x-3, y + m_tmFontHeight );

    /*
     * Display the WinStation Comment header
     */
    str.LoadString( IDS_HEADER_COMMENT );
    pDC->TextOut( (x += m_tmMaxWdNameWidth + m_tmSpacerWidth),
                  y, str, lstrlen(str) );
    pDC->MoveTo( x-3, y );
    pDC->LineTo( x-3, y + m_tmFontHeight );

    /*
     * Select the original stuff back into the DC.
     */
    pDC->SelectObject( hOldFont );
    pDC->SetBkMode( nOldMode );
    pDC->SetTextColor( crTextColor );
    pDC->SetBkColor( crBkColor );

}  // end CAppServerView::OnDrawHeaderBar


/*******************************************************************************
 *
 *  ResetHeaderBar - CAppServerView member function: CRowView class override
 *
 *      Set the font for the header bar and call the CRowView ResetHeaderBar()
 *      member function.
 *
 ******************************************************************************/

void
CAppServerView::ResetHeaderBar()
{
    /*
     * Set the header bar's font to the app's current font.
     *
     * BUGBUG: we may want to have the header font be different from the
     * view (app) font.  It could be set here.
     */
    m_pHeaderBar->SetFont( &(((CWincfgApp *)AfxGetApp())->m_font) );

    /*
     * Call the CRowView ResetHeaderBar member function to finish up.
     */
    CRowView::ResetHeaderBar();

}  // end CAppServerView::ResetHeaderBar


////////////////////////////////////////////////////////////////////////////////
// CAppServerView operations

/*******************************************************************************
 *
 *  ResetView - CAppServerView member function: public operation
 *
 *      Reset the view for complete update, including the header bar.
 *
 *  ENTRY:
 *      bCalculateFieldMaximums (input)
 *          TRUE if request to recalculate the maximum sizes of each field in
 *          the view, based on the current WSL contents; FALSE otherwise.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::ResetView( BOOL bCalculateFieldMaximums )
{
    /*
     * Calculate field maximum values if requested (default to screen DC).
     * The bCalculateFieldMaximums flag will generally be set to TRUE when
     * ResetView is called after a font change or for complete view reset;
     * FALSE when called after a row update (change) has occurred that was
     * already handled by an explicit CalculateFieldMaximums() call.
     */
    if ( bCalculateFieldMaximums )
        CalculateFieldMaximums( NULL, NULL, TRUE );

    /*
     * Reset the header bar, which will cause the parent frame's layout to be
     * recalculated.
     */
    ResetHeaderBar();

    /*
     * Invalidate the entire view to cause full repaint and update the scroll
     * sizes for this view.
     */
    Invalidate();
    UpdateScrollSizes();

}  // end CAppServerView::ResetView


/*******************************************************************************
 *
 *  CalculateFieldMaximums - CAppServerView member function: private operation
 *
 *      Recalculate the maximum width for each display field in the view.
 *
 *  ENTRY:
 *      pWSLObject (input)
 *          Points to WSLObject to use for new maximum calculation;  if this is
 *          NULL, then will traverse the entire WSL to recalculate maximums.
 *      pEntryDC (input)
 *          Points to the CDC object to use for the GetTextExtent() calls; if
 *          NULL then will open up a screen DC to use.
 *      bResetDefaults (input)
 *          TRUE to reset the minimum field sizes to the sizes of the header
 *          bar text for each field; FALSE for no such reset.
 *
 *  EXIT:
 *      (BOOL) TRUE if new maximum(s) were set; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CAppServerView::CalculateFieldMaximums( PWSLOBJECT pWSLObject,
                                        CDC * pEntryDC,
                                        BOOL bResetDefaults )
{
    BOOL bNewMaximums = FALSE;
    TEXTMETRIC tm;
    CDC *pDC, DC;
    CFont * pOldFont;

    /*
     * If the given CDC is NULL, open up a screen DC and point to it.
     * Otherwise, point to the one given.
     */
    if ( pEntryDC == NULL ) {

        DC.CreateCompatibleDC( NULL );
        pDC = &DC;

    } else
        pDC = pEntryDC;

    /*
     * Select the app's font into the DC and get the text metrics.
     */
    pOldFont = pDC->SelectObject( &(pApp->m_font) );
    pDC->GetTextMetrics( &tm );

    /*
     * If the bResetDefaults flag is TRUE, establish the default field
     * widths based on the width required for the field's header.
     */
    if ( bResetDefaults ) {
        CString str;

        str.LoadString( IDS_HEADER_TRANSPORTNAME );
        m_tmMaxPdNameWidth = (pDC->GetTextExtent( str, lstrlen(str) )).cx;

        str.LoadString( IDS_HEADER_WINSTATIONNAME );
        m_tmMaxWSNameWidth = (pDC->GetTextExtent( str, lstrlen(str) )).cx;

        str.LoadString( IDS_HEADER_TYPENAME );
        m_tmMaxWdNameWidth = (pDC->GetTextExtent( str, lstrlen(str) )).cx;

        str.LoadString( IDS_HEADER_COMMENT );
        m_tmMaxCommentWidth = (pDC->GetTextExtent( str, lstrlen(str) )).cx;
    }

    /*
     * Establish the inter-field spacer width and save the font height
     * to use in GetRowWidthHeight() calculations.
     */
    m_tmSpacerWidth = SPACER_COLUMNS * tm.tmAveCharWidth;
    m_tmFontHeight = tm.tmHeight;

    /*
     * Determine new field maximums based on GetTextExtent calls with actual
     * WSLObject strings.
     */
    if ( pWSLObject ) {

        /*
         * A WSLObject was specified.  Determine if that one causes new
         * field maximums.
         */
         bNewMaximums = WSLObjectFieldMaximums( pWSLObject, pDC );

    } else {

        /*
         * No WSLObject was specified.  Traverse the entire WinStation Object
         * List
         */
        int i, count = GetRowCount();

        for ( i = 0; i < count; i++ ) {
        
            if ( (pWSLObject = GetDocument()->GetWSLObject( i )) )
                bNewMaximums = WSLObjectFieldMaximums( pWSLObject, pDC );
        }
    }

    /*
     * Set the total line width variable.
     */
    m_tmTotalWidth = BITMAP_END + m_tmSpacerWidth +
                     m_tmMaxWSNameWidth + m_tmSpacerWidth +
                     m_tmMaxPdNameWidth + m_tmSpacerWidth +
                     m_tmMaxWdNameWidth + m_tmSpacerWidth +
                     m_tmMaxCommentWidth + m_tmSpacerWidth;

    /*
     * Select the original font back into the DC.
     */
    pDC->SelectObject( pOldFont );

    return ( bNewMaximums );

}  // end CAppServerView::CalculateFieldMaximums


/*******************************************************************************
 *
 *  WSLObjectFieldMaximums - CAppServerView member function: private operation
 *
 *      Calculate display field sizes for the viewable items in a WSLObject,
 *      resetting the maximum view field sizes if necessary.
 *
 *  ENTRY:
 *      pWSLObject (input)
 *          Points to WSLObject to use for new maximum calculation.
 *      pEntryDC (input)
 *          Points to the CDC object to use for the GetTextExtent() calls.
 *
 *  EXIT:
 *      (BOOL) TRUE if new maximum(s) were set; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CAppServerView::WSLObjectFieldMaximums( PWSLOBJECT pWSLObject,
                                        CDC * pDC )
{
    CSize strSize;
    BOOL bNewMaximums = FALSE;

    /*
     * WinStation name.
     */
    strSize = pDC->GetTextExtent( pWSLObject->m_WinStationName,
                                  lstrlen(pWSLObject->m_WinStationName) );
    if ( strSize.cx > m_tmMaxWSNameWidth ) {
        m_tmMaxWSNameWidth = strSize.cx;
        bNewMaximums = TRUE;
    }

    /*
     * Transport (1st Pd) Name.
     */
    strSize = pDC->GetTextExtent( pWSLObject->m_PdName,
                                  lstrlen(pWSLObject->m_PdName) );
    if ( strSize.cx > m_tmMaxPdNameWidth ) {
        m_tmMaxPdNameWidth = strSize.cx;
        bNewMaximums = TRUE;
    }

    /*
     * Wd Name.
     */
    strSize = pDC->GetTextExtent( pWSLObject->m_WdName,
                                  lstrlen(pWSLObject->m_WdName) );
    if ( strSize.cx > m_tmMaxWdNameWidth ) {
        m_tmMaxWdNameWidth = strSize.cx;
        bNewMaximums = TRUE;
    }

    /*
     * Comment (including prefixed device name for SdAsync and single-instance
     * PdOemTransport display).
     */
    strSize = pDC->GetTextExtent( pWSLObject->m_Comment,
                                  lstrlen(pWSLObject->m_Comment) );

    if ( (pWSLObject->m_SdClass == SdAsync) ||
         ((pWSLObject->m_SdClass == SdOemTransport) &&
          (pWSLObject->m_Flags & WSL_SINGLE_INST)) ) {

        CSize strSize2;

        strSize2 = pDC->GetTextExtent( pWSLObject->m_DeviceName,
                                       lstrlen(pWSLObject->m_DeviceName) );
        strSize.cx += strSize2.cx;

        strSize2 = pDC->GetTextExtent( TEXT(": "), 2 );
        strSize.cx += strSize2.cx;
    }

    if ( strSize.cx > m_tmMaxCommentWidth ) {
        m_tmMaxCommentWidth = strSize.cx;
        bNewMaximums = TRUE;
    }

    return ( bNewMaximums );

}  // end CAppServerView::WSLObjectFieldMaximums


////////////////////////////////////////////////////////////////////////////////
// CAppServerView message map

BEGIN_MESSAGE_MAP(CAppServerView, CRowView)
    //{{AFX_MSG_MAP(CAppServerView)
    ON_WM_CREATE()
    ON_COMMAND(ID_WINSTATION_ADD, OnWinStationAdd)
    ON_UPDATE_COMMAND_UI(ID_WINSTATION_ADD, OnUpdateWinStationAdd)
    ON_COMMAND(ID_WINSTATION_COPY, OnWinStationCopy)
    ON_UPDATE_COMMAND_UI(ID_WINSTATION_COPY, OnUpdateWinStationCopy)
    ON_COMMAND(ID_WINSTATION_DELETE, OnWinStationDelete)
    ON_UPDATE_COMMAND_UI(ID_WINSTATION_DELETE, OnUpdateWinStationDelete)
    ON_COMMAND(ID_WINSTATION_RENAME, OnWinStationRename)
    ON_UPDATE_COMMAND_UI(ID_WINSTATION_RENAME, OnUpdateWinStationRename)
    ON_COMMAND(ID_WINSTATION_EDIT, OnWinStationEdit)
    ON_UPDATE_COMMAND_UI(ID_WINSTATION_EDIT, OnUpdateWinStationEdit)
    ON_COMMAND(ID_WINSTATION_ENABLE, OnWinStationEnable)
    ON_UPDATE_COMMAND_UI(ID_WINSTATION_ENABLE, OnUpdateWinStationEnable)
    ON_COMMAND(ID_WINSTATION_DISABLE, OnWinStationDisable)
    ON_UPDATE_COMMAND_UI(ID_WINSTATION_DISABLE, OnUpdateWinStationDisable)
    ON_WM_LBUTTONDBLCLK()
    ON_COMMAND(ID_WINSTATION_NEXT, OnWinStationNext)
    ON_UPDATE_COMMAND_UI(ID_WINSTATION_NEXT, OnUpdateWinStationNext)
    ON_COMMAND(ID_WINSTATION_PREV, OnWinStationPrev)
    ON_UPDATE_COMMAND_UI(ID_WINSTATION_PREV, OnUpdateWinStationPrev)
    ON_COMMAND(ID_SECURITY_PERMISSIONS, OnSecurityPermissions)
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


////////////////////////////////////////////////////////////////////////////////
// CAppServerView commands

/*******************************************************************************
 *
 *  OnCreate - CAppServerView member function: command
 *
 *      Perform initialization when view is created.
 *
 *  ENTRY:
 *  EXIT:
 *      (refer to CWnd::OnCreate documentation)
 *
 ******************************************************************************/

int
CAppServerView::OnCreate( LPCREATESTRUCT lpCreateStruct )
{
    /*
     * Construct a new instance of a CRowViewHeaderBar object and set the
     * m_bAutoDelete member variable (defined in CControlBar class) to TRUE
     * to cause the object to be deleted automatically when the windows control
     * bar is destroyed.  The CRowView's OnCreate will see that the m_pHeaderBar
     * member variable is not NULL and will actually create the header bar via
     * its Create() member function.
     */
    m_pHeaderBar = new CRowViewHeaderBar;
    m_pHeaderBar->m_bAutoDelete = TRUE;
        
    /*
     * Call the CRowView parent class OnCreate.
     */
    if ( CRowView::OnCreate( lpCreateStruct ) == -1 )
        return(-1);

    /*
     * Reset the view (with calculating new field maximums).
     */
    ResetView(TRUE);

    return( 0 );

}  // end CAppServerView::OnCreate


/*******************************************************************************
 *
 *  OnWinStationAdd - CAppServerView member function: command
 *
 *      Process the "add winstation" command.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnWinStationAdd()
{
    int nRow;

    /*
     * Only process add if it is allowed.
     */
    if ( GetDocument()->IsAddAllowed(m_nActiveRow) ) {

        if ( (nRow = GetDocument()->AddWinStation(m_nActiveRow)) != -1 )
            m_nPrevSelectedRow = m_nActiveRow = nRow;
    }

}  // end CAppServerView::OnWinStationAdd


/*******************************************************************************
 *
 *  OnUpdateWinStationAdd - CAppServerView member function: command
 *
 *      Enable or disable the "add winstation" command depending on whether
 *      or not it is allowed on the active row's WinStation.
 *
 *  ENTRY:
 *      pCndUI (input)
 *          Points to the CCmdUI object of the "add winstation"
 *          command item.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnUpdateWinStationAdd( CCmdUI* pCmdUI )
{
    pCmdUI->Enable( GetDocument()->IsAddAllowed(m_nActiveRow) ?
                        TRUE : FALSE );

}  // end CAppServerView::OnUpdateWinStationAdd


/*******************************************************************************
 *
 *  OnWinStationCopy - CAppServerView member function: command
 *
 *      Process the "copy winstation" command.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnWinStationCopy()
{
    int nRow;

    /*
     * Only process copy if it is allowed.
     */
    if ( GetDocument()->IsCopyAllowed(m_nActiveRow) ) {

        if ( (nRow = GetDocument()->CopyWinStation(m_nActiveRow)) != -1 )
            m_nPrevSelectedRow = m_nActiveRow = nRow;
    }

}  // end CAppServerView::OnWinStationCopy


/*******************************************************************************
 *
 *  OnUpdateWinStationCopy - CAppServerView member function: command
 *
 *      Enable or disable the "copy winstation" command depending on whether
 *      or not it is allowed on the active row's WinStation.
 *
 *  ENTRY:
 *      pCndUI (input)
 *          Points to the CCmdUI object of the "copy winstation"
 *          command item.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnUpdateWinStationCopy( CCmdUI* pCmdUI )
{
    pCmdUI->Enable( GetDocument()->IsCopyAllowed(m_nActiveRow) ?
                        TRUE : FALSE );

}  // end CAppServerView::OnUpdateWinStationCopy


/*******************************************************************************
 *
 *  OnWinStationDelete - CAppServerView member function: command
 *
 *      Process the "delete winstation" command.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnWinStationDelete()
{
    /*
     * Only process delete if it is allowed.
     */
    if ( GetDocument()->IsDeleteAllowed(m_nActiveRow) ) {

        if ( GetDocument()->DeleteWinStation(m_nActiveRow) ) {

            if ( (m_nActiveRow >= GetRowCount()) && GetRowCount() )
                m_nPrevSelectedRow = m_nActiveRow = (GetRowCount() - 1);
        }
    }

}  // end CAppServerView::OnWinStationDelete


/*******************************************************************************
 *
 *  OnUpdateWinStationDelete - CAppServerView member function: command
 *
 *      Enable or disable the "delete winstation" command depending on whether
 *      or not it is allowed on the active row's WinStation.
 *
 *  ENTRY:
 *      pCndUI (input)
 *          Points to the CCmdUI object of the "delete winstation"
 *          command item.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnUpdateWinStationDelete( CCmdUI* pCmdUI )
{
    pCmdUI->Enable( GetDocument()->IsDeleteAllowed(m_nActiveRow) ?
                        TRUE : FALSE );

}  // end CAppServerView::OnUpdateWinStationDelete


/*******************************************************************************
 *
 *  OnWinStationRename - CAppServerView member function: command
 *
 *      Process the "rename winstation" command.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnWinStationRename()
{
    int nRow;

    /*
     * Only process rename if it is allowed.
     */
    if ( GetDocument()->IsRenameAllowed(m_nActiveRow) ) {

        if ( (nRow = GetDocument()->RenameWinStation(m_nActiveRow)) != -1 )
            m_nPrevSelectedRow = m_nActiveRow = nRow;
    }

}  // end CAppServerView::OnWinStationRename


/*******************************************************************************
 *
 *  OnUpdateWinStationRename - CAppServerView member function: command
 *
 *      Enable or disable the "rename winstation" command depending on whether
 *      or not it is allowed on the active row's WinStation.
 *
 *  ENTRY:
 *      pCndUI (input)
 *          Points to the CCmdUI object of the "rename winstation"
 *          command item.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnUpdateWinStationRename(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( GetDocument()->IsRenameAllowed(m_nActiveRow) ?
                        TRUE : FALSE );

}  // end CAppServerView::OnUpdateWinStationRename


/*******************************************************************************
 *
 *  OnWinStationEdit - CAppServerView member function: command
 *
 *      Process the "edit winstation" command.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnWinStationEdit()
{
    int nRow;

    /*
     * Only process edit if it is allowed.
     */
    if ( GetDocument()->IsEditAllowed(m_nActiveRow) ) {

        if ( (nRow = GetDocument()->EditWinStation(m_nActiveRow)) != -1 )
            m_nPrevSelectedRow = m_nActiveRow = nRow;
    }

}  // end CAppServerView::OnWinStationEdit


/*******************************************************************************
 *
 *  OnUpdateWinStationEdit - CAppServerView member function: command
 *
 *      Enable or disable the "edit winstation" command depending on whether
 *      or not it is allowed on the active row's WinStation.
 *
 *  ENTRY:
 *      pCndUI (input)
 *          Points to the CCmdUI object of the "edit winstation" command item.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnUpdateWinStationEdit(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( GetDocument()->IsEditAllowed(m_nActiveRow) ?
                        TRUE : FALSE );

}  // end CAppServerView::OnUpdateWinStationEdit


/*******************************************************************************
 *
 *  OnWinStationEnable - CAppServerView member function: command
 *
 *      Process the "enable winstation" command.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnWinStationEnable()
{
    /*
     * Only process enable if it is allowed.
     */
    if ( GetDocument()->IsEnableAllowed(m_nActiveRow, TRUE ) )
        GetDocument()->EnableWinStation( m_nActiveRow, TRUE );

}  // end CAppServerView::OnWinStationEnable


/*******************************************************************************
 *
 *  OnUpdateWinStationEnable - CAppServerView member function: command
 *
 *      Enable or disable the "enable winstation" command depending on
 *      whether or not it is allowed on the active row's WinStation.
 *
 *  ENTRY:
 *      pCndUI (input)
 *          Points to the CCmdUI object of the "enable winstation"
 *          command item.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnUpdateWinStationEnable(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( GetDocument()->IsEnableAllowed( m_nActiveRow, TRUE ) ?
                        TRUE : FALSE );

}  // end CAppServerView::OnUpdateWinStationEnable


/*******************************************************************************
 *
 *  OnWinStationDisable - CAppServerView member function: command
 *
 *      Process the "disable winstation" command.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnWinStationDisable()
{
    /*
     * Only process disable if it is allowed.
     */
    if ( GetDocument()->IsEnableAllowed( m_nActiveRow, FALSE ) )
        GetDocument()->EnableWinStation( m_nActiveRow, FALSE );

}  // end CAppServerView::OnWinStationDisable


/*******************************************************************************
 *
 *  OnUpdateWinStationDisable - CAppServerView member function: command
 *
 *      Enable or disable the "disable winstation" command depending on
 *      whether or not it is allowed on the active row's WinStation.
 *
 *  ENTRY:
 *      pCndUI (input)
 *          Points to the CCmdUI object of the "disable winstation"
 *          command item.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnUpdateWinStationDisable(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( GetDocument()->IsEnableAllowed( m_nActiveRow, FALSE ) ?
                        TRUE : FALSE );

}  // end CAppServerView::OnUpdateWinStationDisable


/*******************************************************************************
 *
 *  OnLButtonDblClk - CAppServerView member function: command
 *
 *      Process a left mouse button double-click as an "edit winstation"
 *      command.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to the CWnd::OnLButtonCblClk documentation)
 *
 ******************************************************************************/

void CAppServerView::OnLButtonDblClk(UINT nFlags, CPoint point)
{
    /*
     * Let the parent class process the message first.
     */
    CRowView::OnLButtonDblClk(nFlags, point);

    /*
     * Treat this as a 'Edit/View WinStation' request.
     */
    OnWinStationEdit();

}  // end CAppServerView::OnLButtonDblClk


/*******************************************************************************
 *
 *  OnWinStationNext - CAppServerView member function: command
 *
 *      Processes the "next winstation" command by calling the
 *      ChangeSelectionNextRow function with argument TRUE.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnWinStationNext()
{
    ChangeSelectionNextRow(TRUE);

}  // end CAppServerView::OnWinStationNext


/*******************************************************************************
 *
 *  OnUpdateWinStationNext - CAppServerView member function: command
 *
 *      Enables or disables the "next winstation" command item based on
 *      whether or not we're at the end of the view's list.
 *
 *  ENTRY:
 *      pCndUI (input)
 *          Points to the CCmdUI object of the "next winstation"
 *          command item.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnUpdateWinStationNext( CCmdUI* pCmdUI )
{
    pCmdUI->Enable( (m_nActiveRow < (GetRowCount() - 1)) ? TRUE : FALSE );

}  // end CAppServerView::OnUpdateWinStationNext


/*******************************************************************************
 *
 *  OnWinStationPrev - CAppServerView member function: command
 *
 *      Processes the "previous winstation" command by calling the
 *      ChangeSelectionNextRow function with argument FALSE.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnWinStationPrev()
{
    ChangeSelectionNextRow(FALSE);

}  // end CAppServerView::OnWinStationPrev


/*******************************************************************************
 *
 *  OnUpdateWinStationPrev - CAppServerView member function: command
 *
 *      Enables or disables the "previous winstation" command item based on
 *      whether or not we're at the beginning of the view's list.
 *
 *  ENTRY:
 *      pCndUI (input)
 *          Points to the CCmdUI object of the "next winstation"
 *          command item.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnUpdateWinStationPrev( CCmdUI* pCmdUI )
{
    pCmdUI->Enable( (m_nActiveRow > 0) ? TRUE : FALSE );

}  // end CAppServerView::OnUpdateWinStationPrev


/*******************************************************************************
 *
 *  OnSecurityPermissions - CAppServerView member function: command
 *
 *      Process the "Permissions..." command.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAppServerView::OnSecurityPermissions()
{
    GetDocument()->SecurityPermissions(m_nActiveRow);
    
}  // end CAppServerView::OnSecurityPermissions


void CAppServerView::OnRButtonDown(UINT nFlags, CPoint point) 
{
    CRect rect(point, CSize(1,1));

    int nFirstRow, nLastRow;
    RectLPtoRowRange(rect, nFirstRow, nLastRow, TRUE);

    if (nFirstRow <= (GetRowCount() - 1))
        ChangeSelectionToRow(nFirstRow);
	
	//CRowView::OnRButtonDown(nFlags, point);
}

void CAppServerView::OnRButtonUp(UINT nFlags, CPoint point) 
{
    CRect rect(point, CSize(1,1));

    int nFirstRow, nLastRow;
    RectLPtoRowRange(rect, nFirstRow, nLastRow, TRUE);

    if(nFirstRow == GetActiveRow()) {
        ::GetCursorPos(&point);
        CMenu menu;
        if(menu.LoadMenu(IDR_POPUP)) {   
            menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN|TPM_RIGHTBUTTON,
                point.x, point.y, AfxGetMainWnd());
            menu.DestroyMenu();
        }    
    }
	
	//CRowView::OnRButtonUp(nFlags, point);
}


////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\anasidlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* anasidlg.h
*
* interface of CAdvancedNASIDlg dialog class
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\ANASIDLG.H  $
*  
*     Rev 1.1   16 Nov 1995 17:11:40   butchd
*  update
*  
*     Rev 1.0   09 Jul 1995 15:11:12   butchd
*  Initial revision.
*
*******************************************************************************/

/*
 * Include the base dialog class.
 */
#include "basedlg.h"

////////////////////////////////////////////////////////////////////////////////
// CAdvancedNASIDlg class
//
class CAdvancedNASIDlg : public CBaseDialog
{

/*
 * Member variables.
 */
    //{{AFX_DATA(CAdvancedNASIDlg)
    enum { IDD = IDD_NASI_ADVANCED };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA
public:
    NASICONFIG m_NASIConfig;
    BOOL m_bReadOnly;

/* 
 * Implementation.
 */
public:
    CAdvancedNASIDlg();

/*
 * Operations.
 */
protected:
    void SetFields();
    BOOL GetFields();

/*
 * Message map / commands.
 */
protected:
    //{{AFX_MSG(CAdvancedNASIDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  // end CAdvancedNASIDlg class interface
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\atdlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* atdlg.h
*
* interface of WINCFG CAsyncTestDlg, CEchoEditControl, and CLed classes 
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\ATDLG.H  $
*  
*     Rev 1.5   12 Sep 1996 16:16:00   butchd
*  update
*
*******************************************************************************/

/*
 * Include the base dialog and led classes.
 */
#include "basedlg.h"
#include "led.h"

////////////////////////////////////////////////////////////////////////////////
// CEchoEditControl class
//
class CEchoEditControl : public CEdit
{
friend class CAsyncTestDlg;

/*
 * Member variables.
 */
public:
    BOOL m_bProcessingOutput;
    HWND m_hDlg;
    int m_FontHeight;
    int m_FontWidth;
    int m_FormatOffsetX;
    int m_FormatOffsetY;

/*
 * Message map / commands.
 */
protected:
    //{{AFX_MSG(CEchoEditControl)
    afx_msg void OnChar (UINT nChar, UINT nRepCnt, UINT nFlags);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  // end CEchoEditControl class interface
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg class
//
#define NUM_LEDS    6

class CAsyncTestDlg : public CBaseDialog
{

/*
 * Member variables.
 */
    //{{AFX_DATA(CAsyncTestDlg)
    enum { IDD = IDD_ASYNC_TEST };
    //}}AFX_DATA
public:
    PDCONFIG m_PdConfig0;
    PDCONFIG m_PdConfig1;
    PWINSTATIONNAME m_pWSName;

protected:
    CEchoEditControl m_EditControl;
    HANDLE  m_hDevice;
    HBRUSH  m_hRedBrush;
    UINT    m_LEDToggleTimer;
    PROTOCOLSTATUS m_Status;
    CATDlgInputThread *m_pATDlgInputThread;
    OVERLAPPED m_OverlapWrite;
    BYTE    m_Buffer[MAX_COMMAND_LEN+1];
    int     m_CurrentPos;
    DWORD   m_BufferBytes;
    TCHAR   m_szModemInit[MAX_COMMAND_LEN+1];
    TCHAR   m_szModemDial[MAX_COMMAND_LEN+1];
    TCHAR   m_szModemListen[MAX_COMMAND_LEN+1];
    HANDLE  m_hModem;
    BOOL    m_bDeletedWinStation;
    CLed *  m_pLeds[NUM_LEDS];
    WINSTATIONCONFIG2 m_WSConfig;

/* 
 * Implementation.
 */
public:
    CAsyncTestDlg();
    ~CAsyncTestDlg();

/*
 * Operations.
 */
protected:
    void NotifyAbort( UINT idError );
    BOOL DeviceSetParams();
    BOOL DeviceWrite();
    void SetInfoFields( PPROTOCOLSTATUS pCurrent, PPROTOCOLSTATUS pNew );
    void OutputToEditControl( BYTE *pBuffer, int *pIndex );

/*
 * Message map / commands.
 */
protected:
    //{{AFX_MSG(CAsyncTestDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnTimer(UINT nIDEvent);
    afx_msg LRESULT OnAsyncTestError(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAsyncTestAbort(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAsyncTestStatusReady(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAsyncTestInputReady(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAsyncTestWriteChar(WPARAM wParam, LPARAM lParam);
    afx_msg void OnClickedAtdlgModemDial();
    afx_msg void OnClickedAtdlgModemInit();
    afx_msg void OnClickedAtdlgModemListen();
	afx_msg void OnNcDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  // end CAsyncTestDlg class interface 

#define ASYNC_LED_TOGGLE_MSEC   200
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\appsvvw.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* appsvvw.h
*
* interface of the CAppServerView class
*
* copyright notice: Copyright 1994, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   M:\nt\private\utils\citrix\winutils\wincfg\VCS\appsvvw.h  $
*  
*     Rev 1.10   22 Oct 1997 09:43:58   butchd
*  MS changes: added r-button popup menu
*  
*     Rev 1.9   12 Sep 1996 16:15:54   butchd
*  update
*
*******************************************************************************/

#define BITMAP_HEIGHT       15      // class bitmap height
#define BITMAP_WIDTH        25      // class bitmap height
#define BITMAP_X            5       // class bitmap starting display x-point

#define BITMAP_END          (BITMAP_X + BITMAP_WIDTH)

#define SPACER_COLUMNS      3       // inter-field spacing

////////////////////////////////////////////////////////////////////////////////
// CAppServerView class
//
class CAppServerView : public CRowView
{
    DECLARE_DYNCREATE(CAppServerView)

/*
 * Member variables.
 */
protected:
    int m_nActiveRow;
    int m_nLatestDeviceTechnology;
    int m_tmMaxPdNameWidth;
    int m_tmMaxWSNameWidth;
    int m_tmMaxWdNameWidth;
    int m_tmMaxCommentWidth;
    int m_tmTotalWidth;
    int m_tmSpacerWidth;
    int m_tmFontHeight;
                
/*
 * Implementation
 */
public:
    CAppServerView();
protected:
    virtual ~CAppServerView();

/*
 * Overrides of MFC CView class
 */
public:
    CAppServerDoc* GetDocument();

protected:
    void OnUpdate( CView* pSender, LPARAM lHint = 0L,
                   CObject* pHint = NULL );

/*
 * Overrides of CRowView class
 */
protected:
    void GetRowWidthHeight( CDC* pDC, int& nRowWidth, int& nRowHeight );
    int GetActiveRow();
    int GetRowCount();
    void ChangeSelectionNextRow( BOOL bNext );
    void ChangeSelectionToRow( int nRow );
    void OnDrawRow( CDC* pDC, int nRowNo, int y, BOOL bSelected );
    void OnDrawHeaderBar( CDC* pDC, int y );
    void ResetHeaderBar();

/*
 * Operations
 */
public:
    void ResetView( BOOL bCalculateFieldMaximums );
protected:
    BOOL CalculateFieldMaximums( PWSLOBJECT pWSLObject,
                                 CDC * pEntryDC,
                                 BOOL bResetDefaults );
    BOOL WSLObjectFieldMaximums( PWSLOBJECT pWSLObject,
                                 CDC * pDC );
/*
 * Message map / commands
 */
protected:
    //{{AFX_MSG(CAppServerView)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnWinStationAdd();
    afx_msg void OnUpdateWinStationAdd( CCmdUI* pCmdUI );
    afx_msg void OnWinStationCopy();
    afx_msg void OnUpdateWinStationCopy( CCmdUI* pCmdUI );
    afx_msg void OnWinStationDelete();
    afx_msg void OnUpdateWinStationDelete( CCmdUI* pCmdUI );
    afx_msg void OnWinStationRename();
    afx_msg void OnUpdateWinStationRename(CCmdUI* pCmdUI);
    afx_msg void OnWinStationEdit();
    afx_msg void OnUpdateWinStationEdit(CCmdUI* pCmdUI);
    afx_msg void OnWinStationEnable();
    afx_msg void OnUpdateWinStationEnable(CCmdUI* pCmdUI);
    afx_msg void OnWinStationDisable();
    afx_msg void OnUpdateWinStationDisable(CCmdUI* pCmdUI);
    afx_msg void OnLButtonDblClk( UINT nFlags, CPoint point );
    afx_msg void OnWinStationNext();
    afx_msg void OnUpdateWinStationNext( CCmdUI* pCmdUI );
    afx_msg void OnWinStationPrev();
    afx_msg void OnUpdateWinStationPrev( CCmdUI* pCmdUI );
	afx_msg void OnSecurityPermissions();
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  // end CAppServerView class interface
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\atdlg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* atdlg.cpp
*
* implementation of WINCFG CAsyncTestDlg, CEchoEditControl, and CLed classes 
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   M:\nt\private\utils\citrix\winutils\wincfg\VCS\atdlg.cpp  $
*  
*     Rev 1.18   12 Sep 1997 16:22:28   butchd
*  better async test auto-disable/enable
*  
*     Rev 1.17   19 Jun 1997 19:21:14   kurtp
*  update
*  
*     Rev 1.16   30 Sep 1996 12:11:22   butchd
*  update
*  
*     Rev 1.15   20 Sep 1996 20:36:56   butchd
*  update
*  
*     Rev 1.14   19 Sep 1996 15:57:56   butchd
*  update
*  
*     Rev 1.13   12 Sep 1996 16:15:56   butchd
*  update
*  
*******************************************************************************/

/*
 * include files
 */
#include "stdafx.h"
#include "wincfg.h"

#include "atdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CWincfgApp *pApp;
extern "C" LPCTSTR WinUtilsAppName;
extern "C" HWND WinUtilsAppWindow;
extern "C" HINSTANCE WinUtilsAppInstance;

static int LedIds[NUM_LEDS] = {
    IDC_ATDLG_DTR,
    IDC_ATDLG_RTS,
    IDC_ATDLG_CTS,
    IDC_ATDLG_DSR,
    IDC_ATDLG_DCD,
    IDC_ATDLG_RI    };

///////////////////////////////////////////////////////////////////////////////
// CEchoEditControl class construction / destruction, implementation

////////////////////////////////////////////////////////////////////////////////
// CEchoEditControl message map

BEGIN_MESSAGE_MAP(CEchoEditControl, CEdit)
    //{{AFX_MSG_MAP(CEchoEditControl)
     ON_WM_CHAR()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////////////////
// CEchoEditControl commands

void
CEchoEditControl::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    /*
     * Tell dialog to write the character to the device unless we're
     * currently processing edit control output.  This flag check is needed
     * because the CEdit::Cut() member function will generate an OnChar() 
     * event, which we need to ignore ('\b' processing).
     */
    if ( !m_bProcessingOutput )
        ::SendMessage(m_hDlg, WM_ASYNCTESTWRITECHAR, nChar, 0);

    /*
     * Pass character on to the edit control.  This will do nothing if
     * the edit control is 'read only'.  To cause a 'local echo' effect,
     * set the edit control to 'read/write'.
     */
    CEdit::OnChar(nChar, nRepCnt, nFlags);

}  // end CEchoEditControl::OnChar
////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg class construction / destruction, implementation

/*******************************************************************************
 *
 *  CAsyncTestDlg - CAsyncTestDlg constructor
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CDialog::CDialog documentation)
 *
 ******************************************************************************/

CAsyncTestDlg::CAsyncTestDlg()
    : CBaseDialog(CAsyncTestDlg::IDD),
      m_hDevice(INVALID_HANDLE_VALUE),
      m_hRedBrush(NULL),
      m_LEDToggleTimer(0),
      m_pATDlgInputThread(NULL),
      m_CurrentPos(0),
      m_hModem(NULL),
      m_bDeletedWinStation(FALSE)
{
    //{{AFX_DATA_INIT(CAsyncTestDlg)
    //}}AFX_DATA_INIT

    int i;

    /*
     * Create a solid RED brush for painting the 'LED's when 'on'.
     */
    VERIFY( m_hRedBrush = CreateSolidBrush(RGB(255,0,0)) );

    /*
     * Initialize member variables.
     */
    memset(&m_Status, 0, sizeof(PROTOCOLSTATUS));
    memset(&m_OverlapWrite, 0, sizeof(OVERLAPPED));

    /*
     * Create the led objects.
     */
    for ( i = 0; i < NUM_LEDS; i++ )
        m_pLeds[i] = new CLed(m_hRedBrush);

}  // end CAsyncTestDlg::CAsyncTestDlg


/*******************************************************************************
 *
 *  ~CAsyncTestDlg - CAsyncTestDlg destructor
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CDialog::~CDialog documentation)
 *
 ******************************************************************************/

CAsyncTestDlg::~CAsyncTestDlg()
{
    int i;

    /*
     * Zap our led objects.
     */
    for ( i = 0; i < NUM_LEDS; i++ )
        if ( m_pLeds[i] )
            delete m_pLeds[i];

}  // end CAsyncTestDlg::~CAsyncTestDlg


////////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg operations

/*******************************************************************************
 *
 *  NotifyAbort - CAsyncTestDlg member function: private operation
 *
 *      Post a WM_ASYNCTESTABORT message to notify the dialog of
 *      abort and reason.
 *
 *  ENTRY:
 *      idError (input)
 *          Resource id for error message.
 *  EXIT:
 *
 ******************************************************************************/

void
CAsyncTestDlg::NotifyAbort( UINT idError )
{
    PostMessage(WM_ASYNCTESTABORT, idError, GetLastError());

}  // end CAsyncTestDlg::NotifyAbort


/*******************************************************************************
 *
 *  DeviceSetParams - CAsyncTestDlg member function: private operation
 *
 *      Set device parameters for opened device.
 *
 *  ENTRY:
 *  EXIT:
 *    TRUE - no error; FALSE error.
 *
 ******************************************************************************/

BOOL
CAsyncTestDlg::DeviceSetParams()
{
    PASYNCCONFIG pAsync;
    PFLOWCONTROLCONFIG pFlow;
    DCB Dcb;

    /*
     *  Get pointer to async parameters
     */
    pAsync = &m_PdConfig0.Params.Async;

    /*
     *  Get current DCB
     */
    if ( !GetCommState( m_hDevice, &Dcb ) )
        return(FALSE);

    /*
     *  Set defaults
     */
    Dcb.fOutxCtsFlow      = FALSE;
    Dcb.fOutxDsrFlow      = FALSE;
    Dcb.fTXContinueOnXoff = TRUE;
    Dcb.fOutX             = FALSE;
    Dcb.fInX              = FALSE;
    Dcb.fErrorChar        = FALSE;
    Dcb.fNull             = FALSE;
    Dcb.fAbortOnError     = FALSE;

    /*
     *  Set Communication parameters
     */
    Dcb.BaudRate        = pAsync->BaudRate;
    Dcb.Parity          = (BYTE) pAsync->Parity;
    Dcb.StopBits        = (BYTE) pAsync->StopBits;
    Dcb.ByteSize        = (BYTE) pAsync->ByteSize;
    Dcb.fDsrSensitivity = pAsync->fEnableDsrSensitivity;

    pFlow = &pAsync->FlowControl;

    /*
     *  Initialize default DTR state
     */
    if ( pFlow->fEnableDTR )
        Dcb.fDtrControl = DTR_CONTROL_ENABLE;
    else
        Dcb.fDtrControl = DTR_CONTROL_DISABLE;

    /*
     *  Initialize default RTS state
     */
    if ( pFlow->fEnableRTS )
        Dcb.fRtsControl = RTS_CONTROL_ENABLE;
    else
        Dcb.fRtsControl = RTS_CONTROL_DISABLE;

    /*
     *  Initialize flow control
     */
    switch ( pFlow->Type ) {

        /*
         *  Initialize hardware flow control
         */
        case FlowControl_Hardware :

            switch ( pFlow->HardwareReceive ) {
                case ReceiveFlowControl_RTS :
                    Dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
                    break;
                case ReceiveFlowControl_DTR :
                    Dcb.fDtrControl = DTR_CONTROL_HANDSHAKE;
                    break;
            }
            switch ( pFlow->HardwareTransmit ) {
                case TransmitFlowControl_CTS :
                    Dcb.fOutxCtsFlow = TRUE;
                    break;
                case TransmitFlowControl_DSR :
                    Dcb.fOutxDsrFlow = TRUE;
                    break;
            }
            break;

        /*
         *  Initialize software flow control
         */
        case FlowControl_Software :
            Dcb.fOutX    = pFlow->fEnableSoftwareTx;
            Dcb.fInX     = pFlow->fEnableSoftwareRx;
            Dcb.XonChar  = (char) pFlow->XonChar;
            Dcb.XoffChar = (char) pFlow->XoffChar;
            break;

        case FlowControl_None :
            break;

        default :
            ASSERT( FALSE );
            break;
    }

    /*
     *  Set new DCB
     */
    if ( !SetCommState( m_hDevice, &Dcb ) )
        return(FALSE);

    return( TRUE );

}  // end CAsyncTestDlg::DeviceSetParams


/*******************************************************************************
 *
 *  DeviceWrite - CAsyncTestDlg member function: private operation
 *
 *      Write out m_Buffer contents (m_BufferBytes length) to the m_hDevice.
 *
 *  ENTRY:
 *  EXIT:
 *    TRUE - no error; FALSE error.
 *
 ******************************************************************************/

BOOL
CAsyncTestDlg::DeviceWrite()
{
    DWORD Error, BytesWritten;

    /*
     *  Write data
     */
    if ( !WriteFile( m_hDevice, m_Buffer, m_BufferBytes,
                     &BytesWritten, &m_OverlapWrite ) ) {

        if ( (Error = GetLastError()) == ERROR_IO_PENDING ) {

            /*
             *  Wait for write to complete (this may block till timeout)
             */
            if ( !GetOverlappedResult( m_hDevice, &m_OverlapWrite,
                                       &BytesWritten, TRUE ) ) {

                OnAsyncTestError(IDP_ERROR_GET_OVERLAPPED_RESULT_WRITE, Error);
                return(FALSE);
            }

        } else {

            OnAsyncTestError(IDP_ERROR_WRITE_FILE, Error);
            return(FALSE);
        }
    }

    return(TRUE);
    
}  // end CAsyncTestDlg::DeviceWrite


/*******************************************************************************
 *
 *  SetInfoFields - CAsyncTestDlg member function: private operation
 *
 *      Update the fields in the dialog with new data, if necessary.
 *
 *  ENTRY:
 *      pCurrent (input)
 *          points to COMMINFO structure containing the current Comm Input data.
 *      pNew (input)
 *          points to COMMINFO structure containing the new Comm Input data.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAsyncTestDlg::SetInfoFields( PPROTOCOLSTATUS pCurrent,
                              PPROTOCOLSTATUS pNew )
{
    BOOL    bSetTimer = FALSE;

    /*
     * Set new LED states if state change, or set up for quick toggle if
     * no state changed, but change(s) were detected since last query.
     */
    if ( (pCurrent->AsyncSignal & MS_DTR_ON) !=
         (pNew->AsyncSignal & MS_DTR_ON) ) {

        pNew->AsyncSignalMask &= ~EV_DTR;
        ((CLed *)GetDlgItem(IDC_ATDLG_DTR))->
            Update(pNew->AsyncSignal & MS_DTR_ON);

    } else if ( pNew->AsyncSignalMask & EV_DTR ) {

        pCurrent->AsyncSignal ^= MS_DTR_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_DTR))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_RTS_ON) !=
         (pNew->AsyncSignal & MS_RTS_ON) ) {

        pNew->AsyncSignalMask &= ~EV_RTS;
        ((CLed *)GetDlgItem(IDC_ATDLG_RTS))->
            Update(pNew->AsyncSignal & MS_RTS_ON);

    } else if ( pNew->AsyncSignalMask & EV_RTS ) {

        pCurrent->AsyncSignal ^= MS_RTS_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_RTS))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_CTS_ON) !=
         (pNew->AsyncSignal & MS_CTS_ON) ) {

        pNew->AsyncSignalMask &= ~EV_CTS;
        ((CLed *)GetDlgItem(IDC_ATDLG_CTS))->
            Update(pNew->AsyncSignal & MS_CTS_ON);

    } else if ( pNew->AsyncSignalMask & EV_CTS ) {

        pCurrent->AsyncSignal ^= MS_CTS_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_CTS))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_RLSD_ON) !=
         (pNew->AsyncSignal & MS_RLSD_ON) ) {

        pNew->AsyncSignalMask &= ~EV_RLSD;
        ((CLed *)GetDlgItem(IDC_ATDLG_DCD))->
            Update(pNew->AsyncSignal & MS_RLSD_ON);

    } else if ( pNew->AsyncSignalMask & EV_RLSD ) {

        pCurrent->AsyncSignal ^= MS_RLSD_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_DCD))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_DSR_ON) !=
         (pNew->AsyncSignal & MS_DSR_ON) ) {

        pNew->AsyncSignalMask &= ~EV_DSR;
        ((CLed *)GetDlgItem(IDC_ATDLG_DSR))->
            Update(pNew->AsyncSignal & MS_DSR_ON);

    } else if ( pNew->AsyncSignalMask & EV_DSR ) {

        pCurrent->AsyncSignal ^= MS_DSR_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_DSR))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_RING_ON) !=
         (pNew->AsyncSignal & MS_RING_ON) ) {

        pNew->AsyncSignalMask &= ~EV_RING;
        ((CLed *)GetDlgItem(IDC_ATDLG_RI))->
            Update(pNew->AsyncSignal & MS_RING_ON);

    } else if ( pNew->AsyncSignalMask & EV_RING ) {

        pCurrent->AsyncSignal ^= MS_RING_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_RI))->Toggle();

        bSetTimer = TRUE;
    }

    /*
     * Create our led toggle timer if needed.
     */
    if ( bSetTimer && !m_LEDToggleTimer )
        m_LEDToggleTimer = SetTimer( IDD_ASYNC_TEST,
                                     ASYNC_LED_TOGGLE_MSEC, NULL );

}  // end CAsyncTestDlg::SetInfoFields


////////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg message map

BEGIN_MESSAGE_MAP(CAsyncTestDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CAsyncTestDlg)
    ON_WM_TIMER()
    ON_MESSAGE(WM_ASYNCTESTERROR, OnAsyncTestError)
    ON_MESSAGE(WM_ASYNCTESTABORT, OnAsyncTestAbort)
    ON_MESSAGE(WM_ASYNCTESTSTATUSREADY, OnAsyncTestStatusReady)
    ON_MESSAGE(WM_ASYNCTESTINPUTREADY, OnAsyncTestInputReady)
    ON_MESSAGE(WM_ASYNCTESTWRITECHAR, OnAsyncTestWriteChar)
    ON_BN_CLICKED(IDC_ATDLG_MODEM_DIAL, OnClickedAtdlgModemDial)
    ON_BN_CLICKED(IDC_ATDLG_MODEM_INIT, OnClickedAtdlgModemInit)
    ON_BN_CLICKED(IDC_ATDLG_MODEM_LISTEN, OnClickedAtdlgModemListen)
	ON_WM_NCDESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg commands

/*******************************************************************************
 *
 *  OnInitDialog - CAsyncTestDlg member function: command (override)
 *
 *      Performs the dialog intialization.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnInitDialog documentation)
 *      WM_ASYNCTESTABORT message(s) will have been posted on error.
 *
 ******************************************************************************/

BOOL CAsyncTestDlg::OnInitDialog()
{
    int i;
    DEVICENAME DeviceName;
    COMMTIMEOUTS CommTimeouts;
    BOOL bModemInit = TRUE;
    BOOL bModemDial = TRUE;
    BOOL bModemListen = TRUE;
#ifdef WINSTA
    ULONG LogonId;
#endif // WINSTA

    /*
     * Call the parent classes' OnInitDialog to perform default dialog
     * initialization.
     */    
    CBaseDialog::OnInitDialog();

    /*
     * Fill in the device and baud fields.
     */
    SetDlgItemText( IDL_ATDLG_DEVICE,
                    m_PdConfig0.Params.Async.DeviceName );
    SetDlgItemInt( IDL_ATDLG_BAUD,
                   m_PdConfig0.Params.Async.BaudRate,
                   FALSE ); 

    /*
     * If a WinStation memory object is currently present, reset it.
     */
#ifdef WINSTA
    if ( m_pWSName &&
         LogonIdFromWinStationName(SERVERNAME_CURRENT, m_pWSName, &LogonId) ) {

        LONG Status;
        ULONG Length;

        if ( QueryLoggedOnCount(m_pWSName) ) {

            if ( QuestionMessage( MB_YESNO | MB_ICONEXCLAMATION, 
                                  IDP_CONFIRM_ASYNCTESTDISABLE,
                                  m_pWSName ) == IDNO ) {

                PostMessage( WM_COMMAND, MAKEWPARAM( IDOK, BN_CLICKED ),
                             (LPARAM)(GetDlgItem(IDOK)->m_hWnd) );
                return(TRUE);   // exit dialog via posted 'OK' click
            }
        }

        if ( (Status = RegWinStationQuery( SERVERNAME_CURRENT,
                                           m_pWSName,
                                           &m_WSConfig,
                                           sizeof(WINSTATIONCONFIG2),
                                           &Length )) ) {
            NotifyAbort(IDP_ERROR_DISABLE);
            return(TRUE);
        }

        m_WSConfig.Create.fEnableWinStation = FALSE;

        if ( (Status = RegWinStationCreate( SERVERNAME_CURRENT,
                                            m_pWSName,
                                            FALSE,
                                            &m_WSConfig,
                                            sizeof(WINSTATIONCONFIG2) )) ) {
            NotifyAbort(IDP_ERROR_DISABLE);
            return(TRUE);
        }

        /*
         * Do the reset.  If, for some reason, the reset was unsucessful,
         * the device open will fail (below).
         */
        CWaitCursor wait;
        WinStationReset(SERVERNAME_CURRENT, LogonId, TRUE);

        m_bDeletedWinStation = TRUE;
    }
#endif // WINSTA

    /* 
     * Open the specified device.
     */
    lstrcpy( DeviceName, TEXT("\\\\.\\") );
    lstrcat( DeviceName, m_PdConfig0.Params.Async.DeviceName );
    if ( (m_hDevice = CreateFile( DeviceName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  0,                  // exclusive access
                                  NULL,               // no security attr
                                  OPEN_EXISTING,      // must exist
                                  FILE_FLAG_OVERLAPPED,
                                  NULL                // no template
                                )) == INVALID_HANDLE_VALUE ) {

        NotifyAbort(IDP_ERROR_CANT_OPEN_DEVICE);
        return(TRUE);
    }

    /*
     * Set device timeouts & communication parameters and create an event
     * for overlapped writes.
     */
    memset(&CommTimeouts, 0, sizeof(COMMTIMEOUTS));
    CommTimeouts.ReadIntervalTimeout = 1;           // 1 msec
    CommTimeouts.WriteTotalTimeoutConstant = 1000;  // 1 second
    if ( !SetCommTimeouts(m_hDevice, &CommTimeouts) ||
         !DeviceSetParams() ||
         !(m_OverlapWrite.hEvent = CreateEvent( NULL, TRUE,
                                                FALSE, NULL )) ) {

        NotifyAbort(IDP_ERROR_CANT_INITIALIZE_DEVICE);
        return(TRUE);
    }

    /*
     * Create the input thread object and initialize it's member variables.
     */
    m_pATDlgInputThread = new CATDlgInputThread;
    m_pATDlgInputThread->m_hDlg = m_hWnd;
    m_pATDlgInputThread->m_hDevice = m_hDevice;
    m_pATDlgInputThread->m_PdConfig = m_PdConfig0;
    if ( !m_pATDlgInputThread->CreateThread() ) {

        NotifyAbort(IDP_ERROR_CANT_CREATE_INPUT_THREAD);
        return(TRUE);
    }

#ifdef WF1x
    /*
     * If a modem is configured, get command strings for current configuration.
     */
    if ( m_PdConfig1.Create.SdClass == PdModem ) {

        ULONG dRC, fCapability, cbCommand;

        if ( (dRC = ModemOpen( &m_hModem,
                               (BYTE *)m_PdConfig1.Params.Modem.ModemName,
                               &fCapability )) != ERROR_SUCCESS ) {

            OnAsyncTestError(IDP_ERROR_MODEMOPEN_CONFIG, dRC);

            bModemInit = bModemDial = bModemListen = FALSE;
            m_hModem = NULL;
        }

        if ( m_hModem ) {

            /*
             * Set configured capability.
             */
            fCapability = 0 ;
            fCapability |= m_PdConfig1.Params.Modem.fHwFlowControl ?
                            MODEM_CAPABILITY_HW_FLOWCONTROL_ON :
                            MODEM_CAPABILITY_HW_FLOWCONTROL_OFF;
            fCapability |= m_PdConfig1.Params.Modem.fProtocol ?
                            MODEM_CAPABILITY_ERROR_CORRECTION_ON :
                            MODEM_CAPABILITY_ERROR_CORRECTION_OFF;
            fCapability |= m_PdConfig1.Params.Modem.fCompression ?
                            MODEM_CAPABILITY_COMPRESSION_ON :
                            MODEM_CAPABILITY_COMPRESSION_OFF;
            fCapability |= m_PdConfig1.Params.Modem.fSpeaker ?
                            MODEM_CAPABILITY_SPEAKER_ON :
                            MODEM_CAPABILITY_SPEAKER_OFF;
            fCapability |= m_PdConfig1.Params.Modem.fAutoBaud ?
                            MODEM_CAPABILITY_AUTOBAUD_ON :
                            MODEM_CAPABILITY_AUTOBAUD_OFF;

            if ( (dRC = ModemSetInfo(m_hModem, &fCapability)) != ERROR_SUCCESS ) {

                OnAsyncTestError(IDP_ERROR_MODEM_SET_INFO, dRC);

                bModemInit = bModemDial = bModemListen = FALSE;
                ModemClose(m_hModem);
                m_hModem = NULL;
            }
        }

        cbCommand = MAX_COMMAND_LEN;
        if ( (dRC == ERROR_SUCCESS) &&
             ((dRC = ModemGetCommand( m_hModem, CT_LISTEN, FALSE,
                                      (BYTE *)m_szModemListen,
                                      &cbCommand)) != ERROR_SUCCESS) ) {

            OnAsyncTestError(IDP_ERROR_MODEM_GET_LISTEN, dRC);

            bModemListen = FALSE;
            cbCommand = 0;

        }
        m_szModemListen[cbCommand] = TCHAR('\0');
    }
#endif // WF1x

    /*
     * Hide the modem string buttons if a modem is not configured, or disable
     * buttons that are not valid.
     */
#ifdef WF1x
    if ( m_PdConfig1.Create.SdClass != PdModem ) {
#endif // WF1x

        int id;
        for ( id=IDC_ATDLG_MODEM_INIT; id <= IDC_ATDLG_PHONE_NUMBER; id++ ) {

            GetDlgItem(id)->EnableWindow(FALSE);
            GetDlgItem(id)->ShowWindow(SW_HIDE);
        }

#ifdef WF1x
    } else {

        if ( !bModemInit )
            GetDlgItem(IDC_ATDLG_MODEM_INIT)->EnableWindow(FALSE);

        if ( !bModemListen )
            GetDlgItem(IDC_ATDLG_MODEM_LISTEN)->EnableWindow(FALSE);
    }
#endif // WF1x

    /*
     * Subclass the edit field to pass messages to dialog first.
     */
    m_EditControl.m_hDlg = m_hWnd;
    m_EditControl.m_bProcessingOutput = FALSE;
    m_EditControl.SubclassDlgItem(IDC_ATDLG_EDIT, this);

    /*
     * Determine the edit control's font and format offset metrics.
     */
    {
        TEXTMETRIC tm;
        RECT Rect;    
        CDC *pDC;
        CFont *pFont, *pOldFont;

        pDC = m_EditControl.GetDC();

        pFont = m_EditControl.GetFont();
        pOldFont = pDC->SelectObject(pFont);
        pDC->GetTextMetrics(&tm);
        pDC->SelectObject(pOldFont);

        m_EditControl.ReleaseDC(pDC);

        m_EditControl.m_FontHeight = tm.tmHeight;
        m_EditControl.m_FontWidth = tm.tmMaxCharWidth;

        m_EditControl.GetRect(&Rect);
        m_EditControl.m_FormatOffsetY = Rect.top;
        m_EditControl.m_FormatOffsetX = Rect.left;
    }

    /*
     * Subclass the led controls and default to 'off'.
     */
    for ( i = 0; i < NUM_LEDS; i++ ) {
        m_pLeds[i]->Subclass( (CStatic *)GetDlgItem(LedIds[i]) );
        m_pLeds[i]->Update(0);
    }

    return ( TRUE );

}  // end CAsyncTestDlg::OnInitDialog


/*******************************************************************************
 *
 *  OnTimer - CAsyncTestDlg member function: command (override)
 *
 *      Used for quick 'LED toggle'.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CWnd::OnTimer documentation)
 *
 ******************************************************************************/

void
CAsyncTestDlg::OnTimer(UINT nIDEvent)
{
    /*
     * Process this timer event if it it our 'LED toggle' event.
     */
    if ( nIDEvent == m_LEDToggleTimer ) {

        /*
         * Toggle each LED that is flagged as 'changed'.
         */
        if ( m_Status.AsyncSignalMask & EV_DTR )
            ((CLed *)GetDlgItem(IDC_ATDLG_DTR))->Toggle();
            
        if ( m_Status.AsyncSignalMask & EV_RTS )
            ((CLed *)GetDlgItem(IDC_ATDLG_RTS))->Toggle();
            
        if ( m_Status.AsyncSignalMask & EV_CTS )
            ((CLed *)GetDlgItem(IDC_ATDLG_CTS))->Toggle();
            
        if ( m_Status.AsyncSignalMask & EV_RLSD )
            ((CLed *)GetDlgItem(IDC_ATDLG_DCD))->Toggle();

        if ( m_Status.AsyncSignalMask & EV_DSR )
            ((CLed *)GetDlgItem(IDC_ATDLG_DSR))->Toggle();

        if ( m_Status.AsyncSignalMask & EV_RING )
            ((CLed *)GetDlgItem(IDC_ATDLG_RI))->Toggle();

        /*
         * Kill this timer event and indicate so.
         */
        KillTimer(m_LEDToggleTimer);
        m_LEDToggleTimer = 0;

    } else    
        CBaseDialog::OnTimer(nIDEvent);

}  // end CAsyncTestDlg::OnTimer


/*******************************************************************************
 *
 *  OnAsyncTestError - CAsyncTestDlg member function: command
 *
 *      Handle the Async Test Dialog error conditions.
 *
 *  ENTRY:
 *      wParam (input)
 *          Contains message ID for error.
 *      wLparam (input)
 *          Contains error code (GetLastError or API-specific return code)
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate error handling complete.
 *
 ******************************************************************************/

LRESULT
CAsyncTestDlg::OnAsyncTestError( WPARAM wParam, LPARAM lParam )
{
    /*
     * Handle special and default errors.
     */
    switch ( wParam ) {

#ifdef WF1x
        case IDP_ERROR_MODEMOPEN_CONFIG:
#endif // WF1x
        case IDP_ERROR_MODEM_SET_INFO:
        case IDP_ERROR_MODEM_GET_DIAL:
        case IDP_ERROR_MODEM_GET_INIT:
        case IDP_ERROR_MODEM_GET_LISTEN:
#ifdef WF1x
            STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, lParam,
                                     wParam, m_PdConfig1.Params.Modem.ModemName ))
#endif // WF1x
            break;

        case IDP_ERROR_DISABLE:
            STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, lParam,
                                     wParam, m_pWSName ))
            break;                                                

        default:
            STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, lParam, wParam, lParam ))
            break;
    }
    return(0);

} // end CAsyncTestDlg::OnAsyncTestError


/*******************************************************************************
 *
 *  OnAsyncTestAbort - CAsyncTestDlg member function: command
 *
 *      Handle the Async Test Dialog abort conditions.
 *
 *  ENTRY:
 *      wParam (input)
 *          Contains message ID for error.
 *      wLparam (input)
 *          Contains error code (GetLastError)
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate error handling complete.  Will
 *          have posted an 'Ok' (Exit) button click to cause exit.
 *
 ******************************************************************************/

LRESULT
CAsyncTestDlg::OnAsyncTestAbort( WPARAM wParam, LPARAM lParam )
{
    /*
     * Call OnAsyncTestError() to output message.
     */
    OnAsyncTestError(wParam, lParam);

    /*
     * Post a click for 'OK' (Exit) button to exit dialog.
     */
    PostMessage( WM_COMMAND, MAKEWPARAM( IDOK, BN_CLICKED ),
                 (LPARAM)(GetDlgItem(IDOK)->m_hWnd) );
    return(0);

} // end CAsyncTestDlg::OnAsyncTestAbort


/*******************************************************************************
 *
 *  OnAsyncTestStatusReady - CAsyncTestDlg member function: command
 *
 *      Update dialog with comm status information.
 *
 *  ENTRY:
 *      wParam (input)
 *          not used (0)
 *      wLparam (input)
 *          not used (0)
 *  EXIT:
 *      (LRESULT) always returns 0.
 *
 ******************************************************************************/

LRESULT
CAsyncTestDlg::OnAsyncTestStatusReady( WPARAM wParam, LPARAM lParam )
{
    /*
     * Update dialog fields with information from the input thread's
     * PROTOCOLSTATUS structure.
     */
    SetInfoFields( &m_Status, &(m_pATDlgInputThread->m_Status) );

    /*
     * Set our working PROTOCOLSTATUS structure to the new one and signal
     * the thread that we're done.
     */
    m_Status = m_pATDlgInputThread->m_Status;
    m_pATDlgInputThread->SignalConsumed();

    return(0);

} // end CAsyncTestDlg::OnAsyncTestStatusReady


/*******************************************************************************
 *
 *  OnAsyncTestInputReady - CAsyncTestDlg member function: command
 *
 *      Update dialog with comm input data.
 *
 *  ENTRY:
 *      wParam (input)
 *          not used (0)
 *      wLparam (input)
 *          not used (0)
 *  EXIT:
 *      (LRESULT) always returns 0.
 *
 ******************************************************************************/

LRESULT
CAsyncTestDlg::OnAsyncTestInputReady( WPARAM wParam, LPARAM lParam )
{
    BYTE OutBuf[MAX_COMMAND_LEN+2];
    int i, j;

    /*
     * Copy the thread's buffer and count locally.
     */
    m_BufferBytes = m_pATDlgInputThread->m_BufferBytes;
    memcpy(m_Buffer, m_pATDlgInputThread->m_Buffer, m_BufferBytes);

    /*
     * Always return caret to the current position before processing, and set
     * edit control to 'read/write' so that character overwrites can occur
     * properly.  Finally, flag control for no redraw until all updates are completed,
     * and flag 'processing output' to avoid OnChar() recursion during '\b' processing.
     */
    m_EditControl.SetSel(m_CurrentPos, m_CurrentPos);
    m_EditControl.SetReadOnly(FALSE);
    m_EditControl.SetRedraw(FALSE);

    /*
     * Loop to traverse the buffer, with special processing for certain
     * control characters.
     */
    for ( i = 0, j = 0; m_BufferBytes; i++, m_BufferBytes-- ) {

        switch ( m_Buffer[i] ) {

            case '\b':
                /*
                 * If there is data in the output buffer, write it now.
                 */
                if ( j )
                    OutputToEditControl(OutBuf, &j);

                /*
                 * Output the '\b' (will actually cut current character from buffer)
                 */
                OutBuf[j++] = '\b';
                OutputToEditControl(OutBuf, &j);
                continue;

            case '\r':
                /*
                 * If there is data in the output buffer, write it now.
                 */
                if ( j )
                    OutputToEditControl(OutBuf, &j);

                /*
                 * Output the '\r' (will not actually output, but will special case
                 * for caret positioning and screen update).
                 */
                OutBuf[j++] = '\r';
                OutputToEditControl(OutBuf, &j);
                continue;

            case '\n':
                /*
                 * If there is data in the output buffer, write it now.
                 */
                if ( j )
                    OutputToEditControl(OutBuf, &j);

                /*
                 * Output the '\n' (will actually quietly output the '\r' and take
                 * care of scolling).
                 */
                OutBuf[j++] = '\n';
                OutputToEditControl(OutBuf, &j);
                continue;

            default:
                break;
        }

        /*
         * Add this character to the output buffer.
         */
        OutBuf[j++] = m_Buffer[i];
    }

    /*
     * If there is anything remaining in the output buffer, output it now.
     */
    if ( j )
        OutputToEditControl(OutBuf, &j);

    /*
     * Place edit control back in 'read only' mode, flag 'not processing output',
     * set redraw flag for control, and validate the entire control (updates have
     * already taken place).
     */
    m_EditControl.SetReadOnly(TRUE);
    m_EditControl.SetRedraw(TRUE);
    m_EditControl.ValidateRect(NULL);

    /*
     * Signal thread that we're done with input so that it can continue.
     * NOTE: we don't do this at the beginning of the routine even though
     * we could (for more parallelism), since a constantly chatty async
     * line would cause WM_ASYNCTESTINPUTREADY messages to always be posted
     * to our message queue, effectively blocking any other message processing
     * (like telling the dialog to exit!).
     */
    m_pATDlgInputThread->SignalConsumed();
    return(0);

} // end CAsyncTestDlg::OnAsyncTestInputReady


void
CAsyncTestDlg::OutputToEditControl( BYTE *pBuffer, int *pIndex )
{
    RECT Rect, ClientRect;
    BOOL bScroll = FALSE;
    int CurrentLine = m_EditControl.LineFromChar(m_CurrentPos);
    int FirstVisibleLine = m_EditControl.GetFirstVisibleLine();
    int CurrentLineIndex = m_EditControl.LineIndex(CurrentLine);

    /*
     * Calculate clip rectangle.
     */
    Rect.top = ((CurrentLine - FirstVisibleLine) * m_EditControl.m_FontHeight)
                + m_EditControl.m_FormatOffsetY;
    Rect.bottom = Rect.top + m_EditControl.m_FontHeight;
    Rect.left = m_EditControl.m_FormatOffsetX +
                ((m_CurrentPos - CurrentLineIndex) * m_EditControl.m_FontWidth);
    Rect.right = Rect.left + (*pIndex * m_EditControl.m_FontWidth);

    /*
     * Handle special cases.
     */
    if ( pBuffer[0] == '\b' ) {

        /*
         * If we're already at the beginning of the line, clear buffer index
         * and return (don't do anything).
         */        
        if ( m_CurrentPos == CurrentLineIndex ) {

            *pIndex = 0;
            return;
        }

        /*
         * Position the caret back one character and select through current character.
         */
        m_EditControl.SetSel(m_CurrentPos - 1, m_CurrentPos);

        /*
         * Cut the character out of the edit buffer.
         */
        m_EditControl.m_bProcessingOutput = TRUE;
        m_EditControl.Cut();
        m_EditControl.m_bProcessingOutput = FALSE;

        /*
         * Decrement current position and zero index to suppress further output.  Also,
         * widen the clipping rectangle back one character.
         */
        Rect.left -= m_EditControl.m_FontWidth;
        m_CurrentPos--;
        *pIndex = 0;

    } else if ( pBuffer[0] == '\r' ) {
        
        /*
         * Position the caret at the beginning of the current line.
         */
        m_CurrentPos = CurrentLineIndex;
        m_EditControl.SetSel(m_CurrentPos, m_CurrentPos);

        /*
         * Zero index to keep from actually outputing to edit buffer.
         */
        *pIndex = 0;

    } else if ( pBuffer[0] == '\n' ) {

        /*
         * Position selection point at end of the current edit buffer.
         */
        m_EditControl.SetSel(m_CurrentPos = m_EditControl.GetWindowTextLength(), -1 );

        /*
         * Cause '\r' '\n' pair to be output to edit buffer.
         */
        pBuffer[0] = '\r';
        pBuffer[1] = '\n';
        *pIndex = 2;

        /*
         * See if scrolling needed.
         */
        m_EditControl.GetClientRect(&ClientRect);
        if ( (Rect.bottom + m_EditControl.m_FontHeight) > ClientRect.bottom )
            bScroll = TRUE;

    } else {

        /*
         * Set selection from current position through *pIndex characters.  This
         * will perform desired 'overwrite' function if current position is not at
         * the end of the edit buffer.
         */
        m_EditControl.SetSel(m_CurrentPos, m_CurrentPos + *pIndex);
    }

    /*
     * If necessary, update the dialog's edit box with the buffer data.
     */
    if ( *pIndex ) {


#ifdef UNICODE
        TCHAR OutBuffer[MAX_COMMAND_LEN+1];

        mbstowcs(OutBuffer, (PCHAR)pBuffer, *pIndex);
        OutBuffer[*pIndex] = TEXT('\0');
        m_EditControl.ReplaceSel(OutBuffer);
#else
        pBuffer[*pIndex] = BYTE('\0');
        m_EditControl.ReplaceSel((LPCSTR)pBuffer);
#endif // UNICODE    
    }

    /*
     * Update the current line.
     */
    m_EditControl.SetRedraw(TRUE);
    m_EditControl.ValidateRect(NULL);
    m_EditControl.InvalidateRect(&Rect, FALSE);
    m_EditControl.UpdateWindow();
    /*
     * If scrolling is required to see the new line, do so.
     */
    if ( bScroll )
        m_EditControl.LineScroll(1);

    m_EditControl.SetRedraw(FALSE);

    /*
     * Update current position and clear buffer index.
     */
    m_CurrentPos += *pIndex;
    *pIndex = 0;


} // end CAsyncTestDlg::OutputToEditControl


/*******************************************************************************
 *
 *  OnAsyncTestWriteChar - CAsyncTestDlg member function: command
 *
 *      Place the specified character in m_Buffer, set m_BufferBytes to 1,
 *      and call DeviceWrite() to output the character to the device.
 *
 *  ENTRY:
 *      wParam (input)
 *          Character to write.
 *      lParam (input)
 *          not used (0)
 *  EXIT:
 *      (LRESULT) always returns 0.
 *
 ******************************************************************************/

LRESULT
CAsyncTestDlg::OnAsyncTestWriteChar( WPARAM wParam, LPARAM lParam )
{
    /*
     * Write the byte to the device.
     */
    m_Buffer[0] = (BYTE)wParam;
    m_BufferBytes = 1;
    DeviceWrite();

    return(0);

}  // end CAsyncTestDlg::OnAsyncTestWriteChar


/*******************************************************************************
 *
 *  OnClickedAtdlgModemDial - CAsyncTestDlg member function: command
 *
 *      Send the modem dial string.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAsyncTestDlg::OnClickedAtdlgModemDial()
{
#ifdef WF1x
    TCHAR PhoneNumber[CALLBACK_LENGTH + 1];
    ULONG dRC, cbCommand;

    GetDlgItemText(IDC_ATDLG_PHONE_NUMBER, PhoneNumber, lengthof(PhoneNumber));
    if ( (dRC = ModemSetCallback(m_hModem, (BYTE *)PhoneNumber)) != ERROR_SUCCESS ) {

        OnAsyncTestError(IDP_ERROR_MODEM_SET_INFO, dRC);
        return;
    }

    cbCommand = MAX_COMMAND_LEN;
    if ( ((dRC = ModemGetCommand( m_hModem, CT_DIAL, TRUE,
                                  (BYTE *)m_szModemDial,
                                  &cbCommand)) != ERROR_SUCCESS) ) {

        OnAsyncTestError(IDP_ERROR_MODEM_GET_DIAL, dRC);
        return;
    }
    m_szModemDial[cbCommand] = TCHAR('\0');

    lstrcpy((TCHAR *)m_Buffer, m_szModemDial);
    m_BufferBytes = lstrlen((TCHAR *)m_Buffer);
    DeviceWrite();
#endif // WF1x

}  // end CAsyncTestDlg::OnClickedAtdlgModemDial


/*******************************************************************************
 *
 *  OnClickedAtdlgModemInit - CAsyncTestDlg member function: command
 *
 *      Send the modem init string.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAsyncTestDlg::OnClickedAtdlgModemInit()
{
#ifdef WF1x
    ULONG cbCommand;
    ULONG fFirst = TRUE;

    CWaitCursor Wait;

    for ( ;; ) {

        cbCommand = MAX_COMMAND_LEN;
        if ( !m_hModem || (ModemGetCommand( m_hModem, CT_INIT, fFirst,
                                            (BYTE *)m_szModemInit,
                                            &cbCommand) != ERROR_SUCCESS) ) {
            return;
        }

        fFirst = FALSE;
        m_szModemInit[cbCommand] = TCHAR('\0');
        lstrcpy((TCHAR *)m_Buffer, m_szModemInit);
        m_BufferBytes = lstrlen((TCHAR *)m_Buffer);
        DeviceWrite();
        Sleep( 2000 );
    }
#endif // WF1x

}  // end CAsyncTestDlg::OnClickedAtdlgModemInit


/*******************************************************************************
 *
 *  OnClickedAtdlgModemListen - CAsyncTestDlg member function: command
 *
 *      Send the modem listen string.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAsyncTestDlg::OnClickedAtdlgModemListen()
{
    lstrcpy((TCHAR *)m_Buffer, m_szModemListen);
    m_BufferBytes = lstrlen((TCHAR *)m_Buffer);
    DeviceWrite();
    
}  // end CAsyncTestDlg::OnClickedAtdlgModemListen


/*******************************************************************************
 *
 *  OnNcDestroy - CAsyncTestDlg member function: command
 *
 *      Clean up before deleting dialog object.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CWnd::OnNcDestroy documentation)
 *
 ******************************************************************************/

void
CAsyncTestDlg::OnNcDestroy()
{
    if ( m_LEDToggleTimer )
        KillTimer(m_LEDToggleTimer);

#ifdef WF1x
    if ( m_hModem )
        ModemClose(m_hModem);
#endif // WF1x

    if ( m_pATDlgInputThread )
        m_pATDlgInputThread->ExitThread();

    if ( m_hDevice != INVALID_HANDLE_VALUE )
        PurgeComm(m_hDevice, PURGE_TXABORT | PURGE_TXCLEAR);

    if ( m_OverlapWrite.hEvent )
        CloseHandle(m_OverlapWrite.hEvent);

    if ( m_hDevice != INVALID_HANDLE_VALUE )
        CloseHandle(m_hDevice);

    if ( m_bDeletedWinStation && m_pWSName ) {

        LONG Status;

        m_WSConfig.Create.fEnableWinStation = TRUE;

        if ( !(Status = RegWinStationCreate( SERVERNAME_CURRENT,
                                             m_pWSName,
                                             FALSE,
                                             &m_WSConfig,
                                             sizeof(WINSTATIONCONFIG2) )) ) {
#ifdef WINSTA
            _WinStationReadRegistry(SERVERNAME_CURRENT);
#endif // WINSTA
        }
    }

    DeleteObject(m_hRedBrush);

    /*
     * Call parent after we've cleaned up.
     */
    CBaseDialog::OnNcDestroy();

}  // end CAsyncTestDlg::OnNcDestroy
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\basedlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* basedlg.h
*
* interface of CBaseDialog class
*   This class handles some extra housekeeping functions for WinUtils dialogs.
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\COMMON\VCS\BASEDLG.H  $
*  
*     Rev 1.1   29 Dec 1995 17:19:12   butchd
*  update
*
*******************************************************************************/

#ifndef BASEDLG_INCLUDED
////////////////////////////////////////////////////////////////////////////////
// CBaseDialog class
//
class CBaseDialog : public CDialog
{
	DECLARE_DYNAMIC(CBaseDialog)

/*
 * Member variables.
 */
private:
    HWND    m_SaveWinUtilsAppWindow;
protected:
    BOOL    m_bError;
public:

/* 
 * Implementation.
 */
public:
    CBaseDialog( UINT idResource,
                 CWnd *pParentWnd = NULL );

/*
 * Operations.
 */
	//{{AFX_VIRTUAL(CBaseDialog)
	//}}AFX_VIRTUAL
public:
    inline BOOL GetError()
        { return(m_bError); }
protected:

/*
 * Message map / commands.
 */
protected:
	//{{AFX_MSG(CBaseDialog)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end CBaseDialog class interface 
////////////////////////////////////////////////////////////////////////////////
#define BASEDLG_INCLUDED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\basedlg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* basedlg.cpp
*
* implementation of CBaseDialog class 
*   This class handles some extra housekeeping functions for WinUtils dialogs.
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\COMMON\VCS\BASEDLG.CPP  $
*  
*     Rev 1.1   29 Dec 1995 17:19:08   butchd
*  update
*  
*******************************************************************************/

/*
 * include files
 */
#include <stdafx.h>
#include <afxwin.h>             // MFC core and standard components
#include <afxext.h>             // MFC extensions
#include "common.h"
#include "basedlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern "C" HWND WinUtilsAppWindow;

///////////////////////////////////////////////////////////////////////////////
// CBaseDialog class construction / destruction, implementation

IMPLEMENT_DYNAMIC(CBaseDialog, CDialog)

/*******************************************************************************
 *
 *  CBaseDialog - CBaseDialog constructor
 *
 *  ENTRY:
 *      idResource (input)
 *          Resource Id of dialog template.
 *      pParentWnd (input/optional)
 *          CWnd * to parent of dialog (NULL is default)
 *  EXIT:
 *      (Refer to MFC CDialog::CDialog documentation)
 *
 ******************************************************************************/

CBaseDialog::CBaseDialog( UINT idResource, CWnd *pParentWnd )
	:CDialog(idResource, pParentWnd),
         m_bError(FALSE)
{
}  // end CBaseDialog::CBaseDialog


////////////////////////////////////////////////////////////////////////////////
// CBaseDialog operations


////////////////////////////////////////////////////////////////////////////////
// CBaseDialog message map

BEGIN_MESSAGE_MAP(CBaseDialog, CDialog)
	//{{AFX_MSG_MAP(CBaseDialog)
    ON_WM_CREATE()
    ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CBaseDialog commands


/*******************************************************************************
 *
 *  OnCreate - CBaseDialog member function: command (override)
 *
 *      Save & set global window handle for messages.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

int
CBaseDialog::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CDialog::OnCreate(lpCreateStruct) == -1)
        return -1;
	
    /*
     * Set global window handle for messages.
     */
    m_SaveWinUtilsAppWindow = WinUtilsAppWindow;
    WinUtilsAppWindow = GetSafeHwnd();
	
    return 0;

}  // end CBaseDialog::OnCreate


/*******************************************************************************
 *
 *  OnDestroy - CBaseDialog member function: command (override)
 *
 *      Restore global window handle (for messages) to previous setting.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CBaseDialog::OnDestroy() 
{
    CDialog::OnDestroy();
	
    WinUtilsAppWindow = m_SaveWinUtilsAppWindow;
	
}  // end CBaseDialog::OnDestroy
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\basedrpe.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* basedrpe.cpp
*
* implementation of CBaseDropEditBox and CBaseDropEditControl classes
*   The CBaseDropEditBox class does things the way we like, overriding the base
*   CComboBox (with edit field) class.
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\COMMON\VCS\BASEDRPE.CPP  $
*  
*     Rev 1.1   29 Dec 1995 17:19:16   butchd
*  update
*  
*******************************************************************************/

/*
 * include files
 */
#include <stdafx.h>
#include <afxwin.h>             // MFC core and standard components
#include <afxext.h>             // MFC extensions
#include "basedrpe.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseDropEdit operations

BOOL
CBaseDropEditControl::Subclass(CComboBox *pWnd)
{
    POINT pt;

    /*
     * Subclass this object to the child window of the specified combo box
     * control (the combo box's edit control) and save away the combo box
     * object pointer.
     */
    pt.x = 5;
    pt.y = 5;
    
    m_pComboBoxControl = pWnd;
    return( SubclassWindow((pWnd->ChildWindowFromPoint(pt))->GetSafeHwnd()) );

}  // end CBaseDropEditControl::Subclass


////////////////////////////////////////////////////////////////////////////////
// CBaseDropEditControl message map

BEGIN_MESSAGE_MAP(CBaseDropEditControl, CEdit)
	//{{AFX_MSG_MAP(CBaseDropEditControl)
	ON_WM_GETDLGCODE()
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CBaseDropEdit commands

UINT
CBaseDropEditControl::OnGetDlgCode() 
{
    return( CEdit::OnGetDlgCode() | 
            (m_pComboBoxControl->GetDroppedState() ? DLGC_WANTALLKEYS : 0) );

}  // end CBaseDropEditControl::OnGetDlgCode


void
CBaseDropEditControl::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
    if ( ((nChar == VK_ESCAPE) || (nChar == VK_RETURN) || (nChar == VK_TAB)) &&
         m_pComboBoxControl->GetDroppedState() ) {

        m_pComboBoxControl->ShowDropDown(FALSE);

        if ( nChar == VK_TAB ) {

            /* 
             * CODEWORK: need to figgure out how to set focus to the next
             * or previous control when TAB (or shift-TAB) is pressed while
             * we've gobbled up all keys.  Here are 3 atempts that don't quite
             * do what is needed [remember: the final solution must work for
             * both tabbed-dialog as well as regular dialog, in all Windows
             * host models (Win31, WinNT, Win95)!]
             */

            /* Try #1
             * Post a TAB WM_KEYDOWN message to the parent (grandparent if parent
             * is a property page).
             */
//          CWnd *pParent = GetParent();
//          if ( pParent->IsKindOf(RUNTIME_CLASS(CPropertyPage)) )
//              pParent = pParent->GetParent();
//
//          pParent->PostMessage( WM_KEYDOWN, (WPARAM)VK_TAB, (LPARAM)0 );

            /* Try #2
             * Issue a Next or Prev dialog control message to the control's parent,
             * based on the state of the shift key.
             */
//          CDialog *pParent = (CDialog *)GetParent();
//          if ( (GetKeyState(VK_SHIFT) < 0) ) {
//              pParent->PrevDlgCtrl();
//          } else {
//              pParent->NextDlgCtrl();
//          }

            /* Try #3
             * Just pass the VK_TAB along to our control.
             */
//          CEdit::OnChar(nChar, nRepCnt, nFlags);
        }

    } else {

        CEdit::OnChar(nChar, nRepCnt, nFlags);
    }

}  // end CBaseDropEditControl::OnChar


/////////////////////////////////////////////////////////////////////////////
// CBaseDropEditBox operations

void
CBaseDropEditBox::Subclass(CComboBox *pWnd)
{
    /*
     * Subclass this object to the specified combo box and let our edit
     * object subclass the combo box's edit control.
     */
    SubclassWindow(pWnd->GetSafeHwnd());
    m_EditControl.Subclass(pWnd);

}  // end CBaseDropEditBox::Subclass


////////////////////////////////////////////////////////////////////////////////
// CBaseDropEditBox message map

BEGIN_MESSAGE_MAP(CBaseDropEditBox, CComboBox)
	//{{AFX_MSG_MAP(CBaseDropEditBox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CBaseDropEditBox commands

////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\basedrpe.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* basedrpe.h
*
* interface of CBaseDropEditBox and CBaseDropEditControl classes
*   The CBaseDropEditBox class does things the way we like, overriding the base
*   CComboBox class.
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\COMMON\VCS\BASEDRPE.H  $
*  
*     Rev 1.1   29 Dec 1995 17:19:20   butchd
*  update
*
*******************************************************************************/

#ifndef BASEDRPE_INCLUDED
////////////////////////////////////////////////////////////////////////////////
// CBaseDropEditControl class
//
class CBaseDropEditControl : public CEdit
{
/*
 * Member variables.
 */
public:
private:
    CComboBox   *m_pComboBoxControl;

/*
 * Operations.
 */
public:
    BOOL Subclass(CComboBox *pWnd);

/*
 * Message map / commands.
 */
protected:
	//{{AFX_MSG(CBaseDropEditControl)
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end CBaseDropEditControl class interface 


////////////////////////////////////////////////////////////////////////////////
// CBaseDropEditBox class
//
class CBaseDropEditBox : public CComboBox
{
/*
 * Member variables.
 */
public:
private:
    CBaseDropEditControl    m_EditControl;

/*
 * Operations.
 */
public:
    void Subclass(CComboBox *pWnd);

/*
 * Message map / commands.
 */
protected:
	//{{AFX_MSG(CBaseDropEditBox)
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end CBaseDropEditBox class interface 
////////////////////////////////////////////////////////////////////////////////
#define BASEDRPE_INCLUDED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\common1.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "..\common\common.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\basedrpl.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* basedrpl.h
*
* interface of CBaseDropListBox class
*   The CBaseDropListBox class does things the way we like, overriding the base
*   CComboBox (no edit field) class.
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\COMMON\VCS\BASEDRPL.H  $
*  
*     Rev 1.1   29 Dec 1995 17:19:30   butchd
*  update
*
*******************************************************************************/

#ifndef BASEDRPL_INCLUDED
////////////////////////////////////////////////////////////////////////////////
// CBaseDropListBox class
//
class CBaseDropListBox : public CComboBox
{
/*
 * Member variables.
 */
public:
private:

/*
 * Operations.
 */
public:
    BOOL Subclass(CComboBox* pWnd);

/*
 * Message map / commands.
 */
protected:
	//{{AFX_MSG(CBaseDropListBox)
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end CBaseDropListBox class interface 
////////////////////////////////////////////////////////////////////////////////
#define BASEDRPL_INCLUDED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\defines.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* defines.h
*
* WinStation Configuration #defines needed for C++ and C compilations.
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\DEFINES.H  $
*  
*     Rev 1.5   27 Jun 1997 15:59:54   butchd
*  Registry changes for Wds/Tds/Pds/Cds
*  
*     Rev 1.4   24 Sep 1996 16:21:28   butchd
*  update
*  
*     Rev 1.3   20 Sep 1996 20:36:58   butchd
*  update
*  
*     Rev 1.2   12 Sep 1996 16:16:02   butchd
*  update
*  
*******************************************************************************/

/*
 * Define the global batch flag for all to see and Redefine the
 * ErrorMessage and StandardErrorMessage functions to skip if
 * in batch mode.
 */
#ifdef __cplusplus
extern "C" {
#endif
extern USHORT g_Batch;
#ifdef __cplusplus
}
#endif
#define WINAPPSTUFF         WinUtilsAppName, WinUtilsAppWindow, WinUtilsAppInstance
#define ERROR_MESSAGE(x)    { if ( !g_Batch ) ErrorMessage x ; }
#define STANDARD_ERROR_MESSAGE(x) { if ( !g_Batch ) StandardErrorMessage x ; }


/*
 * Default, min, max WinStation configuration settings
 */
#define CONNECTION_TIME_DIGIT_MAX           6       // 5 digits + NULL
#define CONNECTION_TIME_DEFAULT             120     // 120 minutes
#define CONNECTION_TIME_MIN                 1       // 1 minute
#define CONNECTION_TIME_MAX                 71582   // 71582 minutes (max msec for ULONG)

#define DISCONNECTION_TIME_DIGIT_MAX        6       // 5 digits + NULL
#define DISCONNECTION_TIME_DEFAULT          10      // 10 minutes
#define DISCONNECTION_TIME_MIN              1       // 1 minute
#define DISCONNECTION_TIME_MAX              71582   // 71582 minutes (max msec for ULONG)

#define IDLE_TIME_DIGIT_MAX                 6       // 5 digits + NULL
#define IDLE_TIME_DEFAULT                   30      // 30 minutes
#define IDLE_TIME_MIN                       1       // 1 minute
#define IDLE_TIME_MAX                       71582   // 71582 minutes (max msec for ULONG)

#define MODEM_RESET_TIME_DIGIT_MAX          5       // 4 digits + NULL
#define MODEM_RESET_TIME_DEFAULT            15      // 15 minutes
#define MODEM_RESET_TIME_MIN                5       // 5 minutes
#define MODEM_RESET_TIME_MAX                9999    // 9999 minutes

/*
 * Multi-instance WinStation defines
 */
#define INSTANCE_COUNT_DIGIT_MAX    6       // maximum # instances = 999999
#define INSTANCE_COUNT_MIN          1
#define INSTANCE_COUNT_MAX          999999
#define INSTANCE_COUNT_UNLIMITED    ((ULONG)-1)

/*
 * Timer storage resolution.
 */
#define TIME_RESOLUTION                     60000   // stored as msec-seen as minutes

/*
 * Keyboard state defines.
 */
#define KBDSHIFT    0x01
#define KBDCTRL     0x02
#define KBDALT      0x04

/*
 * Window messages private to WinCfg.
 */
#define WM_ADDWINSTATION        (WM_USER + 0)
#define WM_LISTINITERROR        (WM_USER + 1)
#define WM_EDITSETFIELDSERROR   (WM_USER + 2)
#define WM_ASYNCTESTERROR       (WM_USER + 3)
#define WM_ASYNCTESTABORT       (WM_USER + 4)
#define WM_ASYNCTESTSTATUSREADY (WM_USER + 5)
#define WM_ASYNCTESTINPUTREADY  (WM_USER + 6)
#define WM_ASYNCTESTWRITECHAR   (WM_USER + 7)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\common.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* common.h
*
* WINUTILS commmon helper function header file
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\COMMON\VCS\COMMON.H  $
*  
*     Rev 1.10   20 Sep 1996 20:35:34   butchd
*  update
*
*******************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef COMMON_H_INCLUDED
#define COMMON_H_INCLUDED
/*
 * Include files to be compatible with 'basic' NT typedefs, defines, and function
 * prototypes.  All WINUTILS WIN16 applications which are derived from a common
 * WIN32 (NT) code base should include this file (common.h ) to take care of this
 * stuff.
 */
#ifdef WIN16
#include <stdarg.h>		// for va_list, va_start, va_end definitions
#include <string.h>		// for strncpy and related functions
#ifndef _INC_TCHAR
#include <tchar.h>      // for TCHAR related stuff (provided for in afxver_.h)
#define TEXT    _T
#define LPCTSTR LPCSTR
#define LPTSTR  LPSTR
#endif  /* _INC_TCHAR */
#define MAX_PATH    255
typedef unsigned short USHORT;
typedef unsigned long ULONG;
#define BASED_DATA __based(__segname("_DATA")) 
#else   // WIN32
#define BASED_DATA
#endif  // WIN16

/* 
 * WINUTILS common helper function typedefs & defines
 */

/* 
 * WINUTILS common helper function prototypes
 */
void ErrorMessage( int nErrorResourceID, ...);
void ErrorMessageStr( LPTSTR pErrorString, int nErrorStringLen,
                      int nErrorResourceID, ...);

#ifdef WIN16
void ErrorMessageWnd( HWND hWnd, int nErrorResourceID, ...);
#else
void ErrorMessageWndA( HWND hWnd, int nErrorResourceID, ...);
void ErrorMessageWndW( HWND hWnd, int nErrorResourceID, ...);
#ifdef UNICODE
#define ErrorMessageWnd ErrorMessageWndW
#else
#define ErrorMessageWnd ErrorMessageWndA
#endif // UNICODE
#endif // WIN16

int QuestionMessage( UINT nType, int nQuestionResourceID, ...);
int QuestionMessageWnd( HWND hWnd, UINT nType, int nQuestionResourceID, ...);

/*
 * ANSI / UNICODE function defines
 */
#include "..\..\inc\ansiuni.h"

#endif  // COMMON_H_INCLUDED

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\basedrpl.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* basedrpl.cpp
*
* implementation of CBaseDropListBox class
*   The CBaseDropListBox class does things the way we like, overriding the base
*   CComboBox (no edit field) class.
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\COMMON\VCS\BASEDRPL.CPP  $
*  
*     Rev 1.1   29 Dec 1995 17:19:26   butchd
*  update
*  
*******************************************************************************/

/*
 * include files
 */
#include <stdafx.h>
#include <afxwin.h>             // MFC core and standard components
#include <afxext.h>             // MFC extensions
#include "basedrpl.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseDropListBox operations

BOOL
CBaseDropListBox::Subclass(CComboBox *pWnd)
{
    return( SubclassWindow(pWnd->GetSafeHwnd()) );

}  // end CBaseDropListBox::Subclass


////////////////////////////////////////////////////////////////////////////////
// CBaseDropListBox message map

BEGIN_MESSAGE_MAP(CBaseDropListBox, CComboBox)
	//{{AFX_MSG_MAP(CBaseDropListBox)
	ON_WM_GETDLGCODE()
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CBaseDropListBox commands

UINT
CBaseDropListBox::OnGetDlgCode() 
{
    return( CComboBox::OnGetDlgCode() | 
            (GetDroppedState() ? DLGC_WANTALLKEYS : 0) );

}  // end CBaseDropListBox::OnGetDlgCode


void
CBaseDropListBox::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
    if ( ((nChar == VK_ESCAPE) || (nChar == VK_RETURN) || (nChar == VK_TAB)) &&
         GetDroppedState() ) {

        ShowDropDown(FALSE);

        if ( nChar == VK_TAB ) {

            /* 
             * CODEWORK: need to figgure out how to set focus to the next
             * or previous control when TAB (or shift-TAB) is pressed while
             * we've gobbled up all keys.  Here are 3 atempts that don't quite
             * do what is needed [remember: the final solution must work for
             * both tabbed-dialog as well as regular dialog, in all Windows
             * host models (Win31, WinNT, Win95)!]
             */

            /* Try #1
             * Post a TAB WM_KEYDOWN message to the parent (grandparent if parent
             * is a property page).
             */
//          CWnd *pParent = GetParent();
//          if ( pParent->IsKindOf(RUNTIME_CLASS(CPropertyPage)) )
//              pParent = pParent->GetParent();
//
//          pParent->PostMessage( WM_KEYDOWN, (WPARAM)VK_TAB, (LPARAM)0 );

            /* Try #2
             * Issue a Next or Prev dialog control message to the control's parent,
             * based on the state of the shift key.
             */
//          CDialog *pParent = (CDialog *)GetParent();
//          if ( (GetKeyState(VK_SHIFT) < 0) ) {
//              pParent->PrevDlgCtrl();
//          } else {
//              pParent->NextDlgCtrl();
//          }

            /* Try #3
             * Just pass the VK_TAB along to our control.
             */
//          CComboBox::OnChar(nChar, nRepCnt, nFlags);
        }

    } else {

        CComboBox::OnChar(nChar, nRepCnt, nFlags);
    }

}  // end CBaseDropListBox::OnChar

////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\dialogs.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* dialogs.cpp
*
* implementation of WINCFG dialogs
*
* copyright notice: Copyright 1996, Citrix Systems Inc.
*
* $Author:   donm  $  Butch Davis
*
* $Log:   N:\nt\private\utils\citrix\winutils\tscfg\VCS\dialogs.cpp  $
*  
*     Rev 1.59   18 Apr 1998 15:32:48   donm
*  Added capability bits
*  
*     Rev 1.58   06 Feb 1998 14:37:52   donm
*  fixed trap when no encyrption levels
*  
*     Rev 1.2   29 Jan 1998 17:29:10   donm
*  sets default encryption and grays out control properly
*  
*     Rev 1.1   15 Jan 1998 17:57:08   thanhl
*  Hydra merge
*  
*     Rev 1.56   13 Jan 1998 14:08:18   donm
*  gets encryption levels from extension DLL
*  
*     Rev 1.55   31 Jul 1997 16:33:20   butchd
*  update
*  
*     Rev 1.54   25 Mar 1997 15:42:14   butchd
*  update
*  
*     Rev 1.53   16 Nov 1996 16:11:48   butchd
*  update
*  
*     Rev 1.52   27 Sep 1996 17:52:22   butchd
*  update
*  
*******************************************************************************/

/*
 * include files
 */
#include "stdafx.h"
#include "wincfg.h"
#include "appsvdoc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CWincfgApp *pApp;

/*
 * Global variables for WINUTILS Common functions.
 */
extern "C" HWND WinUtilsAppWindow;

/*
 * Global command line variables.
 */

////////////////////////////////////////////////////////////////////////////////
// CAdvancedWinStationDlg class construction / destruction, implementation

/*******************************************************************************
 *
 *  CAdvancedWinStationDlg - CAdvancedWinStationDlg constructor
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CDialog::CDialog documentation)
 *
 ******************************************************************************/

CAdvancedWinStationDlg::CAdvancedWinStationDlg()
    : CBaseDialog(CAdvancedWinStationDlg::IDD)
{
    //{{AFX_DATA_INIT(CAdvancedWinStationDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

}  // end CAdvancedWinStationDlg::CAdvancedWinStationDlg


////////////////////////////////////////////////////////////////////////////////
// CAdvancedWinStationDlg operations

/*******************************************************************************
 *
 *  HandleEnterEscKey - CAdvancedWinStationDlg member function:
 *                          private operation
 *
 *      If the ENTER or ESC key is pressed while a combo box is dropped down,
 *      treat as combo box selection (suppress OnOk/OnCancel notification).
 *
 *  ENTRY:
 *      nID (input)
 *          IDOK if OK button (ENTER) brought us here; otherwise, IDCANCEL for
 *          Cancel button (ESC).
 *  EXIT:
 *      TRUE to process Enter/Esc (perform OnOk/OnCancel); FALSE to ignore
 *      (a combo box is dropped down).
 *
 ******************************************************************************/

BOOL
CAdvancedWinStationDlg::HandleEnterEscKey(int nID)
{
    CComboBox *pEncryption = (CComboBox *)GetDlgItem(IDC_AWS_SECURITY_ENCRYPT);
    CComboBox *pBroken = (CComboBox *)GetDlgItem(IDC_AWS_BROKEN);
    CComboBox *pReconnect = (CComboBox *)GetDlgItem(IDC_AWS_RECONNECT);
    CComboBox *pShadow = (CComboBox *)GetDlgItem(IDC_AWS_SHADOW);

    /*
     * Check encryption level combo-box.
     */
    if ( pEncryption->GetDroppedState() ) {

        if ( nID == IDCANCEL )      // select original selection
			for(ULONG i = 0; i < m_NumEncryptionLevels; i++) {
				if((int)(m_UserConfig.MinEncryptionLevel) == (int)(m_pEncryptionLevels[i].RegistryValue))
					pEncryption->SetCurSel(i);
			}
        pEncryption->ShowDropDown(FALSE);
        return(FALSE);
    }

    /*
     * Check broken connection combo-box.
     */
    if ( pBroken->GetDroppedState() ) {

        if ( nID == IDCANCEL )      // select original selection
            pBroken->SetCurSel((int)(m_UserConfig.fResetBroken));
        pBroken->ShowDropDown(FALSE);
        return(FALSE);
    }

    /*
     * Check reconnect session combo-box.
     */
    if ( pReconnect->GetDroppedState() ) {

        if ( nID == IDCANCEL )      // select original selection
            pReconnect->SetCurSel((int)(m_UserConfig.fReconnectSame));
        pReconnect->ShowDropDown(FALSE);
        return(FALSE);
    }

    /*
     * Check shadowing combo-box.
     */
    if ( pShadow->GetDroppedState() ) {

        if ( nID == IDCANCEL )      // select original selection
            pShadow->SetCurSel((int)(m_UserConfig.Shadow));
        pShadow->ShowDropDown(FALSE);
        return(FALSE);
    }

    /*
     * No combo boxes are down; process Enter/Esc
     */
    return(TRUE);

}  // end CAdvancedWinStationDlg::HandleEnterEscKey


////////////////////////////////////////////////////////////////////////////////
// CAdvancedWinStationDlg message map

BEGIN_MESSAGE_MAP(CAdvancedWinStationDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CAdvancedWinStationDlg)
    ON_BN_CLICKED(IDC_AWS_CONNECTION_NONE, OnClickedAwsConnectionNone)
    ON_BN_CLICKED(IDC_AWS_CONNECTION_INHERIT, OnClickedAwsConnectionInherit)
    ON_BN_CLICKED(IDC_AWS_DISCONNECTION_NONE, OnClickedAwsDisconnectionNone)
    ON_BN_CLICKED(IDC_AWS_DISCONNECTION_INHERIT, OnClickedAwsDisconnectionInherit)
    ON_BN_CLICKED(IDC_AWS_IDLE_NONE, OnClickedAwsIdleNone)
    ON_BN_CLICKED(IDC_AWS_IDLE_INHERIT, OnClickedAwsIdleInherit)
    ON_BN_CLICKED(IDC_AWS_AUTOLOGON_INHERIT, OnClickedAwsAutologonInherit)
    ON_BN_CLICKED(IDC_AWS_AUTOLOGON_PASSWORD_PROMPT, OnClickedAwsPromptForPassword)
    ON_BN_CLICKED(IDC_AWS_INITIALPROGRAM_INHERIT, OnClickedAwsInitialprogramInherit)
	ON_BN_CLICKED(IDC_AWS_INITIALPROGRAM_PUBLISHEDONLY, OnClickedAwsInitialprogramPublishedonly)
//    ON_BN_CLICKED(IDC_AWS_SECURITY_DISABLEENCRYPTION, OnClickedAwsSecurityDisableencryption)
    ON_BN_CLICKED(IDC_AWS_USEROVERRIDE_DISABLEWALLPAPER, OnClickedAwsUseroverrideDisablewallpaper)
    ON_BN_CLICKED(IDC_AWS_BROKEN_INHERIT, OnClickedAwsBrokenInherit)
    ON_BN_CLICKED(IDC_AWS_RECONNECT_INHERIT, OnClickedAwsReconnectInherit)
    ON_BN_CLICKED(IDC_AWS_SHADOW_INHERIT, OnClickedAwsShadowInherit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


////////////////////////////////////////////////////////////////////////////////
// CAdvancedWinStationDlg commands

/*******************************************************************************
 *
 *  OnInitDialog - CAdvancedWinStationDlg member function: command (override)
 *
 *      Performs the dialog intialization.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnInitDialog documentation)
 *
 ******************************************************************************/

BOOL
CAdvancedWinStationDlg::OnInitDialog()
{
    int i;
    CString string;
    CComboBox *pComboBox;

    /*
     * Call the parent classes' OnInitDialog to perform default dialog
     * initialization.
     */    
    CBaseDialog::OnInitDialog();

    m_Capabilities = m_pTermObject ? m_pTermObject->m_Capabilities : 0;

    /*
     * Set WinStation state radio buttons.
     */
    CheckRadioButton( IDC_AWS_WSDISABLED, IDC_AWS_WSENABLED,
                      IDC_AWS_WSDISABLED + (int)m_fEnableWinStation );

    /*
     * Set the Connection Timeout fields.
     */
    CheckDlgButton( IDC_AWS_CONNECTION_NONE,
                    m_UserConfig.MaxConnectionTime ? FALSE : TRUE);
    OnClickedAwsConnectionNone();
    CheckDlgButton( IDC_AWS_CONNECTION_INHERIT,
                    m_UserConfig.fInheritMaxSessionTime );
    OnClickedAwsConnectionInherit();

    /*
     * Set the Disconnection Timeout fields.
     */
    CheckDlgButton( IDC_AWS_DISCONNECTION_NONE,
                    m_UserConfig.MaxDisconnectionTime ? FALSE : TRUE);
    OnClickedAwsDisconnectionNone();
    CheckDlgButton( IDC_AWS_DISCONNECTION_INHERIT,
                    m_UserConfig.fInheritMaxDisconnectionTime );
    OnClickedAwsDisconnectionInherit();

    /*
     * Set the Idle Timeout fields.
     */
    CheckDlgButton( IDC_AWS_IDLE_NONE,
                    m_UserConfig.MaxIdleTime ? FALSE : TRUE);
    OnClickedAwsIdleNone();
    CheckDlgButton( IDC_AWS_IDLE_INHERIT,
                    m_UserConfig.fInheritMaxIdleTime );
    OnClickedAwsIdleInherit();

    /*
     * Set AutoLogon fields.
     */
    CheckDlgButton( IDC_AWS_AUTOLOGON_PASSWORD_PROMPT,
                    m_UserConfig.fPromptForPassword );
    CheckDlgButton( IDC_AWS_AUTOLOGON_INHERIT,
                    m_UserConfig.fInheritAutoLogon );
    OnClickedAwsAutologonInherit();

    /*
     * Set Initial Program fields.
     */
    CheckDlgButton( IDC_AWS_INITIALPROGRAM_INHERIT,
                    m_UserConfig.fInheritInitialProgram );
    CheckDlgButton( IDC_AWS_INITIALPROGRAM_PUBLISHEDONLY,
                    m_UserConfig.fDisableExe );
    OnClickedAwsInitialprogramInherit();

    /*
     * Load combo box strings and set Security fields.
     */
    pComboBox = (CComboBox *)GetDlgItem(IDC_AWS_SECURITY_ENCRYPT);

    m_pEncryptionLevels = NULL;
    m_NumEncryptionLevels = 0L;
    m_DefaultEncryptionLevelIndex = 0;
    BOOL bSet = FALSE;

    // Get the array of encryption levels from the extension DLL
    if(m_pTermObject && m_pTermObject->m_hExtensionDLL && m_pTermObject->m_lpfnExtEncryptionLevels)
        m_NumEncryptionLevels = (*m_pTermObject->m_lpfnExtEncryptionLevels)(&(m_pTermObject->m_WdConfig.Wd.WdName), &m_pEncryptionLevels);
                                 										   
    if(m_pEncryptionLevels) {
        // Loop through the encryption levels, read in their strings,
        // and add them to the combo box
        for(UINT i = 0; i < m_NumEncryptionLevels; i++) {
            TCHAR estring[128];
            if(::LoadString(m_pTermObject->m_hExtensionDLL,
                m_pEncryptionLevels[i].StringID, estring, 127)) {
                    pComboBox->AddString(estring);
            }

            // If this is the default encryption level, remember its value
            if(m_pEncryptionLevels[i].Flags & ELF_DEFAULT)
                m_DefaultEncryptionLevelIndex = i;

            // If this is the currently selected encryption level
            if(m_pEncryptionLevels[i].RegistryValue == (DWORD)m_UserConfig.MinEncryptionLevel) {
                bSet = TRUE;
                pComboBox->SetCurSel(i);
            }
        }

        // If the WinStation's encryption level didn't match one of the
        // levels returned by the extension DLL, set the level to the
        // default
        if(!bSet) {
            pComboBox->SetCurSel(m_DefaultEncryptionLevelIndex);
            m_UserConfig.MinEncryptionLevel = (UCHAR)(m_pEncryptionLevels[m_DefaultEncryptionLevelIndex].RegistryValue);
        }

    } else {
        // There aren't any encryption levels
        // Disable the combo box
        GetDlgItem(IDL_AWS_SECURITY_ENCRYPT1)->EnableWindow(FALSE);
        pComboBox->EnableWindow(FALSE);
        m_UserConfig.MinEncryptionLevel = 0;
    }

    CheckDlgButton( IDC_AWS_SECURITY_DEFAULTGINA,
                    m_UserConfig.fUseDefaultGina );

    /*
     * Set User Profile Override fields
     */
    CheckDlgButton( IDC_AWS_USEROVERRIDE_DISABLEWALLPAPER,
                    m_UserConfig.fWallPaperDisabled );

    /*
     * Load combo box strings and set Connection fields.
     */
    pComboBox = (CComboBox *)GetDlgItem(IDC_AWS_BROKEN);
    string.LoadString(IDS_AWS_BROKEN_DISCONNECT);
    pComboBox->AddString(string);
    string.LoadString(IDS_AWS_BROKEN_RESET);
    pComboBox->AddString(string);
    pComboBox->SetCurSel(m_UserConfig.fResetBroken);
    CheckDlgButton( IDC_AWS_BROKEN_INHERIT,
                    m_UserConfig.fInheritResetBroken );
    OnClickedAwsBrokenInherit();

    /*
     * Load combo box strings and set Reconnection fields.
     */
    pComboBox = (CComboBox *)GetDlgItem(IDC_AWS_RECONNECT);
    string.LoadString(IDS_AWS_RECONNECT_FROM_ANY);
    pComboBox->AddString(string);
    string.LoadString(IDS_AWS_RECONNECT_FROM_THIS);
    pComboBox->AddString(string);
    pComboBox->SetCurSel(m_UserConfig.fReconnectSame);
    CheckDlgButton( IDC_AWS_RECONNECT_INHERIT,
                    m_UserConfig.fInheritReconnectSame );
    OnClickedAwsReconnectInherit();

    /*
     * Load combo box strings and set Shadow fields.
     */
    pComboBox = (CComboBox *)GetDlgItem(IDC_AWS_SHADOW);
    string.LoadString(IDS_AWS_SHADOW_DISABLED);
    pComboBox->AddString(string);
    string.LoadString(IDS_AWS_SHADOW_ENABLED_ON_ON);
    pComboBox->AddString(string);
    string.LoadString(IDS_AWS_SHADOW_ENABLED_ON_OFF);
    pComboBox->AddString(string);
    string.LoadString(IDS_AWS_SHADOW_ENABLED_OFF_ON);
    pComboBox->AddString(string);
    string.LoadString(IDS_AWS_SHADOW_ENABLED_OFF_OFF);
    pComboBox->AddString(string);
    pComboBox->SetCurSel(m_UserConfig.Shadow);
    CheckDlgButton( IDC_AWS_SHADOW_INHERIT,
                    m_UserConfig.fInheritShadow );

    if(m_Capabilities & WDC_SHADOWING) {
        OnClickedAwsShadowInherit();
    } else {
        GetDlgItem(IDL_AWS_SHADOW)->EnableWindow(FALSE);
        GetDlgItem(IDC_AWS_SHADOW)->EnableWindow(FALSE);
        GetDlgItem(IDC_AWS_SHADOW_INHERIT)->EnableWindow(FALSE);
    }

    /*
     * Process based on document's read/write state.
     */
    if ( m_bReadOnly ) {

        /*                          
         * Document is 'read-only': disable all dialog controls and labels
         * except for CANCEL and HELP buttons.
         */
        for ( i=IDL_AWS_WSSTATE; i <=IDC_AWS_SHADOW_INHERIT; i++ )
            GetDlgItem(i)->EnableWindow(FALSE);
        GetDlgItem(IDOK)->EnableWindow(FALSE);

    } else {

        /*
         * The document is 'read-write': set the maximum length for the edit
         * controls.
         */
        ((CEdit *)GetDlgItem(IDC_AWS_AUTOLOGON_USERNAME))
                ->LimitText(USERNAME_LENGTH);
        ((CEdit *)GetDlgItem(IDC_AWS_AUTOLOGON_DOMAIN))
                ->LimitText(DOMAIN_LENGTH);
        ((CEdit *)GetDlgItem(IDC_AWS_AUTOLOGON_PASSWORD))
                ->LimitText(PASSWORD_LENGTH);
        ((CEdit *)GetDlgItem(IDC_AWS_AUTOLOGON_CONFIRM_PASSWORD))
                ->LimitText(PASSWORD_LENGTH);

        ((CEdit *)GetDlgItem(IDC_AWS_INITIALPROGRAM_COMMANDLINE))
                ->LimitText(INITIALPROGRAM_LENGTH);
        ((CEdit *)GetDlgItem(IDC_AWS_INITIALPROGRAM_WORKINGDIRECTORY))
                ->LimitText(DIRECTORY_LENGTH);

        ((CEdit *)GetDlgItem(IDC_AWS_CONNECTION))
                ->LimitText(CONNECTION_TIME_DIGIT_MAX-1);
        ((CEdit *)GetDlgItem(IDC_AWS_DISCONNECTION))
                ->LimitText(DISCONNECTION_TIME_DIGIT_MAX-1);
        ((CEdit *)GetDlgItem(IDC_AWS_IDLE))
                ->LimitText(IDLE_TIME_DIGIT_MAX-1);

        /*
         * If this WinStation is the System Console, disable the WinStation
         * state fields.
         */
        if ( m_bSystemConsole )
            for ( i=IDL_AWS_WSSTATE; i <=IDC_AWS_WSENABLED; i++ )
            GetDlgItem(i)->EnableWindow(FALSE);
    }        

    /*
     * Set all combo boxes to use the 'extended' UI.
     */
    ((CComboBox *)GetDlgItem(IDC_AWS_SECURITY_ENCRYPT))->SetExtendedUI(TRUE);
    ((CComboBox *)GetDlgItem(IDC_AWS_BROKEN))->SetExtendedUI(TRUE);
    ((CComboBox *)GetDlgItem(IDC_AWS_RECONNECT))->SetExtendedUI(TRUE);
    ((CComboBox *)GetDlgItem(IDC_AWS_SHADOW))->SetExtendedUI(TRUE);

    return(TRUE);

}  // end CAdvancedWinStationDlg::OnInitDialog


/*******************************************************************************
 *
 *  OnClickedAwsConnectionNone - CAdvancedWinStationDlg
 *                                member function: command
 *
 *      Process the connection timeout field when the 'none' checkbox is
 *      checked or unchecked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsConnectionNone()
{
    if ( ((CButton *)GetDlgItem(IDC_AWS_CONNECTION_NONE))->GetCheck() ) {

        /*
         * The user checked 'none' box: blank the connection
         * timeout field, set to zero,  and disable it.
         */
        SetDlgItemText(IDC_AWS_CONNECTION, TEXT(""));
        m_UserConfig.MaxConnectionTime = 0;
        GetDlgItem(IDL_AWS_CONNECTION)->EnableWindow(FALSE);
        GetDlgItem(IDC_AWS_CONNECTION)->EnableWindow(FALSE);

    } else {

        TCHAR string[CONNECTION_TIME_DIGIT_MAX];

        /*
         * The user unchecked 'none' box: enable the connection timeout
         * field, fill it in (default if necessary), and set focus there.
         */
        GetDlgItem(IDL_AWS_CONNECTION)->EnableWindow(TRUE);
        GetDlgItem(IDC_AWS_CONNECTION)->EnableWindow(TRUE);
        if ( !m_UserConfig.MaxConnectionTime )
            m_UserConfig.MaxConnectionTime =
                (CONNECTION_TIME_DEFAULT * TIME_RESOLUTION);
        wsprintf(string, TEXT("%lu"), m_UserConfig.MaxConnectionTime / TIME_RESOLUTION);
        SetDlgItemText(IDC_AWS_CONNECTION, string);
        GotoDlgCtrl(GetDlgItem(IDC_AWS_CONNECTION));
    }

}  // end CAdvancedWinStationDlg::OnClickedAwsConnectionNone


/*******************************************************************************
 *
 *  OnClickedAwsConnectionInherit - CAdvancedWinStationDlg
 *                                   member function: command
 *
 *      Process the connection timeout field when the 'inherit user config'
 *      checkbox is checked or unchecked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsConnectionInherit()
{
    if ( (m_UserConfig.fInheritMaxSessionTime = 
            ((CButton *)GetDlgItem(IDC_AWS_CONNECTION_INHERIT))->GetCheck()) ) {

         /*
          * When 'inherit' button is checked, default to 'none'.
          */
        CheckDlgButton(IDC_AWS_CONNECTION_NONE, TRUE);
        OnClickedAwsConnectionNone();
    }

    GetDlgItem(IDL_AWS_CONNECTION)->
        EnableWindow( (m_UserConfig.fInheritMaxSessionTime || 
                       !m_UserConfig.MaxConnectionTime) ? FALSE : TRUE );
    GetDlgItem(IDC_AWS_CONNECTION)->
        EnableWindow( (m_UserConfig.fInheritMaxSessionTime || 
                       !m_UserConfig.MaxConnectionTime) ? FALSE : TRUE );
    GetDlgItem(IDC_AWS_CONNECTION_NONE)->
        EnableWindow(m_UserConfig.fInheritMaxSessionTime ? FALSE : TRUE);

}  // end CAdvancedWinStationDlg::OnClickedAwsConnectionInherit


/*******************************************************************************
 *
 *  OnClickedAwsDisconnectionNone - CAdvancedWinStationDlg
 *                                   member function: command
 *
 *      Process the disconnection timeout field when the 'none' checkbox is
 *      checked or unchecked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsDisconnectionNone()
{
    if ( ((CButton *)GetDlgItem(IDC_AWS_DISCONNECTION_NONE))->GetCheck() ) {

        /*
         * The user checked 'none' box: blank the disconnection
         * timeout field, set to zero,  and disable it.
         */
        SetDlgItemText(IDC_AWS_DISCONNECTION, TEXT(""));
        m_UserConfig.MaxDisconnectionTime = 0;
        GetDlgItem(IDL_AWS_DISCONNECTION)->EnableWindow(FALSE);
        GetDlgItem(IDC_AWS_DISCONNECTION)->EnableWindow(FALSE);

    } else {

        TCHAR string[DISCONNECTION_TIME_DIGIT_MAX];

        /*
         * The user unchecked 'none' box: enable the disconnection timeout
         * field, fill it in (default if necessary), and set focus there.
         */
        GetDlgItem(IDL_AWS_DISCONNECTION)->EnableWindow(TRUE);
        GetDlgItem(IDC_AWS_DISCONNECTION)->EnableWindow(TRUE);
        if ( !m_UserConfig.MaxDisconnectionTime )
            m_UserConfig.MaxDisconnectionTime =
                (DISCONNECTION_TIME_DEFAULT * TIME_RESOLUTION);
        wsprintf(string, TEXT("%lu"), m_UserConfig.MaxDisconnectionTime / TIME_RESOLUTION);
        SetDlgItemText(IDC_AWS_DISCONNECTION, string);
        GotoDlgCtrl(GetDlgItem(IDC_AWS_DISCONNECTION));
    }

}  // end CAdvancedWinStationDlg::OnClickedAwsDisconnectionNone


/*******************************************************************************
 *
 *  OnClickedAwsDisconnectionInherit - CAdvancedWinStationDlg
 *                                      member function: command
 *
 *      Process the disconnection timeout field when the 'inherit user config'
 *      checkbox is checked or unchecked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsDisconnectionInherit()
{
    if ( (m_UserConfig.fInheritMaxDisconnectionTime = 
            ((CButton *)GetDlgItem(IDC_AWS_DISCONNECTION_INHERIT))->GetCheck()) ) {

         /*
          * When 'inherit' button is checked, default to 'none'.
          */
        CheckDlgButton(IDC_AWS_DISCONNECTION_NONE, TRUE);
        OnClickedAwsDisconnectionNone();
    }

    GetDlgItem(IDL_AWS_DISCONNECTION)->
        EnableWindow( (m_UserConfig.fInheritMaxDisconnectionTime || 
                       !m_UserConfig.MaxDisconnectionTime) ? FALSE : TRUE );
    GetDlgItem(IDC_AWS_DISCONNECTION)->
        EnableWindow( (m_UserConfig.fInheritMaxDisconnectionTime || 
                       !m_UserConfig.MaxDisconnectionTime) ? FALSE : TRUE );
    GetDlgItem(IDC_AWS_DISCONNECTION_NONE)->
        EnableWindow(m_UserConfig.fInheritMaxDisconnectionTime ? FALSE : TRUE);

}  // end CAdvancedWinStationDlg::OnClickedAwsDisconnectionInherit


/*******************************************************************************
 *
 *  OnClickedAwsIdleNone - CAdvancedWinStationDlg member function: command
 *
 *      Process the idle timeout field when the 'none' checkbox is
 *      checked or unchecked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsIdleNone()
{
    if ( ((CButton *)GetDlgItem(IDC_AWS_IDLE_NONE))->GetCheck() ) {

        /*
         * The user checked 'none' box: blank the idle
         * timeout field, set to zero,  and disable it.
         */
        SetDlgItemText(IDC_AWS_IDLE, TEXT(""));
        m_UserConfig.MaxIdleTime = 0;
        GetDlgItem(IDL_AWS_IDLE)->EnableWindow(FALSE);
        GetDlgItem(IDC_AWS_IDLE)->EnableWindow(FALSE);

    } else {

        TCHAR string[IDLE_TIME_DIGIT_MAX];

        /*
         * The user unchecked 'none' box: enable the idle timeout
         * field, fill it in (default if necessary), and set focus there.
         */
        GetDlgItem(IDL_AWS_IDLE)->EnableWindow(TRUE);
        GetDlgItem(IDC_AWS_IDLE)->EnableWindow(TRUE);
        if ( !m_UserConfig.MaxIdleTime )
            m_UserConfig.MaxIdleTime =
                (IDLE_TIME_DEFAULT * TIME_RESOLUTION);
        wsprintf(string, TEXT("%lu"), m_UserConfig.MaxIdleTime / TIME_RESOLUTION);
        SetDlgItemText(IDC_AWS_IDLE, string);
        GotoDlgCtrl(GetDlgItem(IDC_AWS_IDLE));
    }

}  // end CAdvancedWinStationDlg::OnClickedAwsIdleNone


/*******************************************************************************
 *
 *  OnClickedAwsIdleInherit - CAdvancedWinStationDlg member function: command
 *
 *      Process the idle timeout field when the 'inherit user config' checkbox
 *      is checked or unchecked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsIdleInherit()
{
    if ( (m_UserConfig.fInheritMaxIdleTime = 
            ((CButton *)GetDlgItem(IDC_AWS_IDLE_INHERIT))->GetCheck()) ) {

         /*
          * When 'inherit' button is checked, default to 'none'.
          */
        CheckDlgButton(IDC_AWS_IDLE_NONE, TRUE);
        OnClickedAwsIdleNone();
    }

    GetDlgItem(IDL_AWS_IDLE)->
        EnableWindow( (m_UserConfig.fInheritMaxIdleTime || 
                       !m_UserConfig.MaxIdleTime) ? FALSE : TRUE );
    GetDlgItem(IDC_AWS_IDLE)->
        EnableWindow( (m_UserConfig.fInheritMaxIdleTime || 
                       !m_UserConfig.MaxIdleTime) ? FALSE : TRUE );
    GetDlgItem(IDC_AWS_IDLE_NONE)->
        EnableWindow(m_UserConfig.fInheritMaxIdleTime ? FALSE : TRUE);

}  // end CAdvancedWinStationDlg::OnClickedAwsIdleInherit


/*******************************************************************************
 *
 *  OnClickedAwsAutologonInherit - CAdvancedWinStationDlg
 *                                  member function: command
 *
 *      Process the auto logon fields when the 'inherit client config' checkbox\
 *      is checked or unchecked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsAutologonInherit()
{
    if ( (m_UserConfig.fInheritAutoLogon =
          ((CButton *)GetDlgItem(IDC_AWS_AUTOLOGON_INHERIT))->GetCheck()) ) {

         /*
          * When 'inherit' button is checked, default fields to empty.
          */
         memset(m_UserConfig.UserName, 0, sizeof(m_UserConfig.UserName));
         memset(m_UserConfig.Domain, 0, sizeof(m_UserConfig.Domain));
         memset(m_UserConfig.Password, 0, sizeof(m_UserConfig.Password));
      
    }

    SetDlgItemText(IDC_AWS_AUTOLOGON_USERNAME, m_UserConfig.UserName);
    SetDlgItemText(IDC_AWS_AUTOLOGON_DOMAIN, m_UserConfig.Domain);
    SetDlgItemText(IDC_AWS_AUTOLOGON_PASSWORD, m_UserConfig.Password);
    SetDlgItemText(IDC_AWS_AUTOLOGON_CONFIRM_PASSWORD, m_UserConfig.Password);

    GetDlgItem(IDL_AWS_AUTOLOGON_USERNAME)->
        EnableWindow(m_UserConfig.fInheritAutoLogon ? FALSE : TRUE);
    GetDlgItem(IDC_AWS_AUTOLOGON_USERNAME)->
        EnableWindow(m_UserConfig.fInheritAutoLogon ? FALSE : TRUE);
    GetDlgItem(IDL_AWS_AUTOLOGON_DOMAIN)->
        EnableWindow(m_UserConfig.fInheritAutoLogon ? FALSE : TRUE);
    GetDlgItem(IDC_AWS_AUTOLOGON_DOMAIN)->
        EnableWindow(m_UserConfig.fInheritAutoLogon ? FALSE : TRUE);
    GetDlgItem(IDL_AWS_AUTOLOGON_PASSWORD)->
        EnableWindow((!m_UserConfig.fInheritAutoLogon && !m_UserConfig.fPromptForPassword));
    GetDlgItem(IDC_AWS_AUTOLOGON_PASSWORD)->
        EnableWindow((!m_UserConfig.fInheritAutoLogon && !m_UserConfig.fPromptForPassword));
    GetDlgItem(IDL_AWS_AUTOLOGON_CONFIRM_PASSWORD)->
        EnableWindow((!m_UserConfig.fInheritAutoLogon && !m_UserConfig.fPromptForPassword));
    GetDlgItem(IDC_AWS_AUTOLOGON_CONFIRM_PASSWORD)->
        EnableWindow((!m_UserConfig.fInheritAutoLogon && !m_UserConfig.fPromptForPassword));
    if(!m_UserConfig.fInheritAutoLogon)
        GetDlgItem(IDC_AWS_AUTOLOGON_USERNAME)->SetFocus();

    


}  // end CAdvancedWinStationDlg::OnClickedAwsAutologonInherit

/*******************************************************************************
 *
 *  OnClickedAwsPromptforPassword - CAdvancedWinStationDlg
 *                                  member function: command
 *
 *      Process the auto logon fields when the 'Prompt for password' checkbox\
 *      is checked or unchecked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsPromptForPassword()
{
    if ( (m_UserConfig.fPromptForPassword =
          ((CButton *)GetDlgItem(IDC_AWS_AUTOLOGON_PASSWORD_PROMPT))->GetCheck()) ) {

         /*
          * When 'Prompt for Password' button is checked, default password field to empty.
          */
         memset(m_UserConfig.Password, 0, sizeof(m_UserConfig.Password));
    }
    if(m_UserConfig.fInheritAutoLogon)
        return;

    SetDlgItemText(IDC_AWS_AUTOLOGON_PASSWORD, m_UserConfig.Password);
    SetDlgItemText(IDC_AWS_AUTOLOGON_CONFIRM_PASSWORD, m_UserConfig.Password);

    GetDlgItem(IDL_AWS_AUTOLOGON_PASSWORD)->
        EnableWindow(m_UserConfig.fPromptForPassword ? FALSE : TRUE);
    GetDlgItem(IDC_AWS_AUTOLOGON_PASSWORD)->
        EnableWindow(m_UserConfig.fPromptForPassword ? FALSE : TRUE);
    GetDlgItem(IDL_AWS_AUTOLOGON_CONFIRM_PASSWORD)->
        EnableWindow(m_UserConfig.fPromptForPassword ? FALSE : TRUE);
    GetDlgItem(IDC_AWS_AUTOLOGON_CONFIRM_PASSWORD)->
        EnableWindow(m_UserConfig.fPromptForPassword ? FALSE : TRUE);

}  // end CAdvancedWinStationDlg::OnClickedAwsPromptforPassword

/*******************************************************************************
 *
 *  OnClickedAwsInitialprogramInherit - CAdvancedWinStationDlg
 *                                       member function: command
 *
 *      Process the initial program fields when the 'inherit client/user config'
 *      checkbox is checked or unchecked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsInitialprogramInherit()
{
    if ( (m_UserConfig.fInheritInitialProgram =
          ((CButton *)GetDlgItem(IDC_AWS_INITIALPROGRAM_INHERIT))->GetCheck()) ) {

         /*
          * When 'inherit' button is checked, default fields to empty.
          */
         memset(m_UserConfig.InitialProgram, 0, sizeof(m_UserConfig.InitialProgram));
         memset(m_UserConfig.WorkDirectory, 0, sizeof(m_UserConfig.WorkDirectory));

    } else {

        /*
         * When 'inherit' button is unchecked, set 'published only' to 'off'.
         */
        CheckDlgButton( IDC_AWS_INITIALPROGRAM_PUBLISHEDONLY,
                        m_UserConfig.fDisableExe = FALSE );
    }

    SetDlgItemText(IDC_AWS_INITIALPROGRAM_COMMANDLINE, m_UserConfig.InitialProgram);
    SetDlgItemText(IDC_AWS_INITIALPROGRAM_WORKINGDIRECTORY, m_UserConfig.WorkDirectory);

    GetDlgItem(IDL_AWS_INITIALPROGRAM_COMMANDLINE1)->
        EnableWindow(m_UserConfig.fInheritInitialProgram ? FALSE : TRUE);
    GetDlgItem(IDL_AWS_INITIALPROGRAM_COMMANDLINE2)->
        EnableWindow(m_UserConfig.fInheritInitialProgram ? FALSE : TRUE);
    GetDlgItem(IDC_AWS_INITIALPROGRAM_COMMANDLINE)->
        EnableWindow(m_UserConfig.fInheritInitialProgram ? FALSE : TRUE);
    GetDlgItem(IDL_AWS_INITIALPROGRAM_WORKINGDIRECTORY1)->
        EnableWindow(m_UserConfig.fInheritInitialProgram ? FALSE : TRUE);
    GetDlgItem(IDL_AWS_INITIALPROGRAM_WORKINGDIRECTORY2)->
        EnableWindow(m_UserConfig.fInheritInitialProgram ? FALSE : TRUE);
    GetDlgItem(IDC_AWS_INITIALPROGRAM_WORKINGDIRECTORY)->
        EnableWindow(m_UserConfig.fInheritInitialProgram ? FALSE : TRUE);

    if(!(m_Capabilities & WDC_PUBLISHED_APPLICATIONS)) {
        GetDlgItem(IDC_AWS_INITIALPROGRAM_PUBLISHEDONLY)->EnableWindow(FALSE);
    } else {
        GetDlgItem(IDC_AWS_INITIALPROGRAM_PUBLISHEDONLY)->
            EnableWindow(m_UserConfig.fInheritInitialProgram ? TRUE : FALSE);
    }

}  // end CAdvancedWinStationDlg::OnClickedAwsInitialprogramInherit


/*******************************************************************************
 *
 *  OnClickedAwsInitialprogramPublishedonly - CAdvancedWinStationDlg
 *                                       member function: command
 *
 *      Set the state of fDisableExe flag when 'Only run Published
 *      Applications' checkbox is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsInitialprogramPublishedonly() 
{
    m_UserConfig.fDisableExe =
        ((CButton *)GetDlgItem(IDC_AWS_INITIALPROGRAM_PUBLISHEDONLY))->GetCheck();
	
}  // end CAdvancedWinStationDlg::OnClickedAwsInitialprogramPublishedonly


/*******************************************************************************
 *
 *  OnClickedAwsSecurityDisableencryption -
 *                  CAdvancedWinStationDlg member function: command
 *
 *      Set the state of fDisableEncryption flag when 'Disable encryption after
 *      Logon' checkbox is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsSecurityDisableencryption()
{
//    m_UserConfig.fDisableEncryption =
//        ((CButton *)GetDlgItem(IDC_AWS_SECURITY_DISABLEENCRYPTION))->GetCheck();

}  // end CAdvancedWinStationDlg::OnClickedAwsSecurityDisableencryption


/*******************************************************************************
 *
 *  OnClickedAwsUseroverrideDisablewallpaper -
 *                  CAdvancedWinStationDlg member function: command
 *
 *      Set the state of fWallPaperDisabled flag when 'Disable Wallpaper'
 *      checkbox is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsUseroverrideDisablewallpaper()
{
    m_UserConfig.fWallPaperDisabled =
        ((CButton *)GetDlgItem(IDC_AWS_USEROVERRIDE_DISABLEWALLPAPER))->GetCheck();

}  // end CAdvancedWinStationDlg::OnClickedAwsUseroverrideDisablewallpaper


/*******************************************************************************
 *
 *  OnClickedAwsBrokenInherit - CAdvancedWinStationDlg member function: command
 *
 *      Process the broken connection fields when the 'user specified'
 *      checkbox is checked or unchecked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsBrokenInherit()
{
    m_UserConfig.fInheritResetBroken =
        ((CButton *)GetDlgItem(IDC_AWS_BROKEN_INHERIT))->GetCheck();

    GetDlgItem(IDL_AWS_BROKEN1)->
        EnableWindow(m_UserConfig.fInheritResetBroken ? FALSE : TRUE);
    GetDlgItem(IDC_AWS_BROKEN)->
        EnableWindow(m_UserConfig.fInheritResetBroken ? FALSE : TRUE);
    GetDlgItem(IDL_AWS_BROKEN2)->
        EnableWindow(m_UserConfig.fInheritResetBroken ? FALSE : TRUE);

}  // end CAdvancedWinStationDlg::OnClickedAwsBrokenInherit


/*******************************************************************************
 *
 *  OnClickedAwsReconnectInherit - CAdvancedWinStationDlg
 *                                  member function: command
 *
 *      Process the reconnect sessions fields when the 'user specified'
 *      checkbox is checked or unchecked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsReconnectInherit()
{
    m_UserConfig.fInheritReconnectSame =
        ((CButton *)GetDlgItem(IDC_AWS_RECONNECT_INHERIT))->GetCheck();

    GetDlgItem(IDL_AWS_RECONNECT1)->
        EnableWindow(m_UserConfig.fInheritReconnectSame ? FALSE : TRUE);
    GetDlgItem(IDC_AWS_RECONNECT)->
        EnableWindow(m_UserConfig.fInheritReconnectSame ? FALSE : TRUE);

}  // end CAdvancedWinStationDlg::OnClickedAwsReconnectInherit


/*******************************************************************************
 *
 *  OnClickedAwsShadowInherit - CAdvancedWinStationDlg member function: command
 *
 *      Process the shadowing fields when the 'user specified' checkbox is
 *      checked or unchecked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnClickedAwsShadowInherit()
{
    m_UserConfig.fInheritShadow =
        ((CButton *)GetDlgItem(IDC_AWS_SHADOW_INHERIT))->GetCheck();

    GetDlgItem(IDL_AWS_SHADOW)->
        EnableWindow(m_UserConfig.fInheritShadow ? FALSE : TRUE);
    GetDlgItem(IDC_AWS_SHADOW)->
        EnableWindow(m_UserConfig.fInheritShadow ? FALSE : TRUE);

}  // end CAdvancedWinStationDlg::OnClickedAwsShadowInherit


/*******************************************************************************
 *
 *  OnOK - CAdvancedWinStationDlg member function: command (override)
 *
 *      Read all control contents back into the dialog's member variables
 *      before closing the dialog.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnOk documentation)
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnOK()
{
    /*
     * If the Enter key was pressed while a combo box was dropped down, ignore
     * it (treat as combo list selection only).
     */
    if ( !HandleEnterEscKey(IDOK) )
        return;

    /*
     * Get WinStation state.
     */
    m_fEnableWinStation =
        (GetCheckedRadioButton( IDC_AWS_WSDISABLED, IDC_AWS_WSENABLED )
                                - IDC_AWS_WSDISABLED );

    /*
     * Get Connection Timeout settings.
     */
    if ( IsDlgButtonChecked(IDC_AWS_CONNECTION_NONE) ) {

            m_UserConfig.MaxConnectionTime = 0;
        
    } else {

        TCHAR string[CONNECTION_TIME_DIGIT_MAX], *endptr;
        ULONG ul;

        GetDlgItemText(IDC_AWS_CONNECTION, string, lengthof(string));
        ul = lstrtoul(string, &endptr, 10);

        if ( (*endptr != TEXT('\0')) ||
             (ul < CONNECTION_TIME_MIN) || (ul > CONNECTION_TIME_MAX) ) {

            ERROR_MESSAGE(( IDP_INVALID_CONNECTIONTIMEOUT,
                            CONNECTION_TIME_MIN, CONNECTION_TIME_MAX ))

            GotoDlgCtrl(GetDlgItem(IDC_AWS_CONNECTION));
            return;

        } else
            m_UserConfig.MaxConnectionTime = ul * TIME_RESOLUTION;
    }
    m_UserConfig.fInheritMaxSessionTime =
        IsDlgButtonChecked(IDC_AWS_CONNECTION_INHERIT);

    /*
     * Get Disconnection Timeout settings.
     */
    if ( IsDlgButtonChecked(IDC_AWS_DISCONNECTION_NONE) ) {

            m_UserConfig.MaxDisconnectionTime = 0;
        
    } else {

        TCHAR string[DISCONNECTION_TIME_DIGIT_MAX], *endptr;
        ULONG ul;

        GetDlgItemText(IDC_AWS_DISCONNECTION, string, lengthof(string));
        ul = lstrtoul(string, &endptr, 10);

        if ( (*endptr != TEXT('\0')) ||
             (ul < DISCONNECTION_TIME_MIN) || (ul > DISCONNECTION_TIME_MAX) ) {

            ERROR_MESSAGE(( IDP_INVALID_DISCONNECTIONTIMEOUT,
                            DISCONNECTION_TIME_MIN, DISCONNECTION_TIME_MAX ))

            GotoDlgCtrl(GetDlgItem(IDC_AWS_DISCONNECTION));
            return;

        } else
            m_UserConfig.MaxDisconnectionTime = ul * TIME_RESOLUTION;
    }
    m_UserConfig.fInheritMaxDisconnectionTime =
        IsDlgButtonChecked(IDC_AWS_DISCONNECTION_INHERIT);

    /*
     * Get Idle Timeout settings.
     */
    if ( IsDlgButtonChecked(IDC_AWS_IDLE_NONE) ) {

            m_UserConfig.MaxIdleTime = 0;
        
    } else {

        TCHAR string[IDLE_TIME_DIGIT_MAX], *endptr;
        ULONG ul;

        GetDlgItemText(IDC_AWS_IDLE, string, lengthof(string));
        ul = lstrtoul(string, &endptr, 10);

        if ( (*endptr != TEXT('\0')) ||
             (ul < IDLE_TIME_MIN) || (ul > IDLE_TIME_MAX) ) {

            ERROR_MESSAGE(( IDP_INVALID_IDLETIMEOUT,
                            IDLE_TIME_MIN, IDLE_TIME_MAX ))

            GotoDlgCtrl(GetDlgItem(IDC_AWS_IDLE));
            return;

        } else
            m_UserConfig.MaxIdleTime = ul * TIME_RESOLUTION;
    }
    m_UserConfig.fInheritMaxIdleTime = IsDlgButtonChecked(IDC_AWS_IDLE_INHERIT);

    /*
     * Get and check AutoLogon password text settings.
     */
    {
    TCHAR szConfirmPassword[PASSWORD_LENGTH+1];

    GetDlgItemText( IDC_AWS_AUTOLOGON_PASSWORD, m_UserConfig.Password,
                    lengthof(m_UserConfig.Password) );
    GetDlgItemText( IDC_AWS_AUTOLOGON_CONFIRM_PASSWORD, szConfirmPassword,
                    lengthof(szConfirmPassword) );

    if ( lstrcmp(m_UserConfig.Password, szConfirmPassword) ) {

        ERROR_MESSAGE((IDP_INVALID_PASSWORDS_DONT_MATCH))
        GotoDlgCtrl(GetDlgItem(IDC_AWS_AUTOLOGON_PASSWORD));
        return;
    }
    }

    /*
     * Get other AutoLogon settings.
     */
    GetDlgItemText( IDC_AWS_AUTOLOGON_USERNAME, m_UserConfig.UserName,
                    lengthof(m_UserConfig.UserName) );
    GetDlgItemText( IDC_AWS_AUTOLOGON_DOMAIN, m_UserConfig.Domain,
                    lengthof(m_UserConfig.Domain) );
    m_UserConfig.fPromptForPassword =
        IsDlgButtonChecked(IDC_AWS_AUTOLOGON_PASSWORD_PROMPT);

    /*
     * Get Initial Program settings.
     */
    GetDlgItemText( IDC_AWS_INITIALPROGRAM_COMMANDLINE,
                    m_UserConfig.InitialProgram,
                    lengthof(m_UserConfig.InitialProgram) );
    GetDlgItemText( IDC_AWS_INITIALPROGRAM_WORKINGDIRECTORY,
                    m_UserConfig.WorkDirectory,
                    lengthof(m_UserConfig.WorkDirectory) );

    /*
     * Get encryption level, broken connection, reconnect, and shadow settings.
     */
	if(m_pEncryptionLevels) {
    	m_UserConfig.MinEncryptionLevel = 
        	(BYTE)m_pEncryptionLevels[((CComboBox *)GetDlgItem(IDC_AWS_SECURITY_ENCRYPT))->GetCurSel()].RegistryValue;
	}

    m_UserConfig.fUseDefaultGina =
        IsDlgButtonChecked(IDC_AWS_SECURITY_DEFAULTGINA);
    m_UserConfig.fResetBroken = 
        ((CComboBox *)GetDlgItem(IDC_AWS_BROKEN))->GetCurSel();
    m_UserConfig.fReconnectSame =
        ((CComboBox *)GetDlgItem(IDC_AWS_RECONNECT))->GetCurSel();
    m_UserConfig.Shadow =
        (SHADOWCLASS)((CComboBox *)GetDlgItem(IDC_AWS_SHADOW))->GetCurSel();

    /*
     * Call the parent classes' OnOk to complete dialog closing
     * and destruction.
     */
    CBaseDialog::OnOK();

}  // end CAdvancedWinStationDlg::OnOk


/*******************************************************************************
 *
 *  OnCancel - CAdvancedWinStationDlg member function: command (override)
 *
 *      Cancel dialog.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnCancel documentation)
 *
 ******************************************************************************/

void
CAdvancedWinStationDlg::OnCancel()
{
    /*
     * If the Esc key was pressed while a combo box was dropped down, ignore
     * it (treat as combo close-up and cancel only).
     */
    if ( !HandleEnterEscKey(IDCANCEL) )
        return;
    
    /*
     * Call the parent classes' OnCancel to complete dialog closing
     * and destruction.
     */
    CBaseDialog::OnCancel();

}  // end CAdvancedWinStationDlg::OnCancel
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// CClientSettingsDlg class construction / destruction, implementation

/*******************************************************************************
 *
 *  CClientSettingsDlg - CClientSettingsDlg constructor
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CDialog::CDialog documentation)
 *
 ******************************************************************************/

CClientSettingsDlg::CClientSettingsDlg()
    : CBaseDialog(CClientSettingsDlg::IDD)
{
    //{{AFX_DATA_INIT(CClientSettingsDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

}  // end CClientSettingsDlg::CClientSettingsDlg


////////////////////////////////////////////////////////////////////////////////
// CClientSettingsDlg operations


////////////////////////////////////////////////////////////////////////////////
// CClientSettingsDlg message map

BEGIN_MESSAGE_MAP(CClientSettingsDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CClientSettingsDlg)
    ON_BN_CLICKED(IDC_CS_CONNECTION_DRIVES, OnClickedCsClientdevicesDrives)
    ON_BN_CLICKED(IDC_CS_CONNECTION_PRINTERS, OnClickedCsClientdevicesPrinters)
    ON_BN_CLICKED(IDC_CS_CONNECTION_INHERIT, OnClickedCsClientdevicesInherit)
    ON_BN_CLICKED(IDC_CS_CONNECTION_FORCEPRTDEF, OnClickedCsClientdevicesForceprtdef)
	ON_BN_CLICKED(IDC_CS_MAPPING_DRIVES, OnClickedCsMappingDrives)
	ON_BN_CLICKED(IDC_CS_MAPPING_WINDOWSPRINTERS, OnClickedCsMappingWindowsprinters)
	ON_BN_CLICKED(IDC_CS_MAPPING_DOSLPTS, OnClickedCsMappingDoslpts)
	ON_BN_CLICKED(IDC_CS_MAPPING_COMPORTS, OnClickedCsMappingComports)
	ON_BN_CLICKED(IDC_CS_MAPPING_CLIPBOARD, OnClickedCsMappingClipboard)
	ON_BN_CLICKED(IDC_CS_MAPPING_AUDIO, OnClickedCsMappingAudio)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


////////////////////////////////////////////////////////////////////////////////
// CClientSettingsDlg commands

/*******************************************************************************
 *
 *  OnInitDialog - CClientSettingsDlg member function: command (override)
 *
 *      Performs the dialog intialization.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnInitDialog documentation)
 *
 ******************************************************************************/

BOOL
CClientSettingsDlg::OnInitDialog()
{
    int i;

    /*
     * Call the parent classes' OnInitDialog to perform default dialog
     * initialization.
     */    
    CBaseDialog::OnInitDialog();

    /*
     * Set Connection fields.
     */
    CheckDlgButton( IDC_CS_CONNECTION_DRIVES,
                    m_UserConfig.fAutoClientDrives );
    CheckDlgButton( IDC_CS_CONNECTION_PRINTERS,
                    m_UserConfig.fAutoClientLpts );
    CheckDlgButton( IDC_CS_CONNECTION_FORCEPRTDEF,
                    m_UserConfig.fForceClientLptDef );
    CheckDlgButton( IDC_CS_CONNECTION_INHERIT,
                    m_UserConfig.fInheritAutoClient );

    /*
     * Set Mapping Override fields.
     */
    CheckDlgButton( IDC_CS_MAPPING_DRIVES,
                    m_UserConfig.fDisableCdm );
    CheckDlgButton( IDC_CS_MAPPING_WINDOWSPRINTERS,
                    m_UserConfig.fDisableCpm );
    CheckDlgButton( IDC_CS_MAPPING_DOSLPTS,
                    m_UserConfig.fDisableLPT );
    CheckDlgButton( IDC_CS_MAPPING_COMPORTS,
                    m_UserConfig.fDisableCcm );
    CheckDlgButton( IDC_CS_MAPPING_CLIPBOARD,
                    m_UserConfig.fDisableClip );
    CheckDlgButton( IDC_CS_MAPPING_AUDIO,
                    m_UserConfig.fDisableCam );

    /*
     * Set proper control states based on selections.
     */
    OnClickedCsClientdevicesInherit();

    /*
     * Process based on document's read/write state.
     */
    if ( m_bReadOnly ) {

        /*                          
         * Document is 'read-only': disable all dialog controls and labels
         * except for CANCEL and HELP buttons.
         */
        for ( i=IDL_CS_CONNECTION; i <=IDC_CS_MAPPING_AUDIO; i++ )
            GetDlgItem(i)->EnableWindow(FALSE);
        GetDlgItem(IDOK)->EnableWindow(FALSE);

    } else {
    
        /*
        * Enable/Disable Controls based on capabilities of the Wd
        */
        GetDlgItem(IDC_CS_MAPPING_DRIVES)->EnableWindow((m_Capabilities & WDC_CLIENT_DRIVE_MAPPING) > 0);
        GetDlgItem(IDC_CS_MAPPING_WINDOWSPRINTERS)->EnableWindow((m_Capabilities & WDC_WIN_CLIENT_PRINTER_MAPPING) > 0);
        GetDlgItem(IDC_CS_MAPPING_DOSLPTS)->EnableWindow((m_Capabilities & WDC_CLIENT_LPT_PORT_MAPPING) > 0);
        GetDlgItem(IDC_CS_MAPPING_COMPORTS)->EnableWindow((m_Capabilities & WDC_CLIENT_COM_PORT_MAPPING) > 0);
        GetDlgItem(IDC_CS_MAPPING_CLIPBOARD)->EnableWindow((m_Capabilities & WDC_CLIENT_CLIPBOARD_MAPPING) > 0);
        GetDlgItem(IDC_CS_MAPPING_AUDIO)->EnableWindow((m_Capabilities & WDC_CLIENT_AUDIO_MAPPING) > 0);

        GetDlgItem(IDC_CS_CONNECTION_INHERIT)->EnableWindow((m_Capabilities & WDC_CLIENT_CONNECT_MASK) > 0);
    }

    return(TRUE);

}  // end CClientSettingsDlg::OnInitDialog


/*******************************************************************************
 *
 *  OnClickedCsClientdevicesDrives -
 *                  CClientSettingsDlg member function: command
 *
 *      Set the state of fAutoClientDrives flag when 'Connect client drives at
 *      Logon' checkbox is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CClientSettingsDlg::OnClickedCsClientdevicesDrives()
{
    m_UserConfig.fAutoClientDrives =
        ((CButton *)GetDlgItem(IDC_CS_CONNECTION_DRIVES))->GetCheck();

}  // end CClientSettingsDlg::OnClickedCsClientdevicesDrives


/*******************************************************************************
 *
 *  OnClickedCsClientdevicesPrinters -
 *                  CClientSettingsDlg member function: command
 *
 *      Set the state of fAutoClientLpts flag when 'Connect client LPTs at
 *      Logon' checkbox is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CClientSettingsDlg::OnClickedCsClientdevicesPrinters()
{
    m_UserConfig.fAutoClientLpts =
        ((CButton *)GetDlgItem(IDC_CS_CONNECTION_PRINTERS))->GetCheck();

}  // end CClientSettingsDlg::OnClickedCsClientdevicesPrinters


/*******************************************************************************
 *
 *  OnClickedCsClientdevicesForceprtdef -
 *                  CClientSettingsDlg member function: command
 *
 *      Set the state of fForceClientLptDef flag when 'Default to main client
 *      printer' checkbox is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CClientSettingsDlg::OnClickedCsClientdevicesForceprtdef()
{
    m_UserConfig.fForceClientLptDef =
        ((CButton *)GetDlgItem(IDC_CS_CONNECTION_FORCEPRTDEF))->GetCheck();

}  // end CClientSettingsDlg::OnClickedCsClientdevicesForceprtdef


/*******************************************************************************
 *
 *  OnClickedCsClientdevicesInherit - CClientSettingsDlg
 *                                       member function: command
 *
 *      Process the Connection fields when the 'inherit user config'
 *      checkbox is checked or unchecked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CClientSettingsDlg::OnClickedCsClientdevicesInherit()
{
    m_UserConfig.fInheritAutoClient =
        ((CButton *)GetDlgItem(IDC_CS_CONNECTION_INHERIT))->GetCheck();

    if(!(m_Capabilities & WDC_CLIENT_DRIVE_MAPPING)) {
        GetDlgItem(IDC_CS_CONNECTION_DRIVES)->EnableWindow(FALSE);
    } else {
        GetDlgItem(IDC_CS_CONNECTION_DRIVES)->
            EnableWindow( (m_UserConfig.fInheritAutoClient ||
                           m_UserConfig.fDisableCdm) ? FALSE : TRUE );
    }

    if(!(m_Capabilities & (WDC_WIN_CLIENT_PRINTER_MAPPING | WDC_CLIENT_LPT_PORT_MAPPING))) {
        GetDlgItem(IDC_CS_CONNECTION_PRINTERS)->EnableWindow(FALSE);
        GetDlgItem(IDC_CS_CONNECTION_FORCEPRTDEF)->EnableWindow(FALSE);
    } else {
        GetDlgItem(IDC_CS_CONNECTION_PRINTERS)->
            EnableWindow( (m_UserConfig.fInheritAutoClient ||
                           (m_UserConfig.fDisableCpm && m_UserConfig.fDisableLPT) ) ? FALSE : TRUE );

        GetDlgItem(IDC_CS_CONNECTION_FORCEPRTDEF)->
            EnableWindow( (m_UserConfig.fInheritAutoClient ||
                           (m_UserConfig.fDisableCpm && m_UserConfig.fDisableLPT) ) ? FALSE : TRUE );
    }

}  // end CClientSettingsDlg::OnClickedCsClientdevicesInherit


/*******************************************************************************
 *
 *  OnClickedCsMappingDrives - CClientSettingsDlg member function: command
 *
 *      Set the state of fDisableCdm flag and related controls when
 *      'Disable Client Drive Mapping' checkbox is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CClientSettingsDlg::OnClickedCsMappingDrives() 
{
    m_UserConfig.fDisableCdm =
        ((CButton *)GetDlgItem(IDC_CS_MAPPING_DRIVES))->GetCheck();
    OnClickedCsClientdevicesInherit();

}  // end CClientSettingsDlg::OnClickedCsMappingDrives


/*******************************************************************************
 *
 *  OnClickedCsMappingWindowsprinters - CClientSettingsDlg
 *                                          member function: command
 *
 *      Set the state of fDisableCpm flag and related controls when
 *      'Disable Windows Client Printer Mapping' checkbox is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CClientSettingsDlg::OnClickedCsMappingWindowsprinters() 
{
    m_UserConfig.fDisableCpm =
        ((CButton *)GetDlgItem(IDC_CS_MAPPING_WINDOWSPRINTERS))->GetCheck();
    OnClickedCsClientdevicesInherit();
	
}  // end CClientSettingsDlg::OnClickedCsMappingWindowsprinters


/*******************************************************************************
 *
 *  OnClickedCsMappingDoslpts - CClientSettingsDlg member function: command
 *
 *      Set the state of fDisableLPT flag and related controls when
 *      'Disable DOS Client LPT Port Mapping' checkbox is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CClientSettingsDlg::OnClickedCsMappingDoslpts() 
{
    m_UserConfig.fDisableLPT =
        ((CButton *)GetDlgItem(IDC_CS_MAPPING_DOSLPTS))->GetCheck();
    OnClickedCsClientdevicesInherit();
	
}  // end CClientSettingsDlg::OnClickedCsMappingDoslpts


/*******************************************************************************
 *
 *  OnClickedCsMappingComports - CClientSettingsDlg member function: command
 *
 *      Set the state of fDisableCcm flag when 'Disable Client COM Port
 *      Mapping' checkbox is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CClientSettingsDlg::OnClickedCsMappingComports() 
{
    m_UserConfig.fDisableCcm =
        ((CButton *)GetDlgItem(IDC_CS_MAPPING_COMPORTS))->GetCheck();
	
}  // end CClientSettingsDlg::OnClickedCsMappingComports


/*******************************************************************************
 *
 *  OnClickedCsMappingClipboard - CClientSettingsDlg member function: command
 *
 *      Set the state of fDisableClip flag when 'Disable Client Clipboard
 *      Mapping' checkbox is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CClientSettingsDlg::OnClickedCsMappingClipboard() 
{
    m_UserConfig.fDisableClip =
        ((CButton *)GetDlgItem(IDC_CS_MAPPING_CLIPBOARD))->GetCheck();
	
}  // end CClientSettingsDlg::OnClickedCsMappingClipboard


/*******************************************************************************
 *
 *  OnClickedCsMappingAudio - CClientSettingsDlg member function: command
 *
 *      Set the state of fDisableCam flag when 'Disable Client Audio
 *      Mapping' checkbox is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CClientSettingsDlg::OnClickedCsMappingAudio() 
{
    m_UserConfig.fDisableCam =
        ((CButton *)GetDlgItem(IDC_CS_MAPPING_AUDIO))->GetCheck();
	
}  // end CClientSettingsDlg::OnClickedCsMappingAudio


/*******************************************************************************
 *
 *  OnOK - CClientSettingsDlg member function: command (override)
 *
 *      Read all control contents back into the dialog's member variables
 *      before closing the dialog.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnOk documentation)
 *
 ******************************************************************************/

void
CClientSettingsDlg::OnOK()
{
    /*
     * Call the parent classes' OnOk to complete dialog closing
     * and destruction.
     */
    CBaseDialog::OnOK();

}  // end CClientSettingsDlg::OnOk


/*******************************************************************************
 *
 *  OnCancel - CClientSettingsDlg member function: command (override)
 *
 *      Cancel dialog.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnCancel documentation)
 *
 ******************************************************************************/

void
CClientSettingsDlg::OnCancel()
{
    /*
     * Call the parent classes' OnCancel to complete dialog closing
     * and destruction.
     */
    CBaseDialog::OnCancel();

}  // end CClientSettingsDlg::OnCancel
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// CAdvancedAsyncDlg class construction / destruction, implementation

/*******************************************************************************
 *
 *  CAdvancedAsyncDlg - CAdvancedAsyncDlg constructor
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CDialog::CDialog documentation)
 *
 ******************************************************************************/

CAdvancedAsyncDlg::CAdvancedAsyncDlg()
    : CBaseDialog(CAdvancedAsyncDlg::IDD)
{
    //{{AFX_DATA_INIT(CAdvancedAsyncDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

}  // end CAdvancedAsyncDlg::CAdvancedAsyncDlg


////////////////////////////////////////////////////////////////////////////////
// CAdvancedAsyncDlg operations

/*******************************************************************************
 *
 *  HandleEnterEscKey - CAdvancedAsyncDlg member function: private operation
 *
 *      If the ENTER or ESC key is pressed while a combo box is dropped down,
 *      treat as combo box selection (suppress OnOk/OnCancel notification).
 *
 *  ENTRY:
 *      nID (input)
 *          IDOK if OK button (ENTER) brought us here; otherwise, IDCANCEL for
 *          Cancel button (ESC).
 *  EXIT:
 *      TRUE to process Enter/Esc (perform OnOk/OnCancel); FALSE to ignore
 *      (a combo box is dropped down).
 *
 ******************************************************************************/

BOOL
CAdvancedAsyncDlg::HandleEnterEscKey(int nID)
{
    /*
     * Check HW Flow Receive and Transmit combo boxes.
     */
    if ( ((CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWRX))->GetDroppedState() ) {

        if ( nID == IDCANCEL ) {    // select original selection
            
            ((CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWRX))->
                SetCurSel(m_Async.FlowControl.HardwareReceive);
        }
        ((CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWRX))->ShowDropDown(FALSE);
        return(FALSE);
    }

    if ( ((CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWTX))->GetDroppedState() ) {

        if ( nID == IDCANCEL ) {    // select original selection
            
            ((CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWTX))->
                SetCurSel(m_Async.FlowControl.HardwareTransmit);
        }
        ((CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWTX))->ShowDropDown(FALSE);
        return(FALSE);
    }

    /*
     * No combo boxes are down; process Enter/Esc.
     */
    return(TRUE);

}  // end CAdvancedAsyncDlg::HandleEnterEscKey


/*******************************************************************************
 *
 *  SetFields - CAdvancedAsyncDlg member function: private operation
 *
 *      Set the dialog fields.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::SetFields()
{
    int nId;

    /*
     * Set the FLOWCONTROL radio buttons.
     */
    switch( m_Async.FlowControl.Type ) {

        case FlowControl_None:
            nId = IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE;
            break;

        case FlowControl_Hardware:
            nId = IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE;
            break;

        case FlowControl_Software:
            nId = IDC_ASYNC_ADVANCED_FLOWCONTROL_SOFTWARE;
            break;
    }

    CheckRadioButton( IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE,
                      IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE,
                      nId );

    /*
     * Set the text of the Hardware flowcontrol button.
     */
    SetHWFlowText();


    /*
     * If a modem is defined, disable the Flow Control fields, since they cannot
     * be modified (must match modem's flow control established in Modem dialog).
     */
    if ( m_bModem ) {

        for ( nId = IDL_ASYNC_ADVANCED_FLOWCONTROL;
              nId <= IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE; nId++ )
            GetDlgItem(nId)->EnableWindow(FALSE);
    }

    /*
     * Call member functions to set the Global, Hardware, and Software fields.
     */
    SetGlobalFields();
    SetHWFields();
    SetSWFields();

}  // end CAdvancedAsyncDlg::SetFields


/*******************************************************************************
 *
 *  SetHWFlowText - CAdvancedAsyncDlg member function: private operation
 *
 *      Set the contents of the flow control configuration field.
 *      
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::SetHWFlowText()
{
    CString str( TEXT("Hardware (") );

    switch ( m_Async.FlowControl.HardwareReceive ) {

        case ReceiveFlowControl_None:
            str += TEXT(".../");
            break;

        case ReceiveFlowControl_RTS:
            str += TEXT("RTS/");
            break;

        case ReceiveFlowControl_DTR:
            str += TEXT("DTR/");
            break;
    }
    switch ( m_Async.FlowControl.HardwareTransmit ) {

        case TransmitFlowControl_None:
            str += TEXT("...)");
            break;

        case TransmitFlowControl_CTS:
            str += TEXT("CTS)");
            break;

        case TransmitFlowControl_DSR:
            str += TEXT("DSR)");
            break;
    }

    SetDlgItemText( IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE, str );

}  // end CAdvancedAsyncDlg::SetHWFlowText


/*******************************************************************************
 *
 *  SetGlobalFields - CAdvancedAsyncDlg member function: private operation
 *
 *      Set the 'global' dialog fields common to both HW and SW flowcontrol.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::SetGlobalFields()
{
    /*
     * Select proper DTR radio button.
     */
    CheckRadioButton( IDC_ASYNC_ADVANCED_DTROFF, IDC_ASYNC_ADVANCED_DTRON,
                      IDC_ASYNC_ADVANCED_DTROFF +
                      (int)m_Async.FlowControl.fEnableDTR );

    /*
     * Select proper RTS radio button.
     */
    CheckRadioButton( IDC_ASYNC_ADVANCED_RTSOFF, IDC_ASYNC_ADVANCED_RTSON,
                      IDC_ASYNC_ADVANCED_RTSOFF +
                      (int)m_Async.FlowControl.fEnableRTS );

    /*
     * Set the PARITY radio buttons.
     */
    CheckRadioButton( IDC_ASYNC_ADVANCED_PARITY_NONE,
                      IDC_ASYNC_ADVANCED_PARITY_SPACE,
                      IDC_ASYNC_ADVANCED_PARITY_NONE +
                        (int)m_Async.Parity );

    /*
     * Set the STOPBITS radio buttons.
     */
    CheckRadioButton( IDC_ASYNC_ADVANCED_STOPBITS_1,
                      IDC_ASYNC_ADVANCED_STOPBITS_2,
                      IDC_ASYNC_ADVANCED_STOPBITS_1 +
                        (int)m_Async.StopBits );

    /*
     * Set the BYTESIZE radio buttons.
     *
     * NOTE: the constant '7' that is subtracted from the stored ByteSize
     * must track the lowest allowed byte size / BYTESIZE radio button.
     */
    CheckRadioButton( IDC_ASYNC_ADVANCED_BYTESIZE_7,
                      IDC_ASYNC_ADVANCED_BYTESIZE_8,
                      IDC_ASYNC_ADVANCED_BYTESIZE_7 +
                        ((int)m_Async.ByteSize - 7) );

    /*
     * If the currently selected Wd is an ICA type, disable the BYTESIZE
     * group box and buttons - user can't change from default.
     */
    if ( m_nWdFlag & WDF_ICA ) {
        int i;

        for ( i =  IDL_ASYNC_ADVANCED_BYTESIZE;
              i <= IDC_ASYNC_ADVANCED_BYTESIZE_8; i++ )
            GetDlgItem(i)->EnableWindow(FALSE);
    }
}  // end CAdvancedAsyncDlg::SetGlobalFields


/*******************************************************************************
 *
 *  SetHWFields - CAdvancedAsyncDlg member function: private operation
 *
 *      Set the dialog fields specific to HW flowcontrol.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::SetHWFields()
{
    int i;

    /*
     * Initialize HW Receive class combo-box
     */
    ((CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWRX))->
        SetCurSel(m_Async.FlowControl.HardwareReceive);

    /*
     * If HW flow control is selected AND the HW Receive class is set to
     * ReceiveFlowControl_DTR, disable the DTR controls & labels.
     * Otherwise, enable the DTR control & labels.
     */
    for ( i=IDL_ASYNC_ADVANCED_DTRSTATE;
          i <=IDC_ASYNC_ADVANCED_DTRON; i++ )
        GetDlgItem(i)->EnableWindow(
            ((m_Async.FlowControl.Type == FlowControl_Hardware) &&
             (m_Async.FlowControl.HardwareReceive == ReceiveFlowControl_DTR)) ?
             FALSE : TRUE );

    /*
     * Initialize HW Transmit class combo-box.
     */
    ((CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWTX))->
        SetCurSel(m_Async.FlowControl.HardwareTransmit);
    
    /*
     * If HW flow control is selected AND the HW Receive class is set to
     * ReceiveFlowControl_RTS, disable the RTS controls & labels.
     * Otherwise, enable the RTS control & labels.
     */
    for ( i=IDL_ASYNC_ADVANCED_RTSSTATE;
          i <=IDC_ASYNC_ADVANCED_RTSON; i++ )
        GetDlgItem(i)->EnableWindow(
            ((m_Async.FlowControl.Type == FlowControl_Hardware) &&
             (m_Async.FlowControl.HardwareReceive == ReceiveFlowControl_RTS)) ?
             FALSE : TRUE );

    /*
     * Enable or disable all HW fields.
     */
    for ( i=IDL_ASYNC_ADVANCED_HARDWARE;
          i <=IDC_ASYNC_ADVANCED_HWTX; i++ )
        GetDlgItem(i)->EnableWindow(m_Async.FlowControl.Type == FlowControl_Hardware);

}  // end CAdvancedAsyncDlg::SetHWFields


/*******************************************************************************
 *
 *  SetSWFields - CAdvancedAsyncDlg member function: private operation
 *
 *      Set the dialog fields specific to SW flowcontrol.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::SetSWFields()
{
    TCHAR string[UCHAR_DIGIT_MAX];
    int i;

    /*
     * Initialize Xon character edit control.
     */
    wsprintf( string, (m_nHexBase ? TEXT("0x%02X") : TEXT("%d")),
              (UCHAR)m_Async.FlowControl.XonChar );
    SetDlgItemText( IDC_ASYNC_ADVANCED_XON, string );
    ((CEdit *)GetDlgItem(IDC_ASYNC_ADVANCED_XON))
            ->SetModify(FALSE);
    ((CEdit *)GetDlgItem(IDC_ASYNC_ADVANCED_XON))
            ->LimitText( UCHAR_DIGIT_MAX-1 );

    /*
     * Initialize Xoff character edit control.
     */
    wsprintf( string, (m_nHexBase ? TEXT("0x%02X") : TEXT("%d")),
              (UCHAR)m_Async.FlowControl.XoffChar );
    SetDlgItemText( IDC_ASYNC_ADVANCED_XOFF, string );
    ((CEdit *)GetDlgItem(IDC_ASYNC_ADVANCED_XOFF))
            ->SetModify(FALSE);
    ((CEdit *)GetDlgItem(IDC_ASYNC_ADVANCED_XOFF))
            ->LimitText( UCHAR_DIGIT_MAX-1 );

    /*
     * Initialize the Xon/Xoff base control.
     */
    CheckRadioButton( IDC_ASYNC_ADVANCED_BASEDEC, IDC_ASYNC_ADVANCED_BASEHEX,
                      IDC_ASYNC_ADVANCED_BASEDEC + m_nHexBase );

    /*
     * Enable or disable all SW fields.
     */
    for ( i=IDL_ASYNC_ADVANCED_SOFTWARE;
          i <=IDC_ASYNC_ADVANCED_BASEHEX; i++ )
        GetDlgItem(i)->EnableWindow(m_Async.FlowControl.Type == FlowControl_Software);

}  // end CAdvancedAsyncDlg::SetSWFields


/*******************************************************************************
 *
 *  GetFields - CAdvancedAsyncDlg member function: private operation
 *
 *      Fetch and validate the dialog fields.
 *
 *  ENTRY:
 *  EXIT:
 *      (BOOL)
 *          Returns TRUE if all fields were valid; FALSE otherwise.  If FALSE,
 *          will have output an error message and set the focus back to the
 *          field in error for the user to correct.
 *
 ******************************************************************************/

BOOL
CAdvancedAsyncDlg::GetFields()
{
    /*
     * Call member functions to get the Flow Control, Global, Hardware, and
     * Software fields.
     */
    GetFlowControlFields();

    if ( !GetGlobalFields() )
        return(FALSE);

    if ( !GetHWFields() )
        return(FALSE);

    if ( !GetSWFields(TRUE) )
        return(FALSE);

    return(TRUE);

}  // end CAdvancedAsyncDlg::GetFields


/*******************************************************************************
 *
 *  GetFlowControlFields - CAdvancedAsyncDlg member function: private operation
 *
 *      Fetch the flow control configuration field contents.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::GetFlowControlFields()
{
    switch ( GetCheckedRadioButton( IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE,
                                    IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE ) ) {

        case IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE:
            m_Async.FlowControl.Type = FlowControl_None;
            break;
            
        case IDC_ASYNC_ADVANCED_FLOWCONTROL_SOFTWARE:                            
            m_Async.FlowControl.Type = FlowControl_Software;
            break;

        case IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE:
            m_Async.FlowControl.Type = FlowControl_Hardware;
            break;
    }        

}  // end CAdvancedAsyncDlg::GetFlowControlFields


/*******************************************************************************
 *
 *  GetGlobalFields - CAdvancedAsyncDlg member function: private operation
 *
 *      Fetch and validate the 'global' dialog fields common to both HW and
 *      SW flowcontrol.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL)
 *          Returns TRUE if all fields were valid; FALSE otherwise.  If FALSE,
 *          will have output an error message and set the focus back to the
 *          field in error for the user to correct.
 *
 ******************************************************************************/

BOOL
CAdvancedAsyncDlg::GetGlobalFields()
{
    /*
     * Fetch DTR state.
     */
    m_Async.FlowControl.fEnableDTR =
            (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_DTROFF,
                                    IDC_ASYNC_ADVANCED_DTRON )
                    - IDC_ASYNC_ADVANCED_DTROFF);

    /*
     * Fetch RTS state.
     */
    m_Async.FlowControl.fEnableRTS =
            (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_RTSOFF,
                                    IDC_ASYNC_ADVANCED_RTSON )
                    - IDC_ASYNC_ADVANCED_RTSOFF);

    /*
     * Fetch the selected PARITY.
     */
    m_Async.Parity = (ULONG)
        (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_PARITY_NONE,
                                IDC_ASYNC_ADVANCED_PARITY_SPACE )
                - IDC_ASYNC_ADVANCED_PARITY_NONE);

    /*
     * Fetch the selected STOPBITS.
     */
    m_Async.StopBits = (ULONG)
        (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_STOPBITS_1,
                                IDC_ASYNC_ADVANCED_STOPBITS_2 )
                - IDC_ASYNC_ADVANCED_STOPBITS_1);

    /*
     * Fetch the selected BYTESIZE.
     *
     * NOTE: the constant '7' that is added to the stored ByteSize
     * must track the lowest allowed byte size / BYTESIZE radio button.
     */
    m_Async.ByteSize = (ULONG)
        (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_BYTESIZE_7,
                                IDC_ASYNC_ADVANCED_BYTESIZE_8 )
                - IDC_ASYNC_ADVANCED_BYTESIZE_7 + 7);

    return(TRUE);

}  // end CAdvancedAsyncDlg::GetGlobalFields


/*******************************************************************************
 *
 *  GetHWFields - CAdvancedAsyncDlg member function: private operation
 *
 *      Fetch and validate the dialog fields specific to HW flowcontrol.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL)
 *          Returns TRUE if all fields were valid; FALSE otherwise.  If FALSE,
 *          will have output an error message and set the focus back to the
 *          field in error for the user to correct.
 *
 ******************************************************************************/

BOOL
CAdvancedAsyncDlg::GetHWFields()
{
    /*
     * Fetch the HW receive flow class.
     */
    m_Async.FlowControl.HardwareReceive = (RECEIVEFLOWCONTROLCLASS)
        ((CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWRX))->GetCurSel();

    /*
     * Fetch the HW transmit flow class.
     */
    m_Async.FlowControl.HardwareTransmit = (TRANSMITFLOWCONTROLCLASS)
        ((CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWTX))->GetCurSel();

    return(TRUE);

}  // end CAdvancedAsyncDlg::GetHWFields


/*******************************************************************************
 *
 *  GetSWFields - CAdvancedAsyncDlg member function: private operation
 *
 *      Fetch and optionally validate the dialog fields specific to SW
 *      flowcontrol.
 *
 *  ENTRY:
 *      bValidate (input)
 *          TRUE if validation is desired; FALSE if no validation desired.
 *  EXIT:
 *      (BOOL)
 *          Returns TRUE if all fields were valid or if no validation was
 *          desired; FALSE otherwise.  If FALSE, will have output an error
 *          message and set the focus back to the field in error for the
 *          user to correct.
 *
 ******************************************************************************/

BOOL
CAdvancedAsyncDlg::GetSWFields( BOOL bValidate )
{
    TCHAR string[UCHAR_DIGIT_MAX], *endptr;
    ULONG ul;
    int nNewHexBase, base;

    /*
     * Determine the current state of the base controls and save.
     */
    nNewHexBase = (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_BASEDEC,
                                          IDC_ASYNC_ADVANCED_BASEHEX )
                                            - IDC_ASYNC_ADVANCED_BASEDEC);

    /*
     * Fetch and convert XON character.
     */
    GetDlgItemText(IDC_ASYNC_ADVANCED_XON, string, lengthof(string));

    /*
     * If the edit box is modified, use the 'new' base for conversion.
     */
    base = ((CEdit *)GetDlgItem(IDC_ASYNC_ADVANCED_XON))->GetModify() ? 
                                nNewHexBase : m_nHexBase;
    ul = lstrtoul( string, &endptr, (base ? 16 : 10) );

    /*
     * If validation is requested and there is a problem with the input,
     * complain and allow user to fix.
     */
    if ( bValidate && ((*endptr != TEXT('\0')) || (ul < 0) || (ul > 255)) ) {

        /*
         * Invalid character in field or invalid value.
         */
        ERROR_MESSAGE((IDP_INVALID_XONXOFF))

        /*
         * Set focus to the control so that it can be fixed.
         */
        GotoDlgCtrl(GetDlgItem(IDC_ASYNC_ADVANCED_XON));
        return(FALSE);
    }

    /*
     * Save the Xon character.
     */
    m_Async.FlowControl.XonChar = (UCHAR)ul;

    /*
     * Fetch and convert XOFF character.
     */
    GetDlgItemText(IDC_ASYNC_ADVANCED_XOFF, string, lengthof(string));

    /*
     * If the edit box is modified, use the 'new' base for conversion.
     */
    base = ((CEdit *)GetDlgItem(IDC_ASYNC_ADVANCED_XOFF))->GetModify() ? 
                                nNewHexBase : m_nHexBase;
    ul = lstrtoul( string, &endptr, (base ? 16 : 10) );

    /*
     * If validation is requested and there is a problem with the input,
     * complain and allow user to fix.
     */
    if ( bValidate && ((*endptr != TEXT('\0')) || (ul < 0) || (ul > 255)) ) {

        /*
         * Invalid character in field or invalid value.
         */
        ERROR_MESSAGE((IDP_INVALID_XONXOFF))

        /*
         * Set focus to the control so that it can be fixed.
         */
        GotoDlgCtrl(GetDlgItem(IDC_ASYNC_ADVANCED_XOFF));
        return(FALSE);
    }

    /*
     * Save the Xoff character.
     */
    m_Async.FlowControl.XoffChar = (UCHAR)ul;

    /*
     * Save the current base state.
     */
    m_nHexBase = nNewHexBase;

    return(TRUE);

}  // end CAdvancedAsyncDlg::GetSWFields


////////////////////////////////////////////////////////////////////////////////
// CAdvancedAsyncDlg message map

BEGIN_MESSAGE_MAP(CAdvancedAsyncDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CAdvancedAsyncDlg)
    ON_BN_CLICKED(IDC_ASYNC_ADVANCED_BASEDEC, OnClickedAsyncAdvancedBasedec)
    ON_BN_CLICKED(IDC_ASYNC_ADVANCED_BASEHEX, OnClickedAsyncAdvancedBasehex)
    ON_CBN_CLOSEUP(IDC_ASYNC_ADVANCED_HWRX, OnCloseupAsyncAdvancedHwrx)
    ON_CBN_SELCHANGE(IDC_ASYNC_ADVANCED_HWRX, OnSelchangeAsyncAdvancedHwrx)
    ON_CBN_CLOSEUP(IDC_ASYNC_ADVANCED_HWTX, OnCloseupAsyncAdvancedHwtx)
    ON_CBN_SELCHANGE(IDC_ASYNC_ADVANCED_HWTX, OnSelchangeAsyncAdvancedHwtx)
    ON_BN_CLICKED(IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE, OnClickedAsyncAdvancedFlowcontrolHardware)
    ON_BN_CLICKED(IDC_ASYNC_ADVANCED_FLOWCONTROL_SOFTWARE, OnClickedAsyncAdvancedFlowcontrolSoftware)
    ON_BN_CLICKED(IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE, OnClickedAsyncAdvancedFlowcontrolNone)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


////////////////////////////////////////////////////////////////////////////////
// CAdvancedAsyncDlg commands

/*******************************************************************************
 *
 *  OnInitDialog - CAdvancedAsyncDlg member function: command (override)
 *
 *      Performs the dialog intialization.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnInitDialog documentation)
 *
 ******************************************************************************/

BOOL
CAdvancedAsyncDlg::OnInitDialog()
{
    int i;
    CString string;
    CComboBox *pComboBox;

    /*
     * Call the parent classes' OnInitDialog to perform default dialog
     * initialization.
     */    
    CBaseDialog::OnInitDialog();

    /*
     * Load up combo boxes with strings.
     */
    pComboBox = (CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWRX);
    string.LoadString(IDS_ASYNC_ADVANCED_HWRX_NOTHING);
    pComboBox->AddString(string);
    string.LoadString(IDS_ASYNC_ADVANCED_HWRX_TURN_OFF_RTS);
    pComboBox->AddString(string);
    string.LoadString(IDS_ASYNC_ADVANCED_HWRX_TURN_OFF_DTR);
    pComboBox->AddString(string);

    pComboBox = (CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWTX);
    string.LoadString(IDS_ASYNC_ADVANCED_HWTX_ALWAYS);
    pComboBox->AddString(string);
    string.LoadString(IDS_ASYNC_ADVANCED_HWTX_WHEN_CTS_IS_ON);
    pComboBox->AddString(string);
    string.LoadString(IDS_ASYNC_ADVANCED_HWTX_WHEN_DSR_IS_ON);
    pComboBox->AddString(string);

    /*
     * Initalize all dialog fields.
     */
    SetFields();

    if ( m_bReadOnly ) {

        /*                          
         * Document is 'read-only': disable all dialog controls and labels
         * except for CANCEL & HELP buttons.
         */
        for ( i=IDL_ASYNC_ADVANCED_FLOWCONTROL;
              i <=IDC_ASYNC_ADVANCED_BYTESIZE_8; i++ )
            GetDlgItem(i)->EnableWindow(FALSE);
        GetDlgItem(IDOK)->EnableWindow(FALSE);
    }

    /*
     * Set all combo boxes to use the 'extended' UI.
     */
    ((CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWRX))->SetExtendedUI(TRUE);
    ((CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWTX))->SetExtendedUI(TRUE);

    return(TRUE);

}  // end CAdvancedAsyncDlg::OnInitDialog


/*******************************************************************************
 *
 *  OnClickedAsyncAdvancedFlowcontrolHardware -
 *                              CAdvancedAsyncDlg member function: command
 *
 *      Change the state of the FlowControl flags and corresponding dialog
 *      controls when HARDWARE is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolHardware()
{
    GetFlowControlFields();
    SetFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolHardware


/*******************************************************************************
 *
 *  OnClickedAsyncAdvancedFlowcontrolSoftware -
 *                              CAdvancedAsyncDlg member function: command
 *
 *      Change the state of the FlowControl flags and corresponding dialog
 *      controls when SOFTWARE is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolSoftware()
{
    GetFlowControlFields();
    SetFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolSoftware


/*******************************************************************************
 *
 *  OnClickedAsyncAdvancedFlowcontrolNone -
 *                              CAdvancedAsyncDlg member function: command
 *
 *      Change the state of the FlowControl flags and corresponding dialog
 *      controls when NONE is clicked.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolNone()
{
    GetFlowControlFields();
    SetFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolNone


/*******************************************************************************
 *
 *  OnCloseupAsyncAdvancedHwrx - CAdvancedAsyncDlg member function: command
 *
 *      Invoke OnSelchangeAsyncAdvancedHwrx() when 'receive' HW flow combo box
 *      closes up.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::OnCloseupAsyncAdvancedHwrx()
{
    OnSelchangeAsyncAdvancedHwrx();
    
}  // end CAdvancedAsyncDlg::OnCloseupAsyncAdvancedHwrx


/*******************************************************************************
 *
 *  OnSelchangeAsyncAdvancedHwrx - CAdvancedAsyncDlg member function: command
 *
 *      Process new Hardware Receive Flow Control selection.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::OnSelchangeAsyncAdvancedHwrx()
{
    CComboBox *pHWRx = (CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWRX);

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if ( pHWRx->GetDroppedState() )
        return;

    /*
     * Fetch and Set the Hardware fields to update.
     */
    GetHWFields();
    SetHWFields();    
    SetHWFlowText();

}  // end CAdvancedAsyncDlg::OnSelchangeAsyncAdvancedHwrx


/*******************************************************************************
 *
 *  OnCloseupAsyncAdvancedHwtx - CAdvancedAsyncDlg member function: command
 *
 *      Invoke OnSelchangeAsyncAdvancedHwtx() when 'transmit' HW flow combo box
 *      closes up.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::OnCloseupAsyncAdvancedHwtx()
{
    OnSelchangeAsyncAdvancedHwtx();
    
}  // end CAdvancedAsyncDlg::OnCloseupAsyncAdvancedHwtx


/*******************************************************************************
 *
 *  OnSelchangeAsyncAdvancedHwtx - CAdvancedAsyncDlg member function: command
 *
 *      Process new Hardware Transmit Flow Control selection.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::OnSelchangeAsyncAdvancedHwtx()
{
    CComboBox *pHWTx = (CComboBox *)GetDlgItem(IDC_ASYNC_ADVANCED_HWTX);

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if ( pHWTx->GetDroppedState() )
        return;

    /*
     * Fetch and Set the Hardware fields to update.
     */
    GetHWFields();
    SetHWFields();    
    SetHWFlowText();
    
}  // end CAdvancedAsyncDlg::OnSelchangeAsyncAdvancedHwtx


/*******************************************************************************
 *
 *  OnClickedAsyncAdvancedBasedec - CAdvancedAsyncDlg member function: command
 *
 *      Process request to display numbers using decimal base.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::OnClickedAsyncAdvancedBasedec()
{
    /*
     * Get/Set the SW fields to display in decimal base.
     */
    GetSWFields(FALSE);
    SetSWFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedBasedec


/*******************************************************************************
 *
 *  OnClickedAsyncAdvancedBasehex - CAdvancedAsyncDlg member function: command
 *
 *      Process request to display numbers using hexadecimal base.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::OnClickedAsyncAdvancedBasehex()
{
    /*
     * Get/Set the SW fields to display in hexadecimal base.
     */
    GetSWFields(FALSE);
    SetSWFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedBasehex


/*******************************************************************************
 *
 *  OnOK - CAdvancedAsyncDlg member function: command (override)
 *
 *      Read all control contents back into the Async config structure
 *      before closing the dialog.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnOk documentation)
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::OnOK()
{
    /*
     * If the Enter key was pressed while a combo box was dropped down, ignore
     * it (treat as combo list selection only).
     */
    if ( !HandleEnterEscKey(IDOK) )
        return;

    /*
     * Fetch the field contents.  Return (don't close dialog) if a problem
     * was found.
     */
    if ( !GetFields() )
        return;

    /*
     * Call the parent classes' OnOk to complete dialog closing
     * and destruction.
     */
    CBaseDialog::OnOK();

}  // end CAdvancedAsyncDlg::OnOK


/*******************************************************************************
 *
 *  OnCancel - CAdvancedAsyncDlg member function: command (override)
 *
 *      Cancel the dialog.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnCancel documentation)
 *
 ******************************************************************************/

void
CAdvancedAsyncDlg::OnCancel()
{
    /*
     * If the Esc key was pressed while a combo box was dropped down, ignore
     * it (treat as combo close-up and cancel only).
     */
    if ( !HandleEnterEscKey(IDCANCEL) )
        return;
    
    /*
     * Call the parent classes' OnCancel to complete dialog closing
     * and destruction.
     */
    CBaseDialog::OnCancel();

}  // end CAdvancedAsyncDlg::OnCancel
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\common.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* common.c
*
* WINUTILS common C helper functions
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\COMMON\VCS\COMMON.C  $
*  
*     Rev 1.3   16 Nov 1995 17:16:18   butchd
*  update
*  
*     Rev 1.2   24 Mar 1995 17:23:58   butchd
*  Added WINUTILS global instance handle
*  
*     Rev 1.1   20 Mar 1995 16:06:34   butchd
*  Segregated code for WIN32 & WIN16 library builds
*  
*     Rev 1.0   28 Feb 1995 17:37:12   butchd
*  Initial revision.
*  
*******************************************************************************/

/*
 * include files
 */
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#include "common.h"

/* 
 * Common WINUTIL external variables
 */
extern LPCTSTR WinUtilsAppName;
extern HWND WinUtilsAppWindow;
extern HINSTANCE WinUtilsAppInstance;

////////////////////////////////////////////////////////////////////////////////
// common helper functions

/*******************************************************************************
 *
 *  ErrorMessage - WINUTILS helper function
 *
 *      Display an error message with variable arguments - main application
 *      window is owner of message box.
 *
 *  ENTRY:
 *      nErrorResourceID (input)
 *          Resource ID of the format string to use in the error message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
ErrorMessage( int nErrorResourceID, ...)
{
    TCHAR sz1[256], sz2[1024];
    int length;

    va_list args;
    va_start( args, nErrorResourceID );

    length = LoadString(WinUtilsAppInstance, nErrorResourceID, sz1, 256);

    wvsprintf( sz2, sz1, args );
    lstrcpy(sz1, WinUtilsAppName);
    lstrcat(sz1, TEXT(" ERROR"));
    MessageBox( WinUtilsAppWindow,
                sz2, sz1, MB_OK | MB_ICONEXCLAMATION );

    va_end(args);

}  // end ErrorMessage


/*******************************************************************************
 *
 *  ErrorMessageStr - WINUTILS helper function
 *
 *      Load the specified error resource format string and format an error
 *      message string into the specified output buffer.
 *
 *  ENTRY:
 *      pErrorString (output)
 *          Buffer to place formatted error string into.
 *      nErrorStringLen (input)
 *          Specifies maximum number of characters, including the terminator,
 *          that can be written to pErrorString.
 *      nErrorResourceID (input)
 *          Resource ID of the format string to use in the error message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
ErrorMessageStr( LPTSTR pErrorString,
                 int nErrorStringLen,
                 int nErrorResourceID, ...)
{
    TCHAR sz1[256], sz2[1024];
    int length;

    va_list args;
    va_start( args, nErrorResourceID );

    length = LoadString(WinUtilsAppInstance, nErrorResourceID, sz1, 256);

    wvsprintf( sz2, sz1, args );
    lstrncpy(pErrorString, sz2, nErrorStringLen);
    pErrorString[nErrorStringLen-1] = TEXT('\0');

    va_end(args);

}  // end ErrorMessage


/*******************************************************************************
 *
 *  ErrorMessageWndA - WINUTILS helper function (ANSI version)
 *
 *      Display an error message with variable arguments - caller specifies the
 *      owner of message box.
 *
 *  ENTRY:
 *      hWnd (input)
 *          Window handle of owner window for the message box.  If this is
 *           NULL, the main application window will be the owner.
 *      nErrorResourceID (input)
 *          Resource ID of the format string to use in the error message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
#ifdef WIN16
#define LoadStringA LoadString
#define wvsprintfA wvsprintf
#define lstrcpyA lstrcpy
#define lstrcatA lstrcat
#define MessageBoxA MessageBox
ErrorMessageWnd( 
#else
ErrorMessageWndA( 
#endif
                  HWND hWnd,
                  int nErrorResourceID, ...)
{
    char sz1[256], sz2[1024];
    int length;

    va_list args;
    va_start( args, nErrorResourceID );

    length = LoadStringA(WinUtilsAppInstance, nErrorResourceID, sz1, 256);

    wvsprintfA( sz2, sz1, args );

#ifdef UNICODE
    wcstombs(sz1, WinUtilsAppName, sizeof(sz1));    
#else
    lstrcpyA(sz1, WinUtilsAppName);
#endif

    lstrcatA(sz1, " ERROR");
    MessageBoxA( 
                hWnd ? hWnd : WinUtilsAppWindow,
                 sz2, sz1, MB_OK | MB_ICONEXCLAMATION );

    va_end(args);

}  // end ErrorMessageWndA


#ifndef WIN16
/*******************************************************************************
 *
 *  ErrorMessageWndW - WINUTILS helper function (UNICODE version)
 *
 *      Display an error message with variable arguments - caller specifies the
 *      owner of message box.
 *
 *  ENTRY:
 *      hWnd (input)
 *          Window handle of owner window for the message box.  If this is
 *           NULL, the main application window will be the owner.
 *      nErrorResourceID (input)
 *          Resource ID of the format string to use in the error message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
ErrorMessageWndW( HWND hWnd,
                  int nErrorResourceID, ...)
{
    WCHAR sz1[256], sz2[1024];
    int length;

    va_list args;
    va_start( args, nErrorResourceID );

    length = LoadStringW(WinUtilsAppInstance, nErrorResourceID, sz1, 256);

    wvsprintfW( sz2, sz1, args );

#ifndef UNICODE
    mbstowcs(sz1, WinUtilsAppName, lstrlenA(WinUtilsAppName)+1);    
#else
    lstrcpyW(sz1, WinUtilsAppName);
#endif

    lstrcatW(sz1, L" ERROR");
    MessageBoxW( hWnd ? hWnd : WinUtilsAppWindow,
                 sz2, sz1, MB_OK | MB_ICONEXCLAMATION );

    va_end(args);

}  // end ErrorMessageWndW
#endif // WIN16


/*******************************************************************************
 *
 *  QuestionMessage - WINUTILS helper function
 *
 *      Display a 'question' message with variable arguments and return the
 *      user's response - main application window is owner of message box.
 *
 *  ENTRY:
 *      nType (input)
 *          Message box 'type' flags to determine the apperance and function
 *          of the generated MessageBox.
 *      nErrorResourceID (input)
 *          Resource ID of the format string to use in the error message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *      (int) Returns the user response from the MessageBox function.
 *
 ******************************************************************************/

int
QuestionMessage( UINT nType,
                 int nQuestionResourceID, ...)
{
    TCHAR sz1[256], sz2[1024];
    int reply, length;

    va_list args;
    va_start( args, nQuestionResourceID );

    length = LoadString(WinUtilsAppInstance, nQuestionResourceID, sz1, 256);

    wvsprintf( sz2, sz1, args );
    reply = MessageBox( WinUtilsAppWindow,
                        sz2, WinUtilsAppName, nType );

    va_end(args);

    return(reply);

}  // end QuestionMessage


/*******************************************************************************
 *
 *  QuestionMessageWnd - WINUTILS helper function
 *
 *      Display a 'question' message with variable arguments and return the
 *      user's response - caller specifies the owner of message box.
 *
 *  ENTRY:
 *      hWnd (input)
 *          Window handle of owner window for the message box.  If this is
 *           NULL, the main application window will be the owner.
 *      nType (input)
 *          Message box 'type' flags to determine the apperance and function
 *          of the generated MessageBox.
 *      nErrorResourceID (input)
 *          Resource ID of the format string to use in the error message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *      (int) Returns the user response from the MessageBox function.
 *
 ******************************************************************************/

int
QuestionMessageWnd( HWND hWnd,
                    UINT nType,
                    int nQuestionResourceID, ...)
{
    TCHAR sz1[256], sz2[1024];
    int reply, length;

    va_list args;
    va_start( args, nQuestionResourceID );

    length = LoadString(WinUtilsAppInstance, nQuestionResourceID, sz1, 256);

    wvsprintf( sz2, sz1, args );
    reply = MessageBox( hWnd ? hWnd : WinUtilsAppWindow,
                        sz2, WinUtilsAppName, nType );

    va_end(args);

    return(reply);

}  // end QuestionMessageWnd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\ewsdlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* ewsdlg.h
*
* interface of CEditWinStationDlg dialog class
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   donm  $  Butch Davis
*
* $Log:   N:\nt\private\utils\citrix\winutils\wincfg\VCS\ewsdlg.h  $
*  
*     Rev 1.13   10 Dec 1997 15:59:26   donm
*  added ability to have extension DLLs
*  
*     Rev 1.12   27 Jun 1997 15:58:32   butchd
*  Registry changes for Wds/Tds/Pds/Cds
*  
*     Rev 1.11   21 Mar 1997 16:26:14   butchd
*  update
*  
*     Rev 1.10   03 Mar 1997 17:14:28   butchd
*  update
*  
*     Rev 1.9   28 Feb 1997 17:59:36   butchd
*  update
*  
*     Rev 1.8   18 Dec 1996 16:02:08   butchd
*  update
*  
*     Rev 1.7   27 Sep 1996 13:58:42   butchd
*  update
*  
*     Rev 1.6   24 Sep 1996 16:21:40   butchd
*  update
*  
*******************************************************************************/

/*
 * Include the base dialog class.
 */
#include "basedlg.h"

////////////////////////////////////////////////////////////////////////////////
// CEditWinStationDlg class
//
typedef enum _EWSDLGMODE {
    EWSDlgAdd,
    EWSDlgCopy,
    EWSDlgEdit,
    EWSDlgView,
    EWSDlgRename,
} EWSDLGMODE;

class CEditWinStationDlg : public CBaseDialog
{

/*
 * Member variables.
 */
    //{{AFX_DATA(CEditWinStationDlg)
    enum { IDD = IDD_EDIT_WINSTATION };
    //}}AFX_DATA
private:
    class CAppServerDoc *m_pDoc;
    CObList *m_pCurrentTdList;
    CObList *m_pCurrentPdList;
public:
    PWINSTATIONNAME m_pWSName;
    WINSTATIONCONFIG2 m_WSConfig;
    EWSDLGMODE m_DlgMode;
    PDCONFIG2 m_PreviousPdConfig;
    BOOL m_bAsyncListsInitialized;
    int m_nPreviousMaxTAPILineNumber;
    int m_nCurrentMaxTAPILineNumber;
    int m_nComboBoxIndexOfLatestTAPIDevice;
    void *m_pExtObject;
protected:
    NASICONFIG m_NASIConfig;

/* 
 * Implementation.
 */
public:
    
    CEditWinStationDlg( class CAppServerDoc *pDoc );

/*
 * Operations.
 */
protected:
    BOOL AddNetworkDeviceNameToList(PPDCONFIG3 pPdConfig,CComboBox * pLanAdapter);
    void RefrenceAssociatedLists();
    void InitializeTransportComboBox();
    BOOL InitializeLists( PPDCONFIG3 pPdConfig );
    void HandleListInitError( PPDCONFIG3 pPdConfig, DWORD ListInitError );
    void HandleSetFieldsError( PPDCONFIG3 pPdConfig, int nId );
    BOOL InitializeAsyncLists( PPDCONFIG3 pPdConfig );
    BOOL InitializeNetworkLists( PPDCONFIG3 pPdConfig );
    BOOL InitializeNASIPortNames( PNASICONFIG pNASIConfig );
    BOOL InitializeOemTdLists( PPDCONFIG3 pPdConfig );
    void GetSelectedPdConfig( PPDCONFIG3 pPdConfig );
    void GetSelectedWdConfig( PWDCONFIG2 pWdConfig );
    PTERMLOBJECT GetSelectedWdListObject();
    BOOL SetConfigurationFields();
    void EnableAsyncFields( BOOL bEnableAndShow );
    void EnableConsoleFields( BOOL bEnableAndShow );
    void EnableNetworkFields( BOOL bEnableAndShow );
    void EnableNASIFields( BOOL bEnableAndShow );
    void EnableOemTdFields( BOOL bEnableAndShow );
    BOOL SetAsyncFields();
    BOOL SetConsoleFields();
    BOOL SetNetworkFields();
    BOOL SetNASIFields();
    BOOL SetOemTdFields();
    void SetDefaults();
    BOOL GetConfigurationFields();
    BOOL GetAsyncFields();
    BOOL GetConsoleFields();
    BOOL GetNetworkFields();
    BOOL GetNASIFields();
    BOOL GetOemTdFields();
    void SetupInstanceCount(int nControlId);
    BOOL ValidateInstanceCount(int nControlId);

/*
 * Message map / commands.
 */
protected:
    //{{AFX_MSG(CEditWinStationDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnClickedAsyncModeminstall();
    afx_msg void OnClickedAsyncModemconfig();
    afx_msg void OnClickedAsyncModemcallbackInherit();
    afx_msg void OnClickedAsyncModemcallbackPhonenumberInherit();
    afx_msg void OnClickedAsyncDefaults();
    afx_msg void OnClickedAsyncAdvanced();
    afx_msg void OnClickedAsyncTest();
    afx_msg void OnClickedNasiInstancecountUnlimited();
    afx_msg void OnClickedNasiAdvanced();
    afx_msg void OnClickedNetworkInstancecountUnlimited();
    afx_msg void OnClickedOemInstancecountUnlimited();
    afx_msg void OnClickedAdvancedWinStation();
    afx_msg void OnCloseupPdname();
    afx_msg void OnSelchangePdname();
    afx_msg void OnCloseupWdname();
    afx_msg void OnSelchangeWdname();
    afx_msg void OnCloseupAsyncDevicename();
    afx_msg void OnSelchangeAsyncDevicename();
    afx_msg void OnCloseupAsyncModemcallback();
    afx_msg void OnSelchangeAsyncModemcallback();
    afx_msg void OnCloseupAsyncBaudrate();
    afx_msg void OnSelchangeAsyncBaudrate();
    afx_msg void OnCloseupAsyncConnect();
    afx_msg void OnSelchangeAsyncConnect();
    afx_msg void OnDropdownNasiPortname();
    virtual void OnOK();
    virtual void OnCancel();
    afx_msg LRESULT OnListInitError(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnSetFieldsError(WPARAM wParam, LPARAM lParam);
    afx_msg void OnClickedClientSettings();
    afx_msg void OnClickedExtensionButton();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  // end CEditWinStationDlg class interface
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\dialogs.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* dialogs.h
*
* interface of WINCFG dialogs
*
* copyright notice: Copyright 1996, Citrix Systems Inc.
*
* $Author:   donm  $  Butch Davis
*
* $Log:   N:\nt\private\utils\citrix\winutils\tscfg\VCS\dialogs.h  $
*  
*     Rev 1.31   18 Apr 1998 15:32:58   donm
*  Added capability bits
*  
*     Rev 1.30   13 Jan 1998 14:08:22   donm
*  gets encryption levels from extension DLL
*  
*     Rev 1.29   31 Jul 1997 16:33:26   butchd
*  update
*  
*     Rev 1.28   27 Sep 1996 17:52:24   butchd
*  update
*  
*******************************************************************************/

/*
 * Include the base dialog class.
 */
#include "basedlg.h"

#define ULONG_DIGIT_MAX 12
#define UINT_DIGIT_MAX 7
#define UCHAR_DIGIT_MAX 5

////////////////////////////////////////////////////////////////////////////////
// CAdvancedWinStationDlg class
//
class CAdvancedWinStationDlg : public CBaseDialog
{

/*
 * Member variables.
 */
    //{{AFX_DATA(CAdvancedWinStationDlg)
    enum { IDD = IDD_ADVANCED_WINSTATION };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA
public:
    ULONG m_fEnableWinStation: 1;
    USERCONFIG m_UserConfig;
//  HOTKEYTABLECONFIG m_Hotkeys;
    int m_CurrentHotkeyType;
    BOOL m_bReadOnly;
    BOOL m_bSystemConsole;
    PTERMLOBJECT m_pTermObject;
    ULONG m_Capabilities;

private:
    EncryptionLevel *m_pEncryptionLevels;
    ULONG m_NumEncryptionLevels;
    WORD m_DefaultEncryptionLevelIndex;

/*
 * Implementation.
 */
public:
    CAdvancedWinStationDlg();

/*
 * Operations.
 */
protected:
    BOOL HandleEnterEscKey(int nID);

/*
 * Message map / commands.
 */
protected:
    //{{AFX_MSG(CAdvancedWinStationDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnClickedAwsConnectionNone();
    afx_msg void OnClickedAwsConnectionInherit();
    afx_msg void OnClickedAwsDisconnectionNone();
    afx_msg void OnClickedAwsDisconnectionInherit();
    afx_msg void OnClickedAwsIdleNone();
    afx_msg void OnClickedAwsIdleInherit();
    afx_msg void OnClickedAwsAutologonInherit();
    afx_msg void OnClickedAwsPromptForPassword();
    afx_msg void OnClickedAwsInitialprogramInherit();
    afx_msg void OnClickedAwsSecurityDisableencryption();
    afx_msg void OnClickedAwsUseroverrideDisablewallpaper();
    afx_msg void OnClickedAwsBrokenInherit();
    afx_msg void OnClickedAwsReconnectInherit();
    afx_msg void OnClickedAwsShadowInherit();
    virtual void OnOK();
    virtual void OnCancel();
	afx_msg void OnClickedAwsInitialprogramPublishedonly();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  // end CAdvancedWinStationDlg class interface
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// CClientSettingsDlg class
//
class CClientSettingsDlg : public CBaseDialog
{

/*
 * Member variables.
 */
    //{{AFX_DATA(CClientSettingsDlg)
    enum { IDD = IDD_CLIENT_SETTINGS };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA
public:
    USERCONFIG m_UserConfig;
    BOOL m_bReadOnly;
    ULONG m_Capabilities;

/*
 * Implementation.
 */
public:
    CClientSettingsDlg();

/*
 * Operations.
 */
protected:

/*
 * Message map / commands.
 */
protected:
    //{{AFX_MSG(CClientSettingsDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnClickedCsClientdevicesDrives();
    afx_msg void OnClickedCsClientdevicesPrinters();
    afx_msg void OnClickedCsClientdevicesInherit();
	afx_msg void OnClickedCsClientdevicesForceprtdef();
	afx_msg void OnClickedCsMappingDrives();
	afx_msg void OnClickedCsMappingWindowsprinters();
	afx_msg void OnClickedCsMappingDoslpts();
	afx_msg void OnClickedCsMappingComports();
	afx_msg void OnClickedCsMappingClipboard();
    virtual void OnOK();
    virtual void OnCancel();
	afx_msg void OnClickedCsMappingAudio();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  // end CClientSettingsDlg class interface
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// CAdvancedAsyncDlg class
//
class CAdvancedAsyncDlg : public CBaseDialog
{

/*
 * Member variables.
 */
    //{{AFX_DATA(CAdvancedAsyncDlg)
    enum { IDD = IDD_ASYNC_ADVANCED };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA
public:
    ASYNCCONFIG m_Async;
    BOOL m_bReadOnly;
    BOOL m_bModem;
    int m_nHexBase;
    ULONG m_nWdFlag;

/* 
 * Implementation.
 */
public:
    CAdvancedAsyncDlg();

/*
 * Operations.
 */
protected:
    BOOL HandleEnterEscKey(int nID);
    void SetFields();
    void SetHWFlowText();
    void SetGlobalFields();
    void SetHWFields();
    void SetSWFields();
    BOOL GetFields();
    void GetFlowControlFields();
    BOOL GetGlobalFields();
    BOOL GetHWFields();
    BOOL GetSWFields( BOOL bValidate );

/*
 * Message map / commands.
 */
protected:
    //{{AFX_MSG(CAdvancedAsyncDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnClickedAsyncAdvancedFlowcontrolHardware();
    afx_msg void OnClickedAsyncAdvancedFlowcontrolSoftware();
    afx_msg void OnClickedAsyncAdvancedFlowcontrolNone();
    afx_msg void OnClickedAsyncAdvancedBasedec();
    afx_msg void OnClickedAsyncAdvancedBasehex();
    afx_msg void OnCloseupAsyncAdvancedHwrx();
    afx_msg void OnSelchangeAsyncAdvancedHwrx();
    afx_msg void OnCloseupAsyncAdvancedHwtx();
    afx_msg void OnSelchangeAsyncAdvancedHwtx();
    virtual void OnOK();
    virtual void OnCancel();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  // end CAdvancedAsyncDlg class interface
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\ewsdlg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* ewsdlg.cpp
*
* implementation of CEditWinStationDlg dialog class
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   thanhl  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\TSCFG\VCS\EWSDLG.CPP  $
*
*     Rev 1.51   04 May 1998 13:14:50   thanhl
*  MS bug#2090 fix
*
*     Rev 1.50   18 Apr 1998 15:31:18   donm
*  Added capability bits
*
*     Rev 1.49   Feb 21 1998 12:58:56   grega
*
*
*     Rev 1.47   28 Jan 1998 14:08:36   donm
*  sets default encryption and grays out control properly
*
*     Rev 1.46   13 Jan 1998 14:08:26   donm
*  gets encryption levels from extension DLL
*
*     Rev 1.45   10 Dec 1997 15:59:20   donm
*  added ability to have extension DLLs
*
*     Rev 1.44   16 Sep 1997 09:16:30   butchd
*  delayed network transport error till OnOK
*
*     Rev 1.43   29 Jul 1997 11:10:54   butchd
*  Don't allow editing of Max WinStation Count during rename
*
*     Rev 1.42   15 Jul 1997 17:08:34   thanhl
*  Add support for Required PDs
*
*     Rev 1.41   27 Jun 1997 15:58:26   butchd
*  Registry changes for Wds/Tds/Pds/Cds
*
*     Rev 1.40   19 Jun 1997 19:22:14   kurtp
*  update
*
*     Rev 1.39   18 Jun 1997 15:13:32   butchd
*  Hydrix split
*
*     Rev 1.38   19 May 1997 14:34:42   butchd
*  ifdef out NASICALL dependancies
*
*     Rev 1.37   03 May 1997 19:06:28   butchd
*  look out for RAS-configured modems
*
*     Rev 1.36   25 Apr 1997 11:07:18   butchd
*  update
*
*     Rev 1.35   25 Mar 1997 09:00:04   butchd
*  update
*
*     Rev 1.34   21 Mar 1997 16:26:10   butchd
*  update
*
*     Rev 1.33   11 Mar 1997 15:37:18   donm
*  update
*
*     Rev 1.32   03 Mar 1997 17:14:24   butchd
*  update
*
*     Rev 1.31   28 Feb 1997 17:59:32   butchd
*  update
*
*     Rev 1.30   18 Dec 1996 16:02:04   butchd
*  update
*
*     Rev 1.29   15 Oct 1996 09:11:12   butchd
*  update
*
*******************************************************************************/

/*
 * include files
 */
#include "stdafx.h"
#include "wincfg.h"
//#include <citrix\nasicall.h>// for InitializeNASIPortNames() NASI enum call
#include <hydra\oemtdapi.h>// for OemTdxxx APIs

#include "appsvdoc.h"
#include "ewsdlg.h"
#include "atdlg.h"
#include "anasidlg.h"

#define INITGUID
#include "objbase.h"
#include "initguid.h"
#include <netcfgx.h>
#include "devguid.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CWincfgApp *pApp;
extern "C" LPCTSTR WinUtilsAppName;
extern "C" HWND WinUtilsAppWindow;
extern "C" HINSTANCE WinUtilsAppInstance;

/*
 * Global command line variables.
 */
extern USHORT       g_Install;
extern USHORT       g_Add;
extern WDNAME       g_szType;
extern PDNAME       g_szTransport;
extern ULONG        g_ulCount;


#define RELEASEPTR(iPointer)    if(iPointer)                                        \
                                        {                                                       \
                                             iPointer->Release();     \
                                             iPointer = NULL;                              \
                                        }
////////////////////////////////////////////////////////////////////////////////
// CEditWinStationDlg class construction / destruction, implementation

/*******************************************************************************
 *
 *  CEditWinStationDlg - CEditWinStationDlg constructor
 *
 *  ENTRY:
 *      pDoc (input)
 *          Points to CAppServerDoc; current document.
 *  EXIT:
 *      (Refer to MFC CDialog::CDialog documentation)
 *
 ******************************************************************************/

CEditWinStationDlg::CEditWinStationDlg( CAppServerDoc *pDoc )
    : CBaseDialog(CEditWinStationDlg::IDD),
      m_pDoc(pDoc),
      m_bAsyncListsInitialized(FALSE),
      m_nPreviousMaxTAPILineNumber(-1),
      m_nCurrentMaxTAPILineNumber(-1),
      m_nComboBoxIndexOfLatestTAPIDevice(-1),
      m_pCurrentTdList(NULL),
      m_pCurrentPdList(NULL)
{
    //{{AFX_DATA_INIT(CEditWinStationDlg)
    //}}AFX_DATA_INIT

    /*
     * Zero-initialize the NASICONFIG member structure.
     */
    memset(&m_NASIConfig, 0, sizeof(m_NASIConfig));

}  // end CEditWinStationDlg::CEditWinStationDlg


////////////////////////////////////////////////////////////////////////////////
// CEditWinStationDlg operations

/*******************************************************************************
 *
 *  RefrenceAssociatedLists -
 *          CEditWinStationDlg member function: protected operation
 *
 *      Set the m_pCurrentTdList and m_pCurrentPdList members to point to the
 *      lists associated with the currently selected Wd (Type).
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::RefrenceAssociatedLists()
{
    int index, count, currentcount;
    POSITION pos;

    CComboBox *pWdNameBox = (CComboBox *)GetDlgItem(IDC_WDNAME);

    if ( (index = pWdNameBox->GetCurSel()) != CB_ERR ) {

        if ( (count = pWdNameBox->GetItemData( index )) != CB_ERR ) {

            for ( currentcount = 0, pos = pApp->m_TdListList.GetHeadPosition();
                  pos != NULL;
                  currentcount++ ) {

                m_pCurrentTdList = (CObList *)pApp->m_TdListList.GetNext( pos );
                if ( currentcount == count )
                    break;
            }

            for ( currentcount = 0, pos = pApp->m_PdListList.GetHeadPosition();
                  pos != NULL;
                  currentcount++ ) {

                m_pCurrentPdList = (CObList *)pApp->m_PdListList.GetNext( pos );
                if ( currentcount == count )
                    break;
            }
        }
    }

}  // end RefrenceAssociatedLists


/*******************************************************************************
 *
 *  InitializeTransportComboBox -
 *          CEditWinStationDlg member function: protected operation
 *
 *      Initialize the Transport combo box with Tds available for the
 *      currently selected Wd (Type).
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::InitializeTransportComboBox()
{
    CComboBox *pTdNameBox = (CComboBox *)GetDlgItem(IDC_TDNAME);
    POSITION pos;

    /*
     * (re)initialize the Transport combo-box.
     */
    pTdNameBox->ResetContent();

    for ( pos = m_pCurrentTdList->GetHeadPosition(); pos != NULL; ) {

        PPDLOBJECT pObject = (PPDLOBJECT)m_pCurrentTdList->GetNext( pos );

        pTdNameBox->AddString( pObject->m_PdConfig.Data.PdName );
    }

    /*
     * Select the currently specified PD in the combo-box.  If that fails,
     * select the first in the list.
     */
    if ( pTdNameBox->SelectString(-1, m_WSConfig.Pd[0].Create.PdName) == CB_ERR )
        pTdNameBox->SetCurSel(0);

}  // end InitializeTransportComboBox


/*******************************************************************************
 *
 *  InitializeLists - CEditWinStationDlg member function: protected operation
 *
 *      Initialize the list box(es) to be used with the specified Pd.
 *
 *  ENTRY:
 *      pPdConfig (input)
 *          Pointer to PDCONFIG3 structure specifying the Pd.
 *
 *  EXIT:
 *      (BOOL) TRUE if the Pd list box(es) were initialized.  FALSE if error.
 *
 *      FUTURE: For now, FALSE will indicate that there was an error
 *          initializing the device list for the PD, the cause of which is
 *          saved for GetLastError().  Additional status codes and/or
 *          a queue of error conditions will need to be returned as the
 *          additional FUTURE actions defined below are implemented.
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::InitializeLists( PPDCONFIG3 pPdConfig )
{
    switch( pPdConfig->Data.SdClass ) {

        case SdAsync:

            /*
             * Initialize the Device combo-box.
             */
            if ( !InitializeAsyncLists(pPdConfig) )
                return(FALSE);

            break;

        case SdNetwork:
            /*
             * Initialize the LANADAPTER combo-box.
             */
            if ( !InitializeNetworkLists(pPdConfig) )
                return(FALSE);

            break;


        case SdNasi:
            /*
             * NOTE: we don't initalize the NASI Port Name list at this
             * time, since it will be initialized at various times during
             * the dialog activity (like when SetDefaults() is processed).
             */
            break;

        case SdOemTransport:
            /*
             * Initialize the DEVICE combo-box.
             */
            if ( !InitializeOemTdLists(pPdConfig) )
                return(FALSE);

            break;

        default:
            break;
    }

    return(TRUE);

}  // end CEditWinStationDlg::InitializeLists


/*******************************************************************************
 *
 *  HandleListInitError -
 *                  CEditWinStationDlg member function: protected operation
 *
 *      Output a nice explaination as to why the list initialization failed.
 *
 *  ENTRY:
 *      pPdConfig (input)
 *          Pointer to PDCONFIG3 structure specifying the current Pd.
 *      ListInitError (input)
 *          Error resource id from InitializeLists
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::HandleListInitError( PPDCONFIG3 pPdConfig, DWORD ListInitError )
{
    /*
     * Output a specific message for error conditions.
     */
    switch( pPdConfig->Data.SdClass ) {

        case SdAsync:
        case SdNetwork:
        case SdNasi:
            ERROR_MESSAGE((ListInitError))
            break;

        case SdOemTransport:
            switch ( ListInitError ) {

                case IDP_ERROR_OEMTDINIT_NOCONFIGDLL:
                case IDP_ERROR_OEMTDINIT_CONFIGDLLENUMERATIONFAILURE:
                case IDP_ERROR_PDINIT:
                    ERROR_MESSAGE((ListInitError))
                    break;

                case IDP_ERROR_OEMTDINIT_MISSINGCONFIGDLLENTRYPOINT:
                case IDP_ERROR_OEMTDINIT_CANTOPENCONFIGDLL:
                    ERROR_MESSAGE((ListInitError, pPdConfig->ConfigDLL))
                    break;
            }
            break;
    }

}  // end CEditWinStationDlg::HandleListInitError


/*******************************************************************************
 *
 *  HandleSetFieldsError -
 *                  CEditWinStationDlg member function: protected operation
 *
 *      Output a nice explaination as to why the setting the Pd fields failed.
 *
 *  ENTRY:
 *      pPdConfig (input)
 *          Pointer to PDCONFIG3 structure specifying the current Pd.
 *      nId (input)
 *          Specifies control Id of field in error.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::HandleSetFieldsError( PPDCONFIG3 pPdConfig,
                                          int nId )
{
    /*
     * Output protocol-specific error message.
     */
    switch( pPdConfig->Data.SdClass ) {

        case SdAsync:
            switch ( nId ) {

                case IDC_ASYNC_DEVICENAME:
                    {
                    TCHAR szDecoratedName[DEVICENAME_LENGTH + MODEMNAME_LENGTH + 1];

                    FormDecoratedAsyncDeviceName(
                                    szDecoratedName,
                                    &(m_WSConfig.Pd[0].Params.Async) );
                    ERROR_MESSAGE(( IDP_ERROR_INVALIDDEVICE,
                                    szDecoratedName ))
                    }
                    break;

                default:
                    break;
            }
            break;

        case SdNetwork:
            switch ( nId ) {

                case IDC_NETWORK_LANADAPTER:
                    ERROR_MESSAGE(( (pPdConfig->Data.PdFlag & PD_LANA) ?
                                        IDP_ERROR_INVALIDNETBIOSLANA :
                                        IDP_ERROR_INVALIDNETWORKADAPTER,
                                     m_WSConfig.Pd[0].Params.Network.LanAdapter ))
                    break;

                default:
                    break;
            }
            break;

        case SdOemTransport:
            switch ( nId ) {

                case IDC_OEMTD_DEVICENAME:
                    ERROR_MESSAGE(( IDP_ERROR_INVALIDDEVICE,
                                    m_WSConfig.Pd[0].Params.OemTd.DeviceName ))
                    break;

                default:
                    break;
            }
            break;
    }

}  // end CEditWinStationDlg::HandleSetFieldsError


/*******************************************************************************
 *
 *  InitializeAsyncLists - CEditWinStationDlg member function: protected operation
 *
 *      Initialize the Async Device combo-box with the device strings
 *      associated with the specified Async PD DLL.
 *
 *  ENTRY:
 *      pPdConfig (input)
 *          Pointer to PDCONFIG3 structure specifying the Pd.
 *  EXIT:
 *      (BOOL) TRUE if the Device combo-box was initialized.
 *             FALSE if error (code set for GetLastError).
 *
 *      If the highest-numbered TAPI line device has been added to the combo
 *      box, the m_nComboBoxIndexOfLatestTAPIDevice member will be set to the
 *      combo-box index of that item.  It will be -1 if the combo-box does
 *      not contain the highest numbered TAPI line device.
 *
 *      This routine also saves the current max TAPI line number
 *      (m_nCurrentMaxTAPILineNumber) to the previous max TAPI line number
 *      (m_nPreviousMaxTAPILineNumber) and will recalculate the current max
 *      number so the caller can determine if the enumeration found a new TAPI
 *      line device by checking for m_nCurrentMaxTAPILineNumber >
 *      m_nPreviousMaxTAPILineNumber.
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::InitializeAsyncLists( PPDCONFIG3 pPdConfig )
{
    PPDPARAMS pPdParams;
    char *pBuffer = NULL;
    ULONG i, Entries;
    CComboBox *pDevice = (CComboBox *)GetDlgItem(IDC_ASYNC_DEVICENAME);
    int index, nLoopIndexOfLatestTAPIDevice = -1;
    TCHAR szDecoratedName[DEVICENAME_LENGTH + MODEMNAME_LENGTH + 1];

    /*
     * If the Async lists have already been initialized, we don't need to
     * do it again, since there is only one Async Transport for WinStations.
     * This is not the case for Network WinStations, as there are different
     * network transport types.
     */
    if ( m_bAsyncListsInitialized )
        return(TRUE);

    /*
     * Clear the Device combo-box.
     */
    pDevice->ResetContent();

    /*
     * Perform the device enumeration.
     */
    if ( (pBuffer = (char *)WinEnumerateDevices(
                        this->GetSafeHwnd(),
                        pPdConfig,
                        &Entries,
                        g_Install ? TRUE : FALSE )) == NULL ) {
        SetLastError(IDP_ERROR_ASYNCDEVICEINIT);
        goto BadEnumerate;
    }

    /*
     * Set previous max TAPI line number to current max TAPI line number,
     * initialize current max TAPI line number and latest TAPI device combo-box
     * index, and loop to initialize the combo-box.
     */
    m_nPreviousMaxTAPILineNumber = m_nCurrentMaxTAPILineNumber;
    m_nCurrentMaxTAPILineNumber = m_nComboBoxIndexOfLatestTAPIDevice = -1;
    for ( i = 0, pPdParams = (PPDPARAMS)pBuffer; i < Entries; i++, pPdParams++ ) {

        /*
         * Form decorated name.
         */
        FormDecoratedAsyncDeviceName( szDecoratedName, &(pPdParams->Async) );

        /*
         * If this device is a TAPI modem and it's line number (in BaudRate field)
         * is greater than the current max line number, set it's line number as max and
         * save this loop index.
         */
        if ( *(pPdParams->Async.ModemName) &&
             (int(pPdParams->Async.BaudRate) > m_nCurrentMaxTAPILineNumber) ) {

            m_nCurrentMaxTAPILineNumber = int(pPdParams->Async.BaudRate);
            nLoopIndexOfLatestTAPIDevice = i;
        }

        /*
         * Don't add this device to the list if it is already in use by a
         * WinStation other than the current one.
         */
        if ( !((CAppServerDoc *)m_pDoc)->
                IsAsyncDeviceAvailable( pPdParams->Async.DeviceName,
                                        (m_DlgMode == EWSDlgCopy) ?
                                            TEXT("") : m_pWSName) )
            continue;

        /*
         * Insert the name into the combo-box if it's not a TAPI modem
         * or it is a TAPI modem that's not being used by RAS and it's
         * port is currently available.
         */
        if ( !*(pPdParams->Async.ModemName) ||
             (!pPdParams->Async.Parity &&
              (pDevice->FindStringExact(-1, pPdParams->Async.DeviceName)
                                        != CB_ERR)) ) {

            index = CBInsertInstancedName( szDecoratedName,
                                           pDevice );
            if ( (index == CB_ERR) || (index == CB_ERRSPACE) )
                goto BadAdd;
        }

        /*
         * If this device is a modem, make sure that the raw port this
         * device is configured on is not present in the list.  This will
         * also take care of removing the raw port for TAPI modems that are
         * configured for use by RAS, in which case neither the configured.
         * TAPI modem(s) or raw port will be present in the list.
         */
        if ( *(pPdParams->Async.ModemName) &&
             ((index = pDevice->FindStringExact(
                                    -1, pPdParams->Async.DeviceName ))
                                        != CB_ERR) )
            pDevice->DeleteString(index);
    }

    /*
     * Always make sure that the currently configured device is in
     * the list.
     */
    if ( *(m_WSConfig.Pd[0].Params.Async.DeviceName) ) {

        FormDecoratedAsyncDeviceName( szDecoratedName,
                                      &(m_WSConfig.Pd[0].Params.Async) );

        if ( (index = pDevice->FindStringExact(
                        -1, szDecoratedName )) == CB_ERR ) {

            index = CBInsertInstancedName(
                        szDecoratedName,
                        pDevice );
            if ( (index == CB_ERR) || (index == CB_ERRSPACE) )
                goto BadAdd;
        }
    }

    /*
     * If the highest line-numbered TAPI device that was added to
     * the combo-box, find and save it's index in
     * m_nComboBoxIndexOfLatestTAPIDevice.
     */
    if ( nLoopIndexOfLatestTAPIDevice > -1 ) {

        pPdParams = &((PPDPARAMS)pBuffer)[nLoopIndexOfLatestTAPIDevice];

        FormDecoratedAsyncDeviceName( szDecoratedName, &(pPdParams->Async) );
        if ( (index = pDevice->FindStringExact(-1, szDecoratedName)) != CB_ERR )
            m_nComboBoxIndexOfLatestTAPIDevice = index;
    }

    /*
     * Free the enumeration buffer and return success.
     */
    VERIFY( LocalFree(pBuffer) == NULL );
    m_bAsyncListsInitialized = TRUE;
    return(TRUE);

/*==============================================================================
 * Error returns
 *============================================================================*/
BadAdd:
    LocalFree(pBuffer);
    SetLastError(IDP_ERROR_PDINIT);
BadEnumerate:
    return(FALSE);

}  // end CEditWinStationDlg::InitializeAsyncLists


/*******************************************************************************
 *
 *  InitializeNetworkLists -
 *                  CEditWinStationDlg member function: protected operation
 *
 *      Initialize the Network Lan Adapter combo-box with the network adapter
 *      strings and ordinal values associated with the specified Network PD DLL.
 *
 *  ENTRY:
 *      pPdConfig (input)
 *          Pointer to PDCONFIG3 structure specifying the Pd.
 *
 *  EXIT:
 *      (BOOL) TRUE if the Lan Adapter combo-box was initialized.
 *             FALSE if error (code set for GetLastError)
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::InitializeNetworkLists( PPDCONFIG3 pPdConfig )
{

    BOOL bResult = 0;
    CComboBox *pLanAdapter = (CComboBox *)GetDlgItem(IDC_NETWORK_LANADAPTER);
    /*
     * Clear the Lan Adapter combo-box.
     */
    pLanAdapter->ResetContent();

    bResult = AddNetworkDeviceNameToList(pPdConfig,pLanAdapter);

    return(TRUE); //We are returning TRUE always as we atleast return "All Lan Adapters"

}  // end CEditWinStationDlg::InitializeNetworkLists


/*******************************************************************************
 *
 *  InitializeNASIPortNames -
 *                  CEditWinStationDlg member function: protected operation
 *
 *      Initialize the NASI Port Name combo-box with the NASI Port strings,
 *      based on the current NASICONFIG UserName, Password, FileServer,
 *      and GlobalSession settings.
 *
 *      NOTE: we only perform this initialization if any of the above settings
 *            have changed since the last time this function was called.
 *
 *  ENTRY:
 *      pNASIConfig (input)
 *          Pointer to NASICONFIG structure for the current NASI WinStation Set.
 *
 *  EXIT:
 *      (BOOL) TRUE if the Port Name combo-box was initialized (or not needed);
 *             FALSE if error (code set for GetLastError)
 *
 ******************************************************************************/

// local helper function StripUndies(): strips trailing underscores from
// names returned by NCS enumeration calls.
void
StripUndies( PBYTE String, ULONG Length )
{
    LONG i;

    for ( i = Length-2; i > 0; i-- ) {
        if ( String[i] == '_' )
        String[i] = '\0';
        else
        break;
    }
}

BOOL
CEditWinStationDlg::InitializeNASIPortNames( PNASICONFIG pNASIConfig )
{
#ifdef NASI
    PORTQUERY PortQuery;
    NCS_ENUMERATE_HANDLE hEnum;
    int index;
    ULONG Status;
#endif // NASI
    BOOL bReturn = TRUE;
    CComboBox *pPortName = (CComboBox *)GetDlgItem(IDC_NASI_PORTNAME);

    /*
     * Only do this if any of the 'input' settings have changed.
     */

    if ( !lstrcmp(m_NASIConfig.UserName, pNASIConfig->UserName) &&
         !lstrcmp(m_NASIConfig.PassWord, pNASIConfig->PassWord) &&
         !lstrcmp(m_NASIConfig.FileServer, pNASIConfig->FileServer) &&
         m_NASIConfig.GlobalSession == pNASIConfig->GlobalSession ) {

        return(TRUE);
    }

    /*
     * Update the saved input settings.
     */
    lstrcpy(m_NASIConfig.UserName, pNASIConfig->UserName);
    lstrcpy(m_NASIConfig.PassWord, pNASIConfig->PassWord);
    lstrcpy(m_NASIConfig.FileServer, pNASIConfig->FileServer);
    m_NASIConfig.GlobalSession = pNASIConfig->GlobalSession;

    /*
     * Clear the Port Name combo-box.
     */
    pPortName->ResetContent();

#ifdef NASI
    /*
     * Perform NASI port enumeration
     */
    if ( !(Status = NCSOpenEnumerate(
                                &hEnum,
                                (PBYTE)pNASIConfig->UserName,
                                   (PBYTE)pNASIConfig->PassWord,
                                   (PBYTE)pNASIConfig->FileServer,
                                   pNASIConfig->GlobalSession ? TRUE : FALSE )) ) {
        while ( !Status ) {
            Status = NCSEnumerate(hEnum, &PortQuery);

             if ( !Status ) {
                StripUndies(PortQuery.abSpecific, sizeof(PortQuery.abSpecific));
                index = pPortName->AddString((LPTSTR)PortQuery.abSpecific);

                if ( (index == CB_ERR) || (index == CB_ERRSPACE) ) {
                    SetLastError(IDP_ERROR_PDINIT);
                    bReturn = FALSE;
                    break;
                }
             }
        }

        NCSCloseEnumerate(hEnum);
    }
#endif // NASI

    /*
     * Set the Port Name combo-box selection.  Default to the
     * first item in the list (if any) if no SpecificName (Port Name)
     * is defined.
     */
    if ( !*(pNASIConfig->SpecificName) ) {
        pPortName->SetCurSel(0);
    } else {
        pPortName->SetWindowText(pNASIConfig->SpecificName);
    }

    return(bReturn);

}  // end CEditWinStationDlg::InitializeNASIPortNames


/*******************************************************************************
 *
 *  InitializeOemTdLists -
 *                  CEditWinStationDlg member function: protected operation
 *
 *      Initialize the Oem Transport Device combo-box with the device strings
 *      returned by the Oem configuration helper DLL
 *
 *  ENTRY:
 *      pPdConfig (input)
 *          Pointer to PDCONFIG3 structure specifying the Pd.
 *
 *  EXIT:
 *      (BOOL) TRUE if the device combo-box was initialized.
 *             FALSE if error (code set for GetLastError)
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::InitializeOemTdLists( PPDCONFIG3 pPdConfig )
{
    BOOL bStatus = FALSE;
    CComboBox *pDevice = (CComboBox *)GetDlgItem(IDC_OEMTD_DEVICENAME);
    HMODULE    hMod;
    PFNOEMTDENUMERATEDEVICESW pfnOemTdEnumerateDevicesW;
    PFNOEMTDFREEBUFFERW pfnOemTdFreeBufferW;

    /*
     * Clear the Device combo-box.
     */
    pDevice->ResetContent();

    if ( *pPdConfig->ConfigDLL ) {

        if ( hMod = ::LoadLibrary(pPdConfig->ConfigDLL) ) {

            if ( (pfnOemTdEnumerateDevicesW =
                    (PFNOEMTDENUMERATEDEVICESW)::GetProcAddress(hMod, OEMTDENUMERATEDEVICESW)) &&
                  (pfnOemTdFreeBufferW =
                    (PFNOEMTDFREEBUFFERW)::GetProcAddress(hMod, OEMTDFREEBUFFERW)) ) {

                LPWSTR pBuffer, pDeviceName;
                int index;

                if ( (*pfnOemTdEnumerateDevicesW)( &pBuffer ) == ERROR_SUCCESS ) {

                    for ( pDeviceName = pBuffer;
                          *pDeviceName;
                          pDeviceName += (wcslen(pDeviceName) + 1) ) {

                        /*
                         * Don't add this device to the list if it is already in use by a
                         * WinStation other than the current one.
                         */
                        if ( !((CAppServerDoc *)m_pDoc)->
                                IsOemTdDeviceAvailable( pDeviceName,
                                                        pPdConfig->Data.PdName,
                                                        (m_DlgMode == EWSDlgCopy) ?
                                                            TEXT("") : m_pWSName ) )
                            continue;

                        index = pDevice->AddString(pDeviceName);
                        if ( (index == CB_ERR) || (index == CB_ERRSPACE) ) {

                            SetLastError(IDP_ERROR_PDINIT);
                            break;
                        }
                    }
                    (*pfnOemTdFreeBufferW)( pBuffer );

                } else {

                    SetLastError(IDP_ERROR_OEMTDINIT_CONFIGDLLENUMERATIONFAILURE);
                }

            } else {

                SetLastError(IDP_ERROR_OEMTDINIT_MISSINGCONFIGDLLENTRYPOINT);
            }
            ::FreeLibrary(hMod);

        } else {

            SetLastError(IDP_ERROR_OEMTDINIT_CANTOPENCONFIGDLL);
        }

    } else {

        SetLastError(IDP_ERROR_OEMTDINIT_NOCONFIGDLL);
    }
    return(bStatus);

}  // end CEditWinStationDlg::InitializeOemTdLists


/*******************************************************************************
 *
 *  GetSelectedPdConfig - CEditWinStationDlg member function: protected operation
 *
 *      Read the PD config structure associated with the currently selected
 *      TD in the Transport combo-box.
 *
 *  ENTRY:
 *      pPdConfig (output)
 *          Pointer to PDCONFIG3 structure to fill.
 *  EXIT:
 *      nothing
 *
 ******************************************************************************/

void
CEditWinStationDlg::GetSelectedPdConfig( PPDCONFIG3 pPdConfig )
{
    POSITION pos;
    CComboBox *pPd = (CComboBox *)GetDlgItem(IDC_TDNAME);
    PDNAME PdName;
    PPDLOBJECT pObject;

    /*
     * Fetch the currently selected TD string from the combo-box.
     */
    pPd->GetLBText( pPd->GetCurSel(), PdName );

    /*
     * Traverse the PD list and obtain the PdConfig of matching PdName element.
     */
    for ( pos = m_pCurrentTdList->GetHeadPosition(); pos != NULL; ) {

        pObject = (PPDLOBJECT)m_pCurrentTdList->GetNext( pos );

        if ( !lstrcmp( pObject->m_PdConfig.Data.PdName, PdName ) ) {

            *pPdConfig = pObject->m_PdConfig;
            break;
        }
    }

}  // end CEditWinStation::GetSelectedPdConfig


/*******************************************************************************
 *
 *  GetSelectedWdConfig - CEditWinStationDlg member function: protected operation
 *
 *      Read the Wd config structure associated with the current
 *      selection in the Wd combo-box.
 *
 *  ENTRY:
 *      pWdConfig (output)
 *          Pointer to WDCONFIG2 structure to fill.
 *
 *  EXIT:
 *      nothing
 *
 ******************************************************************************/

void
CEditWinStationDlg::GetSelectedWdConfig( PWDCONFIG2 pWdConfig )
{
    POSITION pos;
    CComboBox *pWd = (CComboBox *)GetDlgItem(IDC_WDNAME);
    WDNAME WdName;
    PTERMLOBJECT pObject;

    /*
     * Fetch the currently selected WD string from the combo-box.
     */
    pWd->GetLBText( pWd->GetCurSel(), WdName );

    /*
     * Traverse the WD list and obtain the WdConfig of matching WdName element.
     */
    for ( pos = pApp->m_WdList.GetHeadPosition(); pos != NULL; ) {

        pObject = (PTERMLOBJECT)pApp->m_WdList.GetNext( pos );

        if ( !lstrcmp( pObject->m_WdConfig.Wd.WdName, WdName ) ) {

            *pWdConfig = pObject->m_WdConfig;
            break;
        }
    }

}  // end CEditWinStation::GetSelectedWdConfig


PTERMLOBJECT
CEditWinStationDlg::GetSelectedWdListObject()
{
    POSITION pos;
    CComboBox *pWd = (CComboBox *)GetDlgItem(IDC_WDNAME);
    WDNAME WdName;
    PTERMLOBJECT pObject;

    /*
     * Fetch the currently selected WD string from the combo-box.
     */
    pWd->GetLBText( pWd->GetCurSel(), WdName );

    /*
     * Traverse the WD list and obtain the WdConfig of matching WdName element.
     */
    for ( pos = pApp->m_WdList.GetHeadPosition(); pos != NULL; ) {

        pObject = (PTERMLOBJECT)pApp->m_WdList.GetNext( pos );

        if ( !lstrcmp( pObject->m_WdConfig.Wd.WdName, WdName ) ) {
            return(pObject);
        }
    }

    return(NULL);

}  // end CEditWinStation::GetSelectedWdListObject


/*******************************************************************************
 *
 *  SetConfigurationFields -
 *                  CEditWinStationDlg member function: protected operation
 *
 *      Main control function for the hiding / showing / setting of the proper
 *      Pd-specific configuration fields.
 *
 *
 *  ENTRY:
 *  EXIT:
 *      TRUE if the SetxxxFields was sucessful; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::SetConfigurationFields()
{
    BOOL bSetFields;

    /*
     * If the previous PdConfig is not the same as the current, disable and
     * hide all controls in the previous (currently displayed) Pd and
     * then enable (if not 'View' mode) and show the controls in the new
     * Pd.
     */
    if ( memcmp(&m_PreviousPdConfig, &(m_WSConfig.Pd[0].Create), sizeof(m_PreviousPdConfig)) ) {

        /*
         * If this is not the first time that the function is called (at
         * dialog init time), disable/hide the current configuration fields.
         * These fields will already be disabled/hidden otherwise.
         */
        if ( m_PreviousPdConfig.SdClass != SdNone ) {

            /*
             * Set the style of the parent dialog window to 'hidden' to suppress
             * the 'disable/hide' repainting of the child windows that is about
             * to take place.
             */
            SetWindowLong( m_hWnd, GWL_STYLE,
                           GetWindowLong( m_hWnd, GWL_STYLE ) & (~WS_VISIBLE) );

            switch ( m_PreviousPdConfig.SdClass ) {

                case SdAsync:
                    EnableAsyncFields(FALSE);
                    break;

                case SdNetwork:
                    EnableNetworkFields(FALSE);
                    break;

                case SdNasi:
                    EnableNASIFields(FALSE);
                    break;

                case SdOemTransport:
                    EnableOemTdFields(FALSE);
                    break;
            }

            /*
             * Make the parent dialog window visible again to allow the child
             * window 'enable/show' painting to take place.
             */
            SetWindowLong( m_hWnd, GWL_STYLE,
                           GetWindowLong( m_hWnd, GWL_STYLE ) | WS_VISIBLE );
          }

            switch ( m_WSConfig.Pd[0].Create.SdClass ) {

                case SdNone:
                    break;

            case SdAsync:
                    EnableAsyncFields(TRUE);
                    break;

                case SdNetwork:
                    EnableNetworkFields(TRUE);
                    break;

                case SdNasi:
                    EnableNASIFields(TRUE);
                    break;

                case SdOemTransport:
                    EnableOemTdFields(TRUE);
                    break;
            }

    }

    /*
     * Set the previous PdConfig to the current one.
     */
    memcpy(&m_PreviousPdConfig, &(m_WSConfig.Pd[0].Create), sizeof(m_PreviousPdConfig));

    // If the WD doesn't support any of the capabilities presented in the
    // "Client Settings" dialogs, disable it's button
    PTERMLOBJECT pTermObject = GetSelectedWdListObject();
    if(pTermObject && !(pTermObject->m_Capabilities & WDC_CLIENT_DIALOG_MASK)) {
          GetDlgItem(IDC_CLIENT_SETTINGS)->EnableWindow(FALSE);
    }

    /*
     * Set the data in the configuration fields.
     */
    switch ( m_WSConfig.Pd[0].Create.SdClass ) {

            case SdNone:
                bSetFields = TRUE;
                    break;

            case SdAsync:
                    bSetFields = SetAsyncFields();
                    break;

            case SdNetwork:
                    bSetFields = SetNetworkFields();
                    break;

            case SdNasi:
                    bSetFields = SetNASIFields();
                    break;

            case SdOemTransport:
                    bSetFields = SetOemTdFields();
                    break;
        }

    /*
     * Return the status of the SetxxxFields call.
     */
    return(bSetFields);

}  // end CEditWinStationDlg::SetConfigurationFields


/*******************************************************************************
 *
 *  EnableAsyncFields - CEditWinStationDlg member function: protected operation
 *
 *      Enable and show or disable and hide the Async Pd configuration field's
 *      control windows.
 *
 *  ENTRY:
 *      bEnableAndShow (input)
 *          TRUE to enable and show the controls; FALSE to disable and hide.
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::EnableAsyncFields( BOOL bEnableAndShow )
{
    BOOL bEnableFlag = (bEnableAndShow && ((m_DlgMode != EWSDlgView) &&
                                           (m_DlgMode != EWSDlgRename))) ?
                                                        TRUE : FALSE;
    int nCmdShow = bEnableAndShow ? SW_SHOW : SW_HIDE;
    int id;

    /*
     * NOTE: must keep the Async label and control IDs consecutive for this
     * iteration to function properly.
     */
    for ( id=IDL_ASYNC; id <= IDC_ASYNC_TEST; id++ ) {
        GetDlgItem(id)->EnableWindow(bEnableFlag);
        GetDlgItem(id)->ShowWindow(nCmdShow);
    }

    /*
     * The Advanced WinStation and Client Settings buttons are always
     * SHOWN and ENABLED for Async.
     */
     if(bEnableAndShow) {
         GetDlgItem(IDC_ADVANCED_WINSTATION)->ShowWindow(SW_SHOW);
         GetDlgItem(IDC_ADVANCED_WINSTATION)->EnableWindow(TRUE);
         GetDlgItem(IDC_CLIENT_SETTINGS)->ShowWindow(SW_SHOW);
         GetDlgItem(IDC_CLIENT_SETTINGS)->EnableWindow(TRUE);
     }

}  // end CEditWinStationDlg::EnableAsyncFields


/*******************************************************************************
 *
 *  EnableNetworkFields - CEditWinStationDlg member function: protected operation
 *
 *      Enable and show or disable and hide the Network Pd configuration
 *      field's control windows.
 *
 *  ENTRY:
 *      bEnableAndShow (input)
 *          TRUE to enable and show the controls; FALSE to disable and hide.
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::EnableNetworkFields( BOOL bEnableAndShow )
{
    BOOL bEnableFlag = (bEnableAndShow && ((m_DlgMode != EWSDlgView) &&
                                           (m_DlgMode != EWSDlgRename))) ?
                                                        TRUE : FALSE;
    int nCmdShow = bEnableAndShow ? SW_SHOW : SW_HIDE;
    int id;

    /*
     * NOTE: must keep the Network label and control IDs consecutive for this
     * iteration to function properly.
     */
    for ( id=IDL_NETWORK; id <= IDC_NETWORK_INSTANCECOUNT_UNLIMITED; id++ ) {
        GetDlgItem(id)->EnableWindow(bEnableFlag);
        GetDlgItem(id)->ShowWindow(nCmdShow);
    }

    /*
     * The Advanced WinStation and Client Settings buttons are
     * always SHOWN and ENABLED for Network.
     */
     if(bEnableAndShow) {
         GetDlgItem(IDC_ADVANCED_WINSTATION)->ShowWindow(SW_SHOW);
         GetDlgItem(IDC_ADVANCED_WINSTATION)->EnableWindow(TRUE);
         GetDlgItem(IDC_CLIENT_SETTINGS)->ShowWindow(SW_SHOW);
         GetDlgItem(IDC_CLIENT_SETTINGS)->EnableWindow(TRUE);
     }

}  // end CEditWinStationDlg::EnableNetworkFields


/*******************************************************************************
 *
 *  EnableNASIFields - CEditWinStationDlg member function: protected operation
 *
 *      Enable and show or disable and hide the NASI Pd configuration
 *      field's control windows.
 *
 *  ENTRY:
 *      bEnableAndShow (input)
 *          TRUE to enable and show the controls; FALSE to disable and hide.
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::EnableNASIFields( BOOL bEnableAndShow )
{
    BOOL bEnableFlag = (bEnableAndShow && ((m_DlgMode != EWSDlgView) &&
                                           (m_DlgMode != EWSDlgRename))) ?
                                                        TRUE : FALSE;
    int nCmdShow = bEnableAndShow ? SW_SHOW : SW_HIDE;
    int id;

    /*
     * NOTE: must keep the NASI label and control IDs consecutive for this
     * iteration to function properly.
     */
    for ( id=IDL_NASI; id <= IDC_NASI_ADVANCED; id++ ) {
        GetDlgItem(id)->EnableWindow(bEnableFlag);
        GetDlgItem(id)->ShowWindow(nCmdShow);
    }

    /*
     * The Advanced WinStation and Client Settings buttons are
     * always SHOWN and ENABLED for Nasi.
     */
     if(bEnableAndShow) {
         GetDlgItem(IDC_ADVANCED_WINSTATION)->ShowWindow(SW_SHOW);
         GetDlgItem(IDC_ADVANCED_WINSTATION)->EnableWindow(TRUE);
         GetDlgItem(IDC_CLIENT_SETTINGS)->ShowWindow(SW_SHOW);
         GetDlgItem(IDC_CLIENT_SETTINGS)->EnableWindow(TRUE);
     }

}  // end CEditWinStationDlg::EnableNASIFields


/*******************************************************************************
 *
 *  EnableOemTdFields - CEditWinStationDlg member function: protected operation
 *
 *      Enable and show or disable and hide the Oem Transport Pd configuration
 *      field's control windows.
 *
 *  ENTRY:
 *      bEnableAndShow (input)
 *          TRUE to enable and show the controls; FALSE to disable and hide.
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::EnableOemTdFields( BOOL bEnableAndShow )
{
    BOOL bEnableFlag = (bEnableAndShow && ((m_DlgMode != EWSDlgView) &&
                                           (m_DlgMode != EWSDlgRename))) ?
                                                        TRUE : FALSE;
    int nCmdShow = bEnableAndShow ? SW_SHOW : SW_HIDE;
    int id;

    /*
     * NOTE: must keep the Oem label and control IDs consecutive for this
     * iteration to function properly.
     */
    for ( id=IDL_OEMTD; id <= IDC_OEMTD_INSTANCECOUNT_UNLIMITED; id++ ) {
        GetDlgItem(id)->EnableWindow(bEnableFlag);
        GetDlgItem(id)->ShowWindow(nCmdShow);
    }

    /*
     * If we're enabling and this is a single-instance Oem Transport,
     * hide the multi-instance fields.
     */
    if ( bEnableAndShow && (m_WSConfig.Pd[0].Create.PdFlag & PD_SINGLE_INST) ) {

        for ( id=IDL_OEMTD_INSTANCECOUNT;
              id <= IDC_OEMTD_INSTANCECOUNT_UNLIMITED; id++ ) {
            GetDlgItem(id)->EnableWindow(FALSE);
            GetDlgItem(id)->ShowWindow(SW_HIDE);
        }
    }

    /*
     * The Advanced WinStation and Client Settings buttons are
     * always SHOWN and ENABLED for Oem.
     */
     if(bEnableAndShow) {
         GetDlgItem(IDC_ADVANCED_WINSTATION)->ShowWindow(SW_SHOW);
         GetDlgItem(IDC_ADVANCED_WINSTATION)->EnableWindow(TRUE);
         GetDlgItem(IDC_CLIENT_SETTINGS)->ShowWindow(SW_SHOW);
         GetDlgItem(IDC_CLIENT_SETTINGS)->EnableWindow(TRUE);
     }

}  // end CEditWinStationDlg::EnableOemTdFields


/*******************************************************************************
 *
 *  SetAsyncFields - CEditWinStationDlg member function: protected operation
 *
 *      Set the contents of the Async Pd configuration fields.
 *
 *  ENTRY:
 *  EXIT:
 *      TRUE if no errors on field setting; FALSE otherwise.
 *      WM_EDITSETFIELDSERROR message(s) will have been posted on error.
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::SetAsyncFields()
{
    BOOL bStatus = TRUE;
    BOOL bSelectDefault = (m_DlgMode == EWSDlgAdd) ||
                          (m_DlgMode == EWSDlgCopy) ||
                          !(*m_WSConfig.Pd[0].Params.Async.DeviceName);
    CComboBox *pDevice = (CComboBox *)GetDlgItem(IDC_ASYNC_DEVICENAME);
    CComboBox *pCallback = (CComboBox *)GetDlgItem(IDC_ASYNC_MODEMCALLBACK);
    TCHAR szDeviceName[DEVICENAME_LENGTH+MODEMNAME_LENGTH+1];

    /*
     * Set the DEVICE combo-box selection from the current selection.
     */
    FormDecoratedAsyncDeviceName( szDeviceName, &(m_WSConfig.Pd[0].Params.Async) );
    if ( pDevice->SelectString(-1, szDeviceName) == CB_ERR ) {

        /*
         * Can't select current async DeviceName in combo-box.  If this is
         * because we're supposed to select a default device name, select
         * the first device in the list.
         */
        if ( bSelectDefault ) {

            pDevice->SetCurSel(0);

        } else {

            PostMessage(WM_EDITSETFIELDSERROR, IDC_ASYNC_DEVICENAME, 0);
            bStatus = FALSE;
        }
    }

    /*
     * If the DEVICENAME list is empty, disable the Install Modems button,
     * since the user can't install a modem to a COM port that's unavailable
     * (maybe could, but would be very frustrating when it couldn't be used).
     */
    if ( pDevice->GetCount() == 0 )
        GetDlgItem(IDC_ASYNC_MODEMINSTALL)->EnableWindow(FALSE);

    /*
     * Set the MODEMCALLBACK combo-box selection, phone number, and 'inherit'
     * checkboxes, based on the current UserConfig settings.
     */
    pCallback->SetCurSel(m_WSConfig.Config.User.Callback);
    SetDlgItemText( IDC_ASYNC_MODEMCALLBACK_PHONENUMBER,
                    m_WSConfig.Config.User.CallbackNumber );
    CheckDlgButton( IDC_ASYNC_MODEMCALLBACK_INHERIT,
                    m_WSConfig.Config.User.fInheritCallback );
    CheckDlgButton( IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT,
                    m_WSConfig.Config.User.fInheritCallbackNumber );

    /*
     * Set the BAUDRATE combo-box selection (in it's edit field) and limit the
     * edit field text.
     */
    {
        TCHAR string[ULONG_DIGIT_MAX];

        wsprintf( string, TEXT("%lu"), m_WSConfig.Pd[0].Params.Async.BaudRate );

        SetDlgItemText( IDC_ASYNC_BAUDRATE, string );
        ((CEdit *)GetDlgItem(IDC_ASYNC_BAUDRATE))
            ->LimitText( ULONG_DIGIT_MAX-1 );
    }

    /*
     * Set the CONNECT combo-box selection.
     */
    ((CComboBox *)GetDlgItem(IDC_ASYNC_CONNECT))->SetCurSel(
                        m_WSConfig.Pd[0].Params.Async.Connect.Type);

    /*
     * Perform OnSelchangeAsyncDevicename() to properly
     * set up control states.
     */
    OnSelchangeAsyncDevicename();

    /*
     * Return the set fields status.
     */
    return(bStatus);

}  // end CEditWinStationDlg::SetAsyncFields


/*******************************************************************************
 *
 *  SetNetworkFields - CEditWinStationDlg member function: protected operation
 *
 *      Set the contents of the Network Pd configuration fields.
 *
 *  ENTRY:
 *  EXIT:
 *      TRUE if no errors on field setting; FALSE otherwise.
 *      WM_EDITSETFIELDSERROR message(s) will have been posted on error.
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::SetNetworkFields()
{
    int i;
    BOOL bSelectDefault = (m_DlgMode == EWSDlgAdd) ||
                          (m_DlgMode == EWSDlgCopy) ||
                          (m_WSConfig.Pd[0].Params.Network.LanAdapter == -1);
    CComboBox *pLanAdapter = (CComboBox *)GetDlgItem(IDC_NETWORK_LANADAPTER);

    /*
     * Set InstanceCount field and limit text.
     */
    SetupInstanceCount(IDC_NETWORK_INSTANCECOUNT);
    ((CEdit *)GetDlgItem(IDC_NETWORK_INSTANCECOUNT))
            ->LimitText( INSTANCE_COUNT_DIGIT_MAX );

    /*
     * Set the LANADAPTER combo-box selection.
     */
    for ( i = pLanAdapter->GetCount(); i > 0; i-- ) {

        /*
         * If the current list item has the saved Lan Adapter's number, break
         * from loop to select this list item.
         */
         if ( m_WSConfig.Pd[0].Params.Network.LanAdapter ==
             (LONG)pLanAdapter->GetItemData(i-1) )
            break;
    }

    /*
     * Select a list item only if we found a match or are to
     * set the 'default'.
     */
    if ( (i > 0) || bSelectDefault ) {

        pLanAdapter->SetCurSel(bSelectDefault ? 0 : i-1);
        if ( bSelectDefault )
            m_WSConfig.Pd[0].Params.Network.LanAdapter =
                (LONG)pLanAdapter->GetItemData(0);
        return(TRUE);

    } else {

        PostMessage(WM_EDITSETFIELDSERROR, IDC_NETWORK_LANADAPTER, 0);
        return(FALSE);
    }

}  // end CEditWinStationDlg::SetNetworkFields


/*******************************************************************************
 *
 *  SetNASIFields - CEditWinStationDlg member function: protected operation
 *
 *      Set the contents of the NASI Pd configuration fields.
 *
 *  ENTRY:
 *  EXIT:
 *      TRUE if no errors on field setting; FALSE otherwise.
 *      WM_EDITSETFIELDSERROR message(s) will have been posted on error.
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::SetNASIFields()
{
    CComboBox *pPortName = (CComboBox *)GetDlgItem(IDC_NASI_PORTNAME);

    /*
     * Set edit fields.
     */
    SetDlgItemText(IDC_NASI_USERNAME, m_WSConfig.Pd[0].Params.Nasi.UserName);
    SetDlgItemText(IDC_NASI_PASSWORD, m_WSConfig.Pd[0].Params.Nasi.PassWord);
    SetupInstanceCount(IDC_NASI_INSTANCECOUNT);

    /*
     * Limit edit field lengths.
     */
    ((CEdit *)GetDlgItem(IDC_NASI_USERNAME))->LimitText(NASIUSERNAME_LENGTH);
    ((CEdit *)GetDlgItem(IDC_NASI_PASSWORD))->LimitText(NASIPASSWORD_LENGTH);
    pPortName->LimitText(NASISPECIFICNAME_LENGTH);
    ((CEdit *)GetDlgItem(IDC_NASI_INSTANCECOUNT))->
        LimitText(INSTANCE_COUNT_DIGIT_MAX);

    /*
     * Set the Port Name combo-box selection.  Default to the
     * first item in the list (if any) if no SpecificName (Port Name)
     * is defined.
     */
    if ( !*(m_WSConfig.Pd[0].Params.Nasi.SpecificName) ) {
        pPortName->SetCurSel(0);
    } else {
        pPortName->SetWindowText(m_WSConfig.Pd[0].Params.Nasi.SpecificName);
    }

    return(TRUE);

}  // end CEditWinStationDlg::SetNASIFields


/*******************************************************************************
 *
 *  SetOemTdFields - CEditWinStationDlg member function: protected operation
 *
 *      Set the contents of the Oem Transport Pd configuration fields.
 *
 *  ENTRY:
 *  EXIT:
 *      TRUE if no errors on field setting; FALSE otherwise.
 *      WM_EDITSETFIELDSERROR message(s) will have been posted on error.
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::SetOemTdFields()
{
    BOOL bStatus = TRUE;
    BOOL bSelectDefault = (m_DlgMode == EWSDlgAdd) ||
                          (m_DlgMode == EWSDlgCopy) ||
                          !(*m_WSConfig.Pd[0].Params.OemTd.DeviceName);
    CComboBox *pDevice = (CComboBox *)GetDlgItem(IDC_OEMTD_DEVICENAME);

    /*
     * Set InstanceCount field and limit text.
     */
    SetupInstanceCount(IDC_OEMTD_INSTANCECOUNT);
    ((CEdit *)GetDlgItem(IDC_OEMTD_INSTANCECOUNT))
            ->LimitText( INSTANCE_COUNT_DIGIT_MAX );

    /*
     * Set the DEVICE combo-box selection.
     */
    if ( pDevice->SelectString(-1, m_WSConfig.Pd[0].Params.OemTd.DeviceName) == CB_ERR ) {

        /*
         * Can't select current DeviceName in combo-box.  If this is
         * because we're supposed to select a default device name, select
         * the first device in the list.
         */
        if ( bSelectDefault ) {

            pDevice->SetCurSel(0);

        } else {

            PostMessage(WM_EDITSETFIELDSERROR, IDC_OEMTD_DEVICENAME, 0);
            bStatus = FALSE;
        }
    }

    return(bStatus);

}  // end CEditWinStationDlg::SetOemTdFields


/*******************************************************************************
 *
 *  SetDefaults - CEditWinStationDlg member function: protected operation
 *
 *      Set defaults for current Protocol Configuration.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::SetDefaults()
{
    int i;
    WDCONFIG2 WdConfig;
    CString szText;

    /*
     * Clear out all non-base WinStation Pd structures, and default
     * the instance count if we're not in an auto-add mode.
     */
    for ( i=1; i < MAX_PDCONFIG; i++ )
        memset(&m_WSConfig.Pd[i], 0, sizeof(PDCONFIG));
    if ( !g_Add )
        m_WSConfig.Create.MaxInstanceCount =
            (m_WSConfig.Pd[0].Create.PdFlag & PD_SINGLE_INST) ?
                1 : INSTANCE_COUNT_UNLIMITED;

    /*
     * Fetch the currently selected Wd's config structure.
     */
    GetSelectedWdConfig(&WdConfig);

    /*
     * Copy the Wd information into the WinStation config structure.
     */
    m_WSConfig.Wd = WdConfig.Wd;
    m_WSConfig.Config.User = WdConfig.User;
//  m_WSConfig.Config.Hotkeys = WdConfig.Hotkeys;

    /*
     * Establish default settings for the Pd[0]'s PdParams structure.
     */
    switch ( m_WSConfig.Pd[0].Create.SdClass ) {

        case SdNetwork:
            /*
             * Zeroing the Pd[0].Params.Network structure and setting the
             * LanAdapter field to -1 will set proper defaults.
             */
            memset(&m_WSConfig.Pd[0].Params.Network, 0,
                   sizeof(m_WSConfig.Pd[0].Params.Network));
            m_WSConfig.Pd[0].Params.Network.LanAdapter = -1;
            break;

        case SdNasi:
            /*
             * Zero the Pd[0].Params.Nasi structure, set GlobalSession TRUE,
             * UserName to default, and SessionName to the AppServer name
             * (less the beginning slashes).
             */
            memset(&m_WSConfig.Pd[0].Params.Nasi, 0,
                   sizeof(m_WSConfig.Pd[0].Params.Nasi));
            m_WSConfig.Pd[0].Params.Nasi.GlobalSession = TRUE;
            szText.LoadString(IDS_NASI_DEFAULT_USERNAME);
            lstrcpy(m_WSConfig.Pd[0].Params.Nasi.UserName, szText);
            lstrncpy( m_WSConfig.Pd[0].Params.Nasi.SessionName,
                      &(pApp->m_szCurrentAppServer[2]),
                      NASISESSIONNAME_LENGTH );
            m_WSConfig.Pd[0].Params.Nasi.SessionName[NASISESSIONNAME_LENGTH] =
                TCHAR('\0');

            /*
             * We also establish the PortName list box at this time.
             */
            InitializeNASIPortNames(&(m_WSConfig.Pd[0].Params.Nasi));
            break;

        case SdAsync:
            /*
             * Copy the Async WD configuration information into
             * Pd[0]'s Async structure to establish defaults.
             */
            m_WSConfig.Pd[0].Params.Async = WdConfig.Async;
            break;

        case SdOemTransport:
            /*
             * Zero the Pd[0].Params.OemTd structure to set proper defaults.
             */
            memset(&m_WSConfig.Pd[0].Params.OemTd, 0,
                   sizeof(m_WSConfig.Pd[0].Params.OemTd));
            break;
    }

    /*
     * Set the encryption level to the default for the WD
     */
    EncryptionLevel *pEncryptionLevels = NULL;
    LONG NumEncryptionLevels = 0L;
    BOOL bSet = FALSE;

    // Get the array of encryption levels from the extension DLL
    PTERMLOBJECT pTermObject = GetSelectedWdListObject();
    if(pTermObject && pTermObject->m_hExtensionDLL && pTermObject->m_lpfnExtEncryptionLevels)
        NumEncryptionLevels = (*pTermObject->m_lpfnExtEncryptionLevels)(&WdConfig.Wd.WdName, &pEncryptionLevels);

    if(pEncryptionLevels) {
        // Loop through the encryption levels and look for the default
        for(int i = 0; i < NumEncryptionLevels; i++) {

            // If this is the default encryption level, set the user's
            // encryption level to this one
            if(pEncryptionLevels[i].Flags & ELF_DEFAULT) {
                m_WSConfig.Config.User.MinEncryptionLevel = (UCHAR)pEncryptionLevels[i].RegistryValue;
                bSet = TRUE;
            }
        }

        // If none of the encryption levels was flagged as the default,
        // use the first encryption level as the default.
        if(!bSet) {
            m_WSConfig.Config.User.MinEncryptionLevel = (UCHAR)pEncryptionLevels[0].RegistryValue;
        }

    } else {
        // There aren't any encryption levels
        m_WSConfig.Config.User.MinEncryptionLevel = 0;
    }

    /*
     * Update the Protocol Configuration fields.
     */
    SetConfigurationFields();

}  // end CEditWinStationDlg::SetDefaults


/*******************************************************************************
 *
 *  GetConfigurationFields -
 *                  CEditWinStationDlg member function: protected operation
 *
 *      Fetch the configuration field contents and validate.
 *
 *  ENTRY:
 *  EXIT:
 *      (BOOL) TRUE if the configuration fields were all OK; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::GetConfigurationFields()
{
    /*
     * Fetch the data in the configuration fields.
     */
    switch ( m_WSConfig.Pd[0].Create.SdClass ) {

                case SdNone:
                    break;

                case SdAsync:
                    return(GetAsyncFields());

             case SdNetwork:
                return(GetNetworkFields());

                case SdNasi:
                    return(GetNASIFields());

            case SdOemTransport:
                   return(GetOemTdFields());
    }

    return(TRUE);

}  // end CEditWinStationDlg::GetConfigurationFields


/*******************************************************************************
 *
 *  GetAsyncFields - CEditWinStationDlg member function: protected operation
 *
 *      Fetch and validate the Async configuration field contents.
 *
 *  ENTRY:
 *  EXIT:
 *      (BOOL) TRUE if all of the Async configuration fields were OK;
 *             FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::GetAsyncFields()
{
    /*
     * Fetch the currently selected DEVICENAME string.
     */
    {
    CComboBox *pDeviceName = (CComboBox *)GetDlgItem(IDC_ASYNC_DEVICENAME);
    int index;

    if ( !pDeviceName->GetCount() ||
         ((index = pDeviceName->GetCurSel()) == CB_ERR) ) {

            /*
             * No device is selected.
             */
            ERROR_MESSAGE((IDP_INVALID_DEVICE))
            GotoDlgCtrl(GetDlgItem(IDC_ASYNC_DEVICENAME));
            return(FALSE);

    } else

        OnSelchangeAsyncDevicename();
    }

    /*
     * Get the MODEMCALLBACK phone number (callback state and 'user specified'
     * flags are already gotten).
     */
    GetDlgItemText( IDC_ASYNC_MODEMCALLBACK_PHONENUMBER,
                    m_WSConfig.Config.User.CallbackNumber,
                    lengthof(m_WSConfig.Config.User.CallbackNumber) );

    /*
     * Fetch and convert the BAUDRATE combo-box selection (in it's edit field).
     */
    {
        TCHAR string[ULONG_DIGIT_MAX], *endptr;
        ULONG ul;

        GetDlgItemText(IDC_ASYNC_BAUDRATE, string, lengthof(string));
        ul = lstrtoul( string, &endptr, 10 );

        if ( *endptr != TEXT('\0') ) {

            /*
             * Invalid character in Baud Rate field.
             */
            ERROR_MESSAGE((IDP_INVALID_BAUDRATE))
            GotoDlgCtrl(GetDlgItem(IDC_ASYNC_BAUDRATE));
            return(FALSE);

        } else
            m_WSConfig.Pd[0].Params.Async.BaudRate = ul;
    }

    /*
     * Fetch the CONNECT combo-box selection and set/reset the break
     * disconnect flag.
     */
    if ( (m_WSConfig.Pd[0].Params.Async.Connect.Type = (ASYNCCONNECTCLASS)
          ((CComboBox *)GetDlgItem(IDC_ASYNC_CONNECT))->GetCurSel()) ==
                                                        Connect_FirstChar )
        m_WSConfig.Pd[0].Params.Async.Connect.fEnableBreakDisconnect = 1;
    else
        m_WSConfig.Pd[0].Params.Async.Connect.fEnableBreakDisconnect = 0;

    return(TRUE);

}  // end CEditWinStationDlg::GetAsyncFields


/*******************************************************************************
 *
 *  GetNetworkFields - CEditWinStationDlg member function: protected operation
 *
 *      Fetch and validate the Network configuration field contents.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL) TRUE if all of the Network configuration fields were OK;
 *             FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::GetNetworkFields()
{
    CComboBox *pLanAdapter = (CComboBox *)GetDlgItem(IDC_NETWORK_LANADAPTER);
    int index;

    /*
     * Fetch & validate instance count field.
     */
    if ( !ValidateInstanceCount(IDC_NETWORK_INSTANCECOUNT) )
        return(FALSE);

    /*
     * Fetch the currently selected LANADAPTER string's associated value
     * (ordinal network card #) and save.
     */
    if ( !pLanAdapter->GetCount() ||
         ((index = pLanAdapter->GetCurSel()) == CB_ERR) ) {

            /*
             * No Lan Adapter is selected.
             */
            if ( !pLanAdapter->GetCount() )
                ERROR_MESSAGE((IDP_ERROR_NETWORKDEVICEINIT))
            else
                ERROR_MESSAGE((IDP_INVALID_LANADAPTER))
            GotoDlgCtrl(GetDlgItem(IDC_NETWORK_LANADAPTER));
            return(FALSE);
    } else {
        m_WSConfig.Pd[0].Params.Network.LanAdapter =
            pLanAdapter->GetItemData(index);
    }

    return(TRUE);

}  // end CEditWinStationDlg::GetNetworkFields


/*******************************************************************************
 *
 *  GetNASIFields - CEditWinStationDlg member function: protected operation
 *
 *      Fetch and validate the NASI configuration field contents.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL) TRUE if all of the NASI configuration fields were OK;
 *             FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::GetNASIFields()
{
    /*
     * Fetch & validate UserName field.
     */
    GetDlgItemText( IDC_NASI_USERNAME,
                    m_WSConfig.Pd[0].Params.Nasi.UserName,
                    lengthof(m_WSConfig.Pd[0].Params.Nasi.UserName) );
    if ( !*(m_WSConfig.Pd[0].Params.Nasi.UserName) ) {
        ERROR_MESSAGE((IDP_INVALID_NASI_USERNAME_EMPTY))
        GotoDlgCtrl(GetDlgItem(IDC_NASI_USERNAME));
        return(FALSE);
    }

    /*
     * Fetch & validate Port Name field.
     */
    GetDlgItemText( IDC_NASI_PORTNAME,
                    m_WSConfig.Pd[0].Params.Nasi.SpecificName,
                    lengthof(m_WSConfig.Pd[0].Params.Nasi.SpecificName) );
    if ( !*(m_WSConfig.Pd[0].Params.Nasi.SpecificName) ) {
        ERROR_MESSAGE((IDP_INVALID_NASI_PORTNAME_EMPTY))
        GotoDlgCtrl(GetDlgItem(IDC_NASI_PORTNAME));
        return(FALSE);
    }

    /*
     * Fetch & validate instance count field.
     */
    if ( !ValidateInstanceCount(IDC_NASI_INSTANCECOUNT) )
        return(FALSE);

    /*
     * Fetch Password field.
     */
    GetDlgItemText( IDC_NASI_PASSWORD,
                    m_WSConfig.Pd[0].Params.Nasi.PassWord,
                    lengthof(m_WSConfig.Pd[0].Params.Nasi.PassWord) );

    return(TRUE);

}  // end CEditWinStationDlg::GetNASIFields


/*******************************************************************************
 *
 *  GetOemTdFields - CEditWinStationDlg member function: protected operation
 *
 *      Fetch and validate the Oem Transport configuration field contents.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL) TRUE if all of the Oem Transport configuration fields were OK;
 *             FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::GetOemTdFields()
{
    CComboBox *pDevice = (CComboBox *)GetDlgItem(IDC_OEMTD_DEVICENAME);
    int index;

    /*
     * Fetch & validate instance count field.
     */
    if ( !ValidateInstanceCount(IDC_OEMTD_INSTANCECOUNT) )
        return(FALSE);

    /*
     * Fetch the currently selected DEVICE string.
     */
    if ( !pDevice->GetCount() ||
         ((index = pDevice->GetCurSel()) == CB_ERR) ) {

            /*
             * No Device is selected.
             */
            ERROR_MESSAGE((IDP_INVALID_DEVICE))
            GotoDlgCtrl(GetDlgItem(IDC_OEMTD_DEVICENAME));
            return(FALSE);
    } else {
        pDevice->GetLBText(
                    index,
                    m_WSConfig.Pd[0].Params.OemTd.DeviceName);
    }

    return(TRUE);

}  // end CEditWinStationDlg::GetOemTdFields


/*******************************************************************************
 *
 *  SetupInstanceCount -
 *          CEditWinStationDlg member function: protected operation
 *
 *      Setup the specified instance count controls based on the current
 *      contents of m_WSConfig.Create.MaxInstanceCount.
 *
 *  ENTRY:
 *      nControlId (input)
 *          Control ID of the instance count edit field.  nControlId+1 must
 *          be the control ID of the 'unlimited' checkbox.
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::SetupInstanceCount(int nControlId)
{
    if ( m_WSConfig.Create.MaxInstanceCount == INSTANCE_COUNT_UNLIMITED ) {

        CheckDlgButton( nControlId+1, TRUE );
        SetDlgItemText( nControlId, TEXT("") );
        GetDlgItem(nControlId)->EnableWindow(FALSE);

    } else {

        SetDlgItemInt( nControlId, m_WSConfig.Create.MaxInstanceCount );
        GetDlgItem(nControlId)->EnableWindow( ((m_DlgMode == EWSDlgRename) ||
                                               (m_DlgMode == EWSDlgView)) ?
                                               FALSE : TRUE );
    }

}  // end CEditWinStationDlg::SetupInstanceCount


/*******************************************************************************
 *
 *  ValidateInstanceCount -
 *          CEditWinStationDlg member function: protected operation
 *
 *      Fetch and validate the specified InstanceCount control contents
 *      and save to m_WSConfig.Create.MaxInstanceCount member variable if valid.
 *
 *  ENTRY:
 *      nControlId (input)
 *          Control ID of the instance count edit field.  nControlId+1 must
 *          be the control ID of the 'unlimited' checkbox.
 *  EXIT:
 *      (BOOL) TRUE if instance count is OK; FALSE otherwise (an error message
 *             will have been output).
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::ValidateInstanceCount(int nControlId)
{
    BOOL bTrans, bStatus = TRUE;
    int i;

    /*
     * Fetch & validate instance count field if 'unlimited' checkbox
     * is not checked.
     */
    if ( !((CButton *)GetDlgItem(nControlId+1))->GetCheck() ) {

        i = GetDlgItemInt(nControlId, &bTrans);
        if ( !bTrans ||
             (i < INSTANCE_COUNT_MIN) || (i > INSTANCE_COUNT_MAX) ) {

            /*
             * Invalid instance count.  Display message and return to fix.
             */
            ERROR_MESSAGE((IDP_INVALID_INSTANCECOUNT, INSTANCE_COUNT_MIN, INSTANCE_COUNT_MAX))

            GotoDlgCtrl(GetDlgItem(nControlId));
            bStatus = FALSE;

        } else {

            m_WSConfig.Create.MaxInstanceCount = i;
        }
    }

    return(bStatus);

}  // end CEditWinStationDlg::ValidateInstanceCount


////////////////////////////////////////////////////////////////////////////////
// CEditWinStationDlg message map

BEGIN_MESSAGE_MAP(CEditWinStationDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CEditWinStationDlg)
     ON_BN_CLICKED(IDC_ASYNC_MODEMINSTALL, OnClickedAsyncModeminstall)
    ON_BN_CLICKED(IDC_ASYNC_MODEMCONFIG, OnClickedAsyncModemconfig)
     ON_BN_CLICKED(IDC_ASYNC_MODEMCALLBACK_INHERIT, OnClickedAsyncModemcallbackInherit)
     ON_BN_CLICKED(IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT, OnClickedAsyncModemcallbackPhonenumberInherit)
     ON_BN_CLICKED(IDC_ASYNC_DEFAULTS, OnClickedAsyncDefaults)
     ON_BN_CLICKED(IDC_ASYNC_ADVANCED, OnClickedAsyncAdvanced)
    ON_BN_CLICKED(IDC_ASYNC_TEST, OnClickedAsyncTest)
     ON_BN_CLICKED(IDC_NASI_INSTANCECOUNT_UNLIMITED, OnClickedNasiInstancecountUnlimited)
     ON_BN_CLICKED(IDC_NASI_ADVANCED, OnClickedNasiAdvanced)
     ON_BN_CLICKED(IDC_NETWORK_INSTANCECOUNT_UNLIMITED, OnClickedNetworkInstancecountUnlimited)
     ON_BN_CLICKED(IDC_OEMTD_INSTANCECOUNT_UNLIMITED, OnClickedOemInstancecountUnlimited)
    ON_BN_CLICKED(IDC_ADVANCED_WINSTATION, OnClickedAdvancedWinStation)
    ON_CBN_CLOSEUP(IDC_TDNAME, OnCloseupPdname)
    ON_CBN_SELCHANGE(IDC_TDNAME, OnSelchangePdname)
    ON_CBN_CLOSEUP(IDC_WDNAME, OnCloseupWdname)
    ON_CBN_SELCHANGE(IDC_WDNAME, OnSelchangeWdname)
    ON_CBN_CLOSEUP(IDC_ASYNC_DEVICENAME, OnCloseupAsyncDevicename)
    ON_CBN_SELCHANGE(IDC_ASYNC_DEVICENAME, OnSelchangeAsyncDevicename)
     ON_CBN_CLOSEUP(IDC_ASYNC_MODEMCALLBACK, OnCloseupAsyncModemcallback)
     ON_CBN_SELCHANGE(IDC_ASYNC_MODEMCALLBACK, OnSelchangeAsyncModemcallback)
    ON_CBN_CLOSEUP(IDC_ASYNC_BAUDRATE, OnCloseupAsyncBaudrate)
    ON_CBN_SELCHANGE(IDC_ASYNC_BAUDRATE, OnSelchangeAsyncBaudrate)
    ON_CBN_CLOSEUP(IDC_ASYNC_CONNECT, OnCloseupAsyncConnect)
    ON_CBN_SELCHANGE(IDC_ASYNC_CONNECT, OnSelchangeAsyncConnect)
     ON_CBN_DROPDOWN(IDC_NASI_PORTNAME, OnDropdownNasiPortname)
    ON_MESSAGE(WM_LISTINITERROR, OnListInitError)
    ON_MESSAGE(WM_EDITSETFIELDSERROR, OnSetFieldsError)
     ON_BN_CLICKED(IDC_CLIENT_SETTINGS, OnClickedClientSettings)
    ON_BN_CLICKED(IDC_EXTENSION_BUTTON, OnClickedExtensionButton)
     //}}AFX_MSG_MAP
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////////////////
// CEditWinStationDlg commands

/*******************************************************************************
 *
 *  OnInitDialog - CEditWinStationDlg member function: command (override)
 *
 *      Performs the dialog intialization.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnInitDialog documentation)
 *
 ******************************************************************************/

BOOL
CEditWinStationDlg::OnInitDialog()
{
    int index, count;
    CString string;
    CComboBox *pComboBox;
    POSITION pos;

    /*
     * Call the parent classes' OnInitDialog to perform default dialog
     * initialization.
     */
    CBaseDialog::OnInitDialog();

    /*
     * Load up the fixed string combo boxes.
     */
    pComboBox = (CComboBox *)GetDlgItem(IDC_ASYNC_CONNECT);
    string.LoadString(IDS_CONNECT_CTS);
    pComboBox->AddString(string);
    string.LoadString(IDS_CONNECT_DSR);
    pComboBox->AddString(string);
    string.LoadString(IDS_CONNECT_RI);
    pComboBox->AddString(string);
    string.LoadString(IDS_CONNECT_DCD);
    pComboBox->AddString(string);
    string.LoadString(IDS_CONNECT_FIRST_CHARACTER);
    pComboBox->AddString(string);
    string.LoadString(IDS_CONNECT_ALWAYS);
    pComboBox->AddString(string);

    pComboBox = (CComboBox *)GetDlgItem(IDC_ASYNC_MODEMCALLBACK);
    string.LoadString(IDS_MODEM_CALLBACK_DISABLED);
    pComboBox->AddString(string);
    string.LoadString(IDS_MODEM_CALLBACK_ROVING);
    pComboBox->AddString(string);
    string.LoadString(IDS_MODEM_CALLBACK_FIXED);
    pComboBox->AddString(string);

    /*
     * Initialize the WinStation name field if we're not in 'rename' mode.
     */
    if ( m_DlgMode != EWSDlgRename )
        SetDlgItemText( IDC_WINSTATIONNAME, m_pWSName );

    /*
     * Initialize the Wd list box.
     */
    pComboBox = ((CComboBox *)GetDlgItem(IDC_WDNAME));
    pComboBox->ResetContent();

    for ( count = 0, pos = pApp->m_WdList.GetHeadPosition(); pos != NULL; count++ ) {

        PTERMLOBJECT pObject = (PTERMLOBJECT)pApp->m_WdList.GetNext( pos );

        index = pComboBox->AddString( pObject->m_WdConfig.Wd.WdName );
        pComboBox->SetItemData(index, count);
    }

    /*
     * Set the currently-selected WD.
     */
    if ( pComboBox->SelectString( -1, m_WSConfig.Wd.WdName ) == CB_ERR )
        pComboBox->SetCurSel(0);

    /*
     * Disable the Wd list box and label if only one element is in the list.
     */
    pComboBox->EnableWindow(pComboBox->GetCount() > 1 ? TRUE : FALSE);
    GetDlgItem(IDL_WDNAME)->EnableWindow(pComboBox->GetCount() > 1 ? TRUE : FALSE);

    /*
     * Set all combo boxes to use the 'extended' UI.
     */
    ((CComboBox *)GetDlgItem(IDC_TDNAME))->SetExtendedUI(TRUE);
    ((CComboBox *)GetDlgItem(IDC_WDNAME))->SetExtendedUI(TRUE);
    ((CComboBox *)GetDlgItem(IDC_ASYNC_DEVICENAME))->SetExtendedUI(TRUE);
    ((CComboBox *)GetDlgItem(IDC_ASYNC_BAUDRATE))->SetExtendedUI(TRUE);
    ((CComboBox *)GetDlgItem(IDC_ASYNC_CONNECT))->SetExtendedUI(TRUE);
    ((CComboBox *)GetDlgItem(IDC_NETWORK_LANADAPTER))->SetExtendedUI(TRUE);
    ((CComboBox *)GetDlgItem(IDC_NASI_PORTNAME))->SetExtendedUI(TRUE);

    /*
     * Initialize all other common control contents.
     */
    SetDlgItemText( IDC_WSCOMMENT, m_WSConfig.Config.Comment );

    /*
     * Set the maximum length for the edit controls.
     */
    ((CEdit *)GetDlgItem(IDC_WINSTATIONNAME))
        ->LimitText(WINSTATIONNAME_LENGTH);
    ((CEdit *)GetDlgItem(IDC_WSCOMMENT))
            ->LimitText(WINSTATIONCOMMENT_LENGTH);

    /*
     * Process for current dialog mode.
     */
    if ( m_DlgMode == EWSDlgView ) {

        /*
         * View mode: set the dialog's title to "View WinStation Configuration".
         */
        {
        CString szTitle;

        szTitle.LoadString(IDS_VIEW_WINSTATION);

        SetWindowText(szTitle);
        }

        /*
         * Disable all common dialog controls (and their labels), except for
         * navigation, CANCEL, & HELP buttons.
         */
        GetDlgItem(IDC_WINSTATIONNAME)->EnableWindow(FALSE);
        GetDlgItem(IDL_WINSTATIONNAME)->EnableWindow(FALSE);
        GetDlgItem(IDC_TDNAME)->EnableWindow(FALSE);
        GetDlgItem(IDL_TDNAME)->EnableWindow(FALSE);
        GetDlgItem(IDC_WDNAME)->EnableWindow(FALSE);
        GetDlgItem(IDL_WDNAME)->EnableWindow(FALSE);
        GetDlgItem(IDC_WSCOMMENT)->EnableWindow(FALSE);
        GetDlgItem(IDL_WSCOMMENT)->EnableWindow(FALSE);
        GetDlgItem(IDOK)->EnableWindow(FALSE);

    } else if ( m_DlgMode == EWSDlgEdit ) {

        /*
         * Edit mode: set the dialog's title to "Edit WinStation Configuration".
         */
        {
        CString szTitle;

        szTitle.LoadString(IDS_EDIT_WINSTATION);

        SetWindowText(szTitle);
        }

        /*
         * Disable the WinStationName box and PD & WD combo boxes.
         */
        GetDlgItem(IDC_WINSTATIONNAME)->EnableWindow(FALSE);
        GetDlgItem(IDL_WINSTATIONNAME)->EnableWindow(FALSE);
        GetDlgItem(IDC_TDNAME)->EnableWindow(FALSE);
        GetDlgItem(IDL_TDNAME)->EnableWindow(FALSE);
        GetDlgItem(IDC_WDNAME)->EnableWindow(FALSE);
        GetDlgItem(IDL_WDNAME)->EnableWindow(FALSE);

    } else if ( m_DlgMode == EWSDlgAdd ) {

        /*
         * Add mode: set the dialog's title to "New WinStation".
         */
        {
        CString szTitle;

        szTitle.LoadString(IDS_NEW_WINSTATION);

        SetWindowText(szTitle);
        }

    } else if ( m_DlgMode == EWSDlgCopy ){

        /*
         * Copy mode: set the dialog's title to "Copy of " plus the
         * current WinStation name.
         */
        {
        CString szTitle;

        szTitle.LoadString(IDS_COPY_WINSTATION);

        SetWindowText( szTitle + m_pWSName );
        }

        /*
         * Disable the PD and WD combo boxes.
         */
        GetDlgItem(IDC_TDNAME)->EnableWindow(FALSE);
        GetDlgItem(IDL_TDNAME)->EnableWindow(FALSE);
        GetDlgItem(IDC_WDNAME)->EnableWindow(FALSE);
        GetDlgItem(IDL_WDNAME)->EnableWindow(FALSE);

    } else {

        /*
         * Rename mode: set the dialog's title to "Rename " plus the
         * current WinStation name.
         */
        {
        CString szTitle;

        szTitle.LoadString(IDS_RENAME_WINSTATION);

        SetWindowText( szTitle + m_pWSName );
        }

        /*
         * Disable all common dialog controls (and their labels), except for
         * WinStationName field and navigation, OK, CANCEL, & HELP buttons.
         */
        GetDlgItem(IDC_TDNAME)->EnableWindow(FALSE);
        GetDlgItem(IDL_TDNAME)->EnableWindow(FALSE);
        GetDlgItem(IDC_WDNAME)->EnableWindow(FALSE);
        GetDlgItem(IDL_WDNAME)->EnableWindow(FALSE);
        GetDlgItem(IDC_WSCOMMENT)->EnableWindow(FALSE);
        GetDlgItem(IDL_WSCOMMENT)->EnableWindow(FALSE);
    }

    /*
     * Zero init previous PdConfig and initialize fields.
     */
    memset(&m_PreviousPdConfig, 0, sizeof(m_PreviousPdConfig));

    if ( m_DlgMode != EWSDlgAdd ) {
        PDCONFIG3 PdConfig;

        /*
         * We're not in Add mode, so initialize list boxes for this WinStation's
         * WD and TD and call SetConfigurationFields() to enable/show the proper
         * configuration field controls and initialize them.  We don't call
         * OnSelchangeWdname() as for Add mode, because that will set Pd, Wd,
         * and field defaults, loosing the current settings.
         */
        RefrenceAssociatedLists();
        InitializeTransportComboBox();
        GetSelectedPdConfig(&PdConfig);

        if ( !InitializeLists(&PdConfig) )
            PostMessage(WM_LISTINITERROR, 0, (LPARAM)GetLastError());

        SetConfigurationFields();

         /*
          * Update the extension DLL button based on the selected Wd
          */

         PTERMLOBJECT pObject = GetSelectedWdListObject();
          BOOL bShowButton = FALSE;
         if(pObject && pObject->m_hExtensionDLL) {
             TCHAR string[128];
             if(::LoadString(pObject->m_hExtensionDLL, 100, string, 127)) {
                /*
                 * The button is specified as hidden in the dialog template so
                 * we need to set the text and then show the window.
                 */
                 ((CButton*)GetDlgItem(IDC_EXTENSION_BUTTON))->SetWindowText(string);
                    bShowButton = TRUE;
               }
        }

          ((CButton*)GetDlgItem(IDC_EXTENSION_BUTTON))->ShowWindow(bShowButton);

    } else {

        /*
         * We're in auto-add mode.
         */
         if ( g_Add ) {

            /*
             * Set instance count from command line.
             */
            m_WSConfig.Create.MaxInstanceCount = (int)g_ulCount;

            /*
             * Initialize WdName and PdName to specified wd and transport.
             */
            lstrcpy(m_WSConfig.Wd.WdName, g_szType);
            lstrcpy(m_WSConfig.Pd[0].Create.PdName, g_szTransport);
            OnSelchangeWdname();

            /*
             * Post an IDOK message to cause automatic addition.
             */
            PostMessage(WM_COMMAND, IDOK);

         } else {       // normal add

            /*
             * NULL the PdName to establish the default WD / TD for
             * the new WinStation.
             */
            memset( m_WSConfig.Pd[0].Create.PdName, 0,
                    sizeof(m_WSConfig.Pd[0].Create.PdName) );

            OnSelchangeWdname();
        }
    }

    /*
     * If we're not in batch mode, make our window visible.
     */
    if ( !g_Batch )
        ShowWindow(SW_SHOW);

    /*
     * If we're in Edit mode, set focus to the comment field.
     * Otherwise, let dialog set focus/select first available control.
     */
    if ( m_DlgMode == EWSDlgEdit ) {
        CEdit *pEdit = (CEdit *)GetDlgItem(IDC_WSCOMMENT);

        GotoDlgCtrl(pEdit);
        return(FALSE);

    } else
        return(TRUE);

} // end CEditWinStationDlg::OnInitDialog


/*******************************************************************************
 *
 *  OnClickedAsyncModeminstall - CEditWinStationDlg member function: command
 *
 *      Invoke the UNIMODEM installation dialog.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

#define MODEMINSTALL_ENUM_RETRY_COUNT 5

void CEditWinStationDlg::OnClickedAsyncModeminstall()
{
    pApp->m_bAllowHelp = FALSE;
    CComboBox *pDevice = (CComboBox *)GetDlgItem(IDC_ASYNC_DEVICENAME);

    if ( InstallModem( GetSafeHwnd() ) ) {

        PDCONFIG3 PdConfig;
        int i;
        CWaitCursor wait;

        if ( ((m_DlgMode == EWSDlgAdd) || (m_DlgMode == EWSDlgCopy)) &&
             !*(m_WSConfig.Pd[0].Params.Async.ModemName) ) {

             /*
              * If we're in Add or Copy mode and the currently selected device
              * is not a modem device, zero out the device field before
              * re-initializing the device list so that if the user added a
              * modem to the device it will no longer show up in the list.
              */
             *(m_WSConfig.Pd[0].Params.Async.DeviceName) = TEXT('\0');
        }

        /*
         * Loop up to MODEMINSTALL_ENUM_RETRY_COUNT times till we notice
         * the new TAPI device.
         */
        for ( i = 0; i < MODEMINSTALL_ENUM_RETRY_COUNT; i++ ) {

            m_bAsyncListsInitialized = FALSE;
            GetSelectedPdConfig(&PdConfig);
            InitializeAsyncLists(&PdConfig);

            if ( m_nCurrentMaxTAPILineNumber > m_nPreviousMaxTAPILineNumber ) {

                pDevice->SetCurSel(m_nComboBoxIndexOfLatestTAPIDevice);
                break;

            } else {

                Sleep(1000L);
            }
        }
        pDevice->ShowDropDown(TRUE);
    }

    pApp->m_bAllowHelp = TRUE;

}  // end CEditWinStationDlg::OnClickedAsyncModeminstall


/*******************************************************************************
 *
 *  OnClickedAsyncModemconfig - CEditWinStationDlg member function: command
 *
 *      Invoke the UNIMODEM Config dialog.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnClickedAsyncModemconfig()
{
    pApp->m_bAllowHelp = FALSE;

    if ( !ConfigureModem( m_WSConfig.Pd[0].Params.Async.ModemName,
                          GetSafeHwnd() ) ) {

        ERROR_MESSAGE(( IDP_ERROR_MODEM_PROPERTIES_NOT_AVAILABLE,
                        m_WSConfig.Pd[0].Params.Async.ModemName ));
    }

    pApp->m_bAllowHelp = TRUE;

}  // end CEditWinStationDlg::OnClickedAsyncModemconfig


/*******************************************************************************
 *
 *  OnClickedAsyncModemcallbackInherit -
 *              CEditWinStationDlg member function: command
 *
 *      Handle the 'inherit user config' for modem callback.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnClickedAsyncModemcallbackInherit()
{
    BOOL bChecked = ((CButton *)GetDlgItem(IDC_ASYNC_MODEMCALLBACK_INHERIT))->GetCheck();
    BOOL bEnable = !bChecked &&
                   (m_DlgMode != EWSDlgView) &&
                   (m_DlgMode != EWSDlgRename);

    m_WSConfig.Config.User.fInheritCallback = bChecked;
    GetDlgItem(IDL_ASYNC_MODEMCALLBACK1)->EnableWindow(bEnable);
    GetDlgItem(IDC_ASYNC_MODEMCALLBACK)->EnableWindow(bEnable);

}  // end CEditWinStationDlg::OnClickedAsyncModemcallbackInherit


/*******************************************************************************
 *
 *  OnClickedAsyncModemcallbackPhonenumberInherit -
 *              CEditWinStationDlg member function: command
 *
 *      Handle the 'inherit user config' for modem callback phone number.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnClickedAsyncModemcallbackPhonenumberInherit()
{
    BOOL bChecked = ((CButton *)GetDlgItem(IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT))->GetCheck();
    BOOL bEnable = !bChecked &&
                   (m_DlgMode != EWSDlgView) &&
                   (m_DlgMode != EWSDlgRename);

    m_WSConfig.Config.User.fInheritCallbackNumber = bChecked;
    GetDlgItem(IDL_ASYNC_MODEMCALLBACK_PHONENUMBER)->EnableWindow(bEnable);
    GetDlgItem(IDC_ASYNC_MODEMCALLBACK_PHONENUMBER)->EnableWindow(bEnable);

}  // end CEditWinStationDlg::OnClickedAsyncModemcallbackPhonenumberInherit


/*******************************************************************************
 *
 *  OnClickedAsyncDefaults - CEditWinStationDlg member function: command
 *
 *      Invoke the SetDefaults() member in response to Defaults button click.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void CEditWinStationDlg::OnClickedAsyncDefaults()
{
    SetDefaults();

}  // end CEditWinStationDlg::OnClickedAsyncDefaults


/*******************************************************************************
 *
 *  OnClickedAsyncAdvanced - CEditWinStationDlg member function: command
 *
 *      Invoke the Advanced Async dialog.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void CEditWinStationDlg::OnClickedAsyncAdvanced()
{
    CAdvancedAsyncDlg AADlg;

    /*
     * Initialize the dialog's member variables.
     */
    AADlg.m_Async = m_WSConfig.Pd[0].Params.Async;
    AADlg.m_bReadOnly = (m_DlgMode == EWSDlgView) ||
                        (m_DlgMode == EWSDlgRename) ? TRUE : FALSE;
    AADlg.m_bModem = FALSE;
    AADlg.m_nHexBase = pApp->m_nHexBase;
    AADlg.m_nWdFlag = m_WSConfig.Wd.WdFlag;

    /*
     * Invoke the dialog.
     */
    if ( (AADlg.DoModal() == IDOK) &&
         !AADlg.m_bReadOnly ) {

        /*
         * Fetch the dialog's member variables.
         */
        m_WSConfig.Pd[0].Params.Async = AADlg.m_Async;
        pApp->m_nHexBase = AADlg.m_nHexBase;
    }

}  // end CEditWinStationDlg::OnClickedAsyncAdvanced


/*******************************************************************************
 *
 *  OnClickedAsyncTest - CEditWinStationDlg member function: command
 *
 *      Invoke the Async Test dialog.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnClickedAsyncTest()
{
    CAsyncTestDlg ATDlg;
    WINSTATIONNAME WSName;

    /*
     * Get the current Configuration field data.  Return if invalid data
     * entered (stay in edit dialog to fix the data).
     */
    if ( !GetConfigurationFields() )
        return;

    ATDlg.m_PdConfig0 = m_WSConfig.Pd[0];
    ATDlg.m_PdConfig1 = m_WSConfig.Pd[1];

    if ( m_DlgMode == EWSDlgEdit ) {
        GetDlgItemText(IDC_WINSTATIONNAME, WSName, lengthof(WSName));
        ATDlg.m_pWSName = WSName;
    } else {
        ATDlg.m_pWSName = NULL;
    }

    /*
     * Invoke the dialog.
     */
    ATDlg.DoModal();

}  // end CEditWinStationDlg::OnClickedAsyncTest


/*******************************************************************************
 *
 *  OnClickedNasiInstancecountUnlimited -
 *          CEditWinStationDlg member function: command
 *
 *      Process NASI 'unlimited' checkbox.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnClickedNasiInstancecountUnlimited()
{
    if ( ((CButton *)GetDlgItem(IDC_NASI_INSTANCECOUNT_UNLIMITED))->GetCheck() ) {

        m_WSConfig.Create.MaxInstanceCount = INSTANCE_COUNT_UNLIMITED;
        SetupInstanceCount(IDC_NASI_INSTANCECOUNT);

    } else {

        m_WSConfig.Create.MaxInstanceCount = INSTANCE_COUNT_MIN;
        SetupInstanceCount(IDC_NASI_INSTANCECOUNT);
        GotoDlgCtrl( GetDlgItem(IDC_NASI_INSTANCECOUNT) );
    }

}  // end CEditWinStationDlg::OnClickedNasiInstancecountUnlimited


/*******************************************************************************
 *
 *  OnClickedNetworkInstancecountUnlimited -
 *          CEditWinStationDlg member function: command
 *
 *      Process Network 'unlimited' checkbox.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnClickedNetworkInstancecountUnlimited()
{
    if ( ((CButton *)GetDlgItem(IDC_NETWORK_INSTANCECOUNT_UNLIMITED))->GetCheck() ) {

        m_WSConfig.Create.MaxInstanceCount = INSTANCE_COUNT_UNLIMITED;
        SetupInstanceCount(IDC_NETWORK_INSTANCECOUNT);

    } else {

        m_WSConfig.Create.MaxInstanceCount = INSTANCE_COUNT_MIN;
        SetupInstanceCount(IDC_NETWORK_INSTANCECOUNT);
        GotoDlgCtrl( GetDlgItem(IDC_NETWORK_INSTANCECOUNT) );
    }

}  // end CEditWinStationDlg::OnClickedNetworkInstancecountUnlimited


/*******************************************************************************
 *
 *  OnClickedOemInstancecountUnlimited -
 *          CEditWinStationDlg member function: command
 *
 *      Process Oem Transport 'unlimited' checkbox.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnClickedOemInstancecountUnlimited()
{
    if ( ((CButton *)GetDlgItem(IDC_OEMTD_INSTANCECOUNT_UNLIMITED))->GetCheck() ) {

        m_WSConfig.Create.MaxInstanceCount = INSTANCE_COUNT_UNLIMITED;
        SetupInstanceCount(IDC_OEMTD_INSTANCECOUNT);

    } else {

        m_WSConfig.Create.MaxInstanceCount = INSTANCE_COUNT_MIN;
        SetupInstanceCount(IDC_OEMTD_INSTANCECOUNT);
        GotoDlgCtrl( GetDlgItem(IDC_OEMTD_INSTANCECOUNT) );
    }

}  // end CEditWinStationDlg::OnClickedOemInstancecountUnlimited


/*******************************************************************************
 *
 *  OnClickedNasiAdvanced - CEditWinStationDlg member function: command
 *
 *      Invoke the Advanced NASI dialog.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnClickedNasiAdvanced()
{
    CAdvancedNASIDlg ANDlg;

    /*
     * Initialize the dialog's member variables.
     */
    ANDlg.m_NASIConfig = m_WSConfig.Pd[0].Params.Nasi;
    ANDlg.m_bReadOnly = (m_DlgMode == EWSDlgView) ||
                        (m_DlgMode == EWSDlgRename) ? TRUE : FALSE;

    /*
     * Invoke the dialog.
     */
    if ( (ANDlg.DoModal() == IDOK) &&
         !ANDlg.m_bReadOnly ) {

        /*
         * Fetch the dialog's member variables.
         */
        m_WSConfig.Pd[0].Params.Nasi = ANDlg.m_NASIConfig;
    }

}  // end CEditWinStationDlg::OnClickedNasiAdvanced


/*******************************************************************************
 *
 *  OnClickedAdvancedWinStation - CEditWinStationDlg member function: command
 *
 *      Invoke the AdvancedWinStation dialog.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnClickedAdvancedWinStation()
{
    CAdvancedWinStationDlg AWSDlg;

    /*
     * Initialize the dialog's member variables.
     */
    AWSDlg.m_fEnableWinStation = m_WSConfig.Create.fEnableWinStation;
    AWSDlg.m_UserConfig = m_WSConfig.Config.User;
//  AWSDlg.m_Hotkeys = m_WSConfig.Config.Hotkeys;
    AWSDlg.m_bReadOnly = (m_DlgMode == EWSDlgView) ||
                         (m_DlgMode == EWSDlgRename) ? TRUE : FALSE;
    AWSDlg.m_bSystemConsole = !lstrcmpi( m_pWSName, pApp->m_szSystemConsole ) ?
                              TRUE : FALSE;
    AWSDlg.m_pTermObject = GetSelectedWdListObject();

    /*
     * Invoke the dialog.
     */
    if ( (AWSDlg.DoModal() == IDOK) &&
         !AWSDlg.m_bReadOnly ) {

        /*
         * Copy dialog's member variables back to our local member variables.
         */
        m_WSConfig.Create.fEnableWinStation = AWSDlg.m_fEnableWinStation;
        m_WSConfig.Config.User = AWSDlg.m_UserConfig;
//      m_WSConfig.Config.Hotkeys = AWSDlg.m_Hotkeys;
    }

}  // end CEditWinStationDlg::OnClickedAdvancedWinStation


/*******************************************************************************
 *
 *  OnClickedClientSettings - CEditWinStationDlg member function: command
 *
 *      Invoke the ClientSettings dialog.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnClickedClientSettings()
{
    CClientSettingsDlg CSDlg;

    /*
     * Initialize the dialog's member variables.
     */
    CSDlg.m_UserConfig = m_WSConfig.Config.User;
    CSDlg.m_bReadOnly = (m_DlgMode == EWSDlgView) ||
                        (m_DlgMode == EWSDlgRename) ? TRUE : FALSE;

    PTERMLOBJECT pTermObject = GetSelectedWdListObject();
    CSDlg.m_Capabilities = pTermObject ? pTermObject->m_Capabilities : 0;

    /*
     * Invoke the dialog.
     */
    if ( (CSDlg.DoModal() == IDOK) &&
         !CSDlg.m_bReadOnly ) {

        /*
         * Copy dialog's member variables back to our local member variables.
         */
        m_WSConfig.Config.User = CSDlg.m_UserConfig;
    }

}  // end CEditWinStationDlg::OnClickedClientSettings

/*******************************************************************************
 *
 *  OnClickedExtensionButton - CEditWinStationDlg member function: command
 *
 *      Invoke the Extension dialog.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnClickedExtensionButton()
{
    PTERMLOBJECT pObject = GetSelectedWdListObject();
    if(pObject && pObject->m_hExtensionDLL && pObject->m_lpfnExtDialog) {
        (*pObject->m_lpfnExtDialog)(m_hWnd, m_pExtObject);
    }

}  // end CEditWinStationDlg::OnClickedExtensionButton


/*******************************************************************************
 *
 *  OnCloseupPdname - CEditWinStationDlg member function: command
 *
 *      Invoke OnSelchangePdname() when Transport combo box closes up.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnCloseupPdname()
{
    OnSelchangePdname();

} // end CEditWinStationDlg::OnCloseupPdname


/*******************************************************************************
 *
 *  OnSelcahngePdname - CEditWinStationDlg member function: command
 *
 *      Process new PD (Transport) selection.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnSelchangePdname()
{
    int i;
    WINSTATIONNAME WSName;
    PDCONFIG3 PdConfig;
    PDNAME PdName;
    CComboBox *pTdNameBox = (CComboBox *)GetDlgItem(IDC_TDNAME);
    CWaitCursor Wait;

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if ( pTdNameBox->GetDroppedState() )
        return;

    if ( (i = pTdNameBox->GetCurSel()) != CB_ERR ) {

        /*
         * If the newly selected Pd is the same as the one that is currently
         * selected, ignore this notification.
         */
        pTdNameBox->GetLBText( i, PdName );
        if ( !lstrcmp(PdName, m_WSConfig.Pd[0].Create.PdName) )
            return;

    } else {

        /*
         * No current selection (we're called from OnSelchangeWdname).
         * Select the currently specified PD in the combo-box.  If that fails,
         * select the first in the list.
         */
        if ( pTdNameBox->SelectString(-1, m_WSConfig.Pd[0].Create.PdName) == CB_ERR )
            pTdNameBox->SetCurSel(0);
    }

    /*
     * Fetch the currently selected Protocol's config structure.
     */
    GetSelectedPdConfig(&PdConfig);

    /*
     * Clear out all WinStation Pd structures, then copy the selected PD
     * information into the WinStation config's Pd[0] structure and default
     * the instance count if we're not in auto-add mode.
     */
    for ( i=0; i < MAX_PDCONFIG; i++ )
        memset(&m_WSConfig.Pd[i], 0, sizeof(PDCONFIG));
    m_WSConfig.Pd[0].Create = PdConfig.Data;
    m_WSConfig.Pd[0].Params.SdClass = PdConfig.Data.SdClass;
    if ( !g_Add )
        m_WSConfig.Create.MaxInstanceCount =
            (m_WSConfig.Pd[0].Create.PdFlag & PD_SINGLE_INST) ?
                1 : INSTANCE_COUNT_UNLIMITED;

    /*
     * Initialize the list box(es) that will be used with the selected PD.
     */
    if ( !InitializeLists(&PdConfig) )
        PostMessage(WM_LISTINITERROR, 0, (LPARAM)GetLastError());

    /*
     * Set the default Wd settings for this WinStation.
     */
    SetDefaults();

    /*
     * Process if no name has been entered yet (edit control not 'modified'):
     * If we're a SdNetwork or PdNasi type, default the WinStation name to the
     * WdPrefix plus the PD name.  Otherwise, clear the WinStation name field.
     * Set focus to the name and clear the 'modified' flag before leaving.
     */
    if ( !((CEdit *)GetDlgItem(IDC_WINSTATIONNAME))->GetModify() ) {


        if ( (m_WSConfig.Pd[0].Create.SdClass == SdNetwork) ||
             (m_WSConfig.Pd[0].Create.SdClass == SdNasi) ) {
            PTERMLOBJECT pObject = GetSelectedWdListObject();
            if(pObject) {
                lstrcpy(WSName, pObject->m_WdConfig.Wd.WdPrefix);
                if(WSName[0]) lstrcat(WSName, TEXT("-"));
                lstrcat(WSName, m_WSConfig.Pd[0].Create.PdName);
            }
            else
                lstrcpy(WSName, m_WSConfig.Pd[0].Create.PdName);
        }
        else
            WSName[0] = TCHAR('\0');

        SetDlgItemText(IDC_WINSTATIONNAME, WSName);
        ((CEdit *)GetDlgItem(IDC_WINSTATIONNAME))->SetModify(FALSE);
        GotoDlgCtrl(GetDlgItem(IDC_WINSTATIONNAME));
    }

}  // end CEditWinStationDlg::OnSelchangePdname


/*******************************************************************************
 *
 *  OnCloseupWdname - CEditWinStationDlg member function: command
 *
 *      Invoke OnSelchangeWdname() when Type combo box closes up.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnCloseupWdname()
{
    OnSelchangeWdname();

} // end CEditWinStationDlg::OnCloseupWdname


/*******************************************************************************
 *
 *  OnSelchangeWdname - CEditWinStationDlg member function: command
 *
 *      Process new Wd selection.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnSelchangeWdname()
{
    WDNAME WdName;
    CComboBox *pWdNameBox = (CComboBox *)GetDlgItem(IDC_WDNAME);
    CWaitCursor Wait;

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if ( pWdNameBox->GetDroppedState() )
        return;

    pWdNameBox->GetLBText( pWdNameBox->GetCurSel(), WdName );

    /*
     * Update the extension DLL button based on the selected Wd
     */
    PTERMLOBJECT pObject = GetSelectedWdListObject();
     BOOL bShowButton = FALSE;
    if(pObject && pObject->m_hExtensionDLL) {
        TCHAR string[128];
        if(::LoadString(pObject->m_hExtensionDLL, 100, string, 127)) {
            ((CButton*)GetDlgItem(IDC_EXTENSION_BUTTON))->SetWindowText(string);
               bShowButton = TRUE;
        }
    }

     ((CButton*)GetDlgItem(IDC_EXTENSION_BUTTON))->ShowWindow(bShowButton);

    /*
     * If the newly selected Wd is the same as the one that is currently
     * selected, ignore this notification.
     */
    if ( !lstrcmp(WdName, m_WSConfig.Wd.WdName) )
        return;
#if 0
     /*
      * We need to set the Wd that is associated with this WinStation
      *
      */
     if(pObject && pObject->m_hExtensionDLL && pObject->m_lpfnExtRegQuery) {
          m_pExtObject = (*pObject->m_lpfnExtRegQuery)(m_pWSName);
     } else m_pExtObject = NULL;
#endif
    /*
     * Point to the Td and Pd lists associated with this Wd and
     * (re)initialize the Transport combo-box.
     */
    RefrenceAssociatedLists();
    InitializeTransportComboBox();

    /*
     * Cause no current transport selection so that OnSelchangePdname will
     * not ignore the call (the user may want to configure same transport
     * but different type).
     */
    ((CComboBox *)GetDlgItem(IDC_TDNAME))->SetCurSel(-1);

    /*
     * Set default field contents for the currently configured Pd.
     */
    OnSelchangePdname();

     /*
      * We need to set the Wd that is associated with this WinStation
      *
      */
     if(pObject && pObject->m_hExtensionDLL && pObject->m_lpfnExtRegQuery) {
          PDCONFIG3 PdConfig;
          GetSelectedPdConfig( &PdConfig );
          m_pExtObject = (*pObject->m_lpfnExtRegQuery)(m_pWSName, &m_WSConfig.Pd[0]);
     } else m_pExtObject = NULL;


}  // end CEditWinStationDlg::OnSelchangeWdname


/*******************************************************************************
 *
 *  OnCloseupAsyncDevicename - CEditWinStationDlg member function: command
 *
 *      Invoke OnSelchangeAsyncDevicename() when Device combo box closes up.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnCloseupAsyncDevicename()
{
    OnSelchangeAsyncDevicename();

}  // end CEditWinStationDlg::OnCloseupAsyncDevicename


/*******************************************************************************
 *
 *  OnSelchangeAsyncDevicename - CEditWinStationDlg member function: command
 *
 *      Process new Async Device selection.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnSelchangeAsyncDevicename()
{
    CComboBox *pDevice = (CComboBox *)GetDlgItem(IDC_ASYNC_DEVICENAME);
    BOOL bModemEnableFlag, bDirectEnableFlag;
    int index, nModemCmdShow, nDirectCmdShow;

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if ( pDevice->GetDroppedState() )
        return;

    if ( (index = pDevice->GetCurSel()) != CB_ERR ) {

        TCHAR szDeviceName[DEVICENAME_LENGTH+MODEMNAME_LENGTH+1];

        /*
         * Fetch current selection and parse into device and modem names.
         */
        pDevice->GetLBText(index, szDeviceName);
        ParseDecoratedAsyncDeviceName( szDeviceName,
                                       &(m_WSConfig.Pd[0].Params.Async) );

    }

    /*
     * The SetDefaults, Advanced, and Test buttons and Device Connect
     * and Baud fields are enabled if the configuration is non-modem.
     * Otherwise, the Configure Modem button and modem callback fields
     * are enabled.  (The Install Modems buttons is always enabled).
     */
    if ( (*m_WSConfig.Pd[0].Params.Async.ModemName) ) {

        bModemEnableFlag = ( (m_DlgMode != EWSDlgRename) &&
                             (m_DlgMode != EWSDlgView) ) ?
                                TRUE : FALSE;
        nModemCmdShow = SW_SHOW;
        bDirectEnableFlag = FALSE;
        nDirectCmdShow = SW_HIDE;

    } else {

        bModemEnableFlag = FALSE;
        nModemCmdShow = SW_HIDE;
        bDirectEnableFlag = ( (m_DlgMode != EWSDlgRename) &&
                              (m_DlgMode != EWSDlgView) ) ?
                                TRUE : FALSE;
        nDirectCmdShow = SW_SHOW;

    }

    GetDlgItem(IDC_ASYNC_MODEMCONFIG)->ShowWindow(nModemCmdShow);
    GetDlgItem(IDC_ASYNC_MODEMCONFIG)->EnableWindow(bModemEnableFlag);
    GetDlgItem(IDL_ASYNC_MODEMCALLBACK)->ShowWindow(nModemCmdShow);
    GetDlgItem(IDL_ASYNC_MODEMCALLBACK)->EnableWindow(bModemEnableFlag);
    GetDlgItem(IDL_ASYNC_MODEMCALLBACK1)->ShowWindow(nModemCmdShow);
    GetDlgItem(IDL_ASYNC_MODEMCALLBACK1)->EnableWindow(bModemEnableFlag);
    GetDlgItem(IDC_ASYNC_MODEMCALLBACK)->ShowWindow(nModemCmdShow);
    GetDlgItem(IDC_ASYNC_MODEMCALLBACK)->EnableWindow(bModemEnableFlag);
    GetDlgItem(IDC_ASYNC_MODEMCALLBACK_INHERIT)->ShowWindow(nModemCmdShow);
    GetDlgItem(IDC_ASYNC_MODEMCALLBACK_INHERIT)->EnableWindow(bModemEnableFlag);
    GetDlgItem(IDL_ASYNC_MODEMCALLBACK_PHONENUMBER)->ShowWindow(nModemCmdShow);
    GetDlgItem(IDL_ASYNC_MODEMCALLBACK_PHONENUMBER)->EnableWindow(bModemEnableFlag);
    GetDlgItem(IDC_ASYNC_MODEMCALLBACK_PHONENUMBER)->ShowWindow(nModemCmdShow);
    GetDlgItem(IDC_ASYNC_MODEMCALLBACK_PHONENUMBER)->EnableWindow(bModemEnableFlag);
    GetDlgItem(IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT)->ShowWindow(nModemCmdShow);
    GetDlgItem(IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT)->EnableWindow(bModemEnableFlag);
    GetDlgItem(IDL_ASYNC_CONNECT)->ShowWindow(nDirectCmdShow);
    GetDlgItem(IDL_ASYNC_CONNECT)->EnableWindow(bDirectEnableFlag);
    GetDlgItem(IDC_ASYNC_CONNECT)->ShowWindow(nDirectCmdShow);
    GetDlgItem(IDC_ASYNC_CONNECT)->EnableWindow(bDirectEnableFlag);
    GetDlgItem(IDL_ASYNC_BAUDRATE)->ShowWindow(nDirectCmdShow);
    GetDlgItem(IDL_ASYNC_BAUDRATE)->EnableWindow(bDirectEnableFlag);
    GetDlgItem(IDC_ASYNC_BAUDRATE)->ShowWindow(nDirectCmdShow);
    GetDlgItem(IDC_ASYNC_BAUDRATE)->EnableWindow(bDirectEnableFlag);
    GetDlgItem(IDC_ASYNC_DEFAULTS)->ShowWindow(nDirectCmdShow);
    GetDlgItem(IDC_ASYNC_DEFAULTS)->EnableWindow(bDirectEnableFlag);
    GetDlgItem(IDC_ASYNC_ADVANCED)->ShowWindow(nDirectCmdShow);
    GetDlgItem(IDC_ASYNC_ADVANCED)->EnableWindow(bDirectEnableFlag);
    GetDlgItem(IDC_ASYNC_TEST)->ShowWindow(nDirectCmdShow);
    GetDlgItem(IDC_ASYNC_TEST)->EnableWindow(bDirectEnableFlag);

    /*
     * If this is a modem device, properly set the callback fields.
     */
    if ( (*m_WSConfig.Pd[0].Params.Async.ModemName) ) {

        OnClickedAsyncModemcallbackInherit();
        OnClickedAsyncModemcallbackPhonenumberInherit();
    }

}  // end CEditWinStationDlg::OnSelchangeAsyncDevicename


/*******************************************************************************
 *
 *  OnCloseupAsyncModemcallback - CModemConfigDlg member function: command
 *
 *      Invoke OnSelchangeAsyncModemcallback() when Modem Callback combo box
 *      closes up.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnCloseupAsyncModemcallback()
{
    OnSelchangeAsyncModemcallback();

}  // end CEditWinStationDlg::OnCloseupAsyncModemcallback


/*******************************************************************************
 *
 *  OnSelchangeAsyncModemcallback - CModemConfigDlg member function: command
 *
 *      Process new Modem Callback selection.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnSelchangeAsyncModemcallback()
{
    CComboBox *pCallback = (CComboBox *)GetDlgItem(IDC_ASYNC_MODEMCALLBACK);

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if ( pCallback->GetDroppedState() )
        return;

    /*
     * Fetch current callback selection.
     */
    m_WSConfig.Config.User.Callback = (CALLBACKCLASS)(pCallback->GetCurSel());

}  // end CEditWinStationDlg::OnSelchangeAsyncModemcallback


/*******************************************************************************
 *
 *  OnCloseupAsyncBaudrate - CEditWinStationDlg member function: command
 *
 *      Invoke OnSelchangeAsyncBaudrate() when Baud combo box closes up.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnCloseupAsyncBaudrate()
{
    OnSelchangeAsyncBaudrate();

}  // end CEditWinStationDlg::OnCloseupAsyncBaudrate


/*******************************************************************************
 *
 *  OnSelchangeAsyncBaudrate - CEditWinStationDlg member function: command
 *
 *      Process new Async Baud combo-box selection.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnSelchangeAsyncBaudrate()
{
    CComboBox *pBaud = (CComboBox *)GetDlgItem(IDC_ASYNC_BAUDRATE);
    TCHAR string[ULONG_DIGIT_MAX], *endptr;

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if ( pBaud->GetDroppedState() )
        return;

    GetDlgItemText(IDC_ASYNC_BAUDRATE, string, lengthof(string));
    m_WSConfig.Pd[0].Params.Async.BaudRate = lstrtoul(string, &endptr, 10);

}  // end CEditWinStationDlg::OnSelchangeAsyncBaudrate


/*******************************************************************************
 *
 *  OnCloseupAsyncConnect - CEditWinStationDlg member function: command
 *
 *      Invoke OnSelchangeAsyncConnect() when Connect combo box closes up.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnCloseupAsyncConnect()
{
    OnSelchangeAsyncConnect();

}  // end CEditWinStationDlg::OnCloseupAsyncConnect


/*******************************************************************************
 *
 *  OnSelchangeAsyncConnect - CEditWinStationDlg member function: command
 *
 *      Process new Async Connect combo-box selection.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnSelchangeAsyncConnect()
{
    CComboBox *pConnect = (CComboBox *)GetDlgItem(IDC_ASYNC_CONNECT);

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if ( pConnect->GetDroppedState() )
        return;

    m_WSConfig.Pd[0].Params.Async.Connect.Type =
         (ASYNCCONNECTCLASS)pConnect->GetCurSel();

}  // end CEditWinStationDlg::OnSelchangeAsyncConnect


/*******************************************************************************
 *
 *  OnDropdownNasiPortname - CEditWinStationDlg member function: command
 *
 *      Update the Port Name combo box (if necessary) when it is opened up.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void CEditWinStationDlg::OnDropdownNasiPortname()
{
    CWaitCursor Wait;

    /*
     * We need to retrieve the current UserName, PassWord, and PortName contents
     * (with no validation) in order for InitializeNASIPortNames() to be able
     * to properly determine whether or not the 'input' fields have changed
     * since the last time the function was called.
     *
     * NOTE: be careful if you decide to validate at this point in time, because
     * any error message output to complain about invalid (like empty) fields may
     * mess up the behavior of the dialog (a strange side effect ButchD has
     * noticed in MFC).
     */
    GetDlgItemText( IDC_NASI_USERNAME,
                    m_WSConfig.Pd[0].Params.Nasi.UserName,
                    lengthof(m_WSConfig.Pd[0].Params.Nasi.UserName) );
    GetDlgItemText( IDC_NASI_PASSWORD,
                    m_WSConfig.Pd[0].Params.Nasi.PassWord,
                    lengthof(m_WSConfig.Pd[0].Params.Nasi.PassWord) );
    GetDlgItemText( IDC_NASI_PORTNAME,
                    m_WSConfig.Pd[0].Params.Nasi.SpecificName,
                    lengthof(m_WSConfig.Pd[0].Params.Nasi.SpecificName) );

    /*
     * Now we get to initialize the Port Names (if needed).
     */
    InitializeNASIPortNames(&(m_WSConfig.Pd[0].Params.Nasi));

}  // end CEditWinStationDlg::OnDropdownNasiPortname


/*******************************************************************************
 *
 *  OnOK - CEditWinStationDlg member function: command (override)
 *
 *      Read all control contents back into the WinStation config structure
 *      before closing the dialog.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CEditWinStationDlg::OnOK()
{
    BOOL bOk = FALSE;

    /*
     * Get the current Configuration field data.  Return if invalid data
     * entered (stay in dialog to fix the data).
     */
    if ( !GetConfigurationFields() )
        goto done;

    /*
     * Read common control contents back into the WinStation config structure.
     */
    GetDlgItemText( IDC_WSCOMMENT, m_WSConfig.Config.Comment,
                    lengthof(m_WSConfig.Config.Comment) );

    /*
     * If we're in Add, Copy, or Rename mode, fetch WinStation name from
     * control and validate.
     */
    if ( (m_DlgMode == EWSDlgAdd) ||
         (m_DlgMode == EWSDlgCopy) ||
         (m_DlgMode == EWSDlgRename) ) {

        GetDlgItemText(IDC_WINSTATIONNAME, m_pWSName, lengthof(WINSTATIONNAME));

        /*
         * If no WinStation name has been entered, output error message and
         * reset focus to WinStation name field for correction.
         */
        if ( !*m_pWSName ) {

            ERROR_MESSAGE((IDP_INVALID_WINSTATIONNAME_EMPTY))

            GotoDlgCtrl(GetDlgItem(IDC_WINSTATIONNAME));
            goto done;
        }

        /*
         * The WinStation name cannot begin with a digit.
         */
        if ( _istdigit(*m_pWSName) ) {

            ERROR_MESSAGE((IDP_INVALID_WINSTATIONNAME_DIGIT1))
            GotoDlgCtrl(GetDlgItem(IDC_WINSTATIONNAME));
            goto done;
        }

        /*
         * Validate the WinStation name for invalid characters.
         */
        if ( lstrpbrk(m_pWSName, TEXT(":#.\\/ ")) ) {

            ERROR_MESSAGE((IDP_INVALID_WINSTATIONNAME))
            GotoDlgCtrl(GetDlgItem(IDC_WINSTATIONNAME));
            goto done;
        }

        /*
         * The WinStation cannot be called 'console', which is a reserved name.
         */
        if ( !lstrcmpi(m_pWSName, pApp->m_szSystemConsole) ) {

            ERROR_MESSAGE((IDP_INVALID_WINSTATIONNAME_CONSOLE, pApp->m_szSystemConsole))
            GotoDlgCtrl(GetDlgItem(IDC_WINSTATIONNAME));
            goto done;
        }

        /*
         * Make sure that the specified WinStation name is unique.
         */
        if ( !((CAppServerDoc *)m_pDoc)->IsWSNameUnique(m_pWSName) ) {

            ERROR_MESSAGE((IDP_INVALID_WINSTATIONNAME_NOT_UNIQUE))

            /*
             * Set focus back to the WinStation name field and return
             * (don't allow exit).
             */
            GotoDlgCtrl(GetDlgItem(IDC_WINSTATIONNAME));
            goto done;
        }

    }  // end 'Add, Copy, or Rename name validation' if.

    /*
     * Perform special validation for SdNetwork and SdNasi types.
     */
    if ( (m_WSConfig.Pd[0].Create.SdClass == SdNetwork) ||
         (m_WSConfig.Pd[0].Create.SdClass == SdNasi) ) {
        PWSLOBJECT pWSLObject;

        /*
         * Special SdNetwork check:
         * If this is not a 'rename', make sure that no WinStation(s)
         * already exist with the selected PdName, WdName, and LanAdapter.
         * We don't need to make this check for rename, since the user
         * can't change anything but the name, which has already been
         * validated for uniqueness above.
         */
        if ( (m_WSConfig.Pd[0].Create.SdClass == SdNetwork) &&
             (m_DlgMode != EWSDlgRename) &&
             (pWSLObject =
                ((CAppServerDoc *)m_pDoc)->GetWSLObjectNetworkMatch(
                      m_WSConfig.Pd[0].Create.PdName,
                      m_WSConfig.Wd.WdName,
                      m_WSConfig.Pd[0].Params.Network.LanAdapter )) ) {

            CString sz1;

            /*
             * A WinStation already exists with specified Pd, Wd, and LanAdapter.
             * If we're in Edit mode and the WinStation is actually 'us', then
             * this is no problem.  Otherwise, tell the user of the problem.
             */
            if ( (m_DlgMode != EWSDlgEdit) ||
                 lstrcmpi(m_pWSName, pWSLObject->m_WinStationName) ) {

                /*
                 * Output a message indicating that existing WinStation(s)
                 * are already defined with the current Protocol, Wd,
                 * and LanAdapter; at least one of these must be changed for
                 * new WinStation(s).
                 */
                ERROR_MESSAGE(( IDP_INVALID_NETWORK_WINSTATIONS_ALREADY_EXIST,
                                pWSLObject->m_WinStationName ))

                GotoDlgCtrl(GetDlgItem(IDC_WINSTATIONNAME));
                goto done;
            }
        }

    }  // end 'special validation for SdNetwork and SdNasi types' if

    /*
     * If we're in Add, Copy, or Edit mode, make sure that the non-base PD
     * configuration fields are reset and then fill them with additional
     * PDs if necessary.
     */
    if ( (m_DlgMode == EWSDlgAdd) || (m_DlgMode == EWSDlgCopy) ||
                                     (m_DlgMode == EWSDlgEdit) ) {

        int PdNext;
          UINT i;
        PDCONFIG3 PdConfig, SelectedPdConfig;

        PdNext = 1;

        for ( i=PdNext; i < MAX_PDCONFIG; i++ )
            memset(&m_WSConfig.Pd[i], 0, sizeof(PDCONFIG));

        /*
         * If the selected Wd is an ICA type, process for additional Pds.
         */
        if ( m_WSConfig.Wd.WdFlag & WDF_ICA ) {
            GetSelectedPdConfig(&SelectedPdConfig);

            /*
             * add additonal required PDs
             */
            for ( i=PdNext; i < SelectedPdConfig.RequiredPdCount; i++ ) {
                GetPdConfig( m_pCurrentPdList, SelectedPdConfig.RequiredPds[i], &m_WSConfig, &PdConfig );
                m_WSConfig.Pd[PdNext].Create = PdConfig.Data;
                m_WSConfig.Pd[PdNext].Params.SdClass = PdConfig.Data.SdClass;
                PdNext++;
            }
        }

        /*
         * Special Async handling.
         */
        if ( m_WSConfig.Pd[0].Create.SdClass == SdAsync ) {

            /*
             * Properly set connection driver flag and Cd config
             * structure.
             */
            m_WSConfig.Pd[0].Params.Async.fConnectionDriver =
                *(m_WSConfig.Pd[0].Params.Async.ModemName) ?
                    TRUE : FALSE;

            SetupAsyncCdConfig( &(m_WSConfig.Pd[0].Params.Async),
                                &(m_WSConfig.Cd) );

        }

    }  // end 'Add, Copy, or Edit' Pd configuration set' if

    bOk = TRUE; // all's well

done:
    /*
     * If we're in batch mode and not all's well, post
     * IDCANCEL to cancel this batch operation.
     */
    if ( g_Batch && !bOk )
        PostMessage(WM_COMMAND, IDCANCEL);

    /*
     * If all's well, Call the parent classes' OnOk to complete dialog closing
     * and destruction.
     */
    if ( bOk )
        CBaseDialog::OnOK();

} // end CEditWinStationDlg::OnOk


/*******************************************************************************
 *
 *  OnCancel - CEditWinStationDlg member function: command (override)
 *
 *      Cancel the dialog.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnCancel documentation)
 *
 ******************************************************************************/

void CEditWinStationDlg::OnCancel()
{
    /*
     * Call the parent classes' OnCancel to complete dialog closing
     * and destruction.
     */
    CBaseDialog::OnCancel();

} // end CEditWinStationDlg::OnCancel


/*******************************************************************************
 *
 *  OnListInitError - CEditWinStationDlg member function: command
 *
 *      Handle the list initialization error condition.
 *
 *  ENTRY:
 *      wParam (input)
 *          (not used)
 *      wLparam (input)
 *          contains the DWORD error code from the list initialization attempt
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate error handling complete.
 *
 ******************************************************************************/

LRESULT
CEditWinStationDlg::OnListInitError( WPARAM wParam, LPARAM lParam )
{
    PDCONFIG3 PdConfig;

    GetSelectedPdConfig(&PdConfig);
    HandleListInitError(&PdConfig, (DWORD)lParam);
    return(0);

} // end CEditWinStationDlg::OnListInitError


/*******************************************************************************
 *
 *  OnSetFieldsError - CEditWinStationDlg member function: command
 *
 *      Handle the Protocol Configuration field set error condition.
 *
 *  ENTRY:
 *      wParam (input)
 *          Contains the control ID that was in error during field setting.
 *      wLparam (input)
 *          (not used)
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate error handling complete.
 *
 ******************************************************************************/

LRESULT
CEditWinStationDlg::OnSetFieldsError( WPARAM wParam, LPARAM lParam )
{
    PDCONFIG3 PdConfig;

    GetSelectedPdConfig(&PdConfig);
    HandleSetFieldsError(&PdConfig, wParam);
    return(0);

} // end CEditWinStationDlg::OnSetFieldsError
////////////////////////////////////////////////////////////////////////////////

#define ERROR_PDINIT          \
     {                              \
          bError = TRUE;          \
          goto cleanup;          \
     }

BOOL CEditWinStationDlg::AddNetworkDeviceNameToList(PPDCONFIG3 pPdConfig, CComboBox * pLanAdapter)
{

     TCHAR szDevice[DEVICENAME_LENGTH];
     int length = 0, index = 0,Entry = 0;
     BOOL bError = FALSE;

     //Interface pointer declarations

     TCHAR szProtocol[256];
     INetCfg * pnetCfg = NULL;
     INetCfgClass * pNetCfgClass = NULL;
     INetCfgClass * pNetCfgClassAdapter = NULL;
     INetCfgComponent * pNetCfgComponent = NULL;
     INetCfgComponent * pNetCfgComponentprot = NULL;
     INetCfgComponent * pOwner = NULL;
     IEnumNetCfgComponent * pEnumComponent = NULL;
     INetCfgComponentBindings * pBinding = NULL;
     LPWSTR pDisplayName = NULL;
     DWORD dwCharacteristics;
     ULONG count = 0;
     HRESULT hResult = S_OK;


    /*
     * Check for NetBIOS (PD_LANA) mapping or other mapping.
     */
    if ( !(pPdConfig->Data.PdFlag & PD_LANA) )
     {

        //The First entry will be "All Lan Adapters"
        length = LoadString( AfxGetInstanceHandle( ),
                                         IDS_ALL_LAN_ADAPTERS, szDevice, DEVICENAME_LENGTH );
        ASSERT(length);
        index = pLanAdapter->AddString(szDevice);
        if ( (index != CB_ERR) && (index != CB_ERRSPACE) )
        {
             pLanAdapter->SetItemData( index, Entry);
             Entry++;
        }
        else
             ERROR_PDINIT;

            //include other possibilities
        if(0 == lstrcmpi(pPdConfig->Data.PdName,L"tcp"))
              lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_TCPIP);

        else
            if(0 == lstrcmpi(pPdConfig->Data.PdName,L"netbios"))
               lstrcpy(szProtocol,NETCFG_SERVICE_CID_MS_NETBIOS);

            else
                if(0 == lstrcmpi(pPdConfig->Data.PdName,L"ipx"))
                    lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWIPX);
                else
                    if(0 == lstrcmpi(pPdConfig->Data.PdName,L"spx"))
                        lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWSPX);
                    else
                        return E_INVALIDARG;


        if(S_OK != CoCreateInstance(CLSID_CNetCfg,NULL,CLSCTX_SERVER,IID_INetCfg,(LPVOID *)&pnetCfg))
             ERROR_PDINIT;

        if(pnetCfg)
        {
             hResult = pnetCfg->Initialize(NULL);
             if(FAILED(hResult))
                  ERROR_PDINIT;
             hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NETTRANS ,IID_INetCfgClass,(void **)&pNetCfgClass);
             if(FAILED(hResult))
                  ERROR_PDINIT;
             hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NET ,IID_INetCfgClass,(void **)&pNetCfgClassAdapter);
             if(FAILED(hResult))
                  ERROR_PDINIT;
             hResult = pNetCfgClass->FindComponent(szProtocol,&pNetCfgComponentprot);
             if(FAILED(hResult))
                  ERROR_PDINIT;
             hResult = pNetCfgComponentprot->QueryInterface(IID_INetCfgComponentBindings,(void **)&pBinding);
             if(FAILED(hResult))
                  ERROR_PDINIT;
             hResult = pNetCfgClassAdapter->EnumComponents(&pEnumComponent);
             RELEASEPTR(pNetCfgClassAdapter);
             if(FAILED(hResult))
                  ERROR_PDINIT;
             hResult = S_OK;
             while(TRUE)
             {
                  hResult = pEnumComponent->Next(1,&pNetCfgComponent,&count);
                  if(count == 0 || NULL == pNetCfgComponent)
                       break;

                  hResult = pNetCfgComponent->GetCharacteristics(&dwCharacteristics);
                  if(FAILED(hResult))
                  {
                       RELEASEPTR(pNetCfgComponent);
                       continue;
                  }
                  if(dwCharacteristics & NCF_PHYSICAL)
                  {

                        if(S_OK == pBinding->IsBoundTo(pNetCfgComponent))
                         {
                              hResult = pNetCfgComponent->GetDisplayName(&pDisplayName);
                              if(FAILED(hResult))
                                   ERROR_PDINIT;

                              index = pLanAdapter->AddString(pDisplayName);
                              CoTaskMemFree(pDisplayName);
                              if ( (index != CB_ERR) && (index != CB_ERRSPACE) )
                              {
                                   pLanAdapter->SetItemData( index, Entry);
                                   Entry++;
                              }
                              else
                                  ERROR_PDINIT;

                         }
                    }

                    RELEASEPTR(pNetCfgComponent);
              }
          }
     cleanup:
          if(pnetCfg)
               pnetCfg->Uninitialize();
          RELEASEPTR(pBinding);
          RELEASEPTR(pEnumComponent);
          RELEASEPTR(pNetCfgComponentprot);
          RELEASEPTR(pNetCfgComponent);
          RELEASEPTR(pNetCfgClass);
          RELEASEPTR(pnetCfg);

          if(bError)
          {
             SetLastError(IDP_ERROR_PDINIT);
             return(FALSE);

          }
          else
              return TRUE;
     }
     else
     {

        /*
         * NetBIOS LANA #: see which LanaMap entry corresponds to the specified
         * Lan Adapter.
         */

          //Just use the functionality in Utildll. This seems to remain same on NT5.0 also
          PPDPARAMS pPdParams, pBuffer;
          DEVICENAME szDevice;
          ULONG i, Entries;
          BOOL bResult = 0;
          int index;

          /*
           * Perform the device enumeration.
           */
         if ( (pBuffer = WinEnumerateDevices(
                                   this->GetSafeHwnd(),
                                   pPdConfig,
                                   &Entries,
                                   g_Install ? TRUE : FALSE )) == NULL )
          {
          // Don't report error here - let OnOK handle empty lan adapter selection
          //        SetLastError(IDP_ERROR_NETWORKDEVICEINIT);
          //        return(FALSE);
                 Entries = 0;
          }

          /*
           * Loop to initialize the combo-box.
           */
         for ( i = 0, pPdParams = pBuffer; i < Entries; i++, pPdParams++ ) {

               /*
                * Fetch the Description for this device.
                */
              if(!RegGetNetworkDeviceName(NULL, pPdConfig, pPdParams,
                                             szDevice, DEVICENAME_LENGTH))

                {
                      SetLastError(IDP_ERROR_PDINIT);
                      LocalFree(pBuffer);
                      return(FALSE);
                }
               /*
                * If the device description is not empty ('hidden' device), add the
                * device description and the ordinal value to the Lan Adapter
                * combo-box.
                */

              if ( *szDevice )
               {
                    index = pLanAdapter->AddString(szDevice);
                    if ( (index != CB_ERR) && (index != CB_ERRSPACE) )

                         pLanAdapter->SetItemData( index, pPdParams->Network.LanAdapter );

                    else
                    {
                      SetLastError(IDP_ERROR_PDINIT);
                      LocalFree(pBuffer);
                      return(FALSE);
                    }

               }

          /*
           * Free the enumeration buffer and return success.
           */
          if ( pBuffer )
               LocalFree(pBuffer);
          }

    return TRUE;

     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\helpers.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* helpers.h
*
* WINCFG helper function header file
*
* copyright notice: Copyright 1994, Citrix Systems Inc.
*
* $Author:   thanhl  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\HELPERS.H  $
*  
*     Rev 1.11   15 Jul 1997 17:14:06   thanhl
*  Add support for Required PDs
*  
*     Rev 1.10   27 Jun 1997 15:58:38   butchd
*  Registry changes for Wds/Tds/Pds/Cds
*  
*     Rev 1.9   19 Jun 1997 19:22:18   kurtp
*  update
*  
*     Rev 1.8   28 Feb 1997 17:59:40   butchd
*  update
*  
*     Rev 1.7   24 Sep 1996 16:21:44   butchd
*  update
*
*******************************************************************************/

/* 
 * WINCFG helper function prototypes
 */
BOOL CommandLineHelper( LPTSTR pszCommandLine );
void CommandLineUsage();
long QueryLoggedOnCount(PWINSTATIONNAME pWSName);
int LBInsertInstancedName( LPCTSTR pName, CListBox *pListBox );
int CBInsertInstancedName( LPCTSTR pName, CComboBox *pComboBox );
void ParseRootAndInstance( LPCTSTR pString, LPTSTR pRoot, long *pInstance );
void GetPdConfig( CObList *pPdList,
                  LPCTSTR pPdName,
                  PWINSTATIONCONFIG2 pWSConfig,
                  PPDCONFIG3 pPdConfig );

/* 
 * WINCFG helper function typedefs & defines
 */

// NOTE: the _SWITCH strings must NOT have the ':' at the end; they are used
//       for ParseCommandLine() API as well as the 'options' dialog.  The ':'
//       is placed at the beginning of the _VALUE define (for switches that
//       have values associated).
#define HELP_SWITCH             TEXT("/?")
#define HELP_VALUE              TEXT("")    
#define REGISTRYONLY_SWITCH     TEXT("/regonly")
#define REGISTRYONLY_VALUE      TEXT("")
#define ADD_SWITCH              TEXT("/add")
#define ADD_VALUE               TEXT(":<type>")
#define TRANSPORT_SWITCH        TEXT("/transport")
#define TRANSPORT_VALUE         TEXT(":<transport>")
#define COUNT_SWITCH            TEXT("/count")
#define COUNT_VALUE             TEXT(":#")
#define INSTALL_SWITCH          TEXT("/install")
#define INSTALL_VALUE           TEXT("")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\led.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* led.h
*
* interface of CLed class
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\COMMON\VCS\LED.H  $
*  
*     Rev 1.0   14 Nov 1995 06:40:44   butchd
*  Initial revision.
*
*******************************************************************************/

#ifndef LED_INCLUDED
////////////////////////////////////////////////////////////////////////////////
// CLed class
//
class CLed : public CStatic
{

/*
 * Member variables.
 */
	//{{AFX_DATA(CLed)
	//}}AFX_DATA
private:
    HBRUSH          m_hBrush;
    BOOL            m_bOn;

/* 
 * Implementation.
 */
public:
	CLed( HBRUSH hBrush );

/*
 * Operations.
 */
public:
    void Subclass( CStatic *pStatic );
    void Update(int nOn);
    void Toggle();

/*
 * Message map / commands.
 */
protected:
	//{{AFX_MSG(CLed)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end CLed class interface 
////////////////////////////////////////////////////////////////////////////////
#endif  // LED_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\led.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* led.cpp
*
* implementation of CLed class
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\COMMON\VCS\LED.CPP  $
*  
*     Rev 1.0   14 Nov 1995 06:40:40   butchd
*  Initial revision.
*  
*******************************************************************************/

/*
 * include files
 */
#include "stdafx.h"
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include "led.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// CLed class construction / destruction, implementation

/*******************************************************************************
 *
 *  CLed - CLed constructor
 *
 *  ENTRY:
 *      hBrush (input)
 *          Brush to paint window with.
 *  EXIT:
 *      (Refer to MFC CStatic::CStatic documentation)
 *
 ******************************************************************************/

CLed::CLed( HBRUSH hBrush ) 
    : CStatic(),
      m_hBrush(hBrush)
{
	//{{AFX_DATA_INIT(CLed)
	//}}AFX_DATA_INIT

}  // end CLed::CLed


////////////////////////////////////////////////////////////////////////////////
//  CLed operations

/*******************************************************************************
 *
 *  Subclass - CLed member function: public operation
 *
 *      Subclass the specified object to our special blip object.
 *
 *  ENTRY:
 *      pStatic (input)
 *          Points to CStatic object to subclass.
 *  EXIT:
 *
 ******************************************************************************/

void
CLed::Subclass( CStatic *pStatic )
{
    SubclassWindow(pStatic->m_hWnd);

}  // end CLed::Subclass


/*******************************************************************************
 *
 *  Update - CLed member function: public operation
 *
 *      Update the LED to 'on' or 'off' state.
 *
 *  ENTRY:
 *      nOn (input)
 *          nonzero to set 'on' state; zero for 'off' state.
 *  EXIT:
 *
 ******************************************************************************/

void
CLed::Update( int nOn )
{
    m_bOn = nOn ? TRUE : FALSE;
    InvalidateRect(NULL);
    UpdateWindow();

}  // end CLed::Update


/*******************************************************************************
 *
 *  Toggle - CLed member function: public operation
 *
 *      Toggle the LED's on/off state.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CLed::Toggle()
{
    m_bOn = !m_bOn;
    InvalidateRect(NULL);
    UpdateWindow();

}  // end CLed::Toggle


////////////////////////////////////////////////////////////////////////////////
// CLed message map

BEGIN_MESSAGE_MAP(CLed, CStatic)
	//{{AFX_MSG_MAP(CLed)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////////////////
//  CLed commands


/*******************************************************************************
 *
 *  OnPaint - CLed member function: public operation
 *
 *      Paint the led with its brush for 'on' state.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CWnd::OnPaint documentation)
 *
 ******************************************************************************/

void
CLed::OnPaint() 
{
    RECT rect;
    CPaintDC dc(this);
    CBrush brush;

    GetClientRect(&rect);

#ifdef USING_3DCONTROLS
    (rect.right)--;
    (rect.bottom)--;
    dc.FrameRect( &rect, brush.FromHandle((HBRUSH)GetStockObject(GRAY_BRUSH)) );

    (rect.top)++;
    (rect.left)++;
    (rect.right)++;
    (rect.bottom)++;
    dc.FrameRect( &rect, brush.FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)) );

    (rect.top)++;
    (rect.left)++;
    (rect.right) -= 2;
    (rect.bottom) -= 2;
#else
    dc.FrameRect( &rect, brush.FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)) );
    (rect.top)++;
    (rect.left)++;
    (rect.right)--;
    (rect.bottom)--;
#endif
    dc.FillRect( &rect,
                 brush.FromHandle(
                    m_bOn ?
                        m_hBrush :
                        (HBRUSH)GetStockObject(LTGRAY_BRUSH)) );

}  // end CLed::OnPaint
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\helpers.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* helpers.cpp
*
* WINCFG helper functions
*
* copyright notice: Copyright 1994, Citrix Systems Inc.
*
* $Author:   thanhl  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\HELPERS.CPP  $
*  
*     Rev 1.17   15 Jul 1997 17:08:36   thanhl
*  Add support for Required PDs
*  
*     Rev 1.16   27 Jun 1997 15:58:34   butchd
*  Registry changes for Wds/Tds/Pds/Cds
*  
*     Rev 1.15   19 Jun 1997 19:22:16   kurtp
*  update
*  
*     Rev 1.14   28 Feb 1997 17:59:38   butchd
*  update
*  
*     Rev 1.13   24 Sep 1996 16:21:42   butchd
*  update
*
*******************************************************************************/

/*
 * include files
 */
#include "stdafx.h"
#include "wincfg.h"
#include "optdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CWincfgApp *pApp;
extern "C" LPCTSTR WinUtilsAppName;
extern "C" HWND WinUtilsAppWindow;
extern "C" HINSTANCE WinUtilsAppInstance;

/*
 * Define global variables for command line parsing helper.
 */
USHORT      g_help = FALSE;
USHORT      g_RegistryOnly = FALSE;
USHORT      g_Add = FALSE;
WDNAME      g_szType = { TEXT("") };
PDNAME      g_szTransport = { TEXT("") };
ULONG       g_ulCount = 0;

USHORT  g_Install = FALSE;   // hidden switch to let us know we're invoked by Setup
USHORT  g_Batch = FALSE;     // TRUE if an auto-command was specified;
                             // FALSE otherwise

/*
 *  This is the structure vector to be sent to ParseCommandLine.
 */
TOKMAP tokenmap[] =
{
   /*-------------------------------------------------------------------------
   -- Retail Switches
   -------------------------------------------------------------------------*/
   { HELP_SWITCH,           TMFLAG_OPTIONAL, TMFORM_BOOLEAN,    sizeof(USHORT), &g_help },

   { REGISTRYONLY_SWITCH,   TMFLAG_OPTIONAL, TMFORM_BOOLEAN,    sizeof(USHORT), &g_RegistryOnly },

   { ADD_SWITCH,            TMFLAG_OPTIONAL, TMFORM_STRING,     WDNAME_LENGTH,  g_szType },
   { TRANSPORT_SWITCH,      TMFLAG_OPTIONAL, TMFORM_STRING,     PDNAME_LENGTH,  g_szTransport },
   { COUNT_SWITCH,          TMFLAG_OPTIONAL, TMFORM_ULONG,      sizeof(ULONG),  &g_ulCount },

   /*-------------------------------------------------------------------------
   -- Debug or Hidden switches
   -------------------------------------------------------------------------*/
   { INSTALL_SWITCH,        TMFLAG_OPTIONAL, TMFORM_BOOLEAN,    sizeof(USHORT), &g_Install },

   /*-------------------------------------------------------------------------
   -- POSITIONAL PARAMETERS
   -------------------------------------------------------------------------*/

   /*-------------------------------------------------------------------------
   -- END OF LIST
   -------------------------------------------------------------------------*/
   { NULL, 0, 0, 0, NULL }
};
TOKMAP *ptm = tokenmap;

////////////////////////////////////////////////////////////////////////////////
// helper functions

/*******************************************************************************
 *
 *  CommandLineHelper - helper function
 *
 *      Parse the command line for optional parameters.  This routine will also
 *      handle the request for 'help' and invalid command line parameter.
 *
 *  ENTRY:
 *      pszCommandLine (input)
 *          Points to command line.
 *
 *  EXIT:
 *      (BOOL) TRUE if command line was parsed sucessfully or if internal error
 *              (command line will be ignored).
 *             FALSE if 'help' requested or error on command line (message
 *                  will have been output).
 *
 ******************************************************************************/

BOOL
CommandLineHelper( LPTSTR pszCommandLine )
{
    int rc;
    int argc;
    TCHAR **argv;
    TCHAR szModuleName[DIRECTORY_LENGTH+1];

    /*
     *  Get command line args
     */
    GetModuleFileName( AfxGetInstanceHandle(), szModuleName,
                       lengthof(szModuleName) );
    if ( setargv( szModuleName, pszCommandLine, &argc, &argv ) ) {

        ERROR_MESSAGE((IDP_ERROR_INTERNAL_SETARGV))
        goto done;
    }

    /*
     *  Parse command line args and then free them.
     */
    rc = ParseCommandLine( (argc-1), (argv+1), ptm, 0 );
    freeargv( argv );

    /*
     *  Check for command line errors or help requested
     */
    if ( ((rc != PARSE_FLAG_NO_ERROR) &&
          !(rc & PARSE_FLAG_NO_PARMS))
         || g_help ) {

        if ( rc & PARSE_FLAG_NOT_ENOUGH_MEMORY ) {

            ERROR_MESSAGE((IDP_ERROR_INTERNAL_PARSECOMMANDLINE))
            goto done;

        } else {

            CommandLineUsage();
            return(FALSE);
        }
    }

done:
    /*
     * If a batch auto command was specified, set batch flag.
     */
    if ( (g_Add = IsTokenPresent(ptm, ADD_SWITCH)) )
        g_Batch = TRUE;

    /*
     * Set for registry only or full registry & winstation APIs.
     */
    pApp->m_nRegistryOnly = (int)g_RegistryOnly;

    /*
     * If add is defined and no count given, set count to 1.
     */
    if ( g_Add && (g_ulCount == 0) )
        g_ulCount = 1;

    return(TRUE);

}  // end CommandLineHelper


/*******************************************************************************
 *
 *  CommandLineUsage - helper function
 *
 *      Handle the request for 'help' and invalid command line parameter.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CommandLineUsage()
{
    COptionsDlg OPTDlg;

    OPTDlg.DoModal();

}  // end CommandLineUsage


/*******************************************************************************
 *
 *  QueryLoggedOnCount  - helper function
 *
 *      Query the specified WinStation(s) to determine how many users are
 *      currently logged on.
 *
 *  ENTRY:
 *      pWSName (input)
 *          Points to (root) name of WinStation to query.  The query will
 *          match this name with those present in the ICA Server, including
 *          multi-instanced WinStations.
 *  EXIT:
 *      (long) # of users logged onto the specified WinStation(s).
 *
 ******************************************************************************/

long
QueryLoggedOnCount( PWINSTATIONNAME pWSName )
{
    long LoggedOnCount = 0;
#ifdef WINSTA
    ULONG Entries;
    PLOGONID pLogonId;
    TCHAR *p;
    CWaitCursor wait;

    WinStationEnumerate(SERVERNAME_CURRENT, &pLogonId, &Entries);
    if ( pLogonId ) {

        for ( ULONG i = 0; i < Entries; i++ ) {

            /*
             * Check active, connected, and shadowing WinStations, and increment
             * the logged on count if the specified name matches the 'root'
             * name of current winstation.
             */
            if ( (pLogonId[i].State == State_Active) ||
                 (pLogonId[i].State == State_Connected) ||
                 (pLogonId[i].State == State_Shadow) ) {

                if ( (p = lstrchr(pLogonId[i].WinStationName, TEXT('#'))) )
                    *p = TEXT('\0');

                if ( !lstrcmpi(pWSName, pLogonId[i].WinStationName) )
                    LoggedOnCount++;
            }
        }

        WinStationFreeMemory(pLogonId);
    }
#endif // WINSTA

    /*
     * Return the logged-on count.
     */
    return(LoggedOnCount);

}  // end QueryLoggedOnCount


/*******************************************************************************
 *
 *  LBInsertInstancedName - helper function
 *
 *      Insert the specified 'instanced' name into the specified list box,
 *      using a special sort based on the 'root' name and 'instance' count.
 *
 *  ENTRY:
 *      pName (input)
 *          Pointer to name string to insert.
 *      pListBox (input)
 *          Pointer to CListBox object to insert name string into.
 *
 *  EXIT:
 *      (int) List box list index of name after insertion, or error code.
 *
 ******************************************************************************/

int
LBInsertInstancedName( LPCTSTR pName,
                       CListBox *pListBox )
{
    int i, count, result;
    TCHAR NameRoot[64], ListRoot[64];
    CString ListString;
    long NameInstance, ListInstance;

    /*
     * Form the root and instance for this name
     */
    ParseRootAndInstance( pName, NameRoot, &NameInstance );

    /*
     * Traverse list box to perform insert.
     */
    for ( i = 0, count = pListBox->GetCount(); i < count; i++ ) {

        /*
         * Fetch current list box string.
         */
        pListBox->GetText( i, ListString );
    
        /*
         * Parse the root and instance of the list box string.
         */
        ParseRootAndInstance( ListString, ListRoot, &ListInstance );

        /*
         * If the list box string's root is greater than the our name string's
         * root, or the root strings are the same but the list instance is
         * greater than the name string's instance, the name string belongs
         * at the current instance: insert it there.
         */
        if ( ((result = lstrcmpi( ListRoot, NameRoot )) > 0) ||
             ((result == 0) && (ListInstance > NameInstance)) )
            return( pListBox->InsertString( i, pName ) );
    }

    /*
     * Insert this name at the end of the list.
     */
    return( pListBox->InsertString( -1, pName ) );

}  // end LBInsertInstancedName


/*******************************************************************************
 *
 *  CBInsertInstancedName - helper function
 *
 *      Insert the specified 'instanced' name into the specified combo box,
 *      using a special sort based on the 'root' name and 'instance' count.
 *
 *  ENTRY:
 *      pName (input)
 *          Pointer to name string to insert.
 *      pComboBox (input)
 *          Pointer to CComboBox object to insert name string into.
 *
 *  EXIT:
 *      (int) Combo box list index of name after insertion, or error code.
 *
 ******************************************************************************/

int
CBInsertInstancedName( LPCTSTR pName,
                       CComboBox *pComboBox )
{
    int i, count, result;
    TCHAR NameRoot[64], ListRoot[64];
    CString ListString;
    long NameInstance, ListInstance;

    /*
     * Form the root and instance for this name
     */
    ParseRootAndInstance( pName, NameRoot, &NameInstance );

    /*
     * Traverse combo box to perform insert.
     */
    for ( i = 0, count = pComboBox->GetCount(); i < count; i++ ) {

        /*
         * Fetch current combo (list) box string.
         */
        pComboBox->GetLBText( i, ListString );
    
        /*
         * Parse the root and instance of the list box string.
         */
        ParseRootAndInstance( ListString, ListRoot, &ListInstance );

        /*
         * If the list box string's root is greater than the our name string's
         * root, or the root strings are the same but the list instance is
         * greater than the name string's instance, or the root strings are
         * the same and the instances are the same but the entire list string
         * is greater than the entire name string, the name string belongs
         * at the current list position: insert it there.
         */
        if ( ((result = lstrcmpi( ListRoot, NameRoot )) > 0) ||
             ((result == 0) &&
              (ListInstance > NameInstance)) ||
             ((result == 0) &&
              (ListInstance == NameInstance) &&
              (lstrcmpi(ListString, pName) > 0)) )
            return( pComboBox->InsertString( i, pName ) );
    }

    /*
     * Insert this name at the end of the list.
     */
    return( pComboBox->InsertString( -1, pName ) );

}  // end CBInsertInstancedName


/*******************************************************************************
 *
 *  ParseRootAndInstance - helper function
 *
 *      Parse the 'root' string and instance count for a specified string.
 *
 *  ENTRY:
 *      pString (input)
 *          Points to the string to parse.
 *      pRoot (output)
 *          Points to the buffer to store the parsed 'root' string.
 *      pInstance (output)
 *          Points to the int variable to store the parsed instance count.
 *
 *  EXIT:
 *      ParseRootAndInstance will parse only up to the first blank character
 *      of the string (if a blank exists).
 *      If the string contains no 'instance' count (no trailing digits), the
 *      pInstance variable will contain -1.  If the string consists entirely
 *      of digits, the pInstance variable will contain the conversion of those
 *      digits and pRoot will contain a null string.
 *
 ******************************************************************************/

void
ParseRootAndInstance( LPCTSTR pString,
                      LPTSTR pRoot,
                      long *pInstance )
{
    LPCTSTR end, p;
    TCHAR szString[256];

    /*
     * Make a copy of the string and terminate at first blank (if present).
     */
    lstrncpy(szString, pString, lengthof(szString));
    szString[lengthof(szString)-1] = TEXT('\0');
    lstrtok(szString, TEXT(" "));
    p = &(szString[lstrlen(szString)-1]);

    /*
     * Parse the instance portion of the string.
     */
    end = p;
    while( (p >= szString) && islstrdigit(*p) )
        p--;

    if ( p == end ) {

        /*
         * No trailing digits: indicate no 'instance' and make the 'root'
         * the whole string.
         */
        *pInstance = -1;
        lstrcpy( pRoot, szString );

    } else {

        /*
         * Trailing digits found (or entire string was digits): calculate
         * 'instance' and copy the 'root' string (null if all digits).
         */
        end = p;
        *pInstance = (int)lstrtol( p+1, NULL, 10 );

        /*
         * Copy 'root' string.
         */
        for ( p = szString; p <= end; pRoot++, p++ )
            *pRoot = *p;

        /* 
         * Terminate 'root' string.
         */
        *pRoot = TEXT('\0');
    }

}  // end ParseRootAndInstance


/*******************************************************************************
 *
 *  GetPdConfig - helper function
 *
 *      Read the PD config structure associated with the first PD in the PdList
 *      of the specified PD class.
 *
 *  ENTRY:
 *      pPdList (input)
 *          Points to the Pd list for selected Wd type.
 *      PdName (input)
 *          Specifies the Pd name to look for.
 *      pWSConfig (input)
 *          Pointer to WINSTATIONCONFIG2 structure to reference for Pd[0]
 *          framing type (if SdClass == SdFrame).  Can be NULL if SdClass
 *          != SdFrame.
 *      pPdConfig (output)
 *          Pointer to PDCONFIG3 structure to fill.
 *  EXIT:
 *      nothing
 *
 ******************************************************************************/

void
GetPdConfig( CObList *pPdList,
             LPCTSTR PdName,
             PWINSTATIONCONFIG2 pWSConfig,
             PPDCONFIG3 pPdConfig )
{
    POSITION pos;
    PPDLOBJECT pObject;
    BOOL bFound = FALSE;


    /*
     * Traverse the PD list and obtain the specified Pd's key string for query.
     */
    for ( pos = pPdList->GetHeadPosition(); pos != NULL; ) {

        pObject = (PPDLOBJECT)pPdList->GetNext(pos);

        if ( !lstrcmp(pObject->m_PdConfig.Data.PdName, PdName ) ) {
            bFound = TRUE;
            break;
        }
    }

    if ( bFound )
        *pPdConfig = pObject->m_PdConfig;

}  // end GetPdConfig
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\mainfrm.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* mainfrm.h
*
* interface of CMainFrame class
*
* copyright notice: Copyright 1996, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\MAINFRM.H  $
*  
*     Rev 1.3   27 Sep 1996 17:52:32   butchd
*  update
*
*******************************************************************************/

////////////////////////////////////////////////////////////////////////////////
// CMainFrame class
//
class CMainFrame : public CFrameWnd
{
    DECLARE_DYNCREATE(CMainFrame)

/*
 * Member variables.
 */
public:

/*
 * Implementation
 */
public:
    CMainFrame();
    virtual ~CMainFrame();

/*
 * Debug diagnostics
 */
#ifdef _DEBUG
public:
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

/*
 * Overrides of MFC CFrameWnd class
 */
public:
    void ActivateFrame(int nCmdShow);

/*
 * Message map / functions
 */
protected:
    //{{AFX_MSG(CMainFrame)
   // afx_msg void OnClose();
    afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
    afx_msg void OnSysCommand(UINT nId, LPARAM lParam);
    afx_msg void OnUpdateAppExit(CCmdUI* pCmdUI);
    afx_msg LRESULT OnAddWinstation(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  // end CMainFrame class declaration
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\rescom.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* resource.h
*
* WINUTILS commmon resource file defines
*
*   Note: resource.h and common.rc are not intended to be RC compiled by this
*         tree but will be included by the WINUTILS apps which will use
*         COMMON.LIB.
*
* copyright notice: Copyright 1996, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\COMMON\VCS\RESOURCE.H  $
*  
*     Rev 1.10   20 Sep 1996 20:35:42   butchd
*  update
*
*******************************************************************************/

//#define IDS_TOO_MANY_ROWS               0x4000

#ifndef IDS_BASEWIZ_BACK
#define IDS_BASEWIZ_BACK                0x4001
#define IDS_BASEWIZ_NEXT                0x4002
#define IDS_BASEWIZ_FINISH              0x4003
#define IDS_BASEPROP_OK                 0x4004
#define IDS_BASEPROP_CANCEL             0x4005
#define IDS_BASEPROP_APPLY              0x4006
#define IDS_BASEPROP_HELP               0x4007
#define IDS_BASEPROP_CLOSE              0x4008
#endif

#ifndef IDP_CONFIRM_SHEET_CLOSE
#define IDP_CONFIRM_SHEET_CLOSE         0x4100
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\optdlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* optdlg.h
*
* interface of COptionsDlg class
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $ Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\OPTDLG.H  $
*  
*     Rev 1.0   16 Nov 1995 17:20:56   butchd
*  Initial revision.
*
*******************************************************************************/

/*
 * include files (base dialog)
 */
#include "basedlg.h"

#ifndef OPTDLG_INCLUDED
////////////////////////////////////////////////////////////////////////////////
// COptionsDlg class
//
class COptionsDlg : public CBaseDialog
{

/*
 * Member variables.
 */
	//{{AFX_DATA(COptionsDlg)
	enum { IDD = IDD_OPTDLG };
	//}}AFX_DATA

/* 
 * Implementation.
 */
public:
	COptionsDlg();

/*
 * Operations.
 */
public:

/*
 * Message map / commands.
 */
protected:
	//{{AFX_MSG(COptionsDlg)
    virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end COptionsDlg class interface 
////////////////////////////////////////////////////////////////////////////////
#define OPTDLG_INCLUDED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\optdlg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* optdlg.cpp
*
* implementation of COptionsDlg class
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $ Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\OPTDLG.CPP  $
*  
*     Rev 1.2   24 Sep 1996 16:21:50   butchd
*  update
*  
*     Rev 1.1   29 Nov 1995 14:00:48   butchd
*  update
*  
*     Rev 1.0   16 Nov 1995 17:20:50   butchd
*  Initial revision.
*  
*******************************************************************************/

/*
 * include files
 */
#include "stdafx.h"
#include "wincfg.h"
#include "optdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// COptionsDlg class construction / destruction, implementation

/*******************************************************************************
 *
 *  COptionsDlg - COptionsDlg constructor
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CDialog::CDialog documentation)
 *
 ******************************************************************************/

COptionsDlg::COptionsDlg()
    : CBaseDialog(COptionsDlg::IDD)
{
	//{{AFX_DATA_INIT(COptionsDlg)
	//}}AFX_DATA_INIT
}

////////////////////////////////////////////////////////////////////////////////
// COptionsDlg message map

BEGIN_MESSAGE_MAP(COptionsDlg, CBaseDialog)
	//{{AFX_MSG_MAP(COptionsDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////////////////
//  COptionsDlg commands

/*******************************************************************************
 *
 *  OnInitDialog - COptionsDlg member function: command (override)
 *
 *      Performs the dialog intialization.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnInitDialog documentation)
 *
 ******************************************************************************/

BOOL
COptionsDlg::OnInitDialog()
{
    CString szString;
    TCHAR   szFormat[128], szBuffer[128];

    /*
     * Call the parent classes' OnInitDialog to perform default dialog
     * initialization.
     */    
    CBaseDialog::OnInitDialog();

    /*
     * Set the dialog title.
     */    
    GetWindowText(szString);
    szString += AfxGetAppName();
    SetWindowText(szString);

    /*
     * Set the command line switch and description text.
     */
    GetDlgItemText(IDL_OPTDLG_HELP_SWITCH, szFormat, lengthof(szFormat));
    wsprintf(szBuffer, szFormat, HELP_SWITCH, HELP_VALUE);
    SetDlgItemText(IDL_OPTDLG_HELP_SWITCH, szBuffer);

    GetDlgItemText(IDL_OPTDLG_REGISTRYONLY_SWITCH, szFormat, lengthof(szFormat));
    wsprintf(szBuffer, szFormat, REGISTRYONLY_SWITCH, REGISTRYONLY_VALUE);
    SetDlgItemText(IDL_OPTDLG_REGISTRYONLY_SWITCH, szBuffer);

    GetDlgItemText(IDL_OPTDLG_ADD_SWITCH, szFormat, lengthof(szFormat));
    wsprintf(szBuffer, szFormat, ADD_SWITCH, ADD_VALUE);
    SetDlgItemText(IDL_OPTDLG_ADD_SWITCH, szBuffer);

    GetDlgItemText(IDL_OPTDLG_COUNT_SWITCH, szFormat, lengthof(szFormat));
    wsprintf(szBuffer, szFormat, COUNT_SWITCH, COUNT_VALUE);
    SetDlgItemText(IDL_OPTDLG_COUNT_SWITCH, szBuffer);

    return ( TRUE );

}  // end COptionsDlg::OnInitDialog
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\resource.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wincfg.rc
//
#define IDR_MAINFRAME                   2
#define IDS_SYSTEM_CONSOLE_NAME         3
#define IDR_APPSERVER                   5
#define IDS_WSINUSE_1USER               6
#define IDS_WSINUSE_NUSERS              7
#define IDS_HEADER_TRANSPORTNAME        18
#define IDS_HEADER_WINSTATIONNAME       19
#define IDS_HEADER_TYPENAME             20
#define IDS_HEADER_COMMENT              21
#define IDS_RENAME_WINSTATION           22
#define IDS_COPY_WINSTATION             23
#define IDS_NEW_WINSTATION              24
#define IDS_READONLY                    25
#define IDS_EDIT_WINSTATION             26
#define IDS_VIEW_WINSTATION             27
#define IDS_PERMS_SPECIAL_QUERY         32
#define IDS_PERMS_SPECIAL_SET           33
#define IDS_PERMS_SPECIAL_RESET         34
#define IDS_PERMS_SPECIAL_SHADOW        36
#define IDS_PERMS_SPECIAL_LOGON         37
#define IDS_PERMS_SPECIAL_LOGOFF        38
#define IDS_PERMS_SPECIAL_MSG           39
#define IDS_PERMS_SPECIAL_CONNECT       40
#define IDS_PERMS_SPECIAL_DISCONNECT    41
#define IDS_PERMS_SPECIAL_DELETE        42
#define IDS_WINSTATION                  48
#define IDS_SPECIALACCESS               49
#define IDS_PERMS_RESOURCE_NOACCESS     50
#define IDS_PERMS_RESORUCE_GUEST        51
#define IDS_PERMS_RESORUCE_USER         52
#define IDS_PERMS_RESOURCE_ADMIN        53
#define IDS_NASI_DEFAULT_USERNAME       54
#define IDS_AWS_SECURITY_ENCRYPT_NO     60
#define IDS_AWS_SECURITY_ENCRYPT_LEVEL1 61
#define IDS_AWS_SECURITY_ENCRYPT_LEVEL2 62
#define IDS_AWS_SECURITY_ENCRYPT_LEVEL3 63
#define IDS_AWS_BROKEN_DISCONNECT       66
#define IDS_AWS_BROKEN_RESET            67
#define IDS_AWS_RECONNECT_FROM_ANY      68
#define IDS_AWS_RECONNECT_FROM_THIS     69
#define IDS_AWS_SHADOW_DISABLED         70
#define IDS_AWS_SHADOW_ENABLED_ON_ON    71
#define IDS_AWS_SHADOW_ENABLED_ON_OFF   72
#define IDS_AWS_SHADOW_ENABLED_OFF_ON   73
#define IDS_AWS_SHADOW_ENABLED_OFF_OFF  74
#define IDS_ASYNC_ADVANCED_HWRX_NOTHING 76
#define IDS_ASYNC_ADVANCED_HWRX_TURN_OFF_RTS 77
#define IDS_ASYNC_ADVANCED_HWRX_TURN_OFF_DTR 78
#define IDS_ASYNC_ADVANCED_HWTX_ALWAYS  79
#define IDS_ASYNC_ADVANCED_HWTX_WHEN_CTS_IS_ON 80
#define IDS_ASYNC_ADVANCED_HWTX_WHEN_DSR_IS_ON 81
#define IDS_CONNECT_CTS                 82
#define IDS_CONNECT_DSR                 83
#define IDS_CONNECT_RI                  84
#define IDS_CONNECT_DCD                 85
#define IDS_CONNECT_FIRST_CHARACTER     86
#define IDS_CONNECT_ALWAYS              87
#define IDS_MODEM_CALLBACK_DISABLED     88
#define IDS_MODEM_CALLBACK_ROVING       89
#define IDS_MODEM_CALLBACK_FIXED        90
#define IDS_TOO_MANY_ROWS               91
#define IDR_POPUP                       165
#define IDD_OPTDLG                      200
#define IDL_OPTDLG_HELP_SWITCH          201
#define IDL_OPTDLG_REGISTRYONLY_SWITCH  202
#define IDL_OPTDLG_ADD_SWITCH           203
#define IDL_OPTDLG_COUNT_SWITCH         204
#define IDD_EDIT_WINSTATION             300
#define IDL_WINSTATIONNAME              301
#define IDC_WINSTATIONNAME              302
#define IDL_TDNAME                      304
#define IDC_TDNAME                      305
#define IDL_WDNAME                      306
#define IDC_WDNAME                      307
#define IDL_WSCOMMENT                   308
#define IDC_WSCOMMENT                   309
#define IDC_ADVANCED_WINSTATION         312
#define IDC_CLIENT_SETTINGS             313
#define IDC_EXTENSION_BUTTON            314
#define IDL_ASYNC                       330
#define IDL_ASYNC_DEVICENAME            331
#define IDC_ASYNC_DEVICENAME            332
#define IDC_ASYNC_MODEMINSTALL          333
#define IDC_ASYNC_MODEMCONFIG           334
#define IDL_ASYNC_MODEMCALLBACK         335
#define IDL_ASYNC_MODEMCALLBACK1        336
#define IDC_ASYNC_MODEMCALLBACK         337
#define IDC_ASYNC_MODEMCALLBACK_INHERIT 338
#define IDL_ASYNC_MODEMCALLBACK_PHONENUMBER 339
#define IDC_ASYNC_MODEMCALLBACK_PHONENUMBER 340
#define IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT 341
#define IDL_ASYNC_CONNECT               342
#define IDC_ASYNC_CONNECT               343
#define IDL_ASYNC_BAUDRATE              344
#define IDC_ASYNC_BAUDRATE              345
#define IDC_ASYNC_DEFAULTS              346
#define IDC_ASYNC_ADVANCED              347
#define IDC_ASYNC_TEST                  348
#define IDL_NASI                        350
#define IDL_NASI_USERNAME               351
#define IDC_NASI_USERNAME               352
#define IDL_NASI_PASSWORD               353
#define IDC_NASI_PASSWORD               354
#define IDL_NASI_PORTNAME               355
#define IDC_NASI_PORTNAME               356
#define IDL_NASI_INSTANCECOUNT          357
#define IDC_NASI_INSTANCECOUNT          358
#define IDC_NASI_INSTANCECOUNT_UNLIMITED 359
#define IDC_NASI_ADVANCED               360
#define IDL_NETWORK                     370
#define IDL_NETWORK_LANADAPTER          371
#define IDC_NETWORK_LANADAPTER          372
#define IDL_NETWORK_INSTANCECOUNT       373
#define IDC_NETWORK_INSTANCECOUNT       374
#define IDC_NETWORK_INSTANCECOUNT_UNLIMITED 375
#define IDL_OEMTD                       380
#define IDL_OEMTD_DEVICENAME            381
#define IDC_OEMTD_DEVICENAME            382
#define IDL_OEMTD_INSTANCECOUNT         383
#define IDC_OEMTD_INSTANCECOUNT         384
#define IDC_OEMTD_INSTANCECOUNT_UNLIMITED 385
#define IDD_ADVANCED_WINSTATION         400
#define IDL_AWS_WSSTATE                 401
#define IDC_AWS_WSDISABLED              402
#define IDC_AWS_WSENABLED               403
#define IDL_AWS_TIMEOUTS                404
#define IDL_AWS_CONNECTION              405
#define IDC_AWS_CONNECTION              406
#define IDC_AWS_CONNECTION_NONE         407
#define IDC_AWS_CONNECTION_INHERIT      408
#define IDL_AWS_DISCONNECTION           409
#define IDC_AWS_DISCONNECTION           410
#define IDC_AWS_DISCONNECTION_NONE      411
#define IDC_AWS_DISCONNECTION_INHERIT   412
#define IDL_AWS_IDLE                    413
#define IDC_AWS_IDLE                    414
#define IDC_AWS_IDLE_NONE               415
#define IDC_AWS_IDLE_INHERIT            416
#define IDL_AWS_AUTOLOGON               417
#define IDL_AWS_AUTOLOGON_USERNAME      418
#define IDC_AWS_AUTOLOGON_USERNAME      419
#define IDL_AWS_AUTOLOGON_DOMAIN        420
#define IDC_AWS_AUTOLOGON_DOMAIN        421
#define IDL_AWS_AUTOLOGON_PASSWORD      422
#define IDC_AWS_AUTOLOGON_PASSWORD      423
#define IDL_AWS_AUTOLOGON_CONFIRM_PASSWORD 424
#define IDC_AWS_AUTOLOGON_CONFIRM_PASSWORD 425
#define IDC_AWS_AUTOLOGON_PASSWORD_PROMPT 426
#define IDC_AWS_AUTOLOGON_INHERIT       427
#define IDL_AWS_INITIALPROGRAM          428
#define IDL_AWS_INITIALPROGRAM_COMMANDLINE1 429
#define IDL_AWS_INITIALPROGRAM_COMMANDLINE2 430
#define IDC_AWS_INITIALPROGRAM_COMMANDLINE 431
#define IDL_AWS_INITIALPROGRAM_WORKINGDIRECTORY1 432
#define IDL_AWS_INITIALPROGRAM_WORKINGDIRECTORY2 433
#define IDC_AWS_INITIALPROGRAM_WORKINGDIRECTORY 434
#define IDC_AWS_INITIALPROGRAM_INHERIT  435
#define IDC_AWS_INITIALPROGRAM_PUBLISHEDONLY 436
#define IDL_AWS_SECURITY                437
#define IDL_AWS_SECURITY_ENCRYPT1       438
#define IDC_AWS_SECURITY_ENCRYPT        439
#define IDC_AWS_SECURITY_DEFAULTGINA    440
#define IDL_AWS_USEROVERRIDES           441
#define IDC_AWS_USEROVERRIDE_DISABLEWALLPAPER 442
#define IDL_AWS_BROKEN1                 443
#define IDC_AWS_BROKEN                  444
#define IDL_AWS_BROKEN2                 445
#define IDC_AWS_BROKEN_INHERIT          446
#define IDL_AWS_RECONNECT1              447
#define IDC_AWS_RECONNECT               448
#define IDC_AWS_RECONNECT_INHERIT       449
#define IDL_AWS_SHADOW                  450
#define IDC_AWS_SHADOW                  451
#define IDC_AWS_SHADOW_INHERIT          452
#define IDD_CLIENT_SETTINGS             470
#define IDL_CS_CONNECTION               471
#define IDC_CS_CONNECTION_DRIVES        472
#define IDC_CS_CONNECTION_PRINTERS      473
#define IDC_CS_CONNECTION_FORCEPRTDEF   474
#define IDC_CS_CONNECTION_INHERIT       475
#define IDL_CS_MAPPING                  476
#define IDC_CS_MAPPING_WINDOWSPRINTERS  477
#define IDC_CS_MAPPING_DRIVES           478
#define IDC_CS_MAPPING_COMPORTS         479
#define IDC_CS_MAPPING_DOSLPTS          480
#define IDC_CS_MAPPING_CLIPBOARD        481
#define IDC_CS_MAPPING_AUDIO            482
#define IDD_ASYNC_ADVANCED              500
#define IDL_ASYNC_ADVANCED_FLOWCONTROL  501
#define IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE 502
#define IDC_ASYNC_ADVANCED_FLOWCONTROL_SOFTWARE 503
#define IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE 504
#define IDL_ASYNC_ADVANCED_DTRSTATE     505
#define IDL_ASYNC_ADVANCED_DTRALWAYS    506
#define IDC_ASYNC_ADVANCED_DTROFF       507
#define IDC_ASYNC_ADVANCED_DTRON        508
#define IDL_ASYNC_ADVANCED_RTSSTATE     509
#define IDL_ASYNC_ADVANCED_RTSALWAYS    510
#define IDC_ASYNC_ADVANCED_RTSOFF       511
#define IDC_ASYNC_ADVANCED_RTSON        512
#define IDL_ASYNC_ADVANCED_HARDWARE     513
#define IDC_ASYNC_ADVANCED_HWRX         514
#define IDL_ASYNC_ADVANCED_HWRX         515
#define IDL_ASYNC_ADVANCED_HWTX         516
#define IDC_ASYNC_ADVANCED_HWTX         517
#define IDL_ASYNC_ADVANCED_SOFTWARE     518
#define IDL_ASYNC_ADVANCED_XON          519
#define IDC_ASYNC_ADVANCED_XON          520
#define IDL_ASYNC_ADVANCED_XOFF         521
#define IDC_ASYNC_ADVANCED_XOFF         522
#define IDL_ASYNC_ADVANCED_BASE         523
#define IDC_ASYNC_ADVANCED_BASEDEC      524
#define IDC_ASYNC_ADVANCED_BASEHEX      525
#define IDL_ASYNC_ADVANCED_PARITY       526
#define IDC_ASYNC_ADVANCED_PARITY_NONE  527
#define IDC_ASYNC_ADVANCED_PARITY_EVEN  528
#define IDC_ASYNC_ADVANCED_PARITY_ODD   529
#define IDC_ASYNC_ADVANCED_PARITY_MARK  530
#define IDC_ASYNC_ADVANCED_PARITY_SPACE 531
#define IDL_ASYNC_ADVANCED_STOPBITS     532
#define IDC_ASYNC_ADVANCED_STOPBITS_1   533
#define IDC_ASYNC_ADVANCED_STOPBITS_2   534
#define IDL_ASYNC_ADVANCED_BYTESIZE     535
#define IDC_ASYNC_ADVANCED_BYTESIZE_7   536
#define IDC_ASYNC_ADVANCED_BYTESIZE_8   537
#define IDD_ASYNC_TEST                  620
#define IDC_ATDLG_DTR                   621
#define IDC_ATDLG_RTS                   622
#define IDC_ATDLG_CTS                   623
#define IDC_ATDLG_DSR                   624
#define IDC_ATDLG_DCD                   625
#define IDC_ATDLG_RI                    626
#define IDL_ATDLG_DEVICE                627
#define IDL_ATDLG_BAUD                  628
#define IDC_ATDLG_EDIT                  629
#define IDC_ATDLG_MODEM_INIT            630
#define IDC_ATDLG_MODEM_LISTEN          631
#define IDC_ATDLG_MODEM_DIAL            632
#define IDL_ATDLG_PHONE_NUMBER          633
#define IDC_ATDLG_PHONE_NUMBER          634
#define IDD_NASI_ADVANCED               650
#define IDL_NASI_ADVANCED_SESSIONTYPE   651
#define IDC_NASI_ADVANCED_PRIVATESESSION 652
#define IDC_NASI_ADVANCED_GLOBALSESSION 653
#define IDL_NASI_ADVANCED_FILESERVER    654
#define IDC_NASI_ADVANCED_FILESERVER    655
#define IDL_NASI_ADVANCED_SESSIONNAME   656
#define IDC_NASI_ADVANCED_SESSIONNAME   657
#define IDP_CONFIRM_WINSTATIONDELETE    800
#define IDP_CONFIRM_WINSTATIONDELETE_1USER 801
#define IDP_CONFIRM_WINSTATIONDELETE_NUSERS 802
#define IDP_CONFIRM_WINSTATIONDISABLE   803
#define IDP_CONFIRM_WINSTATIONDISABLE_1USER 804
#define IDP_CONFIRM_WINSTATIONDISABLE_NUSERS 805
#define IDP_CONFIRM_DEVICECHANGED       806
#define IDP_CONFIRM_MODEMCHANGED        807
#define IDP_CONFIRM_ADAPTERCHANGED_1USER 808
#define IDP_CONFIRM_ADAPTERCHANGED_NUSERS 809
#define IDP_CONFIRM_ASYNCTESTDISABLE    810
#define IDP_NOTICE_REBOOTFORMODEM_ADD_CAPTION 850
#define IDP_NOTICE_REBOOTFORMODEM_ADD   850
#define IDP_NOTICE_REBOOTFORMODEM_EDIT_CAPTION 851
#define IDP_NOTICE_REBOOTFORMODEM_EDIT  851
#define IDP_NOTICE_REBOOTFORMODEM_DELETE 852
#define IDP_NOTICE_REBOOTFORMODEM_DISABLE 853
#define IDP_NOTICE_REBOOTFORMODEM_ENABLE 853
#define IDP_NOTICE_REBOOTFORMODEM_RENAME 854
#define IDP_NOTICE_WSINUSE_1USER        856
#define IDP_NOTICE_WSINUSE_NUSERS       857
#define IDP_INVALID_DEVICE              900
#define IDP_INVALID_LANADAPTER          901
#define IDP_INVALID_INSTANCECOUNT       902
#define IDP_INVALID_BAUDRATE            903
#define IDP_INVALID_XONXOFF             904
#define IDP_INVALID_IDLETIMEOUT         905
#define IDP_INVALID_WINSTATIONNAME_NOT_UNIQUE 906
#define IDP_INVALID_WINSTATIONNAME_EMPTY 907
#define IDP_INVALID_NETWORK_WINSTATIONS_ALREADY_EXIST 908
#define IDP_INVALID_WINSTATIONNAME      909
#define IDP_INVALID_WINSTATIONNAME_DIGIT1 910
#define IDP_INVALID_WINSTATIONNAME_NOT_UNIQUE_NETWORK 912
#define IDP_INVALID_CONNECTIONTIMEOUT   913
#define IDP_INVALID_DISCONNECTIONTIMEOUT 914
#define IDP_INVALID_PASSWORDS_DONT_MATCH 918
#define IDP_INVALID_NASI_SESSIONNAME_EMPTY 919
#define IDP_INVALID_NASI_PORTNAME_EMPTY 920
#define IDP_INVALID_NASI_USERNAME_EMPTY 921
#define IDP_INVALID_WINSTATIONNAME_CONSOLE 922
#define IDP_ERROR_ADDWINSTATION         1001
#define IDP_ERROR_COPYWINSTATION        1002
#define IDP_ERROR_RENAMEWINSTATION      1003
#define IDP_ERROR_EDITWINSTATION        1004
#define IDP_ERROR_DELETEWINSTATION      1005
#define IDP_ERROR_ENABLEWINSTATION      1006
#define IDP_ERROR_DISABLEWINSTATION     1007
#define IDP_ERROR_REFRESHWINSTATIONSTATE 1008
#define IDP_ERROR_QUERYCURRENTWINSTATION 1009
#define IDP_ERROR_WSLISTALLOC           1010
#define IDP_ERROR_REGWINSTATIONQUERY    1011
#define IDP_ERROR_PDINIT                1013
#define IDP_ERROR_ASYNCDEVICEINIT       1014
#define IDP_ERROR_NETWORKDEVICEINIT     1015
#define IDP_ERROR_INVALIDNETBIOSLANA    1016
#define IDP_ERROR_INVALIDASYNCDEVICE    1017
#define IDP_ERROR_INVALIDDEVICE         1017
#define IDP_ERROR_INVALIDNETWORKADAPTER 1018
#define IDP_ERROR_WDLISTALLOC           1019
#define IDP_ERROR_TDLISTALLOC           1020
#define IDP_ERROR_PDLISTALLOC           1021
#define IDP_ERROR_EMPTYWDLIST           1022
#define IDP_ERROR_REGPDQUERY            1027
#define IDP_ERROR_REGWDQUERY            1028
#define IDP_ERROR_DISABLE               1037
#define IDP_ERROR_CANT_OPEN_DEVICE      1044
#define IDP_ERROR_CANT_CREATE_INPUT_THREAD 1045
#define IDP_ERROR_GET_COMM_MODEM_STATUS 1046
#define IDP_ERROR_CANT_INITIALIZE_DEVICE 1047
#define IDP_ERROR_CANT_INITIALIZE_INPUT_THREAD 1050
#define IDP_ERROR_WAIT_FOR_MULTIPLE_OBJECTS 1051
#define IDP_ERROR_GET_OVERLAPPED_RESULT_WRITE 1052
#define IDP_ERROR_WRITE_FILE            1053
#define IDP_ERROR_READ_FILE             1054
#define IDP_ERROR_WAIT_COMM_EVENT       1055
#define IDP_ERROR_GET_OVERLAPPED_RESULT_READ 1056
#define IDP_ERROR_MODEM_SET_INFO        1057
#define IDP_ERROR_MODEM_GET_INIT        1058
#define IDP_ERROR_MODEM_GET_DIAL        1059
#define IDP_ERROR_MODEM_GET_LISTEN      1060
#define IDP_ERROR_COULDNOTFINDPROCEDURE 1061
#define IDP_ERROR_COULDNOTLOADLIBRARY   1062
#define IDP_ERROR_GET_SECURITY_WINSTATION 1063
#define IDP_ERROR_PERMISSIONS_EDITOR_FAILED 1065
#define IDP_ERROR_SET_SECURITY_WINSTATION 1067
#define IDP_ERROR_INTERNAL_SETARGV      1069
#define IDP_ERROR_INTERNAL_PARSECOMMANDLINE 1070
#define IDP_ERROR_OEMTDINIT_CONFIGDLLENUMERATIONFAILURE 1071
#define IDP_ERROR_OEMTDINIT_MISSINGCONFIGDLLENTRYPOINT 1072
#define IDP_ERROR_OEMTDINIT_CANTOPENCONFIGDLL 1073
#define IDP_ERROR_OEMTDINIT_NOCONFIGDLL 1074
#define IDP_ERROR_MODEM_PROPERTIES_NOT_AVAILABLE 1075
#define IDD_CONNECT_SERVER              1076
#define IDC_SERVER_NAME                 1077
#define IDD_HELP_PERMISSIONS_MAIN       10000
#define IDD_HELP_PERMISSIONS_SPECIAL_ACCESS 10001
#define IDD_HELP_PERMISSIONS_ADD_USER   10002
#define IDD_HELP_PERMISSIONS_LOCAL_GROUP 10003
#define IDD_HELP_PERMISSIONS_GLOBAL_GROUP 10004
#define IDD_HELP_PERMISSIONS_FIND_ACCOUNT 10005
#define IDB_ASYNCDD                     20000
#define IDB_ASYNCDE                     20001
#define IDB_ASYNCMD                     20002
#define IDB_ASYNCME                     20003
#define IDB_ASYNCMER                    20004
#define IDB_CONSOLED                    20005
#define IDB_CONSOLEE                    20006
#define IDB_NETWORKD                    20007
#define IDB_NETWORKE                    20008
#define IDB_NASID                       20009
#define IDB_NASIE                       20010
#define IDB_OEMTDD                      20011
#define IDB_OEMTDE                      20012
#define ID_WINSTATION_ADD               32774
#define ID_WINSTATION_NEXT              32775
#define ID_WINSTATION_PREV              32776
#define ID_WINSTATION_DELETE            32777
#define ID_WINSTATION_EDIT              32778
#define ID_WINSTATION_COPY              32779
#define ID_OPTIONS_FONT                 32785
#define ID_OPTIONS_CONFIRM_ON_DELETE    32786
#define ID_OPTIONS_SAVE_SETTINGS_ON_EXIT 32787
#define ID_OPTIONS_CONFIRMATION         32791
#define ID_WINSTATION_RENAME            32792
#define ID_WINSTATION_ENABLE            32794
#define ID_WINSTATION_DISABLE           32795
#define ID_SECURITY_PERMISSIONS         32799
#define ID_HELP_SEARCH_FOR              32815
#define IDS_ALL_LAN_ADAPTERS            32816
#define ID_STATIC                       65535
#define IDS_ERROR_NOT_TS                32817

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        165
#define _APS_NEXT_COMMAND_VALUE         32801
#define _APS_NEXT_CONTROL_VALUE         264
#define _APS_NEXT_SYMED_VALUE           111
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\mainfrm.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* mainfrm.cpp
*
* implementation of CMainFrame class
*
* copyright notice: Copyright 1994, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\MAINFRM.CPP  $
*  
*     Rev 1.5   27 Sep 1996 17:52:30   butchd
*  update
*  
*     Rev 1.4   24 Sep 1996 16:21:46   butchd
*  update
*
*******************************************************************************/

#include "stdafx.h"
#include "wincfg.h"

#include "mainfrm.h"
#include "appsvdoc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CWincfgApp *pApp;

/*
 * Global command line variables.
 */

/////////////////////////////////////////////////////////////////////////////
// CMainFrame class implementation / construction, destruction

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

/*******************************************************************************
 *
 *  CMainFrame - CMainFrame constructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CMainFrame::CMainFrame()
{
}  // end CMainFrame::CMainFrame


/*******************************************************************************
 *
 *  ~CMainFrame - CMainFrame destructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CMainFrame::~CMainFrame()
{
	pApp->Terminate();
}  // end CMainFrame::~CMainFrame



/////////////////////////////////////////////////////////////////////////////
// CMainFrame debug diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CMainFrame Overrides of MFC CFrameWnd class

/*******************************************************************************
 *
 *  ActivateFrame - CMainFrame member function: override
 *
 *      Place and show the main frame window.
 *
 *  ENTRY:
 *      nCmdShow (input)
 *          Default application 'show' state.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CMainFrame::ActivateFrame(int nCmdShow)
{
    if ( g_Batch ) {

        /*
         * Always hide our main window if we're in batch mode.
         */
        ShowWindow(SW_HIDE);

    } else {
    
        if ( pApp->m_Placement.length == -1 ) {

            /*
             * This is the first time that this is called, set the window
             * placement and show state to the previously saved state.
             */
            pApp->m_Placement.length = sizeof(pApp->m_Placement);

            /*
             * If we're in batch mode, make window hidden.
             */
            if ( g_Batch )
                nCmdShow = SW_HIDE;

            /*
             * If we have a previously saved placement state: set it.
             */
            if ( pApp->m_Placement.rcNormalPosition.right != -1 ) {

                if ( nCmdShow != SW_SHOWNORMAL )
                    pApp->m_Placement.showCmd = nCmdShow;
                else
                    nCmdShow = pApp->m_Placement.showCmd;

                SetWindowPlacement(&(pApp->m_Placement));
            }
        }

        /*
         * Perform the parent classes' ActivateFrame().
         */
        CFrameWnd::ActivateFrame(nCmdShow);
    }

}  // end CMainFrame::ActivateFrame


/////////////////////////////////////////////////////////////////////////////
// CMainFrame message map

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    //ON_WM_CLOSE()
    ON_WM_INITMENUPOPUP()
    ON_WM_SYSCOMMAND()
    ON_UPDATE_COMMAND_UI(ID_APP_EXIT, OnUpdateAppExit)
    ON_MESSAGE(WM_ADDWINSTATION, OnAddWinstation)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

/*******************************************************************************
 *
 *  OnClose - CMainFrame member function: command
 *
 *      Save application defaults and clean-up, then perform default
 *      OnClose
 *
 *  ENTRY:
 *  EXIT:
 *      (refer to the CWnd::OnClose documentation)
 *
 ******************************************************************************/
//void
//CMainFrame::OnClose()
//{
    /*
     * Call CWinquery::Terminate member function to save application defaults
     * and clean-up.
     */
  //  pApp->Terminate();
    
    /*
     * Call the default OnClose() member function.
     */
    //CFrameWnd::OnClose();

//}  // end CMainFrame::OnClose


/*******************************************************************************
 *
 *  OnInitMenuPopup - CMainFrame member function: command
 *
 *      When the system control menu is about to be displayed, set the state of
 *      the "close" item to allow or disallow closing the application.
 *
 *  ENTRY:
 *  EXIT:
 *      (refer to the CWnd::OnInitMenuPopup documentation)
 *
 ******************************************************************************/

void
CMainFrame::OnInitMenuPopup( CMenu* pPopupMenu,
                             UINT nIndex,
                             BOOL bSysMenu )
{
    /*
     * Call the parent classes OnInitMenuPopup first.
     */
    CFrameWnd::OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);
    
    /*
     * If this is the system menu, enable or disable the Close menu item based
     * on whether our current document says that we can exit.
     */
    if ( bSysMenu )
        pPopupMenu->EnableMenuItem( SC_CLOSE, MF_BYCOMMAND |
            (((CAppServerDoc *)GetActiveDocument())->IsExitAllowed() ? MF_ENABLED : MF_GRAYED) );
        
}  // end CMainFrame::OnInitMenuPopup


/*******************************************************************************
 *
 *  OnSysCommand - CMainFrame member function: command
 *
 *      In case the user presses the ALT-F4 accelerator key, which can't be
 *      disabled in the OnUpdateAppExit() and OnInitMenuPopup() command
 *      functions.
 *
 *  ENTRY:
 *  EXIT:
 *      (refer to the CWnd::OnSysCommand documentation)
 *
 ******************************************************************************/

void
CMainFrame::OnSysCommand( UINT nId,
                          LPARAM lParam )
{

    /*
     * If this is the SC_CLOSE command and exiting is not allowed, return.
     */
    if ( (nId == SC_CLOSE) &&
         !((CAppServerDoc *)GetActiveDocument())->IsExitAllowed() )
        return;

    /*
     * Call the parent classes OnSysCommand() function.
     */
    CFrameWnd::OnSysCommand( nId, lParam );

}  // end CMainFrame::OnSysCommand


/*******************************************************************************
 *
 *  OnUpdateAppExit - CMainFrame member function: command
 *
 *      Enables or disables the "exit" command item based on whether or not
 *      we're allowed to close the application.
 *
 *  ENTRY:
 *      pCmdUI (input)
 *          Points to the CCmdUI object of the "exit" command item.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CMainFrame::OnUpdateAppExit(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( ((CAppServerDoc *)GetActiveDocument())->IsExitAllowed() ? TRUE : FALSE );

}  // end CMainFrame::OnUpdateAppExit


/*******************************************************************************
 *
 *  OnAddWinstation - CMainFrame member function: command
 *
 *      Perform batch-mode add of winstation(s).
 *
 *  ENTRY:
 *      wParam (input)
 *          WPARAM associated with the window message: not used.
 *      wLparam (input)
 *          LPARAM associated with the window message: not used.
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CMainFrame::OnAddWinstation( WPARAM wParam,
                             LPARAM lParam )
{
    /*
     * Call AddWinStation() in document to perform the add operation.  If the
     * add failed in any way (index <= 0), post a WM_CLOSE message
     * to ourself so that we go away.  Sucessful add will be closed when final
     * add operaion completes (in the document's OperationDone() function).
     */
    if ( ((CAppServerDoc *)GetActiveDocument())->AddWinStation(0) <= 0 )
        PostMessage(WM_CLOSE);

    return(0);

}  // end CMainFrame::OnAddWinstation
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\rowview.cpp ===
/*******************************************************************************
*
* rowview.cpp
*
* implementation of the CRowView class and CRowViewHeaderBar class
*
* Modified from the Microsoft Foundation Classes C++ library.
* Copyright (C) 1992 Microsoft Corporation
* All rights reserved.
*
* additional copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\COMMON\VCS\ROWVIEW.CPP  $
*  
*     Rev 1.1   18 Jul 1995 06:50:06   butchd
*  Scrolling fix for Windows95 / MFC 3.0
*  
*     Rev 1.0   01 Mar 1995 10:54:46   butchd
*  Initial revision.
*  
*     Rev 1.0   02 Aug 1994 18:18:30   butchd
*  (Initial revision: was duplicated in each app directory).
*
*******************************************************************************/

/*
 * include files
 */
#include "stdafx.h"
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include "rowview.h"
#include "resource.h"
#include <stdlib.h>
#include <limits.h> // for INT_MAX


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


////////////////////////////////////////////////////////////////////////////////
// CRowViewHeaderBar class implementation / construction, destruction

IMPLEMENT_DYNAMIC(CRowViewHeaderBar, CStatusBar)

CRowViewHeaderBar::CRowViewHeaderBar()
{
}


CRowViewHeaderBar::~CRowViewHeaderBar()
{
}


/*******************************************************************************
 *
 *  DoPaint - CRowViewHeaderBar member function: CStatusBar class override
 *
 *      Draw the view's header bar.
 *
 *  ENTRY:
 *
 *      pDC (input)
 *          Points to the current CDC device-context object for drawing
 *          the header bar.
 *
 *  NOTE: The view's
 *      DoPaint function.
 *
 ******************************************************************************/
void
CRowViewHeaderBar::DoPaint( CDC* pDC )
{
    /*
     * Perform the CControlBar base class' DoPaint first.
     */
    CControlBar::DoPaint(pDC);

    /*
     * Default the y position for drawing the header bar to the m_cyTopBorder
     * member variable setting and call the view's OnDrawHeaderBar() member
     * function to perform the desired header bar drawing.
     */
    int y = m_cyTopBorder;
    ((CRowView *)m_pView)->OnDrawHeaderBar( pDC, y );

}  // end CRowViewHeaderBar::DoPaint
////////////////////////////////////////////////////////////////////////////////
// CRowViewHeaderBar message map

BEGIN_MESSAGE_MAP(CRowViewHeaderBar, CStatusBar)
    //{{AFX_MSG_MAP(CRowViewHeaderBar)
#if _MFC_VER >= 0x400 
	ON_WM_PAINT()
#endif
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////////////////
// CRowViewHeaderBar commands


////////////////////////////////////////////////////////////////////////////////
// CRowView implementation / construction, destruction

IMPLEMENT_DYNAMIC(CRowView, CScrollView)

CRowView::CRowView()
{
    m_nPrevSelectedRow = 0;
    m_bThumbTrack = TRUE;       // default to handle SB_THUMBTRACK messages.
    m_pHeaderBar = NULL;        // default to no header bar
}


CRowView::~CRowView()
{
}



int
CRowView::OnCreate( LPCREATESTRUCT lpCreateStruct )
{
    if ( CScrollView::OnCreate(lpCreateStruct) == -1 )
        return -1;
    
    /*
     * If the derived class has constructed a header bar, call CreateHeaderBar
     * to create the header-bar window and initialize.
     */
    if ( m_pHeaderBar )
        if ( !CreateHeaderBar() )
            return( -1 );
    
    return( 0 );

}  // end CRowView::OnCreate


BOOL
CRowView::CreateHeaderBar()
{
    /*
     * Invoke the CRowViewHeaderBar's Create member function (CStatusBar defined)
     * to create the header bar, which will be hooked to this document/view's
     * parent window.  Set the header bar's m_pView pointer to this view.
     */
    if ( !m_pHeaderBar->Create( GetParent(), WS_CHILD | WS_VISIBLE | CBRS_TOP,
                                IDW_HEADER_BAR ) ) {
        return ( FALSE );

    } else {

        m_pHeaderBar->m_pView = this;
        return ( TRUE );
    }
}  // end CRowView::CreateHeaderBar


////////////////////////////////////////////////////////////////////////////////
// CRowView class optional derived class override

/*******************************************************************************
 *
 *  ResetHeaderBar - CRowView member function: optional derived class override
 *
 *      Reset the header bar width and height based on the view's total width
 *      and view's row height.  Will also instruct the parent frame to
 *      recalculate it's layout based on the new header bar metrics.
 *
 *      NOTE: A derived class will typically override this member function to
 *      set the desired header bar font, then call this function.
 *
 ******************************************************************************/

void
CRowView::ResetHeaderBar()
{
    /*
     * If no header bar was created, return.
     */
    if ( !m_pHeaderBar )
        return;

    /*
     * Set the header bar's width and height.
     */
    m_pHeaderBar->SendMessage( WM_SIZE, 0, MAKELONG(m_nRowWidth, m_nRowHeight) );

    /*
     * Recalculate parent frame's layout with new header bar.
     */
    ((CFrameWnd *)m_pHeaderBar->GetParent())->RecalcLayout();

}  // end CRowView::ResetHeaderBar


////////////////////////////////////////////////////////////////////////////////
// CRowView class override member functions

/*******************************************************************************
 *
 *  OnInitialUpdate - CRowView member function: CView class override
 *
 *      Called before the view is initially displayed.
 *
 *  (Refer to the MFC CView::OnInitialUpdate documentation)
 *
 ******************************************************************************/

void
CRowView::OnInitialUpdate()
{
    m_nPrevRowCount = GetRowCount();
    m_nPrevSelectedRow = GetActiveRow();

}  // end CRowView::OnInitialUpdate


/*******************************************************************************
 *
 *  OnPrepareDC - CRowView member function: CView class override
 *
 *      Prepare the DC for screen or printer output.
 *
 *  (Refer to the MFC CView::OnPrepareDC documentation)
 *
 ******************************************************************************/

void
CRowView::OnPrepareDC( CDC* pDC,
                       CPrintInfo* pInfo )
{
    /*
     * The size of text that is displayed, printed or previewed changes
     * depending on the DC.  We explicitly call OnPrepareDC() to prepare
     * CClientDC objects used for calculating text positions and to
     * prepare the text metric member variables of the CRowView object.
     * The framework also calls OnPrepareDC() before passing the DC to
     * OnDraw().
     */
    CScrollView::OnPrepareDC( pDC, pInfo );
    CalculateRowMetrics( pDC );

}  // end CRowView::OnPrepareDC


/*******************************************************************************
 *
 *  OnDraw - CRowView member function: CView class override
 *
 *      Draw on the view as needed.
 *
 *  (Refer to the MFC CView::OnDraw documentation)
 *
 ******************************************************************************/

void
CRowView::OnDraw( CDC* pDC )
{
    /*
     * If there are no rows to draw, don't do anything.
     */
    if ( GetRowCount() == 0 )
        return;

    /*
     * The window has been invalidated and needs to be repainted;
     * or a page needs to be printed (or previewed).
     * First, determine the range of rows that need to be displayed or
     * printed by fetching the invalidated region.
     */
    int nFirstRow, nLastRow;
    CRect rectClip;
    pDC->GetClipBox( &rectClip );
    RectLPtoRowRange( rectClip, nFirstRow, nLastRow, TRUE );

    /*
     * Draw each row in the invalidated region of the window,
     * or on the printed (previewed) page.
     */
    int nActiveRow = GetActiveRow();
    int nRow, y;
    int nLastViewableRow = LastViewableRow();
    for ( nRow = nFirstRow, y = m_nRowHeight * nFirstRow;
          nRow <= nLastRow;
          nRow++, y += m_nRowHeight ) {

        if ( nRow > nLastViewableRow ) {

            CString strWarning;
            strWarning.LoadString( IDS_TOO_MANY_ROWS );
            pDC->TextOut( 0, y, strWarning );
            break;
        }

        OnDrawRow( pDC, nRow, y, nRow == nActiveRow );
    }

}  // end CRowView::OnDraw


/*******************************************************************************
 *
 *  OnPreparePrinting - CRowView member function: CView class override
 *
 *      Prepare the view for printing or print preview.
 *
 *  (Refer to the MFC CView::OnPreparePrinting documentation)
 *
 ******************************************************************************/

BOOL
CRowView::OnPreparePrinting( CPrintInfo* pInfo )
{
    return ( DoPreparePrinting( pInfo ) );

}  // end CRowView::OnPreparePrinting


/*******************************************************************************
 *
 *  OnBeginPrinting - CRowView member function: CView class override
 *
 *      Setup before beginning to print.
 *
 *  (Refer to the MFC CView::OnBeginPrinting documentation)
 *
 ******************************************************************************/

void
CRowView::OnBeginPrinting( CDC* pDC,
                           CPrintInfo* pInfo )
{
    /*
     * OnBeginPrinting() is called after the user has committed to
     * printing by OK'ing the Print dialog, and after the framework
     * has created a CDC object for the printer or the preview view.
     */

    /*
     * This is the right opportunity to set up the page range.
     * Given the CDC object, we can determine how many rows will
     * fit on a page, so we can in turn determine how many printed
     * pages represent the entire document.
     */

    int nPageHeight = pDC->GetDeviceCaps(VERTRES);
    CalculateRowMetrics(pDC);
    m_nRowsPerPrintedPage = nPageHeight / m_nRowHeight;

    int nPrintableRowCount = LastViewableRow() + 1;
    if ( GetRowCount() < nPrintableRowCount )
        nPrintableRowCount = GetRowCount();

    pInfo->SetMaxPage( (nPrintableRowCount + m_nRowsPerPrintedPage - 1)
                        / m_nRowsPerPrintedPage );
    /*
     * Start previewing at page #1.
     */
    pInfo->m_nCurPage = 1;
}  // end CRowView::OnBeginPrinting


/*******************************************************************************
 *
 *  OnPrint - CRowView member function: CView class override
 *
 *      Print or preview a page of the view's document.
 *
 *  (Refer to the MFC CView::OnPrint documentation)
 *
 ******************************************************************************/

void
CRowView::OnPrint( CDC* pDC,
                   CPrintInfo* pInfo )
{
    /*
     * Print the rows for the current page.
     */
    int yTopOfPage = (pInfo->m_nCurPage -1) * m_nRowsPerPrintedPage
                        * m_nRowHeight;

    /*
     * Orient the viewport so that the first row to be printed
     * has a viewport coordinate of (0,0).
     */
    pDC->SetViewportOrg(0, -yTopOfPage);

    /*
     * Draw as many rows as will fit on the printed page.
     * Clip the printed page so that there is no partially shown
     * row at the bottom of the page (the same row which will be fully
     * shown at the top of the next page).
     */
    int nPageWidth = pDC->GetDeviceCaps(HORZRES);
    CRect rectClip = CRect(0, yTopOfPage, nPageWidth, 
         yTopOfPage + m_nRowsPerPrintedPage * m_nRowHeight);
    pDC->IntersectClipRect(&rectClip);
    OnDraw(pDC);

}  // end CRowView::OnPrint


/////////////////////////////////////////////////////////////////////////////
// CRowView operations

/*******************************************************************************
 *
 *  UpdateRow - CRowView member function: operation
 *
 *      Handle scrolling and invalidation of the specified row, in preparation
 *      for the OnDraw function.
 *
 *  ENTRY:
 *
 *      nInvalidRow (input)
 *          Row to update.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CRowView::UpdateRow( int nInvalidRow )
{
    int nRowCount = GetRowCount();

    /*
     * If the number of rows has changed, then adjust the scrolling range.
     */
    if (nRowCount != m_nPrevRowCount)
    {
        UpdateScrollSizes();
        m_nPrevRowCount = nRowCount;
    }

    /*
     * When the currently selected row changes:
     * scroll the view so that the newly selected row is visible, and
     * ask the derived class to repaint the selected and previously
     * selected rows.
     */
    CClientDC dc(this);
    OnPrepareDC(&dc);

    /*
     * Determine the range of the rows that are currently fully visible
     * in the window.  We want to do discrete scrolling by so that
     * the next or previous row is always fully visible.
     */
    int nFirstRow, nLastRow;
    CRect rectClient;
    GetClientRect( &rectClient );
    dc.DPtoLP( &rectClient );
    RectLPtoRowRange( rectClient, nFirstRow, nLastRow, FALSE );

    /*
     * If necessary, scroll the window so the newly selected row is
     * visible.  MODIFICATION: set the pt.x to the left visible x point
     * in the row (not 0), so that the ScrollToDevicePosition() call won't
     * automatically perform a horizontal scroll (very annoying to user).
     */
    POINT pt;
    pt.x = rectClient.left;
    BOOL bNeedToScroll = TRUE;

    if ( nInvalidRow < nFirstRow ) {
    
        /*
         * The newly selected row is above those currently visible
         * in the window.  Scroll so the newly selected row is at the
         * very top of the window.  The last row in the window might
         * be only partially visible.
         */
        pt.y = RowToYPos(nInvalidRow);

    } else if ( nInvalidRow > nLastRow ) {
    
        /*
         * The newly selected row is below those currently visible
         * in the window.  Scroll so the newly selected row is at the
         * very bottom of the window.  The first row in the window might
         * be only partially visible.
         */
        pt.y = max( 0, RowToYPos(nInvalidRow+1) - rectClient.Height() );

    } else {

        bNeedToScroll = FALSE;
    }

    if ( bNeedToScroll ) {

        /*
         * Scrolling will cause the newly selected row to be
         * redrawn in the invalidated area of the window.
         */
        ScrollToDevicePosition(pt);

        /*
         * Need to prepare the DC again because ScrollToDevicePosition()
         * will have changed the viewport origin.  The DC is used some
         * more below.
         */
        OnPrepareDC(&dc);
    }

    CRect rectInvalid = RowToWndRect( &dc, nInvalidRow );
    InvalidateRect( &rectInvalid );

    /*
     * Give the derived class an opportunity to repaint the
     * previously selected row, perhaps to un-highlight it.
     */
    int nSelectedRow = GetActiveRow();
    if (m_nPrevSelectedRow != nSelectedRow) {

        CRect rectOldSelection = RowToWndRect(&dc, m_nPrevSelectedRow);
        InvalidateRect(&rectOldSelection);
        m_nPrevSelectedRow = nSelectedRow;
    }

}  // end CRowView::UpdateRow


/*******************************************************************************
 *
 *  IsScrollingNeeded - CRowView member function: operation
 *
 *      Determine if the client window of this view is small enough in a
 *      HORIZONTAL or VERTICAL direction to require scrolling to see the
 *      entire view.  This function is mainly used to support the operation
 *      of 'scrolling keys' (non-mouse generated scrolling commands).
 *
 *  ENTRY:
 *
 *      nBar (input)
 *          SB_HORZ or SB_VERT: to indicate which scrolling direction to check.
 *
 *  EXIT:
 *
 *      TRUE if scrolling is needed in the specified direction.
 *      FALSE if no scrolling is needed in the specified direction.
 *
 ******************************************************************************/

BOOL
CRowView::IsScrollingNeeded( int nBar )
{
    CRect rectClient;
    CSize sizeTotal;

    GetClientRect( &rectClient );
    sizeTotal = GetTotalSize();

    if ( nBar == SB_HORZ ) {
    
        if ( sizeTotal.cx > rectClient.right )
            return ( TRUE );
        else
            return (FALSE );

    } else {

        if ( sizeTotal.cy > rectClient.bottom )
            return ( TRUE );
        else
            return (FALSE );
    }
}  // end CRowView::IsScrollingNeeded


#ifndef MFC300
/*******************************************************************************
 *
 *  GetScrollLimit - CRowView member function: operation (MFC 2.x stub)
 *
 *      MFC 3.0 provides a GetScrollLimit() member function that properly
 *      handles Windows95 scrollbar controls if running on Windows95.  This
 *      stub is provided for
 *
 *  ENTRY:
 *      nBar (input)
 *          SB_HORZ or SB_VERT: to indicate which scrolling direction to check.
 *  EXIT:
 *      Returns the nMax value from the standard Windows GetScrollLimit() API.
 *      Also contains an ASSERT to check for nMin != 0.
 *
 ******************************************************************************/

int
CRowView::GetScrollLimit( int nBar )
{
    int nMin, nMax;
    GetScrollRange(nBar, &nMin, &nMax);
    ASSERT(nMin == 0);
    return nMax;

}  // end CRowView::GetScrollLimit
#endif


void
CRowView::CalculateRowMetrics( CDC* pDC )
{
    GetRowWidthHeight( pDC, m_nRowWidth, m_nRowHeight );

}  // end CRowView::CalculateRowMetrics


void
CRowView::UpdateScrollSizes()
{
    /*
     * UpdateScrollSizes() is called when it is necessary to adjust the
     * scrolling range or page/line sizes.  There are two occassions
     * where this is necessary:  (1) when a new row is effected (added,
     * deleted, or changed) -- see UpdateRow()-- and (2) when the window size
     * changes-- see OnSize().
     */
    CRect rectClient;
    GetClientRect( &rectClient );

    CClientDC dc( this );
    CalculateRowMetrics( &dc );

    /*
     * The vert scrolling range is the total display height of all
     * of the rows.
     */
    CSize sizeTotal( m_nRowWidth, 
                     m_nRowHeight * (min( GetRowCount(), LastViewableRow() )) );

    /*
     * The vertical per-page scrolling distance is equal to the
     * how many rows can be displayed in the current window, less
     * one row for paging overlap.
     */
    CSize sizePage( m_nRowWidth/5,
                    max( m_nRowHeight,
                         ((rectClient.bottom/m_nRowHeight)-1)*m_nRowHeight ) );

    /*
     * We'll also calculate the number of rows that the view should be scrolled
     * during PageUp / PageDown.  This number will always be at least 1.
     */
    m_nPageScrollRows = (m_nPageScrollRows =
                         ((rectClient.bottom / m_nRowHeight)-1)) >= 1 ?
                         m_nPageScrollRows : 1;

    /*
     * The vertical per-line scrolling distance is equal to the
     * height of the row.
     */
    CSize sizeLine( m_nRowWidth/20, m_nRowHeight );

    SetScrollSizes( MM_TEXT, sizeTotal, sizePage, sizeLine );

}  // end CRowView::UpdateScrollSizes


int
CRowView::RowToYPos( int nRow )
{
    return ( nRow * m_nRowHeight );

}  // end CRowView::RowToYPos


CRect
CRowView::RowToWndRect( CDC* pDC,
                        int nRow )
{
    /*
     * MODIFICATION: Set right end of returned rectangle to max of end of row,
     * or screen width.  This will assure full update in case of horizontall
     * scrolling on very wide rows (> screen width).
     */
    int nHorzRes = pDC->GetDeviceCaps(HORZRES);
    CRect rect( 0, nRow * m_nRowHeight, 
                max( m_nRowWidth, nHorzRes ), (nRow + 1) * m_nRowHeight );
    pDC->LPtoDP( &rect );
    return rect;

}  // end CRowView::RowToWndRect


int
CRowView::LastViewableRow()
{
    return ( (INT_MAX / m_nRowHeight) - 1 );
}  // end CRowView::LastViewableRow


void
CRowView::RectLPtoRowRange( const CRect& rect,
                            int& nFirstRow,
                            int& nLastRow,
                            BOOL bIncludePartiallyShownRows )
{
    int nRounding = bIncludePartiallyShownRows? 0 : (m_nRowHeight - 1);

    nFirstRow = (rect.top + nRounding) / m_nRowHeight;
    nLastRow = min( (rect.bottom - nRounding) / m_nRowHeight,
                    GetRowCount() - 1 );
}  // end CRowView::RectLPtoRowRange


/////////////////////////////////////////////////////////////////////////////
// CRowView message map

BEGIN_MESSAGE_MAP(CRowView, CScrollView)
    //{{AFX_MSG_MAP(CRowView)
    ON_WM_KEYDOWN()
    ON_WM_SIZE()
    ON_WM_LBUTTONDOWN()
    ON_WM_HSCROLL()
    ON_WM_CREATE()
    ON_WM_VSCROLL()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CRowView commands

/*******************************************************************************
 *
 *  OnSize - CRowView member function: command (override of CWnd)
 *
 *      Processes size change message.
 *
 *  ENTRY:
 *
 *      (Refer to CWnd::OnSize documentation)
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CRowView::OnSize( UINT nType,
                  int cx,
                  int cy )
{
    UpdateScrollSizes();
    CScrollView::OnSize(nType, cx, cy);

}  // end CRowView::OnSize


/*******************************************************************************
 *
 *  OnKeyDown - CRowView member function: command (override of CWnd)
 *
 *      Processes list scrolling / selection via keyboard input.
 *
 *  ENTRY:
 *
 *      (Refer to CWnd::OnKeyDown documentation)
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CRowView::OnKeyDown( UINT nChar,
                     UINT nRepCnt,
                     UINT nFlags )
{
    int nNewRow;

    switch ( nChar ) {

        case VK_HOME:
            ChangeSelectionToRow(0);
            break;

        case VK_END:
            ChangeSelectionToRow(GetRowCount() - 1);
            break;

        case VK_UP:
            ChangeSelectionNextRow(FALSE);
            break;

        case VK_DOWN:
            ChangeSelectionNextRow(TRUE);
            break;
            
        case VK_PRIOR:
            /*
             * Determine a new row that is one 'pageup' above our currently
             * active row and make it active.
             */
            nNewRow = (nNewRow = GetActiveRow() - m_nPageScrollRows) >
                       0 ? nNewRow : 0;
            ChangeSelectionToRow(nNewRow);
            break;

        case VK_NEXT:
            /*
             * Determine a new row that is one 'pagedown' below our currently
             * active row and make it active.
             */
            nNewRow = (nNewRow = GetActiveRow() + m_nPageScrollRows) <
                       GetRowCount() ? nNewRow : GetRowCount() - 1;
            ChangeSelectionToRow(nNewRow);
            break;

        case VK_LEFT:
        
            /*
             * Scroll page-left.
             */
            if ( IsScrollingNeeded(SB_HORZ) ) {
            
                OnHScroll( SB_PAGELEFT, 0, GetScrollBarCtrl(SB_HORZ) );
                return;
            }
            break;

        case VK_RIGHT:
        
            /*
             * Scroll page-right.
             */
            if ( IsScrollingNeeded(SB_HORZ) ) {
            
                OnHScroll(SB_PAGERIGHT, 0, GetScrollBarCtrl(SB_HORZ));
                return;
            }
            break;

        default:

            /*
             * Call the CScrollView OnKeyDown function for keys not
             * specifically handled here.
             */
            CScrollView::OnKeyDown( nChar, nRepCnt, nFlags );
    }

}  // end CRowView::OnKeyDown


/*******************************************************************************
 *
 *  OnLButtonDown - CRowView member function: command (override of CWnd)
 *
 *      Processes left mouse button for list item selection.
 *
 *  ENTRY:
 *
 *      (Refer to CWnd::OnLButtonDown documentation)
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CRowView::OnLButtonDown( UINT nFlags,
                         CPoint point )
{
    CClientDC dc(this);
    OnPrepareDC(&dc);
    dc.DPtoLP(&point);
    CRect rect(point, CSize(1,1));

    int nFirstRow, nLastRow;
    RectLPtoRowRange(rect, nFirstRow, nLastRow, TRUE);

    if (nFirstRow <= (GetRowCount() - 1))
        ChangeSelectionToRow(nFirstRow);

}  // end CRowView::OnLButtonDown


/*******************************************************************************
 *
 *  OnHScroll - CRowView member function: command (override of CScrollView)
 *
 *      Handles horizontal scrolling message.  The CScrollView member function
 *      is overriden to allow us to call the CRowView::OnScroll override during
 *      a Hscroll message.
 *
 *  ENTRY:
 *
 *      (Refer to CWnd::OnHScroll documentation)
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CRowView::OnHScroll( UINT nSBCode,
                     UINT nPos,
                     CScrollBar* pScrollBar )
{
    VERIFY( pScrollBar == GetScrollBarCtrl(SB_HORZ) );    // may be null
    OnScroll( SB_HORZ, nSBCode, nPos );

}  // end CRowView::OnHScroll


/*******************************************************************************
 *
 *  OnVScroll - CRowView member function: command (override of CScrollView)
 *
 *      Handles vertical scrolling message.  The CScrollView member function is
 *      overriden to allow us to call the CRowView::OnScroll override during a
 *      Vscroll message.
 *
 *  ENTRY:
 *
 *      (Refer to CWnd::OnVScroll documentation)
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CRowView::OnVScroll( UINT nSBCode,
                     UINT nPos,
                     CScrollBar* pScrollBar )
{
    VERIFY( pScrollBar == GetScrollBarCtrl(SB_HORZ) );    // may be null
    OnScroll( SB_VERT, nSBCode, nPos );

}  // end CRowView::OnVScroll


/*******************************************************************************
 *
 *  OnScroll - CRowView member function: command (override of CScrollView)
 *
 *      Processes horizontal scrolling.  The CScrollView member function
 *      is overriden to properly scroll the header bar (if it is defined) and
 *      to handle or ignore SB_THUMBTRACK scroll messages.
 *
 *  ENTRY:
 *      nBar (input)
 *          SB_HORZ or SB_VERT.
 *      nSBCode (input)
 *          Scroll bar code.
 *      nPos (input)
 *          Scroll-box position for SB_THUMBTRACK handling.
 *  EXIT:
 *
 *
 *  NOTE: This code is a slight modificaton of the CScrollView::OnScroll code
 *        found in the VIEWSCRL.CPP MFC 2.5 source.  The GetScrollLimit()
 *        function has been added to handle Windows95 scrollbar controls
 *        (when built with MFC 3.0 and above - MFC300 defined).
 *
 ******************************************************************************/

void
CRowView::OnScroll( int nBar,
                    UINT nSBCode,
                    UINT nPos )
{
    VERIFY(nBar == SB_HORZ || nBar == SB_VERT);
    BOOL bHorz = (nBar == SB_HORZ);

    int zOrig, z;   // z = x or y depending on 'nBar'
    int zMax;
    zOrig = z = GetScrollPos(nBar);
    zMax = GetScrollLimit(nBar);
    if (zMax <= 0)
    {
        TRACE0("Warning: no scroll range - ignoring scroll message\n");
        VERIFY(z == 0);     // must be at top
        return;
    }

    switch (nSBCode)
    {
    case SB_TOP:
        z = 0;
        break;

    case SB_BOTTOM:
        z = zMax;
        break;
        
    case SB_LINEUP:
        z -= bHorz ? m_lineDev.cx : m_lineDev.cy;
        break;

    case SB_LINEDOWN:
        z += bHorz ? m_lineDev.cx : m_lineDev.cy;
        break;

    case SB_PAGEUP:
        z -= bHorz ? m_pageDev.cx : m_pageDev.cy;
        break;

    case SB_PAGEDOWN:
        z += bHorz ? m_pageDev.cx : m_pageDev.cy;
        break;

    case SB_THUMBTRACK:

        /*
         * If we're not handling the SB_THUMBTRACK messages, return.
         */
        if ( !m_bThumbTrack )
            return;

        z = nPos;
        break;

    case SB_THUMBPOSITION:
        z = nPos;
        break;

    default:        // ignore other notifications
        return;
    }

    if (z < 0)
        z = 0;
    else if (z > zMax)
        z = zMax;

    if (z != zOrig)
    {
        if (bHorz) {

            ScrollWindow(-(z-zOrig), 0);

            /*
             * If this view has a header bar, scroll it to match the view.
             */
            if ( m_pHeaderBar )
                m_pHeaderBar->ScrollWindow( -(z-zOrig), 0 );

        } else
            ScrollWindow(0, -(z-zOrig));

        SetScrollPos(nBar, z);
        UpdateWindow();

        /*
         * If this view has a header bar, update it now.
         */
        if ( m_pHeaderBar )
            m_pHeaderBar->UpdateWindow();
    }
}  // end CRowView::OnScroll

#if _MFC_VER >= 0x400 

void CRowViewHeaderBar::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	// TODO: Add your message handler code here
	
	// Do not call CStatusBar::OnPaint() for painting messages
   	DoPaint(&dc);      
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\stdafx.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* stdafx.cpp
*
* source file that includes just the standard includes stdafx.pch will be the
* pre-compiled header stdafx.obj will contain the pre-compiled type information
*
* $Author:   butchd  $
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\STDAFX.CPP  $
*  
*     Rev 1.0   02 Aug 1994 18:18:38   butchd
*  Initial revision.
*
*******************************************************************************/
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\stdafx.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* stdafx.h
*
* include file for standard system include files, or project specific include
* files that are used frequently, but are changed infrequently
*
* $Author:   butchd  $
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\STDAFX.H  $
*
*     Rev 1.2   23 Aug 1996 08:52:48   butchd
*  update
*
*     Rev 1.1   29 Nov 1995 14:01:26   butchd
*  update
*
*     Rev 1.0   02 Aug 1994 18:18:42   butchd
*  Initial revision.
*
*******************************************************************************/

    // These include files must come from ...\MSVCNT\MFC\INCLUDE
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>         // MFC Win95 common control classes
    // These include files must come from ...\SDK\INC and subdirs
#include <objbase.h>
#include <ntddkbd.h>        // NT keyboard definitions
#include <ntddmou.h>        // NT mouse definitions
#include <winsta.h>  // Citrix WinStation definitions
    // local include files
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\rowview.h ===
/*******************************************************************************
*
* rowview.h
*
* interface of the CRowView class and CRowViewHeaderBar class
*
* Modified from the Microsoft Foundation Classes C++ library.
* Copyright (C) 1992 Microsoft Corporation
* All rights reserved.
*
* This class implements the behavior of a scrolling view that presents
* multiple rows of fixed-height data.  A row view is similar to an
* owner-draw listbox in its visual behavior; but unlike listboxes,
* a row view has all of the benefits of a view (as well as scroll view),
* including perhaps most importantly printing and print preview.
*
* additional copyright notice: Copyright 1995, Citrix Systems Inc.
*
* Citrix modifications include optional horizontal scrolling header bar
* (derived from MFC CStatusBar class) and horizontal scrolling keyboard
* control.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\COMMON\VCS\ROWVIEW.H  $
*  
*     Rev 1.1   18 Jul 1995 06:50:16   butchd
*  Scrolling fix for Windows95 / MFC 3.0
*  
*     Rev 1.0   01 Mar 1995 10:54:50   butchd
*  Initial revision.
*  
*     Rev 1.0   02 Aug 1994 18:18:34   butchd
*  (Initial revision: was duplicated in each app directory).
*
*******************************************************************************/

#define IDW_HEADER_BAR  100

////////////////////////////////////////////////////////////////////////////////
// CRowViewHeaderBar class
//
class CRowViewHeaderBar : public CStatusBar
{
    DECLARE_DYNAMIC(CRowViewHeaderBar)

/*
 * Member variables.
 */
public:
    CView * m_pView;

/*
 * Implementation
 */
public:
    CRowViewHeaderBar();
    virtual ~CRowViewHeaderBar();

/*
 * Overrides of MFC CStatusBar class
 */
protected:
       virtual void DoPaint(CDC* pDC);

/*
 * Message map / commands.
 */
protected:
    //{{AFX_MSG(CRowViewHeaderBar)
#if _MFC_VER >= 0x400 
	afx_msg void OnPaint();
#endif
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  // end CRowViewHeaderBar class interface
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// CRowView class
//
class CRowView : public CScrollView
{
    DECLARE_DYNAMIC(CRowView)

/*
 * Member variables.
 */
protected:
    int m_nRowWidth;            // width of row in current device units
    int m_nRowHeight;           // height of row in current device untis
    int m_nPrevSelectedRow;     // index of the most recently selected row
    int m_nPrevRowCount;        // most recent row count, before update
    int m_nPageScrollRows;      // # rows to PageUp/PageDown scroll (>=1).
    int m_nRowsPerPrintedPage;  // how many rows fit on a printed page
    BOOL m_bThumbTrack;         // Flag to handle SB_THUMBTRACK or not.
    CRowViewHeaderBar * m_pHeaderBar;  // Optional header bar.

/*
 * Implementation
 */
public:
    CRowView();
protected:
    virtual ~CRowView();
    BOOL CreateHeaderBar();

/*
 * Mandantory overridables (must be overridden in the CRowView derived class)
 */
protected:
    virtual void GetRowWidthHeight( CDC* pDC, int& nRowWidth, 
                                    int& nRowHeight ) = 0;
    virtual int GetActiveRow() = 0;
    virtual int GetRowCount() = 0;
    virtual void OnDrawRow( CDC* pDC, int nRow, int y, BOOL bSelected ) = 0;
    virtual void ChangeSelectionNextRow( BOOL bNext ) = 0;
    virtual void ChangeSelectionToRow( int nRow ) = 0;

/*
 * Optional overridables (must be overridden in the CRowView derived class if
 *  a header bar is desired).
 */
public:
    virtual void OnDrawHeaderBar( CDC* pDC, int y ) = 0;

/*
 * Optional overridables (may be overridden in the CRowView derived class)
 */
public:
    virtual void ResetHeaderBar();

/*
 * Overrides of MFC CScrollView class
 */
public:
    void OnScroll(int nBar, UINT nSBCode, UINT nPos);

/*
 * Overrides of MFC CView class
 */
    void OnInitialUpdate();
    virtual void OnPrepareDC( CDC* pDC, CPrintInfo* pInfo = NULL );
    virtual void OnDraw( CDC* pDC );
    virtual BOOL OnPreparePrinting( CPrintInfo* pInfo );
    virtual void OnBeginPrinting( CDC* pDC, CPrintInfo* pInfo );
    virtual void OnPrint( CDC* pDC, CPrintInfo* pInfo );

/*
 * Operations
 */
protected:
    virtual void UpdateRow( int nInvalidRow ); 
    BOOL IsScrollingNeeded( int nBar );
#ifndef MFC300
    int GetScrollLimit( int nBar );
#endif
    virtual void CalculateRowMetrics( CDC* pDC );
    virtual void UpdateScrollSizes();
    virtual int RowToYPos( int nRow );
    virtual CRect RowToWndRect( CDC* pDC, int nRow );
    virtual int LastViewableRow();
    virtual void RectLPtoRowRange( const CRect& rectLP, 
                                   int& nFirstRow,
                                   int& nLastRow,
                                   BOOL bIncludePartiallyShownRows );

/*
 * Message map / commands
 */
protected:
    //{{AFX_MSG(CRowView)
    afx_msg void OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags );
    afx_msg void OnSize( UINT nType, int cx, int cy );
    afx_msg void OnLButtonDown( UINT nFlags, CPoint point );
    afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  // end CRowView class interface
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\security.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* security.h
*
* header file for WinStation ACL editing functions
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\SECURITY.H  $
*  
*     Rev 1.4   19 Sep 1996 15:58:46   butchd
*  update
*
*******************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

/* 
 * Security helper public function prototypes
 */
BOOL CallPermissionsDialog( HWND hwnd, BOOL bAdmin, PWINSTATIONNAME pWSName );

DWORD GetWinStationSecurityA( PWINSTATIONNAMEA pWSName,
                              PSECURITY_DESCRIPTOR *ppSecurityDescriptor );
DWORD GetWinStationSecurityW( PWINSTATIONNAMEW pWSName,
                              PSECURITY_DESCRIPTOR *ppSecurityDescriptor );
#ifdef UNICODE
#define GetWinStationSecurity GetWinStationSecurityW
#else
#define GetWinStationSecurity GetWinStationSecurityA
#endif

DWORD GetDefaultWinStationSecurity( PSECURITY_DESCRIPTOR *ppSecurityDescriptor );
void FreeSecurityStrings();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\threads.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* threads.cpp
*
* implementation of WINCFG thread classes
*
* copyright notice: Copyright 1994, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   N:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\THREADS.CPP  $
*  
*     Rev 1.18   19 Sep 1996 15:58:52   butchd
*  update
*  
*     Rev 1.17   12 Sep 1996 16:16:44   butchd
*  update
*
*******************************************************************************/

/*
 * include files
 */
#include "stdafx.h"
#include "wincfg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CWincfgApp *pApp;


////////////////////////////////////////////////////////////////////////////////
// CThread class construction / destruction, implementation

/*******************************************************************************
 *
 *  CThread - CThread constructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CThread::CThread()
{
    m_hThread = NULL;
    m_dwThreadID = 0;

}  // end CThread::CThread


/*******************************************************************************
 *
 *  ~CThread - CThread destructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/


CThread::~CThread()
{
}  // end CThread::~CThread


/*******************************************************************************
 *
 *  operator new - CThread operator override
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void *
CThread::operator new(size_t nSize)
{
    return( ::malloc(nSize) );

}  // end CThread::operator new


/*******************************************************************************
 *
 *  operator delete - CThread operator override
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CThread::operator delete(void *p)
{
    ::free(p);

}  // end CThread::operator delete


////////////////////////////////////////////////////////////////////////////////
// CThread operations: primary thread

/*******************************************************************************
 *
 *  CreateThread - CThread implementation function
 *
 *      Class wrapper for the Win32 CreateThread API.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

HANDLE
CThread::CreateThread( DWORD cbStack,
                       DWORD fdwCreate )
{
    /*
     * Simple wrapper for Win32 CreateThread API.
     */
    return( m_hThread = ::CreateThread( NULL, cbStack, ThreadEntryPoint,
            (LPVOID)this, fdwCreate, &m_dwThreadID ) );

}  // end CThread::CreateThread


////////////////////////////////////////////////////////////////////////////////
// CThread operations: secondary thread

/*******************************************************************************
 *
 *  ThreadEntryPoint - CThread implementation function
 *                     (SECONDARY THREAD)
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

DWORD __stdcall
CThread::ThreadEntryPoint(LPVOID lpParam)
{
    CThread *pThread;
    DWORD dwResult;

    /* 
     * (lpParam is actually the 'this' pointer)
     */
    pThread = (CThread*)lpParam;
    VERIFY(pThread != NULL);

    /*
     * Run the thread.
     */
    dwResult = pThread->RunThread();

    /*
     * Return the result.
     */    
    return(dwResult);

}  // end CThread::ThreadEntryPoint
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// CATDlgInputThread class construction / destruction, implementation

/*******************************************************************************
 *
 *  CATDlgInputThread - CATDlgInputThread constructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CATDlgInputThread::CATDlgInputThread()
{
    /*
     * Initialize member variables.
     */    
    m_bExit = FALSE;
    m_ErrorStatus = ERROR_SUCCESS;
    m_hConsumed = m_OverlapSignal.hEvent = m_OverlapRead.hEvent = NULL;

}  // end CATDlgInputThread::CATDlgInputThread


/*******************************************************************************
 *
 *  ~CATDlgInputThread - CATDlgInputThread destructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CATDlgInputThread::~CATDlgInputThread()
{
    /*
     * Close the semaphore and events when the CATDlgInputThread
     * object is destroyed.
     */
    if ( m_hConsumed )
        CloseHandle(m_hConsumed);

    if ( m_OverlapRead.hEvent )
        CloseHandle(m_OverlapRead.hEvent);

    if ( m_OverlapSignal.hEvent )
        CloseHandle(m_OverlapSignal.hEvent);

}  // end CATDlgInputThread::~CATDlgInputThread


/*******************************************************************************
 *
 *  RunThread - CATDlgInputThread secondary thread main function loop
 *              (SECONDARY THREAD)
 *
 *  ENTRY:
 *  EXIT:
 *      (DWORD) exit status for the secondary thread.
 *
 ******************************************************************************/

DWORD
CATDlgInputThread::RunThread()
{
    HANDLE hWait[2];
    DWORD Status;
    int iStat;

    /*
     * Initialize for overlapped status and read input.
     */
    if ( !(m_hConsumed = CreateSemaphore( NULL, 0,
                                          MAX_STATUS_SEMAPHORE_COUNT,
                                          NULL )) ||
         !(m_OverlapRead.hEvent = CreateEvent( NULL, TRUE,
                                               FALSE, NULL )) ||
         !(m_OverlapSignal.hEvent = CreateEvent( NULL, TRUE,
                                                 FALSE, NULL )) ||
         !SetCommMask( m_hDevice,
                       EV_CTS | EV_DSR | EV_ERR | EV_RING | EV_RLSD | EV_BREAK ) ) {

        NotifyAbort(IDP_ERROR_CANT_INITIALIZE_INPUT_THREAD);
        return(1);
    }
    
    /* 
     * Query initial comm status to initialize dialog with (return if error).
     */
    if ( (iStat = CommStatusAndNotify()) != -1 )
        return(iStat);

    /*
     *  Post Read for input data.
     */
    if ( (iStat = PostInputRead()) != -1 )
        return(iStat);

    /*
     *  Post Read for status.
     */
    if ( (iStat = PostStatusRead()) != -1 )
        return(iStat);

    /*
     * Loop till exit requested.
     */
    for ( ; ; ) {

        /*
         * Wait for either input data or an comm status event.
         */
        hWait[0] = m_OverlapRead.hEvent;
        hWait[1] = m_OverlapSignal.hEvent;
        Status = WaitForMultipleObjects(2, hWait, FALSE, INFINITE);

        /*
         * Check for exit.
         */        
        if ( m_bExit )
            return(0);

        if ( Status == WAIT_OBJECT_0 ) {

            /*
             * Read event:
             * Get result of overlapped read.
             */
            if ( !GetOverlappedResult( m_hDevice,
                                       &m_OverlapRead,
                                       &m_BufferBytes,
                                       TRUE ) ) {

                NotifyAbort(IDP_ERROR_GET_OVERLAPPED_RESULT_READ);
                return(1);
            }

            /*
             * Notify dialog.
             */
            if ( (iStat = CommInputNotify()) != -1 )
                return(iStat);

            /*
             *  Post Read for input data.
             */
            if ( (iStat = PostInputRead()) != -1 )
                return(iStat);

        } else if ( Status == WAIT_OBJECT_0+1 ) {

            /* 
             * Comm status event:
             * Query comm status and notify dialog.
             */
            if ( (iStat = CommStatusAndNotify()) != -1 )
                return(iStat);

            /*
             *  Post Read for status.
             */
            if ( (iStat = PostStatusRead()) != -1 )
                return(iStat);


        } else {

            /*
             * Unknown event: Abort.
             */
            NotifyAbort(IDP_ERROR_WAIT_FOR_MULTIPLE_OBJECTS);
            return(1);
        }
    }

}  // end CATDlgInputThread::RunThread


////////////////////////////////////////////////////////////////////////////////
// CATDlgInputThread operations: primary thread

/*******************************************************************************
 *
 *  SignalConsumed - CATDlgInputThread member function: public operation
 *
 *      Release the m_hConsumed semaphore to allow secondary thread to continue
 *      running.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CATDlgInputThread::SignalConsumed()
{
    ReleaseSemaphore( m_hConsumed, 1, NULL );

}  // end CATDlgInputThread::SignalConsumed


/*******************************************************************************
 *
 *  ExitThread - CATDlgInputThread member function: public operation
 *
 *      Tell the secondary thread to exit and cleanup after.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CATDlgInputThread::ExitThread()
{
    DWORD dwReturnCode;
    int i;
    CWaitCursor wait;

    /*
     * If the thread was not created properly, just delete object and return.
     */
    if ( !m_hThread ) {
        delete this;
        return;
    }

    /*
     * Set the m_bExit flag to TRUE, wake up the run thread's WaitCommEvent() by
     * resetting device's Comm mask, and bump the consumed semaphore to assure exit.
     */
    m_bExit = TRUE;
    SetCommMask(m_hDevice, 0);
    SignalConsumed();

    /*
     * Purge the recieve buffer and any pending read.
     */
    PurgeComm(m_hDevice, PURGE_RXABORT | PURGE_RXCLEAR);

    /*
     * Wait a while for the thread to exit.
     */
    for ( i = 0, GetExitCodeThread( m_hThread, &dwReturnCode );
          (i < MAX_SLEEP_COUNT) && (dwReturnCode == STILL_ACTIVE); i++ ) {

        Sleep(100);
        GetExitCodeThread( m_hThread, &dwReturnCode );
    }

    /*
     * If the thread has still not exited, terminate it.
     */
    if ( dwReturnCode == STILL_ACTIVE ) {

        TerminateThread( m_hThread, 1 );

#ifdef _DEBUG
    TRACE( TEXT("WINCFG: Forced Terminate of Async Test Input thread after %u 100msec exit waits.\n"),
            MAX_SLEEP_COUNT );
#endif

    }

    /*
     * Close the thread handle and delete this CATDlgInputThread object
     */
    VERIFY( CloseHandle(m_hThread) );
    delete this;

}  // end CATDlgInputThread::ExitThread


////////////////////////////////////////////////////////////////////////////////
// CATDlgInputThread operations: secondary thread

/*******************************************************************************
 *
 *  NotifyAbort - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Notify the dialog of thread abort and reason.
 *
 *  ENTRY:
 *      idError (input)
 *          Resource id for error message.
 *  EXIT:
 *
 ******************************************************************************/

void
CATDlgInputThread::NotifyAbort( UINT idError )
{
    ::PostMessage(m_hDlg, WM_ASYNCTESTABORT, idError, GetLastError());

}  // end CATDlgInputThread::NotifyAbort


/*******************************************************************************
 *
 *  CommInputNotify - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Notify the dialog of comm input.
 *
 *  ENTRY:
 *  EXIT:
 *      -1 no error and continue thread
 *      0 if ExitThread was requested by parent
 *
 ******************************************************************************/

int
CATDlgInputThread::CommInputNotify()
{
    /*
     * Tell the dialog that we've got some new input.
     */
    ::PostMessage(m_hDlg, WM_ASYNCTESTINPUTREADY, 0, 0);
    WaitForSingleObject(m_hConsumed, INFINITE);

    /*
     * Check for thread exit request.
     */
    if ( m_bExit )
        return(0);
    else
        return(-1);    

}  // end CATDlgInputThread::CommInputNotify


/*******************************************************************************
 *
 *  CommStatusAndNotify - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Read the comm port status and notify dialog.
 *
 *  ENTRY:
 *  EXIT:
 *      -1 no error and continue thread
 *      0 if ExitThread was requested by parent
 *      1 error condition
 *
 ******************************************************************************/

int
CATDlgInputThread::CommStatusAndNotify()
{
    PFLOWCONTROLCONFIG pFlow;
    DWORD ModemStatus, Error;

    if ( !GetCommModemStatus(m_hDevice, &ModemStatus) ) {

        /*
         * We can't query the comm information; tell the primary thread
         * that we've aborted, and return error (will exit thread).
         */
        NotifyAbort(IDP_ERROR_GET_COMM_MODEM_STATUS);
        return(1);
    }

    /*
     *  Update modem status
     */
    m_Status.AsyncSignal = ModemStatus;

    /*
     *  Or in status of DTR and RTS
     */
    pFlow = &m_PdConfig.Params.Async.FlowControl;
    if ( pFlow->fEnableDTR )
        m_Status.AsyncSignal |= MS_DTR_ON;
    if ( pFlow->fEnableRTS )
        m_Status.AsyncSignal |= MS_RTS_ON;

    /*
     *  OR in new event mask
     */
    m_Status.AsyncSignalMask |= m_EventMask;

    /*
     *  Update async error counters
     */
    if ( m_EventMask & EV_ERR ) {
        (VOID) ClearCommError( m_hDevice, &Error, NULL );
        if ( Error & CE_OVERRUN )
            m_Status.Output.AsyncOverrunError++;
        if ( Error & CE_FRAME )
            m_Status.Input.AsyncFramingError++;
        if ( Error & CE_RXOVER )
            m_Status.Input.AsyncOverflowError++;
        if ( Error & CE_RXPARITY )
            m_Status.Input.AsyncParityError++;
    }

    /*
     * Tell the dialog that we've got some new status information.
     */
    ::PostMessage(m_hDlg, WM_ASYNCTESTSTATUSREADY, 0, 0);
    WaitForSingleObject(m_hConsumed, INFINITE);

    /*
     * Check for thread exit request.
     */
    if ( m_bExit )
        return(0);
    else
        return(-1);    

}  // end CATDlgInputThread::CommStatusAndNotify


/*******************************************************************************
 *
 *  PostInputRead - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Post a ReadFile operation for the device, processing as long as data
 *      is present.
 *
 *  ENTRY:
 *  EXIT:
 *      -1 if read operation posted sucessfully
 *      0 if ExitThread was requested by parent
 *      1 if error condition
 *
 ******************************************************************************/

int
CATDlgInputThread::PostInputRead()
{
    int iStat;

    /*
     * Post read for input data, processing immediataly if not 'pending'.
     */
    while ( ReadFile( m_hDevice, m_Buffer, MAX_COMMAND_LEN,
                   &m_BufferBytes, &m_OverlapRead ) ) {

        if ( (iStat = CommInputNotify()) != -1 )
            return(iStat);
    }

    /*
     *  Make sure read is pending (not some other error).
     */
    if ( GetLastError() != ERROR_IO_PENDING ) {

        NotifyAbort(IDP_ERROR_READ_FILE);
        return(1);
    }

    /*
     * Return 'posted sucessfully' status.
     */
    return(-1);

}  // end CATDlgInputThread::PostInputRead


/*******************************************************************************
 *
 *  PostStatusRead - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Post a WaitCommStatus operation for the device.
 *
 *  ENTRY:
 *  EXIT:
 *      -1 if status operation posted sucessfully
 *      1 if error condition
 *
 ******************************************************************************/

int
CATDlgInputThread::PostStatusRead()
{
    /*
     * Post read for comm status.
     */
    if ( !WaitCommEvent(m_hDevice, &m_EventMask, &m_OverlapSignal) ) {

        /*
         *  Make sure comm status read is pending (not some other error).
         */
        if ( GetLastError() != ERROR_IO_PENDING ) {

            NotifyAbort(IDP_ERROR_WAIT_COMM_EVENT);
            return(1);
        }
    }

    /*
     * Return 'posted sucessfully' status.
     */
    return(-1);

}  // end CATDlgInputThread::PostStatusRead
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\threads.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* threads.h
*
* interface of WINCFG thread classes
*
* copyright notice: Copyright 1994, Citrix Systems Inc.
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINCFG\VCS\THREADS.H  $
*  
*     Rev 1.8   18 Jun 1997 15:13:28   butchd
*  Hydrix split
*  
*     Rev 1.7   12 Sep 1996 16:16:46   butchd
*  update
*  
*******************************************************************************/

//#include <citrix\modem.h>   // for CITRIX MODEM.DLL
#define MAX_COMMAND_LEN   255

////////////////////////////////////////////////////////////////////////////////
// CThread class
//
class CThread
{

/*
 * Member variables.
 */
public:
    HANDLE m_hThread;
    DWORD m_dwThreadID;

/*
 * Implementation
 */
public:
    virtual ~CThread();
    void* operator new(size_t nSize);
    void operator delete(void* p);
protected:
    CThread();
    static DWORD __stdcall ThreadEntryPoint(LPVOID lpParam);
    virtual DWORD RunThread() = 0;

/*
 * Operations: primary thread
 */
public:
    HANDLE CreateThread( DWORD cbStack = 0,
                         DWORD fdwCreate = 0 );

};  // end CThread class interface
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// CATDlgInputThread class
//
#define MAX_STATUS_SEMAPHORE_COUNT 1
#define MAX_SLEEP_COUNT 10

class CATDlgInputThread : public CThread
{

/*
 * Member variables.
 */
public:
    HWND m_hDlg;
    HANDLE m_hDevice;
    PDCONFIG m_PdConfig;
    PROTOCOLSTATUS m_Status;
    BYTE m_Buffer[MAX_COMMAND_LEN+1];
    DWORD m_BufferBytes;
protected:
    DWORD m_ErrorStatus;
    HANDLE m_hConsumed;
    BOOL m_bExit;
    DWORD m_EventMask;
    OVERLAPPED m_OverlapSignal;
    OVERLAPPED m_OverlapRead;

/*
 * Implementation
 */
public:
    CATDlgInputThread();
protected:
    virtual ~CATDlgInputThread();
    virtual DWORD RunThread();

/*
 * Operations: primary thread.
 */
public:
    void SignalConsumed();
    void ExitThread();

/*
 * Operations: secondary thread.
 */
protected:
    void NotifyAbort( UINT idError );
    int CommInputNotify();
    int CommStatusAndNotify();
    int PostInputRead();
    int PostStatusRead();

};  // end CATDlgInputThread class interface
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\security.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* security.c
*
* WinStation ACL editing functions (based on code from NT PRINTMAN security.c)
*
* copyright notice: Copyright 1995, Citrix Systems Inc.
*
* $Author:   donm  $  Butch Davis
*
* $Log:   N:\nt\private\utils\citrix\winutils\tscfg\VCS\security.c  $
*
*     Rev 1.12   19 Mar 1998 16:38:40   donm
*  was looking for old help file
*
*     Rev 1.11   20 Sep 1996 20:37:18   butchd
*  update
*
*     Rev 1.10   19 Sep 1996 15:58:44   butchd
*  update
*
*     Rev 1.9   12 Sep 1996 16:16:38   butchd
*  update
*
*******************************************************************************/

/*
 * We must compile for UNICODE because of ACL edit structures & interface, which
 * is UNICODE-only.
 */
#ifndef UNICODE
#define UNICODE 1
#endif
#ifndef _UNICODE
#define _UNICODE 1
#endif

/*
 * include files
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tchar.h>
#include <wchar.h>
#include <sedapi.h>

#include <winsta.h>
#include "defines.h"
#include "resource.h"
#include "security.h"
#include "common.h"
#include <utildll.h>

/*
 * Global variables for WINUTILS Common functions.
 */
LPCTSTR WinUtilsAppName;
HWND WinUtilsAppWindow;
HINSTANCE WinUtilsAppInstance;

////////////////////////////////////////////////////////////////////////////////
// typedefs, defines, persistant storage, and private function prototypes

/*
 * Indexes into the APPLICATION_ACCESSES structure:
 */
#define PERMS_SPECIAL_QUERY         0       /* query information access */
#define PERMS_SPECIAL_SET           1       /* set information access */
#define PERMS_SPECIAL_RESET         2       /* reset access */
#define PERMS_SPECIAL_SHADOW        3       /* shadow access */
#define PERMS_SPECIAL_LOGON         4       /* logon access */
#define PERMS_SPECIAL_LOGOFF        5       /* logoff access */
#define PERMS_SPECIAL_MSG           6       /* message access */
#define PERMS_SPECIAL_CONNECT       7       /* connect access */
#define PERMS_SPECIAL_DISCONNECT    8       /* disconnect access */
#define PERMS_SPECIAL_DELETE        9       /* delete access */

#define PERMS_RESOURCE_NOACCESS     10      /* no access grouping */
#define PERMS_RESOURCE_GUEST        11      /* guest access grouping */
#define PERMS_RESOURCE_USER         12      /* user access grouping */
#define PERMS_RESOURCE_ADMIN        13      /* all (admin) access grouping */

#define PERMS_COUNT                 14      /* Total number of permissions */


/*
 * Typedefs and static storage.
 */
typedef struct _SECURITY_CONTEXT
{
    PWINSTATIONNAME      pWSName;
}
SECURITY_CONTEXT, *PSECURITY_CONTEXT;

/*
 * We need this structure even though we're not doing generic access mapping.
 */
GENERIC_MAPPING GenericMapping =
{                                   /* GenericMapping:             */
    GENERIC_READ,                   /*     GenericRead             */
    GENERIC_WRITE,                  /*     GenericWrite            */
    GENERIC_EXECUTE,                /*     GenericExecute          */
    GENERIC_ALL                     /*     GenericAll              */
};

WCHAR szLWinCfgHlp[] = L"TSCFG.HLP";
TCHAR szAclEdit[] = TEXT("ACLEDIT"); /* DLL containing ACL Edit Dialog */
char szSedDiscretionaryAclEditor[] = "SedDiscretionaryAclEditor";

LPWSTR pwstrWinStation = NULL;
LPWSTR pwstrSpecial = NULL;

#define IDD_BASE 0x20000    // makehelp.bat uses this base offset to form HIDD_ symbol
SED_HELP_INFO PermissionsHelpInfo =
{                                  /* HelpInfo                    */
    szLWinCfgHlp,
    IDD_HELP_PERMISSIONS_MAIN+IDD_BASE,
    IDD_HELP_PERMISSIONS_SPECIAL_ACCESS+IDD_BASE,
    0,
    IDD_HELP_PERMISSIONS_ADD_USER+IDD_BASE,
    IDD_HELP_PERMISSIONS_LOCAL_GROUP+IDD_BASE,
    IDD_HELP_PERMISSIONS_GLOBAL_GROUP+IDD_BASE,
    IDD_HELP_PERMISSIONS_FIND_ACCOUNT+IDD_BASE
};


SED_OBJECT_TYPE_DESCRIPTOR ObjectTypeDescriptor =
{
    SED_REVISION1,                 /* Revision                    */
    FALSE,                         /* IsContainer                 */
    FALSE,                         /* AllowNewObjectPerms         */
    FALSE,                         /* MapSpecificPermsToGeneric   */
    &GenericMapping,               /* GenericMapping              */
    NULL,                          /* GenericMappingNewObjects    */
    NULL,                          /* ObjectTypeName              */
    NULL,                          /* HelpInfo                    */
    NULL,                          /* ApplyToSubContainerTitle    */
    NULL,                          /* ApplyToObjectsTitle         */
    NULL,                          /* ApplyToSubContainerConfirmation */
    NULL,                          /* SpecialObjectAccessTitle    */
    NULL                           /* SpecialNewObjectAccessTitle */
};

/*
 * Application accesses passed to the discretionary ACL editor.
 */
SED_APPLICATION_ACCESS pDiscretionaryAccessGroup[PERMS_COUNT] =
{
    /* query (Special...)
     */
    {
        SED_DESC_TYPE_RESOURCE_SPECIAL,         /* Type                   */
        WINSTATION_QUERY,                       /* AccessMask1            */
        0,                                      /* AccessMask2            */
        NULL                                    /* PermissionTitle        */
    },

    /* set (Special...)
     */
    {
        SED_DESC_TYPE_RESOURCE_SPECIAL,
        WINSTATION_SET,
        0,
        NULL
    },

    /* reset (Special...)
     */
    {
        SED_DESC_TYPE_RESOURCE_SPECIAL,
        WINSTATION_RESET,
        0,
        NULL
    },

    /* shadow (Special...)
     */
    {
        SED_DESC_TYPE_RESOURCE_SPECIAL,
        WINSTATION_SHADOW,
        0,
        NULL
    },

    /* logon (Special...)
     */
    {
        SED_DESC_TYPE_RESOURCE_SPECIAL,
        WINSTATION_LOGON,
        0,
        NULL
    },

    /* logoff (Special...)
     */
    {
        SED_DESC_TYPE_RESOURCE_SPECIAL,
        WINSTATION_LOGOFF,
        0,
        NULL
    },

    /* message (Special...)
     */
    {
        SED_DESC_TYPE_RESOURCE_SPECIAL,
        WINSTATION_MSG,
        0,
        NULL
    },

    /* connect (Special...)
     */
    {
        SED_DESC_TYPE_RESOURCE_SPECIAL,
        WINSTATION_CONNECT,
        0,
        NULL
    },

    /* disconnect (Special...)
     */
    {
        SED_DESC_TYPE_RESOURCE_SPECIAL,
        WINSTATION_DISCONNECT,
        0,
        NULL
    },

    /* delete (Special...)
     */
    {
        SED_DESC_TYPE_RESOURCE_SPECIAL,
        DELETE,
        0,
        NULL
    },

    /* no access (grouping):
     */
    {
        SED_DESC_TYPE_RESOURCE,
        0,
        0,
        NULL
    },

    /* guest access (grouping)
     */
    {
        SED_DESC_TYPE_RESOURCE,
        WINSTATION_GUEST_ACCESS,
        0,
        NULL
    },

    /* user access (grouping)
     */
    {
        SED_DESC_TYPE_RESOURCE,
        WINSTATION_USER_ACCESS,
        0,
        NULL
    },

    /* administrator access (grouping)
     */
    {
        SED_DESC_TYPE_RESOURCE,
        GENERIC_ALL,        // maps to WINSTATION_ALL_ACCESS on WinStationOpen()
        0,
        NULL
    }
};

#define PRIV_SECURITY   0
#define PRIV_COUNT      1

LUID SecurityValue;

/*
 * Definitions from SEDAPI.H:
 * (unfortunately we have to do this if we want to link dynamically)
 */
typedef DWORD (WINAPI *SED_DISCRETIONARY_ACL_EDITOR)(
    HWND                         Owner,
    HANDLE                       Instance,
    LPWSTR                       Server,
    PSED_OBJECT_TYPE_DESCRIPTOR  ObjectType,
    PSED_APPLICATION_ACCESSES    ApplicationAccesses,
    LPWSTR                       ObjectName,
    PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
    ULONG                        CallbackContext,
    PSECURITY_DESCRIPTOR         SecurityDescriptor,
    BOOLEAN                      CouldntReadDacl,
    BOOLEAN                      CantWriteDacl,
    LPDWORD                      SEDStatusReturn,
    DWORD                        Flags
);

SED_DISCRETIONARY_ACL_EDITOR  lpfnSedDiscretionaryAclEditor = NULL;

/*
 * Private function prototypes (public prototypes are in security.h).
 */
DWORD SetWinStationSecurity( PWINSTATIONNAME pWSName,
                             PSECURITY_DESCRIPTOR pSecurityDescriptor );
DWORD ValidateSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor);
FARPROC LoadLibraryGetProcAddress( HWND hwnd,
                                   LPTSTR LibraryName,
                                   LPCSTR ProcName,
                                   PHANDLE phLibrary );
void InitializeSecurityStrings( );
VOID ReportSecurityFailure(HWND hwnd, DWORD ErrorResource, LPCTSTR String, DWORD Error);
LPVOID AllocSplMem( DWORD cb );
BOOL FreeSplMem( LPVOID pMem );
LPWSTR GetUnicodeString( int id );
DWORD WINAPI SedCallback( HWND                 hwndParent,
                          HANDLE               hInstance,
                          ULONG                CallBackContext,
                          PSECURITY_DESCRIPTOR pNewSecurityDescriptor,
                          PSECURITY_DESCRIPTOR pSecDescNewObjects,
                          BOOLEAN              ApplyToSubContainers,
                          BOOLEAN              ApplyToSubObjects,
                          LPDWORD              StatusReturn );


////////////////////////////////////////////////////////////////////////////////
// public functions

/*******************************************************************************
 *
 *  CallPermissionsDialog (public function)
 *
 *      Call the SedDiscretionaryAclEditor() function in ACLEDIT dll.
 *
 *  ENTRY:
 *      hwnd (input)
 *          window handle of parent for ACL edit dialog.
 *      bAdmin (input)
 *          TRUE if user is an Administrator (can write to WinStation registry)
 *          FALSE otherwise (permissions will be read-only).
 *      pWSName (input)
 *          Name of WinStation to edit security for.
 *  EXIT:
 *      (BOOL) TRUE if any winstations were modified; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CallPermissionsDialog( HWND hwnd,
                       BOOL bAdmin,
                       PWINSTATIONNAME pWSName )
{
    SECURITY_CONTEXT            SecurityContext;
    BOOLEAN                     CantWriteDacl;
    SED_APPLICATION_ACCESSES    ApplicationAccesses;
    HANDLE                      hLibrary;
    PSECURITY_DESCRIPTOR        pSecurityDescriptor;
    DWORD                       Status = SED_STATUS_NOT_MODIFIED;
    DWORD                       Error;
    HCURSOR                     hOldCursor;

    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /*
     * Get the current WinStation security
     */
    if ( (Error = GetWinStationSecurity(pWSName, &pSecurityDescriptor)) != ERROR_SUCCESS ) {

        ReportSecurityFailure( hwnd,
                               IDP_ERROR_GET_SECURITY_WINSTATION,
                               pWSName, Error );

        SetCursor(hOldCursor);
        return(FALSE);
    }

    /*
     * If we're not allowed access to write to WinStation registry, flag such.
     */
    CantWriteDacl = !(BOOL)bAdmin;

    if( !lpfnSedDiscretionaryAclEditor )
        lpfnSedDiscretionaryAclEditor =
            (SED_DISCRETIONARY_ACL_EDITOR)LoadLibraryGetProcAddress(
                hwnd, szAclEdit, szSedDiscretionaryAclEditor, &hLibrary);

    if( lpfnSedDiscretionaryAclEditor )
    {
        InitializeSecurityStrings( );

        ObjectTypeDescriptor.ObjectTypeName = pwstrWinStation;

        /*
         * Pass all the permissions to the ACL editor,
         * and set up the type required:
         */
        ApplicationAccesses.Count = PERMS_COUNT;
        ApplicationAccesses.AccessGroup = pDiscretionaryAccessGroup;
        ApplicationAccesses.DefaultPermName =
            pDiscretionaryAccessGroup[PERMS_RESOURCE_USER].PermissionTitle;

        ObjectTypeDescriptor.HelpInfo = &PermissionsHelpInfo;
        ObjectTypeDescriptor.SpecialObjectAccessTitle = pwstrSpecial;

        SecurityContext.pWSName = pWSName;
        Error = (*lpfnSedDiscretionaryAclEditor )
            (hwnd, NULL, NULL, &ObjectTypeDescriptor,
             &ApplicationAccesses, pWSName,
             (PSED_FUNC_APPLY_SEC_CALLBACK)SedCallback,
             (ULONG)&SecurityContext,
             pSecurityDescriptor,
             FALSE, CantWriteDacl,
             &Status, 0);

        if( Error != ERROR_SUCCESS )
            ReportSecurityFailure(hwnd, IDP_ERROR_PERMISSIONS_EDITOR_FAILED, NULL, Error);
    }

    SetCursor(hOldCursor);
    LocalFree(pSecurityDescriptor);

    return( ((Status == SED_STATUS_NOT_MODIFIED) ||
             (Status == SED_STATUS_NOT_ALL_MODIFIED)) ? FALSE : TRUE );

}  // end CallPermissionsDialog


/*******************************************************************************
 *
 *  GetWinStationSecurityA (public function - ANSI stub)
 *
 *      (see GetWinStationSecurityW)
 *
 *  ENTRY:
 *      (see GetWinStationSecurityW)
 *  EXIT:
 *      (see GetWinStationSecurityW)
 *
 ******************************************************************************/

DWORD
GetWinStationSecurityA( PWINSTATIONNAMEA pWSName,
                        PSECURITY_DESCRIPTOR *ppSecurityDescriptor )
{
    WINSTATIONNAMEW WSNameW;

    /*
     * Copy ANSI WinStation name to UNICODE and call GetWinStationNameW().
     */
    mbstowcs(WSNameW, pWSName, sizeof(WSNameW));

    return( GetWinStationSecurityW(WSNameW, ppSecurityDescriptor) );

}  // GetWinStationSecurityA


/*******************************************************************************
 *
 *  GetWinStationSecurityW (public function - UNICODE)
 *
 *      Obtain the security descriptor for the specified WinStation.  If the
 *      WinStation does not have a security descriptor associated with it,
 *      will quietly call GetDefaultWinStationSecurity() to get the default
 *      security descriptor for it.
 *
 *  ENTRY:
 *      pWSName (input)
 *          UNICODE name of WinStation to get security descriptor for.
 *      ppSecurityDescriptor (output)
 *          on success, set to pointer to allocated memory containing the
 *          WinStation's security descriptor.
 *  EXIT:
 *      ERROR_SUCCESS if all is OK; error code and *pSecurityDescriptor set to
 *      NULL if error.
 *
 *  NOTE: on success, the memory pointed to by *ppSecurityDescriptor should be
 *        LocalFree()'d by the caller when the security descriptor is no longer
 *        needed.
 *
 ******************************************************************************/

DWORD
GetWinStationSecurityW( PWINSTATIONNAMEW pWSName,
                        PSECURITY_DESCRIPTOR *ppSecurityDescriptor )
{
    DWORD Error, SDLength, SDLengthRequired;

    *ppSecurityDescriptor = NULL;
    if ( (Error = RegWinStationQuerySecurity( SERVERNAME_CURRENT,
                                              pWSName,
                                              NULL,
                                              0, &SDLengthRequired ))
                                        == ERROR_INSUFFICIENT_BUFFER ) {

        if ( !(*ppSecurityDescriptor =
                (PSECURITY_DESCRIPTOR)LocalAlloc(
                                        0, SDLength = SDLengthRequired)) ) {

            Error = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            Error = RegWinStationQuerySecurity( SERVERNAME_CURRENT,
                                                pWSName,
                                                *ppSecurityDescriptor,
                                                SDLength, &SDLengthRequired );
        }

    } else {

        /*
         * Unexpected error.  If 'not found', fetch the default WinStation SD.
         */
        if ( Error == ERROR_FILE_NOT_FOUND )
            return( GetDefaultWinStationSecurity(ppSecurityDescriptor) );
    }

    /*
     * Check for a valid SD before returning.
     */
    if ( Error == ERROR_SUCCESS ) {

        Error = ValidateSecurityDescriptor(*ppSecurityDescriptor);

    } else if ( *ppSecurityDescriptor ) {

        LocalFree(*ppSecurityDescriptor);
        *ppSecurityDescriptor = NULL;
    }

    return(Error);

}  // GetWinStationSecurityW


/*******************************************************************************
 *
 *  GetDefaultWinStationSecurity (public function)
 *
 *      Obtain the default WinStation security descriptor.
 *
 *  ENTRY:
 *      ppSecurityDescriptor (output)
 *          on success, set to pointer to allocated memory containing the
 *          default WinStation security descriptor.
 *  EXIT:
 *      ERROR_SUCCESS if all is OK; error code and *pSecurityDescriptor set to
 *      NULL if error.
 *
 *  NOTE: on success, the memory pointed to by *ppSecurityDescriptor should be
 *        LocalFree()'d by the caller when the security descriptor is no longer
 *        needed.
 *
 ******************************************************************************/

DWORD
GetDefaultWinStationSecurity( PSECURITY_DESCRIPTOR *ppSecurityDescriptor )
{
    DWORD Error, SDLength, SDLengthRequired;

    *ppSecurityDescriptor = NULL;
    if ( (Error = RegWinStationQueryDefaultSecurity( SERVERNAME_CURRENT,
                                                     NULL,
                                                     0, &SDLengthRequired ))
                                == ERROR_INSUFFICIENT_BUFFER ) {

        if ( !(*ppSecurityDescriptor =
                (PSECURITY_DESCRIPTOR)LocalAlloc(
                                        0, SDLength = SDLengthRequired)) ) {

            Error = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            Error = RegWinStationQueryDefaultSecurity( SERVERNAME_CURRENT,
                                                       *ppSecurityDescriptor,
                                                       SDLength, &SDLengthRequired );
        }
    }

    /*
     * Check for a valid SD before returning.
     */
    if ( Error == ERROR_SUCCESS ) {

        Error = ValidateSecurityDescriptor(*ppSecurityDescriptor);

    } else if ( *ppSecurityDescriptor ) {

        LocalFree(*ppSecurityDescriptor);
        *ppSecurityDescriptor = NULL;
    }

    return(Error);

}  // GetDefaultWinStationSecurity


/*******************************************************************************
 *
 *  FreeSecurityStrings (public function)
 *
 *      Free allocated memory for ACL edit string resources.  This function
 *      should be called when the application exits.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
FreeSecurityStrings( )
{
    /*
     * Only perform free if the strings have been allocated and loaded.
     */
    if( pwstrWinStation )
    {
        FreeSplMem(pwstrWinStation);
        FreeSplMem(pwstrSpecial);

        FreeSplMem(pDiscretionaryAccessGroup[PERMS_SPECIAL_QUERY].PermissionTitle);
        FreeSplMem(pDiscretionaryAccessGroup[PERMS_SPECIAL_SET].PermissionTitle);
        FreeSplMem(pDiscretionaryAccessGroup[PERMS_SPECIAL_RESET].PermissionTitle);
        FreeSplMem(pDiscretionaryAccessGroup[PERMS_SPECIAL_SHADOW].PermissionTitle);
        FreeSplMem(pDiscretionaryAccessGroup[PERMS_SPECIAL_LOGON].PermissionTitle);
        FreeSplMem(pDiscretionaryAccessGroup[PERMS_SPECIAL_LOGOFF].PermissionTitle);
        FreeSplMem(pDiscretionaryAccessGroup[PERMS_SPECIAL_MSG].PermissionTitle);
        FreeSplMem(pDiscretionaryAccessGroup[PERMS_SPECIAL_CONNECT].PermissionTitle);
        FreeSplMem(pDiscretionaryAccessGroup[PERMS_SPECIAL_DISCONNECT].PermissionTitle);
        FreeSplMem(pDiscretionaryAccessGroup[PERMS_SPECIAL_DELETE].PermissionTitle);
        FreeSplMem(pDiscretionaryAccessGroup[PERMS_RESOURCE_NOACCESS].PermissionTitle);
        FreeSplMem(pDiscretionaryAccessGroup[PERMS_RESOURCE_GUEST].PermissionTitle);
        FreeSplMem(pDiscretionaryAccessGroup[PERMS_RESOURCE_USER].PermissionTitle);
        FreeSplMem(pDiscretionaryAccessGroup[PERMS_RESOURCE_ADMIN].PermissionTitle);
    }

}  // end FreeSecurityStrings


////////////////////////////////////////////////////////////////////////////////
// private  functions

/*******************************************************************************
 *
 *  InitializeSecurityStrings (private function)
 *
 *      Allocate and load ACL editing string resources if not done already.
 *      The application should call the public FreeSecurityStrings() function
 *      to free allocated memory when the application exits.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
InitializeSecurityStrings()
{
    if( !pwstrWinStation )
    {
        pwstrWinStation = GetUnicodeString(IDS_WINSTATION);
        pwstrSpecial = GetUnicodeString(IDS_SPECIALACCESS);

        pDiscretionaryAccessGroup[PERMS_SPECIAL_QUERY].PermissionTitle =
            GetUnicodeString(IDS_PERMS_SPECIAL_QUERY);

        pDiscretionaryAccessGroup[PERMS_SPECIAL_SET].PermissionTitle =
            GetUnicodeString(IDS_PERMS_SPECIAL_SET);

        pDiscretionaryAccessGroup[PERMS_SPECIAL_RESET].PermissionTitle =
            GetUnicodeString(IDS_PERMS_SPECIAL_RESET);

        pDiscretionaryAccessGroup[PERMS_SPECIAL_SHADOW].PermissionTitle =
            GetUnicodeString(IDS_PERMS_SPECIAL_SHADOW);

        pDiscretionaryAccessGroup[PERMS_SPECIAL_LOGON].PermissionTitle =
            GetUnicodeString(IDS_PERMS_SPECIAL_LOGON);

        pDiscretionaryAccessGroup[PERMS_SPECIAL_LOGOFF].PermissionTitle =
            GetUnicodeString(IDS_PERMS_SPECIAL_LOGOFF);

        pDiscretionaryAccessGroup[PERMS_SPECIAL_MSG].PermissionTitle =
            GetUnicodeString(IDS_PERMS_SPECIAL_MSG);

        pDiscretionaryAccessGroup[PERMS_SPECIAL_CONNECT].PermissionTitle =
            GetUnicodeString(IDS_PERMS_SPECIAL_CONNECT);

        pDiscretionaryAccessGroup[PERMS_SPECIAL_DISCONNECT].PermissionTitle =
            GetUnicodeString(IDS_PERMS_SPECIAL_DISCONNECT);

        pDiscretionaryAccessGroup[PERMS_SPECIAL_DELETE].PermissionTitle =
            GetUnicodeString(IDS_PERMS_SPECIAL_DELETE);

        pDiscretionaryAccessGroup[PERMS_RESOURCE_NOACCESS].PermissionTitle =
            GetUnicodeString(IDS_PERMS_RESOURCE_NOACCESS);

        pDiscretionaryAccessGroup[PERMS_RESOURCE_GUEST].PermissionTitle =
            GetUnicodeString(IDS_PERMS_RESORUCE_GUEST);

        pDiscretionaryAccessGroup[PERMS_RESOURCE_USER].PermissionTitle =
            GetUnicodeString(IDS_PERMS_RESORUCE_USER);

        pDiscretionaryAccessGroup[PERMS_RESOURCE_ADMIN].PermissionTitle =
            GetUnicodeString(IDS_PERMS_RESOURCE_ADMIN);
    }

}  // end InitializeSecurityStrings


/*******************************************************************************
 *
 *  ReportSecurityFailure (private function)
 *
 *      Output an appropriate error message for security failure.
 *
 *  ENTRY:
 *      hwnd (input)
 *          window handle of parent for message box.
 *      ErrorResource (input)
 *          resource ID of error format string.
 *      String (input)
 *          If not NULL, points to string to output as part of message.
 *      Error (input)
 *          Error code
 *  EXIT:
 *
 *  NOTE: all ErrorResource format strings should specify a %d for Error code
 *        and %S for system error message string as the last two substitution
 *        arguments.  The %S is optional, and must be present in the format
 *        string if the String argument is non-NULL.
 *
 ******************************************************************************/

VOID
ReportSecurityFailure(HWND hwnd, DWORD ErrorResource, LPCTSTR String, DWORD Error)
{
    HWND hwndSave = WinUtilsAppWindow;

    /*
     * Set parent window in WinUtilsAppWindow global for use
     * by STANDARD_ERROR_MESSAGE macro (StandardErrorMessage function).
     */
    WinUtilsAppWindow = hwnd;

    if ( String )
        STANDARD_ERROR_MESSAGE((WINAPPSTUFF, LOGONID_NONE, Error, ErrorResource, String))
    else
        STANDARD_ERROR_MESSAGE((WINAPPSTUFF, LOGONID_NONE, Error, ErrorResource))

    /*
     * Restore original WinUtilsAppWindow to global.
     */
    WinUtilsAppWindow = hwndSave;

}  // end ReportSecurityFailure


/*******************************************************************************
 *
 *  SedCallback (private function)
 *
 *      Callback function from ACL edit dialog DLL
 *
 *  ENTRY:
 *      (see sedapi.h)
 *  EXIT:
 *      (see sedapi.h)
 *
 ******************************************************************************/

DWORD WINAPI
SedCallback( HWND hwndParent,
             HANDLE hInstance,
             ULONG CallBackContext,
             PSECURITY_DESCRIPTOR pUpdatedSecurityDescriptor,
             PSECURITY_DESCRIPTOR pSecDescNewObjects,
             BOOLEAN ApplyToSubContainers,
             BOOLEAN ApplyToSubObjects,
             LPDWORD StatusReturn )
{
    WINSTATIONNAME          WSName;
    PSECURITY_CONTEXT       pSecurityContext;
    DWORD                   Error;
    BOOL                    OK = TRUE;

    pSecurityContext = (PSECURITY_CONTEXT)CallBackContext;

    /*
     * Apply security to the WinStation.
     */
    lstrcpy(WSName, pSecurityContext->pWSName);
    if ( (Error = SetWinStationSecurity( WSName,
                                         pUpdatedSecurityDescriptor))
                                != ERROR_SUCCESS ) {

        ReportSecurityFailure( hwndParent,
                               IDP_ERROR_SET_SECURITY_WINSTATION,
                               WSName,
                               Error );
        OK = FALSE;
        *StatusReturn = SED_STATUS_NOT_ALL_MODIFIED;
    }

    if ( OK == TRUE )
        *StatusReturn = SED_STATUS_MODIFIED;

    return( OK ? 0 : 1 );

}  // end SedCallback


/*******************************************************************************
 *
 *  LoadLibraryGetProcAddress (private function)
 *
 *      Load the specified library and retrieve FARPROC pointer to specified
 *      procedure's entry point.
 *
 *  ENTRY:
 *      hwnd (input)
 *          window handle of owner for error message display
 *      LibraryName (input)
 *          name of library dll to load
 *      ProcName (input)
 *          name of library procedure to reference
 *      phLibrary (output)
 *          set to handle of loaded library on return
 *  EXIT:
 *      FARPROC pointer to library procedure's entry point.
 *
 ******************************************************************************/

FARPROC
LoadLibraryGetProcAddress(  HWND hwnd,
                            LPTSTR LibraryName,
                            LPCSTR ProcName,
                            PHANDLE phLibrary )
{
    HANDLE  hLibrary;
    FARPROC lpfn = NULL;

    hLibrary = LoadLibrary(LibraryName);

    if ( hLibrary ) {

        lpfn = GetProcAddress(hLibrary, ProcName);

        if(!lpfn) {

            ERROR_MESSAGE(( IDP_ERROR_COULDNOTFINDPROCEDURE,
                            ProcName, LibraryName ))
            FreeLibrary(hLibrary);
        }

    } else
        ERROR_MESSAGE((IDP_ERROR_COULDNOTLOADLIBRARY, LibraryName))

    *phLibrary = hLibrary;

    return(lpfn);

}  // end LoadLibraryGetProcAddress


/*******************************************************************************
 *
 *  AllocSplMem (private function)
 *
 *      Allocate and zero-fill specified amount of memory.
 *
 *  ENTRY:
 *      cb (input)
 *          number of bytes to allocate
 *  EXIT:
 *      LPVOID pointer to allocated memory; NULL if error.
 *
 ******************************************************************************/

LPVOID
AllocSplMem( DWORD cb )
{
    return(LocalAlloc(LPTR, cb));

}  // end AllocSplMem


/*******************************************************************************
 *
 *  FreeSplMem (private function)
 *
 *      Free the specified memory block.
 *
 *  ENTRY:
 *      pMem (input)
 *          memory to free
 *  EXIT:
 *      TRUE if sucess; FALSE if error.
 *
 ******************************************************************************/

BOOL
FreeSplMem( LPVOID pMem )
{
    return( LocalFree((HLOCAL)pMem) == NULL );

}  // end FreeSplMem


/*******************************************************************************
 *
 *  GetUnicodeString (private function)
 *
 *      Load a resource string and allocate/save in memory block.
 *
 *  ENTRY:
 *      id (input)
 *          resource id of string to get
 *  EXIT:
 *      pointer to allocated and loaded UNICODE string
 *
 ******************************************************************************/

LPWSTR
GetUnicodeString(int id)
{
    WCHAR ResString[256];
    DWORD length = 0;
    LPWSTR pUnicode;
    DWORD  cbUnicode;

    length = LoadStringW(NULL, id, ResString, 256);

    cbUnicode = (length * sizeof(WCHAR)) + sizeof(WCHAR);
    pUnicode = AllocSplMem(cbUnicode);

    if( pUnicode )
        memcpy(pUnicode, ResString, cbUnicode);

    return(pUnicode);

}  // end GetUnicodeString


/*******************************************************************************
 *
 *  ValidateSecurityDescriptor (private function)
 *
 *      Check the specified security descriptor for valid structure as well as
 *      valid ACLs and SIDs.
 *
 *  ENTRY:
 *      pSecurityDescriptor (input)
 *          Security descriptor to validate.
 *  EXIT:
 *      ERROR_SUCCESS if valid; error otherwise.
 *
 ******************************************************************************/

DWORD
ValidateSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    DWORD Error = ERROR_SUCCESS;

    if ( !IsValidSecurityDescriptor(pSecurityDescriptor) ) {

        Error = GetLastError();

    } else {

        BOOL bAclPresent, bDefaulted;
        PACL pACL;
        PSID pSID;

        for ( ; ; ) {

            if ( !GetSecurityDescriptorDacl( pSecurityDescriptor,
                                             &bAclPresent, &pACL, &bDefaulted ) ) {
                Error = GetLastError();
                break;
            }
            if ( bAclPresent && pACL )
                if ( !IsValidAcl(pACL) ) {
                    Error = GetLastError();
                    break;
                }

            if ( !GetSecurityDescriptorSacl( pSecurityDescriptor,
                                             &bAclPresent, &pACL, &bDefaulted ) ) {
                Error = GetLastError();
                break;
            }
            if ( bAclPresent && pACL )
                if ( !IsValidAcl(pACL) ) {
                    Error = GetLastError();
                    break;
                }

            if ( !GetSecurityDescriptorOwner( pSecurityDescriptor,
                                              &pSID, &bDefaulted ) ) {
                Error = GetLastError();
                break;
            }
            if ( pSID )
                if ( !IsValidSid(pSID) ) {
                    Error = GetLastError();
                    break;
                }

            if ( !GetSecurityDescriptorGroup( pSecurityDescriptor,
                                              &pSID, &bDefaulted ) ) {
                Error = GetLastError();
                break;
            }
            if ( pSID )
                if ( !IsValidSid(pSID) ) {
                    Error = GetLastError();
                    break;
                }

            break;
        }
    }

    return(Error);

}  // end ValidateSecurityDescriptor


/*******************************************************************************
 *
 *  SetWinStationSecurity (private function)
 *
 *      Set the specified WinStation's registry and kernel object security.
 *
 *  ENTRY:
 *      pWSName (input)
 *          Name of WinStation to set security for.
 *      pSecurityDescriptor (input)
 *          Security descriptor to set for winstation.
 *  EXIT:
 *      ERROR_SUCCESS if valid; error otherwise.
 *
 ******************************************************************************/

DWORD
SetWinStationSecurity( PWINSTATIONNAME pWSName,
                       PSECURITY_DESCRIPTOR pSecurityDescriptor )
{
    DWORD   Error = ERROR_SUCCESS;

    Error = RegWinStationSetSecurity( SERVERNAME_CURRENT,
                                      pWSName,
                                      pSecurityDescriptor,
                                      GetSecurityDescriptorLength(pSecurityDescriptor) );

    return(Error);

}  // SetWinStationSecurity
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\tscfgext.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*******************************************************************************
*
* tscfgext.h
*
* some definitions for TSCFG extension DLLs
*
* copyright notice: Copyright 1998, Citrix Systems Inc.
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tscfg\VCS\tscfgext.h  $
*  
*     Rev 1.0   18 Apr 1998 15:30:22   donm
*  Initial revision.
*  
*******************************************************************************/

#ifndef __TSCFGEXT_H
#define __TSCFGEXT_H

// capability flags
const ULONG WDC_CLIENT_DRIVE_MAPPING            = 0x00000001;
const ULONG WDC_WIN_CLIENT_PRINTER_MAPPING      = 0x00000002;
const ULONG WDC_CLIENT_LPT_PORT_MAPPING         = 0x00000004;
const ULONG WDC_CLIENT_COM_PORT_MAPPING         = 0x00000008;
const ULONG WDC_CLIENT_CLIPBOARD_MAPPING        = 0x00000010;
const ULONG WDC_CLIENT_AUDIO_MAPPING            = 0x00000020;
const ULONG WDC_SHADOWING                       = 0x00000040;
const ULONG WDC_PUBLISHED_APPLICATIONS          = 0x00000080;

const ULONG WDC_CLIENT_DIALOG_MASK = 
                                WDC_CLIENT_DRIVE_MAPPING | 
                                WDC_WIN_CLIENT_PRINTER_MAPPING |
                                WDC_CLIENT_LPT_PORT_MAPPING |
                                WDC_CLIENT_COM_PORT_MAPPING |
                                WDC_CLIENT_CLIPBOARD_MAPPING |
                                WDC_CLIENT_AUDIO_MAPPING;


const ULONG WDC_CLIENT_CONNECT_MASK = 
                                WDC_CLIENT_DRIVE_MAPPING |
                                WDC_WIN_CLIENT_PRINTER_MAPPING |
                                WDC_CLIENT_LPT_PORT_MAPPING;

#endif // __TSCFGEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\wincfg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* wincfg.cpp
*
* WinStation Configuration application
*
* copyright notice: Copyright 1996, Citrix Systems Inc.
*
* $Author:   donm  $  Butch Davis
*
* $Log:   N:\nt\private\utils\citrix\winutils\tscfg\VCS\wincfg.cpp  $
*  
*     Rev 1.34   24 Apr 1998 09:44:28   donm
*  removed command line options
*  
*     Rev 1.33   18 Apr 1998 15:31:42   donm
*  Added capability bits
*  
*     Rev 1.32   14 Feb 1998 11:22:38   donm
*  fixed memory leak by avoiding CDocManager::OpenDocumentFile
*  
*     Rev 1.31   26 Jan 1998 18:33:04   thanhl
*  Save CharSet Font info
*  
*     Rev 1.30   13 Jan 1998 14:08:38   donm
*  gets encryption levels from extension DLL
*  
*     Rev 1.29   10 Dec 1997 15:59:28   donm
*  added ability to have extension DLLs
*  
*     Rev 1.28   26 Sep 1997 19:05:06   butchd
*  Hydra registry name changes
*  
*     Rev 1.27   02 Jul 1997 15:21:10   butchd
*  update
*  
*     Rev 1.26   27 Jun 1997 15:58:42   butchd
*  Registry changes for Wds/Tds/Pds/Cds
*  
*******************************************************************************/

/*
 * include files
 */
#include "stdafx.h"
#include "wincfg.h"

#include "mainfrm.h"
#include "rowview.h"
#include "appsvdoc.h"
#include "appsvvw.h"

#include "security.h"
#include <errno.h>
#include <hydra\regapi.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/*
 * Global command line variables.
 */
extern USHORT  g_Add;

/*
 * Global variables for WINUTILS Common functions.
 */
extern "C" {
LPCTSTR WinUtilsAppName = NULL;
HWND WinUtilsAppWindow = NULL;
HINSTANCE WinUtilsAppInstance = NULL;
}

////////////////////////////////////////////////////////////////////////////////
// CWincfgApp class implementation / construction, destruction

/*******************************************************************************
 *
 *  CWincfgApp - CWincfgApp constructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CWincfgApp::CWincfgApp()
    : m_pszRegWinStationCreate(TEXT("RegWinStationCreate")),
      m_pszRegWinStationSetSecurity(TEXT("RegWinStationSetSecurity")),
      m_pszRegWinStationQuery(TEXT("RegWinStationQuery")),
      m_pszRegWinStationDelete(TEXT("RegWinStationDelete")),
      m_pszGetDefaultWinStationSecurity(TEXT("GetDefaultWinStationSecurity")),
      m_pszGetWinStationSecurity(TEXT("GetWinStationSecurity"))
{
}  // end CWincfgApp::CWincfgApp


////////////////////////////////////////////////////////////////////////////////
// The one and only CWincfgApp object and a application-global reference to it.

CWincfgApp theApp;
CWincfgApp *pApp = &theApp;
BOOL AreWeRunningTerminalServices(void);


////////////////////////////////////////////////////////////////////////////////
// CWincfgApp overrides of MFC CWinApp class

/*******************************************************************************
 *
 *  InitInstance - CWincfgApp member function: CWinApp override
 *
 *      Perform application initialization and previous state restoration.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL)
 *          TRUE if initialization sucessful; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CWincfgApp::InitInstance()
{

		
	//Check if we are running under Terminal Server
	if(!AreWeRunningTerminalServices())
	{
	    AfxMessageBox(IDS_ERROR_NOT_TS,MB_OK |MB_ICONSTOP );
	    return FALSE;
	}

    if(FAILED(CoInitialize(NULL)))
        return FALSE;
    /*
     * Initialize the global WINUTILS app name and instance variables.
     */
    WinUtilsAppName = AfxGetAppName();
    WinUtilsAppInstance = AfxGetInstanceHandle();

    /*
     * Fetch and save the Computer Name as the local AppServer and current
     * AppServer.
     */
    DWORD   cchBuffer = MAX_COMPUTERNAME_LENGTH+1;
    m_szLocalAppServer[0] = m_szLocalAppServer[1] = TEXT('\\');
    GetComputerName(m_szLocalAppServer+2, &cchBuffer);
    lstrcpy(m_szCurrentAppServer, m_szLocalAppServer);

    /*
     * Load the system console string for rapid comparison in the 'IsAllowed'
     * functions.
     */
    LoadString( m_hInstance, IDS_SYSTEM_CONSOLE_NAME,
                m_szSystemConsole, WINSTATIONNAME_LENGTH );

    /*
     * Default to 'help allowed'.
     */
    m_bAllowHelp = TRUE;

    /*
     * Initialize the application defaults.
     */
    if ( !Initialize() )
        return(FALSE);

    /*
     * Register the application's document templates.  Document templates
     * serve as the connection between documents, frame windows and views.
     */
    CSingleDocTemplate *pTemplate =  new CSingleDocTemplate( IDR_MAINFRAME,
                                            RUNTIME_CLASS(CAppServerDoc),
                                            RUNTIME_CLASS(CMainFrame),
                                            RUNTIME_CLASS(CAppServerView) );

    if(!pTemplate) return(FALSE);

    AddDocTemplate(pTemplate);

    /*
     * open the initial document window for the current (default local) AppServer.
     * NOTE: We can't call CWinApp::OpenDocumentFile because it causes
     * a memory leek in SHELL32.DLL SHGetFileInfo since we were trying to
     * pass the server name (i.e. \\MYSERVER) as the file name.
     * CWinApp::OpenDocumentFile will trap if we pass a NULL, therefore
     * we call CSingleDocTemplate::OpenDocumentFile which can handle
     * a NULL.
     */
    if(!pTemplate->OpenDocumentFile(NULL)) {
        Terminate();
        return(FALSE);

    } else {

        CAppServerDoc *pDoc =
            (CAppServerDoc *)((CFrameWnd *)m_pMainWnd)->GetActiveDocument();

        /*
         * Initialize the global WINUTILS app window handle.
         */
        WinUtilsAppWindow = m_pMainWnd->m_hWnd;

#ifdef USING_3DCONTROLS
        Enable3dControls();
#endif

        /*
         * Take care of special command line flags (only one allowed
         * at a time).
         */
        if ( g_Add )
            m_pMainWnd->PostMessage(WM_ADDWINSTATION);

        return(TRUE);
    }

}  // end CWincfgApp::InitInstance


/*******************************************************************************
 *
 *  AddToRecentFileList - CWincfgApp member function: override
 *
 *      Suppress the adding of MRU file names to .INI file.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CWinApp::AddToRecentFileList documentation)
 *
 ******************************************************************************/

void
CWincfgApp::AddToRecentFileList( const char * pszPathName )
{
    /*
     * Don't do anything: we don't use a MRU or .INI file.
     */

}  // end CWincfgApp::AddToRecentFileList


////////////////////////////////////////////////////////////////////////////////
// CWincfgApp Operations
    
static TCHAR BASED_CODE szWincfgAppKey[] = REG_SOFTWARE_TSERVER TEXT("\\TSCFG");
static TCHAR BASED_CODE szPlacement[] = TEXT("Placement");
static TCHAR BASED_CODE szPlacementFormat[] = TEXT("%u,%u,%d,%d,%d,%d,%d,%d,%d,%d");
static TCHAR BASED_CODE szFont[] = TEXT("Font");
static TCHAR BASED_CODE szFontFace[] = TEXT("FontFace");
static TCHAR BASED_CODE szFontFormat[] = TEXT("%ld,%ld,%d,%d,%d,%d");
static TCHAR BASED_CODE szConfirm[] = TEXT("Confirmation");
static TCHAR BASED_CODE szSaveSettings[] = TEXT("SaveSettingsOnExit");
static TCHAR BASED_CODE szHexBase[] = TEXT("HexBase");

static CHAR szStart[] = "ExtStart";
static CHAR szEnd[] = "ExtEnd";
static CHAR szDialog[] = "ExtDialog";
static CHAR szDeleteObject[] = "ExtDeleteObject";
static CHAR szDupObject[] = "ExtDupObject";
static CHAR szRegQuery[] = "ExtRegQuery";
static CHAR szRegCreate[] = "ExtRegCreate";
static CHAR szRegDelete[] = "ExtRegDelete";
static CHAR szCompareObjects[] = "ExtCompareObjects";
static CHAR szEncryptionLevels[] = "ExtEncryptionLevels";
static CHAR szGetCapabilities[] = "ExtGetCapabilities";


/*******************************************************************************
 *
 *  Initialize - CWincfgApp member function: private operation
 *
 *      Restore state settings from app's profile and initialize the
 *      Pd and Wd lists.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL) TRUE if initialization sucessful; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CWincfgApp::Initialize()
{
    LONG Status;
    ULONG Index, Index2, ByteCount, Entries, Entries2;
    PDNAME PdKey;
    WDNAME WdKey;
    LONG QStatus;
    PTERMLOBJECT pWdListObject;
    WDCONFIG2 WdConfig;
    CObList *pTdList, *pPdList;
    PPDLOBJECT pPdListObject;
    PDCONFIG3 PdConfig;
    TCHAR WdDll[MAX_PATH];

    /*
     * Fetch the application's profile information.
     */
    GetAppProfileInfo();

    /*
     * Set up the application's font.
     */
    m_font.DeleteObject();
    m_font.CreateFontIndirect( &m_lfDefFont );

    /*
     * Initialize the Wd list.
     */
    for ( Index = 0, Entries = 1, ByteCount = sizeof(WDNAME);
          (Status =
           RegWdEnumerate( SERVERNAME_CURRENT, 
                           &Index, 
                           &Entries,
                           WdKey, 
                           &ByteCount )) == ERROR_SUCCESS;
          ByteCount = sizeof(WDNAME) ) {
        
        if ( ( QStatus = RegWdQuery( SERVERNAME_CURRENT, WdKey, &WdConfig,
                                     sizeof(WdConfig),
                                     &ByteCount ) ) != ERROR_SUCCESS ) {
            STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, QStatus,
                                     IDP_ERROR_REGWDQUERY, WdKey ))
            return(FALSE);
        }

        /*
         * Only place this Wd in the WdList if it's DLL is present
         * on the system.
         */
        GetSystemDirectory( WdDll, MAX_PATH );
        lstrcat( WdDll, TEXT("\\Drivers\\") );
        lstrcat( WdDll, WdConfig.Wd.WdDLL );
        lstrcat( WdDll, TEXT(".sys" ) );
        if ( lstr_access( WdDll, 0 ) != 0 )
            continue;
        
        /*
         * Create a new WdList object and initialize from WdConfig
         * structure, adding it to the end of the WdList.
         */
        if ( !(pWdListObject = new CWdListObject) ) {

            ERROR_MESSAGE((IDP_ERROR_WDLISTALLOC))
            return(FALSE);
        }

        pWdListObject->m_WdConfig = WdConfig;
        pWdListObject->m_Capabilities = (ULONG)0;

        // Load the extension DLL for this WD
        pWdListObject->m_hExtensionDLL = ::LoadLibrary(WdConfig.Wd.CfgDLL);
        if(pWdListObject->m_hExtensionDLL) {
            // Get the entry points
            pWdListObject->m_lpfnExtStart = (LPFNEXTSTARTPROC)::GetProcAddress(pWdListObject->m_hExtensionDLL, szStart);
            pWdListObject->m_lpfnExtEnd = (LPFNEXTENDPROC)::GetProcAddress(pWdListObject->m_hExtensionDLL, szEnd);
            pWdListObject->m_lpfnExtDialog = (LPFNEXTDIALOGPROC)::GetProcAddress(pWdListObject->m_hExtensionDLL, szDialog);
            pWdListObject->m_lpfnExtDeleteObject = (LPFNEXTDELETEOBJECTPROC)::GetProcAddress(pWdListObject->m_hExtensionDLL, szDeleteObject);
            pWdListObject->m_lpfnExtDupObject = (LPFNEXTDUPOBJECTPROC)::GetProcAddress(pWdListObject->m_hExtensionDLL, szDupObject);
            pWdListObject->m_lpfnExtRegQuery = (LPFNEXTREGQUERYPROC)::GetProcAddress(pWdListObject->m_hExtensionDLL, szRegQuery);
            pWdListObject->m_lpfnExtRegCreate = (LPFNEXTREGCREATEPROC)::GetProcAddress(pWdListObject->m_hExtensionDLL, szRegCreate);
            pWdListObject->m_lpfnExtRegDelete = (LPFNEXTREGDELETEPROC)::GetProcAddress(pWdListObject->m_hExtensionDLL, szRegDelete);
            pWdListObject->m_lpfnExtCompareObjects = (LPFNEXTCOMPAREOBJECTSPROC)::GetProcAddress(pWdListObject->m_hExtensionDLL, szCompareObjects);
            pWdListObject->m_lpfnExtEncryptionLevels = (LPFNEXTENCRYPTIONLEVELSPROC)::GetProcAddress(pWdListObject->m_hExtensionDLL, szEncryptionLevels);
            pWdListObject->m_lpfnExtGetCapabilities = (LPFNEXTGETCAPABILITIES)::GetProcAddress(pWdListObject->m_hExtensionDLL, szGetCapabilities);

            // Call the ExtStart() function in the extension DLL
            if(pWdListObject->m_lpfnExtStart)(*pWdListObject->m_lpfnExtStart)(&WdConfig.Wd.WdName);

            // Call the ExtGetCapabilities function in the extension DLL
            // to get the capabilities for this WD
            if(pWdListObject->m_lpfnExtGetCapabilities) {
                pWdListObject->m_Capabilities = (*pWdListObject->m_lpfnExtGetCapabilities)();
            }

        }

        m_WdList.AddTail( pWdListObject );
                
        /*
         * Create and initialize Td list with all Tds defined for this Wd.
         */
        if ( !(pTdList = new CObList) ) {

            ERROR_MESSAGE((IDP_ERROR_TDLISTALLOC))
            return(FALSE);
        }
        m_TdListList.AddTail( (CObject *)pTdList );

        for ( Index2 = 0, Entries2 = 1, ByteCount = sizeof(PDNAME);
              (Status =
                RegPdEnumerate( SERVERNAME_CURRENT, 
                                WdKey,
                                TRUE,
                                &Index2,
                                &Entries2,
                                PdKey,
                                &ByteCount )) == ERROR_SUCCESS;
              ByteCount = sizeof(PDNAME) ) {
        
            if ( ( QStatus = RegPdQuery( SERVERNAME_CURRENT, 
                                         WdKey,
                                         TRUE,
                                         PdKey, 
                                         &PdConfig, 
                                         sizeof(PdConfig),
                                         &ByteCount ) ) != ERROR_SUCCESS ) {
                STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, QStatus,
                                         IDP_ERROR_REGPDQUERY, PdKey ))
                return(FALSE);
            }

            /*
             * Create a new PdListObject and initialize from PdConfig
             * structure, then add to the Td list.
             */
            if ( !(pPdListObject = new CPdListObject) ) {

                ERROR_MESSAGE((IDP_ERROR_TDLISTALLOC))
                return(FALSE);
            }
            pPdListObject->m_PdConfig = PdConfig;
            pTdList->AddTail( pPdListObject );
        }

        /*
         * Create and initialize Pd list with all Pds defined for this Wd.
         */
        if ( !(pPdList = new CObList) ) {

            ERROR_MESSAGE((IDP_ERROR_PDLISTALLOC))
            return(FALSE);
        }
        m_PdListList.AddTail( (CObject *)pPdList );

        for ( Index2 = 0, Entries2 = 1, ByteCount = sizeof(PDNAME);
              (Status =
                RegPdEnumerate( SERVERNAME_CURRENT, 
                                WdKey,
                                FALSE,
                                &Index2,
                                &Entries2,
                                PdKey,
                                &ByteCount )) == ERROR_SUCCESS;
              ByteCount = sizeof(PDNAME) ) {
        
            if ( ( QStatus = RegPdQuery( SERVERNAME_CURRENT, 
                                         WdKey,
                                         FALSE,
                                         PdKey, 
                                         &PdConfig, 
                                         sizeof(PdConfig),
                                         &ByteCount ) ) != ERROR_SUCCESS ) {
                STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, QStatus,
                                         IDP_ERROR_REGPDQUERY, PdKey ))
                return(FALSE);
            }

            /*
             * Create a new PdListObject and initialize from PdConfig
             * structure, then add to the Pd list.
             */
            if ( !(pPdListObject = new CPdListObject) ) {

                ERROR_MESSAGE((IDP_ERROR_PDLISTALLOC))
                return(FALSE);
            }
            pPdListObject->m_PdConfig = PdConfig;
            pPdList->AddTail( pPdListObject );
        }
    }

    /*
     * If no Wds are defined, complain and return FALSE.
     */
    if ( !m_WdList.GetCount() ) {

        ERROR_MESSAGE((IDP_ERROR_EMPTYWDLIST))
        return(FALSE);
    }

    return(TRUE);

}  // end CWincfgApp::Initialize


/*******************************************************************************
 *
 *  GetAppProfileInfo - CWincfgApp member function: private operation
 *
 *      Retrieve the app's profile information from the registry, or set
 *      defaults if not there.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CWincfgApp::GetAppProfileInfo()
{
    int Italic, Underline, PitchAndFamily, CharSet;
    HKEY hKeyWincfg;
    DWORD dwType, cbData, dwValue;
    TCHAR szValue[128], *pszFontFace = TEXT("MS Shell Dlg");

    /*
     * Open (or create if not there) the registry key for this application.
     */
    RegCreateKey(HKEY_CURRENT_USER, szWincfgAppKey, &hKeyWincfg);

    /*
     * Get previous WINDOWPLACEMENT.
     */
    cbData = sizeof(szValue);
    if ( !hKeyWincfg ||
         (RegQueryValueEx( hKeyWincfg, szPlacement, NULL, &dwType,
                           (LPBYTE)szValue, &cbData ) != ERROR_SUCCESS ) ||
         !(*szValue) ||
         (lstrscanf( szValue, szPlacementFormat,
                     &m_Placement.flags, &m_Placement.showCmd,
                     &m_Placement.ptMinPosition.x, &m_Placement.ptMinPosition.y,
                     &m_Placement.ptMaxPosition.x, &m_Placement.ptMaxPosition.y,
                     &m_Placement.rcNormalPosition.left,
                     &m_Placement.rcNormalPosition.top,
                     &m_Placement.rcNormalPosition.right,
                     &m_Placement.rcNormalPosition.bottom ) != 10) ) {
        /*
         * Flag to use the default window placement.
         */
        m_Placement.rcNormalPosition.right = -1;

    } else {

        /*
         * Never use a retrieved 'hidden' state from registry.
         */
        if ( m_Placement.showCmd == SW_HIDE )
            m_Placement.showCmd = SW_SHOWNORMAL;
    }

    /*
     * Flag for initial showing of main window in our override of
     * CFrameWnd::ActivateFrame() (in our CMainFrame class).
     */
    m_Placement.length = (UINT)-1;

    /*
     * Get application's font.
     */
    cbData = sizeof(szValue);
    if ( !hKeyWincfg ||
         (RegQueryValueEx( hKeyWincfg, szFont, NULL, &dwType,
                           (LPBYTE)szValue, &cbData ) != ERROR_SUCCESS ) ||
         !(*szValue) ||
         (lstrscanf( szValue, szFontFormat,
                     &m_lfDefFont.lfHeight, &m_lfDefFont.lfWeight,
                     &Italic, &Underline, &PitchAndFamily, &CharSet ) != 6) )
    {

        /* 
         * Set up a default font.
         */
        m_lfDefFont.lfHeight = -13;
        m_lfDefFont.lfWeight = FW_NORMAL;
        m_lfDefFont.lfItalic = 0;
        m_lfDefFont.lfUnderline = 0;
        m_lfDefFont.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS;
#ifdef DBCS
        CHARSETINFO csi;
        DWORD dw = ::GetACP();

        if (!::TranslateCharsetInfo((DWORD *)dw, &csi, TCI_SRCCODEPAGE))
            m_lfDefFont.lfCharSet = ANSI_CHARSET;
        else
            m_lfDefFont.lfCharSet = csi.ciCharset;
#endif
    } else {
    
        m_lfDefFont.lfItalic = (BYTE)Italic;
        m_lfDefFont.lfUnderline = (BYTE)Underline;
        m_lfDefFont.lfPitchAndFamily = (BYTE)PitchAndFamily;
#ifdef DBCS
        m_lfDefFont.lfCharSet = CharSet;
#endif

        cbData = sizeof(szValue);
        if ( (RegQueryValueEx( hKeyWincfg, szFontFace, NULL, &dwType,
                               (LPBYTE)szValue, &cbData ) == ERROR_SUCCESS ) &&
             *szValue )
            pszFontFace = szValue;
    }
    lstrcpy( m_lfDefFont.lfFaceName,  pszFontFace );

    /*
     * Get other profile settings.
     */
    cbData = sizeof(m_nConfirmation);
    if ( !hKeyWincfg ||
         (RegQueryValueEx( hKeyWincfg, szConfirm, NULL, &dwType,
                           (LPBYTE)&dwValue, &cbData ) != ERROR_SUCCESS) )
        m_nConfirmation = 1;
    else
        m_nConfirmation = dwValue;
                
    cbData = sizeof(m_nSaveSettingsOnExit);
    if ( !hKeyWincfg ||
         (RegQueryValueEx( hKeyWincfg, szSaveSettings, NULL, &dwType,
                           (LPBYTE)&dwValue, &cbData ) != ERROR_SUCCESS) )
        m_nSaveSettingsOnExit = 1; 
    else
        m_nSaveSettingsOnExit = dwValue;

    cbData = sizeof(m_nHexBase);
    if ( !hKeyWincfg ||
         (RegQueryValueEx( hKeyWincfg, szHexBase, NULL, &dwType,
                           (LPBYTE)&dwValue, &cbData ) != ERROR_SUCCESS) )
        m_nHexBase = 1;
    else
        m_nHexBase = dwValue;

    if ( hKeyWincfg )
        RegCloseKey(hKeyWincfg);

}  // end CWincfgApp::GetAppProfileInfo


/*******************************************************************************
 *
 *  Terminate - CWincfgApp member function: public operation
 *
 *      Save state settings to the app's profile and free the Pd and Wd
 *      list contents.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CWincfgApp::Terminate()
{
    POSITION pos1, pos2, pos3, pos4;
    CObject *pObject;
    CObList *pTdList, *pPdList;

    /*
     * Save app profile information.
     */
    SetAppProfileInfo();

    /*
     * We need to close all documents here so that when CWinStationListObjects
     * are deleted in the document they can find the proper Wd in the WdList
     * so that they can call the proper extension DLL to delete it's
     * corresponding object.
     */
    CloseAllDocuments(1);

    /*
     * Clean up the TdList list.
     */
    for ( pos1 = m_TdListList.GetHeadPosition(); (pos2 = pos1) != NULL; ) {

        m_TdListList.GetNext( pos1 );
        pTdList = (CObList *)m_TdListList.GetAt( pos2 );

        for ( pos3 = pTdList->GetHeadPosition(); (pos4 = pos3) != NULL; ) {
            pTdList->GetNext( pos3 );
            pObject = pTdList->GetAt( pos4 );
            pTdList->RemoveAt( pos4 );
            delete ( pObject );
        }

        m_TdListList.RemoveAt( pos2 );
        delete ( pTdList );
    }

    /*
     * Clean up the PdList list.
     */
    for ( pos1 = m_PdListList.GetHeadPosition(); (pos2 = pos1) != NULL; ) {

        m_PdListList.GetNext( pos1 );
        pPdList = (CObList *)m_PdListList.GetAt( pos2 );

        for ( pos3 = pPdList->GetHeadPosition(); (pos4 = pos3) != NULL; ) {
            pPdList->GetNext( pos3 );
            pObject = pPdList->GetAt( pos4 );
            pPdList->RemoveAt( pos4 );
            delete ( pObject );
        }

        m_PdListList.RemoveAt( pos2 );
        delete ( pPdList );
    }

    /*
     * Clean up the WdList.
     */
    for ( pos1 = m_WdList.GetHeadPosition(); (pos2 = pos1) != NULL; ) {
        m_WdList.GetNext( pos1 );
        pObject = m_WdList.GetAt( pos2 );
        m_WdList.RemoveAt( pos2 );
        if(((PTERMLOBJECT)pObject)->m_hExtensionDLL) {
            if(((PTERMLOBJECT)pObject)->m_lpfnExtEnd) (*((PTERMLOBJECT)pObject)->m_lpfnExtEnd)();
            ::FreeLibrary(((PTERMLOBJECT)pObject)->m_hExtensionDLL);
        }
        delete ( pObject );
    }

    /*
     * Clean up security strings (in case security functions were requested).
     */
    FreeSecurityStrings();
    CoUninitialize();

}  // end CWincfgApp::Terminate


/*******************************************************************************
 *
 *  SetAppProfileInfo - CWincfgApp member function: private operation
 *
 *      Save the app's profile information to the registry, if requested.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CWincfgApp::SetAppProfileInfo()
{
    HKEY hKeyWincfg;
    DWORD dwValue;
    TCHAR szValue[128];

    /*
     * Open the registry key for this application.
     */
    RegCreateKey(HKEY_CURRENT_USER, szWincfgAppKey, &hKeyWincfg);

    /*
     * Save settings if requested by user and we're not in batch mode.
     */ 
    if ( hKeyWincfg && m_nSaveSettingsOnExit && !g_Batch ) {
    
        /*
         * Fetch and set current window placement.
         */
        if ( m_pMainWnd &&
             m_pMainWnd->GetWindowPlacement(&m_Placement) ) {

            m_Placement.flags = 0;
            if ( m_pMainWnd->IsZoomed() )
                m_Placement.flags |= WPF_RESTORETOMAXIMIZED;

            wsprintf( szValue, szPlacementFormat,
                      m_Placement.flags, m_Placement.showCmd,
                      m_Placement.ptMinPosition.x, m_Placement.ptMinPosition.y,
                      m_Placement.ptMaxPosition.x, m_Placement.ptMaxPosition.y,
                      m_Placement.rcNormalPosition.left,
                      m_Placement.rcNormalPosition.top,
                      m_Placement.rcNormalPosition.right,
                      m_Placement.rcNormalPosition.bottom);
                
            RegSetValueEx( hKeyWincfg, szPlacement, 0, REG_SZ,
                           (LPBYTE)szValue,
                           (lstrlen(szValue) + 1) * sizeof(TCHAR) );
        }

        /*
         * Set the current font.
         */
        wsprintf( szValue, szFontFormat,
                     m_lfDefFont.lfHeight, m_lfDefFont.lfWeight,
                     m_lfDefFont.lfItalic, m_lfDefFont.lfUnderline,
                     m_lfDefFont.lfPitchAndFamily, m_lfDefFont.lfCharSet);
                
        RegSetValueEx( hKeyWincfg, szFont, 0, REG_SZ,
                       (LPBYTE)szValue,
                       (lstrlen(szValue) + 1) * sizeof(TCHAR) );

        lstrcpy(szValue,m_lfDefFont.lfFaceName);
        RegSetValueEx( hKeyWincfg, szFontFace, 0, REG_SZ,
                       (LPBYTE)szValue,
                       (lstrlen(szValue) + 1) * sizeof(TCHAR) );

        /*
         * Set other profile settings.
         */
        dwValue = m_nConfirmation;
        RegSetValueEx( hKeyWincfg, szConfirm, 0, REG_DWORD,
                       (LPBYTE)&dwValue, sizeof(DWORD) );

        dwValue = m_nHexBase;
        RegSetValueEx( hKeyWincfg, szHexBase, 0, REG_DWORD,
                       (LPBYTE)&dwValue, sizeof(DWORD) );
    }

    /*
     * Always write the "SaveSettingsOnExit" value to retain user's preference.
     */
    if ( hKeyWincfg ) {

        dwValue = m_nSaveSettingsOnExit;
        RegSetValueEx( hKeyWincfg, szSaveSettings, 0, REG_DWORD,
                       (LPBYTE)&dwValue, sizeof(DWORD) );

        RegCloseKey(hKeyWincfg);
    }

}  // end CWincfgApp::SetAppProfileInfo


////////////////////////////////////////////////////////////////////////////////
// CWincfgApp message map

#pragma warning( disable : 4245 ) // can remove when we update to MFC 3.0
BEGIN_MESSAGE_MAP(CWincfgApp, CWinApp)
    //{{AFX_MSG_MAP(CWincfgApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    ON_COMMAND(ID_OPTIONS_FONT, OnOptionsFont)
    ON_COMMAND(ID_OPTIONS_CONFIRMATION, OnOptionsConfirmation)
    ON_UPDATE_COMMAND_UI(ID_OPTIONS_CONFIRMATION, OnUpdateOptionsConfirmation)
    ON_COMMAND(ID_OPTIONS_SAVE_SETTINGS_ON_EXIT, OnOptionsSaveSettingsOnExit)
    ON_UPDATE_COMMAND_UI(ID_OPTIONS_SAVE_SETTINGS_ON_EXIT, OnUpdateOptionsSaveSettingsOnExit)
    ON_COMMAND(ID_HELP_SEARCH_FOR, OnHelpSearchFor)
    ON_COMMAND(ID_HELP, OnHelp)
    //}}AFX_MSG_MAP
    // Global help commands
    ON_COMMAND(ID_HELP_INDEX, CWinApp::OnHelpIndex)
    ON_COMMAND(ID_HELP_USING, CWinApp::OnHelpUsing)
    ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, CWinApp::OnHelpIndex)
END_MESSAGE_MAP()
#pragma warning( default : 4245 ) // can remove when we update to MFC 3.0


////////////////////////////////////////////////////////////////////////////////
// CWincfgApp commands

/*******************************************************************************
 *
 *  OnAppAbout - CWincfgApp member function: command
 *
 *      Display the about box dialog (uses Shell32 generic About dialog).
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

// Typedef for the ShellAbout function
typedef void (WINAPI *LPFNSHELLABOUT)(HWND, LPCTSTR, LPCTSTR, HICON);

void
CWincfgApp::OnAppAbout()
{
    HMODULE    hMod;
    LPFNSHELLABOUT lpfn;

    if (hMod = ::LoadLibrary(TEXT("SHELL32")))
    {
        if (lpfn = (LPFNSHELLABOUT)::GetProcAddress( hMod, 
#ifdef UNICODE
                                                     "ShellAboutW"
#else    
                                                     "ShellAboutA"
#endif // UNICODE
                                                            ))
        {
        (*lpfn)( m_pMainWnd->m_hWnd, (LPCTSTR)m_pszAppName,
                 (LPCTSTR)(TEXT("")), LoadIcon(IDR_MAINFRAME) );
        }
        ::FreeLibrary(hMod);
    }
    else
    {
        ::MessageBeep( MB_ICONEXCLAMATION );
    }

}  // end CWincfgApp::OnAppAbout


/*******************************************************************************
 *
 *  OnOptionsFont - CWincfgApp member function: command
 *
 *      Prompt for a new font to use in views and set if given.
 *
 *  ENTRY:
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CWincfgApp::OnOptionsFont()
{
    CFontDialog dlg( &m_lfDefFont, CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT );

    /*
     * We don't want the Help button since none of the other NT utilities
     * in our 'family' offer this.  Also, we need to block the F1 'help' and
     * unblock when done.
     */
    dlg.m_cf.Flags &= ~CF_SHOWHELP;
    m_bAllowHelp = FALSE;

    if ( dlg.DoModal() == IDOK ) {

        /*
         * switch to newly selected font.
         */
        m_font.DeleteObject();

        if ( m_font.CreateFontIndirect( &m_lfDefFont ) ) {

            CAppServerView *pView;

            /*
             * Update the view.
             *
             * NOTE: Call the MDIGetActive function in a loop for MDI
             * application to get each MDI Child window, then get the view
             * associated with each child window and call its ResetView
             * member function with TRUE argument to cause new field maximums
             * to be calculated.
             */
            if ( (pView = (CAppServerView *)
                          ((CMainFrame *)(m_pMainWnd))->GetActiveView()) )
                pView->ResetView( TRUE );
        }
    }
    m_bAllowHelp = TRUE;

}  // end CWincfgApp::OnOptionsFont


/*******************************************************************************
 *
 *  OnOptionsConfirmation- CWincfgApp member function: command
 *
 *      Toggle the "confirmation" flag.
 *
 *  ENTRY:
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CWincfgApp::OnOptionsConfirmation()
{
    m_nConfirmation ^= 1;

}  // end CWincfgApp::OnOptionsConfirmation


/*******************************************************************************
 *
 *  OnUpdateOptionsConfirmation - CWincfgApp member function: command
 *
 *      Check or uncheck the "confirmation" menu item based on the state
 *      of the m_nConfirmation flag.
 *
 *  ENTRY:
 *
 *      pCndUI (input)
 *          Points to the CCmdUI object of the "confirmation" menu item.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CWincfgApp::OnUpdateOptionsConfirmation( CCmdUI* pCmdUI )
{
    pCmdUI->SetCheck( m_nConfirmation );

}  // end CWincfgApp::OnUpdateOptionsConfirmation


/*******************************************************************************
 *
 *  OnOptionsSaveSettingsOnExit - CWincfgApp member function: command
 *
 *      Toggle the "save settings on exit" flag.
 *
 *  ENTRY:
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CWincfgApp::OnOptionsSaveSettingsOnExit()
{
    m_nSaveSettingsOnExit ^= 1;

}  // end CWincfgApp::OnOptionsSaveSettingsOnExit


/*******************************************************************************
 *
 *  OnUpdateOptionsSaveSettingsOnExit - CWincfgApp member function: command
 *
 *      Check or uncheck the "save settings on exit" menu item based on the
 *      state of the m_nSaveSettingsOnExit flag.
 *
 *  ENTRY:
 *
 *      pCndUI (input)
 *          Points to the CCmdUI object of the "save settings on exit"
 *          menu item.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CWincfgApp::OnUpdateOptionsSaveSettingsOnExit( CCmdUI* pCmdUI )
{
    pCmdUI->SetCheck( m_nSaveSettingsOnExit );

}  // end CWincfgApp::OnUpdateOptionsSaveSettingsOnExit


/*******************************************************************************
 *
 *  OnHelp - CWincfgApp member function: command
 *
 *      Invoke standard CWinApp::WinHelp if we're allowing help at this time.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CWincfgApp::OnHelp()
{
    /*
     * If we're allowing help now, call default help helper.
     */
    if ( m_bAllowHelp )
        CWinApp::OnHelp();

}  // end CWincfgApp::OnHelp


/*******************************************************************************
 *
 *  OnHelpSearchFor - CWincfgApp member function: command
 *
 *      Invoke WinHelp on our app's help file to bring up the 'search' window.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CWincfgApp::OnHelpSearchFor()
{
    WinHelp((DWORD)((LPCTSTR)TEXT("")), HELP_PARTIALKEY);
    
}  // end CWincfgApp::OnHelpSearchFor

/*******************************************************************************
 *
 *  AreWeRunningTerminalServices
 *
 *      Check if we are running terminal server
 *
 *  ENTRY:
 *      
 *  EXIT: BOOL: True if we are running Terminal Services False if we
 *              are not running Terminal Services
 *
 *
 ******************************************************************************/

BOOL AreWeRunningTerminalServices(void)
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    return VerifyVersionInfo(
        &osVersionInfo,
        VER_SUITENAME,
        dwlConditionMask
        );
}



////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\admtools\winutils\tscfg\wincfg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* wincfg.h
*
* WinStation Configuration application: main header file
*
* copyright notice: Copyright 1996, Citrix Systems Inc.
*
* $Author:   donm  $  Butch Davis
*
* $Log:   N:\nt\private\utils\citrix\winutils\tscfg\VCS\wincfg.h  $
*
*     Rev 1.23   18 Apr 1998 15:32:12   donm
*  Added capability bits
*
*     Rev 1.22   13 Jan 1998 14:08:42   donm
*  gets encryption levels from extension DLL
*
*     Rev 1.21   10 Dec 1997 15:59:32   donm
*  added ability to have extension DLLs
*
*     Rev 1.20   27 Jun 1997 15:58:46   butchd
*  Registry changes for Wds/Tds/Pds/Cds
*
*     Rev 1.19   19 Jun 1997 19:22:30   kurtp
*  update
*
*     Rev 1.18   25 Mar 1997 09:00:48   butchd
*  update
*
*     Rev 1.17   04 Mar 1997 08:35:30   butchd
*  update
*
*     Rev 1.16   27 Sep 1996 17:52:48   butchd
*  update
*
*******************************************************************************/

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

/*
 * WINUTILS common helper function include files
 */
#include "common.h"
#include "..\..\inc\utilsub.h"
#include <utildll.h>

#include "tscfgext.h"

/*
 * pre-object include files
 */
#include "defines.h"

// define class here so that CWinStationListObject can have
// a pointer to a CWdListObject
class CWdListObject;

////////////////////////////////////////////////////////////////////////////////
// CWinStationListObject class
//
class CWinStationListObject : public CObject
{

/*
 * Member variables
 */
public:
	CWinStationListObject();
	~CWinStationListObject();

    WINSTATIONNAME  m_WinStationName;       // Registry WinStations SubKey
    PDNAME          m_PdName;               // Pd Name (of Pd 0)
    SDCLASS         m_SdClass;              // Pd Class (of Pd 0)
    WDNAME          m_WdName;               // Wd Name
    TCHAR m_Comment[WINSTATIONCOMMENT_LENGTH+1];    // WinStation comment
    TCHAR m_DeviceName[DEVICENAME_LENGTH+MODEMNAME_LENGTH+1];  // Decorated Device Name for Async display
    ULONG           m_Flags;                // Various flags
    ULONG           m_LanAdapter;           // LanAdapter # (for PdNetwork)
	void			*m_pExtObject;			// Additional info kept by extension DLL
    CWdListObject   *m_pWdListObject;

};  // end CWinStationListObject class interface

typedef CWinStationListObject WSLOBJECT;
typedef CWinStationListObject *  PWSLOBJECT;

/*
 * CWinStationListObject flags
 */
#define WSL_ENABLED             0x00000001      // WinStation enabled or disabled
#define WSL_DIRECT_ASYNC        0x00000002      // Direct connection (for PdAsync)
#define WSL_MUST_REBOOT         0x00000004      // System needs reboot before WinStation active.
#define WSL_SINGLE_INST         0x00000008      // Single-instance (PdConfig2->PdFlag & PD_SINGLE_INST)
////////////////////////////////////////////////////////////////////////////////

const int ExDlgModeNew = 0;
const int ExDlgModeEdit = 1;

typedef struct _EncLevel {
    WORD StringID;
    DWORD RegistryValue;
    WORD Flags;
} EncryptionLevel;

// Flags for EncryptionLevel.Flags
const WORD ELF_DEFAULT  = 0x0001;    // This is the default value

typedef void* PEXTOBJECT;

typedef void (WINAPI *LPFNEXTSTARTPROC) (WDNAME *pWdName);
typedef void (WINAPI *LPFNEXTENDPROC) (void);

typedef void (WINAPI *LPFNEXTDIALOGPROC) (HWND, PEXTOBJECT);

typedef void (WINAPI *LPFNEXTDELETEOBJECTPROC) (PEXTOBJECT);
typedef PEXTOBJECT (WINAPI *LPFNEXTDUPOBJECTPROC) (PEXTOBJECT);
typedef PEXTOBJECT (WINAPI *LPFNEXTREGQUERYPROC) (PWINSTATIONNAME, PPDCONFIG);
typedef LONG (WINAPI *LPFNEXTREGCREATEPROC) (PWINSTATIONNAME, PEXTOBJECT, BOOLEAN);
typedef LONG (WINAPI *LPFNEXTREGDELETEPROC) (PWINSTATIONNAME, PEXTOBJECT);
typedef BOOL (WINAPI *LPFNEXTCOMPAREOBJECTSPROC) (PEXTOBJECT, PEXTOBJECT);
typedef LONG (WINAPI *LPFNEXTENCRYPTIONLEVELSPROC) (WDNAME *pWdName, EncryptionLevel **);
typedef ULONG (WINAPI *LPFNEXTGETCAPABILITIES) (void);

////////////////////////////////////////////////////////////////////////////////
// CWdListObject class
//
class CWdListObject : public CObject
{

/*
 * Member variables
 */
public:
    WDCONFIG2   m_WdConfig;
    HINSTANCE   m_hExtensionDLL;
    ULONG       m_Capabilities;

    LPFNEXTSTARTPROC m_lpfnExtStart;
    LPFNEXTENDPROC m_lpfnExtEnd;
    LPFNEXTDIALOGPROC m_lpfnExtDialog;

	LPFNEXTDELETEOBJECTPROC m_lpfnExtDeleteObject;
	LPFNEXTDUPOBJECTPROC m_lpfnExtDupObject;
	LPFNEXTREGQUERYPROC m_lpfnExtRegQuery;
	LPFNEXTREGCREATEPROC m_lpfnExtRegCreate;
	LPFNEXTREGDELETEPROC m_lpfnExtRegDelete;
	LPFNEXTCOMPAREOBJECTSPROC m_lpfnExtCompareObjects;
    LPFNEXTENCRYPTIONLEVELSPROC m_lpfnExtEncryptionLevels;
    LPFNEXTGETCAPABILITIES m_lpfnExtGetCapabilities;

};  // end CWdListObject class interface

typedef CWdListObject TERMLOBJECT;
typedef CWdListObject *  PTERMLOBJECT;
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// CPdListObject class
//
class CPdListObject : public CObject
{

/*
 * Member variables
 */
public:
    PDCONFIG3   m_PdConfig;

};  // end CPdListObject class interface

typedef CPdListObject PDLOBJECT;
typedef CPdListObject *  PPDLOBJECT;
////////////////////////////////////////////////////////////////////////////////


/*
 * post-object include files
 */
#include "resource.h"
#include "threads.h"
#include "dialogs.h"
#include "helpers.h"

////////////////////////////////////////////////////////////////////////////////
// CWincfgApp class
//
class CWincfgApp : public CWinApp
{

/*
 * Member variables.
 */
public:
    CObList     m_WdList;
    CObList     m_TdListList;
    CObList     m_PdListList;
    CFont       m_font;
    TCHAR       m_szSystemConsole[WINSTATIONNAME_LENGTH+1];
    TCHAR       m_szLocalAppServer[MAX_COMPUTERNAME_LENGTH+3];
    TCHAR       m_szCurrentAppServer[MAX_COMPUTERNAME_LENGTH+3];
    TCHAR       m_CurrentUserName[USERNAME_LENGTH];
    WINSTATIONNAME m_CurrentWinStation;
    ULONG       m_CurrentLogonId;
    ULONG       m_CurrentWSFlags;
    WINDOWPLACEMENT m_Placement;
    int         m_nConfirmation;
    int         m_nHexBase;
    int         m_nRegistryOnly;
    BOOL        m_bAllowHelp;
    LPCTSTR     m_pszRegWinStationCreate;
    LPCTSTR     m_pszRegWinStationSetSecurity;
    LPCTSTR     m_pszRegWinStationQuery;
    LPCTSTR     m_pszRegWinStationDelete;
    LPCTSTR     m_pszGetDefaultWinStationSecurity;
    LPCTSTR     m_pszGetWinStationSecurity;
protected:
    LOGFONT     m_lfDefFont;
    int         m_nSaveSettingsOnExit;

/*
 * Implementation
 */
public:
    CWincfgApp();

/*
 * Overrides of MFC CWinApp class
 */
public:
    BOOL InitInstance();
    void AddToRecentFileList( const char * pszPathName );

/*
 * Operations
 */
protected:
    BOOL Initialize();
    void GetAppProfileInfo();
public:
    void Terminate();
protected:
    void SetAppProfileInfo();

/*
 * Message map / commands
 */
protected:
    //{{AFX_MSG(CWincfgApp)
    afx_msg void OnAppAbout();
    afx_msg void OnOptionsFont();
    afx_msg void OnOptionsConfirmation();
    afx_msg void OnUpdateOptionsConfirmation(CCmdUI* pCmdUI);
    afx_msg void OnOptionsSaveSettingsOnExit();
    afx_msg void OnUpdateOptionsSaveSettingsOnExit(CCmdUI* pCmdUI);
    afx_msg void OnHelpSearchFor();
    afx_msg void OnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  // end CWincfgApp class interface
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\device.h ===
//***************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: device.h
//
//  Revision History:
//
//  Aug 11, 1992   J. Perry Hannah   Created
//
//
//  Description: This file contains function prototypes and typedefs
//               used by the interface between RAS Manager and the
//               device DLLs, such as RASMXS.DLL.  This header file
//               will be used by RASMAN.
//
//****************************************************************************


#ifndef _RASDEVICEDLL_
#define _RASDEVICEDLL_


//*  RASMXS API Prototypes  **************************************************
//
//   Apps should define RASMXS_STATIC_LINK to get the appropriate function
//   prototypes for linking statically with the RASMXS DLL.
//
//   Apps should define RASMXS_DYNAMIC_LINK to get the appropriate function
//   typedefs for linking dynamically with the RASMXS DLL.
//

#ifdef RASMXS_STATIC_LINK

DWORD APIENTRY DeviceEnum(char  *pszDeviceType,
                          WORD  *pcEntries,
                          BYTE  *pBuffer,
                          WORD  *pwSize);


DWORD APIENTRY DeviceGetInfo(HANDLE  hIOPort,
                             char    *pszDeviceType,
                             char    *pszDeviceName,
                             BYTE    *pInfo,
                             WORD    *pwSize);


DWORD APIENTRY DeviceSetInfo(HANDLE      hIOPort,
                             char        *pszDeviceType,
                             char        *pszDeviceName,
                             DEVICEINFO  *pInfo);


DWORD APIENTRY DeviceConnect(HANDLE  hIOPort,
                             char    *pszDeviceType,
                             char    *pszDeviceName,
                             HANDLE  hNotifier);


DWORD APIENTRY DeviceListen(HANDLE  hIOPort,
                            char    *pszDeviceType,
                            char    *pszDeviceName,
                            HANDLE  hNotifier);


 VOID APIENTRY DeviceDone(HANDLE  hIOPort);


DWORD APIENTRY DeviceWork(HANDLE  hIOPort,
                          HANDLE  hNotifier);

#endif // RASMXS_STATIC_LINK




#ifdef RASMXS_DYNAMIC_LINK

typedef DWORD (APIENTRY * DeviceEnum_t)(char*, WORD*, BYTE*, WORD*);

typedef DWORD (APIENTRY * DeviceGetInfo_t)(HANDLE, char*, char*, BYTE*, WORD*);

typedef DWORD (APIENTRY * DeviceSetInfo_t)(HANDLE, char*, char*,
                                           RASMAN_DEVICEINFO*);

typedef DWORD (APIENTRY * DeviceConnect_t)(HANDLE, char*, char*, HANDLE);

typedef DWORD (APIENTRY * DeviceListen_t)(HANDLE, char*, char*, HANDLE);

typedef DWORD (APIENTRY * DeviceDone_t)(HANDLE);

typedef DWORD (APIENTRY * DeviceWork_t)(HANDLE, HANDLE);

// OPTIONAL

typedef DWORD (APIENTRY * DeviceSetDevConfig_t)(HANDLE, PBYTE, DWORD);

typedef DWORD (APIENTRY * DeviceGetDevConfig_t)(char *, PBYTE, DWORD*);

#endif // RASMXS_DYNAMIC_LINK




#endif // _RASDEVICEDLL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\apisub\apisub.c ===
/*******************************************************************************
*
* apisub.c
*
* RegApi helpers and convertion routines
*
* Copyright Microsoft Corporation, 1998
*
*
*******************************************************************************/

/*
 *  Includes
 */
#include <windows.h>
#include <stdio.h>
#include <winstaw.h>
#include <regapi.h>


/*
 * General purpose UNICODE <==> ANSI functions
 */
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );

/*
 * Reg Create helpers
 */
LONG SetNumValue( BOOLEAN, HKEY, LPWSTR, DWORD );
LONG SetNumValueEx( BOOLEAN, HKEY, LPWSTR, DWORD, DWORD );
LONG SetStringValue( BOOLEAN, HKEY, LPWSTR, LPWSTR );
LONG SetStringValueEx( BOOLEAN, HKEY, LPWSTR, DWORD, LPWSTR );

/*
 * Reg Query helpers
 */
DWORD GetNumValue( HKEY, LPWSTR, DWORD );
DWORD GetNumValueEx( HKEY, LPWSTR, DWORD, DWORD );
LONG GetStringValue( HKEY, LPWSTR, LPWSTR, LPWSTR, DWORD );
LONG GetStringValueEx( HKEY, LPWSTR, DWORD, LPWSTR, LPWSTR, DWORD );

/*
 * Pd conversion helpers.
 */
VOID PdConfigU2A( PPDCONFIGA, PPDCONFIGW );
VOID PdConfigA2U( PPDCONFIGW, PPDCONFIGA );
VOID PdConfig2U2A( PPDCONFIG2A, PPDCONFIG2W );
VOID PdConfig2A2U( PPDCONFIG2W, PPDCONFIG2A );
VOID PdConfig3U2A( PPDCONFIG3A, PPDCONFIG3W );
VOID PdConfig3A2U( PPDCONFIG3W, PPDCONFIG3A );
VOID PdParamsU2A( PPDPARAMSA, PPDPARAMSW );
VOID PdParamsA2U( PPDPARAMSW, PPDPARAMSA );
VOID AsyncConfigU2A ( PASYNCCONFIGA, PASYNCCONFIGW );
VOID AsyncConfigA2U ( PASYNCCONFIGW, PASYNCCONFIGA );
VOID NetworkConfigU2A ( PNETWORKCONFIGA, PNETWORKCONFIGW );
VOID NetworkConfigA2U ( PNETWORKCONFIGW, PNETWORKCONFIGA );
VOID NasiConfigU2A ( PNASICONFIGA, PNASICONFIGW );
VOID NasiConfigA2U ( PNASICONFIGW, PNASICONFIGA );
VOID OemTdConfigU2A ( POEMTDCONFIGA, POEMTDCONFIGW );
VOID OemTdConfigA2U ( POEMTDCONFIGW, POEMTDCONFIGA );

/*
 * WinStation conversion helpers (regapi).
 */
VOID WinStationCreateU2A( PWINSTATIONCREATEA, PWINSTATIONCREATEW );
VOID WinStationCreateA2U( PWINSTATIONCREATEW, PWINSTATIONCREATEA );
VOID WinStationConfigU2A( PWINSTATIONCONFIGA, PWINSTATIONCONFIGW );
VOID WinStationConfigA2U( PWINSTATIONCONFIGW, PWINSTATIONCONFIGA );
VOID UserConfigU2A( PUSERCONFIGA, PUSERCONFIGW );
VOID UserConfigA2U( PUSERCONFIGW, PUSERCONFIGA );

/*
 * WinStation conversion helpers (winstapi).
 */
VOID WinStationPrinterU2A( PWINSTATIONPRINTERA, PWINSTATIONPRINTERW );
VOID WinStationPrinterA2U( PWINSTATIONPRINTERW, PWINSTATIONPRINTERA );
VOID WinStationInformationU2A( PWINSTATIONINFORMATIONA,
                               PWINSTATIONINFORMATIONW );
VOID WinStationInformationA2U( PWINSTATIONINFORMATIONW,
                               PWINSTATIONINFORMATIONA );
VOID WinStationClientU2A( PWINSTATIONCLIENTA, PWINSTATIONCLIENTW );
VOID WinStationProductIdU2A( PWINSTATIONPRODIDA, PWINSTATIONPRODIDW );

/*
 * Wd conversion helpers.
 */
VOID WdConfigU2A( PWDCONFIGA, PWDCONFIGW );
VOID WdConfigA2U( PWDCONFIGW, PWDCONFIGA );

/*
 * Cd conversion helpers.
 */
VOID CdConfigU2A( PCDCONFIGA, PCDCONFIGW );
VOID CdConfigA2U( PCDCONFIGW, PCDCONFIGA );

/*
 *  procedures used (not defined here)
 */
VOID RtlUnicodeToMultiByteN( LPSTR, ULONG, PULONG, LPWSTR, ULONG );
VOID RtlMultiByteToUnicodeN( LPWSTR, ULONG, PULONG, LPSTR, ULONG );


/*******************************************************************************
 *
 *  UnicodeToAnsi
 *
 *     convert a UNICODE (WCHAR) string into an ANSI (CHAR) string
 *
 * ENTRY:
 *
 *    pAnsiString (output)
 *       buffer to place ANSI string into
 *    lAnsiMax (input)
 *       maximum number of BYTES to write into pAnsiString (sizeof the
 *       pAnsiString buffer)
 *    pUnicodeString (input)
 *       UNICODE string to convert
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
UnicodeToAnsi( CHAR * pAnsiString,
               ULONG lAnsiMax,
               WCHAR * pUnicodeString )
{
    ULONG ByteCount;

    RtlUnicodeToMultiByteN( pAnsiString, lAnsiMax, &ByteCount,
                            pUnicodeString,
                            ((wcslen(pUnicodeString) + 1) << 1) );
}


/*******************************************************************************
 *
 *  AnsiToUnicode
 *
 *     convert an ANSI (CHAR) string into a UNICODE (WCHAR) string
 *
 * ENTRY:
 *
 *    pUnicodeString (output)
 *       buffer to place UNICODE string into
 *    lUnicodeMax (input)
 *       maximum number of BYTES to write into pUnicodeString (sizeof the
 *       pUnicodeString buffer).
 *    pAnsiString (input)
 *       ANSI string to convert
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
AnsiToUnicode( WCHAR * pUnicodeString,
               ULONG lUnicodeMax,
               CHAR * pAnsiString )
{
    ULONG ByteCount;

    RtlMultiByteToUnicodeN( pUnicodeString, lUnicodeMax, &ByteCount,
                            pAnsiString, (strlen(pAnsiString) + 1) );
}


/*******************************************************************************
 *
 *  SetNumValue
 *
 *     Set numeric (DWORD) value in registry
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to set
 *    ValueData (input)
 *       data (DWORD) for registry value to set
 *
 * EXIT:
 *    status from RegDeleteValue or RegSetValueEx
 *
 ******************************************************************************/

LONG
SetNumValue( BOOLEAN bSetValue,
             HKEY Handle,
             LPWSTR ValueName,
             DWORD ValueData )
{
    if ( bSetValue )
        return( RegSetValueEx( Handle, ValueName, 0, REG_DWORD,
                               (BYTE *)&ValueData, sizeof(DWORD) ) );
    else
        return( RegDeleteValue( Handle, ValueName ) );
}


/*******************************************************************************
 *
 *  SetNumValueEx
 *
 *     Set numeric (DWORD) value in registry  (for use with arrays)
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to set
 *    Index (input)
 *       Index of value (array index)
 *    ValueData (input)
 *       data (DWORD) for registry value to set
 *
 * EXIT:
 *    status from SetNumValue
 *
 ******************************************************************************/

LONG
SetNumValueEx( BOOLEAN bSetValue,
               HKEY Handle,
               LPWSTR ValueName,
               DWORD Index,
               DWORD ValueData )
{
    WCHAR Name[MAX_REGKEYWORD];

    if ( Index > 0 )
        swprintf( Name, L"%s%u", ValueName, Index );
    else
        wcscpy( Name, ValueName );

    return( SetNumValue( bSetValue, Handle, Name, ValueData ) );
}


/*******************************************************************************
 *
 *  SetStringValue
 *
 *     Set string value in registry
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to set
 *    pValueData (input)
 *       data (string) for registry value to set
 *
 * EXIT:
 *    status from RegDeleteValue or RegSetValueEx
 *
 ******************************************************************************/

LONG
SetStringValue( BOOLEAN bSetValue,
                HKEY Handle,
                LPWSTR ValueName,
                LPWSTR pValueData )
{
    if ( bSetValue )
        return( RegSetValueEx( Handle, ValueName, 0, REG_SZ,
                               (BYTE *)pValueData, (wcslen(pValueData)+1)<<1 ) );
    else
        return( RegDeleteValue( Handle, ValueName ) );
}


/*******************************************************************************
 *
 *  SetStringValueEx
 *
 *     Set string value in registry  (for use with arrays)
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to set
 *    Index (input)
 *       Index of value (array index)
 *    pValueData (input)
 *       data (string) for registry value to set
 *
 * EXIT:
 *    status from SetStringValue
 *
 ******************************************************************************/

LONG
SetStringValueEx( BOOLEAN bSetValue,
                  HKEY Handle,
                  LPWSTR ValueName,
                  DWORD Index,
                  LPWSTR pValueData )
{
    WCHAR Name[MAX_REGKEYWORD];

    if ( Index > 0 )
        swprintf( Name, L"%s%u", ValueName, Index );
    else
        wcscpy( Name, ValueName );

    return( SetStringValue( bSetValue, Handle, Name, pValueData ) );
}


/*******************************************************************************
 *
 *  GetNumValue
 *
 *     get numeric (DWORD) value from registry
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to query
 *    DefaultData (input)
 *       default value to return if registry value name does not exist
 *
 * EXIT:
 *    registry value (DWORD)
 *
 ******************************************************************************/

DWORD
GetNumValue( HKEY Handle,
             LPWSTR ValueName,
             DWORD DefaultData )
{
    LONG Status;
    DWORD ValueType;
    DWORD ValueData;
    DWORD ValueSize = sizeof(DWORD);

    Status = RegQueryValueEx( Handle, ValueName, NULL, &ValueType,
                              (LPBYTE) &ValueData, &ValueSize );
    if ( Status != ERROR_SUCCESS )
        ValueData = DefaultData;

    return( ValueData );
}


/*******************************************************************************
 *
 *  GetNumValueEx
 *
 *     get numeric (DWORD) value from registry  (for use with arrays)
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to query
 *    Index (input)
 *       Index of value (array index)
 *    DefaultData (input)
 *       default value to return if registry value name does not exist
 *
 * EXIT:
 *    registry value (DWORD)
 *
 ******************************************************************************/

DWORD
GetNumValueEx( HKEY Handle,
               LPWSTR ValueName,
               DWORD Index,
               DWORD DefaultData )
{
    WCHAR Name[MAX_REGKEYWORD];

    if ( Index > 0 )
        swprintf( Name, L"%s%u", ValueName, Index );
    else
        wcscpy( Name, ValueName );

    return( GetNumValue( Handle, Name, DefaultData ) );
}


/*******************************************************************************
 *
 *  GetStringValue
 *
 *     get string value from registry
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to query
 *    DefaultData (input)
 *       default value to return if registry value name does not exist
 *    pValueData (output)
 *       pointer to buffer to store returned string
 *    MaxValueSize (input)
 *       max length of pValueData buffer
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

LONG
GetStringValue( HKEY Handle,
                LPWSTR ValueName,
                LPWSTR DefaultData,
                LPWSTR pValueData,
                DWORD MaxValueSize )
{
    LONG Status;
    DWORD ValueType;
    DWORD ValueSize = MaxValueSize << 1;

    Status = RegQueryValueEx( Handle, ValueName, NULL, &ValueType,
                              (LPBYTE) pValueData, &ValueSize );
    if ( Status != ERROR_SUCCESS || ValueSize == sizeof(UNICODE_NULL) ) {
        if ( DefaultData )
            wcscpy( pValueData, DefaultData );
        else
            pValueData[0] = 0;
    } else {
        if ( ValueType != REG_SZ ) {
            pValueData[0] = 0;
            return( ERROR_INVALID_DATATYPE );
        }
    }
    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  GetStringValueEx
 *
 *     get string value from registry  (for use with arrays)
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to query
 *    Index (input)
 *       Index of value (array index)
 *    DefaultData (input)
 *       default value to return if registry value name does not exist
 *    pValueData (output)
 *       pointer to buffer to store returned string
 *    MaxValueSize (input)
 *       max length of pValueData buffer
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

LONG
GetStringValueEx( HKEY Handle,
                  LPWSTR ValueName,
                  DWORD Index,
                  LPWSTR DefaultData,
                  LPWSTR pValueData,
                  DWORD MaxValueSize )
{
    WCHAR Name[MAX_REGKEYWORD];

    if ( Index > 0 )
        swprintf( Name, L"%s%u", ValueName, Index );
    else
        wcscpy( Name, ValueName );

    return( GetStringValue( Handle, Name, DefaultData, pValueData, MaxValueSize ) );
}


/*******************************************************************************
 *
 *  PdConfigU2A (UNICODE to ANSI)
 *
 *    copies PDCONFIGW elements to PDCONFIGA elements
 *
 * ENTRY:
 *    pPdConfigA (output)
 *       points to PDCONFIGA structure to copy to
 *
 *    pPdConfigW (input)
 *       points to PDCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdConfigU2A( PPDCONFIGA pPdConfigA,
              PPDCONFIGW pPdConfigW )
{
    PdConfig2U2A( &(pPdConfigA->Create), &(pPdConfigW->Create) );
    PdParamsU2A( &(pPdConfigA->Params), &(pPdConfigW->Params) );
}


/*******************************************************************************
 *
 *  PdConfigA2U (ANSI to UNICODE)
 *
 *    copies PDCONFIGA elements to PDCONFIGW elements
 *
 * ENTRY:
 *    pPdConfigW (output)
 *       points to PDCONFIGW structure to copy to
 *
 *    pPdConfigA (input)
 *       points to PDCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdConfigA2U( PPDCONFIGW pPdConfigW,
              PPDCONFIGA pPdConfigA )
{
    PdConfig2A2U( &(pPdConfigW->Create), &(pPdConfigA->Create) );
    PdParamsA2U( &(pPdConfigW->Params), &(pPdConfigA->Params) );
}


/*******************************************************************************
 *
 *  PdConfig2U2A (UNICODE to ANSI)
 *
 *    copies PDCONFIG2W elements to PDCONFIG2A elements
 *
 * ENTRY:
 *    pPdConfig2A (output)
 *       points to PDCONFIG2A structure to copy to
 *
 *    pPdConfig2W (input)
 *       points to PDCONFIG2W structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdConfig2U2A( PPDCONFIG2A pPdConfig2A,
               PPDCONFIG2W pPdConfig2W )
{
    UnicodeToAnsi( pPdConfig2A->PdName,
                   sizeof(pPdConfig2A->PdName),
                   pPdConfig2W->PdName );

    pPdConfig2A->SdClass = pPdConfig2W->SdClass;

    UnicodeToAnsi( pPdConfig2A->PdDLL,
                   sizeof(pPdConfig2A->PdDLL),
                   pPdConfig2W->PdDLL );

    pPdConfig2A->PdFlag  = pPdConfig2W->PdFlag;

    pPdConfig2A->OutBufLength = pPdConfig2W->OutBufLength;
    pPdConfig2A->OutBufCount = pPdConfig2W->OutBufCount;
    pPdConfig2A->OutBufDelay = pPdConfig2W->OutBufDelay;
    pPdConfig2A->InteractiveDelay = pPdConfig2W->InteractiveDelay;
    pPdConfig2A->PortNumber  = pPdConfig2W->PortNumber;
    pPdConfig2A->KeepAliveTimeout = pPdConfig2W->KeepAliveTimeout;
}


/*******************************************************************************
 *
 *  PdConfig2A2U (ANSI to UNICODE)
 *
 *    copies PDCONFIG2A elements to PDCONFIG2W elements
 *
 * ENTRY:
 *    pPdConfig2W (output)
 *       points to PDCONFIG2W structure to copy to
 *
 *    pPdConfig2A (input)
 *       points to PDCONFIG2A structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdConfig2A2U( PPDCONFIG2W pPdConfig2W,
               PPDCONFIG2A pPdConfig2A )
{
    AnsiToUnicode( pPdConfig2W->PdName,
                   sizeof(pPdConfig2W->PdName),
                   pPdConfig2A->PdName );

    pPdConfig2W->SdClass = pPdConfig2A->SdClass;

    AnsiToUnicode( pPdConfig2W->PdDLL,
                   sizeof(pPdConfig2W->PdDLL),
                   pPdConfig2A->PdDLL );

    pPdConfig2W->PdFlag  = pPdConfig2A->PdFlag;

    pPdConfig2W->OutBufLength = pPdConfig2A->OutBufLength;
    pPdConfig2W->OutBufCount = pPdConfig2A->OutBufCount;
    pPdConfig2W->OutBufDelay = pPdConfig2A->OutBufDelay;
    pPdConfig2W->InteractiveDelay = pPdConfig2A->InteractiveDelay;
    pPdConfig2W->PortNumber  = pPdConfig2A->PortNumber;
    pPdConfig2W->KeepAliveTimeout  = pPdConfig2A->KeepAliveTimeout;
}


/*******************************************************************************
 *
 *  PdConfig3U2A (UNICODE to ANSI)
 *
 *    copies PDCONFIG3W elements to PDCONFIG3A elements
 *
 * ENTRY:
 *    pPdConfig3A (output)
 *       points to PDCONFIG3A structure to copy to
 *
 *    pPdConfig3W (input)
 *       points to PDCONFIG3W structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdConfig3U2A( PPDCONFIG3A pPdConfig3A,
               PPDCONFIG3W pPdConfig3W )
{
    PdConfig2U2A( &(pPdConfig3A->Data), &(pPdConfig3W->Data) );

    UnicodeToAnsi( pPdConfig3A->ServiceName,
                   sizeof(pPdConfig3A->ServiceName),
                   pPdConfig3W->ServiceName );

    UnicodeToAnsi( pPdConfig3A->ConfigDLL,
                   sizeof(pPdConfig3A->ConfigDLL),
                   pPdConfig3W->ConfigDLL );
}


/*******************************************************************************
 *
 *  PdConfig3A2U (ANSI to UNICODE)
 *
 *    copies PDCONFIG3A elements to PDCONFIG3W elements
 *
 * ENTRY:
 *    pPdConfig3W (output)
 *       points to PDCONFIG3W structure to copy to
 *
 *    pPdConfig3A (input)
 *       points to PDCONFIG3A structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdConfig3A2U( PPDCONFIG3W pPdConfig3W,
               PPDCONFIG3A pPdConfig3A )
{
    PdConfig2A2U( &(pPdConfig3W->Data), &(pPdConfig3A->Data) );

    AnsiToUnicode( pPdConfig3W->ServiceName,
                   sizeof(pPdConfig3W->ServiceName),
                   pPdConfig3A->ServiceName );

    AnsiToUnicode( pPdConfig3W->ConfigDLL,
                   sizeof(pPdConfig3W->ConfigDLL),
                   pPdConfig3A->ConfigDLL );
}


/*******************************************************************************
 *
 *  PdParamsU2A (UNICODE to ANSI)
 *
 *    copies PDPARAMSW elements to PDPARAMSA elements
 *
 * ENTRY:
 *    pPdParamsA (output)
 *       points to PDPARAMSA structure to copy to
 *
 *    pPdParamsW (input)
 *       points to PDPARAMSW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdParamsU2A( PPDPARAMSA pPdParamsA,
              PPDPARAMSW pPdParamsW )
{
    pPdParamsA->SdClass = pPdParamsW->SdClass;

    switch ( pPdParamsW->SdClass ) {

        case SdNetwork:
            NetworkConfigU2A( &(pPdParamsA->Network), &(pPdParamsW->Network) );
            break;

        case SdNasi:
            NasiConfigU2A( &(pPdParamsA->Nasi), &(pPdParamsW->Nasi) );
            break;

        case SdAsync:
            AsyncConfigU2A( &(pPdParamsA->Async), &(pPdParamsW->Async) );
            break;

        case SdOemTransport:
            OemTdConfigU2A( &(pPdParamsA->OemTd), &(pPdParamsW->OemTd) );
            break;
    }
}


/*******************************************************************************
 *
 *  PdParamsA2U (ANSI to UNICODE)
 *
 *    copies PDPARAMSA elements to PDPARAMSW elements
 *
 * ENTRY:
 *    pPdParamsW (output)
 *       points to PDPARAMSW structure to copy to
 *
 *    pPdParamsA (input)
 *       points to PDPARAMSA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdParamsA2U( PPDPARAMSW pPdParamsW,
              PPDPARAMSA pPdParamsA )
{
    pPdParamsW->SdClass = pPdParamsA->SdClass;

    switch ( pPdParamsA->SdClass ) {

        case SdNetwork:
            NetworkConfigA2U( &(pPdParamsW->Network), &(pPdParamsA->Network) );
            break;

        case SdNasi:
            NasiConfigA2U( &(pPdParamsW->Nasi), &(pPdParamsA->Nasi) );
            break;

        case SdAsync:
            AsyncConfigA2U( &(pPdParamsW->Async), &(pPdParamsA->Async) );
            break;

        case SdOemTransport:
            OemTdConfigA2U( &(pPdParamsW->OemTd), &(pPdParamsA->OemTd) );
            break;
    }
}


/*******************************************************************************
 *
 *  NetworkConfigU2A (UNICODE to ANSI)
 *
 *    copies NETWORKCONFIGW elements to NETWORKCONFIGA elements
 *
 * ENTRY:
 *    pNetworkConfigA (output)
 *       points to NETWORKCONFIGA structure to copy to
 *
 *    pNetworkConfigW (input)
 *       points to NETWORKCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
NetworkConfigU2A( PNETWORKCONFIGA pNetworkConfigA,
                  PNETWORKCONFIGW pNetworkConfigW )
{
    pNetworkConfigA->LanAdapter = pNetworkConfigW->LanAdapter;

    UnicodeToAnsi( pNetworkConfigA->NetworkName,
                   sizeof(pNetworkConfigA->NetworkName),
                   pNetworkConfigW->NetworkName );

    pNetworkConfigA->Flags = pNetworkConfigW->Flags;
}


/*******************************************************************************
 *
 *  NetworkConfigA2U (ANSI to UNICODE)
 *
 *    copies NETWORKCONFIGA elements to NETWORKCONFIGW elements
 *
 * ENTRY:
 *    pNetworkConfigW (output)
 *       points to NETWORKCONFIGW structure to copy to
 *
 *    pNetworkConfigW (input)
 *       points to NETWORKCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
NetworkConfigA2U( PNETWORKCONFIGW pNetworkConfigW,
                  PNETWORKCONFIGA pNetworkConfigA )
{
    pNetworkConfigW->LanAdapter = pNetworkConfigA->LanAdapter;

    AnsiToUnicode( pNetworkConfigW->NetworkName,
                   sizeof(pNetworkConfigW->NetworkName),
                   pNetworkConfigA->NetworkName );

    pNetworkConfigW->Flags = pNetworkConfigA->Flags;
}


/*******************************************************************************
 *
 *  AsyncConfigU2A (UNICODE to ANSI)
 *
 *    copies ASYNCCONFIGW elements to ASYNCCONFIGA elements
 *
 * ENTRY:
 *    pAsyncConfigA (output)
 *       points to ASYNCCONFIGA structure to copy to
 *
 *    pAsyncConfigW (input)
 *       points to ASYNCCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
AsyncConfigU2A( PASYNCCONFIGA pAsyncConfigA,
                PASYNCCONFIGW pAsyncConfigW )
{
    UnicodeToAnsi( pAsyncConfigA->DeviceName,
                   sizeof(pAsyncConfigA->DeviceName),
                   pAsyncConfigW->DeviceName );

    UnicodeToAnsi( pAsyncConfigA->ModemName,
                   sizeof(pAsyncConfigA->ModemName),
                   pAsyncConfigW->ModemName );

    pAsyncConfigA->BaudRate = pAsyncConfigW->BaudRate;
    pAsyncConfigA->Parity = pAsyncConfigW->Parity;
    pAsyncConfigA->StopBits = pAsyncConfigW->StopBits;
    pAsyncConfigA->ByteSize = pAsyncConfigW->ByteSize;
    pAsyncConfigA->fEnableDsrSensitivity = pAsyncConfigW->fEnableDsrSensitivity;
    pAsyncConfigA->fConnectionDriver = pAsyncConfigW->fConnectionDriver;

    pAsyncConfigA->FlowControl = pAsyncConfigW->FlowControl;

    pAsyncConfigA->Connect = pAsyncConfigW->Connect;
}


/*******************************************************************************
 *
 *  AsyncConfigA2U (ANSI to UNICODE)
 *
 *    copies ASYNCCONFIGA elements to ASYNCCONFIGW elements
 *
 * ENTRY:
 *    pAsyncConfigW (output)
 *       points to ASYNCCONFIGW structure to copy to
 *
 *    pAsyncConfigA (input)
 *       points to ASYNCCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
AsyncConfigA2U( PASYNCCONFIGW pAsyncConfigW,
                PASYNCCONFIGA pAsyncConfigA )
{
    AnsiToUnicode( pAsyncConfigW->DeviceName,
                   sizeof(pAsyncConfigW->DeviceName),
                   pAsyncConfigA->DeviceName );

    AnsiToUnicode( pAsyncConfigW->ModemName,
                   sizeof(pAsyncConfigW->ModemName),
                   pAsyncConfigA->ModemName );

    pAsyncConfigW->BaudRate = pAsyncConfigA->BaudRate;
    pAsyncConfigW->Parity = pAsyncConfigA->Parity;
    pAsyncConfigW->StopBits = pAsyncConfigA->StopBits;
    pAsyncConfigW->ByteSize = pAsyncConfigA->ByteSize;
    pAsyncConfigW->fEnableDsrSensitivity = pAsyncConfigA->fEnableDsrSensitivity;

    pAsyncConfigW->FlowControl = pAsyncConfigA->FlowControl;

    pAsyncConfigW->Connect = pAsyncConfigA->Connect;
}


/*******************************************************************************
 *
 *  NasiConfigU2A (UNICODE to ANSI)
 *
 *    copies NASICONFIGW elements to NASICONFIGA elements
 *
 * ENTRY:
 *    pNasiConfigA (output)
 *       points to NASICONFIGA structure to copy to
 *
 *    pNasiConfigW (input)
 *       points to NASICONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
NasiConfigU2A( PNASICONFIGA pNasiConfigA,
                PNASICONFIGW pNasiConfigW )
{
    UnicodeToAnsi( pNasiConfigA->SpecificName,
                   sizeof(pNasiConfigA->SpecificName),
                   pNasiConfigW->SpecificName );
    UnicodeToAnsi( pNasiConfigA->UserName,
                   sizeof(pNasiConfigA->UserName),
                   pNasiConfigW->UserName );
    UnicodeToAnsi( pNasiConfigA->PassWord,
                   sizeof(pNasiConfigA->PassWord),
                   pNasiConfigW->PassWord );
    UnicodeToAnsi( pNasiConfigA->SessionName,
                   sizeof(pNasiConfigA->SessionName),
                   pNasiConfigW->SessionName );
    UnicodeToAnsi( pNasiConfigA->FileServer,
                   sizeof(pNasiConfigA->FileServer),
                   pNasiConfigW->FileServer );

    pNasiConfigA->GlobalSession = pNasiConfigW->GlobalSession;
}


/*******************************************************************************
 *
 *  NasiConfigA2U (ANSI to UNICODE)
 *
 *    copies NASICONFIGA elements to NASICONFIGW elements
 *
 * ENTRY:
 *    pNasiConfigW (output)
 *       points to NASICONFIGW structure to copy to
 *
 *    pNasiConfigA (input)
 *       points to NASICONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
NasiConfigA2U( PNASICONFIGW pNasiConfigW,
               PNASICONFIGA pNasiConfigA )
{
    AnsiToUnicode( pNasiConfigW->SpecificName,
                   sizeof(pNasiConfigW->SpecificName),
                   pNasiConfigA->SpecificName );
    AnsiToUnicode( pNasiConfigW->UserName,
                   sizeof(pNasiConfigW->UserName),
                   pNasiConfigA->UserName );
    AnsiToUnicode( pNasiConfigW->PassWord,
                   sizeof(pNasiConfigW->PassWord),
                   pNasiConfigA->PassWord );
    AnsiToUnicode( pNasiConfigW->SessionName,
                   sizeof(pNasiConfigW->SessionName),
                   pNasiConfigA->SessionName );
    AnsiToUnicode( pNasiConfigW->FileServer,
                   sizeof(pNasiConfigW->FileServer),
                   pNasiConfigA->FileServer );

    pNasiConfigW->GlobalSession = pNasiConfigA->GlobalSession;
}


/*******************************************************************************
 *
 *  OemTdConfigU2A (UNICODE to ANSI)
 *
 *    copies OEMTDCONFIGW elements to OEMTDCONFIGA elements
 *
 * ENTRY:
 *    pOemTdConfigA (output)
 *       points to OEMTDCONFIGA structure to copy to
 *
 *    pOemTdConfigW (input)
 *       points to OEMTDCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
OemTdConfigU2A( POEMTDCONFIGA pOemTdConfigA,
                POEMTDCONFIGW pOemTdConfigW )
{
    pOemTdConfigA->Adapter = pOemTdConfigW->Adapter;

    UnicodeToAnsi( pOemTdConfigA->DeviceName,
                   sizeof(pOemTdConfigA->DeviceName),
                   pOemTdConfigW->DeviceName );

    pOemTdConfigA->Flags = pOemTdConfigW->Flags;
}


/*******************************************************************************
 *
 *  OemTdConfigA2U (ANSI to Unicode)
 *
 *    copies OEMTDCONFIGA elements to OEMTDCONFIGW elements
 *
 * ENTRY:
 *    pOemTdConfigW (output)
 *       points to OEMTDCONFIGW structure to copy to
 *
 *    pOemTdConfigA (input)
 *       points to OEMTDCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
OemTdConfigA2U( POEMTDCONFIGW pOemTdConfigW,
                POEMTDCONFIGA pOemTdConfigA )
{
    pOemTdConfigW->Adapter = pOemTdConfigA->Adapter;

    AnsiToUnicode( pOemTdConfigW->DeviceName,
                   sizeof(pOemTdConfigW->DeviceName),
                   pOemTdConfigA->DeviceName );

    pOemTdConfigW->Flags = pOemTdConfigA->Flags;
}


/*******************************************************************************
 *
 *  WdConfigU2A (UNICODE to ANSI)
 *
 *    copies WDCONFIGW elements to WDCONFIGA elements
 *
 * ENTRY:
 *    pWdConfigA (output)
 *       points to WDCONFIGA structure to copy to
 *
 *    pWdConfigW (input)
 *       points to WDCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WdConfigU2A( PWDCONFIGA pWdConfigA,
             PWDCONFIGW pWdConfigW )
{
    UnicodeToAnsi( pWdConfigA->WdName,
                   sizeof(pWdConfigA->WdName),
                   pWdConfigW->WdName );

    UnicodeToAnsi( pWdConfigA->WdDLL,
                   sizeof(pWdConfigA->WdDLL),
                   pWdConfigW->WdDLL );

    UnicodeToAnsi( pWdConfigA->WsxDLL,
                   sizeof(pWdConfigA->WsxDLL),
                   pWdConfigW->WsxDLL );

    pWdConfigA->WdFlag = pWdConfigW->WdFlag;

    pWdConfigA->WdInputBufferLength = pWdConfigW->WdInputBufferLength;

    UnicodeToAnsi( pWdConfigA->CfgDLL,
                   sizeof(pWdConfigA->CfgDLL),
                   pWdConfigW->CfgDLL );

    UnicodeToAnsi( pWdConfigA->WdPrefix,
                   sizeof(pWdConfigA->WdPrefix),
                   pWdConfigW->WdPrefix );

}


/*******************************************************************************
 *
 *  WdConfigA2U (ANSI to UNICODE)
 *
 *    copies WDCONFIGA elements to WDCONFIGW elements
 *
 * ENTRY:
 *    pWdConfigW (output)
 *       points to WDCONFIGW structure to copy to
 *
 *    pWdConfigA (input)
 *       points to WDCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WdConfigA2U( PWDCONFIGW pWdConfigW,
             PWDCONFIGA pWdConfigA )
{
    AnsiToUnicode( pWdConfigW->WdName,
                   sizeof(pWdConfigW->WdName),
                   pWdConfigA->WdName );

    AnsiToUnicode( pWdConfigW->WdDLL,
                   sizeof(pWdConfigW->WdDLL),
                   pWdConfigA->WdDLL );

    AnsiToUnicode( pWdConfigW->WsxDLL,
                   sizeof(pWdConfigW->WsxDLL),
                   pWdConfigA->WsxDLL );

    pWdConfigW->WdFlag = pWdConfigA->WdFlag;

    pWdConfigW->WdInputBufferLength = pWdConfigA->WdInputBufferLength;

     AnsiToUnicode( pWdConfigW->CfgDLL,
                   sizeof(pWdConfigW->CfgDLL),
                   pWdConfigA->CfgDLL );

     AnsiToUnicode( pWdConfigW->WdPrefix,
                    sizeof(pWdConfigW->WdPrefix),
                    pWdConfigA->WdPrefix );

}


/*******************************************************************************
 *
 *  CdConfigU2A (UNICODE to ANSI)
 *
 *    copies CDCONFIGW elements to CDCONFIGA elements
 *
 * ENTRY:
 *    pCdConfigA (output)
 *       points to CDCONFIGA structure to copy to
 *
 *    pCdConfigW (input)
 *       points to CDCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
CdConfigU2A( PCDCONFIGA pCdConfigA,
             PCDCONFIGW pCdConfigW )
{
    pCdConfigA->CdClass = pCdConfigW->CdClass;

    UnicodeToAnsi( pCdConfigA->CdName,
                   sizeof(pCdConfigA->CdName),
                   pCdConfigW->CdName );

    UnicodeToAnsi( pCdConfigA->CdDLL,
                   sizeof(pCdConfigA->CdDLL),
                   pCdConfigW->CdDLL );

    pCdConfigA->CdFlag = pCdConfigW->CdFlag;
}


/*******************************************************************************
 *
 *  CdConfigA2U (ANSI to UNICODE)
 *
 *    copies CDCONFIGA elements to CDCONFIGW elements
 *
 * ENTRY:
 *    pCdConfigW (output)
 *       points to CDCONFIGW structure to copy to
 *
 *    pCdConfigA (input)
 *       points to CDCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
CdConfigA2U( PCDCONFIGW pCdConfigW,
             PCDCONFIGA pCdConfigA )
{
    pCdConfigW->CdClass = pCdConfigA->CdClass;

    AnsiToUnicode( pCdConfigW->CdName,
                   sizeof(pCdConfigW->CdName),
                   pCdConfigA->CdName );

    AnsiToUnicode( pCdConfigW->CdDLL,
                   sizeof(pCdConfigW->CdDLL),
                   pCdConfigA->CdDLL );

    pCdConfigW->CdFlag = pCdConfigA->CdFlag;
}


/*******************************************************************************
 *
 *  WinStationCreateU2A (UNICODE to ANSI)
 *
 *    copies WINSTATIONCREATEW elements to WINSTATIONCREATEA elements
 *
 * ENTRY:
 *    pWinStationCreateA (output)
 *       points to WINSTATIONCREATEA structure to copy to
 *
 *    pWinStationCreateW (input)
 *       points to WINSTATIONCREATEW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationCreateU2A( PWINSTATIONCREATEA pWinStationCreateA,
                     PWINSTATIONCREATEW pWinStationCreateW )
{
    pWinStationCreateA->fEnableWinStation = pWinStationCreateW->fEnableWinStation;
    pWinStationCreateA->MaxInstanceCount = pWinStationCreateW->MaxInstanceCount;
}


/*******************************************************************************
 *
 *  WinStationCreateA2U (ANSI to UNICODE)
 *
 *    copies WINSTATIONCREATEA elements to WINSTATIONCREATEW elements
 *
 * ENTRY:
 *    pWinStationCreateW (output)
 *       points to WINSTATIONCREATEW structure to copy to
 *
 *    pWinStationCreateA (input)
 *       points to WINSTATIONCREATEA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationCreateA2U( PWINSTATIONCREATEW pWinStationCreateW,
                     PWINSTATIONCREATEA pWinStationCreateA )
{
    pWinStationCreateW->fEnableWinStation = pWinStationCreateA->fEnableWinStation;
    pWinStationCreateW->MaxInstanceCount = pWinStationCreateA->MaxInstanceCount;
}


/*******************************************************************************
 *
 *  WinStationConfigU2A (UNICODE to ANSI)
 *
 *    copies WINSTATIONCONFIGW elements to WINSTATIONCONFIGA elements
 *
 * ENTRY:
 *    pWinStationConfigA (output)
 *       points to WINSTATIONCONFIGA structure to copy to
 *
 *    pWinStationConfigW (input)
 *       points to WINSTATIONCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationConfigU2A( PWINSTATIONCONFIGA pWinStationConfigA,
                     PWINSTATIONCONFIGW pWinStationConfigW )
{
    UnicodeToAnsi( pWinStationConfigA->Comment,
                   sizeof(pWinStationConfigA->Comment),
                   pWinStationConfigW->Comment );

    UserConfigU2A( &(pWinStationConfigA->User),
                   &(pWinStationConfigW->User) );

    RtlCopyMemory( pWinStationConfigA->OEMId,
                   pWinStationConfigW->OEMId,
                   sizeof(pWinStationConfigW->OEMId) );
}


/*******************************************************************************
 *
 *  WinStationConfigA2U (ANSI to UNICODE)
 *
 *    copies WINSTATIONCONFIGA elements to WINSTATIONCONFIGW elements
 *
 * ENTRY:
 *    pWinStationConfigW (output)
 *       points to WINSTATIONCONFIGW structure to copy to
 *
 *    pWinStationConfigA (input)
 *       points to WINSTATIONCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationConfigA2U( PWINSTATIONCONFIGW pWinStationConfigW,
                     PWINSTATIONCONFIGA pWinStationConfigA )
{
    AnsiToUnicode( pWinStationConfigW->Comment,
                   sizeof(pWinStationConfigW->Comment),
                   pWinStationConfigA->Comment );

    UserConfigA2U( &(pWinStationConfigW->User),
                   &(pWinStationConfigA->User) );

    RtlCopyMemory( pWinStationConfigW->OEMId,
                   pWinStationConfigA->OEMId,
                   sizeof(pWinStationConfigA->OEMId) );
}


/*******************************************************************************
 *
 *  UserConfigU2A (UNICODE to ANSI)
 *
 *    copies USERCONFIGW elements to USERCONFIGA elements
 *
 * ENTRY:
 *    pUserConfigA (output)
 *       points to USERCONFIGA structure to copy to
 *
 *    pUserConfigW (input)
 *       points to USERCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
UserConfigU2A( PUSERCONFIGA pUserConfigA,
               PUSERCONFIGW pUserConfigW )
{
    pUserConfigA->fInheritAutoLogon            = pUserConfigW->fInheritAutoLogon;
    pUserConfigA->fInheritResetBroken          = pUserConfigW->fInheritResetBroken;
    pUserConfigA->fInheritReconnectSame        = pUserConfigW->fInheritReconnectSame;
    pUserConfigA->fInheritInitialProgram       = pUserConfigW->fInheritInitialProgram;
    pUserConfigA->fInheritCallback             = pUserConfigW->fInheritCallback;
    pUserConfigA->fInheritCallbackNumber       = pUserConfigW->fInheritCallbackNumber;
    pUserConfigA->fInheritShadow               = pUserConfigW->fInheritShadow;
    pUserConfigA->fInheritMaxSessionTime       = pUserConfigW->fInheritMaxSessionTime;
    pUserConfigA->fInheritMaxDisconnectionTime = pUserConfigW->fInheritMaxDisconnectionTime;
    pUserConfigA->fInheritMaxIdleTime          = pUserConfigW->fInheritMaxIdleTime;
    pUserConfigA->fInheritAutoClient           = pUserConfigW->fInheritAutoClient;
    pUserConfigA->fInheritSecurity             = pUserConfigW->fInheritSecurity;

    pUserConfigA->fPromptForPassword = pUserConfigW->fPromptForPassword;
    pUserConfigA->fResetBroken       = pUserConfigW->fResetBroken;
    pUserConfigA->fReconnectSame     = pUserConfigW->fReconnectSame;
    pUserConfigA->fLogonDisabled     = pUserConfigW->fLogonDisabled;
    pUserConfigA->fWallPaperDisabled = pUserConfigW->fWallPaperDisabled;
    pUserConfigA->fAutoClientDrives  = pUserConfigW->fAutoClientDrives;
    pUserConfigA->fAutoClientLpts    = pUserConfigW->fAutoClientLpts;
    pUserConfigA->fForceClientLptDef = pUserConfigW->fForceClientLptDef;
    pUserConfigA->fDisableEncryption = pUserConfigW->fDisableEncryption;
    pUserConfigA->fHomeDirectoryMapRoot = pUserConfigW->fHomeDirectoryMapRoot;
    pUserConfigA->fUseDefaultGina    = pUserConfigW->fUseDefaultGina;

    pUserConfigA->fDisableCpm = pUserConfigW->fDisableCpm;
    pUserConfigA->fDisableCdm = pUserConfigW->fDisableCdm;
    pUserConfigA->fDisableCcm = pUserConfigW->fDisableCcm;
    pUserConfigA->fDisableLPT = pUserConfigW->fDisableLPT;
    pUserConfigA->fDisableClip = pUserConfigW->fDisableClip;
    pUserConfigA->fDisableExe = pUserConfigW->fDisableExe;
    pUserConfigA->fDisableCam = pUserConfigW->fDisableCam;

    UnicodeToAnsi( pUserConfigA->UserName,
                   sizeof(pUserConfigA->UserName),
                   pUserConfigW->UserName );

    UnicodeToAnsi( pUserConfigA->Domain,
                   sizeof(pUserConfigA->Domain),
                   pUserConfigW->Domain );

    UnicodeToAnsi( pUserConfigA->Password,
                   sizeof(pUserConfigA->Password),
                   pUserConfigW->Password );

    UnicodeToAnsi( pUserConfigA->WorkDirectory,
                   sizeof(pUserConfigA->WorkDirectory),
                   pUserConfigW->WorkDirectory );

    UnicodeToAnsi( pUserConfigA->InitialProgram,
                   sizeof(pUserConfigA->InitialProgram),
                   pUserConfigW->InitialProgram );

    UnicodeToAnsi( pUserConfigA->CallbackNumber,
                   sizeof(pUserConfigA->CallbackNumber),
                   pUserConfigW->CallbackNumber );

    pUserConfigA->Callback             = pUserConfigW->Callback;
    pUserConfigA->Shadow               = pUserConfigW->Shadow;
    pUserConfigA->MaxConnectionTime    = pUserConfigW->MaxConnectionTime;
    pUserConfigA->MaxDisconnectionTime = pUserConfigW->MaxDisconnectionTime;
    pUserConfigA->MaxIdleTime          = pUserConfigW->MaxIdleTime;
    pUserConfigA->KeyboardLayout       = pUserConfigW->KeyboardLayout;
    pUserConfigA->MinEncryptionLevel   = pUserConfigW->MinEncryptionLevel;

    UnicodeToAnsi( pUserConfigA->WFProfilePath,
                   sizeof(pUserConfigA->WFProfilePath),
                   pUserConfigW->WFProfilePath );

    UnicodeToAnsi( pUserConfigA->WFHomeDir,
                   sizeof(pUserConfigA->WFHomeDir),
                   pUserConfigW->WFHomeDir );

    UnicodeToAnsi( pUserConfigA->WFHomeDirDrive,
                   sizeof(pUserConfigA->WFHomeDirDrive),
                   pUserConfigW->WFHomeDirDrive );

}


/*******************************************************************************
 *
 *  UserConfigA2U (ANSI to UNICODE)
 *
 *    copies USERCONFIGA elements to USERCONFIGW elements
 *
 * ENTRY:
 *    pUserConfigW (output)
 *       points to USERCONFIGW structure to copy to
 *
 *    pUserConfigA (input)
 *       points to USERCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
UserConfigA2U( PUSERCONFIGW pUserConfigW,
               PUSERCONFIGA pUserConfigA )
{
    pUserConfigW->fInheritAutoLogon            = pUserConfigA->fInheritAutoLogon;
    pUserConfigW->fInheritResetBroken          = pUserConfigA->fInheritResetBroken;
    pUserConfigW->fInheritReconnectSame        = pUserConfigA->fInheritReconnectSame;
    pUserConfigW->fInheritInitialProgram       = pUserConfigA->fInheritInitialProgram;
    pUserConfigW->fInheritCallback             = pUserConfigA->fInheritCallback;
    pUserConfigW->fInheritCallbackNumber       = pUserConfigA->fInheritCallbackNumber;
    pUserConfigW->fInheritShadow               = pUserConfigA->fInheritShadow;
    pUserConfigW->fInheritMaxSessionTime       = pUserConfigA->fInheritMaxSessionTime;
    pUserConfigW->fInheritMaxDisconnectionTime = pUserConfigA->fInheritMaxDisconnectionTime;
    pUserConfigW->fInheritMaxIdleTime          = pUserConfigA->fInheritMaxIdleTime;
    pUserConfigW->fInheritAutoClient           = pUserConfigA->fInheritAutoClient;
    pUserConfigW->fInheritSecurity             = pUserConfigA->fInheritSecurity;

    pUserConfigW->fPromptForPassword = pUserConfigA->fPromptForPassword;
    pUserConfigW->fResetBroken       = pUserConfigA->fResetBroken;
    pUserConfigW->fReconnectSame     = pUserConfigA->fReconnectSame;
    pUserConfigW->fLogonDisabled     = pUserConfigA->fLogonDisabled;
    pUserConfigW->fWallPaperDisabled = pUserConfigA->fWallPaperDisabled;
    pUserConfigW->fAutoClientDrives  = pUserConfigA->fAutoClientDrives;
    pUserConfigW->fAutoClientLpts    = pUserConfigA->fAutoClientLpts;
    pUserConfigW->fForceClientLptDef = pUserConfigA->fForceClientLptDef;
    pUserConfigW->fDisableEncryption = pUserConfigA->fDisableEncryption;
    pUserConfigW->fHomeDirectoryMapRoot = pUserConfigA->fHomeDirectoryMapRoot;
    pUserConfigW->fUseDefaultGina    = pUserConfigA->fUseDefaultGina;

    pUserConfigW->fDisableCpm = pUserConfigA->fDisableCpm;
    pUserConfigW->fDisableCdm = pUserConfigA->fDisableCdm;
    pUserConfigW->fDisableCcm = pUserConfigA->fDisableCcm;
    pUserConfigW->fDisableLPT = pUserConfigA->fDisableLPT;
    pUserConfigW->fDisableClip = pUserConfigA->fDisableClip;
    pUserConfigW->fDisableExe = pUserConfigA->fDisableExe;
    pUserConfigW->fDisableCam = pUserConfigA->fDisableCam;

    AnsiToUnicode( pUserConfigW->UserName,
                   sizeof(pUserConfigW->UserName),
                   pUserConfigA->UserName );

    AnsiToUnicode( pUserConfigW->Domain,
                   sizeof(pUserConfigW->Domain),
                   pUserConfigA->Domain );

    AnsiToUnicode( pUserConfigW->Password,
                   sizeof(pUserConfigW->Password),
                   pUserConfigA->Password );

    AnsiToUnicode( pUserConfigW->WorkDirectory,
                   sizeof(pUserConfigW->WorkDirectory),
                   pUserConfigA->WorkDirectory );

    AnsiToUnicode( pUserConfigW->InitialProgram,
                   sizeof(pUserConfigW->InitialProgram),
                   pUserConfigA->InitialProgram );

    AnsiToUnicode( pUserConfigW->CallbackNumber,
                   sizeof(pUserConfigW->CallbackNumber),
                   pUserConfigA->CallbackNumber );

    pUserConfigW->Callback             = pUserConfigA->Callback;
    pUserConfigW->Shadow               = pUserConfigA->Shadow;
    pUserConfigW->MaxConnectionTime    = pUserConfigA->MaxConnectionTime;
    pUserConfigW->MaxDisconnectionTime = pUserConfigA->MaxDisconnectionTime;
    pUserConfigW->MaxIdleTime          = pUserConfigA->MaxIdleTime;
    pUserConfigW->KeyboardLayout       = pUserConfigA->KeyboardLayout;
    pUserConfigW->MinEncryptionLevel   = pUserConfigA->MinEncryptionLevel;

    AnsiToUnicode( pUserConfigW->WFProfilePath,
                   sizeof(pUserConfigW->WFProfilePath),
                   pUserConfigA->WFProfilePath );

    AnsiToUnicode( pUserConfigW->WFHomeDir,
                   sizeof(pUserConfigW->WFHomeDir),
                   pUserConfigA->WFHomeDir );

    AnsiToUnicode( pUserConfigW->WFHomeDirDrive,
                   sizeof(pUserConfigW->WFHomeDirDrive),
                   pUserConfigA->WFHomeDirDrive );

}


/*******************************************************************************
 *
 *  WinStationPrinterU2A (UNICODE to ANSI)
 *
 *    copies WINSTATIONPRINTERW elements to WINSTATIONPRINTERA elements
 *
 * ENTRY:
 *    pWinStationPrinterA (output)
 *       points to WINSTATIONPRINTERA structure to copy to
 *
 *    pWinStationPrinterW (input)
 *       points to WINSTATIONPRINTERW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationPrinterU2A( PWINSTATIONPRINTERA pWinStationPrinterA,
                      PWINSTATIONPRINTERW pWinStationPrinterW )
{
    UnicodeToAnsi( pWinStationPrinterA->Lpt1,
                   sizeof(pWinStationPrinterA->Lpt1),
                   pWinStationPrinterW->Lpt1 );

    UnicodeToAnsi( pWinStationPrinterA->Lpt2,
                   sizeof(pWinStationPrinterA->Lpt2),
                   pWinStationPrinterW->Lpt2 );

    UnicodeToAnsi( pWinStationPrinterA->Lpt3,
                   sizeof(pWinStationPrinterA->Lpt3),
                   pWinStationPrinterW->Lpt3 );

    UnicodeToAnsi( pWinStationPrinterA->Lpt4,
                   sizeof(pWinStationPrinterA->Lpt4),
                   pWinStationPrinterW->Lpt4 );

}


/*******************************************************************************
 *
 *  WinStationPrinterA2U (ANSI to UNICODE)
 *
 *    copies WINSTATIONPRINTERA elements to WINSTATIONPRINTERW elements
 *
 * ENTRY:
 *    pWinStationPrinterW (output)
 *       points to WINSTATIONPRINTERW structure to copy to
 *
 *    pWinStationPrinterA (input)
 *       points to WINSTATIONPRINTERA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationPrinterA2U( PWINSTATIONPRINTERW pWinStationPrinterW,
                      PWINSTATIONPRINTERA pWinStationPrinterA )
{
    AnsiToUnicode( pWinStationPrinterW->Lpt1,
                   sizeof(pWinStationPrinterW->Lpt1),
                   pWinStationPrinterA->Lpt1 );

    AnsiToUnicode( pWinStationPrinterW->Lpt2,
                   sizeof(pWinStationPrinterW->Lpt2),
                   pWinStationPrinterA->Lpt2 );

    AnsiToUnicode( pWinStationPrinterW->Lpt3,
                   sizeof(pWinStationPrinterW->Lpt3),
                   pWinStationPrinterA->Lpt3 );

    AnsiToUnicode( pWinStationPrinterW->Lpt4,
                   sizeof(pWinStationPrinterW->Lpt4),
                   pWinStationPrinterA->Lpt4 );

}


/*******************************************************************************
 *
 *  WinStationInformationU2A (UNICODE to ANSI)
 *
 *    copies WINSTATIONINFORMATIONW elements to WINSTATIONINFORMATIONA elements
 *
 * ENTRY:
 *    pWinStationInformationA (output)
 *       points to WINSTATIONINFORMATIONA structure to copy to
 *
 *    pWinStationInformationW (input)
 *       points to WINSTATIONINFORMATIONW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationInformationU2A( PWINSTATIONINFORMATIONA pWinStationInformationA,
                          PWINSTATIONINFORMATIONW pWinStationInformationW )
{
    pWinStationInformationA->ConnectState = pWinStationInformationW->ConnectState;

    UnicodeToAnsi( pWinStationInformationA->WinStationName,
                   sizeof(pWinStationInformationA->WinStationName),
                   pWinStationInformationW->WinStationName );

    pWinStationInformationA->LogonId = pWinStationInformationW->LogonId;

    pWinStationInformationA->ConnectTime = pWinStationInformationW->ConnectTime;
    pWinStationInformationA->DisconnectTime = pWinStationInformationW->DisconnectTime;
    pWinStationInformationA->LastInputTime = pWinStationInformationW->LastInputTime;
    pWinStationInformationA->LogonTime = pWinStationInformationW->LogonTime;

    pWinStationInformationA->Status = pWinStationInformationW->Status;

    UnicodeToAnsi( pWinStationInformationA->Domain,
                   sizeof(pWinStationInformationA->Domain),
                   pWinStationInformationW->Domain );

    UnicodeToAnsi( pWinStationInformationA->UserName,
                   sizeof(pWinStationInformationA->UserName),
                   pWinStationInformationW->UserName );
}


/*******************************************************************************
 *
 *  WinStationInformationA2U (ANSI to UNICODE)
 *
 *    copies WINSTATIONINFORMATIONA elements to WINSTATIONINFORMATIONW elements
 *
 * ENTRY:
 *    pWinStationInformationW (output)
 *       points to WINSTATIONINFORMATIONW structure to copy to
 *
 *    pWinStationInformationA (input)
 *       points to WINSTATIONINFORMATIONA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationInformationA2U( PWINSTATIONINFORMATIONW pWinStationInformationW,
                          PWINSTATIONINFORMATIONA pWinStationInformationA )
{
    pWinStationInformationW->ConnectState = pWinStationInformationA->ConnectState;

    AnsiToUnicode( pWinStationInformationW->WinStationName,
                   sizeof(pWinStationInformationW->WinStationName),
                   pWinStationInformationA->WinStationName );

    pWinStationInformationW->LogonId = pWinStationInformationA->LogonId;

    pWinStationInformationW->ConnectTime = pWinStationInformationA->ConnectTime;
    pWinStationInformationW->DisconnectTime = pWinStationInformationA->DisconnectTime;
    pWinStationInformationW->LastInputTime = pWinStationInformationA->LastInputTime;
    pWinStationInformationW->LogonTime = pWinStationInformationA->LogonTime;

    pWinStationInformationW->Status = pWinStationInformationA->Status;

    AnsiToUnicode( pWinStationInformationW->Domain,
                   sizeof(pWinStationInformationW->Domain),
                   pWinStationInformationA->Domain );

    AnsiToUnicode( pWinStationInformationW->UserName,
                   sizeof(pWinStationInformationW->UserName),
                   pWinStationInformationA->UserName );
}


/*******************************************************************************
 *
 *  WinStationClientU2A (UNICODE to ANSI)
 *
 *    copies WINSTATIONCLIENTW elements to WINSTATIONCLIENTA elements
 *
 * ENTRY:
 *    pWinStationClientA (output)
 *       points to WINSTATIONCLIENTA structure to copy to
 *
 *    pWinStationClientW (input)
 *       points to WINSTATIONCLIENTW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationClientU2A( PWINSTATIONCLIENTA pWinStationClientA,
                     PWINSTATIONCLIENTW pWinStationClientW )
{
    pWinStationClientA->fTextOnly          = pWinStationClientW->fTextOnly;
    pWinStationClientA->fDisableCtrlAltDel = pWinStationClientW->fDisableCtrlAltDel;

    UnicodeToAnsi( pWinStationClientA->ClientName,
                   sizeof(pWinStationClientA->ClientName),
                   pWinStationClientW->ClientName );

    UnicodeToAnsi( pWinStationClientA->Domain,
                   sizeof(pWinStationClientA->Domain),
                   pWinStationClientW->Domain );

    UnicodeToAnsi( pWinStationClientA->UserName,
                   sizeof(pWinStationClientA->UserName),
                   pWinStationClientW->UserName );

    UnicodeToAnsi( pWinStationClientA->Password,
                   sizeof(pWinStationClientA->Password),
                   pWinStationClientW->Password );

    UnicodeToAnsi( pWinStationClientA->WorkDirectory,
                   sizeof(pWinStationClientA->WorkDirectory),
                   pWinStationClientW->WorkDirectory );

    UnicodeToAnsi( pWinStationClientA->InitialProgram,
                   sizeof(pWinStationClientA->InitialProgram),
                   pWinStationClientW->InitialProgram );

    UnicodeToAnsi( pWinStationClientA->clientDigProductId, 
                                 sizeof( pWinStationClientA->clientDigProductId), 
                                 pWinStationClientW->clientDigProductId );

    pWinStationClientA->SerialNumber = pWinStationClientW->SerialNumber;

    pWinStationClientA->EncryptionLevel = pWinStationClientW->EncryptionLevel;


    UnicodeToAnsi( pWinStationClientA->ClientAddress,
                   sizeof(pWinStationClientA->ClientAddress),
                   pWinStationClientW->ClientAddress);

    pWinStationClientA->HRes = pWinStationClientW->HRes;

    pWinStationClientA->VRes = pWinStationClientW->VRes;

    pWinStationClientA->ColorDepth = pWinStationClientW->ColorDepth;

    pWinStationClientA->ProtocolType = pWinStationClientW->ProtocolType;

    pWinStationClientA->KeyboardLayout = pWinStationClientW->KeyboardLayout;

    UnicodeToAnsi( pWinStationClientA->ClientDirectory,
                   sizeof(pWinStationClientA->ClientDirectory),
                   pWinStationClientW->ClientDirectory);

    UnicodeToAnsi( pWinStationClientA->ClientLicense,
                   sizeof(pWinStationClientA->ClientLicense),
                   pWinStationClientW->ClientLicense);

    UnicodeToAnsi( pWinStationClientA->ClientModem,
                   sizeof(pWinStationClientA->ClientModem),
                   pWinStationClientW->ClientModem);

    pWinStationClientA->ClientBuildNumber = pWinStationClientW->ClientBuildNumber;

    pWinStationClientA->ClientHardwareId = pWinStationClientW->ClientHardwareId;

    pWinStationClientA->ClientProductId = pWinStationClientW->ClientProductId;

    pWinStationClientA->OutBufCountHost = pWinStationClientW->OutBufCountHost;

    pWinStationClientA->OutBufCountClient = pWinStationClientW->OutBufCountClient;

    pWinStationClientA->OutBufLength = pWinStationClientW->OutBufLength;
}


VOID WinStationProductIdU2A( PWINSTATIONPRODIDA pWinStationProdIdA, PWINSTATIONPRODIDW pWinStationProdIdW)
{
    UnicodeToAnsi( pWinStationProdIdA->DigProductId,
                   sizeof(pWinStationProdIdA->DigProductId),
                   pWinStationProdIdW->DigProductId);
    UnicodeToAnsi( pWinStationProdIdA->ClientDigProductId,
                   sizeof(pWinStationProdIdA->ClientDigProductId),
                   pWinStationProdIdW->ClientDigProductId);
    UnicodeToAnsi( pWinStationProdIdA->OuterMostDigProductId,
                   sizeof(pWinStationProdIdA->OuterMostDigProductId),
                   pWinStationProdIdW->OuterMostDigProductId);
    pWinStationProdIdA->curentSessionId = pWinStationProdIdW->curentSessionId;
    pWinStationProdIdA->ClientSessionId = pWinStationProdIdW->ClientSessionId;
    pWinStationProdIdA->OuterMostSessionId = pWinStationProdIdW->OuterMostSessionId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\cdmodem.h ===
/***************************************************************************
*
*  CDMODEM.H
*
*  This module contains private CD defines and structures 
*
*  Copyright 1996, Citrix Systems Inc.
*
*  Author:  Brad Pedersen (7/12/96)
*
* $Log:   N:\NT\PRIVATE\CITRIX\CD\CDMODEM\INC\VCS\CDMODEM.H  $
*  
*     Rev 1.1   06 Feb 1997 17:36:16   kurtp
*  update
*  
*     Rev 1.0   16 Oct 1996 11:17:36   brucef
*  Initial revision.
*  
*     Rev 1.3   25 Sep 1996 13:23:40   bradp
*  update
*  
*     Rev 1.2   11 Sep 1996 17:52:20   brucef
*  update
*  
*     Rev 1.1   05 Sep 1996 11:00:48   brucef
*  update
*  
*     Rev 1.0   15 Jul 1996 11:04:00   bradp
*  Initial revision.
*  
*  
*************************************************************************/

/*=============================================================================
==   Defines
=============================================================================*/

#ifdef DBG
#define DBGPRINT(_arg) DbgPrint _arg
#else
#define DBGPRINT(_arg) { }
#endif


/*
 *  these TIMEOUT values should come from the Registry
 */
#define DISCONN_TIMEOUT (10*1000)
#define CALLBACK_TIMEOUT (60*1000)

/* 
 * Given the total buffer size of a buffer which contains
 * a CDMODEM_ENDPOINT at the beginning, return the number of bytes
 * following the CDMODEM_ENDPOINT structure.
 */
#define STACK_ENDPOINT_SIZE(_sz) ( \
    (_sz) == 0 ? 0 : (_sz) - sizeof(CDMODEM_ENDPOINT) \
    )

/*
 * Given the address of a buffer which contains a CDMODEM_ENDPOINT
 * at the beginning, return the address of the word following the 
 * CDMODEM_ENDPOINT structure.
 */
#define STACK_ENDPOINT_ADDR(_ep) ( \
    (_ep) == NULL ? NULL : (PVOID)((BYTE *)(_ep) + sizeof(CDMODEM_ENDPOINT)) \
    )


/*=============================================================================
==   Structures
=============================================================================*/

/*
 *  Modem CD structure
 */
typedef struct _CDMODEM {

    HANDLE hStack;          // ica device driver stack handle

    DEVICENAME DeviceName;  // transport driver device name
    HANDLE hPort;           // modem port handle
    HANDLE hCommDevice;     // comm port handle
    HANDLE hDiscEvent;      // disconnect event handle, used by TAPI

} CDMODEM, * PCDMODEM;


/*
 * The CDMODEM_ENDPOINT prefixes the ICA_STACK_ENDOINT on device
 * connections that utilize a modem.  The Length element must
 * include not only the size of CDMODEM_ENDPOINT, but also the
 * Endpoint which it preceeds.
 *
 * !!! WARNING !!!
 * The length field must be in the same position within this 
 * structure as it is in the ICA_STACK_ENDPOINT structure (icadd.h>.
 */
typedef struct _CDMODEM_ENDPOINT {

    ULONG Length;           // length of ALL endpoint data
    HANDLE hPort;           // modem port handle
    HANDLE hCommDevice;     // comm port handle
    HANDLE hDiscEvent;      // disconnect event handle, used by TAPI

} CDMODEM_ENDPOINT, * PCDMODEM_ENDPOINT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\isdn.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//                     Copyright 1992-93
//
//  Filename: isdn.h
//
//  Revision History:
//
//  Feb 28, 1993	Gurdeep Pall Created
//
//
//  Description: This file contains all the device and media DLL interface
//		 information specific to ISDN.
//
//****************************************************************************


#ifndef _ISDNINCLUDE_
#define _ISDNINCLUDE_

#define ISDN_TXT "isdn"

// ISDN Media Parameter
//
#define ISDN_LINETYPE_KEY	"LineType"	// Param type NUMBER
#define ISDN_LINETYPE_VALUE_64DATA	0
#define ISDN_LINETYPE_VALUE_56DATA	1
#define ISDN_LINETYPE_VALUE_56VOICE	2
#define ISDN_LINETYPE_STRING_64DATA	"0"
#define ISDN_LINETYPE_STRING_56DATA	"1"
#define ISDN_LINETYPE_STRING_56VOICE	"2"


#define ISDN_FALLBACK_KEY	"Fallback"	// Param type NUMBER
#define ISDN_FALLBACK_VALUE_ON		1
#define ISDN_FALLBACK_VALUE_OFF 	0
#define ISDN_FALLBACK_STRING_ON		"1"
#define ISDN_FALLBACK_STRING_OFF	"0"



#define ISDN_COMPRESSION_KEY	"EnableCompression" // Param type NUMBER
#define ISDN_COMPRESSION_VALUE_ON	1
#define ISDN_COMPRESSION_VALUE_OFF	0
#define ISDN_COMPRESSION_STRING_ON	"1"
#define ISDN_COMPRESSION_STRING_OFF	"0"


#define ISDN_CHANNEL_AGG_KEY	"ChannelAggregation"// Param type NUMBER


// ISDN Device Parameter
//
#define ISDN_PHONENUMBER_KEY	"PhoneNumber"	// Param type STRING
#define MAX_PHONENUMBER_LEN	255

#define CONNECTBPS_KEY		"ConnectBPS"	// Param type STRING


//  Statistics information and indices.
//
#define NUM_ISDN_STATS		10

#define BYTES_XMITED		0	// Generic Stats
#define BYTES_RCVED             1
#define FRAMES_XMITED           2
#define FRAMES_RCVED            3

#define CRC_ERR 		4	// Isdn Stats
#define TIMEOUT_ERR             5
#define ALIGNMENT_ERR           6
#define SERIAL_OVERRUN_ERR      7
#define FRAMING_ERR             8
#define BUFFER_OVERRUN_ERR      9

#endif // _ISDNINCLUDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\media.h ===
//***************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//
//  Revision History:
//
//  Jul 22, 1992   J. Perry Hannah   Created
//  Aug 11, 1992   Gurdeep Pall      Added Media data structures
//
//  Description: This file contains function prototypes and structures
//               used by the interface between RAS Manager and the
//               Media DLLs.
//
//****************************************************************************


#ifndef _MEDIADLLHEADER_
#define _MEDIADLLHEADER_



//  General Defines  *********************************************************
//

#define SS_HARDWAREFAILURE  0x00000001
#define SS_LINKDROPPED      0x00000002



//*  Data Structures  ********************************************************
//

#define MAC_NAME_SIZE	32

struct PortMediaInfo {
    CHAR          PMI_Name [MAX_PORT_NAME] ;
    CHAR          PMI_MacBindingName[MAC_NAME_SIZE] ;
    RASMAN_USAGE  PMI_Usage ;
    CHAR          PMI_DeviceType [MAX_DEVICETYPE_NAME] ;
    CHAR	  PMI_DeviceName [MAX_DEVICE_NAME] ;
    DWORD	  PMI_LineDeviceId ;	// Valid for TAPI devices only
    DWORD	  PMI_AddressId ;	// Valid for TAPI devices only
} ;


typedef struct PortMediaInfo PortMediaInfo ;




//*  API References  *********************************************************
//

typedef  DWORD (APIENTRY * PortEnum_t)(BYTE *, WORD *, WORD *);

typedef  DWORD (APIENTRY * PortOpen_t)(char *, HANDLE *, HANDLE);

typedef  DWORD (APIENTRY * PortClose_t)(HANDLE);

#ifndef CITRIX
typedef  DWORD (APIENTRY * PortGetInfo_t)(HANDLE, TCHAR *, BYTE *, WORD *);
#else
typedef  DWORD (APIENTRY * PortGetInfo_t)(HANDLE, CHAR *, BYTE *, WORD *);
#endif

typedef  DWORD (APIENTRY * PortSetInfo_t)(HANDLE, RASMAN_PORTINFO *);

typedef  DWORD (APIENTRY * PortTestSignalState_t)(HANDLE, DWORD *);

typedef  DWORD (APIENTRY * PortConnect_t)(HANDLE, BOOL, DWORD *) ;

typedef  DWORD (APIENTRY * PortDisconnect_t)(HANDLE);

typedef  DWORD (APIENTRY * PortInit_t)(HANDLE);

typedef  DWORD (APIENTRY * PortCompressionSetInfo_t)(HANDLE) ;

typedef  DWORD (APIENTRY * PortSend_t)(HANDLE, BYTE *, DWORD, HANDLE);

typedef  DWORD (APIENTRY * PortReceive_t)(HANDLE, BYTE *, DWORD, DWORD,
                                                                 HANDLE);

typedef  DWORD (APIENTRY * PortGetStatistics_t)(HANDLE, RAS_STATISTICS *);

typedef  DWORD (APIENTRY * PortClearStatistics_t)(HANDLE);

typedef  DWORD (APIENTRY * PortGetPortState_t)(BYTE *, DWORD *);

typedef  DWORD (APIENTRY * PortChangeCallback_t)(HANDLE);

typedef  DWORD (APIENTRY * PortReceiveComplete_t)(HANDLE, DWORD *);

typedef  DWORD (APIENTRY * PortSetFraming_t)(HANDLE, DWORD, DWORD, DWORD, DWORD);

typedef  DWORD (APIENTRY * PortGetIOHandle_t)(HANDLE, HANDLE*);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\eventlog.h ===
/********************************************************************/
/**           Copyright(c) 1992 Microsoft Corporation.             **/
/********************************************************************/

//***
//
// Filename:  eventlog.h
//
// Description: 
//
// History:
//   Dec 09,1992  J. Perry Hannah (perryh)  Created original version.
//
//***


VOID
LogEvent(
    IN DWORD  dwMessageId,
    IN WORD   cNumberOfSubStrings,
    IN LPSTR  *plpwsSubStrings,
    IN DWORD  dwErrorCode);


VOID Audit(
    IN WORD wEventType,
    IN DWORD dwMessageId,
    IN WORD cNumberOfSubStrings,
    IN LPSTR *plpwsSubStrings
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\mprlog.h ===
/********************************************************************/
/**            Copyright(c) 1992 Microsoft Corporation.            **/
/********************************************************************/

//***
//
// Filename:    mprlog.h
//
// Description:
//
// History:     August 26,1995.  NarenG Created original version.
//
//***

//
// Don't change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define ROUTER_LOG_BASE                                 20000

#define ROUTERLOG_CANT_LOAD_NBGATEWAY                   (ROUTER_LOG_BASE+1)
/*
 * Cannot load the NetBIOS gateway DLL component because of the following error: %1
 */

#define ROUTERLOG_CANT_GET_REGKEYVALUES                 (ROUTER_LOG_BASE+2)
/*
 * Cannot access registry key values.
 */

#define ROUTERLOG_CANT_ENUM_REGKEYVALUES                (ROUTER_LOG_BASE+3)
/*
 * Cannot enumerate Registry key values. %1
 */

#define ROUTERLOG_INVALID_PARAMETER_TYPE                (ROUTER_LOG_BASE+4)
/*
 * Parameter %1 has an invalid type.
 */

#define ROUTERLOG_CANT_ENUM_PORTS                       (ROUTER_LOG_BASE+5)
/*
 * Cannot enumerate the Remote Access Connection Manager ports. %1
 */

#define ROUTERLOG_NO_DIALIN_PORTS                       (ROUTER_LOG_BASE+6)
/*
 * The Remote Access Service is not configured to receive calls or all ports
 * configured for receiving calls are in use by other applications.
 */

#define ROUTERLOG_CANT_RECEIVE_FRAME                    (ROUTER_LOG_BASE+7)
/*
 * Cannot receive initial frame on port %1 because of the following error: %2
 * The user has been disconnected.
 */

#define ROUTERLOG_AUTODISCONNECT                        (ROUTER_LOG_BASE+8)
/*
 * The user connected to port %1 has been disconnected due to inactivity.
 */

#define ROUTERLOG_EXCEPT_MEMORY                         (ROUTER_LOG_BASE+9)
/*
 * The user connected to port %1 has been disconnected because there is not
 * enough memory available in the system.
 */

#define ROUTERLOG_EXCEPT_SYSTEM                         (ROUTER_LOG_BASE+10)
/*
 * The user connected to port %1 has been disconnected due to a system error.
 */

#define ROUTERLOG_EXCEPT_LAN_FAILURE                    (ROUTER_LOG_BASE+11)
/*
 * The user connected to port %1 has been disconnected due to a critical network
 * error on the local network.
 */

#define ROUTERLOG_EXCEPT_ASYNC_FAILURE                  (ROUTER_LOG_BASE+12)
/*
 * The user connected to port %1 has been disconnected due to a critical network
 * error on the async network.
 */

#define ROUTERLOG_DEV_HW_ERROR                          (ROUTER_LOG_BASE+13)
/*
 * The communication device attached to port %1 is not functioning.
 */

#define ROUTERLOG_AUTH_FAILURE                          (ROUTER_LOG_BASE+14)
/*
 * The user %1 has connected and failed to authenticate on port %2. The line
 * has been disconnected.
 */

#define ROUTERLOG_AUTH_SUCCESS                          (ROUTER_LOG_BASE+15)
/*
 * The user %1 has connected and has been successfully authenticated on
 * port %2.
 */

#define ROUTERLOG_AUTH_CONVERSATION_FAILURE             (ROUTER_LOG_BASE+16)
/*
 * The user connected to port %1 has been disconnected because there was a
 * transport-level error during the authentication conversation.
 */

#define ROUTERLOG_CANT_RESET_LAN                        (ROUTER_LOG_BASE+18)
/*
 * Cannot reset the network adapter for LANA %1. The error code is the data.
 */

#define ROUTERLOG_CANT_GET_COMPUTERNAME                 (ROUTER_LOG_BASE+19)
/*
 * Remote Access Server Security Failure.
 * Cannot locate the computer name. GetComputerName call has failed.
 */

#define ROUTERLOG_CANT_ADD_RASSECURITYNAME              (ROUTER_LOG_BASE+20)
/*
 * Remote Access Server Security Failure.
 * Cannot add the name for communication with the security agent on LANA %1.
 */

#define ROUTERLOG_CANT_GET_ADAPTERADDRESS               (ROUTER_LOG_BASE+21)
/*
 * Remote Access Server Security Failure.
 * Cannot access the network adapter address on LANA %1.
 */

#define ROUTERLOG_SESSOPEN_REJECTED                     (ROUTER_LOG_BASE+22)
/*
 * Remote Access Server Security Failure.
 * The security agent has rejected the Remote Access server's call to
 * establish a session on LANA %1.
 */

#define ROUTERLOG_START_SERVICE_REJECTED                (ROUTER_LOG_BASE+23)
/*
 * Remote Access Server Security Failure.
 * The security agent has rejected the Remote Access server's request to start
 * the service on this computer on LANA %1.
 */

#define ROUTERLOG_SECURITY_NET_ERROR                    (ROUTER_LOG_BASE+24)
/*
 * Remote Access Server Security Failure.
 * A network error has occurred when trying to establish a session with the
 * security agent on LANA %1.
 * The error code is the data.
 */

#define ROUTERLOG_EXCEPT_OSRESNOTAV                     (ROUTER_LOG_BASE+25)
/*
 * The user connected to port %1 has been disconnected because there are no
 * operating system resources available.
 */

#define ROUTERLOG_EXCEPT_LOCKFAIL                       (ROUTER_LOG_BASE+26)
/*
 * The user connected to port %1 has been disconnected because of a failure to
 * lock user memory.
 */

#define ROUTERLOG_CANNOT_OPEN_RASHUB                    (ROUTER_LOG_BASE+27)
/*
 * Remote Access Connection Manager failed to start because NDISWAN could not
 * be opened. Restart the computer. If the problem persists, reinstall the
 * Remote Access Service. %1
 */


#define ROUTERLOG_CANNOT_INIT_SEC_ATTRIBUTE             (ROUTER_LOG_BASE+28)
/*
 *   Remote Access Connection Manager failed to start because it could not initialize the
 * security attributes. Restart the computer. If the problem persists, reinstall the Remote Access Service. %1
 */


#define ROUTERLOG_CANNOT_GET_ENDPOINTS                  (ROUTER_LOG_BASE+29)
/*
 *   Remote Access Connection Manager failed to start because no endpoints were available.
 * Restart the computer. If the problem persists, reinstall the Remote Access Service.
 */


#define ROUTERLOG_CANNOT_GET_MEDIA_INFO                 (ROUTER_LOG_BASE+30)
/*
 *   Remote Access Connection Manager failed to start because it could not load one or
 * more communication DLLs. Ensure that your communication hardware is installed and then
 * restart the computer. If the problem persists, reinstall the Remote Access Service. %1
 */


#define ROUTERLOG_CANNOT_GET_PORT_INFO                  (ROUTER_LOG_BASE+31)
/*
 *   Remote Access Connection Manager failed to start because it could not locate port
 * information from media DLLs.
 * Restart the computer. If the problem persists, reinstall the Remote Access Service. %1
 */


#define ROUTERLOG_CANNOT_GET_PROTOCOL_INFO              (ROUTER_LOG_BASE+32)
/*
 *   Remote Access Connection Manager failed to start because it could not access
 * protocol information from the Registry.
 * Restart the computer. If the problem persists, reinstall the Remote Access Service. %1
 */


#define ROUTERLOG_CANNOT_REGISTER_LSA                   (ROUTER_LOG_BASE+33)
/*
 *   Remote Access Connection Manager failed to start because it could not register
 * with the local security authority.
 * Restart the computer. If the problem persists, reinstall the Remote Access Service. %1
 */


#define ROUTERLOG_CANNOT_CREATE_FILEMAPPING             (ROUTER_LOG_BASE+34)
/*
 *   Remote Access Connection Manager failed to start because it could not create shared
 * file mapping.
 * Restart the computer. If the problem persists, reinstall the Remote Access Service. %1
 */


#define ROUTERLOG_CANNOT_INIT_BUFFERS                   (ROUTER_LOG_BASE+35)
/*
 *   Remote Access Connection Manager failed to start because it could not create buffers.
 * Restart the computer. If the problem persists, reinstall the Remote Access Service. %1
 */


#define ROUTERLOG_CANNOT_INIT_REQTHREAD                 (ROUTER_LOG_BASE+36)
/*
 *   Remote Access Connection Manager failed to start because it could not access resources.
 * Restart the computer. If the problem persists, reinstall the Remote Access Service. %1
 */


#define ROUTERLOG_CANNOT_START_WORKERS                  (ROUTER_LOG_BASE+37)
/*
 *   Remote Access Connection Manager service failed to start because it could not start worker
 * threads.
 * Restart the computer. If the problem persists, reinstall the Remote Access Service.
 */

#define ROUTERLOG_CANT_GET_LANNETS                      (ROUTER_LOG_BASE+38)
/*
 * Remote Access Server Configuration Failure.
 * Cannot find the LANA numbers for the network adapters.
 */

#define ROUTERLOG_CANNOT_OPEN_SERIAL_INI                (ROUTER_LOG_BASE+39)
/*
 * RASSER.DLL cannot open the SERIAL.INI file.
 */

#define ROUTERLOG_CANNOT_GET_ASYNCMAC_HANDLE            (ROUTER_LOG_BASE+40)
/*
 * An attempt by RASSER.DLL to get an async media access control handle failed.
 */

#define ROUTERLOG_CANNOT_LOAD_SERIAL_DLL                (ROUTER_LOG_BASE+41)
/*
 * RASMXS.DLL cannot load RASSER.DLL.
 */

#define ROUTERLOG_CANNOT_ALLOCATE_ROUTE                 (ROUTER_LOG_BASE+42)
/*
 * The Remote Access server cannot allocate a route for the user connected on port %1 bacause of the following error: %2
 * The user has been disconnected.
 * Check the configuration of your Remote Access Service.
 */

#define ROUTERLOG_ADMIN_MEMORY_FAILURE                  (ROUTER_LOG_BASE+43)
/*
 * Cannot allocate memory in the admin support thread for the Remote Access Service.
 */

#define ROUTERLOG_ADMIN_THREAD_CREATION_FAILURE         (ROUTER_LOG_BASE+44)
/*
 * Cannot create an instance thread in the admin support thread for the Remote Access Service.
 */

#define ROUTERLOG_ADMIN_PIPE_CREATION_FAILURE           (ROUTER_LOG_BASE+45)
/*
 * Cannot create a named pipe instance in the admin support thread for the Remote Access Service.
 */

#define ROUTERLOG_ADMIN_PIPE_FAILURE                    (ROUTER_LOG_BASE+46)
/*
 * General named pipe failure occurred in the admin support thread for the Remote Access Service.
 */

#define ROUTERLOG_ADMIN_INVALID_REQUEST                 (ROUTER_LOG_BASE+47)
/*
 * An invalid request was sent to the admin support thread for the Remote Access Service,
 * possibly from a down-level admin tool.  The request was not processed.
 */

#define ROUTERLOG_USER_ACTIVE_TIME				        (ROUTER_LOG_BASE+48)
/*
 * The user %1 connected on port %2 on %3 at %4 and disconnected on
 * %5 at %6.  The user was active for %7 minutes %8 seconds.  %9 bytes
 * were sent and %10 bytes were received. The port speed was %11.  The
 * reason for disconnecting was %12.
 */

#define ROUTERLOG_AUTH_TIMEOUT                          (ROUTER_LOG_BASE+49)
/*
 * The user connected to port %1 has been disconnected due to an authentication
 * timeout.
 */

#define ROUTERLOG_AUTH_NO_PROJECTIONS                   (ROUTER_LOG_BASE+50)
/*
 * The user %1 connected to port %2 has been disconnected because no network protocols were successfully negotiatated.
 */

#define ROUTERLOG_AUTH_INTERNAL_ERROR                   (ROUTER_LOG_BASE+51)
/*
 * The user connected to port %1 has been disconnected because an internal authentication error occurred.
 */

#define ROUTERLOG_NO_LANNETS_AVAILABLE			        (ROUTER_LOG_BASE+52)
/*
 * The Remote Access server could not be started because the NetBIOS gateway has been configured to access the network but there are no network adapters available.
 */

#define ROUTERLOG_NETBIOS_SESSION_ESTABLISHED		    (ROUTER_LOG_BASE+53)
/*
 * The user %1 established a NetBIOS session between
 * the remote workstation %2 and the network server %3.
 */

#define ROUTERLOG_RASMAN_NOT_AVAILABLE			        (ROUTER_LOG_BASE+54)
/*
 * Remote Access Service failed to start because the Remote Access Connection Manager failed to initialize because of the following error: %1
 */

#define ROUTERLOG_CANT_ADD_NAME				            (ROUTER_LOG_BASE+55)
/*
 * Cannot add the remote computer name %1 on LANA %2 for the client being connected on port %3.
 * The error code is the data.
 */

#define ROUTERLOG_CANT_DELETE_NAME 			            (ROUTER_LOG_BASE+56)
/*
 * Cannot delete the remote computer name %1 from LANA %2 for the client being disconnected on port %3.
 * The error code is the data.
 */

#define ROUTERLOG_CANT_ADD_GROUPNAME			        (ROUTER_LOG_BASE+57)
/*
 * Cannot add the remote computer group name %1 on LANA %2.
 * The error code is the data.
 */

#define ROUTERLOG_CANT_DELETE_GROUPNAME			        (ROUTER_LOG_BASE+58)
/*
 * Cannot delete the remote computer group name %1 from LANA %2.
 * The error code is the data.
 */

#define ROUTERLOG_UNSUPPORTED_BPS                       (ROUTER_LOG_BASE+59)
/*
 * The modem on %1 moved to an unsupported BPS rate.
 */

#define ROUTERLOG_SERIAL_QUEUE_SIZE_SMALL			    (ROUTER_LOG_BASE+60)
/*
 * The serial driver could not allocate adequate I/O queues.
 * This may result in an unreliable connection.
 */

#define ROUTERLOG_CANNOT_REOPEN_BIPLEX_PORT		        (ROUTER_LOG_BASE+61)
/*
 * Remote Access Connection Manager could not reopen biplex port %1. This port
 * will not be available for calling in or calling out.
 * Restart all Remote Access Service components.
 */

#define ROUTERLOG_DISCONNECT_ERROR 			            (ROUTER_LOG_BASE+62)
/*
 * Internal Error: Disconnect operation on %1 completed with an error. %1
 */

#define ROUTERLOG_CANNOT_INIT_PPP				        (ROUTER_LOG_BASE+63)
/*
 * Remote Access Connection Manager failed to start because the Point to Point
 * Protocol failed to initialize. %1
 */

#define ROUTERLOG_CLIENT_CALLED_BACK                    (ROUTER_LOG_BASE+64)
/*
 * The user %1 on port %2 was called back at the number %3.
 */

#define ROUTERLOG_PROXY_CANT_CREATE_PROCESS             (ROUTER_LOG_BASE+65)
/*
 * The Remote Access Gateway Proxy could not create a process.
 */

#define ROUTERLOG_PROXY_CANT_CREATE_PIPE                (ROUTER_LOG_BASE+66)
/*
 * The Remote Access Gateway Proxy could not create a named pipe.
 */

#define ROUTERLOG_PROXY_CANT_CONNECT_PIPE               (ROUTER_LOG_BASE+67)
/*
 * The Remote Access Gateway Proxy could not establish a named pipe connection
 * with the Remote Access Supervisor Proxy.
 */

#define ROUTERLOG_PROXY_READ_PIPE_FAILURE               (ROUTER_LOG_BASE+68)
/*
 * A general error occurred reading from the named pipe in the Remote Access Proxy.
 */

#define ROUTERLOG_CANT_OPEN_PPP_REGKEY			        (ROUTER_LOG_BASE+69)
/*
 * Cannot open or obtain information about the PPP key or one of its subkeys. %1
 */

#define ROUTERLOG_PPP_CANT_LOAD_DLL			            (ROUTER_LOG_BASE+70)
/*
 * Point to Point Protocol engine was unable to load the %1 module. %2
 */

#define ROUTERLOG_PPPCP_DLL_ERROR				        (ROUTER_LOG_BASE+71)
/*
 * The Point to Point Protocol module %1 returned an error while initializing.
 * %2
 */

#define ROUTERLOG_NO_AUTHENTICATION_CPS			        (ROUTER_LOG_BASE+72)
/*
 * The Point to Point Protocol failed to load the required PAP and/or CHAP
 * authentication modules.
 */

#define ROUTERLOG_PPP_FAILURE                           (ROUTER_LOG_BASE+73)
/*
 * The following error occurred in the Point to Point Protocol module on port: %1, UserName: %2.
 * %3
 */

#define ROUTERLOG_IPXCP_NETWORK_NUMBER_CONFLICT		    (ROUTER_LOG_BASE+74)
/*
 * The IPX network number %1 requested by the remote side for the WAN interface
 * is already in use on the local LAN.
 * Possible solution:
 * Disconnect this computer from the LAN and wait 3 minutes before dialing again;
 */

#define ROUTERLOG_IPXCP_CANNOT_CHANGE_WAN_NETWORK_NUMBER    (ROUTER_LOG_BASE+75)
/*
 * The IPX network number %1 requested by the remote workstation for the WAN interface
 * can not be used on the local IPX router because the router is configured to
 * give the same network number to all the remote workstations.
 * If you want to connect a remote workstation with a different network number you
 * should reconfigure the router to disable the common network number option.
 */

#define ROUTERLOG_PASSWORD_EXPIRED                      (ROUTER_LOG_BASE+76)
/*
 * The password for user %1\%2 connected on port %3 has expired.  The line
 * has been disconnected.
 */

#define ROUTERLOG_ACCT_EXPIRED                          (ROUTER_LOG_BASE+77)
/*
 * The account for user %1\%2 connected on port %3 has expired.  The line
 * has been disconnected.
 */

#define ROUTERLOG_NO_DIALIN_PRIVILEGE                   (ROUTER_LOG_BASE+78)
/*
 * The account for user %1\%2 connected on port %3 does not have Remote Access
 * privilege.  The line has been disconnected.
 */

#define ROUTERLOG_UNSUPPORTED_VERSION                   (ROUTER_LOG_BASE+79)
/*
 * The software version of the user %1\%2 connected on port %3 is unsupported.
 * The line has been disconnected.
 */

#define ROUTERLOG_ENCRYPTION_REQUIRED                   (ROUTER_LOG_BASE+80)
/*
 * The server machine is configured to require data encryption.  The machine
 * for user %1\%2 connected on port %3 does not support encryption.  The line
 * has been disconnected.
 */

#define ROUTERLOG_NO_SECURITY_CHECK                     (ROUTER_LOG_BASE+81)
/*
 * Remote Access Server Security Failure.  Could not reset lana %1 (the error
 * code is the data).  Security check not performed.
 */

#define ROUTERLOG_GATEWAY_NOT_ACTIVE_ON_NET             (ROUTER_LOG_BASE+82)
/*
 * The Remote Access Server could not reset lana %1 (the error code is the
 * data) and will not be active on it.
 */

#define ROUTERLOG_IPXCP_WAN_NET_POOL_NETWORK_NUMBER_CONFLICT    (ROUTER_LOG_BASE+83)
/*
 * The IPX network number %1 configured for the pool of WAN network numbers
 * can not be used because it conflicts with another network number on the net.
 * You should re-configure the pool to have unique network numbers.
 */

#define ROUTERLOG_SRV_ADDR_CHANGED                      (ROUTER_LOG_BASE+84)
/*
 * The Remote Access Server will stop using IP Address %1 (either because it
 * was unable to renew the lease from the DHCP Server, or the administrator
 * switched between static address pool and DHCP addresses). All connected users
 * using IP will be unable to access network resources. Users can re-connect
 * to the server to restore IP connectivity.
 */

#define ROUTERLOG_CLIENT_ADDR_LEASE_LOST			    (ROUTER_LOG_BASE+85)
/*
 * The Remote Access Server was unable to renew the lease for IP Address %1
 * from the DHCP Server. The user assigned with this IP address will be unable to
 * access network resources using IP. Re-connecting to the server will restore IP
 * connectivity.
 */

#define ROUTERLOG_ADDRESS_NOT_AVAILABLE			        (ROUTER_LOG_BASE+86)
/*
 * The Remote Access Server was unable to acquire an IP Address from the DHCP Server
 * to assign to the incoming user.
 */

#define ROUTERLOG_SRV_ADDR_NOT_AVAILABLE			    (ROUTER_LOG_BASE+87)
/*
 * The Remote Access Server was unable to acquire an IP Address from the DHCP Server
 * to be used on the Server Adapter. Incoming user will be unable to connect using
 * IP.
 */

#define ROUTERLOG_SRV_ADDR_ACQUIRED			            (ROUTER_LOG_BASE+88)
/*
 * The Remote Access Server acquired IP Address %1 to be used on the Server
 * Adapter.
 */

#define ROUTERLOG_CALLBACK_FAILURE                      (ROUTER_LOG_BASE+89)
/*
 * The Remote Access Server's attempt to callback user %1 on port %2 at %3
 * failed because of the following error: %4
 */

#define ROUTERLOG_PROXY_WRITE_PIPE_FAILURE              (ROUTER_LOG_BASE+90)
/*
 * A general error occurred writing to the named pipe in the Remote Access Proxy.
 */

#define ROUTERLOG_CANT_OPEN_SECMODULE_KEY               (ROUTER_LOG_BASE+91)
/*
 * Cannot open the RAS security host Registry key. The following error
 * occurred: %1
 */

#define ROUTERLOG_CANT_LOAD_SECDLL                      (ROUTER_LOG_BASE+92)
/*
 * Cannot load the Security host module component. The following error
 * occurred: %1
 */

#define ROUTERLOG_SEC_AUTH_FAILURE                      (ROUTER_LOG_BASE+93)
/*
 * The user %1 has connected and failed to authenticate with a third party
 * security on port %2. The line has been disconnected.
 */

#define ROUTERLOG_SEC_AUTH_INTERNAL_ERROR               (ROUTER_LOG_BASE+94)
/*
 * The user connected to port %1 has been disconnected because the following 
 * internal authentication error occurred in the third party security module: %2
 */

#define ROUTERLOG_CANT_RECEIVE_BYTES                    (ROUTER_LOG_BASE+95)
/*
 * Cannot receive initial data on port %1 because of the following error: %2
 * The user has been disconnected.
 */

#define ROUTERLOG_AUTH_DIFFUSER_FAILURE                 (ROUTER_LOG_BASE+96)
/*
 * The user was autheticated as %1 by the third party security host module but
 * was authenticated as %2 by the RAS security. The user has been disconnected.
 */

#define ROUTERLOG_LICENSE_LIMIT_EXCEEDED                (ROUTER_LOG_BASE+97)
/*
 * A user was unable to connect on port %1.
 * No more connections can be made to this remote computer because the computer
 * has exceeded its client license limit.
 */

#define ROUTERLOG_AMB_CLIENT_NOT_ALLOWED                (ROUTER_LOG_BASE+98)
/*
 * A user was unable to connect on port %1.
 * The NetBIOS protocol has been disabled for the Remote Access Server.
 */
#define ROUTERLOG_CANT_QUERY_VALUE                      (ROUTER_LOG_BASE+99)
/*
 * Cannot access Registry value for %1.
 */

#define ROUTERLOG_CANT_OPEN_REGKEY                      (ROUTER_LOG_BASE+100)
/*
 * Cannot access the Registry key %1.
 */

#define ROUTERLOG_REGVALUE_OVERIDDEN                    (ROUTER_LOG_BASE+101)
/*
 * Using the default value for Registry parameter %1 because the value given is
 * not in the legal range for the parameter.
 */

#define ROUTERLOG_CANT_ENUM_SUBKEYS                     (ROUTER_LOG_BASE+102)
/*
 * Cannot enumerate keys of Registry key %1.
 */

#define ROUTERLOG_LOAD_DLL_ERROR                        (ROUTER_LOG_BASE+103)
/*
 * Unable to load %1.
 */

#define ROUTERLOG_NOT_ENOUGH_MEMORY                     (ROUTER_LOG_BASE+104)
/*
 * Memory allocation failure.
 */

#define ROUTERLOG_COULDNT_LOAD_IF                       (ROUTER_LOG_BASE+105)
/*
 * Unable to load the interface %1 from the registry. The following error
 * occurred: %2
 */

#define ROUTERLOG_COULDNT_ADD_INTERFACE                 (ROUTER_LOG_BASE+106)
/*
 * Unable to add the interface %1 with the Router Manager for protocol 0x%2. The
 * following error occurred: %3
 */

#define ROUTERLOG_COULDNT_REMOVE_INTERFACE              (ROUTER_LOG_BASE+107)
/*
 * Unable to remove the interface %1 with the Router Manager for protocol 0x%2.
 * The following error occurred: %3
 */

#define ROUTERLOG_UNABLE_TO_OPEN_PORT                   (ROUTER_LOG_BASE+108)
/*
 * Unable to open the port %1 for use. %2
 */

#define ROUTERLOG_UNRECOGNIZABLE_FRAME_RECVD            (ROUTER_LOG_BASE+109)
/*
 * Cannot recognize initial frame received on port %1.
 * The line has been disconnected.
 */

#define ROUTERLOG_CANT_START_PPP                        (ROUTER_LOG_BASE+110)
/*
 * An error occurred in the Point to Point Protocol module on port %1 while
 * trying to initiate a connection. %2
 */

#define ROUTERLOG_CONNECTION_ATTEMPT_FAILED             (ROUTER_LOG_BASE+111)
/*
 * A Demand Dial connection to the remote interface %1 on port %2 was
 * successfully initiated but failed to complete successfully because of the 
 * following error: %3
 */

#define ROUTERLOG_CANT_OPEN_ADMINMODULE_KEY             (ROUTER_LOG_BASE+112)
/*
 * Cannot open the RAS third party administration host DLL Registry key.
 * The following error occurred: %1
 */

#define ROUTERLOG_CANT_LOAD_ADMINDLL                    (ROUTER_LOG_BASE+113)
/*
 * Cannot load the RAS third pary administration DLL component.
 * The following error occurred: %1
 */

#define ROUTERLOG_NO_PROTOCOLS_CONFIGURED               (ROUTER_LOG_BASE+114)
/*
 * The Service was unable to start. No protocols were configured for use.
 */

#define ROUTERLOG_IPX_NO_VIRTUAL_NET_NUMBER             (ROUTER_LOG_BASE+115)
/*
 * IPX Routing requires internal network number for correct operation.
 * Please set it in IPX transport properties of protocols section in the
 * Network Control Panel.
 */

#define ROUTERLOG_IPX_CANT_LOAD_PROTOCOL                (ROUTER_LOG_BASE+116)
/*
 * Cannot load routing protocol DLL %1. The error code is in data.
 */

#define ROUTERLOG_IPX_CANT_REGISTER_PROTOCOL            (ROUTER_LOG_BASE+117)
/*
 * Cannot register routing protocol 0x%1. The error code is in data.
 */

#define ROUTERLOG_IPX_CANT_START_PROTOCOL               (ROUTER_LOG_BASE+118)
/*
 * Cannot start routing protocol 0x%1. The error code is in data.
 */

#define ROUTERLOG_IPX_CANT_LOAD_IPXCP                   (ROUTER_LOG_BASE+119)
/*
 * Cannot load IPXCP protocol DLL.  The error code is in data.
 */

#define ROUTERLOG_IPXSAP_SAP_SOCKET_IN_USE              (ROUTER_LOG_BASE+120)
/*
 * Could not open IPX SAP socket for exclusive access.
 * The error code is in data.
 */

#define ROUTERLOG_IPXSAP_SERVER_ADDRESS_CHANGE          (ROUTER_LOG_BASE+121)
/*
 * Server %1 has changed its IPX address.  Old and new addresses are in data.
 */

#define ROUTERLOG_IPXSAP_SERVER_DUPLICATE_ADDRESSES     (ROUTER_LOG_BASE+122)
/*
 * Server %1 is advertised with different IPX address.  Old and new addresses are in data.
 */

#define ROUTERLOG_IPXRIP_RIP_SOCKET_IN_USE              (ROUTER_LOG_BASE+123)
/*
 * Could not open IPX RIP socket for exclusive access.
 * The error code is in data.
 */

#define ROUTERLOG_IPXRIP_LOCAL_NET_NUMBER_CONFLICT      (ROUTER_LOG_BASE+124)
/*
 * Another IPX router claims different network number for interface %1.
 * Offending router IPX address is in data.
 */

#define ROUTERLOG_PERSISTENT_CONNECTION_FAILURE         (ROUTER_LOG_BASE+125)
/*
 * A Demand Dial persistent connection to the remote interface %1 failed to be
 * initated succesfully. The following error occurred: %2
 */

#define ROUTERLOG_IP_DEMAND_DIAL_PACKET                 (ROUTER_LOG_BASE+126)
/*
 * A packet from %1 destined to %2 over protocol 0x%3 caused interface %4
 * to be brought up. The first %5 bytes of the packet are in the data.
 */

#define ROUTERLOG_DID_NOT_LOAD_DDMIF                    (ROUTER_LOG_BASE+127)
/*
 * The Demand Dial interface %1 was not loaded. The router was not started in
 * in Demand Dial mode.
 */

#define ROUTERLOG_CANT_LOAD_ARAP                        (ROUTER_LOG_BASE+128)
/*
 * Cannot load the Appletalk Remote Access DLL component because of the following error: %1
 */

#define ROUTERLOG_CANT_START_ARAP                       (ROUTER_LOG_BASE+129)
/*
 * An error occurred in the Appletalk Remote Access Protocol module on port %1
 * while trying to initiate a connection. %2
 */

#define ROUTERLOG_ARAP_FAILURE                          (ROUTER_LOG_BASE+130)
/*
 * The following error occurred in the Appletalk Remote Access Protocol module on
 * port %1. %2
 */

#define ROUTERLOG_ARAP_NOT_ALLOWED                      (ROUTER_LOG_BASE+131)
/*
 * A user was unable to connect on port %1.
 * The Appletalk Remote Access protocol has been disabled for the Remote
 * Access Server.
 */

#define ROUTERLOG_CANNOT_INIT_RASRPC                    (ROUTER_LOG_BASE+132)
/*
 * Remote Access Connection Manager failed to start because the RAS RPC
 * module failed to initialize. %1
 */

#define ROUTERLOG_IPX_CANT_LOAD_FORWARDER               (ROUTER_LOG_BASE+133)
/*
 * IPX Routing failed to start because IPX forwarder driver could
 * not be loaded.
 */

#define ROUTERLOG_IPX_BAD_GLOBAL_CONFIG                 (ROUTER_LOG_BASE+134)
/*
 * IPX global configuration information is corrupted.
 */

#define ROUTERLOG_IPX_BAD_CLIENT_INTERFACE_CONFIG       (ROUTER_LOG_BASE+135)
/*
 * IPX dial-in client configuration information is corrupted.
 */

#define ROUTERLOG_IPX_BAD_INTERFACE_CONFIG              (ROUTER_LOG_BASE+136)
/*
 * IPX configuration information for interface %1 is corrupted.
 */

#define ROUTERLOG_IPX_DEMAND_DIAL_PACKET                (ROUTER_LOG_BASE+137)
/*
 * An IPX packet caused interface %1 to be brought up.
 * The the first %2 bytes of the packet are in data.
 */

#define ROUTERLOG_CONNECTION_FAILURE                    (ROUTER_LOG_BASE+138)
/*
 * A Demand Dial connection to the remote interface %1 failed to be
 * initated succesfully. The following error occurred: %2
 */

#define ROUTERLOG_CLIENT_AUTODISCONNECT                 (ROUTER_LOG_BASE+139)
/*
 * The port %1 has been disconnected due to inactivity.
 */

#define ROUTERLOG_PPP_SESSION_TIMEOUT                   (ROUTER_LOG_BASE+140)
/*
 * The port %1 has been disconnected because the user reached the maximum connect time allowed by the administrator.
 */

#define ROUTERLOG_AUTH_SUCCESS_ENCRYPTION               (ROUTER_LOG_BASE+141)
/*
 * The user %1 has connected and has been successfully authenticated on
 * port %2. Data sent and received over this link is encrypted.
 */

#define ROUTERLOG_AUTH_SUCCESS_STRONG_ENCRYPTION        (ROUTER_LOG_BASE+142)
/*
 * The user %1 has connected and has been successfully authenticated on
 * port %2. Data sent and received over this link is strongly encrypted.
 */

#define ROUTERLOG_NO_DEVICES_FOR_IF                     (ROUTER_LOG_BASE+143)
/*
 * Unable to load the interface %1 from the registry. There are no routing enabled ports available for use by this demand dial interface. Use the Routing and RemoteAccess Administration tool to configure this interface to use a device that is routing enabled. Stop and restart the router for this demand dial interface to be loaded from the registry.
 */

#define ROUTERLOG_LIMITED_WKSTA_SUPPORT                 (ROUTER_LOG_BASE+144)
/*
 * The Demand-Dial interface %1 was not registered with the Router.
 * Demand-Dial interfaces are not supported on a Windows NT Workstation.
 */

#define ROUTERLOG_CANT_INITIALIZE_IP_SERVER             (ROUTER_LOG_BASE+145)
/*
 * Cannot initialize the Remote Access and Router service to accept calls using 
 * the TCP/IP transport protocol. The following error occurred: %1
 */

#define ROUTERLOG_RADIUS_SERVER_NO_RESPONSE             (ROUTER_LOG_BASE+146)
/*
 * The RADIUS server %1 did not respond to the initial request. 
 * Please make sure that the server name or IP address and secret are correct.
 */

#define ROUTERLOG_PPP_INIT_FAILED                       (ROUTER_LOG_BASE+147)
/*
 * The Remote Access service failed to start because the Point to Point was
 * not initialized successfully. %1
 */

#define ROUTERLOG_RADIUS_SERVER_NAME                    (ROUTER_LOG_BASE+148)
/*
 * The RADIUS server name %1 could not be successfully resolved to an IP address. Please make sure that the name is spelled correctly and that the RADIUS server is running correctly.
 */

#define ROUTERLOG_IP_NO_GLOBAL_INFO                     (ROUTER_LOG_BASE+149)
/*
 * No global configuration was supplied to the IP Router Manager. Please rerun
 * setup.
 */

#define ROUTERLOG_IP_CANT_ADD_DD_FILTERS                (ROUTER_LOG_BASE+150)
/*
 * Unable to add demand dial filters for interface %1
 */

#define ROUTERLOG_PPPCP_INIT_ERROR				        (ROUTER_LOG_BASE+151)
/*
 * The Control Protocol %1 in the Point to Point Protocol module %2 returned an
 * error while initializing. %3
 */

#define ROUTERLOG_AUTHPROVIDER_FAILED_INIT              (ROUTER_LOG_BASE+152)
/*
 * The currently configured authentication provider failed to load and initialize successfully. %1
 */

#define ROUTERLOG_ACCTPROVIDER_FAILED_INIT              (ROUTER_LOG_BASE+153)
/*
 * The currently configured accounting provider failied to load and initialize successfully. %1
 */

#define ROUTERLOG_IPX_AUTO_NETNUM_FAILURE               (ROUTER_LOG_BASE+154)
/*
 * The IPX Internal Network Number is invalid and the IPX Router Manager was unsuccessful in its
 * attempt to automatically assign a valid one.  Reconfigure the IPX Internal Network Number through 
 * the connections folder and restart the Routing and Remote Access service.
 */

#define ROUTERLOG_IPX_WRN_STACK_STARTED                 (ROUTER_LOG_BASE+155)
/*
 * In order for the IPX Router Manager (which runs as part of the Routing and Remote Access Service)
 * to run, it had to start the IPX Protocol Stack Driver.  This driver was either manually stopped
 * or marked as demand start.  The Routing and Remote Access Service was probably started by the creation of
 * Incoming Connections or through the Routing and Remote Access snapin.
 */

#define ROUTERLOG_IPX_STACK_DISABLED                    (ROUTER_LOG_BASE+156)
/*
 * The IPX Router Manager was unable to start because the IPX Protocol Stack Driver could
 * not be started.
 */

#define ROUTERLOG_IP_MCAST_NOT_ENABLED                  (ROUTER_LOG_BASE+157)
/*
 * The interface %1 could not be enabled for multicast. %2 will not be
 * activated over this interface.
 */

#define ROUTERLOG_CONNECTION_ESTABLISHED                (ROUTER_LOG_BASE+158)
/*
 * The user %1 successfully established a connection to %2 using the device %3.
 */

#define ROUTERLOG_DISCONNECTION_OCCURRED                (ROUTER_LOG_BASE+159)
/*
 * The connection to %1 made by user %2 using device %3 was disconnected. 
 */

#define ROUTERLOG_CLIENT_IP_NOT_IN_SUBNET               (ROUTER_LOG_BASE+160)
/*
 * The user %1 has connected on port %2 using IP address %3 that does not 
 * belong to the Remote Access Server's subnet: %4, mask %5.
 */

#define ROUTERLOG_BAP_CLIENT_CONNECTED                  (ROUTER_LOG_BASE+161)
/*
 * The user %1 successfully established a connection to %2 using the device %3.
 * This connection happened automatically because the bandwidth utilization was 
 * high.
 */

#define ROUTERLOG_BAP_SERVER_CONNECTED                  (ROUTER_LOG_BASE+162)
/*
 * The Remote Access Server successfully established a connection to %1.
 * This connection happened automatically because the bandwidth utilization
 * was high.
 */

#define ROUTERLOG_BAP_DISCONNECTED                      (ROUTER_LOG_BASE+163)
/*
 * The connection to %1 made by user %2 using device %3 was disconnected. This
 * disconnection happened automatically because the bandwidth utilization was
 * low.
 */

#define ROUTERLOG_BAP_WILL_DISCONNECT                   (ROUTER_LOG_BASE+164)
/*
 * The Remote Access Server wants to disconnect a link in the connection to %1
 * made by user %2 because the bandwidth utilization is too low.
 */

#define ROUTERLOG_LOCAL_UNNUMBERED_IPCP                 (ROUTER_LOG_BASE+165)
/*
 * A connection has been established on port %1 using interface %2, but no IP
 * address was obtained.
 */

#define ROUTERLOG_REMOTE_UNNUMBERED_IPCP                (ROUTER_LOG_BASE+166)
/*
 * A connection has been established on port %1 using interface %2, but the 
 * remote side got no IP address.
 */

#define ROUTERLOG_NO_IP_ADDRESS                         (ROUTER_LOG_BASE+167)
/*
 * No IP address is available to hand out to the client. 
 */

#define ROUTERLOG_CANT_GET_SERVER_CRED                  (ROUTER_LOG_BASE+168)
/*
 * Cannot get a handle to the Remote Access Server's credentials because of
 * the following error: %1
 */

#define ROUTER_LOG_BASEEND                              (ROUTER_LOG_BASE+999)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\rasndis.h ===
#include <ntddndis.h>

//
// definition of the basic spin lock structure
//

typedef struct _NDIS_SPIN_LOCK {
    KSPIN_LOCK SpinLock;
    KIRQL OldIrql;
} NDIS_SPIN_LOCK, * PNDIS_SPIN_LOCK;

typedef PVOID NDIS_HANDLE, *PNDIS_HANDLE;

typedef int NDIS_STATUS, *PNDIS_STATUS; // note default size

//
// Physical address.
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS; // windbgkd

typedef PHYSICAL_ADDRESS NDIS_PHYSICAL_ADDRESS, *PNDIS_PHYSICAL_ADDRESS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\rasfile.h ===
/***************************************************************************** 
**		Microsoft Rasfile Library
** 		Copyright (C) Microsoft Corp., 1992
** 
** File Name : rasfile.h 
**
** Revision History :
**	July 10, 1992	David Kays	Created
**      Dec  12, 1992   Ram Cherala     Added RFM_KEEPDISKFILEOPEN
**
** Description : 
**	Rasfile file export include file.
******************************************************************************/

#ifndef _RASFILE_
#define _RASFILE_

/* 
 * RASFILE load modes 
 */
#define RFM_SYSFORMAT		0x01 	/* DOS config.sys style file */
#define RFM_CREATE		0x02 	/* create file if it does't exist */
#define RFM_READONLY		0x04 	/* open file for read only */
#define RFM_LOADCOMMENTS	0x08 	/* load comment lines into memory */
#define RFM_ENUMSECTIONS	0x10 	/* only section headers loaded */
#define RFM_KEEPDISKFILEOPEN    0x20    /* if not set close the disk file */

/* 
 * RASFILE line type bit-masks.
 * The ANY types are shorthand for multiple line types.
 */
#define RFL_SECTION		0x01
#define RFL_GROUP		0x02
#define RFL_ANYHEADER		(RFL_SECTION | RFL_GROUP)
#define RFL_BLANK		0x04
#define RFL_COMMENT		0x08
#define RFL_ANYINACTIVE		(RFL_BLANK | RFL_COMMENT)
#define RFL_KEYVALUE		0x10
#define RFL_COMMAND		0x20
#define RFL_ANYACTIVE		(RFL_KEYVALUE | RFL_COMMAND)
#define RFL_ANY			0x3F

/* 
 * RASFILE search scope. 
 */
typedef enum {
	RFS_FILE,
	RFS_SECTION,
	RFS_GROUP
} RFSCOPE;

typedef int             HRASFILE;
typedef BOOL            (*PFBISGROUP)();

#define INVALID_HRASFILE     -1
#define RAS_MAXLINEBUFLEN    300
#define RAS_MAXSECTIONNAME   RAS_MAXLINEBUFLEN

#ifndef APIENTRY
#define APIENTRY		
#endif


/*
 * RasfileLoad parameters as returned by RasfileLoadInfo.
 */
typedef struct
RASFILELOADINFO
{
    TCHAR      szPath[ MAX_PATH ];
    DWORD      dwMode;
    TCHAR      szSection[ RAS_MAXSECTIONNAME + 1 ];
    PFBISGROUP pfbIsGroup;
}
RASFILELOADINFO;


/* 
 * RASFILE APIs 
 */

/* file management routines */
extern HRASFILE	APIENTRY  RasfileLoad( LPTSTR, DWORD, LPTSTR, PFBISGROUP);
extern BOOL APIENTRY	RasfileWrite( HRASFILE, LPTSTR );
extern BOOL APIENTRY	RasfileClose( HRASFILE );
extern VOID APIENTRY    RasfileLoadInfo( HRASFILE, RASFILELOADINFO* );
/* file navigation routines */
extern BOOL APIENTRY	RasfileFindFirstLine( HRASFILE, BYTE, RFSCOPE );
extern BOOL APIENTRY	RasfileFindLastLine( HRASFILE, BYTE, RFSCOPE );
extern BOOL APIENTRY	RasfileFindPrevLine( HRASFILE, BYTE, RFSCOPE );
extern BOOL APIENTRY	RasfileFindNextLine( HRASFILE, BYTE, RFSCOPE );
extern BOOL APIENTRY	RasfileFindNextKeyLine( HRASFILE, LPTSTR, RFSCOPE );
extern BOOL APIENTRY	RasfileFindMarkedLine( HRASFILE, BYTE );
extern BOOL APIENTRY	RasfileFindSectionLine( HRASFILE, LPTSTR, BOOL );
/* file editing routines */
extern const LPTSTR APIENTRY	RasfileGetLine( HRASFILE );
extern BOOL APIENTRY	RasfileGetLineText( HRASFILE, LPTSTR );
extern BOOL APIENTRY	RasfilePutLineText( HRASFILE, LPTSTR );
extern BYTE APIENTRY	RasfileGetLineMark( HRASFILE );
extern BOOL APIENTRY	RasfilePutLineMark( HRASFILE, BYTE );
extern BYTE APIENTRY	RasfileGetLineType( HRASFILE );
extern BOOL APIENTRY	RasfileInsertLine( HRASFILE, LPTSTR, BOOL );
extern BOOL APIENTRY	RasfileDeleteLine( HRASFILE );
extern BOOL APIENTRY	RasfileGetSectionName( HRASFILE, LPTSTR );
extern BOOL APIENTRY	RasfilePutSectionName( HRASFILE, LPTSTR );
extern BOOL APIENTRY	RasfileGetKeyValueFields( HRASFILE, LPTSTR, LPTSTR );
extern BOOL APIENTRY	RasfilePutKeyValueFields( HRASFILE, LPTSTR, LPTSTR );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\rasapip.h ===
/*++

Copyright (C) 1994-98 Microsft Corporation. All rights reserved.

Module Name:

    rasapip.h

Abstract:

    This file has definitions for private apis for ras connections.
    These apis are exported from rasapi32.dll

Author:

    Rao Salapaka (raos) 30-Jan-1998

Revision History:

--*/

#ifndef _RASAPIP_
#define _RASAPIP_

#include <windef.h> //for MAX_PATH

#ifdef __cplusplus
extern "C" {
#endif


#define RASAPIP_MAX_DEVICE_NAME     128
#define RASAPIP_MAX_ENTRY_NAME      256

#define RAS_DEVICE_TYPE(_x)     ((_x) & 0x0000FFFF)

#define RAS_DEVICE_CLASS(_x)    ((_x) & 0xFFFF0000)

enum _RASDEVICETYPE
{
    RDT_Modem = 0,

    RDT_X25,

    RDT_Isdn,

    RDT_Serial,

    RDT_FrameRelay,

    RDT_Atm,

    RDT_Sonet,

    RDT_Sw56,

    RDT_Tunnel_Pptp,

    RDT_Tunnel_L2tp,

    RDT_Irda,

    RDT_Parallel,

    RDT_Other,

    //
    // The following flags when set
    // specify the class of the device
    //
    RDT_Tunnel = 0x00010000,

    RDT_Direct  = 0x00020000,

    RDT_Null_Modem = 0x000040000
};


typedef enum _RASDEVICETYPE RASDEVICETYPE;

typedef struct _RASENUMENTRYDETAILS
{
    DWORD   dwSize;
    DWORD   dwFlags;                    // same as RASENTRYNAME.dwFlags
    DWORD   dwType;                     // same as RASENTRY.dwType
    GUID    guidId;                     // same as RASENTRY.guidId
    BOOL    fShowMonitorIconInTaskBar;  // same as RASENTRY.fShowMonitorIconInTaskBar
    RASDEVICETYPE rdt;
    WCHAR   szDeviceName[RASAPIP_MAX_DEVICE_NAME];
    WCHAR   szEntryName[RASAPIP_MAX_ENTRY_NAME + 1];
    WCHAR   szPhonebookPath[MAX_PATH + 1];

} RASENUMENTRYDETAILS, *LPRASENUMENTRYDETAILS;

DWORD
APIENTRY
DwEnumEntryDetails (
    IN     LPCWSTR               lpszPhonebookPath,
    OUT    LPRASENUMENTRYDETAILS lprasentryname,
    IN OUT LPDWORD               lpcb,
    OUT    LPDWORD               lpcEntries
    );

DWORD
DwCloneEntry(
    IN      LPCWSTR lpwszPhonebookPath,
    IN      LPCWSTR lpwszSrcEntryName,
    IN      LPCWSTR lpwszDstEntryName
    );


// Implemented in rasman.dll
//
DWORD
APIENTRY
RasReferenceRasman (
    IN BOOL fAttach
    );


// Implemented in netcfgx.dll
//
HRESULT
WINAPI
RasAddBindings (
    IN OUT UINT*    pcIpOut,
    IN OUT UINT*    pcNbfIn,
    IN OUT UINT*    pcNbfOut);

HRESULT
WINAPI
RasCountBindings (
    OUT UINT*   pcIpOut,
    OUT UINT*   pcNbfIn,
    OUT UINT*   pcNbfOut);

HRESULT
WINAPI
RasRemoveBindings (
    IN OUT UINT*        pcIpOutBindings,
    IN     const GUID*  pguidIpOutBindings,
    IN OUT UINT*        pcNbfIn,
    IN OUT UINT*        pcNbfOut);

typedef struct _RASCONFIGENDPOINTS
{
    DWORD   dwSize;
    DWORD   dwFlags;
    INT     cTotalEndpoints;
    INT     cLimitSimultaneousIncomingCalls;
    INT     cLimitSimultaneousOutgoingCalls;
} RASCONFIGENDPOINTS;

HRESULT
APIENTRY
RasConfigureEndpoints (
    IN OUT  RASCONFIGENDPOINTS* pInfo
    );


//+---------------------------------------------------------------------------
// RAS Event notifications into netman.
//
typedef enum _RASEVENTTYPE
{
    ENTRY_ADDED,
    ENTRY_DELETED,
    ENTRY_MODIFIED,
    ENTRY_RENAMED,
    ENTRY_CONNECTED,
    ENTRY_CONNECTING,
    ENTRY_DISCONNECTING,
    ENTRY_DISCONNECTED,
    INCOMING_CONNECTED,
    INCOMING_DISCONNECTED,
    SERVICE_EVENT,
} RASEVENTTYPE;

typedef enum _SERVICEEVENTTYPE
{
    RAS_SERVICE_STARTED,
    RAS_SERVICE_STOPPED,
} SERVICEEVENTTYPE;

typedef enum _RASSERVICE
{
    RASMAN,
    RASAUTO,
    REMOTEACCESS,
} RASSERVICE;

typedef struct _RASEVENT
{
    RASEVENTTYPE    Type;

    union
    {
    // ENTRY_ADDED,
    // ENTRY_MODIFIED,
        struct
        {
            RASENUMENTRYDETAILS     Details;
        };

    // ENTRY_DELETED,
    // ENTRY_CONNECTED,
    // ENTRY_CONNECTING,
    // ENTRY_DISCONNECTING,
    // ENTRY_DISCONNECTED,
    // INCOMING_CONNECTED,
    // INCOMING_DISCONNECTED,
    //  guidId is valid

    // ENTRY_RENAMED,
        struct
        {
            GUID    guidId;
            WCHAR   pszwNewName [RASAPIP_MAX_ENTRY_NAME + 1];
        };

    // SERVICE_EVENT,
        struct
        {
            SERVICEEVENTTYPE    Event;
            RASSERVICE          Service;
        };
    };
} RASEVENT;

typedef struct _RASENTRYHEADER
{
    DWORD dwEntryType;
    WCHAR szEntryName[RASAPIP_MAX_ENTRY_NAME + 1];
} RASENTRYHEADER, *PRASENTRYHEADER;

// Implemented in netman.dll
//
typedef VOID (APIENTRY *RASEVENTNOTIFYPROC)(const RASEVENT* pEvent);

VOID
APIENTRY
RasEventNotify (
    const RASEVENT* pEvent);

DWORD
DwEnumEntriesForAllUsers(
            DWORD *lpcb,
            DWORD *lpcEntries,
            RASENTRYHEADER * pRasEntryHeader);


#ifdef __cplusplus
}
#endif


#endif  // _RASAPIP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\rasman.h ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-93
//
//
//  Revision History
//
//
//  5/26/92 Gurdeep Singh Pall  Created
//
//
//  Description: This file contains all structure and constant definitions for
//       RAS Manager Component.
//
//****************************************************************************


#ifndef _RASMAN_
#define _RASMAN_

#include <windows.h>
#include <rassapi.h>

#define WM_RASAPICOMPLETE   0xCCCC  // From the "user" window msg range

#define RASMAN_SERVICE_NAME "RASMAN"

#define MAX_MEDIA_NAME       RASSAPI_MAX_MEDIA_NAME
#define MAX_PORT_NAME        RASSAPI_MAX_PORT_NAME
#define MAX_DEVICE_NAME      RASSAPI_MAX_DEVICE_NAME
#define MAX_DEVICETYPE_NAME  RASSAPI_MAX_DEVICETYPE_NAME
#define MAX_PARAM_KEY_SIZE   RASSAPI_MAX_PARAM_KEY_SIZE
#define MAX_PHONENUMBER_SIZE RASSAPI_MAX_PHONENUMBER_SIZE

#define MAX_USERKEY_SIZE    132
#define MAX_XPORT_NAME      128 // ??
#define MAX_IDENTIFIER_SIZE 32
#define MAX_STAT_NAME       32
#define MAX_CHALLENGE_SIZE  8
#define MAX_RESPONSE_SIZE   24
#define MAX_USERNAME_SIZE   UNLEN
#define MAX_DOMAIN_SIZE     DNLEN
#define MAX_PASSWORD_SIZE   PWLEN
#define MAX_LAN_NETS        16
#define MAX_PROTOCOLS_PER_PORT  4
#define MAX_DLL_NAME_SIZE   8
#define MAX_ENTRYPOINT_NAME_SIZE 32
#define MAX_ARG_STRING_SIZE  32
#define MAX_ENTRYNAME_SIZE   256
#define MAX_CALLBACKNUMBER_SIZE MAX_PHONENUMBER_SIZE
#define MAX_PHONEENTRY_SIZE    (MAX_PHONENUMBER_SIZE < MAX_ENTRYNAME_SIZE ? MAX_ENTRYNAME_SIZE : MAX_PHONENUMBER_SIZE)
#define INVALID_TAPI_ID     0xffffffff

typedef  DWORD  HPORT ;

typedef  DWORD  HBUNDLE ;

typedef  DWORD  HCONN;

enum RASMAN_STATUS {

    OPEN    = 0,

    CLOSED  = 1,

    UNKNOWN = 2
}   ;

typedef enum RASMAN_STATUS  RASMAN_STATUS ;


enum RASMAN_USAGE {

    CALL_IN     = 0,

    CALL_OUT    = 1,

    CALL_IN_OUT = 2,

    CALL_NONE   = 3

} ;

typedef enum RASMAN_USAGE   RASMAN_USAGE ;


enum RAS_FORMAT {

    Number      = 0,

    String      = 1

} ;

typedef enum RAS_FORMAT RAS_FORMAT ;


union RAS_VALUE {

    DWORD   Number ;

    struct  {
        DWORD   Length ;
        PCHAR   Data ;
        } String ;
} ;

typedef union RAS_VALUE RAS_VALUE ;



enum RASMAN_STATE {

    CONNECTING  = 0,

    LISTENING   = 1,

    CONNECTED   = 2,

    DISCONNECTING   = 3,

    DISCONNECTED    = 4,

    LISTENCOMPLETED = 5,

} ;

typedef enum RASMAN_STATE   RASMAN_STATE ;


enum RASMAN_DISCONNECT_REASON {

    USER_REQUESTED  = 0,

    REMOTE_DISCONNECTION= 1,

    HARDWARE_FAILURE    = 2,

    NOT_DISCONNECTED    = 3
} ;

typedef enum RASMAN_DISCONNECT_REASON   RASMAN_DISCONNECT_REASON ;


struct RAS_PARAMS {

    CHAR    P_Key   [MAX_PARAM_KEY_SIZE] ;

    RAS_FORMAT  P_Type ;

    BYTE    P_Attributes ;

    RAS_VALUE   P_Value ;

} ;

typedef struct RAS_PARAMS   RAS_PARAMS ;


struct RASMAN_PORT {

    HPORT       P_Handle ;

    CHAR        P_PortName  [MAX_PORT_NAME] ;

    RASMAN_STATUS   P_Status ;

    RASMAN_USAGE    P_ConfiguredUsage ;

    RASMAN_USAGE    P_CurrentUsage ;

    CHAR        P_MediaName [MAX_MEDIA_NAME] ;

    CHAR        P_DeviceType[MAX_DEVICETYPE_NAME] ;

    CHAR        P_DeviceName[MAX_DEVICE_NAME+1] ;

    DWORD       P_LineDeviceId ;    // only valid for TAPI devices

    DWORD       P_AddressId ;       // only valid for TAPI devices

} ;

typedef struct RASMAN_PORT  RASMAN_PORT ;


struct RASMAN_PORTINFO {

    WORD    PI_NumOfParams ;

    RAS_PARAMS  PI_Params[1] ;

} ;

typedef struct RASMAN_PORTINFO RASMAN_PORTINFO ;


struct RASMAN_DEVICE {

    CHAR    D_Name  [MAX_DEVICE_NAME+1] ;

} ;

typedef struct RASMAN_DEVICE    RASMAN_DEVICE ;


struct RASMAN_DEVICEINFO {

    WORD    DI_NumOfParams ;

    RAS_PARAMS  DI_Params[1] ;

} ;

typedef struct RASMAN_DEVICEINFO   RASMAN_DEVICEINFO ;



enum RAS_PROTOCOLTYPE {

    ASYBEUI     = 0x80D5,

    IPX     = 0x8137,

    IP      = 0x0800,

    ARP     = 0x0806,

    APPLETALK   = 0x80F3,

    XNS     = 0x0600,

    RASAUTH     = 0x8FFF,

    INVALID_TYPE= 0x2222
} ;

typedef enum RAS_PROTOCOLTYPE RAS_PROTOCOLTYPE ;




struct RASMAN_PROTOCOLINFO {

    CHAR        PI_XportName    [MAX_XPORT_NAME] ;

    RAS_PROTOCOLTYPE    PI_Type ;

} ;

typedef struct RASMAN_PROTOCOLINFO RASMAN_PROTOCOLINFO ;

struct  RASMAN_ROUTEINFO {

    RAS_PROTOCOLTYPE RI_Type ;

    BYTE    RI_LanaNum ;

    WCHAR   RI_XportName    [MAX_XPORT_NAME] ;

    WCHAR   RI_AdapterName  [MAX_XPORT_NAME] ;

} ;

typedef struct RASMAN_ROUTEINFO    RASMAN_ROUTEINFO ;


struct RAS_PROTOCOLS {

    RASMAN_ROUTEINFO   RP_ProtocolInfo[MAX_PROTOCOLS_PER_PORT] ;
} ;

typedef struct RAS_PROTOCOLS RAS_PROTOCOLS ;


struct  RASMAN_INFO {

    RASMAN_STATUS       RI_PortStatus ;

    RASMAN_STATE        RI_ConnState ;

    DWORD           RI_LinkSpeed ;

    DWORD           RI_LastError ;

    RASMAN_USAGE        RI_CurrentUsage ;

    CHAR            RI_DeviceTypeConnecting [MAX_DEVICETYPE_NAME] ;

    CHAR            RI_DeviceConnecting [MAX_DEVICE_NAME+1] ;

    RASMAN_DISCONNECT_REASON    RI_DisconnectReason ;

    DWORD           RI_OwnershipFlag ;

    DWORD           RI_ConnectDuration ;

    DWORD           RI_BytesReceived ;

    //
    // If this port belongs to a connection, then
    // the following fields are filled in.
    //
    CHAR            RI_Phonebook[MAX_PATH+1];

    CHAR            RI_PhoneEntry[MAX_PHONEENTRY_SIZE+1];

    HCONN           RI_ConnectionHandle;

    DWORD           RI_SubEntry;

} ;

typedef struct RASMAN_INFO    RASMAN_INFO ;


struct  RAS_STATISTICS {

    WORD    S_NumOfStatistics ;

    ULONG   S_Statistics[1] ;

} ;

typedef struct RAS_STATISTICS   RAS_STATISTICS ;

#define MAX_STATISTICS      14
#define MAX_STATISTICS_EX   (MAX_STATISTICS * 2)

#define BYTES_XMITED        0   // Generic Stats
#define BYTES_RCVED             1
#define FRAMES_XMITED           2
#define FRAMES_RCVED            3

#define CRC_ERR         4   // Hardware Stats
#define TIMEOUT_ERR             5
#define ALIGNMENT_ERR           6
#define HARDWARE_OVERRUN_ERR    7
#define FRAMING_ERR             8
#define BUFFER_OVERRUN_ERR      9

#define BYTES_XMITED_UNCOMPRESSED 10    // Compression Stats
#define BYTES_RCVED_UNCOMPRESSED  11
#define BYTES_XMITED_COMPRESSED   12
#define BYTES_RCVED_COMPRESSED    13

#define MSTYPE_COMPRESSION      0x00000001
#define MSTYPE_ENCRYPTION_40    0x00000010
#define MSTYPE_ENCRYPTION_40F   0x00000020
#define MSTYPE_ENCRYPTION_128   0x00000040

#define MACTYPE_NT31RAS         254

#define MAX_SESSIONKEY_SIZE 8
#define MAX_COMPVALUE_SIZE  32
#define MAX_COMPOUI_SIZE    3

struct RAS_COMPRESSION_INFO {

    UCHAR   RCI_SessionKey[MAX_SESSIONKEY_SIZE]; // May be used for encryption, non-zero if supported.

    ULONG   RCI_MSCompressionType;  // bit 0 = MPPPC, bit 5 = encryption.

    UCHAR   RCI_MacCompressionType; // 0=OUI, 1-253 = Public, 254 = NT31 RAS, 255=Not supported

    WORD    RCI_MacCompressionValueLength ;

    union {
    struct {        // Proprietary: used for comp type 0

        UCHAR RCI_CompOUI[MAX_COMPOUI_SIZE];

        UCHAR RCI_CompSubType;

        UCHAR RCI_CompValues[MAX_COMPVALUE_SIZE];

    } RCI_Proprietary;

    struct {        // Public: used for comp type 1-254

        UCHAR RCI_CompValues[MAX_COMPVALUE_SIZE];

    } RCI_Public;

    } RCI_Info ;

};

typedef struct RAS_COMPRESSION_INFO RAS_COMPRESSION_INFO;


struct PROTOCOL_CONFIG_INFO {

    DWORD  P_Length ;

    BYTE   P_Info[1] ;
} ;

typedef struct PROTOCOL_CONFIG_INFO PROTOCOL_CONFIG_INFO ;


struct RASMAN_PPPFEATURES {

    DWORD MRU;
    DWORD ACCM;
    DWORD AuthProtocol;
    DWORD MagicNumber;
    BOOL  PFC;
    BOOL  ACFC;

} ;

typedef struct RASMAN_PPPFEATURES RASMAN_PPPFEATURES ;


enum RAS_FRAMING {PPP, RAS, AUTODETECT, SLIP, SLIPCOMP, SLIPCOMPAUTO} ;

typedef enum RAS_FRAMING RAS_FRAMING ;

struct RAS_FRAMING_CAPABILITIES {
    DWORD   RFC_MaxFrameSize;
    DWORD   RFC_MaxReconstructedFrameSize;
    DWORD   RFC_FramingBits;
    DWORD   RFC_DesiredACCM;
} ;

typedef struct RAS_FRAMING_CAPABILITIES RAS_FRAMING_CAPABILITIES ;


struct RAS_FRAMING_INFO {

    DWORD RFI_MaxSendFrameSize;
    DWORD RFI_MaxRecvFrameSize;
    DWORD RFI_MaxRSendFrameSize;
    DWORD RFI_MaxRRecvFrameSize;
    DWORD RFI_HeaderPadding;
    DWORD RFI_TailPadding;
    DWORD RFI_SendFramingBits;
    DWORD RFI_RecvFramingBits;
    DWORD RFI_SendCompressionBits;
    DWORD RFI_RecvCompressionBits;
    DWORD RFI_SendACCM;
    DWORD RFI_RecvACCM;

} ;

typedef struct RAS_FRAMING_INFO RAS_FRAMING_INFO ;


// NDIS WAN Framing bits: used with RasPortGetFramingEx and RasPortSetFramingEx
//            APIs.
//

#define OLD_RAS_FRAMING                     0x00000001
#define RAS_COMPRESSION                     0x00000002

#define PPP_MULTILINK_FRAMING               0x00000010
#define PPP_SHORT_SEQUENCE_HDR_FORMAT       0x00000020
#define PPP_FRAMING                         0x00000100
#define PPP_COMPRESS_ADDRESS_CONTROL        0x00000200
#define PPP_COMPRESS_PROTOCOL_FIELD         0x00000400
#define PPP_ACCM_SUPPORTED                  0x00000800

#define SLIP_FRAMING                        0x00001000
#define SLIP_VJ_COMPRESSION                 0x00002000
#define SLIP_VJ_AUTODETECT                  0x00004000

#define MEDIA_NRZ_ENCODING                  0x00010000
#define MEDIA_NRZI_ENCODING                 0x00020000
#define MEDIA_NLPID                         0x00040000

#define RFC_1356_FRAMING                    0x00100000
#define RFC_1483_FRAMING                    0x00200000
#define RFC_1490_FRAMING                    0x00400000

#define SHIVA_FRAMING               0x01000000



// Defines for RAS_PROTOCOLCOMPRESSION
//
#define VJ_IP_COMPRESSION        0x002d
#define NO_PROTOCOL_COMPRESSION      0x0000

struct RAS_PROTOCOLCOMPRESSION {

    union {

    struct {

        WORD    RP_IPCompressionProtocol;

        BYTE    RP_MaxSlotID;       // How many slots to allocate

        BYTE    RP_CompSlotID;      // 1 = Slot ID was negotiated

    } RP_IP ;

    struct {

        WORD    RP_IPXCompressionProtocol;

    } RP_IPX ;

    } RP_ProtocolType ;

} ;

typedef struct RAS_PROTOCOLCOMPRESSION RAS_PROTOCOLCOMPRESSION ;


//
// Definitions for Ras{Get,Set}DialParams
//
// The dwMask values control/specify which fields
// of the RAS_DIALPARAMS are stored/retrieved.
//
// NOTE: these values have to match the RASCF_*
// values in ras.h.
//
#define DLPARAMS_MASK_USERNAME       0x00000001
#define DLPARAMS_MASK_PASSWORD       0x00000002
#define DLPARAMS_MASK_DOMAIN         0x00000004
#define DLPARAMS_MASK_PHONENUMBER    0x00000008
#define DLPARAMS_MASK_CALLBACKNUMBER 0x00000010
#define DLPARAMS_MASK_SUBENTRY       0x00000020
#define DLPARAMS_MASK_OLDSTYLE       0x80000000

typedef struct _RAS_DIALPARAMS {
    DWORD DP_Uid;
    WCHAR DP_PhoneNumber[MAX_PHONENUMBER_SIZE + 1];
    WCHAR DP_CallbackNumber[MAX_CALLBACKNUMBER_SIZE + 1];
    WCHAR DP_UserName[MAX_USERNAME_SIZE + 1];
    WCHAR DP_Password[MAX_PASSWORD_SIZE + 1];
    WCHAR DP_Domain[MAX_DOMAIN_SIZE + 1];
    DWORD DP_SubEntry;
} RAS_DIALPARAMS, *PRAS_DIALPARAMS;

//
// Definitions for Ras{Get,Set}ConnectionParams
//
typedef struct _RAS_CONNECTIONPARAMS {
    //
    // Phonebook and entry name.
    //
    CHAR CP_Phonebook[MAX_PATH + 1];
    CHAR CP_PhoneEntry[MAX_PHONEENTRY_SIZE + 1];
    //
    // Bandwidth-on-demand parameters
    //
    DWORD CP_DialExtraPercent;
    DWORD CP_DialExtraSampleSeconds;
    DWORD CP_HangUpExtraPercent;
    DWORD CP_HangUpExtraSampleSeconds;
    //
    // Idle disconnect parameters
    //
    DWORD CP_IdleDisconnectSeconds;
    //
    // Redial on link failure flag
    //
    BOOL CP_RedialOnLinkFailure;
} RAS_CONNECTIONPARAMS, *PRAS_CONNECTIONPARAMS;

//
// Flags for RasAddNotification.
//
// Note: the NOTIF_* values must match the
// RASCN_* values in ras.h
//
#define NOTIF_CONNECT           0x00000001
#define NOTIF_DISCONNECT        0x00000002
#define NOTIF_BANDWIDTHADDED    0x00000004
#define NOTIF_BANDWIDTHREMOVED  0x00000008

//* RAS Manager entrypoint Prototypes
//

DWORD APIENTRY RasPortOpen(PCHAR, HPORT*, HANDLE);

DWORD APIENTRY RasPortClose(HPORT);

DWORD APIENTRY RasPortEnum(PBYTE, PWORD, PWORD);

DWORD APIENTRY RasPortGetInfo(HPORT, PBYTE, PWORD);

DWORD APIENTRY RasPortSetInfo(HPORT, RASMAN_PORTINFO*);

DWORD APIENTRY RasPortDisconnect(HPORT, HANDLE);

DWORD APIENTRY RasPortSend(HPORT, PBYTE, WORD);

DWORD APIENTRY RasPortReceive(HPORT, PBYTE, PWORD, DWORD, HANDLE);

DWORD APIENTRY RasPortListen(HPORT, DWORD, HANDLE);

DWORD APIENTRY RasPortConnectComplete(HPORT);

DWORD APIENTRY RasPortGetStatistics(HPORT, PBYTE, PWORD);

DWORD APIENTRY RasPortClearStatistics(HPORT);

DWORD APIENTRY RasDeviceEnum(PCHAR, PBYTE, PWORD, PWORD);

DWORD APIENTRY RasDeviceGetInfo(HPORT, PCHAR, PCHAR, PBYTE, PWORD);

DWORD APIENTRY RasDeviceSetInfo(HPORT, PCHAR, PCHAR, RASMAN_DEVICEINFO*);

DWORD APIENTRY RasDeviceConnect(HPORT, PCHAR, PCHAR, DWORD, HANDLE);

DWORD APIENTRY RasGetInfo(HPORT, RASMAN_INFO*);

DWORD APIENTRY RasGetInfoEx(RASMAN_INFO*, PWORD);

DWORD APIENTRY RasGetBuffer(PBYTE*, PWORD);

DWORD APIENTRY RasFreeBuffer(PBYTE);

DWORD APIENTRY RasProtocolEnum(PBYTE, PWORD, PWORD);

DWORD APIENTRY RasAllocateRoute(HPORT, RAS_PROTOCOLTYPE, BOOL, RASMAN_ROUTEINFO*);

DWORD APIENTRY RasActivateRoute(HPORT, RAS_PROTOCOLTYPE, RASMAN_ROUTEINFO*, PROTOCOL_CONFIG_INFO*);

DWORD APIENTRY RasActivateRouteEx(HPORT, RAS_PROTOCOLTYPE, DWORD, RASMAN_ROUTEINFO*, PROTOCOL_CONFIG_INFO*);

DWORD APIENTRY RasDeAllocateRoute(HPORT, RAS_PROTOCOLTYPE);

DWORD APIENTRY RasCompressionGetInfo(HPORT, RAS_COMPRESSION_INFO* Send, RAS_COMPRESSION_INFO* Recv);

DWORD APIENTRY RasCompressionSetInfo(HPORT, RAS_COMPRESSION_INFO* Send, RAS_COMPRESSION_INFO* Recv);

DWORD APIENTRY RasGetUserCredentials(PBYTE, PLUID, PWCHAR, PBYTE, PBYTE, PBYTE) ;

DWORD APIENTRY RasSetCachedCredentials( PCHAR, PCHAR, PCHAR ) ;

DWORD APIENTRY RasRequestNotification (HPORT, HANDLE) ;

DWORD APIENTRY RasPortCancelReceive (HPORT) ;

DWORD APIENTRY RasPortEnumProtocols (HPORT, RAS_PROTOCOLS*, PWORD) ;

DWORD APIENTRY RasEnumLanNets (DWORD *, UCHAR *) ;

DWORD APIENTRY RasPortSetFraming (HPORT, RAS_FRAMING, RASMAN_PPPFEATURES*, RASMAN_PPPFEATURES*) ;

DWORD APIENTRY RasPortRegisterSlip (HPORT, DWORD, WCHAR *, BOOL, WCHAR*, WCHAR*, WCHAR*, WCHAR*) ;

DWORD APIENTRY RasPortStoreUserData (HPORT, PBYTE, DWORD) ;

DWORD APIENTRY RasPortRetrieveUserData (HPORT, PBYTE, DWORD *) ;

DWORD APIENTRY RasPortGetFramingEx (HPORT, RAS_FRAMING_INFO *) ;

DWORD APIENTRY RasPortSetFramingEx (HPORT, RAS_FRAMING_INFO *) ;

DWORD APIENTRY RasPortGetProtocolCompression (HPORT, RAS_PROTOCOLTYPE, RAS_PROTOCOLCOMPRESSION *, RAS_PROTOCOLCOMPRESSION *) ;

DWORD APIENTRY RasPortSetProtocolCompression (HPORT, RAS_PROTOCOLTYPE, RAS_PROTOCOLCOMPRESSION *, RAS_PROTOCOLCOMPRESSION *) ;

DWORD APIENTRY RasGetFramingCapabilities (HPORT, RAS_FRAMING_CAPABILITIES*) ;

DWORD APIENTRY RasInitialize () ;

DWORD APIENTRY RasPortReserve (PCHAR, HPORT*) ;

DWORD APIENTRY RasPortFree (HPORT) ;

DWORD APIENTRY RasPortBundle( HPORT, HPORT );

DWORD APIENTRY RasPortGetBundledPort (HPORT oldport, HPORT *pnewport) ;

DWORD APIENTRY RasBundleGetPort (HBUNDLE hbundle, HPORT *phport) ;

DWORD APIENTRY RasPortGetBundle (HPORT hport, HBUNDLE *phbundle) ;

DWORD APIENTRY RasReferenceRasman (BOOL fAttach);

DWORD APIENTRY RasGetDialParams (DWORD dwUID, LPDWORD lpdwMask, PRAS_DIALPARAMS pDialParams);

DWORD APIENTRY RasSetDialParams (DWORD dwOldUID, DWORD dwMask, PRAS_DIALPARAMS pDialParams, BOOL fDelete);

DWORD APIENTRY RasCreateConnection (HCONN *hconn);

DWORD APIENTRY RasDestroyConnection (HCONN hconn);

DWORD APIENTRY RasConnectionEnum (HCONN *lphconn, LPDWORD lpdwcbConnections, LPDWORD lpdwcConnections);

DWORD APIENTRY RasAddConnectionPort (HCONN hconn, HPORT hport, DWORD dwSubEntry);

DWORD APIENTRY RasEnumConnectionPorts (HCONN hconn, RASMAN_PORT *pPorts, LPDWORD lpdwcbPorts, LPDWORD lpdwcPorts);

DWORD APIENTRY RasGetConnectionParams (HCONN hconn, PRAS_CONNECTIONPARAMS pConnectionParams);

DWORD APIENTRY RasSetConnectionParams (HCONN hconn, PRAS_CONNECTIONPARAMS pConnectionParams);

DWORD APIENTRY RasGetConnectionUserData (HPORT hconn, DWORD dwTag, PBYTE pBuf, LPDWORD lpdwcbBuf);

DWORD APIENTRY RasSetConnectionUserData (HPORT hconn, DWORD dwTag, PBYTE pBuf, DWORD dwcbBuf);

DWORD APIENTRY RasGetPortUserData (HPORT hport, DWORD dwTag, PBYTE pBuf, LPDWORD lpdwcbBuf);

DWORD APIENTRY RasSetPortUserData (HPORT hport, DWORD dwTag, PBYTE pBuf, DWORD dwcbBuf);

DWORD APIENTRY RasAddNotification (HCONN hconn, HANDLE hevent, DWORD dwfFlags);

DWORD APIENTRY RasSignalNewConnection(HCONN hconn);

DWORD APIENTRY RasSetDevConfig(HPORT hport, PCHAR devicetype, PBYTE config, DWORD size);

DWORD APIENTRY RasGetDevConfig(HPORT hport, PCHAR devicetype, PBYTE config, DWORD* size);

DWORD APIENTRY RasGetTimeSinceLastActivity(HPORT hport, LPDWORD lpdwTimeSinceLastActivity );

DWORD APIENTRY RasBundleGetStatistics(HPORT, PBYTE, PWORD);

DWORD APIENTRY RasBundleClearStatistics(HPORT);

DWORD _RasmanInit( LPDWORD pNumPorts );

VOID _RasmanEngine();

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\rasmxs.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: rasmxs.h
//
//  Revision History:
//
//  Jun 24, 1992   J. Perry Hannah   Created
//
//
//  Description: This file contains name strings for standard macros and
//               variables found in modem.inf, pad.inf, and switch.inf.
//               This header file will be needed by all users.
//
//****************************************************************************


#ifndef _RASMXS_
#define _RASMXS_


//  General Defines  *********************************************************
//

#include <rasfile.h>


#define  MAX_PHONE_NUMBER_LENGTH    RAS_MAXLINEBUFLEN

#define  MXS_PAD_TXT                "pad"
#define  MXS_MODEM_TXT              "modem"
#define  MXS_SWITCH_TXT             "switch"
#define  MXS_NULL_TXT               "null"

#define  ATTRIB_VARIABLE            0x08
#define  ATTRIB_BINARYMACRO         0x04
#define  ATTRIB_USERSETTABLE        0x02
#define  ATTRIB_ENABLED             0x01


//  Unary Macros  ************************************************************
//
                                                                    //Used in:

#define  MXS_PHONENUMBER_KEY        "PhoneNumber"                   //modem.inf
#define  MXS_CARRIERBPS_KEY         "CarrierBps"                    //modem.inf
#define  MXS_CONNECTBPS_KEY         "ConnectBps"                    //modem.inf

#define  MXS_X25PAD_KEY             "X25Pad"                        //pad.inf
#define  MXS_X25ADDRESS_KEY         "X25Address"                    //pad.inf
#define  MXS_DIAGNOSTICS_KEY        "Diagnostics"                   //pad.inf
#define  MXS_USERDATA_KEY           "UserData"                      //pad.inf
#define  MXS_FACILITIES_KEY         "Facilities"                    //pad.inf

#define  MXS_MESSAGE_KEY	    "Message"			    //all

#define  MXS_USERNAME_KEY	    "UserName"			    //all
#define  MXS_PASSWORD_KEY	    "Password"			    // all


//  Binary Macros  ***********************************************************
//

#define  MXS_SPEAKER_KEY            "Speaker"                       //modem.inf
#define  MXS_HDWFLOWCONTROL_KEY     "HwFlowControl"                 //modem.inf
#define  MXS_PROTOCOL_KEY           "Protocol"                      //modem.inf
#define  MXS_COMPRESSION_KEY        "Compression"                   //modem.inf
#define  MXS_AUTODIAL_KEY           "AutoDial"                      //modem.inf


//  Binary Macro Suffixes  ***************************************************
//

#define  MXS_ON_SUFX                "_on"                           //all
#define  MXS_OFF_SUFX               "_off"                          //all


//  INF File Variables  ******************************************************
//

#define  MXS_DEFAULTOFF_KEY         "DEFAULTOFF"                    //modem.inf
#define  MXS_CALLBACKTIME_KEY       "CALLBACKTIME"                  //modem.inf
#define  MXS_MAXCARRIERBPS_KEY      "MAXCARRIERBPS"                 //modem.inf
#define  MXS_MAXCONNECTBPS_KEY      "MAXCONNECTBPS"                 //modem.inf


//  Keywork Prefixes  ********************************************************
//

#define  MXS_COMMAND_PRFX           "COMMAND"                       //all
#define  MXS_CONNECT_PRFX           "CONNECT"                       //all
#define  MXS_ERROR_PRFX             "ERROR"                         //all
#define  MXS_OK_PRFX                "OK"                            //all


//  Modem Command Keywords  **************************************************
//

#define  MXS_GENERIC_COMMAND        "COMMAND"
#define  MXS_INIT_COMMAND           "COMMAND_INIT"
#define  MXS_DIAL_COMMAND           "COMMAND_DIAL"
#define  MXS_LISTEN_COMMAND         "COMMAND_LISTEN"


//  Modem Response Keywords  *************************************************
//

#define  MXS_OK_KEY                 "OK"

#define  MXS_CONNECT_KEY            "CONNECT"
#define  MXS_CONNECT_EC_KEY         "CONNECT_EC"

#define  MXS_ERROR_KEY              "ERROR"
#define  MXS_ERROR_BUSY_KEY         "ERROR_BUSY"
#define  MXS_ERROR_NO_ANSWER_KEY    "ERROR_NO_ANSWER"
#define  MXS_ERROR_VOICE_KEY        "ERROR_VOICE"
#define  MXS_ERROR_NO_CARRIER_KEY   "ERROR_NO_CARRIER"
#define  MXS_ERROR_NO_DIALTONE_KEY  "ERROR_NO_DIALTONE"
#define  MXS_ERROR_DIAGNOSTICS_KEY  "ERROR_DIAGNOSTICS"

#define  MXS_NORESPONSE             "NoResponse"
#define  MXS_NOECHO                 "NoEcho"



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\rastapi.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//	Copyright (C) 1994-95 Microsft Corporation. All rights reserved.
//
//  Filename: rastapi.h
//
//  Revision History
//
//  Mar  28 1992   Gurdeep Singh Pall	Created
//
//
//  Description: This file contains all structs for TAPI.DLL
//
//****************************************************************************

#define DEVICETYPE_ISDN "ISDN"
#define DEVICETYPE_X25	"X25"
#define DEVICETYPE_UNIMODEM "MODEM"
// #define DEVICETYPE_UNIMODEM "MODEMS"
#define DEVICETYPE_PPTP "VPN"
#define REMOTEACCESS_APP "RemoteAccess"

#define CONTROLBLOCKSIGNATURE 0x06051932

#define CLIENT_USAGE "Client"
#define SERVER_USAGE "Server"
#define CLIENTANDSERVER_USAGE "ClientAndServer"

#define REGISTRY_RASMAN_TAPI_KEY "Software\\Microsoft\\RAS\\Tapi Devices"
#define REGISTRY_ADDRESS	 "Address"
#define REGISTRY_FRIENDLYNAME	 "Friendly Name"
#define REGISTRY_MEDIATYPE	 "Media Type"
#define REGISTRY_USAGE		 "Usage"

#define LOW_MAJOR_VERSION   0x0001
#define LOW_MINOR_VERSION   0x0003
#define HIGH_MAJOR_VERSION  0x0002
#define HIGH_MINOR_VERSION  0x0000

#define LOW_VERSION  ((LOW_MAJOR_VERSION  << 16) | LOW_MINOR_VERSION)
#define HIGH_VERSION ((HIGH_MAJOR_VERSION << 16) | HIGH_MINOR_VERSION)

#define LOW_EXT_MAJOR_VERSION		0x0000
#define LOW_EXT_MINOR_VERSION		0x0000
#define HIGH_EXT_MAJOR_VERSION		0x0000
#define HIGH_EXT_MINOR_VERSION		0x0000

#define LOW_EXT_VERSION  ((LOW_EXT_MAJOR_VERSION  << 16) | LOW_EXT_MINOR_VERSION)
#define HIGH_EXT_VERSION ((HIGH_EXT_MAJOR_VERSION << 16) | HIGH_EXT_MINOR_VERSION)

// Generic indexes
#define ADDRESS_INDEX		0
#define CONNECTBPS_INDEX	1

// ISDN param indexes
#define ISDN_ADDRESS_INDEX	ADDRESS_INDEX
#define ISDN_CONNECTBPS_INDEX	CONNECTBPS_INDEX
#define ISDN_LINETYPE_INDEX	2
#define ISDN_FALLBACK_INDEX	3
#define ISDN_COMPRESSION_INDEX	4
#define ISDN_CHANNEL_AGG_INDEX	5

// X25 indexes
#define X25_ADDRESS_INDEX	ADDRESS_INDEX
#define X25_CONNECTBPS_INDEX	CONNECTBPS_INDEX
#define X25_DIAGNOSTICS_INDEX	2
#define X25_USERDATA_INDEX	3
#define X25_FACILITIES_INDEX	4

enum PORT_STATE {

    PS_CLOSED,

    PS_OPEN,

    PS_LISTENING,

    PS_CONNECTED,

    PS_CONNECTING,

    PS_DISCONNECTING,

    PS_UNINITIALIZED,

} ;

typedef enum PORT_STATE PORT_STATE ;
typedef enum PORT_STATE LINE_STATE ;


enum LISTEN_SUBSTATE {

    LS_WAIT,

    LS_RINGING,

    LS_ACCEPT,

    LS_ANSWER,

    LS_COMPLETE,

    LS_ERROR,

} ;

typedef enum LISTEN_SUBSTATE LISTEN_SUBSTATE ;


struct TapiLineInfo {

    DWORD	    TLI_LineId ;	// Returned by LineInitialize

    HLINE	    TLI_LineHandle ;	// Returned by LineOpen

#define  MAX_PROVIDER_NAME 48
    CHAR	    TLI_ProviderName[MAX_PROVIDER_NAME] ;

    LINE_STATE	    TLI_LineState ;	// open?, closed?, listen posted?.

    DWORD	    TLI_OpenCount ;

    DWORD	    NegotiatedApiVersion;

    DWORD	    NegotiatedExtVersion;

    DWORD	    IdleReceived;

} ;

typedef struct TapiLineInfo TapiLineInfo ;

struct TapiPortControlBlock {

    DWORD       TPCB_Signature ;    // Unique signature for verifying block ptr.

    HANDLE	    TPCB_Handle ;	    // Handle used to identify this port

    CHAR	    TPCB_Name[MAX_PORT_NAME] ;	// Friendly Name of the port

    CHAR	    TPCB_Address[MAX_PORT_NAME] ;// Address

    PORT_STATE	    TPCB_State ;	// State of the port

    LISTEN_SUBSTATE TPCB_ListenState ;	// state of the listen

    CHAR	    TPCB_DeviceType[MAX_DEVICETYPE_NAME] ; // ISDN, etc.

    CHAR	    TPCB_DeviceName [MAX_DEVICE_NAME] ; // Digiboard etc.

    RASMAN_USAGE    TPCB_Usage ;	// CALLIN, CALLOUT or BOTH

    TapiLineInfo   *TPCB_Line ;		// Handle to the "line" this port belongs to

    DWORD	    TPCB_AddressId ;	// Address ID for this "port"

    HCALL	    TPCB_CallHandle ;	// When connected the call id

    HANDLE	    TPCB_DiscNotificationHandle ; // passed in open

    HANDLE	    TPCB_ReqNotificationHandle ;  // passed in device listen and connect

    DWORD	    TPCB_RequestId ;	// id for async requests.

    DWORD	    TPCB_AsyncErrorCode ; // used to store asycn returned code.

    CHAR	    TPCB_Info[6][100] ;	// port info associated with this connection

    DWORD       TPCB_Endpoint ;     // used to store asyncmac context for unimodem ports

    HANDLE      TPCB_CommHandle ;   // used to store comm port handle used in unimodem ports

    OVERLAPPED  TPCB_ReadOverlapped ;   // used in read async ops.

    OVERLAPPED  TPCB_WriteOverlapped ;   // used in write async ops.

    DWORD       TPCB_MediaMode  ;   // Media mode to use for lineopens.

    PBYTE       TPCB_DevConfig ;    // Opaque blob of data used for configuring tapi devices - this is passed in to
                                    // us using DeviceSetDevConfig() ;

    DWORD       TPCB_SizeOfDevConfig ;      // Size of the above blob.

    PBYTE       TPCB_DefaultDevConfig ;     // The current config for the device that is saved away before we write any changes
                                            // to the device. This allows RAS to be a good citizen by not overwriting defauls.

    DWORD       TPCB_DefaultDevConfigSize ;

    DWORD	TPCB_DisconnectReason ;     // Reason for disconnection.

    DWORD	TPCB_NumberOfRings ;	    // Number of rings received so far.
} ;

typedef struct TapiPortControlBlock TapiPortControlBlock ;


VOID FAR PASCAL RasTapiCallback (HANDLE, DWORD, DWORD, DWORD, DWORD, DWORD) ;

VOID SetIsdnParams (TapiPortControlBlock *, LINECALLPARAMS *) ;

VOID GetMutex (HANDLE, DWORD) ;

VOID FreeMutex (HANDLE) ;

DWORD EnumerateTapiPorts (HANDLE) ;

BOOL GetAssociatedPortName(char  *szKeyName, CHAR *szPortName) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\reghelp.h ===
/*++

Copyright (C) 1994-95 Microsft Corporation. All rights reserved.

Module Name: 

    reghelp.h

Abstract:

    This file contains helper functions to read enpoint information
    from registry

Author:

    Rao Salapaka (raos) 01-Nov-1997

Revision History:

--*/

DWORD   DwGetEndPointInfo( DeviceInfo *pInfo, PBYTE pAddress );

DWORD   DwSetEndPointInfo( DeviceInfo *pInfo, PBYTE pAddress );

LONG    lrRasEnableDevice(HKEY hkey, 
                          LPTSTR pszValue,
                          BOOL fEnable);

LONG    lrGetSetMaxEndPoints(DWORD* pdwMaxDialOut,
                             DWORD* pdwMaxDialIn,
                             BOOL   fRead);
                             
DWORD   DwSetModemInfo( DeviceInfo *pInfo);

DWORD   DwSetCalledIdInfo(HKEY hkey,
                          DeviceInfo *pInfo);

DWORD   DwGetCalledIdInfo(HKEY hkey,
                          DeviceInfo  *pInfo);
                       

LONG    lrGetProductType(PRODUCT_TYPE *ppt);

int     RegHelpStringFromGuid(REFGUID rguid, 
        				      LPWSTR lpsz, 
        				      int cchMax);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\wanioctl.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    wanioctl.h

Abstract:

    This is the main file for the NdisWan Driver for the Remote Access
    Service.  This driver conforms to the NDIS 3.0 interface.

Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

// All AsyncMac errors start with this base number
#define ASYBASE 700

// The Mac has not bound to an upper protocol, or the
// previous binding to AsyncMac has been destroyed.
#define ASYNC_ERROR_NO_ADAPTER                  ASYBASE+0

// A port was attempted to be open that was not CLOSED yet.
#define ASYNC_ERROR_ALREADY_OPEN                ASYBASE+1

// All the ports (allocated) are used up or there is
// no binding to the AsyncMac at all (and thus no ports).
// The number of ports allocated comes from the registry.
#define ASYNC_ERROR_NO_PORT_AVAILABLE   ASYBASE+2

// In the open IOCtl to the AsyncParameter the Adapter
// parameter passed was invalid.
#define ASYNC_ERROR_BAD_ADAPTER_PARAM   ASYBASE+3

// During a close or compress request, the port
// specified did not exist.
#define ASYNC_ERROR_PORT_NOT_FOUND              ASYBASE+4

// A request came in for the port which could not
// be handled because the port was in a bad state.
// i.e. you can't a close a port if its state is OPENING
#define ASYNC_ERROR_PORT_BAD_STATE              ASYBASE+5

// A call to ASYMAC_COMPRESS was bad with bad
// parameters.  That is, parameters that were not
// supported.  The fields will not be set to the bad params.
#define ASYNC_ERROR_BAD_COMPRESSION_INFO ASYBASE+6

//-------------- NDISWAN SPECIFIC RETURN CODES --------------------

// A request for information came in for an endpoint handle
// which does not exist (out of range)
#define NDISWAN_ERROR_BAD_ENDPOINT              ASYBASE+40

// A request for information came in for a protocol handle
// which does not exist (out of range)
#define NDISWAN_ERROR_BAD_PROTOCOL              ASYBASE+41

// A request for a route which already existed came in
#define NDISWAN_ERROR_ALREADY_ROUTED            ASYBASE+42

// A request for a route exceeded the routing tables capabilities
#define NDISWAN_ERROR_TOO_MANY_ROUTES   ASYBASE+43

// Send packet has wrong packet size
#define NDISWAN_ERROR_BAD_PACKET_SIZE   ASYBASE+44

// BindAddress has an address already used as an endpoint (duplicate address)
#define NDISWAN_ERROR_BAD_ADDRESS               ASYBASE+45

// Endpoint has an address already bound to it
#define NDISWAN_ERROR_ALREADY_BOUND             ASYBASE+46

// Endpoint was routed without being bound to a remote address
#define NDISWAN_ERROR_NOT_BOUND_YET             ASYBASE+47

// Here we define the DevIOCtl code for the ndiswan
//
// IOCTLs for user-mode requests.
//

// Token-ring and Ethernet address lengths
#define IEEE_ADDRESS_LENGTH     6

// The max packet size information should be picked in a call!!!
// Maximum size of packet that can be sent/rcvd via NDISWAN_SENDPKT/RECVPKT
#define PACKET_SIZE                     1500

// Two 6 byte addreses plus the type/length field (used in RECVPKT)
// Native addressing schemes may have a different header size!!!
#define HEADER_SIZE                     14

// When unrouting an endpoint (hNdisHandle) specify the PROTOCOL_UNROUTE
#define PROTOCOL_UNROUTE        0xFFFF


// we need to get this device defined in sdk\inc\devioctl.h
// for now, I will use 30, since no one is using it yet!
// Beware that the NDIS Wrapper uses IOCTLs based on
// FILE_DEVICE_PHYSICAL_NETCARD
//#define FILE_DEVICE_NDIS              0x30

// below is the standard method for defining IOCTLs for your
// device given that your device is unique.

// we need to get this device defined in sdk\inc\devioctl.h
// for now, I will use 30, since no one is using it yet!
// Beware that the NDIS Wrapper uses IOCTLs based on
// FILE_DEVICE_PHYSICAL_NETCARD
#define FILE_DEVICE_RAS         0x30

// below is the standard method for defining IOCTLs for your
// device given that your device is unique.
#define _RAS_CONTROL_CODE(request,method) \
                ((FILE_DEVICE_RAS)<<16 | (request<<2) | method)

#define IOCTL_ASYMAC_OPEN               _RAS_CONTROL_CODE(10, METHOD_BUFFERED )
#define IOCTL_ASYMAC_CLOSE              _RAS_CONTROL_CODE(11, METHOD_BUFFERED )
//#define IOCTL_ASYMAC_COMPRESS _RAS_CONTROL_CODE(12, METHOD_BUFFERED )
//#define IOCTL_ASYMAC_ENUM             _RAS_CONTROL_CODE(13, METHOD_BUFFERED )
//#define IOCTL_ASYMAC_GETSTATS _RAS_CONTROL_CODE(14, METHOD_BUFFERED )
#define IOCTL_ASYMAC_TRACE              _RAS_CONTROL_CODE(15, METHOD_BUFFERED )

#define IOCTL_NDISWAN_ENUM              _RAS_CONTROL_CODE(6, METHOD_BUFFERED )
#define IOCTL_NDISWAN_ROUTE     _RAS_CONTROL_CODE(7, METHOD_BUFFERED )
#define IOCTL_NDISWAN_GETSTATS  _RAS_CONTROL_CODE(8, METHOD_BUFFERED )
#define IOCTL_NDISWAN_PROTENUM  _RAS_CONTROL_CODE(9, METHOD_BUFFERED )
#define IOCTL_NDISWAN_SENDPKT   _RAS_CONTROL_CODE(10, METHOD_BUFFERED )
#define IOCTL_NDISWAN_RECVPKT   _RAS_CONTROL_CODE(11, METHOD_BUFFERED )
#define IOCTL_NDISWAN_FLUSH             _RAS_CONTROL_CODE(12, METHOD_BUFFERED )
#define IOCTL_NDISWAN_TRACE             _RAS_CONTROL_CODE(13, METHOD_BUFFERED )

#define IOCTL_NDISWAN_INFO                      _RAS_CONTROL_CODE(24, METHOD_BUFFERED )
#define IOCTL_NDISWAN_SET_LINK_INFO     _RAS_CONTROL_CODE(25, METHOD_BUFFERED )
#define IOCTL_NDISWAN_GET_LINK_INFO     _RAS_CONTROL_CODE(26, METHOD_BUFFERED )

#define IOCTL_NDISWAN_SET_BRIDGE_INFO   _RAS_CONTROL_CODE(27, METHOD_BUFFERED )
#define IOCTL_NDISWAN_GET_BRIDGE_INFO   _RAS_CONTROL_CODE(28, METHOD_BUFFERED )

#define IOCTL_NDISWAN_SET_COMP_INFO     _RAS_CONTROL_CODE(29, METHOD_BUFFERED )
#define IOCTL_NDISWAN_GET_COMP_INFO     _RAS_CONTROL_CODE(30, METHOD_BUFFERED )

#define IOCTL_NDISWAN_SET_VJ_INFO               _RAS_CONTROL_CODE(31, METHOD_BUFFERED )
#define IOCTL_NDISWAN_GET_VJ_INFO               _RAS_CONTROL_CODE(32, METHOD_BUFFERED )

#define IOCTL_NDISWAN_SET_CIPX_INFO     _RAS_CONTROL_CODE(33, METHOD_BUFFERED )
#define IOCTL_NDISWAN_GET_CIPX_INFO     _RAS_CONTROL_CODE(34, METHOD_BUFFERED )

#define IOCTL_NDISWAN_SET_MULTILINK_INFO        _RAS_CONTROL_CODE(35, METHOD_BUFFERED )
#define IOCTL_NDISWAN_GET_MULTILINK_INFO        _RAS_CONTROL_CODE(36, METHOD_BUFFERED )


#define IOCTL_ASYMAC_DCDCHANGE          _RAS_CONTROL_CODE(40, METHOD_BUFFERED )
//#define IOCTL_ASYMAC_STARTFRAMING     _RAS_CONTROL_CODE(41, METHOD_BUFFERED )
#define IOCTL_NDISWAN_LINEUP            _RAS_CONTROL_CODE(42, METHOD_BUFFERED )


#define IOCTL_NDISWAN_ENUM_ACTIVE_BUNDLES       _RAS_CONTROL_CODE(45, METHOD_BUFFERED )

// Currently a global array of pointers is used
// which must be predefined to some constant.
// The current restriction seems to be 256
#define MAX_ENDPOINTS                   256
#define MAX_PROTOCOL_BINDINGS   256
#define MAX_MAC_BINDINGS                48
#define MAC_NAME_SIZE                   32


// Here we define the WanEnumBuffer structure
//------------------------------------------------------------------------
//------------------------------- ENDPOINTS ------------------------------
//------------------------------------------------------------------------

// We assume that the most number of protocols a client will run
// is three for now...  that is a client can run TCP/IP, IPX, NBF at
// the same time, but not a fourth protocol.
#define MAX_ROUTES_PER_ENDPOINT 3

// The bytes transmitted, bytes received, frames received, frame transmitted
// are monitored for frame and bytes going to the output device or
// coming from the output device.  If software compression used, it
// is on top of this layer.
typedef struct GENERIC_STATS GENERIC_STATS, *PGENERIC_STATS;
struct GENERIC_STATS {
        ULONG           BytesTransmitted;                               // Generic info
        ULONG           BytesReceived;                                  // Generic info
        ULONG           FramesTransmitted;              // Generic info
        ULONG           FramesReceived;                 // Generic info
};

// o CRC errors are when the 16bit V.41 CRC check fails
// o TimeoutErrors occur when inter-character delays within
//   a frame are exceeded
// o AlignmentErrors occur when the SYN byte or ETX bytes which
//   mark the beginning and end of frames are not found.
// o The other errors are standard UART errors returned by the serial driver
typedef struct SERIAL_STATS SERIAL_STATS, *PSERIAL_STATS;
struct SERIAL_STATS {
        ULONG           CRCErrors;                                              // Serial-like info only
        ULONG           TimeoutErrors;                          // Serial-like info only
        ULONG           AlignmentErrors;                        // Serial-like info only
        ULONG           SerialOverrunErrors;                    // Serial-like info only
        ULONG           FramingErrors;                          // Serial-like info only
        ULONG           BufferOverrunErrors;                    // Serial-like info only
};

typedef struct WAN_STATS WAN_STATS, *PWAN_STATS;
struct WAN_STATS {
        ULONG           BytesSent;      
        ULONG           BytesRcvd;
        ULONG           FramesSent;
        ULONG           FramesRcvd;

        ULONG           CRCErrors;                                              // Serial-like info only
        ULONG           TimeoutErrors;                          // Serial-like info only
        ULONG           AlignmentErrors;                        // Serial-like info only
        ULONG           SerialOverrunErrors;                    // Serial-like info only
        ULONG           FramingErrors;                          // Serial-like info only
        ULONG           BufferOverrunErrors;                    // Serial-like info only

        ULONG           BytesTransmittedUncompressed;   // Compression info only
        ULONG           BytesReceivedUncompressed;      // Compression info only
        ULONG           BytesTransmittedCompressed;     // Compression info only
        ULONG           BytesReceivedCompressed;        // Compression info only


};

typedef struct ROUTE_INFO ROUTE_INFO, *PROUTE_INFO;
struct ROUTE_INFO {
        USHORT          ProtocolType;           // <1500 (NetBEUI), IP, IPX, AppleTalk
        NDIS_HANDLE     ProtocolRoutedTo;       // Handle of protocol to send/recv frames
};

//
// The structure passed up on a WAN_LINE_UP indication
//

typedef struct _ASYNC_LINE_UP {
    ULONG LinkSpeed;                            // 100 bps units
    ULONG MaximumTotalSize;                     // suggested max for send packets
    NDIS_WAN_QUALITY Quality;
    USHORT SendWindow;                          // suggested by the MAC
    UCHAR RemoteAddress[6];                                 // check for in SRC field when rcv
        UCHAR LocalAddress[6];                                  // use SRC field when sending
        USHORT Endpoint;                                        // can we get rid of this!!
        USHORT ProtocolType;                                    // protocol type
        ULONG  BufferLength;                                    // length of protocol specific buffer
        UCHAR  Buffer[1];                                               // protocol specific buffer


} ASYNC_LINE_UP, *PASYNC_LINE_UP;


typedef struct _NDISMAC_LINE_UP {
    IN  ULONG               LinkSpeed;
    IN  NDIS_WAN_QUALITY    Quality;
    IN  USHORT              SendWindow;
    IN  NDIS_HANDLE         ConnectionWrapperID;        // TAPI Cookie
    IN  NDIS_HANDLE         NdisLinkHandle;             
    OUT NDIS_HANDLE         NdisLinkContext;
} NDISMAC_LINE_UP, *PNDISMAC_LINE_UP;


typedef struct NDISWAN_INFO NDISWAN_INFO, *PNDISWAN_INFO;
struct NDISWAN_INFO              {
    ULONG       MaxFrameSize;
        ULONG           MaxTransmit;
    ULONG       HeaderPadding;
    ULONG       TailPadding;
        ULONG           Endpoints;
        UINT        MemoryFlags;
    NDIS_PHYSICAL_ADDRESS HighestAcceptableAddress;
    ULONG       FramingBits;
    ULONG       DesiredACCM;
    ULONG       MaxReconstructedFrameSize;
};

//------------------------------------------------------------------------
//----------------------------- PROTOCOL INFO ----------------------------
//------------------------------------------------------------------------
// There is a PROTOCOL_INFO struct per NDIS protocol binding to NdisWan.
// NOTE:  Most protocols will bind multiple times to the NdisWan.
#define PROTOCOL_NBF            0x80D5
#define PROTOCOL_IP                     0x0800
#define PROTOCOL_ARP            0x0806
#define PROTOCOL_IPX            0x8137
#define PROTOCOL_APPLETALK      0x80F3
#define PROTOCOL_XNS            0x0807

typedef struct PROTOCOL_INFO PROTOCOL_INFO, *PPROTOCOL_INFO;
struct PROTOCOL_INFO {
        NDIS_HANDLE     hProtocolHandle;        // Order at which protocol bound to NdisWan
        ULONG           NumOfRoutes;            // Num of routes this endpoint has
    NDIS_MEDIUM MediumType;                     // NdisMedium802_5, NdisMediumAsync
        USHORT          ProtocolType;           // EtherType of NBF, IP, IPX, AppleTalk..
        USHORT          AdapterNameLength;                      // Up to 16...
        WCHAR           AdapterName[MAC_NAME_SIZE];
                                                                                        // First 16 chars of MAC name
                                                                                        // like "NdisWan01"
                                                                                        // Used to figure out LANA..

        NDIS_HANDLE MacBindingHandle;
        NDIS_HANDLE     MacAdapterContext;      // needed by NdisMan or me?
        NDIS_HANDLE     NdisBindingContext;     // needed by NdisMan or me?
};

typedef struct PROTOCOL_ENUM_BUFFER PROTOCOL_ENUM_BUFFER, *PPROTOCOL_ENUM_BUFFER;
struct PROTOCOL_ENUM_BUFFER {
        ULONG                   NumOfProtocols; // One for each NDIS Upper Binding
                                                                        // Not for each DIFFERENT Protocol
        PROTOCOL_INFO   ProtocolInfo[];
};

typedef struct _ENUM_ACTIVE_BUNDLES ENUM_ACTIVE_BUNDLES, *PENUM_ACTIVE_BUNDLES;
struct _ENUM_ACTIVE_BUNDLES {

        ULONG   NumberOfActiveBundles;

};

//------------------------------------------------------------------------
//------------------------ ASYMAC IOCTL STRUCTS --------------------------
//------------------------------------------------------------------------

// this structure is passed in as the input buffer when opening a port
typedef struct ASYMAC_OPEN ASYMAC_OPEN, *PASYMAC_OPEN;
struct ASYMAC_OPEN {
OUT NDIS_HANDLE hNdisEndpoint;          // unique for each endpoint assigned
IN  ULONG               LinkSpeed;              // RAW link speed in bits per sec
IN  USHORT              QualOfConnect;          // NdisAsyncRaw, NdisAsyncErrorControl, ...
IN      HANDLE          FileHandle;                     // the Win32 or Nt File Handle
};


// this structure is passed in as the input buffer when closing a port
typedef struct ASYMAC_CLOSE ASYMAC_CLOSE, *PASYMAC_CLOSE;
struct ASYMAC_CLOSE {
    NDIS_HANDLE hNdisEndpoint;          // unique for each endpoint assigned
        PVOID           MacAdapter;                     // Which binding to AsyMac to use -- if set
                                                                        // to NULL, will default to last binding
};


typedef struct ASYMAC_DCDCHANGE ASYMAC_DCDCHANGE, *PASYMAC_DCDCHANGE;
struct ASYMAC_DCDCHANGE {
    NDIS_HANDLE hNdisEndpoint;          // unique for each endpoint assigned
        PVOID           MacAdapter;                     // Which binding to AsyMac to use -- if set
                                                                        // to NULL, will default to last binding
};


// this structure is used to read/set configurable 'feature' options
// during authentication this structure is passed and an
// agreement is made which features to support
typedef struct ASYMAC_FEATURES ASYMAC_FEATURES, *PASYMAC_FEATURES;
struct ASYMAC_FEATURES {
    ULONG               SendFeatureBits;        // A bit field of compression/features sendable
        ULONG           RecvFeatureBits;        // A bit field of compression/features receivable
        ULONG           MaxSendFrameSize;       // Maximum frame size that can be sent
                                                                        // must be less than or equal default
        ULONG           MaxRecvFrameSize;       // Maximum frame size that can be rcvd
                                                                        // must be less than or equal default

        ULONG           LinkSpeed;                      // New RAW link speed in bits/sec
                                                                        // Ignored if 0
};


// TransmittedUncompressed are the number of bytes that the compressor
// saw BEFORE attempting to compress the data (top end)
// TransmitCompressed is the bottom end of the compressor which
// is equal to the amount of bytes the compressor spat out (after compression)
// This only counts bytes that went THROUGH the compression mechanism
// Small frames and multi-cast frames (typically) do not get compressed.
typedef struct COMPRESSION_STATS COMPRESSION_STATS, *PCOMPRESSION_STATS;
struct COMPRESSION_STATS {
        ULONG           BytesTransmittedUncompressed;   // Compression info only
        ULONG           BytesReceivedUncompressed;      // Compression info only
        ULONG           BytesTransmittedCompressed;     // Compression info only
        ULONG           BytesReceivedCompressed;        // Compression info only
};


//------------------------------------------------------------------------
//------------------------ NDISWAN IOCTL STRUCTS --------------------------
//------------------------------------------------------------------------

// Define for PACKET_FLAGS
#define PACKET_IS_DIRECT                0x01
#define PACKET_IS_BROADCAST             0x02
#define PACKET_IS_MULTICAST         0x04

// Define for FLUSH_FLAGS
#define FLUSH_RECVPKT                   0x01
#define FLUSH_SENDPKT                   0x02


// The packet just contains data (no IEEE addresses or anything)
// Should it?? Get rid of PACKET_FLAGS??
typedef struct PACKET PACKET, *PPACKET;
struct PACKET {
        UCHAR           PacketData[1];
};


// When unrouting an endpoint (hNdisHandle) specify the PROTOCOL_UNROUTE
#define PROTOCOL_UNROUTE                0xFFFF


// This structure is passed in as the input buffer when routing
typedef struct NDISWAN_ROUTE NDISWAN_ROUTE, *PNDISWAN_ROUTE;
struct NDISWAN_ROUTE {
    NDIS_HANDLE hNdisEndpoint;          // The NdisMan/NdisWan/AsyMac endpoint
    NDIS_HANDLE hProtocolHandle;        // The upper unique protocol (up to 3)
        ASYNC_LINE_UP   AsyncLineUp;    // Include the protocol specific field
};

// This structure is passed in AND out as the input buffer AND
// the output buffer when receiving and sending a frame.
typedef struct NDISWAN_PKT NDISWAN_PKT, *PNDISWAN_PKT;
struct NDISWAN_PKT {                                    // Event is singalled via IOCtl mechanisms
    NDIS_HANDLE hNdisEndpoint;          // The NdisMan/NdisWan/AsyMac endpoint
    USHORT              PacketFlags;            // Broadcast, Multicast, Directed..
        USHORT          PacketSize;                     // Size of packet below (including the header)
        USHORT          HeaderSize;                     // Size of header inside packet
    PACKET              Packet;                         // Not a pointer -- entire packet struct
                                                                // We cannot use a PTR because it
                                    // cannot be probed easily...
                                                                        // Packet looks like - header data + sent data
                                                                        // HeaderSize of 0 is valid for sends
};

typedef struct NDISWAN_FLUSH NDISWAN_FLUSH, *PNDISWAN_FLUSH;
struct NDISWAN_FLUSH {                          // Event is singalled via IOCtl mechanisms
    NDIS_HANDLE         hNdisEndpoint;  // The NdisMan/NdisWan/AsyMac endpoint
    USHORT                      FlushFlags;             // Recv | Xmit flush (or both)
};



// This structure is passed in AND out as the input buffer AND
// the output buffer when get stats on an endpoint
typedef struct NDISWAN_GETSTATS NDISWAN_GETSTATS, *PNDISWAN_GETSTATS;
struct NDISWAN_GETSTATS {
        NDIS_HANDLE     hNdisEndpoint;          // The NdisMan/NdisWan/AsyMac endpoint
        WAN_STATS       WanStats;                       // Not a PTR.  Entire statistics
                                                                        // structure
};


typedef struct NDISWAN_SET_LINK_INFO NDISWAN_SET_LINK_INFO, *PNDISWAN_SET_LINK_INFO;
struct NDISWAN_SET_LINK_INFO     {
        NDIS_HANDLE     hNdisEndpoint;          // The NdisMan/NdisWan endpoint
    ULONG       MaxSendFrameSize;
    ULONG       MaxRecvFrameSize;
    ULONG       HeaderPadding;
    ULONG       TailPadding;
    ULONG       SendFramingBits;
    ULONG       RecvFramingBits;
    ULONG       SendCompressionBits;
    ULONG       RecvCompressionBits;
    ULONG       SendACCM;
    ULONG       RecvACCM;
    ULONG       MaxRSendFrameSize;
    ULONG       MaxRRecvFrameSize;
};

typedef struct NDISWAN_GET_LINK_INFO NDISWAN_GET_LINK_INFO, *PNDISWAN_GET_LINK_INFO;
struct NDISWAN_GET_LINK_INFO     {
        NDIS_HANDLE     hNdisEndpoint;          // The NdisMan/NdisWan endpoint
    ULONG       MaxSendFrameSize;
    ULONG       MaxRecvFrameSize;
    ULONG       HeaderPadding;
    ULONG       TailPadding;
    ULONG       SendFramingBits;
    ULONG       RecvFramingBits;
    ULONG       SendCompressionBits;
    ULONG       RecvCompressionBits;
    ULONG       SendACCM;
    ULONG       RecvACCM;
    ULONG       MaxRSendFrameSize;
    ULONG       MaxRRecvFrameSize;
};


typedef struct NDISWAN_SET_BRIDGE_INFO NDISWAN_SET_BRIDGE_INFO, *PNDISWAN_SET_BRIDGE_INFO;
struct NDISWAN_SET_BRIDGE_INFO   {
        NDIS_HANDLE     hNdisEndpoint;          // The NdisMan/NdisWan endpoint
    USHORT      LanSegmentNumber;
    UCHAR       BridgeNumber;
    UCHAR       BridgingOptions;
    ULONG       BridgingCapabilities;
    UCHAR       BridgingType;
    UCHAR       MacBytes[6];
};

typedef struct NDISWAN_GET_BRIDGE_INFO NDISWAN_GET_BRIDGE_INFO, *PNDISWAN_GET_BRIDGE_INFO;
struct NDISWAN_GET_BRIDGE_INFO   {
        NDIS_HANDLE     hNdisEndpoint;          // The NdisMan/NdisWan endpoint
    USHORT      LanSegmentNumber;
    UCHAR       BridgeNumber;
    UCHAR       BridgingOptions;
    ULONG       BridgingCapabilities;
    UCHAR       BridgingType;
    UCHAR       MacBytes[6];
};


//
// Define bit field for MSCompType
//
#define NDISWAN_COMPRESSION 0x00000001
#define NDISWAN_ENCRYPTION  0x00000010

#define NT31RAS_COMPRESSION 254


typedef struct COMPRESS_INFO COMPRESS_INFO, *PCOMPRESS_INFO;
struct COMPRESS_INFO   {
        UCHAR           SessionKey[8];          // May be used for encryption, non-zero
                                                                        // if supported.
        ULONG           MSCompType;                     // Bit field.  0=No compression.

//
// Info below is received from MAC
//

    UCHAR   CompType;                   // 0=OUI, 1-254 = Public, 255=Not supported
    USHORT  CompLength;                 // Length of CompValues.
    union {
        struct {
            UCHAR CompOUI[3];
            UCHAR CompSubType;
            UCHAR CompValues[32];
        } Proprietary;

        struct {
            UCHAR CompValues[32];
        } Public;

    };
};

typedef struct NDISWAN_SET_COMP_INFO NDISWAN_SET_COMP_INFO, *PNDISWAN_SET_COMP_INFO;
struct NDISWAN_SET_COMP_INFO     {
        NDIS_HANDLE             hNdisEndpoint;          // The RasMan/NdisWan endpoint
        COMPRESS_INFO   SendCapabilities;
        COMPRESS_INFO   RecvCapabilities;
};

typedef struct NDISWAN_GET_COMP_INFO NDISWAN_GET_COMP_INFO, *PNDISWAN_GET_COMP_INFO;
struct NDISWAN_GET_COMP_INFO     {
        NDIS_HANDLE     hNdisEndpoint;                  // The RasMan/NdisWan endpoint
        COMPRESS_INFO   SendCapabilities;
        COMPRESS_INFO   RecvCapabilities;
};

typedef struct VJ_INFO VJ_INFO, *PVJ_INFO;
struct VJ_INFO       {
        USHORT          IPCompressionProtocol;  // 002d for VJ - 0000 indicates NONE!
        UCHAR           MaxSlotID;                              // How many slots to allocate
        UCHAR           CompSlotID;                             // 1 = Slot ID was negotiated
};

typedef struct NDISWAN_SET_VJ_INFO NDISWAN_SET_VJ_INFO, *PNDISWAN_SET_VJ_INFO;
struct NDISWAN_SET_VJ_INFO       {
        NDIS_HANDLE     hNdisEndpoint;                  // The RasMan/NdisWan endpoint
        VJ_INFO         SendCapabilities;
        VJ_INFO         RecvCapabilities;
};

typedef struct NDISWAN_GET_VJ_INFO NDISWAN_GET_VJ_INFO, *PNDISWAN_GET_VJ_INFO;
struct NDISWAN_GET_VJ_INFO       {
        NDIS_HANDLE     hNdisEndpoint;                  // The RasMan/NdisWan endpoint
        VJ_INFO         SendCapabilities;
        VJ_INFO         RecvCapabilities;
};

typedef struct CIPX_INFO CIPX_INFO, *PCIPX_INFO;
struct CIPX_INFO     {
        USHORT          IPXCompressionProtocol; // Telebit/Shiva - 0000 indicates NONE!
};

typedef struct NDISWAN_SET_CIPX_INFO NDISWAN_SET_CIPX_INFO, *PNDISWAN_SET_CIPX_INFO;
struct NDISWAN_SET_CIPX_INFO     {
        NDIS_HANDLE     hNdisEndpoint;                  // The RasMan/NdisWan endpoint
        CIPX_INFO       SendCapabilities;
        CIPX_INFO       RecvCapabilities;
};

typedef struct NDISWAN_GET_CIPX_INFO NDISWAN_GET_CIPX_INFO, *PNDISWAN_GET_CIPX_INFO;
struct NDISWAN_GET_CIPX_INFO     {
        NDIS_HANDLE     hNdisEndpoint;                  // The RasMan/NdisWan endpoint
        CIPX_INFO       SendCapabilities;
        CIPX_INFO       RecvCapabilities;
};


typedef struct NDISWAN_SET_MULTILINK_INFO NDISWAN_SET_MULTILINK_INFO, *PNDISWAN_SET_MULTILINK_INFO;
struct NDISWAN_SET_MULTILINK_INFO {
        NDIS_HANDLE     hNdisEndpoint;          // The RasMan/NdisWan endpoint
        NDIS_HANDLE     EndpointToBundle;       // Endpoint to bundle it to.
};

typedef struct NDISWAN_GET_MULTILINK_INFO NDISWAN_GET_MULTILINK_INFO, *PNDISWAN_GET_MULTILINK_INFO;
struct NDISWAN_GET_MULTILINK_INFO{
        NDIS_HANDLE     hNdisEndpoint;          // The RasMan/NdisWan endpoint
        ULONG           NumOfEndpoints;         // How many endpoints are bundled to this
        NDIS_HANDLE     Endpoints[0];           // List of 0..n endpoints bundled
};

// A WAN_ENDPOINT is an interface to the WanHardware.
// There will be a collection of WAN_ENDPOINT for each NDIS_ENDPOINT
//
// !!!! NOTE !!!!
// LinkSpeed, QualityOfService, and RouteInfo are meaningless
// unless the route is active (i.e. NumberOfRoutes > 0)
//
// The WanEndpointLink has to be the first entry in the structure
typedef struct WAN_ENDPOINT     WAN_ENDPOINT, *PWAN_ENDPOINT;
struct WAN_ENDPOINT {
        LIST_ENTRY              WanEndpointLink;        // used to attach wanendpoints to an ndisendpoint

        NDIS_SPIN_LOCK  Lock;                           // lock for this wanendpoint

        ULONG                   State;                          // state of the endpoint

        ULONG                   NotInUse;                       // set to false when active with a line up

        PVOID                   AllocatedMemory;        // pointer to and size of memory allocated
        ULONG                   MemoryLength;           // for this endpoints packets and buffers

        LIST_ENTRY              DataDescPool;           // Data descriptors for wan packets
        ULONG                   DataDescCount;          // Number of data descriptors in pool

        LIST_ENTRY              WanPacketPool;          // WanPackets
        ULONG                   WanPacketCount;         // Number of WanPackets in pool

        NDIS_HANDLE             hWanEndpoint;           // The NdisWan endpoint

        PVOID                   pNdisEndpoint;          // Back ptr to ndisendpoint attached to

    PVOID                       pDeviceContext;         // Back ptr to DeviceContext

        NDIS_HANDLE             NdisBindingHandle;      // Assigned by NDIS during NdisOpenAdapter

        NDISMAC_LINE_UP MacLineUp;                      // The MAC's LINE UP
        ULONG                   ulBandwidth;            // Percentage of total connection bandwidth

        NDISWAN_INFO    NdisWanInfo;            // Info about the adapter

        USHORT                  MacNameLength;                  // Up to 32...
        WCHAR                   MacName[MAC_NAME_SIZE]; // First 32 chars of MAC name
                                                                                        // like "\Device\AsyncMac01"

        NDIS_MEDIUM             MediumType;                     // NdisMedium802_3, NdisMedium802_5, Wan

        NDIS_WAN_MEDIUM_SUBTYPE
                                        WanMediumSubType;       // Serial, ISDN, X.25 - for WAN only

    NDIS_WAN_HEADER_FORMAT
                                        WanHeaderFormat;        // Native or ethernet emulation

        WAN_STATS               WanStats;                       // Generic statistics kept here

        UCHAR                   OutstandingFrames;      // count of outstanding frames on this endpoint

        LIST_ENTRY              ReadQueue;                      // Holds read frame Irps

        NDISWAN_SET_LINK_INFO   LinkInfo;
};

typedef struct WAN_ENUM_BUFFER WAN_ENUM_BUFFER, *PWAN_ENUM_BUFFER;
struct WAN_ENUM_BUFFER {
        ULONG                   NumOfEndpoints; // Looked up in registry -- key "Endpoints"
        WAN_ENDPOINT    WanEndpoint[];  // One struct for each endpoint is allocated
};

//------------------------------------------------------------------------
//------------------------ FRAMING INFORMATION ---------------------------
//------------------------------------------------------------------------

#if 0 //ndef _NDIS_WAN
//
// NDIS WAN Framing bits
//
#define OLD_RAS_FRAMING                     0x00000001
#define RAS_COMPRESSION                     0x00000002

#define PPP_MULTILINK_FRAMING                           0x00000010
#define PPP_SHORT_SEQUENCE_HDR_FORMAT           0x00000020

#define PPP_FRAMING                         0x00000100
#define PPP_COMPRESS_ADDRESS_CONTROL        0x00000200
#define PPP_COMPRESS_PROTOCOL_FIELD         0x00000400
#define PPP_ACCM_SUPPORTED                  0x00000800

#define SLIP_FRAMING                        0x00001000
#define SLIP_VJ_COMPRESSION                 0x00002000
#define SLIP_VJ_AUTODETECT                  0x00004000

#define MEDIA_NRZ_ENCODING                  0x00010000
#define MEDIA_NRZI_ENCODING                 0x00020000
#define MEDIA_NLPID                         0x00040000

#define RFC_1356_FRAMING                    0x00100000
#define RFC_1483_FRAMING                    0x00200000
#define RFC_1490_FRAMING                    0x00400000

#define SHIVA_FRAMING                                           0x01000000

#endif // _NDIS_WAN

//------------------------------------------------------------------------
//--------------------- OLD RAS COMPRESSION INFORMATION ------------------
//------------------------------------------------------------------------

// The defines below are for the compression bitmap field.

// No bits are set if compression is not available at all
#define COMPRESSION_NOT_AVAILABLE               0x00000000

// This bit is set if the mac can do version 1 compressed frames
#define COMPRESSION_VERSION1_8K                 0x00000001
#define COMPRESSION_VERSION1_16K                0x00000002
#define COMPRESSION_VERSION1_32K                0x00000004
#define COMPRESSION_VERSION1_64K                0x00000008

// And this to turn off any compression feature bit
#define COMPRESSION_OFF_BIT_MASK                (~(     COMPRESSION_VERSION1_8K  | \
                                                                                        COMPRESSION_VERSION1_16K | \
                                                COMPRESSION_VERSION1_32K | \
                                                COMPRESSION_VERSION1_64K ))

// We need to find a place to put the following supported featurettes...
#define XON_XOFF_SUPPORTED                              0x00000010

#define COMPRESS_BROADCAST_FRAMES               0x00000080

#define UNKNOWN_FRAMING                                 0x00010000
#define NO_FRAMING                                              0x00020000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\rastapi\diag.c ===
/*++

Copyright (C) 1994-98 Microsft Corporation. All rights reserved.

Module Name:

    diag.c

Abstract:

    This file contains helper routines to get the callerid/calledid
    and connect response.

Author:

    Rao salapaka (raos) 23-Feb-1998

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <tapi.h>
#include <rasman.h>
#include <raserror.h>
#include <mprlog.h>
#include <rtutils.h>

#include <media.h>
#include <device.h>
#include <rasmxs.h>
#include <isdn.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include "rastapi.h"
#include "reghelp.h"

#include <unimodem.h>

/*++

Routine Description:

    Extract CallerID and CalledID information if
    available.

Arguments:

    port - The tapi port on which the call was made
           / on which the call came in

    pLineCallInfo - the LINECALLINFO associated with
                    this call

    pdwRequiredSize - pointer to buffer to receive the
                      size of buffer required to hold
                      the callerid and called id info.

    pConnectInfo - pointer to the RASTAPI_CONNECT_INFO struct
                   where the information about the
                   callerid and called id will be filledin.
                   If this is not NULL then it is assumed
                   that the buffer is big enough to store
                   the callerid and called id iformation.

Return Value:

    ERROR_SUCCESS if successful

--*/

DWORD
DwGetIDInformation(
    TapiPortControlBlock *port,
    LINECALLINFO         *pLineCallInfo,
    DWORD                *pdwRequiredSize,
    RASTAPI_CONNECT_INFO *pConnectInfo
    )
{

    DWORD dwRequiredSize = 0;
    DWORD dwErr          = ERROR_SUCCESS;

    RasTapiTrace("DwGetIDInformation");

#if DBG

    RasTapiTrace ("RasTapiCallback: connected on %s",
                  port->TPCB_Name );

    RasTapiTrace("RasTapiCallback: CallerIDFlags=0x%x",
                 pLineCallInfo->dwCallerIDFlags);


    RasTapiTrace("RasTapiCallback: CalledIDFlags=0x%x",
                 pLineCallInfo->dwCalledIDFlags);

    RasTapiTrace("RasTapiCallback: dwNeededSize=%d",
                 pLineCallInfo->dwNeededSize);

    RasTapiTrace("RasTapiCallback: dwUsedSize=%d",
                 pLineCallInfo->dwUsedSize);

    RasTapiTrace("RasTapiCallback: dwCallerIDOffset=%d",
                 pLineCallInfo->dwCallerIDOffset);

    RasTapiTrace("RasTapiCallback: dwCalledIdOffset=%d",
                 pLineCallInfo->dwCalledIDOffset);

    RasTapiTrace("RasTapiCallback: dwCallerIdSize=%d",
                 pLineCallInfo->dwCallerIDSize);

    RasTapiTrace("RasTapiCallback: dwCalledIdSize=%d",
                 pLineCallInfo->dwCalledIDSize);

    RasTapiTrace("RasTapiCallback: dwCallerIdNameSize=%d",
                 pLineCallInfo->dwCallerIDNameSize);

    RasTapiTrace("RasTapiCallback: dwCallerIdNameOffset=%d",
                 pLineCallInfo->dwCallerIDNameOffset);
#endif

    //
    // Find the size of the buffer to allocate
    //
    if(pLineCallInfo->dwCallerIDFlags & LINECALLPARTYID_ADDRESS)
    {
        dwRequiredSize += pLineCallInfo->dwCallerIDSize;
    }

    if(pLineCallInfo->dwCalledIDFlags & LINECALLPARTYID_ADDRESS)
    {
        dwRequiredSize += pLineCallInfo->dwCalledIDSize;
    }

    if(     (NULL == pConnectInfo)
        ||  (0 == dwRequiredSize))
    {
        goto done;
    }

    //
    // If pConnectInfo is != NULL it is assumed
    // that the buffer is large enough to put
    // the CALLER/CALLED ID information in it.
    //
    if(     (   pLineCallInfo->dwCallerIDFlags
            &   LINECALLPARTYID_ADDRESS )
        &&  pLineCallInfo->dwCallerIDSize)
    {

        //
        // Copy the caller id information
        //
        pConnectInfo->dwCallerIdSize =
            pLineCallInfo->dwCallerIDSize;

        pConnectInfo->dwCallerIdOffset =
                    FIELD_OFFSET(RASTAPI_CONNECT_INFO, abdata);

        memcpy(  pConnectInfo->abdata,

                 (PBYTE) ((PBYTE) pLineCallInfo
               + pLineCallInfo->dwCallerIDOffset),

               pLineCallInfo->dwCallerIDSize);
    }
    else
    {
        RasTapiTrace("RasTapiCallback: caller id "
                     "info. not avail");

    }

    if(     (   pLineCallInfo->dwCalledIDFlags
            &   LINECALLPARTYID_ADDRESS)
        &&  pLineCallInfo->dwCalledIDSize)
    {

        //
        // Copy the called id information
        //
        pConnectInfo->dwCalledIdSize =
                pLineCallInfo->dwCalledIDSize;

        pConnectInfo->dwCalledIdOffset =
                FIELD_OFFSET(RASTAPI_CONNECT_INFO, abdata)
              + pConnectInfo->dwCallerIdSize;

        memcpy(  (PBYTE)
                 ((PBYTE) pConnectInfo
               + pConnectInfo->dwCalledIdOffset),

                 (PBYTE) ((PBYTE) pLineCallInfo
               + pLineCallInfo->dwCalledIDOffset),

               pLineCallInfo->dwCalledIDSize);
    }
    else
    {
        RasTapiTrace("RasTapiCallback: called id "
                     "info. not avail");
    }

done:

    if(pdwRequiredSize)
    {
        *pdwRequiredSize = dwRequiredSize;
    }

    RasTapiTrace("DwGetIDInformation. %d", dwErr);

    return dwErr;
}



/*++

Routine Description:

    Extract the connect responses from lpLineDiagnostics(see
    MODEM_KEYTYPE_AT_COMMAND_RESPONSE,MODEMDIAGKEY_ATRESP_CONNECT)
    and copy them in lpBuffer

Arguments:

    lpLineDiagnostics - diagnostic structure

    lpBuffer - destination buffer (can be NULL), upon
               return contains null terminated ASCII
               strings

    dwBufferSize - size in bytes of the buffer pointed
                   by lpBuffer

    lpdwNeededSize - pointer (can be NULL) to a dword to
                     receive the needed size

Return Value:

    Returns the number of bytes copied into lpBuffer

--*/
DWORD
DwGetConnectResponses(
    LINEDIAGNOSTICS *lpLineDiagnostics,
    LPBYTE          lpBuffer,
    DWORD           dwBufferSize,
    LPDWORD         lpdwNeededSize
    )
{
    DWORD dwBytesCopied;

    DWORD dwNeededSize;

    LINEDIAGNOSTICS *lpstructDiagnostics;

    RasTapiTrace("DwGetConnectresponses");

    dwBytesCopied   = 0;
    dwNeededSize    = 0;

    lpstructDiagnostics = lpLineDiagnostics;

    while (NULL != lpstructDiagnostics)
    {
        LINEDIAGNOSTICS_PARSEREC    *lpParsedDiagnostics;

        LINEDIAGNOSTICSOBJECTHEADER *lpParsedHeader;

        DWORD                       dwNumItems;

        DWORD                       dwIndex;

        //
        // check the signature for modem diagnostics
        //
        lpParsedHeader = PARSEDDIAGNOSTICS_HDR(lpstructDiagnostics);

        if (    (lpstructDiagnostics->hdr.dwSig
                    != LDSIG_LINEDIAGNOSTICS)

            ||  (lpstructDiagnostics->dwDomainID
                    != DOMAINID_MODEM)

            ||  !IS_VALID_PARSEDDIAGNOSTICS_HDR(lpParsedHeader))
        {
            goto NextStructure;
        }

        //
        // get parsed structure info
        //
        dwNumItems  = PARSEDDIAGNOSTICS_NUM_ITEMS(lpParsedHeader);

        lpParsedDiagnostics = PARSEDDIAGNOSTICS_DATA(lpstructDiagnostics);

        //
        // iterate the array of LINEDIAGNOSTICS_PARSERECs
        //
        for (dwIndex = 0; dwIndex < dwNumItems; dwIndex++)
        {
            DWORD dwThisLength;

            LPSTR lpszThisString;

            //
            //  check is a connect response
            //
            if (    (lpParsedDiagnostics[dwIndex].dwKeyType !=
                        MODEM_KEYTYPE_AT_COMMAND_RESPONSE)

                ||  (lpParsedDiagnostics[dwIndex].dwKey !=
                        MODEMDIAGKEY_ATRESP_CONNECT)

                ||  !(lpParsedDiagnostics[dwIndex].dwFlags &
                    fPARSEKEYVALUE_ASCIIZ_STRING))
            {
                continue;
            }

            //
            // get the string, dwValue offset from the beginning
            // of lpParsedDiagnostics
            //
            lpszThisString  = (LPSTR) ( (LPBYTE) lpParsedHeader +
                                lpParsedDiagnostics[dwIndex].dwValue);

            dwThisLength = strlen(lpszThisString) + 1;

            if (dwThisLength == 1)
            {
                continue;
            }

            //
            //  update needed size
            //
            dwNeededSize += dwThisLength;

            //
            //  copy to buffer, if large enough
            //
            if (    NULL != lpBuffer
                &&  dwBytesCopied < dwBufferSize - 1)
            {
                DWORD dwBytesToCopy;

                //
                //  dwThisLength includes null char, so
                //  does dwBytesToCopy
                //
                dwBytesToCopy = min(dwThisLength,
                                      dwBufferSize
                                    - 1
                                    - dwBytesCopied);

                if (dwBytesToCopy > 1)
                {
                    memcpy(lpBuffer + dwBytesCopied,
                            lpszThisString,
                            dwBytesToCopy - 1);

                    lpBuffer[dwBytesCopied + dwBytesToCopy - 1] = 0;

                    dwBytesCopied += dwBytesToCopy;
                }
            }
        }

NextStructure:

        if (lpstructDiagnostics->hdr.dwNextObjectOffset != 0)
        {
            lpstructDiagnostics = (LINEDIAGNOSTICS *)
                    (((LPBYTE) lpstructDiagnostics) +
                        lpstructDiagnostics->hdr.dwNextObjectOffset);
        }
        else
        {
            lpstructDiagnostics = NULL;
        }
    }

    //
    //  the final null only if data is not empty
    //
    if (dwNeededSize > 0)
    {
        dwNeededSize++;

        if (    lpBuffer != NULL
            &&  dwBytesCopied < dwBufferSize)
        {
            lpBuffer[dwBytesCopied] = 0;

            dwBytesCopied++;
        }
    }

    if (lpdwNeededSize != NULL)
    {
        *lpdwNeededSize = dwNeededSize;
    }

    RasTapiTrace("DwGetConnectResponses done");

    return dwBytesCopied;
}

/*++

Routine Description:

    Extract the connect response information

Arguments:

    pLineCallInfo - the LINECALLINFO associated with
                    this call

    hCall - handle to call

    pdwRequiredSize - This is in/out parameter. As IN it
                      specifies the size of pBuffer. As
                      OUT it contains the size required
                      to store the connect response.

    pBuffer - buffer to receive the connect response. This
              can be NULL.

Return Value:

    ERROR_SUCCESS if successful

--*/
DWORD
DwGetConnectResponseInformation(
                LINECALLINFO *pLineCallInfo,
                HCALL        hCall,
                DWORD        *pdwRequiredSize,
                BYTE         *pBuffer
                )
{
    LONG lr = ERROR_SUCCESS;

    BYTE bvar[100];

    LPVARSTRING pvar = (LPVARSTRING) bvar;

    LINEDIAGNOSTICS *pLineDiagnostics;

    DWORD dwConnectResponseSize = 0;

    RasTapiTrace("DwGetConnectResponseInformation");

    //
    // Get the diagnostics information
    //
    ZeroMemory (pvar, sizeof(*pvar));
    pvar->dwTotalSize = sizeof(bvar);

    lr = lineGetID(
            pLineCallInfo->hLine,
            pLineCallInfo->dwAddressID,
            hCall,
            LINECALLSELECT_CALL,
            pvar,
            szUMDEVCLASS_TAPI_LINE_DIAGNOSTICS);

    if(     (LINEERR_STRUCTURETOOSMALL == lr)
        ||  pvar->dwNeededSize > sizeof(bvar))
    {
        DWORD dwNeededSize = pvar->dwNeededSize;

        //
        // Allocate the required size
        //
        pvar = LocalAlloc(
                    LPTR,
                    dwNeededSize);

        if(NULL == pvar)
        {
            lr = (LONG) GetLastError();
            goto done;
        }

        ZeroMemory (pvar, sizeof(*pvar));
        pvar->dwTotalSize = dwNeededSize;

        lr = lineGetID(
                pLineCallInfo->hLine,
                pLineCallInfo->dwAddressID,
                hCall,
                LINECALLSELECT_CALL,
                pvar,
                szUMDEVCLASS_TAPI_LINE_DIAGNOSTICS);

        if(ERROR_SUCCESS != lr)
        {
            goto done;
        }
    }
    else if(ERROR_SUCCESS != lr)
    {
        goto done;
    }

    pLineDiagnostics = (LINEDIAGNOSTICS *) ((LPBYTE) pvar
                     + pvar->dwStringOffset);


    (void) DwGetConnectResponses(
                        pLineDiagnostics,
                        pBuffer,
                        *pdwRequiredSize,
                        &dwConnectResponseSize);

done:

    if(bvar != (LPBYTE) pvar)
    {
        LocalFree(pvar);
    }

    *pdwRequiredSize = dwConnectResponseSize;

    RasTapiTrace("DwGetConnectResponseInformation. 0x%x",
                 lr);

    return (DWORD) lr;
}

/*++

Routine Description:

    Extract the connection information. This includes
    extracing the caller id / called id information
    and the connect response information for modems.

Arguments:

    port - pointer to the rastapi port on which the
           call came in / was made

    hCall - handle to call

    pLineCallInfo - pointer to the LINECALLINFO structure
                    associated with this call.

Return Value:

    ERROR_SUCCESS if succcessful

--*/
DWORD
DwGetConnectInfo(
    TapiPortControlBlock *port,
    HCALL                hCall,
    LINECALLINFO         *pLineCallInfo
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    DWORD dwRequiredSize = 0;

    DWORD dwConnectResponseSize = 0;

    RASTAPI_CONNECT_INFO *pConnectInfo = NULL;

    RasTapiTrace("DwGetConnectInfo");

    //
    // Get the size required to store the
    // caller/called id information
    //
    dwErr = DwGetIDInformation(port,
                               pLineCallInfo,
                               &dwRequiredSize,
                               NULL);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    RasTapiTrace("SizeRequired for CallID=%d",
                 dwRequiredSize);

    if(0 == _stricmp(port->TPCB_DeviceType, "modem"))
    {
        //
        // Get the size required to store connect
        // response if this is a modem
        //
        dwErr = DwGetConnectResponseInformation(
                    pLineCallInfo,
                    hCall,
                    &dwConnectResponseSize,
                    NULL);

        if(NO_ERROR != dwErr)
        {
            goto done;
        }

        RasTapiTrace("SizeRequired for ConnectResponse=%d",
                     dwConnectResponseSize);
    }

    if(0 == (dwRequiredSize + dwConnectResponseSize))
    {
        //
        // None of the information is available.
        // bail.
        //
        RasTapiTrace("CallIDSize=ConnectResponseSize=0");
        goto done;
    }

    dwRequiredSize += (  dwConnectResponseSize
                       + sizeof(RASTAPI_CONNECT_INFO));


    //
    // Allocate the buffer
    //
    pConnectInfo = (RASTAPI_CONNECT_INFO *) LocalAlloc(
                                    LPTR,
                                    dwRequiredSize);

    if(NULL == pConnectInfo)
    {
        dwErr = GetLastError();
        goto done;
    }

    //
    // Get the actual information
    //
    dwErr = DwGetIDInformation(
                    port,
                    pLineCallInfo,
                    NULL,
                    pConnectInfo);

    if(NO_ERROR != dwErr)
    {
        goto done;
    }

    //
    // Get Connect response if its a modem
    //
    if(0 == _stricmp(port->TPCB_DeviceType, "modem"))
    {

        pConnectInfo->dwConnectResponseOffset =
                        FIELD_OFFSET(RASTAPI_CONNECT_INFO, abdata)
                      + pConnectInfo->dwCallerIdSize
                      + pConnectInfo->dwCalledIdSize;

        pConnectInfo->dwConnectResponseSize =
                            dwConnectResponseSize;

        dwErr = DwGetConnectResponseInformation(
                    pLineCallInfo,
                    hCall,
                    &dwConnectResponseSize,
                    (PBYTE) ((PBYTE) pConnectInfo
                    + pConnectInfo->dwConnectResponseOffset));

        if(ERROR_SUCCESS != dwErr)
        {
            goto done;
        }
    }

    port->TPCB_pConnectInfo = pConnectInfo;

done:

    if(     NO_ERROR != dwErr
        &&  NULL != pConnectInfo)
    {
        LocalFree(pConnectInfo);
    }

    RasTapiTrace("DwGetConnectInfo. 0x%x",
                 dwErr);

    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\inc\serial.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: serial.h
//
//  Revision History:
//
//  July 27, 1992   Gurdeep Pall Created
//
//
//  Description: This file contains name strings for standard parameter
//               names used for serial Media.
//
//****************************************************************************


#ifndef _SERIALDLLINCLUDE_
#define _SERIALDLLINCLUDE_


//  General Defines  *********************************************************
//

#define MAX_BPS_STR_LEN     11  //Longest string from a DWORD + zero byte

#define SERIAL_TXT          "serial"


//  Serial.ini File Defines  *************************************************
//

#define SER_MAXCONNECTBPS_KEY   "MAXCONNECTBPS"
#define SER_MAXCARRIERBPS_KEY   "MAXCARRIERBPS"
#define SER_INITBPS_KEY         "INITIALBPS"

#define SER_DEVICETYPE_KEY      "DEVICETYPE"
#define SER_DEVICENAME_KEY      "DEVICENAME"

#define SER_USAGE_KEY           "USAGE"
#define SER_USAGE_VALUE_CLIENT  "Client"
#define SER_USAGE_VALUE_SERVER  "Server"
#define SER_USAGE_VALUE_BOTH    "ClientAndServer"
#define SER_USAGE_VALUE_NONE    "None"

#define SER_DEFAULTOFF_KEY      "DEFAULTOFF"
#define SER_C_DEFAULTOFF_KEY    "CLIENT_DEFAULTOFF"


//  PortGetInfo and PortSetInfo Defines  *************************************
//

#define SER_PORTNAME_KEY        "PortName"
#define SER_CONNECTBPS_KEY      "ConnectBPS"
#define SER_DATABITS_KEY        "WordSize"

#define SER_PARITY_KEY          "Parity"
#define SER_STOPBITS_KEY        "StopBits"
#define SER_HDWFLOWCTRLON_KEY   "HdwFlowControlEnabled"

#define SER_CARRIERBPS_KEY      "CarrierBPS"
#define SER_ERRORCONTROLON_KEY  "ErrorControlEnabled"
#define SER_DEFAULTOFFSTR_KEY   "DEFAULTOFF"
#define SER_C_DEFAULTOFFSTR_KEY "CLIENT_DEFAULTOFF"

#define SER_PORTOPEN_KEY        "PortOpenFlag"


//  Statistics Indicies  *****************************************************
//

#define NUM_RAS_SERIAL_STATS    14

#define BYTES_XMITED            0       //Generic Stats
#define BYTES_RCVED             1
#define FRAMES_XMITED           2
#define FRAMES_RCVED            3

#define CRC_ERR                 4       //Serial Stats
#define TIMEOUT_ERR             5
#define ALIGNMENT_ERR           6
#define SERIAL_OVERRUN_ERR      7
#define FRAMING_ERR             8
#define BUFFER_OVERRUN_ERR      9

#define BYTES_XMITED_UNCOMP     10      //Compression Stats
#define BYTES_RCVED_UNCOMP      11
#define BYTES_XMITED_COMP       12
#define BYTES_RCVED_COMP        13



#endif // _SERIALDLLINCLUDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\rastapi\rastapi.c ===
//****************************************************************************
//
//                  Terminal Server CDmodem
//
//
// Copyright 1996, Citrix Systems Inc.
// Copyright (C) 1994-95 Microsft Corporation. All rights reserved.
//
//  Filename: rastapi.c
//
//  Revision History
//
//  November 1998  updated by Qunbiao Guo for terminal server
//  Mar  28 1992   Gurdeep Singh Pall  Created
//
//
//  Description: This file contains tapi codes for cdmodem.dll
//
//****************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <tapi.h>
#include <rasndis.h>
#include <wanioctl.h>
#include <rasman.h>
#include <raserror.h>
#include <eventlog.h>

#include <media.h>
#include <device.h>
#include <rasmxs.h>
#include <isdn.h>
#include <serial.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include "rastapi.h"

#ifdef CITRIX
#include <winstaw.h>
#include <icadd.h>
#include <icaapi.h>
#include "cdmodem.h"
#endif // CITRIX

#ifdef CITRIX
#ifdef DBG
#define DBGPRINT(_arg) DbgPrint _arg
#else
#define DBGPRINT(_arg) { }
#endif
#endif // CITRIX

#pragma warning (error:4312)

extern DWORD       TotalPorts ;
extern HLINEAPP       RasLine ;
extern HINSTANCE    RasInstance ;
extern TapiLineInfo *RasTapiLineInfo ;
extern TapiPortControlBlock *RasPorts ;
extern TapiPortControlBlock *RasPortsEnd ;
extern HANDLE      RasTapiMutex ;
extern BOOL     Initialized ;
extern DWORD       TapiThreadId    ;
extern HANDLE      TapiThreadHandle;
extern DWORD       LoaderThreadId;
extern DWORD       ValidPorts;
extern HANDLE     ghAsyMac ;


DWORD GetInfo (TapiPortControlBlock *, BYTE *, WORD *) ;
DWORD SetInfo (TapiPortControlBlock *, RASMAN_PORTINFO *) ;
DWORD GetGenericParams (TapiPortControlBlock *, RASMAN_PORTINFO *, PWORD) ;
DWORD GetIsdnParams (TapiPortControlBlock *, RASMAN_PORTINFO * , PWORD) ;
DWORD GetX25Params (TapiPortControlBlock *, RASMAN_PORTINFO *, PWORD) ;
DWORD FillInX25Params (TapiPortControlBlock *, RASMAN_PORTINFO *) ;
DWORD FillInIsdnParams (TapiPortControlBlock *, RASMAN_PORTINFO *) ;
DWORD FillInGenericParams (TapiPortControlBlock *, RASMAN_PORTINFO *) ;
DWORD FillInUnimodemParams (TapiPortControlBlock *, RASMAN_PORTINFO *) ;
VOID  SetModemParams (TapiPortControlBlock *hIOPort, LINECALLPARAMS *linecallparams) ;
DWORD InitiatePortDisconnection (TapiPortControlBlock *hIOPort) ;
TapiPortControlBlock *LookUpControlBlock (HANDLE hPort) ;
DWORD ValueToNum(RAS_PARAMS *p) ;




//*  Serial APIs  ************************************************************
//


//*  PortEnum  ---------------------------------------------------------------
//
// Function: This API returns a buffer containing a PortMediaInfo struct.
//
// Returns: SUCCESS
//          ERROR_BUFFER_TOO_SMALL
//          ERROR_READING_SECTIONNAME
//          ERROR_READING_DEVICETYPE
//          ERROR_READING_DEVICENAME
//          ERROR_READING_USAGE
//          ERROR_BAD_USAGE_IN_INI_FILE
//
//*

DWORD  APIENTRY
PortEnum(PCDMODEM pCdModem, BYTE *pBuffer, WORD *pwSize, WORD *pwNumPorts)
{
    PortMediaInfo *pinfo ;
    TapiPortControlBlock *pports ;
    DWORD numports = 0;
    DWORD i ;

    DBGPRINT(( "CDMODEM: PortEnum: Entry\n" ));

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;
    DBGPRINT(( "CDMODEM: PortEnum: Lock obtained\n" ));


    if (!Initialized) {
      HANDLE   event;

        LoaderThreadId = GetCurrentThreadId();

        event = CreateEvent (NULL, FALSE, FALSE, NULL) ;
        TapiThreadHandle = CreateThread (NULL, 5000, (LPTHREAD_START_ROUTINE) EnumerateTapiPorts,
            (LPVOID) event,
            0,
            &TapiThreadId);


        DBGPRINT(( "CDMODEM: PortEnum: waiting for ETP thread..." ));
        IcaCdWaitForSingleObject (pCdModem->hStack, event, INFINITE) ;
        DBGPRINT(( "complete\n" ));

        if (RasLine == 0 || !ValidPorts) {

         //
         // Wait for the thread to go away!
         //

        DBGPRINT(( "CDMODEM: PortEnum: ETP didn't init waitin..." ));
        IcaCdWaitForSingleObject(pCdModem->hStack, TapiThreadHandle, INFINITE);
        DBGPRINT(( "complete\n" ));

        CloseHandle (TapiThreadHandle) ;

            // *** Exclusion End ***
        FreeMutex (RasTapiMutex) ;
        return ERROR_TAPI_CONFIGURATION ;
        }

        CloseHandle (event) ;

       Initialized = TRUE ;
    }

    DBGPRINT(( "CDMODEM: PortEnum: TAPI init complete\n" ));
    // calculate the number of valid ports
    //
    for (pports = RasPorts, i=0; i < TotalPorts; i++, pports++) {
       if (pports->TPCB_State == PS_UNINITIALIZED)
           continue ;
       numports++ ;
    }


    if (*pwSize < numports*sizeof(PortMediaInfo)) {

   *pwNumPorts = (WORD) numports ;
   *pwSize = (WORD) *pwNumPorts*sizeof(PortMediaInfo) ;

   // *** Exclusion End ***
   FreeMutex (RasTapiMutex) ;
   return ERROR_BUFFER_TOO_SMALL ;
    }

    *pwNumPorts = 0 ;
    pinfo = (PortMediaInfo *)pBuffer ;

    for (pports = RasPorts, i=0; i < TotalPorts; i++, pports++) {

   if (pports->TPCB_State  == PS_UNINITIALIZED)
       continue ;

   strcpy (pinfo->PMI_Name, pports->TPCB_Name) ;
   pinfo->PMI_Usage = pports->TPCB_Usage ;
   strcpy (pinfo->PMI_DeviceType, pports->TPCB_DeviceType) ;
   strcpy (pinfo->PMI_DeviceName, pports->TPCB_DeviceName) ;
    pinfo->PMI_LineDeviceId = pports->TPCB_Line->TLI_LineId;
    pinfo->PMI_AddressId = pports->TPCB_AddressId;

   pinfo++ ;
   (*pwNumPorts)++   ;
    }

    // *** Exclusion End ***
    FreeMutex (RasTapiMutex) ;

    return(SUCCESS);
}



//*  PortOpen  ---------------------------------------------------------------
//
// Function: This API opens a COM port.  It takes the port name in ASCIIZ
//           form and supplies a handle to the open port.  hNotify is use
//           to notify the caller if the device on the port shuts down.
//
//           PortOpen allocates a SerialPCB and places it at the head of
//           the linked list of Serial Port Control Blocks.
//
// Returns: SUCCESS
//          ERROR_PORT_NOT_CONFIGURED
//          ERROR_DEVICE_NOT_READY
//
//*

DWORD  APIENTRY
PortOpen(char *pszPortName, HANDLE *phIOPort, HANDLE hNotify)
{
    TapiPortControlBlock *pports ;
    DWORD   retcode ;
    DWORD   i ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    pports = RasPorts ;

    for (i=0; i < TotalPorts; i++) {
   if (_stricmp(pszPortName, pports->TPCB_Name) == 0)
       break ;
   pports++ ;
    }

    if (i < TotalPorts) {

       if (pports->TPCB_State == PS_UNINITIALIZED) {
           // **** Exclusion END ****
           FreeMutex (RasTapiMutex) ;
           return ERROR_TAPI_CONFIGURATION ;
       }

       if (pports->TPCB_State != PS_CLOSED) {
           // **** Exclusion END ****
           FreeMutex (RasTapiMutex) ;
           return ERROR_PORT_ALREADY_OPEN ;
       }

       if (pports->TPCB_Line->TLI_LineState == PS_CLOSED) { // open line
            LINEDEVCAPS     *linedevcaps ;
            BYTE            buffer[400] ;

            linedevcaps = (LINEDEVCAPS *)buffer ;
            linedevcaps->dwTotalSize = sizeof (buffer) ;

            lineGetDevCaps (RasLine, pports->TPCB_Line->TLI_LineId, pports->TPCB_Line->NegotiatedApiVersion, pports->TPCB_Line->NegotiatedExtVersion, linedevcaps) ;

            // Remove LINEMEDIAMODE_INTERACTIVEVOICE from the media mode since this mode cannot be
            // used for receiving calls.
            //
            pports->TPCB_MediaMode = linedevcaps->dwMediaModes & ~(LINEMEDIAMODE_INTERACTIVEVOICE) ;

       retcode =
            lineOpen (RasLine,
                pports->TPCB_Line->TLI_LineId,
                &pports->TPCB_Line->TLI_LineHandle,
                pports->TPCB_Line->NegotiatedApiVersion,
                pports->TPCB_Line->NegotiatedExtVersion,
                (ULONG) (ULONG_PTR)pports->TPCB_Line,
                LINECALLPRIVILEGE_OWNER,
                pports->TPCB_MediaMode,
                NULL) ;

           if (retcode) {

          // **** Exclusion END ****
          FreeMutex (RasTapiMutex) ;
          return retcode ;
           }

      //
      // Set monitoring of rings
      //
      lineSetStatusMessages (pports->TPCB_Line->TLI_LineHandle, LINEDEVSTATE_RINGING, 0) ;

      //
      //  Always turn off the modem lights incase this is a modem device
      //
      if ((_stricmp (pports->TPCB_DeviceType, DEVICETYPE_UNIMODEM) == 0)) {

          //
          // unimodem struct not defined in any header
          //
          typedef struct _DEVCFG {
         DWORD dwSize;
         DWORD dwVersion;
         WORD  fwOptions;
         WORD  wWaitBong;
          } DEVCFG;

#define LAUNCH_LIGHTS 8

          LPVARSTRING var ;
          BYTE buffer[1000] ;
          DEVCFG  *devcfg ;

          var = (LPVARSTRING)buffer ;
          var->dwTotalSize  = 1000 ;
          var->dwStringSize = 0 ;
          lineGetDevConfig (pports->TPCB_Line->TLI_LineId, var, "comm/datamodem") ;
          devcfg = (DEVCFG*) (((LPBYTE) var) + var->dwStringOffset) ;
          devcfg->fwOptions &= ~LAUNCH_LIGHTS ;

          lineSetDevConfig (pports->TPCB_Line->TLI_LineId, devcfg, var->dwStringSize, "comm/datamodem") ;

      }

           pports->TPCB_Line->TLI_LineState = PS_OPEN ;
       }

       // Initialize the parameters
       //
       pports->TPCB_Info[0][0] = '\0' ;
       pports->TPCB_Info[1][0] = '\0' ;
       pports->TPCB_Info[2][0] = '\0' ;
       pports->TPCB_Info[3][0] = '\0' ;
       pports->TPCB_Info[4][0] = '\0' ;
       strcpy (pports->TPCB_Info[ISDN_CONNECTBPS_INDEX], "64000") ;

       pports->TPCB_Line->TLI_OpenCount++ ;
       pports->TPCB_DiscNotificationHandle = hNotify ;

       // DbgPrint ("RASTAPI: TPCB_DiscNotificationHandle == %x\n", pports->TPCB_DiscNotificationHandle) ;

       pports->TPCB_State = PS_OPEN ;
       pports->TPCB_DisconnectReason = 0 ;
       pports->TPCB_CommHandle = INVALID_HANDLE_VALUE ;

       *phIOPort = (HANDLE) pports ;

       // **** Exclusion END ****
       FreeMutex (RasTapiMutex) ;

       return(SUCCESS);

    }

   // **** Exclusion END ****
   FreeMutex (RasTapiMutex) ;

   return ERROR_PORT_NOT_CONFIGURED ;


}


//*  PortClose  --------------------------------------------------------------
//
// Function: This API closes the COM port for the input handle.  It also
//           finds the SerialPCB for the input handle, removes it from
//           the linked list, and frees the memory for it
//
// Returns: SUCCESS
//          Values returned by GetLastError()
//
//*

DWORD  APIENTRY
PortClose (HANDLE hIOPort)
{
    TapiPortControlBlock *pports = (TapiPortControlBlock *) hIOPort ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    pports->TPCB_Line->TLI_OpenCount-- ;
    pports->TPCB_State = PS_CLOSED ;

    if (pports->TPCB_DevConfig)
        LocalFree (pports->TPCB_DevConfig) ;
    pports->TPCB_DevConfig = NULL ;

    if (pports->TPCB_Line->TLI_OpenCount == 0) {
       pports->TPCB_Line->TLI_LineState = PS_CLOSED ;
       lineClose (pports->TPCB_Line->TLI_LineHandle) ;
    }

    // **** Exclusion END ****
    FreeMutex (RasTapiMutex) ;

    return(SUCCESS);
}


//*  PortGetInfo  ------------------------------------------------------------
//
// Function: This API returns a block of information to the caller about
//           the port state.  This API may be called before the port is
//           open in which case it will return inital default values
//           instead of actual port values.
//
//           hIOPort can be null in which case use portname to give information
//           hIOPort may be the actual file handle or the hIOPort returned in port open.
//
// Returns: SUCCESS
//
//*

DWORD  APIENTRY
PortGetInfo(HANDLE hIOPort, CHAR *pszPortName, BYTE *pBuffer, WORD *pwSize)
{
    DWORD i ;
    DWORD retcode = ERROR_FROM_DEVICE ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    // hIOPort or pszPortName must be valid:
    //
    for (i=0; i < TotalPorts; i++) {
       if (!_stricmp(RasPorts[i].TPCB_Name, pszPortName) || (hIOPort == (HANDLE) &RasPorts[i]) || (hIOPort == RasPorts[i].TPCB_CommHandle)) {
           hIOPort = (HANDLE) &RasPorts[i] ;
           retcode = GetInfo ((TapiPortControlBlock *) hIOPort, pBuffer, pwSize) ;
           break ;
       }
    }

    // **** Exclusion END ****
    FreeMutex (RasTapiMutex) ;

    return (retcode);
}



//*  PortSetInfo  ------------------------------------------------------------
//
// Function: The values for most input keys are used to set the port
//           parameters directly.  However, the carrier BPS and the
//           error conrol on flag set fields in the Serial Port Control
//           Block only, and not the port.
//
//           hIOPort may the port handle returned in portopen or the actual file handle.
//
// Returns: SUCCESS
//          ERROR_WRONG_INFO_SPECIFIED
//          Values returned by GetLastError()
//*

DWORD  APIENTRY
PortSetInfo(HANDLE hIOPort, RASMAN_PORTINFO *pInfo)
{
    DWORD retcode = ERROR_WRONG_INFO_SPECIFIED ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    if (hIOPort = LookUpControlBlock(hIOPort)) {

        retcode = SetInfo ((TapiPortControlBlock *) hIOPort, pInfo) ;

    }

    // **** Exclusion END ****
    FreeMutex (RasTapiMutex) ;

    return (retcode);
}


//*  PortTestSignalState  ----------------------------------------------------
//
// Function: Really only has meaning if the call was active. Will return
//
// Returns: SUCCESS
//          Values returned by GetLastError()
//
//*

DWORD  APIENTRY
PortTestSignalState(HANDLE hPort, DWORD *pdwDeviceState)
{
    BYTE    buffer[200] ;
    LINECALLSTATUS *pcallstatus ;
    DWORD   retcode = SUCCESS ;
    TapiPortControlBlock *hIOPort = (TapiPortControlBlock *) hPort;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    *pdwDeviceState = 0 ;

    memset (buffer, 0, sizeof(buffer)) ;

    pcallstatus = (LINECALLSTATUS *) buffer ;
    pcallstatus->dwTotalSize = sizeof (buffer) ;

    // First check if we have a disconnect reason stored away. if so return that.
    //
    if (hIOPort->TPCB_DisconnectReason) {

        *pdwDeviceState = hIOPort->TPCB_DisconnectReason ;

    } else if (hIOPort->TPCB_State != PS_CLOSED) {

        // Only in case of CONNECTING or CONNECTED do we care how the link dropped
        //
        if (hIOPort->TPCB_State == PS_CONNECTING || hIOPort->TPCB_State == PS_CONNECTED) {

           retcode = lineGetCallStatus (hIOPort->TPCB_CallHandle, pcallstatus) ;

           if (retcode)
             ;
           else if (pcallstatus->dwCallState == LINECALLSTATE_DISCONNECTED)
             *pdwDeviceState = SS_LINKDROPPED ;
           else if (pcallstatus->dwCallState == LINECALLSTATE_IDLE)
              *pdwDeviceState = SS_HARDWAREFAILURE ;
           else if (pcallstatus->dwCallState == LINECALLSTATE_SPECIALINFO)
              *pdwDeviceState = SS_HARDWAREFAILURE ;

        } else

            *pdwDeviceState = SS_LINKDROPPED | SS_HARDWAREFAILURE ;
    }

    // **** Exclusion END ****
    FreeMutex (RasTapiMutex) ;
    return retcode ;
}




//*  PortDisconnect  ---------------------------------------------------------
//
// Function: This API is called to drop a connection and close AsyncMac.
//
// Returns: SUCCESS
//          PENDING
//          ERROR_PORT_NOT_OPEN
//
//*
DWORD  APIENTRY
PortDisconnect(HANDLE hPort)
{
    DWORD retcode = SUCCESS ;
    TapiPortControlBlock *hIOPort = (TapiPortControlBlock *) hPort;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    // DbgPrint ("PortDisconnect, state = %d\n", hIOPort->TPCB_State) ;

    if ((hIOPort->TPCB_State == PS_CONNECTED)  ||
   (hIOPort->TPCB_State == PS_CONNECTING) ||
   ((hIOPort->TPCB_State == PS_LISTENING) && (hIOPort->TPCB_ListenState != LS_WAIT))) {

        retcode = InitiatePortDisconnection (hIOPort) ;

        // If we had saved away the device config then we restore it here.
        //
        if (hIOPort->TPCB_DefaultDevConfig) {
            lineSetDevConfig (hIOPort->TPCB_Line->TLI_LineId, hIOPort->TPCB_DefaultDevConfig, hIOPort->TPCB_DefaultDevConfigSize, "comm/datamodem") ;
            LocalFree (hIOPort->TPCB_DefaultDevConfig) ;
            hIOPort->TPCB_DefaultDevConfig = NULL ;
        }


    } else if (hIOPort->TPCB_State == PS_LISTENING) {

      hIOPort->TPCB_State = PS_OPEN ; // for LS_WAIT listen state case
        retcode = SUCCESS ;

    } else if (hIOPort->TPCB_State == PS_DISCONNECTING) {

      retcode = PENDING ;
    }

    // **** Exclusion END ****
    FreeMutex (RasTapiMutex) ;

    return retcode ;
}



//*  PortInit  ---------------------------------------------------------------
//
// Function: This API re-initializes the com port after use.
//
// Returns: SUCCESS
//          ERROR_PORT_NOT_CONFIGURED
//          ERROR_DEVICE_NOT_READY
//
//*

DWORD  APIENTRY
PortInit(HANDLE hIOPort)
{
  return(SUCCESS);
}




//*  PortCompressionSetInfo  -------------------------------------------------
//
// Function: This API selects Asyncmac compression mode by setting
//           Asyncmac's compression bits.
//
// Returns: SUCCESS
//          Return code from GetLastError
//
//*

DWORD
PortCompressionSetInfo(HANDLE hIOPort)
{
  return SUCCESS;
}



//*  PortClearStatistics  ----------------------------------------------------
//
// Function: This API is used to mark the beginning of the period for which
//           statistics will be reported.  The current numbers are copied
//           from the MAC and stored in the Serial Port Control Block.  At
//           the end of the period PortGetStatistics will be called to
//           compute the difference.
//
// Returns: SUCCESS
//          ERROR_PORT_NOT_OPEN
//*

DWORD
PortClearStatistics(HANDLE hIOPort)
{
  return SUCCESS;
}



//*  PortGetStatistics  ------------------------------------------------------
//
// Function: This API reports MAC statistics since the last call to
//           PortClearStatistics.
//
// Returns: SUCCESS
//          ERROR_PORT_NOT_OPEN
//*

DWORD
PortGetStatistics(HANDLE hIOPort, RAS_STATISTICS *pStat)
{

  return(SUCCESS);
}


//*  PortSetFraming  -------------------------------------------------------
//
// Function: Sets the framing type with the mac
//
// Returns: SUCCESS
//
//*
DWORD  APIENTRY
PortSetFraming(HANDLE hIOPort, DWORD SendFeatureBits, DWORD RecvFeatureBits,
         DWORD SendBitMask, DWORD RecvBitMask)
{

    return(SUCCESS);
}



//*  PortGetPortState  -------------------------------------------------------
//
// Function: This API is used in MS-DOS only.
//
// Returns: SUCCESS
//
//*

DWORD  APIENTRY
PortGetPortState(char *pszPortName, DWORD *pdwUsage)
{
  return(SUCCESS);
}





//*  PortChangeCallback  -----------------------------------------------------
//
// Function: This API is used in MS-DOS only.
//
// Returns: SUCCESS
//
//*

DWORD  APIENTRY
PortChangeCallback(HANDLE hIOPort)
{
  return(SUCCESS);
}


//*  PortGetIOHandle()
//
// Function: For the given hIOPort this returns the file handle for the connection
//
// Returns: SUCCESS
//
//*
DWORD  APIENTRY
PortGetIOHandle(HANDLE hPort, HANDLE *FileHandle)
{
    DWORD retcode ;
    TapiPortControlBlock *hIOPort = (TapiPortControlBlock *) hPort;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    if (hIOPort->TPCB_State == PS_CONNECTED) {
        *FileHandle = hIOPort->TPCB_CommHandle ;
        retcode = SUCCESS ;
    } else
        retcode = ERROR_PORT_NOT_OPEN ;

    // **** Exclusion Begin ****
    FreeMutex (RasTapiMutex) ;
    return retcode ;
}


//*  DeviceEnum()  -----------------------------------------------------------
//
// Function: Enumerates all devices in the device INF file for the
//           specified DevictType.
//
// Returns: Return codes from RasDevEnumDevices
//
//*

DWORD APIENTRY
DeviceEnum (char  *pszDeviceType,
            WORD  *pcEntries,
            BYTE  *pBuffer,
            WORD  *pwSize)
{
    *pwSize    = 0 ;
    *pcEntries = 0 ;

    return(SUCCESS);
}



//*  DeviceGetInfo()  --------------------------------------------------------
//
// Function: Returns a summary of current information from the InfoTable
//           for the device on the port in Pcb.
//
// Returns: Return codes from GetDeviceCB, BuildOutputTable
//*

DWORD APIENTRY
DeviceGetInfo(HANDLE hPort,
              char   *pszDeviceType,
              char   *pszDeviceName,
              BYTE   *pInfo,
              WORD   *pwSize)
{
    DWORD retcode ;
    TapiPortControlBlock *hIOPort = LookUpControlBlock(hPort);

    if (!hIOPort)
        return ERROR_PORT_NOT_FOUND ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    retcode = GetInfo (hIOPort, pInfo, pwSize) ;


    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;

    return(retcode);
}



//*  DeviceSetInfo()  --------------------------------------------------------
//
// Function: Sets attributes in the InfoTable for the device on the
//           port in Pcb.
//
// Returns: Return codes from GetDeviceCB, UpdateInfoTable
//*

DWORD APIENTRY
DeviceSetInfo(HANDLE    hPort,
              char              *pszDeviceType,
              char              *pszDeviceName,
              RASMAN_DEVICEINFO *pInfo)
{
    DWORD retcode ;
    TapiPortControlBlock *hIOPort = LookUpControlBlock(hPort);

    if (!hIOPort)
        return ERROR_PORT_NOT_FOUND ;


    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    retcode = SetInfo (hIOPort, (RASMAN_PORTINFO*) pInfo) ;

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;

    return (retcode);
}



//*  DeviceConnect()  --------------------------------------------------------
//
// Function: Initiates the process of connecting a device.
//
// Returns: Return codes from ConnectListen
//*

DWORD APIENTRY
DeviceConnect(HANDLE hPort,
              char   *pszDeviceType,
              char   *pszDeviceName,
              HANDLE hNotifier)
{
    LINECALLPARAMS *linecallparams ;
    LPVARSTRING var ;
    BYTE    buffer [2000] ;
    BYTE    *nextstring ;
    TapiPortControlBlock *hIOPort = LookUpControlBlock(hPort);

    if (!hIOPort)
        return ERROR_PORT_NOT_FOUND ;


    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    // if dev config has been set for this device we should call down and set it.
    //
    if ((hIOPort->TPCB_DevConfig) && (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_UNIMODEM) == 0)) {

        // Before the write this - save away the current setting for the device.
        //
        var = (LPVARSTRING)buffer ;
        var->dwTotalSize  = 2000 ;
        var->dwStringSize = 0 ;
        lineGetDevConfig (hIOPort->TPCB_Line->TLI_LineId, var, "comm/datamodem") ;

        // Alloc mem for the returned info
        //
        hIOPort->TPCB_DefaultDevConfig = LocalAlloc (LPTR, var->dwStringSize) ;

        if (hIOPort->TPCB_DefaultDevConfig == NULL) {
           FreeMutex (RasTapiMutex) ;
           return ERROR_NOT_ENOUGH_MEMORY;
        }

        hIOPort->TPCB_DefaultDevConfigSize = var->dwStringSize ;
        memcpy (hIOPort->TPCB_DefaultDevConfig, (CHAR*)var+var->dwStringOffset, var->dwStringSize) ;

        lineSetDevConfig (hIOPort->TPCB_Line->TLI_LineId, hIOPort->TPCB_DevConfig, hIOPort->TPCB_SizeOfDevConfig, "comm/datamodem") ;

    }

    memset (buffer, 0, sizeof(buffer)) ;
    linecallparams = (LINECALLPARAMS *) buffer ;
    nextstring = (buffer + sizeof (LINECALLPARAMS)) ;
    linecallparams->dwTotalSize = sizeof(buffer) ;

    strcpy (nextstring, hIOPort->TPCB_Address) ;
    linecallparams->dwOrigAddressSize = strlen (nextstring) ;
    linecallparams->dwOrigAddressOffset = (ULONG) (nextstring - buffer) ;

    linecallparams->dwAddressMode = LINEADDRESSMODE_DIALABLEADDR ;

    nextstring += linecallparams->dwOrigAddressSize ;

    if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_ISDN) == 0)
       SetIsdnParams (hIOPort, linecallparams) ;

    else if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_X25) == 0) {

       if (*hIOPort->TPCB_Info[X25_USERDATA_INDEX] != '\0') {

           strcpy (nextstring, hIOPort->TPCB_Info[X25_USERDATA_INDEX]) ;
           linecallparams->dwUserUserInfoSize    = strlen (nextstring) ;
           linecallparams->dwUserUserInfoOffset = (ULONG) (nextstring - buffer) ;
           nextstring += linecallparams->dwUserUserInfoSize ;

       }

       if (*hIOPort->TPCB_Info[X25_FACILITIES_INDEX] != '\0') {

           strcpy (nextstring, hIOPort->TPCB_Info[X25_FACILITIES_INDEX]) ;
           linecallparams->dwDevSpecificSize  = strlen (nextstring) ;
           linecallparams->dwDevSpecificOffset = (ULONG) (nextstring - buffer) ;
           nextstring += linecallparams->dwDevSpecificSize ;
       }

       // Diagnostic key is ignored.

    } else if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_UNIMODEM) == 0) {

       SetModemParams (hIOPort, linecallparams) ;

    }


    hIOPort->TPCB_RequestId = INFINITE ;     // mark request id as unused
    hIOPort->TPCB_CallHandle = (HCALL) INFINITE ;  // set call handle to bogus value
    hIOPort->TPCB_AsyncErrorCode = SUCCESS ; // initialize

    if ((hIOPort->TPCB_RequestId =
       lineMakeCall (hIOPort->TPCB_Line->TLI_LineHandle, &hIOPort->TPCB_CallHandle, hIOPort->TPCB_Info[ADDRESS_INDEX], 0, linecallparams)) > 0x80000000 ) {

   // **** Exclusion End ****
   FreeMutex (RasTapiMutex) ;

   // DbgPrint ("RASTAPI: lineMakeCall failed -> returned %x\n", hIOPort->TPCB_RequestId) ;

   if (hIOPort->TPCB_RequestId == LINEERR_INUSE)
       return ERROR_PORT_NOT_AVAILABLE ;

   return ERROR_FROM_DEVICE ;

    }

    ResetEvent (hNotifier) ;

    hIOPort->TPCB_ReqNotificationHandle = hNotifier ;

    hIOPort->TPCB_State = PS_CONNECTING ;

    hIOPort->TPCB_DisconnectReason = 0 ;

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;

    return (PENDING);
}


//*
//
//
//
//
//*
VOID
SetIsdnParams (TapiPortControlBlock *hIOPort, LINECALLPARAMS *linecallparams)
{
    WORD    numchannels ;
    WORD    fallback ;

#ifndef CITRIX
    // Line type
    //
    if (_stricmp (hIOPort->TPCB_Info[ISDN_LINETYPE_INDEX], ISDN_LINETYPE_STRING_64DATA) == 0) {
   linecallparams->dwBearerMode = LINEBEARERMODE_DATA ;
   linecallparams->dwMinRate = 64000 ;
   linecallparams->dwMaxRate = 64000 ;
   linecallparams->dwMediaMode = LINEMEDIAMODE_DIGITALDATA ;

    } else if (_stricmp (hIOPort->TPCB_Info[ISDN_LINETYPE_INDEX], ISDN_LINETYPE_STRING_56DATA) == 0) {
   linecallparams->dwBearerMode = LINEBEARERMODE_DATA ;
   linecallparams->dwMinRate = 56000 ;
   linecallparams->dwMaxRate = 56000 ;
   linecallparams->dwMediaMode = LINEMEDIAMODE_DIGITALDATA ;

    } else if (_stricmp (hIOPort->TPCB_Info[ISDN_LINETYPE_INDEX], ISDN_LINETYPE_STRING_56VOICE) == 0) {
   linecallparams->dwBearerMode = LINEBEARERMODE_VOICE ;
   linecallparams->dwMinRate = 56000 ;
   linecallparams->dwMaxRate = 56000 ;
   linecallparams->dwMediaMode = LINEMEDIAMODE_UNKNOWN ;
    } else {  // default
   linecallparams->dwBearerMode = LINEBEARERMODE_DATA ;
   linecallparams->dwMinRate = 64000 ;
   linecallparams->dwMaxRate = 64000 ;
   linecallparams->dwMediaMode = LINEMEDIAMODE_DIGITALDATA ;
    }

    if (hIOPort->TPCB_Info[ISDN_CHANNEL_AGG_INDEX][0] != '\0')
   numchannels = atoi(hIOPort->TPCB_Info[ISDN_CHANNEL_AGG_INDEX]) ;
    else
   numchannels = 1 ; // default

    if (hIOPort->TPCB_Info[ISDN_FALLBACK_INDEX] != '\0')
   fallback = atoi(hIOPort->TPCB_Info[ISDN_FALLBACK_INDEX]) ;
    else
   fallback = 1 ;   // default

    if (fallback)
   linecallparams->dwMinRate = 56000 ; // always allow the min
    else
   linecallparams->dwMinRate = numchannels * linecallparams->dwMaxRate ;

    linecallparams->dwMaxRate = numchannels * linecallparams->dwMaxRate ;

#else // CITRIX
    DBGPRINT(("CDMODEM: SetIsdnParams: ISDN not supported\n"));
    ASSERT(FALSE);
#endif // CITRIX

}


//*
//
//
//
//
//*
VOID
SetModemParams (TapiPortControlBlock *hIOPort, LINECALLPARAMS *linecallparams)
{
    WORD    numchannels ;
    WORD    fallback ;
    BYTE    buffer[800] ;
    LINEDEVCAPS     *linedevcaps ;

   memset (buffer, 0, sizeof(buffer)) ;

   linedevcaps = (LINEDEVCAPS *)buffer ;
   linedevcaps->dwTotalSize = sizeof(buffer) ;

   // Get a count of all addresses across all lines
   //
   if (lineGetDevCaps (RasLine, hIOPort->TPCB_Line->TLI_LineId,  hIOPort->TPCB_Line->NegotiatedApiVersion, hIOPort->TPCB_Line->NegotiatedExtVersion, linedevcaps))
        linecallparams->dwBearerMode = LINEBEARERMODE_VOICE ;   // in case of failure try the common case - modems

    if (linedevcaps->dwBearerModes & LINEBEARERMODE_VOICE)
        linecallparams->dwBearerMode = LINEBEARERMODE_VOICE ;
    else
        linecallparams->dwBearerMode = LINEBEARERMODE_DATA ;

    //
    // do not dial without dialtone
    //
    linecallparams->dwCallParamFlags |= LINECALLPARAMFLAGS_IDLE ;

    linecallparams->dwMinRate = 2400 ;
    linecallparams->dwMaxRate = 115200 ;
    linecallparams->dwMediaMode = LINEMEDIAMODE_DATAMODEM ;
}


//*  DeviceListen()  ---------------------------------------------------------
//
// Function: Initiates the process of listening for a remote device
//           to connect to a local device.
//
// Returns: Return codes from ConnectListen
//*

DWORD APIENTRY
DeviceListen(HANDLE hPort,
             char   *pszDeviceType,
             char   *pszDeviceName,
             HANDLE hNotifier)
{
    DWORD retcode ;
    TapiPortControlBlock *hIOPort = LookUpControlBlock(hPort);

    if (!hIOPort)
        return ERROR_PORT_NOT_FOUND ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    // DbgPrint ("DevListen, State = %d\n", hIOPort->TPCB_State) ;

    // If the state is DISCONNECTING (this could happen since rasman waits only 10 seconds
    // for the lower layers to complete a disconnect request), then we have no option but
    // to close and open the line.
    //
    if (hIOPort->TPCB_State == PS_DISCONNECTING) {

   // DbgPrint ("DevListen: Hit code path where device is still disconnecting\n") ;

        lineClose (hIOPort->TPCB_Line->TLI_LineHandle) ;

        Sleep (30L) ;   // allow a "reasonable" time to allow clean up.

        retcode = lineOpen (RasLine,
                     hIOPort->TPCB_Line->TLI_LineId,
                     &hIOPort->TPCB_Line->TLI_LineHandle,
                     hIOPort->TPCB_Line->NegotiatedApiVersion,
                     hIOPort->TPCB_Line->NegotiatedExtVersion,
                     (ULONG) (ULONG_PTR) hIOPort->TPCB_Line,
                     LINECALLPRIVILEGE_OWNER,
                     hIOPort->TPCB_MediaMode,
                     NULL) ;

       if (retcode) {
           // **** Exclusion End ****
           FreeMutex (RasTapiMutex) ;
       // DbgPrint ("DevListen: lineOpen failed with %d \n", retcode) ;
            return ERROR_FROM_DEVICE ;
   }

   //
   // Set monitoring of rings
   //
   lineSetStatusMessages (hIOPort->TPCB_Line->TLI_LineHandle, LINEDEVSTATE_RINGING, 0) ;
    }

    if (hIOPort->TPCB_Line->TLI_LineState != PS_LISTENING)
       hIOPort->TPCB_Line->TLI_LineState = PS_LISTENING ;

    hIOPort->TPCB_State = PS_LISTENING ;
    hIOPort->TPCB_ListenState = LS_WAIT ;
    hIOPort->TPCB_DisconnectReason = 0 ;

    ResetEvent (hNotifier) ;

    hIOPort->TPCB_ReqNotificationHandle = hNotifier ;

    hIOPort->TPCB_CallHandle = (HCALL)(ULONG_PTR)INVALID_HANDLE_VALUE ;

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;

    return (PENDING);
}



//*  DeviceDone()  -----------------------------------------------------------
//
// Function: Informs the device dll that the attempt to connect or listen
//           has completed.
//
// Returns: nothing
//*

VOID APIENTRY
DeviceDone(HANDLE hPort)
{
    TapiPortControlBlock *hIOPort = LookUpControlBlock(hPort);

    if (!hIOPort)
        return ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    hIOPort->TPCB_ReqNotificationHandle = NULL ; // no more needed.

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;

}



//*  DeviceWork()  -----------------------------------------------------------
//
// Function: This function is called following DeviceConnect or
//           DeviceListen to further the asynchronous process of
//           connecting or listening.
//
// Returns: ERROR_DCB_NOT_FOUND
//          ERROR_STATE_MACHINES_NOT_STARTED
//          Return codes from DeviceStateMachine
//*

DWORD APIENTRY
DeviceWork(HANDLE hPort,
           HANDLE hNotifier)
{
    LINECALLSTATUS *callstatus ;
    BYTE    buffer [1000] ;
    DWORD      retcode = ERROR_FROM_DEVICE ;
    TapiPortControlBlock *hIOPort = LookUpControlBlock(hPort);

    if (!hIOPort)
        return ERROR_PORT_NOT_FOUND ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    memset (buffer, 0, sizeof(buffer)) ;

    callstatus = (LINECALLSTATUS *)buffer ;
    callstatus->dwTotalSize = sizeof(buffer) ;

    DBGPRINT(("Devicework enter with ps status: %d \n", hIOPort->TPCB_State));

    if (hIOPort->TPCB_State == PS_CONNECTING) {

       if (hIOPort->TPCB_AsyncErrorCode != SUCCESS) {

      retcode = hIOPort->TPCB_AsyncErrorCode ;
      hIOPort->TPCB_AsyncErrorCode = SUCCESS ;

       } else if (lineGetCallStatus (hIOPort->TPCB_CallHandle, callstatus))
           retcode =  ERROR_FROM_DEVICE ;

       else if (callstatus->dwCallState == LINECALLSTATE_CONNECTED) {
           hIOPort->TPCB_State = PS_CONNECTED ;
           retcode =  SUCCESS ;

       } else if (callstatus->dwCallState == LINECALLSTATE_DISCONNECTED) {
           retcode = ERROR_FROM_DEVICE ;
           if (callstatus->dwCallStateMode == LINEDISCONNECTMODE_BUSY)
               retcode = ERROR_LINE_BUSY ;
           else if (callstatus->dwCallStateMode == LINEDISCONNECTMODE_NOANSWER)
               retcode = ERROR_NO_ANSWER ;
            else if (callstatus->dwCallStateMode == LINEDISCONNECTMODE_CANCELLED)
                retcode = ERROR_USER_DISCONNECTION;

       } else if ((callstatus->dwCallState == LINECALLSTATE_SPECIALINFO) &&
               (callstatus->dwCallStateMode == LINESPECIALINFO_NOCIRCUIT)) {
               retcode = ERROR_NO_ACTIVE_ISDN_LINES ;
       }
    }

    if (hIOPort->TPCB_State == PS_LISTENING) {

       DBGPRINT(("DEvicework PS listning, listeining status: %d \n", hIOPort->TPCB_ListenState));

       if (hIOPort->TPCB_ListenState == LS_ERROR)
           retcode = ERROR_FROM_DEVICE ;

       else if (hIOPort->TPCB_ListenState == LS_ACCEPT) {
           hIOPort->TPCB_RequestId = lineAccept (hIOPort->TPCB_CallHandle, NULL, 0) ;

           DBGPRINT(("Devicework lineAccept return status: 0x%x \n", hIOPort->TPCB_RequestId));
           DBGPRINT(("Devicework: change listening status from LS_ACCEPT to LS_ANSWER \n"));

           if (hIOPort->TPCB_RequestId > 0x80000000 ) // ERROR or SUCCESS
             hIOPort->TPCB_ListenState = LS_ANSWER ;

           else if (hIOPort->TPCB_RequestId == 0)
             hIOPort->TPCB_ListenState = LS_ANSWER ;

           retcode = PENDING ;
       }

       if (hIOPort->TPCB_ListenState == LS_ANSWER) {

           hIOPort->TPCB_RequestId = lineAnswer (hIOPort->TPCB_CallHandle, NULL, 0) ;

           DBGPRINT(("Devicework lineAnswer return status: 0x%x \n",
                     hIOPort->TPCB_RequestId));

           if (hIOPort->TPCB_RequestId > 0x80000000 )
             retcode = ERROR_FROM_DEVICE ;
           else if (hIOPort->TPCB_RequestId)
             retcode = PENDING ;
           else  // SUCCESS
             hIOPort->TPCB_ListenState = LS_COMPLETE ;
       }

       if (hIOPort->TPCB_ListenState == LS_COMPLETE) {

           DBGPRINT(("Devicework: LS_COMPLETE \n"));

           if (hIOPort->TPCB_CallHandle == (HCALL)(ULONG_PTR)INVALID_HANDLE_VALUE) {

               retcode = ERROR_FROM_DEVICE ;

           } else {

              hIOPort->TPCB_State = PS_CONNECTED ;
              retcode = SUCCESS ; //
           }
        }

    }

    // If we have connected, then get the com port handle for use in terminal modem i/o
    //
    if (hIOPort->TPCB_State == PS_CONNECTED) {

        VARSTRING *varstring ;
        BYTE       buffer [100] ;

        // get the cookie to realize tapi and ndis endpoints
        //
        varstring = (VARSTRING *) buffer ;
        varstring->dwTotalSize = sizeof(buffer) ;

        // Unimodem/asyncmac linegetid returns a comm port handle. Other medias give the endpoint itself back in linegetid
        // This has to do with the fact that modems/asyncmac are not a miniport.
        //
        if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_UNIMODEM) == 0) {

           if (lineGetID (hIOPort->TPCB_Line->TLI_LineHandle, hIOPort->TPCB_AddressId, hIOPort->TPCB_CallHandle, LINECALLSELECT_CALL, varstring, "comm/datamodem")) {
              // **** Exclusion End ****
              FreeMutex (RasTapiMutex) ;
              return ERROR_FROM_DEVICE ;
           }

           hIOPort->TPCB_CommHandle =  LongToHandle(*((DWORD *) ((BYTE *)varstring+varstring->dwStringOffset))) ;

            // Initialize the port for approp. buffers
            //
            SetupComm (hIOPort->TPCB_CommHandle, 1514, 1514) ;

       } else {

           if (lineGetID (hIOPort->TPCB_Line->TLI_LineHandle, hIOPort->TPCB_AddressId, hIOPort->TPCB_CallHandle, LINECALLSELECT_CALL, varstring, "NDIS")) {
             // **** Exclusion End ****
             FreeMutex (RasTapiMutex) ;
             return ERROR_FROM_DEVICE ;
           }

            hIOPort->TPCB_Endpoint = *((DWORD *) ((BYTE *)varstring+varstring->dwStringOffset)) ;
        }

   // DbgPrint ("L\n") ;
    }

    if (retcode == PENDING) {
       DBGPRINT(("Devicework: Reset event \n"));
       ResetEvent (hNotifier) ;
    }

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;
    return(retcode);
}


//* DeviceSetDevConfig()
//
//  Function: Called to set an opaque blob of data to configure a device.
//
//  Returns:  LocalAlloc returned values.
//
DWORD
DeviceSetDevConfig (HANDLE hPort, PBYTE devconfig, DWORD sizeofdevconfig)
{
    TapiPortControlBlock *hIOPort = LookUpControlBlock(hPort);

    if (!hIOPort)
        return ERROR_PORT_NOT_FOUND ;

    if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_UNIMODEM))
        return SUCCESS ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    if (hIOPort->TPCB_DevConfig != NULL)
        LocalFree (hIOPort->TPCB_DevConfig) ;

    if ((hIOPort->TPCB_DevConfig = LocalAlloc(LPTR, sizeofdevconfig)) == NULL) {

        // **** Exclusion End ****
        FreeMutex (RasTapiMutex) ;
        return(GetLastError());
    }

    memcpy (hIOPort->TPCB_DevConfig, devconfig, sizeofdevconfig) ;
    hIOPort->TPCB_SizeOfDevConfig = sizeofdevconfig ;

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;
    return (SUCCESS);
}


//* DeviceGetDevConfig()
//
//  Function: Called to set an opaque blob of data to configure a device.
//
//  Returns:  LocalAlloc returned values.
//
DWORD
DeviceGetDevConfig (char *name, PBYTE devconfig, DWORD *sizeofdevconfig)
{
    TapiPortControlBlock *hIOPort = NULL;
    DWORD i ;
    BYTE buffer[2000] ;
    LPVARSTRING var ;
    PBYTE configptr ;
    DWORD configsize ;
    DWORD retcode ;

    // hIOPort or pszPortName must be valid:
    //
    for (i=0; i < TotalPorts; i++) {
       if (!_stricmp(RasPorts[i].TPCB_Name, name)) {
           hIOPort = (HANDLE) &RasPorts[i] ;
           break ;
       }
    }

    if (!hIOPort)
        return ERROR_PORT_NOT_FOUND ;

    if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_UNIMODEM)) {
        *sizeofdevconfig = 0 ;
        return SUCCESS ;
    }

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;

    if (hIOPort->TPCB_DevConfig != NULL) {

        configptr  = hIOPort->TPCB_DevConfig ;
        configsize = hIOPort->TPCB_SizeOfDevConfig ;

    } else {

        // Make var string
        //
        var = (LPVARSTRING)buffer ;
        var->dwTotalSize  = 2000 ;
        var->dwStringSize = 0 ;
        lineGetDevConfig (hIOPort->TPCB_Line->TLI_LineId, var, "comm/datamodem") ;
        configptr  = ((CHAR *)var + var->dwStringOffset) ;
        configsize = var->dwStringSize  ;
    }

    if (*sizeofdevconfig > configsize) {
        memcpy (devconfig, configptr, configsize) ;
        retcode = SUCCESS ;
    } else
        retcode = ERROR_BUFFER_TOO_SMALL ;

    *sizeofdevconfig = configsize ;

    // **** Exclusion End ****
    FreeMutex (RasTapiMutex) ;
    return (retcode);
}


//*
//
//
//
//*
DWORD
GetInfo (TapiPortControlBlock *hIOPort, BYTE *pBuffer, WORD *pwSize)
{
    if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_ISDN) == 0)
   GetIsdnParams (hIOPort, (RASMAN_PORTINFO *) pBuffer, pwSize) ;
    else if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_X25) == 0)
   GetX25Params (hIOPort, (RASMAN_PORTINFO *) pBuffer, pwSize) ;
    else
   GetGenericParams (hIOPort, (RASMAN_PORTINFO *) pBuffer, pwSize) ;

    return SUCCESS ;
}


//* SetInfo()
//
//
//
//*
DWORD
SetInfo (TapiPortControlBlock *hIOPort, RASMAN_PORTINFO *pBuffer)
{

    DWORD Error;

    if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_UNIMODEM) == 0)
   Error = FillInUnimodemParams (hIOPort, pBuffer) ;
    if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_ISDN) == 0)
   Error = FillInIsdnParams (hIOPort, pBuffer) ;
    else if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_X25) == 0)
   Error = FillInX25Params (hIOPort, pBuffer) ;
    else
   Error = FillInGenericParams (hIOPort, pBuffer) ;

    return Error ;

}


//* FillInUnimodemParams()
//
//  Function:  We do more than fill in the params if the params are ones that are required to be set
//    right then.
//
//  Returns:   ERROR_WRONG_INFO_SPECIFIED.
//    Comm related Win32 errors
//    SUCCESS.
//*
DWORD
FillInUnimodemParams (TapiPortControlBlock *hIOPort, RASMAN_PORTINFO *pInfo)
{
    RAS_PARAMS *p;
    WORD i;
    DWORD   index = 0xfefefefe ;
    DCB  DCB ;
#define INITIALIZED_VALUE  0xde
    BYTE DCBByteSize = INITIALIZED_VALUE ;
    BYTE DCBParity   = INITIALIZED_VALUE ;
    BYTE DCBStopBits = INITIALIZED_VALUE ;
    BOOL DCBProcessingRequired = FALSE ;

    for (i=0, p=pInfo->PI_Params; i<pInfo->PI_NumOfParams; i++, p++) {

   if (_stricmp(p->P_Key, SER_DATABITS_KEY) == 0) {
       DCBByteSize = (BYTE) ValueToNum(p);
       DCBProcessingRequired = TRUE ;
   } else if (_stricmp(p->P_Key, SER_PARITY_KEY) == 0) {
       DCBParity = (BYTE) ValueToNum(p);
       DCBProcessingRequired = TRUE ;
   } else if (_stricmp(p->P_Key, SER_STOPBITS_KEY) == 0) {
       DCBStopBits = (BYTE) ValueToNum(p);
       DCBProcessingRequired = TRUE ;
   }

   //
   // The fact we use ISDN_PHONENUMBER_KEY is not a bug. This is just a define.
   //
   else if (_stricmp(p->P_Key, ISDN_PHONENUMBER_KEY) == 0)
       index = ADDRESS_INDEX ;
   else if (_stricmp(p->P_Key, CONNECTBPS_KEY) == 0)
       index = CONNECTBPS_INDEX ;
   else
       return(ERROR_WRONG_INFO_SPECIFIED);

    if (index != 0xfefefefe) {
       strncpy (hIOPort->TPCB_Info[index], p->P_Value.String.Data, p->P_Value.String.Length);
       hIOPort->TPCB_Info[index][p->P_Value.String.Length] = '\0' ;
    }
    }


    //
    // For parameters that should be set right away - check that the port handle is still valid
    // if so set the parameters.
    //
    if (DCBProcessingRequired && hIOPort->TPCB_CommHandle != INVALID_HANDLE_VALUE) {

   //
   // Get a Device Control Block with current port values
   //
   if (!GetCommState(hIOPort->TPCB_CommHandle, &DCB))
       return(GetLastError());

   if (DCBByteSize != INITIALIZED_VALUE)
       DCB.ByteSize = DCBByteSize ;
   if (DCBParity  != INITIALIZED_VALUE)
       DCB.Parity  = DCBParity ;
   if (DCBStopBits != INITIALIZED_VALUE)
       DCB.StopBits = DCBStopBits ;

   //
   // Send DCB to Port
   //
   if (!SetCommState(hIOPort->TPCB_CommHandle, &DCB))
       return(GetLastError());

    }

    return SUCCESS ;
}


//* FillInIsdnParams()
//
//
//
//*
DWORD
FillInIsdnParams (TapiPortControlBlock *hIOPort, RASMAN_PORTINFO *pInfo)
{
    RAS_PARAMS *p;
    WORD i;
    DWORD   index ;

    DBGPRINT(("CDMODEM: FillInIsdnParams: ISDN not supported\n"));
    ASSERT(FALSE);
    return SUCCESS ;
}

//*
//
//
//
//*
DWORD
FillInX25Params (TapiPortControlBlock *hIOPort, RASMAN_PORTINFO *pInfo)
{
    RAS_PARAMS *p;
    WORD i;
    DWORD   index ;

#ifndef CITRIX
    for (i=0, p=pInfo->PI_Params; i<pInfo->PI_NumOfParams; i++, p++) {

   if (_stricmp(p->P_Key, MXS_DIAGNOSTICS_KEY) == 0)
       index = X25_DIAGNOSTICS_INDEX ;

   else if (_stricmp(p->P_Key, MXS_USERDATA_KEY) == 0)
       index = X25_USERDATA_INDEX ;

   else if (_stricmp(p->P_Key, MXS_FACILITIES_KEY) == 0)
       index = X25_FACILITIES_INDEX;

   else if (_stricmp(p->P_Key, MXS_X25ADDRESS_KEY) == 0)
       index = ADDRESS_INDEX ;

   else if (_stricmp(p->P_Key, CONNECTBPS_KEY) == 0)
       index = X25_CONNECTBPS_INDEX ;
   else
       return(ERROR_WRONG_INFO_SPECIFIED);

   strncpy (hIOPort->TPCB_Info[index], p->P_Value.String.Data, p->P_Value.String.Length);
   hIOPort->TPCB_Info[index][p->P_Value.String.Length] = '\0' ;
    }

    strcpy (hIOPort->TPCB_Info[X25_CONNECTBPS_INDEX], "9600") ; // initialize connectbps to a
                           // reasonable default
#else // CITRIX
    DBGPRINT(("CDMODEM: FillInX25Params: X25 not supported\n"));
    ASSERT(FALSE);
#endif // CITRIX

    return SUCCESS ;
}




//*
//
//
//
//*
DWORD
FillInGenericParams (TapiPortControlBlock *hIOPort, RASMAN_PORTINFO *pInfo)
{
    RAS_PARAMS *p;
    WORD i;
    DWORD   index ;

    for (i=0, p=pInfo->PI_Params; i<pInfo->PI_NumOfParams; i++, p++) {

   if (_stricmp(p->P_Key, ISDN_PHONENUMBER_KEY) == 0)
       index = ADDRESS_INDEX ;
   else if (_stricmp(p->P_Key, CONNECTBPS_KEY) == 0)
       index = CONNECTBPS_INDEX ;
   else
       return(ERROR_WRONG_INFO_SPECIFIED);

   strncpy (hIOPort->TPCB_Info[index], p->P_Value.String.Data, p->P_Value.String.Length);
   hIOPort->TPCB_Info[index][p->P_Value.String.Length] = '\0' ;
    }

    return SUCCESS ;
}



//*
//
//
//
//*
DWORD
GetGenericParams (TapiPortControlBlock *hIOPort, RASMAN_PORTINFO *pBuffer , PWORD pwSize)
{
    RAS_PARAMS *pParam;
    CHAR *pValue;
    WORD wAvailable ;
    DWORD dwStructSize = sizeof(RASMAN_PORTINFO) + sizeof(RAS_PARAMS) * 2;

    wAvailable = *pwSize;
    *pwSize = (WORD) (dwStructSize + strlen (hIOPort->TPCB_Info[ADDRESS_INDEX])
               + strlen (hIOPort->TPCB_Info[CONNECTBPS_INDEX])
               + 1L) ;

    if (*pwSize > wAvailable)
      return(ERROR_BUFFER_TOO_SMALL);

    // Fill in Buffer

    ((RASMAN_PORTINFO *)pBuffer)->PI_NumOfParams = 2;

    pParam = ((RASMAN_PORTINFO *)pBuffer)->PI_Params;
    pValue = (CHAR*)pBuffer + dwStructSize;

    strcpy(pParam->P_Key, MXS_PHONENUMBER_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = strlen (hIOPort->TPCB_Info[ADDRESS_INDEX]);
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, hIOPort->TPCB_Info[ADDRESS_INDEX]);
    pParam++;

    strcpy(pParam->P_Key, CONNECTBPS_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = strlen (hIOPort->TPCB_Info[ISDN_CONNECTBPS_INDEX]);
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, hIOPort->TPCB_Info[ISDN_CONNECTBPS_INDEX]);

    return(SUCCESS);
}



//*
//
//
//
//*
DWORD
GetIsdnParams (TapiPortControlBlock *hIOPort, RASMAN_PORTINFO *pBuffer , PWORD pwSize)
{
    RAS_PARAMS *pParam;
    CHAR *pValue;
    WORD wAvailable ;
    DWORD dwStructSize = sizeof(RASMAN_PORTINFO) + sizeof(RAS_PARAMS) * 5;

#ifndef CITRIX
    wAvailable = *pwSize;

    *pwSize = (WORD) (dwStructSize + strlen (hIOPort->TPCB_Info[ADDRESS_INDEX])
               + strlen (hIOPort->TPCB_Info[ISDN_LINETYPE_INDEX])
               + strlen (hIOPort->TPCB_Info[ISDN_FALLBACK_INDEX])
               + strlen (hIOPort->TPCB_Info[ISDN_COMPRESSION_INDEX])
               + strlen (hIOPort->TPCB_Info[ISDN_CHANNEL_AGG_INDEX])
               + strlen (hIOPort->TPCB_Info[ISDN_CONNECTBPS_INDEX])
               + 1L) ;

    if (*pwSize > wAvailable)
      return(ERROR_BUFFER_TOO_SMALL);

    // Fill in Buffer

    ((RASMAN_PORTINFO *)pBuffer)->PI_NumOfParams = 6;

    pParam = ((RASMAN_PORTINFO *)pBuffer)->PI_Params;
    pValue = (CHAR*)pBuffer + dwStructSize;


    strcpy(pParam->P_Key, ISDN_PHONENUMBER_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = strlen (hIOPort->TPCB_Info[ADDRESS_INDEX]);
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, hIOPort->TPCB_Info[ADDRESS_INDEX]);
    pValue += pParam->P_Value.String.Length + 1;
    pParam++;


    strcpy(pParam->P_Key, ISDN_LINETYPE_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = strlen (hIOPort->TPCB_Info[ISDN_LINETYPE_INDEX]);
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, hIOPort->TPCB_Info[ISDN_LINETYPE_INDEX]);
    pValue += pParam->P_Value.String.Length + 1;
    pParam++;


    strcpy(pParam->P_Key, ISDN_FALLBACK_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = strlen (hIOPort->TPCB_Info[ISDN_FALLBACK_INDEX]);
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, hIOPort->TPCB_Info[ISDN_FALLBACK_INDEX]);
    pValue += pParam->P_Value.String.Length + 1;
    pParam++;


    strcpy(pParam->P_Key, ISDN_COMPRESSION_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = strlen (hIOPort->TPCB_Info[ISDN_COMPRESSION_INDEX]);
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, hIOPort->TPCB_Info[ISDN_COMPRESSION_INDEX]);
    pValue += pParam->P_Value.String.Length + 1;
    pParam++;


    strcpy(pParam->P_Key, ISDN_CHANNEL_AGG_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = strlen (hIOPort->TPCB_Info[ISDN_CHANNEL_AGG_INDEX]);
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, hIOPort->TPCB_Info[ISDN_CHANNEL_AGG_INDEX]);
    pValue += pParam->P_Value.String.Length + 1;
    pParam++;

    strcpy(pParam->P_Key, CONNECTBPS_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = strlen (hIOPort->TPCB_Info[ISDN_CONNECTBPS_INDEX]);
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, hIOPort->TPCB_Info[ISDN_CONNECTBPS_INDEX]);

#else // CITRIX
    DBGPRINT(("CDMODEM: GetIsdnParams: ISDN not supported\n"));
    ASSERT(FALSE);
#endif // CITRIX


    return(SUCCESS);
}



//*
//
//
//
//*
DWORD
GetX25Params (TapiPortControlBlock *hIOPort, RASMAN_PORTINFO *pBuffer ,PWORD pwSize)
{
    RAS_PARAMS *pParam;
    CHAR *pValue;
    WORD wAvailable ;
    DWORD dwStructSize = sizeof(RASMAN_PORTINFO) + sizeof(RAS_PARAMS) * 4 ;

#ifndef CITRIX
    wAvailable = *pwSize;
    *pwSize = (WORD) (dwStructSize + strlen (hIOPort->TPCB_Info[ADDRESS_INDEX])
               + strlen (hIOPort->TPCB_Info[X25_DIAGNOSTICS_INDEX])
               + strlen (hIOPort->TPCB_Info[X25_USERDATA_INDEX])
               + strlen (hIOPort->TPCB_Info[X25_FACILITIES_INDEX])
               + strlen (hIOPort->TPCB_Info[X25_CONNECTBPS_INDEX])
               + 1L) ;

    if (*pwSize > wAvailable)
      return(ERROR_BUFFER_TOO_SMALL);

    // Fill in Buffer

    ((RASMAN_PORTINFO *)pBuffer)->PI_NumOfParams = 5 ;

    pParam = ((RASMAN_PORTINFO *)pBuffer)->PI_Params;
    pValue = (CHAR*)pBuffer + dwStructSize;

    strcpy(pParam->P_Key, MXS_X25ADDRESS_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = strlen (hIOPort->TPCB_Info[ADDRESS_INDEX]);
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, hIOPort->TPCB_Info[ADDRESS_INDEX]);
    pValue += pParam->P_Value.String.Length + 1;
   pParam++;

    strcpy(pParam->P_Key, MXS_DIAGNOSTICS_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = strlen (hIOPort->TPCB_Info[X25_DIAGNOSTICS_INDEX]);
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, hIOPort->TPCB_Info[X25_DIAGNOSTICS_INDEX]);
    pValue += pParam->P_Value.String.Length + 1;
   pParam++;

    strcpy(pParam->P_Key, MXS_USERDATA_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = strlen (hIOPort->TPCB_Info[X25_USERDATA_INDEX]);
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, hIOPort->TPCB_Info[X25_USERDATA_INDEX]);
    pValue += pParam->P_Value.String.Length + 1;
    pParam++;

    strcpy(pParam->P_Key, MXS_FACILITIES_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = strlen (hIOPort->TPCB_Info[X25_FACILITIES_INDEX]);
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, hIOPort->TPCB_Info[X25_FACILITIES_INDEX]);
    pValue += pParam->P_Value.String.Length + 1;
    pParam++;

    strcpy(pParam->P_Key, CONNECTBPS_KEY);
    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = strlen (hIOPort->TPCB_Info[X25_CONNECTBPS_INDEX]);
    pParam->P_Value.String.Data = pValue;
    strcpy(pParam->P_Value.String.Data, hIOPort->TPCB_Info[X25_CONNECTBPS_INDEX]);

#else // CITRIX
    DBGPRINT(("CDMODEM: GetX25Params: X25 not supported\n"));
    ASSERT(FALSE);
#endif // CITRIX

    return(SUCCESS);
}


//* GetMutex
//
//
//
//*
VOID
GetMutex (HANDLE mutex, DWORD to)
{
    if (WaitForSingleObject (mutex, to) == WAIT_FAILED) {
   GetLastError() ;
   DbgBreakPoint() ;
    }
}



//* FreeMutex
//
//
//
//*
VOID
FreeMutex (HANDLE mutex)
{
    if (!ReleaseMutex(mutex)) {
   GetLastError () ;
   DbgBreakPoint() ;
    }
}


//* InitiatePortDisconnection()
//
// Function: Starts the disconnect process. Note even though this covers SYNC completion of lineDrop this
//           is not per TAPI spec.
//
// Returns:
//*
DWORD
InitiatePortDisconnection (TapiPortControlBlock *hIOPort)
{
    DWORD retcode ;

    hIOPort->TPCB_RequestId = INFINITE ; // mark requestid as unused

    // For asyncmac/unimodem give a close indication to asyncmac if the endpoint is still valid
    //
    if (_stricmp (hIOPort->TPCB_DeviceType, DEVICETYPE_UNIMODEM) == 0) {

        // tell asyncmac to close the link
        //
        if (hIOPort->TPCB_Endpoint != 0xffffffff) {

            ASYMAC_CLOSE  AsyMacClose;
            OVERLAPPED overlapped ;
            DWORD       dwBytesReturned ;

            memset (&overlapped, 0, sizeof(OVERLAPPED)) ;

            AsyMacClose.MacAdapter = NULL;
            AsyMacClose.hNdisEndpoint = LongToHandle(hIOPort->TPCB_Endpoint) ;

            DeviceIoControl(ghAsyMac,
                      IOCTL_ASYMAC_CLOSE,
                      &AsyMacClose,
                      sizeof(AsyMacClose),
                      &AsyMacClose,
                      sizeof(AsyMacClose),
                      &dwBytesReturned,
                     &overlapped);

            hIOPort->TPCB_Endpoint = 0xffffffff ;

        }

        // Close the handle given by lineGetId on unimodem ports
       //
        if (hIOPort->TPCB_CommHandle != INVALID_HANDLE_VALUE) {
       DBGPRINT(( "InitiatePortDisconnection: Closing handle 0x%x",
                  hIOPort->TPCB_CommHandle ));
            CloseHandle (hIOPort->TPCB_CommHandle) ;
            hIOPort->TPCB_CommHandle = INVALID_HANDLE_VALUE ;
        }
    }

    // Handle the case where lineMakeCall is not yet complete and the callhandle is invalid
    //
    if (hIOPort->TPCB_CallHandle == (HCALL) INFINITE) {

        lineClose (hIOPort->TPCB_Line->TLI_LineHandle) ;

        Sleep (30L) ;   // arbitrary sleep time to allow cleanup in lower layers

        retcode = lineOpen (RasLine,
                     hIOPort->TPCB_Line->TLI_LineId,
                     &hIOPort->TPCB_Line->TLI_LineHandle,
                     hIOPort->TPCB_Line->NegotiatedApiVersion,
                     hIOPort->TPCB_Line->NegotiatedExtVersion,
                     (ULONG) (ULONG_PTR) hIOPort->TPCB_Line,
                     LINECALLPRIVILEGE_OWNER,
                     hIOPort->TPCB_MediaMode,
                     NULL) ;

        if (retcode)
        DbgPrint ("InitiateDisconnection: lineOpen failed with %d\n", retcode) ;

   //
   // Set monitoring of rings
   //
   lineSetStatusMessages (hIOPort->TPCB_Line->TLI_LineHandle, LINEDEVSTATE_RINGING, 0) ;

        return SUCCESS ;
    }


    // Initiate disconnection.
    //
    if ((hIOPort->TPCB_RequestId = lineDrop (hIOPort->TPCB_CallHandle, NULL, 0)) > 0x80000000 ) {

      //
      // Error issuing the linedrop.  Should we try to deallocate anyway?
      //
      hIOPort->TPCB_State = PS_OPEN ;
      hIOPort->TPCB_RequestId = INFINITE ;
      lineDeallocateCall (hIOPort->TPCB_CallHandle) ;

      // DbgPrint ("D\n") ;

      return ERROR_DISCONNECTION ; // generic disconnect message

   } else if (hIOPort->TPCB_RequestId) {

      //
      // The linedrop is completeing async
      //
      hIOPort->TPCB_State = PS_DISCONNECTING ;

      // DbgPrint ("InitiatePortDisconnection: ReqId:%d\n", hIOPort->TPCB_RequestId) ;

      return PENDING ;

   } else { // SUCCESS

      //
      // The linedrop completed sync
      //
      hIOPort->TPCB_RequestId = INFINITE ;
      if (hIOPort->TPCB_Line->IdleReceived) {

         hIOPort->TPCB_Line->IdleReceived = FALSE;
         hIOPort->TPCB_State = PS_OPEN ;
         lineDeallocateCall (hIOPort->TPCB_CallHandle) ;

          // DbgPrint ("D\n") ;

         hIOPort->TPCB_CallHandle = (HCALL) 0xffffffff ;
           return SUCCESS ;

      } else {

          //
          // Wait for IdleReceived
          //
          hIOPort->TPCB_State = PS_DISCONNECTING ;
          return PENDING ;
        }
    }

}


// LookUpControlBlock()
//
// Function: This function uses the given handle to find which TPCB is it refering to. This handle can be
//           either a pointer to TPCB itself (in case of non unimodem devices) or it is the CommHandle
//           for the unimodem port.
//
// Consider: Adding a cache for lookup speeding.
//
// Returns:  Nothing.
//
TapiPortControlBlock *
LookUpControlBlock (HANDLE hPort)
{
    DWORD i ;
    TapiPortControlBlock *pports ;

    // hPort is the TPCB pointer
    //
    if (((TapiPortControlBlock *)hPort >= RasPorts)    &&
        ((TapiPortControlBlock *)hPort < RasPortsEnd)  &&
        (((TapiPortControlBlock *)hPort)->TPCB_Signature == CONTROLBLOCKSIGNATURE))
        return (TapiPortControlBlock *)hPort ;

    // hPort is not the TPCB pointer - see if this matches any of the CommHandles
    //
    for (pports = RasPorts, i=0; i < TotalPorts; i++, pports++) {
        if (pports->TPCB_CommHandle == hPort)
            return pports ;
    }

    return NULL ;
}


//*  ValueToNum  -------------------------------------------------------------
//
// Function: Converts a RAS_PARAMS P_Value, which may be either a DWORD or
//           a string, to a DWORD.
//
// Returns: The numeric value of the input as a DWORD.
//
//*

DWORD
ValueToNum(RAS_PARAMS *p)
{
    CHAR szStr[RAS_MAXLINEBUFLEN];


    if (p->P_Type == String) {

   strncpy(szStr, p->P_Value.String.Data, p->P_Value.String.Length);
   szStr[p->P_Value.String.Length] = '\0';
   return(atol(szStr));

    } else

   return(p->P_Value.Number);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\rastapi\init.c ===
//****************************************************************************
//
//                     Terminal Server CDmodem
//
//
// Copyright 1996, Citrix Systems Inc.
// Copyright (C) 1994-95 Microsft Corporation. All rights reserved.
//
//  Filename: init.c
//
//  Revision History
//
//  Nov 1998       updated by Qunbiao Guo for terminal server
//  Mar  28 1992   Gurdeep Singh Pall  Created for RASMAN
//
//  Description: This file contains init code for cdmodem
//
//****************************************************************************


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <tapi.h>
#include <rasndis.h>
#include <wanioctl.h>
#include <rasman.h>
#include <raserror.h>
#include <eventlog.h>

#include <media.h>
#include <device.h>
#include <rasmxs.h>
#include <isdn.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include "rastapi.h"

#ifdef CITRIX
#include <winstaw.h>
#include <icadd.h>
#include <icaapi.h>
#include "cdmodem.h"
#endif // CITRIX

#ifdef CITRIX
#ifdef DBG
#define DBGPRINT(_arg) DbgPrint _arg
#else
#define DBGPRINT(_arg) { }
#endif
#endif // CITRIX

#pragma warning (error:4312)

HLINEAPP RasLine = 0 ;
HINSTANCE   RasInstance = 0 ;
TapiLineInfo   *RasTapiLineInfo ;
DWORD    TotalLines = 0 ;
DWORD    TotalPorts ;
TapiPortControlBlock *RasPorts ;
TapiPortControlBlock *RasPortsEnd ;
//DWORD     NegotiatedApiVersion ;
//DWORD     NegotiatedExtVersion ;
HANDLE      RasTapiMutex ;
BOOL     Initialized = FALSE ;
DWORD       TapiThreadId    ;
HANDLE      TapiThreadHandle;
DWORD       LoaderThreadId;
DWORD     ValidPorts = 0;
DWORD     NumberOfRings = 1 ;

HANDLE      ghAsyMac = INVALID_HANDLE_VALUE ;

//DWORD  EnumerateTapiPorts () ;
BOOL  ReadUsageInfoFromRegistry() ;
TapiLineInfo *FindLineByHandle (HLINE) ;
TapiPortControlBlock *FindPortByRequestId (DWORD) ;
TapiPortControlBlock *FindPortByAddressId (TapiLineInfo *, DWORD) ;
TapiPortControlBlock *FindPortByAddress   (CHAR *) ;
DWORD InitiatePortDisconnection (TapiPortControlBlock *hIOPort) ;
TapiPortControlBlock *FindPortByAddressAndName (CHAR *address, CHAR *name) ;

//* InitTapi()
//
//
//*
BOOL
InitRasTapi (HANDLE hInst, DWORD ul_reason_being_called, LPVOID lpReserved)
{
    STARTUPINFO        startupinfo ;
    DWORD dwErr;
    static BOOLEAN DllInitialized = FALSE ;


    DBGPRINT(( "CDMODEM: InitRasTapi: hInst 0x%x, reason 0x%x\n",
        hInst, ul_reason_being_called ));

   switch (ul_reason_being_called) {

   case DLL_PROCESS_ATTACH:

   if (RasPorts != 0)
       return 1 ;

   RasInstance = hInst ;

   ReadUsageInfoFromRegistry();

   if ((RasTapiMutex = CreateMutex (NULL, FALSE, NULL)) == NULL)
       return 0 ;

   DllInitialized = TRUE ;

   break ;

    case DLL_PROCESS_DETACH:

   //
   // If DLL did not successfully initialize for this process dont try to clean up
   //
   if (!DllInitialized)
       break ;

        lineShutdown (RasLine) ;
        PostThreadMessage (TapiThreadId, WM_QUIT, 0, 0) ;
       break ;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
#ifndef CITRIX
        //
        // If the thread that has created the TAPI
        // message queue thread via EnumerateTapiPorts
        // is exiting, also clean up the TAPI message
        // queue thread at this time.
        //
        // NOTE: We cannot do an explicit WaitForSingleObject()
        // on the TAPI message queue thread because we are
        // in a DLL init proc.  This would cause a deadlock,
        // since the exiting thread has to execute this DLL
        // init proc before exiting.  The TAPI message queue
        // thread actually takes care of the final DLL unload.
        // See EnumerateTapiPorts below.
        //
        if (GetCurrentThreadId() == LoaderThreadId)
           PostThreadMessage (TapiThreadId, WM_QUIT, 0, 0) ;

#endif // CITRIX
   break;

    }

    return 1 ;
}



//* EnumerateTapiPorts()
//
//  Function: First we call line initialize and construct a TLI for each line
//       Then for each line we enumerate addresses and go through each address
//       If the address is configured to be used with RAS we fill in the
//       approp. info into the TPCB for the address (now port).
//
//  Return:   GetLastError(), SUCCESS
//
//*
DWORD
EnumerateTapiPorts (HANDLE event)
{
    WORD     i, k ;
    TapiLineInfo    *nextline ;
    DWORD       lines = 0 ;
    BYTE     buffer[800] ;
    LINEADDRESSCAPS *lineaddrcaps ;
    LINEDEVCAPS       *linedevcaps ;
    CHAR     address[40] ;
    CHAR     devicetype[MAX_DEVICETYPE_NAME] = {0};
    DWORD       devicetypelength;
    CHAR     devicename[MAX_DEVICE_NAME] = {0};
    DWORD       devicenamelength;
    CHAR     szregkey[128];
    LINEEXTENSIONID extensionid ;
    DWORD       totaladdresses ;
#ifndef CITRIX
    TapiPortControlBlock *nextport ;
#else // CITRIX
    DWORD       addresses ;
    TapiPortControlBlock *nextport = NULL, *port ;
#endif // CITRIX
    MSG msg ;
    HINSTANCE hInst;
    TapiPortControlBlock *pports ;
    LINEINITIALIZEEXPARAMS param ;
    DWORD       version = HIGH_VERSION ;

    memset (&param, 0, sizeof (LINEINITIALIZEEXPARAMS)) ;
    param.dwOptions   = LINEINITIALIZEEXOPTION_USEHIDDENWINDOW ;
    param.dwTotalSize = sizeof(param) ;

#ifdef CITRIX
    DBGPRINT(( "CDMODEM: EnumerateTapiPorts: Entry\n" ));
#endif // CITRIX

    if (lineInitializeEx (&RasLine,
                          RasInstance,
                          (LINECALLBACK) RasTapiCallback,
                          REMOTEACCESS_APP,
                          &lines,
                          &version,
                          &param) )
       goto error ;

   if (lines == 0) {
      goto error;
   }

    nextline = RasTapiLineInfo = LocalAlloc (LPTR, sizeof (TapiLineInfo) * lines) ;

    if (nextline == NULL)
       goto error ;

    TotalLines = lines ;
#ifdef CITRIX
    totaladdresses = 0;
#endif // CITRIX

    for (i=0; i<lines; i++) {  // for all lines get the addresses -> ports

      if (lineNegotiateAPIVersion(RasLine,
                                  i,
                                  LOW_VERSION,
                                  HIGH_VERSION,
                                  &nextline->NegotiatedApiVersion,
                                  &extensionid) ) {
#ifdef CITRIX
                   totaladdresses++;
#endif // CITRIX
         nextline->TLI_LineState = PS_UNINITIALIZED ;
         nextline++ ;
         continue ;
      }

      if (lineNegotiateExtVersion(RasLine,
                                  i,
                                  nextline->NegotiatedApiVersion,
                                  LOW_EXT_VERSION,
                                  HIGH_EXT_VERSION,
                                  &nextline->NegotiatedExtVersion)) {

         nextline->NegotiatedExtVersion = 0;
      }

      memset (buffer, 0, sizeof(buffer)) ;

      linedevcaps = (LINEDEVCAPS *)buffer ;
      linedevcaps->dwTotalSize = sizeof (buffer) ;

      // Get a count of all addresses across all lines
      //
      if (lineGetDevCaps (RasLine,
                          i,
                          nextline->NegotiatedApiVersion,
                          nextline->NegotiatedExtVersion,
                          linedevcaps)) {
#ifdef CITRIX
                        totaladdresses += linedevcaps->dwNumAddresses;
#endif // CITRIX
         nextline->TLI_LineState = PS_UNINITIALIZED ;
         nextline++ ;
         continue ;
      }

#ifdef CITRIX
                totaladdresses++;
#endif // CITRIX
      nextline->TLI_LineId = i ; // fill TLI struct. id.
      nextline->TLI_LineState = PS_CLOSED ;

      nextline++ ;
    }
#ifdef CITRIX
    DBGPRINT(( "CDMODEM: ETP: totaladdresses %d\n", totaladdresses));
#endif // CITRIX

    // Now that we know the number of lines and number of addresses per line
    // we now fillin the TPCB structure per address
    //
    for (i=0, nextline = RasTapiLineInfo; i<TotalLines ; i++, nextline++) {

      BOOL fModem = FALSE ;

      if (RasTapiLineInfo[i].TLI_LineState == PS_UNINITIALIZED)
         continue ;

      memset (buffer, 0, sizeof(buffer)) ;

      linedevcaps = (LINEDEVCAPS *)buffer ;
      linedevcaps->dwTotalSize = sizeof(buffer) ;

      // Get a count of all addresses across all lines
      //
      if (lineGetDevCaps (RasLine,
                          i,
                          nextline->NegotiatedApiVersion,
                          nextline->NegotiatedExtVersion,
                          linedevcaps))

          goto error ;

      // Figure out if this is a unimodem device or not
      //
      if (nextline->NegotiatedApiVersion == HIGH_VERSION)  {

          // first convert all nulls in the device class string to non nulls.
          //
          DWORD  j ;
          char *temp ;

         for (j=0, temp = (CHAR *)linedevcaps+linedevcaps->dwDeviceClassesOffset;
              j<linedevcaps->dwDeviceClassesSize;
              j++, temp++)

            if (*temp == '\0')
                 *temp = ' ' ;

#ifdef CITRIX
         DBGPRINT(( "CDMODEM: HIGH VERSION provider: %s, line name: %s \n",
                    (char*) linedevcaps+linedevcaps->dwProviderInfoOffset,
                    (CHAR *)linedevcaps+linedevcaps->dwLineNameOffset));
#endif

          // select only those devices that have comm/datamodem as a device class
          //
          if ( (strstr((CHAR *)linedevcaps+linedevcaps->dwDeviceClassesOffset, "comm/datamodem") != NULL) ||
               (strstr((CHAR *)linedevcaps+linedevcaps->dwProviderInfoOffset, "Modem") != NULL) ) {

         DWORD stringlen = (linedevcaps->dwLineNameSize > MAX_DEVICE_NAME - 1 ? MAX_DEVICE_NAME - 1 : linedevcaps->dwLineNameSize) ;

         strcpy (devicetype, DEVICETYPE_UNIMODEM) ;
         strncpy (devicename, (CHAR *)linedevcaps+linedevcaps->dwLineNameOffset, stringlen) ;
         devicename[stringlen] = '\0' ;

         lstrcpynA(szregkey, (CHAR *)linedevcaps+linedevcaps->dwDevSpecificOffset+(2*sizeof(DWORD)), linedevcaps->dwDevSpecificSize);
         szregkey[linedevcaps->dwDevSpecificSize] = '\0';

         fModem = TRUE ;
          }

      } else {

          // Provider info is of the following format
          //   <media name>\0<device name>\0
          //   where - media name is - ISDN, SWITCH56, FRAMERELAY, etc.
          //         device name is  Digiboard PCIMAC, Cirel, Intel, etc.
          //
          // Since this format is used only by NDISWAN miniports this may not be present if the TSP
          // is a non unimodem and a non NDISWAN miniport. The following code (carefully) tries to
          // parse the
          //
          DWORD copylen ;
          DWORD providerinfosize = linedevcaps->dwProviderInfoSize + 2;
          BYTE* providerinfo = LocalAlloc (LPTR, providerinfosize) ;
          if (providerinfo == NULL)
             goto error ;
          memcpy (providerinfo, (CHAR *)linedevcaps+linedevcaps->dwProviderInfoOffset, linedevcaps->dwProviderInfoSize) ;
          providerinfo[providerinfosize-1] = '\0' ;
          providerinfo[providerinfosize-2] = '\0' ;



#ifdef CITRIX
         DBGPRINT(( "CDMODEM: None High Version, version: %d \n",nextline->NegotiatedApiVersion));
#endif

          if (strlen (providerinfo) > MAX_DEVICETYPE_NAME) {

         //
         //  If this name is longer than specified for a devicetype name then this is not a
         //  wan miniport device. In this case copy the provider info into the devicename
         //
         copylen = (strlen(providerinfo) > MAX_DEVICE_NAME ? MAX_DEVICE_NAME : strlen(providerinfo)) ;

         strcpy (devicetype, "XXXX") ; // put in a dummy device type - this will get skipped.
         strncpy (devicename, providerinfo, copylen) ;

          } else {

         //
         // treat this case as the the properly formatted name
         //
         strcpy (devicetype, providerinfo) ;
         copylen = (strlen(providerinfo+strlen(providerinfo)+1) > MAX_DEVICE_NAME ? MAX_DEVICE_NAME : strlen(providerinfo+strlen(providerinfo)+1)) ;
         strncpy (devicename, providerinfo+strlen(providerinfo)+1, copylen) ;
         devicename[copylen] = '\0' ;
          }
      }

#ifndef CITRIX
      totaladdresses = linedevcaps->dwNumAddresses ;

      for (k=0; k < totaladdresses; k++) {
#else // CITRIX
                for (k=0; k < linedevcaps->dwNumAddresses; k++) {
#endif // CITRIX

          if (!fModem) {

            memset (buffer, 0, sizeof(buffer)) ;

            lineaddrcaps = (LINEADDRESSCAPS*) buffer ;
            lineaddrcaps->dwTotalSize = sizeof (buffer) ;

            if (lineGetAddressCaps (RasLine, i, k, nextline->NegotiatedApiVersion, nextline->NegotiatedExtVersion, lineaddrcaps)) {
                DBGPRINT(( "CDMODEM: ETP: linegetaddresecaps error\n" ));
                continue;
            }


            memcpy (address, (CHAR *)lineaddrcaps + lineaddrcaps->dwAddressOffset, sizeof (address) -1 ) ;

#ifndef CITRIX
         if ((nextport = FindPortByAddress(address)) == NULL)
             continue ; // this address not configured for remoteaccess
#endif // CITRIX

          } else {

         GetAssociatedPortName (szregkey, address) ;

#ifndef CITRIX
              if ((nextport = FindPortByAddressAndName(address, devicename)) == NULL)
             continue ; // this address not configured for remoteaccess
#endif // CITRIX

          }


#ifndef CITRIX
          // nextport is the TPCB for this address

          nextport->TPCB_Line  = &RasTapiLineInfo[i] ;
          nextport->TPCB_State = PS_CLOSED ;
          nextport->TPCB_Endpoint = 0xffffffff ;
          nextport->TPCB_AddressId = k ;

          // Copy over the devicetype and devicename
          strcpy (nextport->TPCB_DeviceType, devicetype) ;
#else // CITRIX
          // Under RAS, the TPCB was allocated and partially
          // set up in the function ReadUsageInfoFromRegistry,
          // since WinFrame doesn't have this info convienently
          // sectioned off in the Registry it is built here
          // from the info garnered from TAPI itself.  This
          // potentially could add lines to the table that
          // WinFrame has no interest in, but it will do no
          // harm, since the lines are only acted upon when
          // an upper-level WinFrame API is called for a true
          // WinFrame-configured line.  (Bruce Fortune, Citrix)
          //
          if (nextport == NULL) {
         int i;

         // Allocate the linear list of TPCBs based on the number
         // of addresses.  This may be wasteful, and a better
         // solution would be to cull the info from WinFrame's
         // registry info.  (Bruce Fortune, Citrix)
         //
         TotalPorts = totaladdresses;
         port = nextport = RasPorts = LocalAlloc (LPTR,
             sizeof (TapiPortControlBlock) * TotalPorts) ;
         if (!port) {
             goto error;
         }
         RasPortsEnd = RasPorts + TotalPorts ;
         while (port < RasPortsEnd) {
             DBGPRINT(( "CDMODEM: ETP: TPCB init loop\n" ));
             port->TPCB_State = PS_UNINITIALIZED;
             port++;
         }
         port = nextport++;
          } else {

         // Look for this address in the table, just in case
         // of duplicates.  If the lookup fails, use the
         // next TPCB in the linear list.
         //
         if ((port = FindPortByAddress(address)) == NULL) {
             port = nextport++; // use next available entry
             if (port >= RasPortsEnd)  { 
            DbgPrint("CDMODEM: ETP: Insufficient TPCB.\n");
            DbgBreakPoint();
             }
         }
          }

          port->TPCB_Signature = CONTROLBLOCKSIGNATURE ;
          port->TPCB_Line  = &RasTapiLineInfo[i] ;
          port->TPCB_State = PS_CLOSED ;
          port->TPCB_Endpoint = 0xffffffff ;
          port->TPCB_AddressId = k ;
          port->TPCB_Usage = CALL_IN_OUT;

          strcpy (port->TPCB_DeviceType, devicetype) ;
          strncpy (port->TPCB_Name, devicename, sizeof(port->TPCB_Name)-1 ) ;
          port->TPCB_Name[sizeof(port->TPCB_Name)-1] = 0;
          strncpy (port->TPCB_Address, address, sizeof(port->TPCB_Address)-1) ;
                    port->TPCB_Address[sizeof(port->TPCB_Address)-1] = 0;
#endif // CITRIX


          // For unimodem devices we need to fix up names
          //
          if (fModem) {

             // Device Name is of the form "COM1: Hayes"
             //

             DBGPRINT(("CDMODEM: address %s, devicename %s \n", address, devicename));
             strcpy (port->TPCB_DeviceName, address) ;
             strcpy (port->TPCB_DeviceName, ":") ;
             strcpy (port->TPCB_DeviceName, devicename) ;


            strncpy (port->TPCB_Name, address, sizeof(port->TPCB_Name)-1) ;
                     port->TPCB_Name[sizeof(port->TPCB_Name)-1] = 0;


          } else {

             if (devicename[0] != '\0')
                strcpy (port->TPCB_DeviceName, devicename) ; // default


          }
          DBGPRINT(( "CDMODEM: ETP: p 0x%x, DN \"%s\", a \"%s\"\n",
                port, port->TPCB_DeviceName, port->TPCB_Name ));
      }

    }

#ifndef CITRIX
    //
    // Calculate the number of valid ports
    //
    for (pports = RasPorts, i=0; i < TotalPorts; i++, pports++) {
        if (pports->TPCB_State == PS_UNINITIALIZED)
            continue ;
        ValidPorts++;
    }
#else // CITRIX
    //
    // Okay, if this DLL got loaded, then at least one TAPI port
    // is being used by WinFrame.  Since this is all we know,
    // ValidPorts will be used here just to indicate that
    // there is *at least* one port worth doing this for...
    //
    ValidPorts = 1;
#endif // CITRIX

    //
    // Increase the reference count on our DLL
    // so it won't get unloaded out from under us.
    //

    hInst = LoadLibrary("cdmodem.dll");


    // Notify the api that the initialization is done
    //
    SetEvent (event) ;

    //
    // If there are ports, then we hang around until
    // we are shut down.  Otherwise, we exit immediately.
    //
    if (ValidPorts) {
        while (GetMessage(&msg, NULL, 0, 0)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg) ;
        }

    DBGPRINT(( "CDMODEM: ETP: WM_QUIT Message received, shutting down\n" ));
    }

    lineShutdown (RasLine) ;

    //
    // The following call atomically unloads our
    // DLL and terminates this thread.
    //
    FreeLibraryAndExitThread(hInst, SUCCESS);

error:

   if (RasLine) {
      lineShutdown (RasLine) ;
   }

    RasLine = 0 ;

    SetEvent (event) ;

    return ((DWORD)-1) ;
}



//* ReadUsageInfoFromRegistry()
//
//
//
//
//
//*
BOOL
ReadUsageInfoFromRegistry()
{
    DWORD   size;
    DWORD   type;
    HKEY    hkey;

    //
    // Read the number of rings key from the registry
    //
    if (RegOpenKey (HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Services\\Rasman\\Parameters"), &hkey))
        return FALSE;

    size = sizeof(DWORD) ;
    if (RegQueryValueEx (hkey, TEXT("NumberOfRings"), NULL, &type, (LPBYTE)&NumberOfRings, &size))
        NumberOfRings = 1 ;

    if ((NumberOfRings < 1) || (NumberOfRings > 20))
        NumberOfRings = 1 ;

    RegCloseKey (hkey) ;

    return TRUE;
}
                  
//* RasTapiCallback()
//
//  Function: Callback entrypoint for TAPI.
//
//  Returns:  Nothing.
//*
VOID FAR PASCAL
RasTapiCallback (HANDLE context, DWORD msg, DWORD instance, DWORD param1, DWORD param2, DWORD param3)
{
    LINECALLINFO    *linecallinfo ;
    BYTE     buffer [1000] ;
    HCALL       hcall ;
    HLINE       linehandle ;
    TapiLineInfo    *line ;
    TapiPortControlBlock *port ;
    DWORD       i ;
    DWORD       retcode ;

    // **** Exclusion Begin ****
    GetMutex (RasTapiMutex, INFINITE) ;


   DBGPRINT(( "RasTapiCallback: Ctx 0x%x, Msg: %d, Inst 0x%x, Param1: %d\n",
                                context, msg, instance, param1 ));

   switch (msg) {

   case LINE_CALLSTATE:

       hcall = (HCALL) (ULONG_PTR) context ;
       line = ULongToPtr(instance);

       // If line is closed dont bother
       //
       if (line->TLI_LineState == PS_CLOSED)
      break ;

       memset (buffer, 0, sizeof(buffer)) ;
       linecallinfo = (LINECALLINFO *) buffer ;
       linecallinfo->dwTotalSize = sizeof(buffer) ;

       // If line get call info fails return.
       //
       if (lineGetCallInfo (hcall, linecallinfo) > 0x80000000)
      break ;

       // Locate the ras port for this call
       //
       if ((port = FindPortByAddressId (line, linecallinfo->dwAddressID)) == NULL) {

      // Did not find a ras port for the call. Ignore it.
      //
      break ;
       }

       DBGPRINT(("RasTapiCallBack: LINE_CALLSTATE check param1 \n"));
       // A new call is coming in
       //
       if (param1 == LINECALLSTATE_OFFERING) {

        if ((line->TLI_LineState == PS_LISTENING) && (port->TPCB_State == PS_LISTENING)) {

          port->TPCB_CallHandle = hcall ;

          //
          // for unimodem devices wait for the specified number of rings
          //
          if (_stricmp (port->TPCB_DeviceType, DEVICETYPE_UNIMODEM) == 0) {

         //
         // call has already been answered by somebody else and is being offered to me
         //
         if (linecallinfo->dwCallStates == LINECALLSTATE_CONNECTED) {

             port->TPCB_ListenState = LS_COMPLETE ;

             //
             // Complete event so that rasman calls DeviceWork to proceed the listen state machine.
             //
             SetEvent (port->TPCB_ReqNotificationHandle) ;

         } else {

             port->TPCB_ListenState = LS_RINGING ;
             port->TPCB_NumberOfRings = NumberOfRings ;

         }

          } else {

         //
         // For other devices make transition to next listening state
         //
         port->TPCB_ListenState = LS_ACCEPT ;

         //
         // Complete event so that rasman calls DeviceWork to proceed the listen state machine.
         //
         SetEvent (port->TPCB_ReqNotificationHandle) ;

          }

      } else {

          //
          // We were not expecting the call. Make transition to next listening state
          //
          port->TPCB_ListenState = LS_ERROR ;
          port->TPCB_CallHandle = hcall ;

          //
          // not interested in call, drop it.
          //
          InitiatePortDisconnection (port) ;

      }

      break ;
       }


       // Call connected.
       //
       if (param1 == LINECALLSTATE_CONNECTED ) {

          DBGPRINT((" RasTapiCallBack: LINECALLSTATE_CONNECTED  \n"));

          if (port->TPCB_State == PS_CONNECTING) {

          //
          // We were requesting the call. Complete event so that rasman calls DeviceWork() to complete the
          // connection process.
          //
          SetEvent (port->TPCB_ReqNotificationHandle) ;

         } else {

          port->TPCB_CallHandle = hcall ;

          // This is a call we are asnwering. Now we can indicate to rasman that the call has come in.
          //
          // Setting listen state to LS_COMPLETE may be redundant but handles the case where the answer
          // completes *after* the connection is indicated
          //
          port->TPCB_ListenState = LS_COMPLETE ;

          //
          // Complete event so that rasman knows of incoming call and calls devicework.
          //
          SetEvent (port->TPCB_ReqNotificationHandle) ;
         }

       }

       //
       // Failure of sorts.
       //
       if ((param1 == LINECALLSTATE_BUSY) || (param1 == LINECALLSTATE_SPECIALINFO)) {

      // If we were connecting, notify rasman to call devicework so that the connection attempt can
      // be gracefully failed.
      //
         if (port->TPCB_State == PS_CONNECTING)
            SetEvent (port->TPCB_ReqNotificationHandle) ;

      //  Can this be received for the answering case?
      //
       }

       //
       // Disconnection happened
       //
       if (param1 == LINECALLSTATE_DISCONNECTED) {

      // If we were connecting, notify rasman to call devicework so that the connection attempt can
      // be gracefully failed.
      //
         if (port->TPCB_State == PS_CONNECTING) {

          if (param2 == LINEDISCONNECTMODE_BUSY)
         port->TPCB_AsyncErrorCode = ERROR_LINE_BUSY ;
          else if (param2 == LINEDISCONNECTMODE_NOANSWER)
         port->TPCB_AsyncErrorCode = ERROR_NO_ANSWER ;
          else if (param2 == LINEDISCONNECTMODE_NODIALTONE)
         port->TPCB_AsyncErrorCode = ERROR_NO_DIALTONE ;
                    else if (param2 == LINEDISCONNECTMODE_CANCELLED)
                        port->TPCB_AsyncErrorCode = ERROR_USER_DISCONNECTION;

          SetEvent (port->TPCB_ReqNotificationHandle) ;

      } else if (port->TPCB_State != PS_CLOSED) {

          // If we were connected and got a disconnect notification then this could be hardware failure or
          // a remote disconnection. Determine this and save the reason away.
          //
          if (port->TPCB_State == PS_CONNECTED) {
         LINECALLSTATUS *pcallstatus ;
         BYTE buffer[200] ;

         memset (buffer, 0, sizeof(buffer)) ;
         pcallstatus = (LINECALLSTATUS *) buffer ;
         pcallstatus->dwTotalSize = sizeof (buffer) ;
         lineGetCallStatus (port->TPCB_CallHandle, pcallstatus) ;
         if (pcallstatus->dwCallState == LINECALLSTATE_DISCONNECTED)
             port->TPCB_DisconnectReason = SS_LINKDROPPED ;
         else
             port->TPCB_DisconnectReason = SS_HARDWAREFAILURE ;

          } else
         port->TPCB_DisconnectReason = 0 ;

          //
          // This means that we got a disconnect indication in one of the other states (listening, connected, etc.)
          // We initiate our disconnect state machine.
          //
          if (InitiatePortDisconnection (port) != PENDING) {

         // Disconnection succeeded or failed. Both are end states for the disconnect state machine so notify
         // rasman that a disconnection has happened.
         //
         // DbgPrint("SignalDisc: 1\n") ;
         SetEvent (port->TPCB_DiscNotificationHandle) ;
          }
      }
       }

       //
       // A busy call state - our attempt to dialout failed
       //
     if (param1 == LINECALLSTATE_BUSY) {

      if (port->TPCB_State == PS_CONNECTING) {
      port->TPCB_AsyncErrorCode = ERROR_LINE_BUSY ;
      SetEvent (port->TPCB_ReqNotificationHandle) ;
      }
       }


       // Idle indication is useful to complete the disconnect state machine.
       //
       if (param1 == LINECALLSTATE_IDLE) {

      // DbgPrint ("I, State = %d\n", port->TPCB_State) ;

         if ((port->TPCB_State == PS_DISCONNECTING) && (port->TPCB_RequestId == INFINITE)) {

            // IDLE notification came after LineDrop Succeeded so safe to
            // deallocate the call
            //
            port->TPCB_State = PS_OPEN ;
            lineDeallocateCall (port->TPCB_CallHandle) ;
            // DbgPrint ("D + Signal Disc\n") ;
            port->TPCB_CallHandle = (HCALL) 0xffffffff ;
            line->IdleReceived = FALSE;
            SetEvent (port->TPCB_DiscNotificationHandle) ;
         } else {

            // We have not yet disconnected so do not deallocate call
            // yet.  This will be done when the disconnect completes.
            //
            line->IdleReceived = TRUE;
          // DbgPrint ("IdleNoAction\n") ;
         }
       }

   break ;


    case LINE_REPLY:

        // This message is sent to indicate completion of an asynchronous API.
        //

       DbgPrint ("LineReply: ReqId:%d", param1) ;


       // Find for which port the async request succeeded. This is done by searching for pending
       // request id that is also provided in this message.
       //
       if ((port = FindPortByRequestId (param1)) == NULL) {
            DbgPrint ("\n") ;

       break ;

       } else

       DbgPrint (" State = %d\n", port->TPCB_State) ;


        // Set request id to invalid.
        //
       port->TPCB_RequestId = INFINITE ;

       if (port->TPCB_State == PS_DISCONNECTING) {

          // lineDrop completed. Note that we ignore the return code in param2. This is
          // because we cant do anything else.
            //
         if (port->TPCB_Line->IdleReceived) {

            // We received IDLE notification before/during disconnect
            // so deallocate this call
            //
            port->TPCB_Line->IdleReceived = FALSE;
            port->TPCB_State = PS_OPEN ;
            lineDeallocateCall (port->TPCB_CallHandle) ;
            // DbgPrint ("D + SignalDisc\n") ;
            port->TPCB_CallHandle = (HCALL) 0xffffffff ;
                SetEvent (port->TPCB_DiscNotificationHandle) ;

         } else {

                // wait for idle message before signalling disconnect
                //
                ; // DbgPrint ("DropCompNoAction\n") ;
            }

         break ;
       }

        // Some other api completed
        //
       if (param2 == SUCCESS) {

         // Success means take no action - unless we are listening
         // in which case it means move to the next state - we simply
         // set the event that will result in a call to DeviceWork() to
         // make the actual call for the next state
         //
         if (port->TPCB_State != PS_LISTENING)
            break ;

         // Proceed to the next listening sub-state
         //
         if (port->TPCB_ListenState == LS_ACCEPT) {

            port->TPCB_ListenState =  LS_ANSWER ;
            SetEvent (port->TPCB_ReqNotificationHandle) ;

         } else if (port->TPCB_ListenState == LS_ANSWER) {

            port->TPCB_ListenState = LS_COMPLETE ;
         }


       } else {

         // For connecting and listening ports this means the attempt failed
         // because of some error
         //
         if (port->TPCB_State == PS_CONNECTING) {

            port->TPCB_AsyncErrorCode = ERROR_PORT_OR_DEVICE ;
            SetEvent (port->TPCB_ReqNotificationHandle) ;

         } else if (port->TPCB_State == PS_LISTENING) {

             // Because ACCEPT may not be supported by the device - treat error as success
                //
            if (port->TPCB_ListenState == LS_ACCEPT)
               port->TPCB_ListenState =  LS_ANSWER ;
            else
               port->TPCB_ListenState =  LS_ERROR ;

            SetEvent (port->TPCB_ReqNotificationHandle) ;
         }

         // Some other API failed, we dont know and we dont care. Ignore.
         //
         else if (port->TPCB_State != PS_CLOSED) {

                ; // DbgPrint ("RASTAPI: LINE_REPLY failed. Ignored.\n") ;
            }
       }

      break ;

    case LINE_CLOSE:

        // Typically sent when things go really wrong.
        //

        DbgPrint ("RASTAPI: received LINE_CLOSE message\n") ;

        // Find which line is indication came for.
        //
        line = ULongToPtr(instance) ;

        // if line not found or if it is closed just return
        //
        if ((line == NULL) || (line->TLI_LineState == PS_CLOSED))
            break ;

        // For every port that is on the line - open the line again and signal
        // hw failure
        //
        for (port = RasPorts, i = 0; i < TotalPorts; i++, port++) {

            // Skip ports that arent initialized
            //
           if (port->TPCB_State == PS_UNINITIALIZED)
               continue ;

            if (port->TPCB_Line == line) {

                if (retcode = lineOpen (RasLine,
                               port->TPCB_Line->TLI_LineId,
                               &port->TPCB_Line->TLI_LineHandle,
                               port->TPCB_Line->NegotiatedApiVersion,
                               port->TPCB_Line->NegotiatedExtVersion,
                               (ULONG) (ULONG_PTR) port->TPCB_Line,
                               LINECALLPRIVILEGE_OWNER,
                               port->TPCB_MediaMode,
                               NULL));      //
      // Set monitoring of rings
      //
      lineSetStatusMessages (port->TPCB_Line->TLI_LineHandle, LINEDEVSTATE_RINGING, 0) ;

                // If the port is listening - then we do not need to do anything since the listen is
                // posted implicitly,
                //
                if (port->TPCB_State != PS_LISTENING) {
                    //
                    // These settings should cause connections and connect attempts to
                    // fail.
                    //
                    port->TPCB_AsyncErrorCode = ERROR_FROM_DEVICE ;
                   port->TPCB_CallHandle =  (HCALL) 0xffffffff ;
                    port->TPCB_ListenState = LS_ERROR ;

                    // Signal hardware failure to rasman.
                    //
                    // DbgPrint ("SignalDisc: 3\n") ;
                    SetEvent (port->TPCB_DiscNotificationHandle) ;
                }
            }
        }
        break ;

    case LINE_LINEDEVSTATE:

   //
   // we are only interested in ringing message
   //
   if (param1 != LINEDEVSTATE_RINGING)
       break ;

   // Find which line is indication came for.
        //
        line = ULongToPtr(instance) ;

        // if line not found or if it is closed just return
        //
        if ((line == NULL) || (line->TLI_LineState == PS_CLOSED))
            break ;

   // get the port from the line
        //
        for (port = RasPorts, i = 0; i < TotalPorts; i++, port++) {

            // Skip ports that arent initialized
            //
       if (port->TPCB_State == PS_UNINITIALIZED)
      continue ;

       if ((port->TPCB_Line == line) && (port->TPCB_State == PS_LISTENING) && (port->TPCB_ListenState == LS_RINGING)) {

      //
      // count down the rings
      //
      port->TPCB_NumberOfRings -= 1 ;
      // DbgPrint ("Ring count = %d\n", port->TPCB_NumberOfRings) ;

      //
      // if the ring count has gone down to zero this means that we should pick up the call.
      //
      if (port->TPCB_NumberOfRings == 0) {

          port->TPCB_ListenState = LS_ACCEPT ;

          //
          // Complete event so that rasman calls DeviceWork to proceed the listen state machine.
          //
          SetEvent (port->TPCB_ReqNotificationHandle) ;
      }

      break ;
            }
   }

   break ;

    case LINE_ADDRESSSTATE:
    case LINE_CALLINFO:
    case LINE_CREATE:
    case LINE_DEVSPECIFIC:
    case LINE_DEVSPECIFICFEATURE:
    case LINE_GATHERDIGITS:
    case LINE_GENERATE:

    case LINE_MONITORDIGITS:
    case LINE_MONITORMEDIA:
    case LINE_MONITORTONE:
    case LINE_REQUEST:
   default:
        // All unhandled unsolicited messages.
        //
      ;
    }

    // **** Exclusion End ****
   FreeMutex (RasTapiMutex) ;
}



//* FindPortByAddressId()
//
//
//
//
//*
TapiPortControlBlock *
FindPortByAddressId (TapiLineInfo *line, DWORD addid)
{
    DWORD   i ;
    TapiPortControlBlock *port ;

    for (i=0, port=RasPorts; i<TotalPorts; i++, port++) {

   if ((port->TPCB_AddressId == addid) && (port->TPCB_Line == line))
       return port ;

    }

    return NULL ;
}


//* FindPortByAddress()
//
//
//
//
//*
TapiPortControlBlock *
FindPortByAddress (CHAR *address)
{
    DWORD   i ;
    TapiPortControlBlock *port ;

    for (i=0, port=RasPorts; i<TotalPorts; i++, port++) {

   if (_stricmp (port->TPCB_Address, address) == 0)
       return port ;

    }

    return NULL ;
}


//* FindPortByAddress()
//
//
//
//
//*
TapiPortControlBlock *
FindPortByAddressAndName (CHAR *address, CHAR *name)
{
    DWORD   i ;
    TapiPortControlBlock *port ;

    for (i=0, port=RasPorts; i<TotalPorts; i++, port++) {

   if ((_stricmp (port->TPCB_Address, address) == 0) &&
       (_strnicmp (port->TPCB_Name, name, MAX_PORT_NAME-1) == 0))
       return port ;

    }

    return NULL ;
}


//* FindPortByRequestId()
//
//
//
//
//*
TapiPortControlBlock *
FindPortByRequestId (DWORD reqid)
{
    DWORD   i ;
    TapiPortControlBlock *port ;

    for (i=0, port=RasPorts; i<TotalPorts; i++, port++) {

   if (port->TPCB_RequestId == reqid)
       return port ;

    }

    return NULL ;
}



//* FindLineByHandle()
//
//
//
//
//*
TapiLineInfo *
FindLineByHandle (HLINE linehandle)
{
    DWORD i ;
    TapiLineInfo *line ;

    for (i=0, line=RasTapiLineInfo; i<TotalLines; i++, line++) {

   if (line->TLI_LineHandle == linehandle)
       return line ;

    }

    return NULL ;
}



#define VALNAME_ATTACHEDTO "AttachedTo"

BOOL
GetAssociatedPortName(
   char  * szKeyName,
   CHAR * szPortName)
/*
 * Given the registry key name 'szRegistryKeyName' corresponding to the modem entry, fills in
 * 'wszAddress' with the associated port like COM1, ..
 *
 */
{
   HKEY   hKeyModem;
   DWORD  dwType;
   DWORD  cbValueBuf;
#if 0
   char   buf[256];
#endif

#if 0
   wsprintfA(buf,"RegistryKey -> %s \n", szKeyName);
   OutputDebugStringA(buf);
#endif

   if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                     szKeyName,
                     0,
                     KEY_READ,
                     &hKeyModem ) )
   {
       return( FALSE );
   }

   cbValueBuf = 40 ;

   if ( RegQueryValueExA(hKeyModem,
                        VALNAME_ATTACHEDTO,
                        NULL,
                        &dwType,
         (LPBYTE)szPortName,
                        &cbValueBuf ))
   {
      return ( FALSE );
   }

   RegCloseKey( hKeyModem );

   return ( TRUE );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\src\cdmodem.c ===
/*************************************************************************
*
* cdmodem.c
*
* Modem Connection Driver
*
*
* Copyright 1996, Citrix Systems Inc.
*
* Author: Brad Pedersen (7/12/96)
*
* $Log:   M:\nt\private\citrix\cd\cdmodem\src\VCS\cdmodem.c  $
*
*     Rev 1.12   23 Feb 1998 21:14:52   kurtp
*  fix CPR 8656, callback fails
*
*     Rev 1.11   26 Jun 1997 14:25:34   wf20r
*  move to WF40 tree
*
*     Rev 1.10   20 Jun 1997 18:06:54   butchd
*  update
*
*     Rev 1.9   07 Feb 1997 15:15:30   miked
*  update
*
*     Rev 1.8   06 Feb 1997 17:41:08   kurtp
*  update
*
*     Rev 1.7   06 Feb 1997 17:39:10   kurtp
*  update
*
*     Rev 1.6   17 Dec 1996 09:47:18   brucef
*  Ensure Stack not left in callback state on error conditions.
*
*     Rev 1.5   12 Dec 1996 16:34:00   brucef
*  Use CD-supplied Disconnect Event to detect disconnections.
*
*     Rev 1.4   09 Dec 1996 14:03:32   brucef
*  Fail if Status from Initialize/Callback is not STATUS_SUCCESS.
*
*     Rev 1.3   06 Dec 1996 18:16:36   bradp
*  update
*
*     Rev 1.2   06 Dec 1996 17:12:34   miked
*  update
*
*     Rev 1.1   04 Dec 1996 17:46:46   brucef
*  Fill in Cd Context prior to calling ModemOpen
*
*     Rev 1.0   16 Oct 1996 11:16:14   brucef
*  Initial revision.
*
*     Rev 1.6   25 Sep 1996 13:23:38   bradp
*  update
*
*     Rev 1.5   12 Sep 1996 13:42:10   brucef
*  update
*
*     Rev 1.4   11 Sep 1996 17:51:46   brucef
*  update
*
*     Rev 1.3   05 Sep 1996 10:00:12   brucef
*  update
*
*     Rev 1.2   05 Sep 1996 09:32:44   brucef
*  update
*
*     Rev 1.1   20 Aug 1996 10:07:56   bradp
*  update
*
*     Rev 1.0   15 Jul 1996 11:03:54   bradp
*  Initial revision.
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <winstaw.h>
#include <icadd.h>
#include <icaapi.h>
#include <cdtapi.h>
#include <icaapi.h>


#include <cdmodem.h>

/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS APIENTRY CdOpen( HANDLE, PPDCONFIG, PVOID * );
NTSTATUS APIENTRY CdClose( PVOID );
NTSTATUS APIENTRY CdIoControl( PVOID, ULONG, PVOID, ULONG, PVOID, ULONG,
                               PULONG );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

VOID _FillInEndpoint( PCDMODEM pCdModem, PCDMODEM_ENDPOINT pMe );

/*=============================================================================
==   External Functions Used
=============================================================================*/

BOOL     InitRasTapi( HANDLE, DWORD, LPVOID );

NTSTATUS IcaMemoryAllocate( ULONG, PVOID * );
VOID     IcaMemoryFree( PVOID );

NTSTATUS ModemOpen( PCDMODEM );
NTSTATUS ModemClose( PCDMODEM );
NTSTATUS ModemInitialize( PCDMODEM );
NTSTATUS ModemHangup( PCDMODEM );
NTSTATUS ModemCallback( PCDMODEM, PICA_STACK_CALLBACK );


/****************************************************************************
 *
 * DllEntryPoint
 *
 *   Function is called when the DLL is loaded and unloaded.
 *   Initialization of the TAPI component is performed here.
 *
 * ENTRY:
 *   hinstDLL (input)
 *     Handle of DLL module
 *
 *   fdwReason (input)
 *     Why function was called
 *
 *   lpvReserved (input)
 *     Reserved; must be NULL
 *
 * EXIT:
 *   TRUE  - Success
 *   FALSE - Error occurred
 *
 ****************************************************************************/

BOOL WINAPI
DllEntryPoint( HINSTANCE hinstDLL,
               DWORD     fdwReason,
               LPVOID    lpvReserved )
{
    return( InitRasTapi( hinstDLL, fdwReason, lpvReserved ) );
}


/*******************************************************************************
 *
 *  CdOpen
 *
 *  Allocate a local context structure
 *  - this pointer will be passed on all subsequent calls
 *
 * ENTRY:
 *    hStack (input)
 *       ICA stack handle
 *    pTdConfig (input)
 *       pointer to transport driver parameters
 *    ppContext (output)
 *       pointer to location to return CD context value
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS APIENTRY
CdOpen( IN HANDLE hStack,
        IN PPDCONFIG pTdConfig,
        OUT PVOID *ppContext )
{
    NTSTATUS Status;
    PCDMODEM pCdModem;

    DBGPRINT(( "CDMODEM: CdOpen, entry\n" ));
    /*
     *  Allocate Memory for private CDMODEM data structure
     */
    Status = IcaMemoryAllocate( sizeof(CDMODEM), &pCdModem );
    if ( !NT_SUCCESS(Status) )
        goto badalloc;

    /*
     *  Fill in the Cd Context pointer now, so that if we block in
     *  ModemOpen, any IOCTLs that come down will have a valid
     *  CdModem structure.
     */
    *ppContext = pCdModem;

    /*
     *  Initialize CDMODEM data structure
     */
    RtlZeroMemory( pCdModem, sizeof(CDMODEM) );

    /*
     *  Save device name
     */
    RtlCopyMemory( pCdModem->DeviceName,
                   pTdConfig->Params.Async.DeviceName,
                   sizeof(pCdModem->DeviceName) );

    /*
     *  Save stack handle
     */
    pCdModem->hStack = hStack;

    /*
     *  Open TAPI device
     */
    ModemOpen( pCdModem );

    DBGPRINT(( "CDMODEM: CdOpen[%u][%u], success\n", hStack, pCdModem ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  allocate failed
     */
badalloc:
    DBGPRINT(( "CDMODEM: CdOpen[%u], 0x%x\n", hStack, Status ));
    return( Status );
}


/*******************************************************************************
 *
 *  CdClose
 *
 *  Free local context structure
 *
 * ENTRY:
 *    pContext (input)
 *       Pointer to private data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS APIENTRY
CdClose( IN PVOID pContext )
{
    DBGPRINT(( "CDMODEM: CdClose, entry\n" ));

    /*
     *  Free context memory
     */
    IcaMemoryFree( pContext );

    DBGPRINT(( "CDMODEM: CdClose[%u], success\n", pContext ));
    return( STATUS_SUCCESS );
}


/****************************************************************************
 *
 * CdIoControl
 *
 *   Generic interface to an ICA stack
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to local context structure
 *
 *   IoControlCode (input)
 *     I/O control code
 *
 *   pInBuffer (input)
 *     Pointer to input parameters
 *
 *   InBufferSize (input)
 *     Size of pInBuffer
 *
 *   pOutBuffer (output)
 *     Pointer to output buffer
 *
 *   OutBufferSize (input)
 *     Size of pOutBuffer
 *
 *   pBytesReturned (output)
 *     Pointer to number of bytes returned
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS APIENTRY
CdIoControl( IN  PVOID pContext,
             IN  ULONG IoControlCode,
             IN  PVOID pInBuffer,
             IN  ULONG InBufferSize,
             OUT PVOID pOutBuffer,
             IN  ULONG OutBufferSize,
             OUT PULONG pBytesReturned )
{
    PCDMODEM pCdModem;
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD Error;
    PCDMODEM_ENDPOINT pMe;
    ICA_STACK_TAPI_ENDPOINT TapiEndpoint;

    DBGPRINT(( "CDMODEM: CdIoControl - function (0x%02x)\n", ((IoControlCode >> 2) & 0x000000ff) ));

    pCdModem = (PCDMODEM) pContext;

    ASSERT(pCdModem);
    switch ( IoControlCode ) {

        case IOCTL_ICA_STACK_CREATE_ENDPOINT :
            /*
             * Skip sending anything down the stack now.
             * Wait until either a CONNECTION_WAIT or CALLBACK
             * ioctl. At which point the appropriate modem API
             * will be used to establish a connection.
             */
            break;


        case IOCTL_ICA_STACK_OPEN_ENDPOINT :
            {
         PCDMODEM_ENDPOINT pMe = (PCDMODEM_ENDPOINT) pInBuffer;

         /*
          * Copy the previously established Modem Device information.
          */
         pCdModem->hCommDevice = pMe->hCommDevice;
         pCdModem->hPort       = pMe->hPort;
         pCdModem->hDiscEvent  = pMe->hDiscEvent;
         ResetEvent( pCdModem->hDiscEvent );
            }

            Status = IcaCdIoControl( pCdModem->hStack,
                                     IoControlCode,
                                     STACK_ENDPOINT_ADDR(pInBuffer),
                                     STACK_ENDPOINT_SIZE(InBufferSize),
                                     NULL,
                                     0,
                                     NULL );
            break;




        case IOCTL_ICA_STACK_CLOSE_ENDPOINT :

            /*
             *  Hangup modem
             */
            Status = IcaCdIoControl( pCdModem->hStack,
                                     IoControlCode,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     NULL );
            (VOID) ModemHangup( pCdModem );
            break;


        case IOCTL_ICA_STACK_CONNECTION_WAIT :

            /*
             *  Send modem init string and wait for call to come in.
             */
            Status = ModemInitialize( pCdModem );
            if ( Status != STATUS_SUCCESS ) {
                break;
            }

            /*
             *  Send open handle to transport driver for inclusion in
             *  the Driver's Endpoint.
             */
            DBGPRINT(( "CDMODEM: CREATE_ENDPOINT NewHandle (0x%x)\n",
                       pCdModem->hCommDevice ));
            TapiEndpoint.hDevice = pCdModem->hCommDevice;
            TapiEndpoint.hDiscEvent = pCdModem->hDiscEvent;
            TapiEndpoint.fCallback = FALSE;
            Status = IcaCdIoControl( pCdModem->hStack,
                                     IOCTL_ICA_STACK_CD_CREATE_ENDPOINT,
                                     &TapiEndpoint,
                                     sizeof(TapiEndpoint),
                                     NULL,
                                     0,
                                     NULL );
            if ( !NT_SUCCESS(Status) ) {
                break;
            }

            Status = IcaCdIoControl( pCdModem->hStack,
                                     IoControlCode,
                                     STACK_ENDPOINT_ADDR(pInBuffer),
                                     STACK_ENDPOINT_SIZE(InBufferSize),
                                     STACK_ENDPOINT_ADDR(pOutBuffer),
                                     STACK_ENDPOINT_SIZE(OutBufferSize),
                                     pBytesReturned );
            if ( !NT_SUCCESS(Status) ) {
                Status = IcaCdIoControl( pCdModem->hStack,
                                         IOCTL_ICA_STACK_CLOSE_ENDPOINT,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         NULL );
                (VOID) ModemHangup( pCdModem );
                break;
            }
            if ( pBytesReturned != NULL && *pBytesReturned != 0 ) {
                *pBytesReturned += sizeof(CDMODEM_ENDPOINT);
         ((PCDMODEM_ENDPOINT)(pOutBuffer))->Length = *pBytesReturned;
            }

            _FillInEndpoint( pCdModem, (PCDMODEM_ENDPOINT) pOutBuffer );
            break;


        case IOCTL_ICA_STACK_CALLBACK_INITIATE :

            DBGPRINT(( "CDMODEM: CdIoControl STACK_CALLBACK_INITIATE\n" ));

            /*
             *  Need to delay to let any output flush, fixes bug where
             *  callback is interrupted and connection is dropped.
             *
             *  Need to check transport to see if all
             *  data is really gone, but not this close to Beta-2.
             */
            Sleep(2000);

            /*
             *  Send callback initiate command to ICA device driver
             */
            Status = IcaCdIoControl( pCdModem->hStack,
                                     IoControlCode,
                                     pInBuffer,
                                     InBufferSize,
                                     pOutBuffer,
                                     OutBufferSize,
                                     pBytesReturned );
            if ( !NT_SUCCESS(Status) )
                break;

            /*
             *  Close endpoint the call came in on
             */
            Status = IcaCdIoControl( pCdModem->hStack,
                         IOCTL_ICA_STACK_CLOSE_ENDPOINT,
                         NULL,
                         0,
                         NULL,
                         0,
                         NULL );
            if ( !NT_SUCCESS(Status) )
                break;

            DBGPRINT(( "CDMODEM: CdIoControl STACK_CALLBACK 0x%x\n", Status));
            /*
             *  Dial modem for callback
             */
            ASSERT ( InBufferSize == sizeof(ICA_STACK_CALLBACK) );
            Status = ModemCallback( pCdModem, pInBuffer );
            if ( Status != STATUS_SUCCESS )
                goto callbackerror;

            /*
             * Create a new endpoint for the outbound call just made
             */
            TapiEndpoint.hDevice = pCdModem->hCommDevice;
            TapiEndpoint.hDiscEvent = pCdModem->hDiscEvent;
            TapiEndpoint.fCallback = TRUE;
            Status = IcaCdIoControl( pCdModem->hStack,
                                     IOCTL_ICA_STACK_CD_CREATE_ENDPOINT,
                                     &TapiEndpoint,
                                     sizeof(TapiEndpoint),
                                     STACK_ENDPOINT_ADDR(pOutBuffer),
                                     STACK_ENDPOINT_SIZE(OutBufferSize),
                                     pBytesReturned );
            if ( !NT_SUCCESS(Status) )
                goto callbackerror;

            if ( pBytesReturned != NULL && *pBytesReturned != 0 ) {
                *pBytesReturned += sizeof(CDMODEM_ENDPOINT);
                ((PCDMODEM_ENDPOINT)(pOutBuffer))->Length = *pBytesReturned;
            }

            _FillInEndpoint( pCdModem, (PCDMODEM_ENDPOINT) pOutBuffer );

            /*
             *  Send callback complete command to ICA device driver
             */
            Status = IcaCdIoControl( pCdModem->hStack,
                                     IOCTL_ICA_STACK_CALLBACK_COMPLETE,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     NULL );
            break;

            /*
             * The callback has failed
             */
callbackerror:
            DBGPRINT(( "CDMODEM: CdIoControl STACK_CALLBACK failed!!! 0x%x\n", Status));
            /*
             *  Send callback complete command to ICA device driver
             *  so that the stack in NOT left in the CALLBACK IN PROGRESS
             *  state.
             */
            IcaCdIoControl( pCdModem->hStack,
                            IOCTL_ICA_STACK_CALLBACK_COMPLETE,
                            NULL,
                            0,
                            NULL,
                            0,
                            NULL );

            /*
             *  Signal the Disconnect Event so that the TD will return
             *  a close-pending status.
             */
            SetEvent( pCdModem->hDiscEvent );
            break;

        case IOCTL_ICA_STACK_CANCEL_IO :

            if ( pCdModem->hDiscEvent ) {
         /*
          * Tell any TAPI-blocked threads to get out now, by
          * signaling an event that all cdmodem APIs wait on.
          */
               SetEvent( pCdModem->hDiscEvent );
            }
            Status = IcaCdIoControl( pCdModem->hStack,
                                     IoControlCode,
                                     pInBuffer,
                                     InBufferSize,
                                     pOutBuffer,
                                     OutBufferSize,
                                     pBytesReturned );
            break;

        case IOCTL_ICA_STACK_CD_CANCEL_IO :

            if ( pCdModem->hDiscEvent ) {
         /*
          * Tell any TAPI-blocked threads to get out now, by
          * signaling an event that all cdmodem APIs wait on.
          */
               SetEvent( pCdModem->hDiscEvent );
            }
            Status = STATUS_SUCCESS;
            break;

        default :

            /*
             *  Send command to ica device driver
             */
            Status = IcaCdIoControl( pCdModem->hStack,
                                     IoControlCode,
                                     pInBuffer,
                                     InBufferSize,
                                     pOutBuffer,
                                     OutBufferSize,
                                     pBytesReturned );
            break;
    }

    DBGPRINT(( "CDMODEM: CdIoControl[%u], fc 0x%x, 0x%x\n",
               pContext, IoControlCode, Status ));
    return( Status );
}
VOID
_FillInEndpoint( PCDMODEM pCdModem, PCDMODEM_ENDPOINT pMe )
{
    ASSERT( pMe );
    /*
     *  Save the CdModem instance data in the endpoint in order
     *  for it to be supplied to a new stack.  When the new
     *  stack is opened, the endpoint is supplied to ModemOpen
     *  so a new CdModem instance can be created with the old
     *  stack's info.
     */
    pMe->hCommDevice = pCdModem->hCommDevice;
    pMe->hPort       = pCdModem->hPort;
    pMe->hDiscEvent  = pCdModem->hDiscEvent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\confsett.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    CONFSETT.C

Abstract:

    Setting Confirmation screen

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"

static
VOID
SetConfirmDiskString (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Formats and outputs information for display in confirmation dialog box

Arguments:

    IN  HWND    hwndDlg
        handle to dialog box that will display the information.

Return Value:

    None

--*/
{
    LPTSTR  szTextString;

    szTextString = GlobalAlloc (GPTR, SMALL_BUFFER_SIZE);

    if (szTextString != NULL) {
#ifdef JAPAN
//  fixed kkntbug #12382
//      NCAdmin:"[] Make Japanese startup disks" is not functioning.

        if (bJpnDisk)
        _stprintf (szTextString,
            GetStringResource (FMT_LOAD_NET_CLIENT1),
            GetStringResource (
                (pAppInfo->mtBootDriveType == F3_1Pt44_512) ?
                    CSZ_35_HD : CSZ_525_HD),
            pAppInfo->szBootFilesPath);
        else
#endif
        _stprintf (szTextString,
            GetStringResource (FMT_LOAD_NET_CLIENT),
            GetStringResource (
                (pAppInfo->mtBootDriveType == F3_1Pt44_512) ?
                    CSZ_35_HD : CSZ_525_HD),
            pAppInfo->szBootFilesPath);

        SetDlgItemText (hwndDlg, NCDU_CONFIRM_DISK_FORMAT, szTextString);
        FREE_IF_ALLOC (szTextString);
    }
}

static
VOID
SetConfirmTargetString (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Formats and outputs information for display in confirmation dialog box

Arguments:

    IN  HWND    hwndDlg
        handle to dialog box that will display the information.

Return Value:

    None

--*/
{
    LPTSTR  szTextString;
    LPTSTR  szTempString;

    szTextString = GlobalAlloc (GPTR, SMALL_BUFFER_SIZE);
    szTempString = GlobalAlloc (GPTR, SMALL_BUFFER_SIZE);

    if ((szTextString != NULL) && (szTempString != NULL)) {
        _stprintf (szTextString,
            GetStringResource (FMT_CONFIRM_TARGET),
            pAppInfo->piFloppyProtocol.szName,
            pAppInfo->niNetCard.szName);

        if (_tcsnicmp(pAppInfo->piFloppyProtocol.szName, cszTCP, lstrlen(cszTCP)) == 0) {
            if (pAppInfo->bUseDhcp) {
                lstrcat (szTextString, GetStringResource(FMT_USING_DHCP));
            } else {
                // display TCP/IP information.
                _stprintf (szTempString,
                    GetStringResource (FMT_CONFIRM_FLOPPY_IP),
                    pAppInfo->tiTcpIpInfo.IpAddr[0],
                    pAppInfo->tiTcpIpInfo.IpAddr[1],
                    pAppInfo->tiTcpIpInfo.IpAddr[2],
                    pAppInfo->tiTcpIpInfo.IpAddr[3],
                    pAppInfo->tiTcpIpInfo.SubNetMask[0],
                    pAppInfo->tiTcpIpInfo.SubNetMask[1],
                    pAppInfo->tiTcpIpInfo.SubNetMask[2],
                    pAppInfo->tiTcpIpInfo.SubNetMask[3],
                    pAppInfo->tiTcpIpInfo.DefaultGateway[0],
                    pAppInfo->tiTcpIpInfo.DefaultGateway[1],
                    pAppInfo->tiTcpIpInfo.DefaultGateway[2],
                    pAppInfo->tiTcpIpInfo.DefaultGateway[3]);

                lstrcat (szTextString, szTempString);
            }
        }

        _stprintf (szTempString,
            GetStringResource (FMT_INSTALL_TARGET_CLIENT),
            pAppInfo->piTargetProtocol.szName);
        lstrcat (szTextString, szTempString);

        SetDlgItemText (hwndDlg, NCDU_CONFIRM_TARGET_NET, szTextString);
    }

    FREE_IF_ALLOC (szTextString);
    FREE_IF_ALLOC (szTempString);

}

static
VOID
SetConfirmProtocolString (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Formats and outputs information for display in confirmation dialog box

Arguments:

    IN  HWND    hwndDlg
        handle to dialog box that will display the information.

Return Value:

    None

--*/
{

    LPTSTR  szTextString;

    szTextString = GlobalAlloc (GPTR, SMALL_BUFFER_SIZE);

    if (szTextString != NULL) {

        if (pAppInfo->szUsername[0] != 0) {
            _stprintf (szTextString,
                GetStringResource (FMT_LOGON_USERNAME),
                pAppInfo->szUsername,
                pAppInfo->szDomain);
        } else {
            _stprintf (szTextString,
                GetStringResource (FMT_PROMPT_USERNAME),
                pAppInfo->szDomain);
        }
        SetDlgItemText (hwndDlg, NCDU_CONFIRM_PROTOCOL, szTextString);

        FREE_IF_ALLOC (szTextString);
    }
}

static
BOOL
ConfirmSettingsDlg_WM_INITDIALOG (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Dialog Box initialization routine:
        calls routines that format the currently selected options
        for display in the static text fields of the dialog box

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    FALSE  because focus is set in this routin to the OK button

--*/
{
    // prepare menu and locate window
    RemoveMaximizeFromSysMenu (hwndDlg);
    PositionWindow  (hwndDlg);

    //build display strings
    SetConfirmDiskString(hwndDlg);
    SetConfirmTargetString(hwndDlg);
    SetConfirmProtocolString(hwndDlg);

    // clear old Dialog and register current
    PostMessage (GetParent(hwndDlg), NCDU_CLEAR_DLG, (WPARAM)hwndDlg, IDOK);
    PostMessage (GetParent(hwndDlg), NCDU_REGISTER_DLG,
        NCDU_CONFIRM_BOOTDISK_DLG, (LPARAM)hwndDlg);

    // set cursor & focus
    SetCursor (LoadCursor(NULL, IDC_ARROW));
    SetFocus (GetDlgItem(hwndDlg, IDOK));
    return FALSE;
}
static
BOOL
ConfirmSettingsDlg_IDOK (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Called when user selects the OK button in the dialog box.
        Validates the destination path is a bootable floppy and
        presents message box to user if it's not.
        if all tests are succeessful, then the copy file dialog is
        called next. If not, the user is returned to this dialog box
        (mainly so they can press the cancel button and return to
        a previous screen and make corrections.)

Arguments:

    IN HWND hwndDlg
        handle to dialog box window

Return Value:

    TRUE, always.

--*/
{
    int         nMbResult;
    MEDIA_TYPE  mtDest;

    // make sure the target media is present
    if (!MediaPresent (pAppInfo->szBootFilesPath, TRUE)) {
        // media is NOT present so display message and return to dialog message
        DisplayMessageBox (
            hwndDlg,
            NCDU_NO_MEDIA,
            0,
            MB_OK_TASK_EXCL);

        return TRUE; // message processed and return to dialog
    }


    // check destination boot disk one last time before copying files
    if (!IsBootDisk (pAppInfo->szBootFilesPath)) {
        nMbResult = DisplayMessageBox (
            hwndDlg,
            NCDU_DRIVE_NOT_BOOTDISK,
            0,
            MB_OKCANCEL_TASK_EXCL);
        if (nMbResult == IDOK) {
            // the message prompts them to insert a bootable disk
            // then press OK. see if they did...
            if (!IsBootDisk (pAppInfo->szBootFilesPath)) {
                // they still have a "regular" disk so add a message
                // to the exit list
                AddMessageToExitList (pAppInfo, NCDU_COPY_TO_FLOPPY);
            } // else they put in the correct disk so continue
        } else {
            return TRUE;   // return now so they can change floppys
        }
    }

    // check destination drive against boot type
    mtDest = GetDriveTypeFromPath (pAppInfo->szBootFilesPath);
    if (mtDest == Unknown) {
        AddMessageToExitList (pAppInfo, NCDU_CONFIRM_FLOPPY);
    } else if (mtDest != pAppInfo->mtBootDriveType) {
        AddMessageToExitList (pAppInfo, NCDU_COPY_TO_FLOPPY);
    }

    if (pAppInfo->itInstall == OverTheNetInstall) {
        AddMessageToExitList (pAppInfo, NCDU_USERNAME_ACCESS);
        AddMessageToExitList (pAppInfo, NCDU_MAKE_COMP_NAME);
        if (GetBootDiskDosVersion (pAppInfo->szBootFilesPath) < 5) {
            AddMessageToExitList (pAppInfo, NCDU_INSUF_MEM_AT_BOOT);
        }
    }

    PostMessage (GetParent(hwndDlg), NCDU_SHOW_COPYING_DLG, 0, 0);
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    return TRUE;

}

static
BOOL
ConfirmSettingsDlg_WM_COMMAND (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    WM_COMMAND message dispatching routine.
        Dispatches IDCANCEL and IDOK button messages, sends all others
        to the DefDlgProc.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        windows message wParam arg

    IN  LPARAM  lParam
        windows message lParam arg

Return Value:

    TRUE if message is not dispatched (i.e. not processed)
        othewise the value returned by the called routine.

--*/
{

    switch (LOWORD(wParam)) {
        case IDCANCEL:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
                    PostMessage (GetParent(hwndDlg), NCDU_SHOW_SERVER_CFG_DLG, 0, 0);
                    SetCursor(LoadCursor(NULL, IDC_WAIT));
                    return TRUE;

                default:
                    return FALSE;
            }

        case IDOK:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
                    return ConfirmSettingsDlg_IDOK (hwndDlg);

                default:
                    return FALSE;
            }

        default:
            return FALSE;
    }
}

INT_PTR CALLBACK
ConfirmSettingsDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    main dialog proc for this dialog box.
        Processes the following messages:

            WM_INITDIALOG:  dialog box initialization
            WM_COMMAND:     command button/item selected
            WM_PAINT:       for painting icon when minimized
            WM_MOVE:        for saving the new location of the window
            WM_SYSCOMMAND:  for processing menu messages

Arguments:

    IN  HWND    hwndDlg
        handle to dialog box window

    IN  UINT    message
        message id

    IN  WPARAM  wParam
        message wParam arg

    IN  LPARAM  lParam
        message lParam arg

Return Value:

    FALSE if message not processed by this module, otherwise the
        value returned by the message processing routine.

--*/
{
    switch (message) {
        case WM_INITDIALOG: return (ConfirmSettingsDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
        case WM_COMMAND:    return (ConfirmSettingsDlg_WM_COMMAND (hwndDlg, wParam, lParam));
        case WM_PAINT:      return (Dlg_WM_PAINT (hwndDlg, wParam, lParam));
        case WM_MOVE:       return (Dlg_WM_MOVE (hwndDlg, wParam, lParam));
        case WM_SYSCOMMAND: return (Dlg_WM_SYSCOMMAND (hwndDlg, wParam, lParam));
        default:            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\clcreate.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ncadmin.C

Abstract:

    Main entry point and application global functions
    for the Net Client Disk Utility.

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written


--*/
#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
//
//  App include files
//
#include "otnboot.h"
#include "otnbtdlg.h"
//
// global variable initializations
//
PNCDU_DATA   pAppInfo= NULL; // pointer to application data structure
BOOL    bDisplayExitMessages = FALSE;   // TRUE allows exit messages to be
                                        //  displayed when the app terminates
POINT   ptWndPos = {-1, -1};    // top left corner of window

static HINSTANCE hNetMsg = NULL;

#ifdef TERMSRV
TCHAR szCommandLineVal[MAX_PATH]=TEXT("");
TCHAR szHelpFileName[MAX_PATH]=TEXT("");
BOOL bUseCleanDisks=FALSE;
#endif

#ifdef JAPAN
USHORT    usLangID;
#endif

LPCTSTR
GetNetErrorMsg (
    IN  LONG    lNetErr
)
/*++

Routine Description:

    formats an error message number using the NetMsg.DLL or the system
        message DLL if the message isn't found in the NetMsg.DLL. returns
        the string that correspond to the error message or an empty
        string if unable to find a matchin message.

Arguments:

    IN  LONG    lNetErr
        error code to translate.

Return Value:

    Pointer to string containing the error message or an empty string if
        no message was found.

--*/
{
    static TCHAR szBuffer[MAX_PATH];
    LPTSTR  szTemp;
    DWORD   dwError;

    // allocate temporary buffer
    szTemp = GlobalAlloc (GPTR, MAX_PATH_BYTES/2);

    if (szTemp != NULL) {
        // if allocation was successful, then format the error message
        if (FormatMessage (FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
            (LPCVOID)hNetMsg,
            (DWORD)lNetErr,
            GetUserDefaultLangID(),
            szTemp,
            MAX_PATH/2,
            NULL) == 0) {
            dwError = GetLastError();
            // try system message table
            if (FormatMessage (FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                (DWORD)lNetErr,
                GetUserDefaultLangID(),
                szTemp,
                MAX_PATH/2,
                NULL) == 0) {
                dwError = GetLastError();
            }
        }
    } else {
        // if allocation was not successful, then just use an empty string
        szTemp = (LPTSTR)cszEmptyString;
    }
    // now format the whole message for display
    _stprintf (szBuffer,
        GetStringResource (FMT_CREATE_SHARE_ERROR),
        lNetErr, szTemp);

    // free temp buffer
    FREE_IF_ALLOC (szTemp);

    return (LPCTSTR)&szBuffer[0];
}

BOOL
SetSysMenuMinimizeEntryState (
    IN  HWND    hwnd,
    IN  BOOL    bState
)
/*++

Routine Description:

    enables/disable the "Minimize" menu item of the system menu based
        on the value of bState.

Arguments:

    IN  HWND    hwnd
        handle of window (the one to modify the system menu from)

    IN  BOOL    bState
        TRUE = enable item
        FALSE = disable (gray) item

Return Value:

    previous state of menu item

--*/
{
    HMENU   hSysMenu;
    BOOL    bReturn;

    hSysMenu = GetSystemMenu (hwnd, FALSE);

    bReturn = EnableMenuItem (hSysMenu, SC_MINIMIZE,
        (MF_BYCOMMAND | (bState ? MF_ENABLED : MF_GRAYED)));

    if (bReturn == MF_ENABLED) {
        bReturn = TRUE;
    } else {
        bReturn = FALSE;
    }

    return bReturn;
}

BOOL
RemoveMaximizeFromSysMenu (
    IN  HWND    hWnd   // window handle
)
/*++

Routine Description:

    modifies the system menu by:
        Removing the "Size" and "Maximize" entries
        inserting the "About" entry,

Arguments:

    IN  HWND    hWnd
        window handle of window containing the system menu to modify


Return Value:

    TRUE if successfully made changes, otherwise
    FALSE if error occurred

--*/
{
    HMENU   hSysMenu;
    BOOL    bReturn;

    hSysMenu = GetSystemMenu (hWnd, FALSE);

    bReturn = RemoveMenu (hSysMenu, SC_MAXIMIZE, MF_BYCOMMAND);

    if (bReturn) {
        bReturn = RemoveMenu (hSysMenu, SC_SIZE, MF_BYCOMMAND);
    }

    if (bReturn) {
        // append to end of menu
        bReturn = InsertMenu (hSysMenu, 0xFFFFFFF,
            MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        if (bReturn) {
            bReturn = InsertMenu (hSysMenu, 0xFFFFFFFF,
                MF_BYPOSITION | MF_STRING,
                NCDU_ID_ABOUT,
                GetStringResource (CSZ_ABOUT_ENTRY));
        }
    }


    return bReturn;
}

BOOL
LoadClientList (
    IN  HWND    hwndDlg,
    IN  int     nListId,
    IN  LPCTSTR  szPath,
    IN  UINT    nListType,
    OUT LPTSTR  mszDirList
)
/*++

Routine Description:

    Load the specified list box with the names of the network clients
        in the specified list and write the corresponding directory
        names to the MSZ list buffer passed in. The ListItem Data
        value is used to store the element id in the MSZ list that
        contains the directory entry corresponding to the displayed
        list item.

Arguments:

    IN  HWND    hwndDlg,
        handle of dialog box window that contains the list box to fill

    IN  int     nListId
        Dialog Item Id of List Box to fill

    IN  LPCTSTR  szPath
        distribution directory path  (where NCADMIN.INF file is found)

    IN  UINT    nListType
        CLT_OTNBOOT_FLOPPY  Make OTN Boot disk clients
        CLT_FLOPPY_INSTALL  make install floppy clients

    OUT LPTSTR  mszDirList
        pointer to buffer that will recieve list of client dirs
        the call must insure the buffer will be large enough!

Return Value:

    TRUE if successful
    FALSE if error

--*/
{
    // list all subdirs under the distribution path Looking up the
    // text name if it's in the inf

    LPTSTR  szInfName;
    LPTSTR  szSearchList;
    LPTSTR  szRealName;
    LPTSTR  szFilterName;
    LPTSTR  szThisDir;
    BOOL    bReturn = FALSE;
    DWORD   dwDirIndex = 0;
    int     nItemIndex;
    DWORD   dwReturn;
    LPTSTR  szKey;

    szInfName = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szSearchList = GlobalAlloc (GPTR, SMALL_BUFFER_SIZE * sizeof(TCHAR));
    szRealName = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szFilterName = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if ((szInfName != NULL) &&
        (szSearchList != NULL) &&
        (szFilterName != NULL) &&
        (szRealName != NULL)) {
        // get key name to use

        if (nListType == CLT_OTNBOOT_FLOPPY) {
            szKey = (LPTSTR) cszOTN;
        } else {
            szKey = (LPTSTR) cszDiskSet;
        }

        // make .INF file name
        lstrcpy (szInfName, szPath);
        if (szInfName[lstrlen(szInfName)-1] != cBackslash) lstrcat(szInfName, cszBackslash);
        lstrcat (szInfName, cszAppInfName);

        // clear old contents and start over
        SendDlgItemMessage (hwndDlg, nListId,
            LB_RESETCONTENT, 0, 0);
        //clear "item data" buffer
        *(PDWORD)mszDirList = 0L; // clear first 4 bytes of string

        // get list of client dirs & names from INF
        // for each item, make sure there's a subdir
        // if so, then add the client to the list and the dir to the dir list

        dwReturn = QuietGetPrivateProfileString (szKey, NULL, cszEmptyString,
            szSearchList, SMALL_BUFFER_SIZE, szInfName);

        if (dwReturn > 0) {
            for (szThisDir = szSearchList;
                *szThisDir != 0;
                szThisDir += lstrlen(szThisDir) + 1) {
                // make dir path
                // is it real?
                lstrcpy (szRealName, szPath);
                if (szRealName[lstrlen(szRealName)-1] != cBackslash) lstrcat(szRealName, cszBackslash);
                lstrcat (szRealName, szThisDir);
                if (IsPathADir(szRealName)) {
                    // this is a real path so
                    // get string and load data to list box
                    dwReturn = QuietGetPrivateProfileString (szKey,
                        szThisDir, szThisDir, szFilterName, MAX_PATH,
                        szInfName);
                    // save dir name
                    AddStringToMultiSz (mszDirList, szThisDir);
                    // add tje display name to the list box
                    SendDlgItemMessage (hwndDlg, nListId,
                        LB_ADDSTRING, 0, (LPARAM)szFilterName);
                    // find entry in list box
                    nItemIndex = (int)SendDlgItemMessage (hwndDlg, nListId,
                        LB_FINDSTRING, 0, (LPARAM)szFilterName);
                    // item data indicates which entry in the msz the
                    // corresponding dir name resides.
                    SendDlgItemMessage (hwndDlg, nListId,
                        LB_SETITEMDATA, nItemIndex, (LPARAM)dwDirIndex);
                    dwDirIndex++;
                }
            } // end of for list
        }

        // Get information about whether to insist on clean diskettes
        dwReturn = QuietGetPrivateProfileString (cszDiskOptions, cszUseCleanDisk, cszEmptyString,
            szSearchList, SMALL_BUFFER_SIZE, szInfName);

        if (dwReturn > 0 && lstrcmpi(szSearchList, cszUseCleanDiskYes)==0) {
            bUseCleanDisks = TRUE;
        }
        else {
            bUseCleanDisks = FALSE;
        }
    } else {
        bReturn = FALSE;
        SetLastError (ERROR_OUTOFMEMORY);
    }

    FREE_IF_ALLOC (szInfName);
    FREE_IF_ALLOC (szSearchList);
    FREE_IF_ALLOC (szRealName);
    FREE_IF_ALLOC (szFilterName);

    return bReturn;
}

BOOL
EnableExitMessage (
    IN  BOOL    bNewState
)
/*++

Routine Description:

    Exported function to enable/disable the display of the "exit" messages

Arguments:

    IN  BOOL    bNewState
        TRUE    Enable display  of exit messages
        FALSE   disable display of exit messages

Return Value:

    previous value of flag

--*/
{
    BOOL    bReturn = bDisplayExitMessages;
    bDisplayExitMessages = (bNewState != 0 ? TRUE : FALSE);
    return  bReturn;
}

BOOL
AddMessageToExitList (
    IN  PNCDU_DATA  pData,
    IN  UINT        nMessage
)
/*++

Routine Description:

    adds message to message list structure in global data block if message
        is unique (i.e. not already in list)

Arguments:

    IN  PNCDU_DATA  pData
        data structure to add message to

    IN  UINT        nMessage
        ID of message to add (ID of string resource)

Return Value:

    TRUE if message added
    FALSE if not

--*/
{
    DWORD   dwIndex;
    dwIndex = 0;

    while (pData->uExitMessages[dwIndex] != 0) {
        if (pData->uExitMessages[dwIndex] == nMessage) {
            // if it's already in the list then leave now.
        return TRUE;
        }
        if (dwIndex < MAX_EXITMSG-1) {
            // if not at the end of the list then continue
            dwIndex++;
        } else {
            // if this is the end of the list, the leave now.
            return FALSE;
        }
    }
    pData->uExitMessages[dwIndex] = nMessage;   // add it to the list
    return TRUE;                                // and leave
}

int
PositionWindow (
    IN  HWND    hwnd
)
/*++

Routine Description:

    function to locate top-left corner of window in arg list in the
        same position as the last window

Arguments:

    IN  HWND    hwnd
        handle of window to position

Return Value:

    value returned by window positioning function called

--*/
{
    POINT   ptWndCorner;

    if ((ptWndPos.x == -1) || (ptWndPos.y == -1)) {
        // position has not been initialized so center in desktop
        return CenterWindow (hwnd, GetDesktopWindow());
    } else {
        ptWndCorner = ptWndPos;

        // move to new location
        return SetWindowPos (hwnd,
            NULL,
            ptWndCorner.x,
            ptWndCorner.y,
            0,0,
            SWP_NOSIZE | SWP_NOZORDER);
    }
}

int
DisplayMessageBox (
    IN  HWND    hWndOwner,
    IN  UINT    nMsgId,
    IN  UINT    nTitleId,
    IN  UINT    nStyle
)
/*++

Routine Description:

    displays message box containing a resource string as the text and
        title rather than a static string.

Arguments:

    IN  HWND    hWndOwner
        hwnd of owner window

    IN  UINT    nMsgId
        Resource String ID of message string

    IN  UINT    nTitleId
        Resource String ID of title, 0 = use app name

    IN  UINT    nStyle
        Message box style bits

Return Value:

    value returned by MessageBox API function

--*/
{
    int     nReturn;
    LPTSTR  szMessageString;
    LPTSTR  szTitleString;
    HINSTANCE    hInst;

    // allocate string buffers
    szTitleString = (LPTSTR)GlobalAlloc(GPTR, (MAX_PATH_BYTES));
    szMessageString = (LPTSTR)GlobalAlloc(GPTR, (SMALL_BUFFER_SIZE * sizeof(TCHAR)));

#ifdef TERMSRV
       if (_tcschr(GetCommandLine(),TEXT('/')) != NULL )
       {
          if ((szMessageString != NULL) &&
              (szTitleString != NULL)) {
              hInst = (HINSTANCE)GetWindowLongPtr(hWndOwner,GWLP_HINSTANCE);
              LoadString (hInst,
                  ((nTitleId != 0) ? nTitleId : WFC_STRING_BASE),
                  szTitleString,
                  MAX_PATH);

              LoadString (hInst,
                  nMsgId,
                  szMessageString,
                  SMALL_BUFFER_SIZE);

              nReturn = MessageBox (
                  hWndOwner,
                  szMessageString,
                  szTitleString,
                  nStyle);
          } else {
              nReturn = 0;
          }
       }
       else
       {
#endif // TERMSRV

        if ((szMessageString != NULL) &&
            (szTitleString != NULL)) {
            hInst = (HINSTANCE)GetWindowLongPtr(hWndOwner,GWLP_HINSTANCE);
            LoadString (hInst,
                ((nTitleId != 0) ? nTitleId : STRING_BASE),
                szTitleString,
                MAX_PATH);

            LoadString (hInst,
                nMsgId,
                szMessageString,
                SMALL_BUFFER_SIZE);

            nReturn = MessageBox (
                hWndOwner,
                szMessageString,
                szTitleString,
                nStyle);
        } else {
            nReturn = 0;
        }
#ifdef TERMSRV
    }
#endif // TERMSRV

    FREE_IF_ALLOC (szMessageString);
    FREE_IF_ALLOC (szTitleString);

    return nReturn;
}

VOID
InitAppData (
    IN  PNCDU_DATA  pData
)
/*++

Routine Description:

    initializes the fields in the application data structure

Arguments:

    pointer to structure to initialize

Return Value:

    None

--*/
{
    pData->mtLocalMachine = UnknownSoftwareType;
    pData->hkeyMachine = HKEY_LOCAL_MACHINE;
    pData->itInstall = OverTheNetInstall;
    pData->bUseExistingPath = FALSE;
    pData->shShareType = ShareExisting;
    pData->szDistShowPath[0] = 0;
    pData->szDistPath[0] = 0;
    pData->szDestPath[0] = 0;
    pData->stDistPathType = SourceUndef;
    pData->mtBootDriveType = F3_1Pt44_512;
    pData->bRemoteBootReqd = FALSE;
    pData->niNetCard.szName[0] = 0;
    pData->niNetCard.szInf[0] = 0;
    pData->niNetCard.szInfKey[0] = 0;
    pData->szBootFilesPath[0] = 0;
    pData->piFloppyProtocol.szName[0] = 0;
    pData->piFloppyProtocol.szKey[0] = 0;
    pData->piFloppyProtocol.szDir[0] = 0;
    pData->piTargetProtocol.szName[0] = 0;
    pData->piTargetProtocol.szKey[0] = 0;
    pData->piTargetProtocol.szDir[0] = 0;
    pData->szUsername[0] = 0;
    pData->szDomain[0] = 0;
    pData->bUseDhcp = TRUE;
    pData->tiTcpIpInfo.IpAddr[0] = 0;
    pData->tiTcpIpInfo.IpAddr[1] = 0;
    pData->tiTcpIpInfo.IpAddr[2] = 0;
    pData->tiTcpIpInfo.IpAddr[3] = 0;
    pData->tiTcpIpInfo.SubNetMask[0] = 0;
    pData->tiTcpIpInfo.SubNetMask[1] = 0;
    pData->tiTcpIpInfo.SubNetMask[2] = 0;
    pData->tiTcpIpInfo.SubNetMask[3] = 0;
    pData->tiTcpIpInfo.DefaultGateway[0] = 0;
    pData->tiTcpIpInfo.DefaultGateway[1] = 0;
    pData->tiTcpIpInfo.DefaultGateway[2] = 0;
    pData->tiTcpIpInfo.DefaultGateway[3] = 0;
    pData->szFloppyClientName[0] = 0;
    pData->uExitMessages[0] = 0;
}

int APIENTRY
WinMain(
    IN  HINSTANCE hInstance,
    IN  HINSTANCE hPrevInstance,
    IN  LPSTR     szCmdLine,
    IN  int       nCmdShow
)
/*++

Routine Description:

    Program entry point for LoadAccount application. Initializes Windows
        data structures and begins windows message processing loop.

Arguments:

    Standard WinMain arguments

ReturnValue:

    0 if unable to initialize correctly, or
    wParam from WM_QUIT message if messages processed

--*/
{
    HWND        hWnd; // Main window handle.
    MSG         msg;
    LPTSTR      szCaption;
    HANDLE      hMap;

#ifdef TERMSRV
    LPTSTR lpszCommandStr;
    TCHAR szProfilename[MAX_PATH + 1];
    DWORD dwLen;
#endif // TERMSRV

    hMap = CreateFileMapping(INVALID_HANDLE_VALUE,
                               NULL, PAGE_READONLY, 0, 32,
                               szAppName);

    if(hMap)
    {
        if( GetLastError() == ERROR_ALREADY_EXISTS )
        {
            HWND hwnd = FindWindow(szAppName, NULL);
            if(IsIconic(hwnd))
            {
                ShowWindow(hwnd, SW_SHOWNORMAL);
            }
            SetForegroundWindow(hwnd);
            CloseHandle(hMap);
            hMap = NULL;
            return FALSE; // Other instance of the app running?
        }
    }

    if (!RegisterMainWindowClass(hInstance)) {
        return FALSE;
    }

    szCaption = GlobalAlloc (GPTR, (MAX_PATH * sizeof(TCHAR)));
    if (szCaption != NULL) {
#ifdef TERMSRV
       if (_tcschr(GetCommandLine(),TEXT('/')) != NULL ) {
            LoadString (hInstance, WFC_STRING_BASE, szCaption, MAX_PATH);
       }
       else {
            return FALSE;   // only allow terminal server client creator works.
       }
#else // TERMSRV
            LoadString (hInstance, STRING_BASE, szCaption, MAX_PATH);
#endif // TERMSRV
    } else {
        // not worth bailing out here, yet...
        szCaption = (LPTSTR)cszEmptyString;
    }

    hNetMsg = LoadLibrary (cszNetMsgDll);

    // initialize application data structure

    pAppInfo = GlobalAlloc (GPTR, sizeof(NCDU_DATA));
    if (pAppInfo != NULL) {
        InitAppData (pAppInfo);
    } else {
        // unable to allocate memory for applicattion data so bail out
        return FALSE;
    }

#ifdef JAPAN
    usLangID = PRIMARYLANGID(GetSystemDefaultLangID());
#endif

    // Create a main window for this application instance.
    // and position it off the screen

    hWnd = CreateWindowEx(
        0L,                 // No extended attributes
        szAppName,              // See RegisterClass() call.
        szCaption,          // caption
        (DWORD)(WS_OVERLAPPEDWINDOW),   // Window style.
        CW_USEDEFAULT,      // Size is set later
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        (HWND)NULL,                 // Overlapped windows have no parent.
        (HMENU)NULL,            // Use the window class menu.
        hInstance,              // This instance owns this window.
        NULL                    // We don't use any data in our WM_CREATE
    );

    // If window could not be created, return "failure"
    if (!hWnd) {
            return (FALSE);
    }
    // This application never shows it's main window but it's still
    // active!

    ShowWindow(hWnd, SW_SHOW);  // Show the window
    SetWindowText (hWnd, szCaption);    // update caption bar
    UpdateWindow(hWnd);         // Sends WM_PAINT message

#ifdef TERMSRV

    /* If using a command line parameter go get the path */

    lpszCommandStr = _tcschr(GetCommandLine(),TEXT('/'));

    if (lpszCommandStr != NULL ) {
       _tcscpy(szCommandLineVal, lpszCommandStr+1);
    }

    //
    // get help file name.
    //

    _tcscpy( szProfilename, szCommandLineVal );

    dwLen = _tcslen(szProfilename);
    if( szProfilename[dwLen - 1] != _T('\\') ) {

        szProfilename[dwLen++] = _T('\\');
        szProfilename[dwLen] = _T('\0');
    }

    _tcscat( szProfilename, cszOtnBootInf );

    dwLen =
        QuietGetPrivateProfileString(
            cszHelpSession,
            cszHelpFileNameKey,
            cszHelpFile,
            szHelpFileName,
            MAX_PATH,
            szProfilename );

    if( _tcscmp( szHelpFileName, cszHelpFile ) == 0 ) {
        szHelpFileName[0] = _T('\0');
    }

#endif // TERMSRV

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while (GetMessage(&msg, // message structure
            NULL,   // handle of window receiving the message
            0,      // lowest message to examine
            0))     // highest message to examine
    {
        TranslateMessage(&msg);// Translates virtual key codes
        DispatchMessage(&msg); // Dispatches message to window
    }

    if (szCaption != cszEmptyString) FREE_IF_ALLOC (szCaption);
    FREE_IF_ALLOC (pAppInfo);

    if (hNetMsg != NULL) FreeLibrary (hNetMsg);

    return (int)(msg.wParam); // Returns the value from PostQuitMessage
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\copyfile.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    COPYFILE.C

Abstract:

    file copy conf. dialog

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"
//
//  Debugging defines
//
#define SHOW_DEBUG_INFO     0

// local windows message

#define     NCDU_START_FILE_COPY    (WM_USER +101)

//
//  Static data for this module
//
static  BOOL    bCopying;       // 1= copying, 0 = done
static  DWORD   dwBytesCopied;  // running total of bytes copied
static  DWORD   dwTotalCBytes;  // total bytes divided by 100 (for % computation)
static  DWORD   dwCurrentPercent; // current percent copied

#define MAX_DOS_FILENAME_LENGTH (8 * sizeof(TCHAR))
#define MAX_DOS_FILE_EXT_LENGTH (3 * sizeof(TCHAR))

static
BOOL
DisplayScrunchedFilePath (
    IN  HWND    hWnd,
    IN  LPCTSTR szInPath
)
/*++

Routine Description:

    sets the window text of hWnd to be the "scrunched" version of
        the path string in szInPath. If the path string is too long
        to fit in a single line of hWnd, then directories are removed
        from the path until it does fit. The directories are removed
        from the "top" down. The root drive\dir is kept as is the
        filename and as many directories that will fit.

Arguments:

    IN  HWND    hWnd
        handle of window to put text in

    IN  LPCTSTR szInPath
        path to display in window

Return Value:

    TRUE    if no error
    FALSE   if error

--*/
{
    LPTSTR  szOutPath;
    RECT    rWindow;
    LONG    lWindowWidth;
    HDC     hDC;
    SIZE    sText;
    LONG    lRootBs, lRootBsCount;

    LPTSTR  szRootBs, szFileBs, szSrc, szDest, szDotsBs;

    GetWindowRect (hWnd, &rWindow); // get window size
    lWindowWidth = rWindow.right - rWindow.left;

    hDC = GetDC (hWnd);             // get DC for window

    szOutPath = GlobalAlloc (GPTR, ((lstrlen(szInPath) + 8) * sizeof(TCHAR)));
    if (szOutPath == NULL) {
        return FALSE;
    } else {
        //buffer allocation succeeded, so copy path to local buffer
        lstrcpy (szOutPath, szInPath);
    }

    if (IsUncPath(szOutPath)) {
        lRootBs = 4;    // the 4th backslash is the "Root" backslash for UNC
    } else {
        lRootBs = 1;    // for DOS file paths, the 1st backslash is the Root
    }

    GetTextExtentPoint32(hDC,
        szOutPath, lstrlen(szOutPath), &sText);

    szSrc = szDest = szOutPath;
    szDotsBs = szRootBs = szFileBs = NULL;
    lRootBsCount = 0;

    while (sText.cx > lWindowWidth) {
        // take dirs out until it fits
        // go through path string
        while (*szSrc != 0) {
            // see if we've passed the root
            if (szRootBs == NULL) {
                if (*szSrc == cBackslash) lRootBsCount++;
                if (lRootBsCount == lRootBs) szDotsBs = szRootBs = szDest;
            } else {
                // root's done, now were; working on the pathname
                // so we'll scope out the rest of the string
                if (*szSrc == cBackslash) szFileBs = szDest;
            }
            *szDest++ = *szSrc++;
        }
        if (szRootBs == NULL) {
            // then this is a bogus path so exit now
            break;
        }
        if (szFileBs == NULL) {
            // if the File backslash didn't get defined, then the file is
            // in the root directory and we should leave now, since there
            // isn't much to do about it.
            szFileBs = szRootBs;
            break;
        }
        // now yank a dir or two (more than one will be pulled if the dir
        // name is < 4 chars
        // if a directory hasn't been pulled, yet, go ahead
        // and take one out
        // initialize the pointers
        if (szRootBs == szDotsBs) {
            // then the ... havent been added so see if they'll fit and add em
            if ((szDotsBs+4) < szFileBs) {
                // they'll fit so addem
                szDest = szDotsBs + 1;
                *szDest++ = cPeriod;
                *szDest++ = cPeriod;
                *szDest++ = cPeriod;
                *szDest = cBackslash;
                szDotsBs = szDest;
                szSrc = ++szDest;
            } else {
                // no room to left to pull files
                break;
            }
        } else {
            // dot's have already been added so set pointers
            szSrc = szDest = szDotsBs+1;
        }
        // go to next dir
        while (*szSrc++ != cBackslash);
        // copy the rest of the string
        while (*szSrc != 0) *szDest++ = *szSrc++;

        *szDest = 0; // terminate the new string

        // get size of new string
        GetTextExtentPoint32(hDC,
            szOutPath, lstrlen(szOutPath), &sText);
    }

    // the string is as small as it's going to get so set the window text

    SetWindowText (hWnd, szOutPath);

    FREE_IF_ALLOC (szOutPath);

    return TRUE;

}

LONG
CreateDirectoryFromPath (
    IN  LPCTSTR                 szPath,
    IN  LPSECURITY_ATTRIBUTES   lpSA
)
/*++

Routine Description:

    Creates the directory specified in szPath and any other "higher"
        directories in the specified path that don't exist.

Arguments:

    IN  LPCTSTR szPath
        directory path to create (assumed to be a DOS path, not a UNC)

    IN  LPSECURITY_ATTRIBUTES   lpSA
        pointer to security attributes argument used by CreateDirectory


Return Value:

    TRUE    if directory(ies) created
    FALSE   if error (GetLastError to find out why)

--*/
{
    LPTSTR   szLocalPath;
    LPTSTR   szEnd;
    LONG     lReturn = 0L;

    szLocalPath = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szLocalPath == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    } else {
        // so far so good...
        SetLastError (ERROR_SUCCESS); // initialize error value to SUCCESS
    }

    lstrcpy (szLocalPath, szPath);

    szEnd = &szLocalPath[3];

    if (*szEnd != 0) {
        // then there are sub dirs to create
        while (*szEnd != 0) {
            // go to next backslash
            while ((*szEnd != cBackslash) && (*szEnd != 0)) szEnd++;
            if (*szEnd == cBackslash) {
                // terminate path here and create directory
                *szEnd = 0;
                if (!CreateDirectory (szLocalPath, lpSA)) {
                    // see what the error was and "adjust" it if necessary
                    if (GetLastError() == ERROR_ALREADY_EXISTS) {
                        // this is OK
                        SetLastError (ERROR_SUCCESS);
                    } else {
                        lReturn = 0;
                    }
                } else {
                    // directory created successfully so update count
                    lReturn++;
                }
                // replace backslash and go to next dir
                *szEnd++ = cBackslash;
            }
        }
        // create last dir in path now
        if (!CreateDirectory (szLocalPath, lpSA)) {
            // see what the error was and "adjust" it if necessary
            if (GetLastError() == ERROR_ALREADY_EXISTS) {
                // this is OK
                SetLastError (ERROR_SUCCESS);
                lReturn++;
            } else {
                lReturn = 0;
            }
        } else {
            // directory created successfully
            lReturn++;
        }
    } else {
#ifndef TERMSRV
        // else this is a root dir only so return success.
        lReturn = 1;
#else // TERMSRV
        // for terminal server return FALSE.
        lReturn = 0;
#endif // TERMSRV

    }
    FREE_IF_ALLOC (szLocalPath);
    return lReturn;

}

static
DWORD
UpdatePercentComplete (
    IN  HWND    hwndDlg,
    IN  LPCTSTR  szFileName
)
/*++

Routine Description:

    Adds the size of the specified file to the running total of
        bytes copied and computes the current percentage of total
        copied. The display string is updated if the new percentage is
        different from the current percentage

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog Box window

    IN  LPTSTR  szFileName
        filename (& path) of file whose size should be added to the
        current total bytes copied value.

Return Value:

    returns the current percentage of total bytes that have been
        copied (including this file)

--*/
{
    HANDLE  hFile;

    DWORD   dwFileSizeLow, dwFileSizeHigh;
    DWORD   dwPercent = 0;

    LPTSTR  szOutBuff;

    szOutBuff = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szOutBuff == NULL) return 0;

    if (dwTotalCBytes == 0) {
        SetDlgItemText (hwndDlg, NCDU_PERCENT_COMPLETE,
            GetStringResource (FMT_WORKING));
        dwPercent = 0;
    } else {
        hFile = CreateFile (
            szFileName,
            GENERIC_READ,
            (FILE_SHARE_READ | FILE_SHARE_WRITE),
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        if (hFile != INVALID_HANDLE_VALUE) {
            dwFileSizeLow = GetFileSize (hFile, &dwFileSizeHigh);
            if (dwFileSizeLow != 0xFFFFFFFF) {
                dwBytesCopied  += dwFileSizeLow;
                dwPercent = dwBytesCopied / dwTotalCBytes;
                if (dwPercent != dwCurrentPercent) {
                    if (dwPercent > 100) dwPercent = 100;
                    dwCurrentPercent = dwPercent;
                    _stprintf (szOutBuff,
                        GetStringResource (FMT_PERCENT_COMPLETE),
                        dwPercent);
                    SetDlgItemText (hwndDlg, NCDU_PERCENT_COMPLETE, szOutBuff);
                }
            }
            CloseHandle (hFile);
        }
    }

    FREE_IF_ALLOC (szOutBuff);

    return dwPercent;
}

static
BOOL
IsDosFileName (
    LPCTSTR   szName
)
/*++

Routine Description:

    examines string to see if it conforms to the DOS filename length
        conventions

Arguments:

        szName  filename and extension to parse


Return Value:

    TRUE     if it passes
    FALSE   if not

--*/
{
    LPTSTR   szNameBegin, szNameEnd;
    LPTSTR   szExtBegin, szExtEnd;
    LPTSTR   szDot;
    LPTSTR   szTmp;
    LPTSTR   szBack_slash;


    szBack_slash = szDot = NULL;
    szTmp = (LPTSTR)szName;

    while (*szTmp) {
        if (*szTmp == '.') szDot = szTmp;
        if (*szTmp == '\\') szBack_slash = szTmp;
        szTmp++;
    }

    // find beginning and end of each component

    if (szBack_slash) {
        // backslash char found in string, pointer points to
        // last occurance, name starts immediately after
        szNameBegin = szBack_slash + 1;
    } else {
        // no backslash char found so name starts at beginning
        // of string
        szNameBegin = (LPTSTR)szName;
    }

    if (szDot) {
        // dot char found in string
        if (szDot == szName) {
            // it's the first char in the string (i.e.
            // no filename)
            szNameEnd = (LPTSTR)szName;
            // a dot was found, then the extension starts right
            // after the dot
            szExtBegin = szDot + 1;
        } else if (szDot < szNameBegin) {
            // then there's no dot in the filename, but
            // it's somewhere else in the path
            szNameEnd = szTmp;
            // no dot so ext "begins" at the end of the string
            szExtBegin = szTmp;
        } else {
            // not the first char, and not before the filename
            // so the name ends with the dot
            szNameEnd = szDot;
            // a dot was found, then the extension starts right
            // after the dot
            szExtBegin = szDot + 1;
        }
    } else {
        // no dot was found in the string so there's no
        // file extension in this string. The end of the string
        // must be the end of the file name , and the beginning of
        // the extension (and also the end of the extension)
        szNameEnd = szTmp;
        szExtBegin = szTmp;
    }

    // the end of the file extension is always the end of the string
    szExtEnd = szTmp;

    // check the components for correct length:
    // 0 <= filename <= MAX_DOS_FILENAME_LENGTH (8)
    // 0 <= ext <= MAX_DOS_FILE_EXT_LENGTH (3)

    if ((LONG)(szNameEnd-szNameBegin) <= MAX_DOS_FILENAME_LENGTH) {
        // name is ok, check extension
        if ((LONG)(szExtEnd-szExtBegin) <= MAX_DOS_FILE_EXT_LENGTH) {
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}

static
LONG
CopyDir (
    IN  HWND        hwndDlg,
    IN  LPCTSTR     szFromDir,
    IN  LPCTSTR     szToDir,
    IN  DWORD       dwFlags,
    IN  PDWORD      pdwFiles,
    IN  PDWORD      pdwDirs
)
/*++

Routine Description:

    Copies all files in the specified from directory to the specified
        to directory. Specific behavior is controlled by the flags as
        documented below.

Arguments:

    hwndDlg         window handle to dialog box
    szFromDir       directory containing files to copy
    szToDir         directory to recieve files
    dwFlags         Flags that control routine's behavior

                    CD_FLAGS_COPY_SUB_DIR   copies all sub dir's as well
                    CD_FLAGS_DONT_CREATE    default is to create dirs as needed
                    CD_FLAGS_IGNORE_ATTR    ignore attributes
                    CD_FLAGS_COPY_ATTR      copy attributes as well (default
                                                is for dest fils to be normal)
                    CD_FLAGS_IGNORE_ERROR   continue with copy even if errors occur
                    CD_FLAGS_LONG_NAMES     allows filenames longer than FAT
                    other bits are ignored
    pdwFiles        Pointer to DWORD that will get count of files copied
    pdwDirs         Pointer to DWORD that will get count of dirs created

Return Value:

    Win 32 status value
        ERROR_SUCCESS   routine completed normally

--*/
{
    LPTSTR   szFromPathName; // full path of FromDir
    LPTSTR   szFromFileName; // full path of source file
    LPTSTR   szFromFileStart; // pointer to where to attach file name to path
    LPTSTR   szSearchName;   // search file name
    LPTSTR   szToPathName;   // full path of destdir
    LPTSTR   szToFileName;   // full path of detination file name
    LPTSTR   szToFileStart;  // pointer to where to attach file name to path

    DWORD   dwFileAttributes;   // attributes of source file

    PWIN32_FIND_DATA    pwfdSearchData; // buffer used for file find ops
    HANDLE              hSearch;

    int     nMbResult;

    BOOL    bStatus;
    LONG    lStatus;

    MSG msg;

    DWORD   dwFileCopyCount;    // local counter variables
    DWORD   dwDirCreateCount;


    // allocate buffers

    szFromPathName = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH * sizeof(TCHAR));
    szFromFileName = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH * sizeof(TCHAR));
    szSearchName = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH * sizeof(TCHAR));
    szToPathName = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH * sizeof(TCHAR));
    szToFileName = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH * sizeof(TCHAR));
    pwfdSearchData = (PWIN32_FIND_DATA)GlobalAlloc (GPTR, sizeof(WIN32_FIND_DATA));

    if (szFromPathName &&
        szFromFileName &&
        szSearchName &&
        szToPathName &&
        szToFileName &&
        pwfdSearchData) {

        // initialize counter fields (to support recursive calls)

        if (pdwFiles != NULL) {
            dwFileCopyCount = *pdwFiles;
        } else {
            dwFileCopyCount = 0;
        }

        if (pdwDirs != NULL) {
            dwDirCreateCount = *pdwDirs;
        } else {
            dwDirCreateCount = 0;
        }
        // get full pathnames of from & to files

        GetFullPathName (
            szFromDir,
            (DWORD)GlobalSize(szFromPathName) / sizeof(TCHAR),
            szFromPathName,
            NULL);

        GetFullPathName (
            szToDir,
            (DWORD)GlobalSize(szToPathName) / sizeof(TCHAR),
            szToPathName,
            NULL);

        lStatus = ERROR_SUCCESS;
    } else {
        lStatus = ERROR_OUTOFMEMORY;
    }

    if (lStatus == ERROR_SUCCESS) {
        // validate from dir and create target if valid

        dwFileAttributes = QuietGetFileAttributes (
            szFromPathName);

        if ((dwFileAttributes != 0xFFFFFFFF) &&
            (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            // from directory is for real so create or check
            // target dir now

            if (dwFlags & CD_FLAGS_DONT_CREATE) {
                // if don't create, then at least validate
                dwFileAttributes = QuietGetFileAttributes (
                    szToPathName);

                if ((dwFileAttributes != 0xFFFFFFFF) &&
                    (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    lStatus = ERROR_SUCCESS;
                } else {
                    lStatus = ERROR_DIRECTORY;
                }
            } else {
                // create sub dirs if necessary
                if (!(dwFlags & CD_FLAGS_LONG_NAMES)) {
                    // check to see if name conforms to DOS 8.3 format
                    if (!IsDosFileName(szFromPathName)) {
                        lStatus = ERROR_FILENAME_EXCED_RANGE;
                    } else {
                        lStatus = ERROR_SUCCESS;
                    }

                } else {
                    lStatus = ERROR_SUCCESS;
                }

                if (lStatus == ERROR_SUCCESS) {
                    lStatus = CreateDirectoryFromPath (
                        szToPathName, NULL);
                    if (lStatus == 0) {
                        lStatus = GetLastError();
                        if (lStatus == ERROR_ALREADY_EXISTS) {
                            // this is OK
                            lStatus = ERROR_SUCCESS;
                            // no dirs were created so don't change the
                            // count.
                        }
                    } else {
                        // if lStatus is not 0, then it's then number of
                        // directories that were created
                        dwDirCreateCount += lStatus;
                        // now set it to the Error Status value the rest of the function
                        // is expecting
                        lStatus = ERROR_SUCCESS;
                    }
                }
            }
        } else {
            lStatus = ERROR_DIRECTORY;
        }
    }

    if (lStatus == ERROR_SUCCESS) {
        // if target directory is valid, then
        // create filename bases and start copying files

        lstrcpy (szFromFileName, szFromPathName);
        if (szFromFileName[lstrlen(szFromFileName)-1] != cBackslash) lstrcat (szFromFileName, cszBackslash);
        szFromFileStart = szFromFileName + lstrlen(szFromFileName);

        lstrcpy (szToFileName, szToPathName);
        if (szToFileName[lstrlen(szToFileName)-1] != cBackslash) lstrcat (szToFileName, cszBackslash);
        szToFileStart = szToFileName + lstrlen(szToFileName);

        // create search name

        lstrcpy (szSearchName, szFromPathName);
        lstrcat (szSearchName, cszWildcardFile);

        hSearch = FindFirstFile (
            szSearchName,
            pwfdSearchData);

        if (hSearch != INVALID_HANDLE_VALUE) {
            lStatus = ERROR_SUCCESS;
            bStatus = TRUE;
            while (((lStatus == ERROR_SUCCESS) && bStatus)  && bCopying) {
                // check & save file attributes of each file, if not
                // normal, then ignore unless flag set
                //
                lstrcpy (szFromFileStart, pwfdSearchData->cFileName); //make full path

                if (!DotOrDotDotDir(pwfdSearchData->cFileName)) { //ignore these dirs
                    dwFileAttributes = QuietGetFileAttributes(
                        szFromFileName);

                    if (dwFileAttributes != 0xFFFFFFFF) {
                        // attributes are valid, so
                        // make full pathname of source file found
                        // and dest. file to be created
                        lstrcpy (szToFileStart, pwfdSearchData->cFileName); //make full path

                        if (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                            // if it's a dir and subdirs is true, then
                            // copy them too if the copy sub dir flag is set

                            if (dwFlags & CD_FLAGS_COPY_SUB_DIR) {
                                lStatus = CopyDir (
                                    hwndDlg,
                                    szFromFileName,
                                    szToFileName,
                                    dwFlags,
                                    &dwFileCopyCount,
                                    &dwDirCreateCount);
                            } else {
                                // ignore directories if flag not set
                            }
                        } else { // not a dir, so see if we can copy it
                            if (lStatus == ERROR_SUCCESS) {
                                // copy the file if either the ignore bit is
                                // set or the attributes are OK
                                //
                                if (!(dwFlags & CD_FLAGS_LONG_NAMES)) {
                                    // check to see if name conforms to DOS 8.3 format
                                    if (!IsDosFileName(szFromFileName)) {
                                        lStatus = ERROR_FILENAME_EXCED_RANGE;
                                    } else {
                                        lStatus = ERROR_SUCCESS;
                                    }
                                }

                                DisplayScrunchedFilePath (
                                    GetDlgItem (hwndDlg, NCDU_FROM_PATH),
                                    (LPCTSTR)_tcslwr(szFromFileName));

                                DisplayScrunchedFilePath (
                                    GetDlgItem (hwndDlg, NCDU_TO_PATH),
                                    (LPCTSTR)_tcslwr(szToFileName));

                                if (lStatus == ERROR_SUCCESS) {
                                    bStatus = CopyFile(
                                        szFromFileName,
                                        szToFileName,
                                        FALSE);         // overwrite existing file

                                    //verify file was created
                                    if (bStatus) {
                                        if (QuietGetFileAttributes(szToFileName) == 0xFFFFFFFF) {
                                            // unable to read attributes of created file
                                            // so return error
                                            lStatus = ERROR_CANNOT_MAKE;
                                        }
                                    } else {
                                        // get copy error
                                        lStatus = BOOL_TO_STATUS (bStatus);
                                    }
                                }

                                // if copy successful reset source file attributes
                                // and optionally destination file attributes

                                if (lStatus == ERROR_SUCCESS) {
                                    // set file attributes to NORMAL
                                    SetFileAttributes (
                                        szToFileName,
                                        FILE_ATTRIBUTE_NORMAL);
                                    // update filesize
                                    UpdatePercentComplete(hwndDlg, szFromFileName);
                                    // update count
                                    dwFileCopyCount++;
                                } else {
                                    // bail out here since there was a copy error
                                    nMbResult = MessageBox (
                                        hwndDlg,
                                        GetStringResource (CSZ_UNABLE_COPY),
                                        szFromFileName,
                                        MB_OKCANCEL_TASK_EXCL);
                                    if (nMbResult == IDCANCEL) {
                                        bCopying = FALSE;
                                    }
                                    // the error has already been handled so return
                                    // success to prevent the calling routine from
                                    // signalling this error
                                    lStatus = ERROR_SUCCESS;
                                }

                                // check for messages

                                while (PeekMessage (&msg, 0, 0, 0, PM_REMOVE)) {
                                    TranslateMessage (&msg);
                                    DispatchMessage (&msg);
                                }
                            }
                        }
                    } else {
                        lStatus = GetLastError();
                    }
                }

                if (dwFlags & CD_FLAGS_IGNORE_ERROR) {
                    // if ignore error, then set to success
                    lStatus = ERROR_SUCCESS;
                }

                if (lStatus == ERROR_SUCCESS) {
                    bStatus = FindNextFile (
                        hSearch,
                        pwfdSearchData);
                } else {
                    bStatus = FALSE;    // abort loop
                }
            } // end while files in dir
            FindClose (hSearch);
        } else {
            // invalid find handle so return error
            lStatus = GetLastError();
        }
    } // end of valid directory block

    FREE_IF_ALLOC(szFromPathName);
    FREE_IF_ALLOC(szFromFileName);
    FREE_IF_ALLOC(szSearchName);
    FREE_IF_ALLOC(szToPathName);
    FREE_IF_ALLOC(szToFileName);
    FREE_IF_ALLOC(pwfdSearchData);

    // set the counter fields if they were passed in

    if (pdwFiles != NULL) {
        *pdwFiles = dwFileCopyCount;
    }

    if (pdwDirs != NULL) {
        *pdwDirs = dwDirCreateCount;
    }

    return lStatus;
}

static
BOOL
CopyFileDlg_NCDU_START_FILE_COPY (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Formats values from Dialog Box parameter structure to argument list of
        copy directory function

Arguments:

    IN  HWND    hwndDlg
        handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        address of copy file structure.

Return Value:

    FALSE, always

--*/
{
    PCF_DLG_DATA pCF;

    pCF = (PCF_DLG_DATA)lParam;

#if SHOW_DEBUG_INFO
    // debug message box
    {
        LPTSTR  szMessageBuffer;
        DWORD   dwSourceAttr, dwDestAttr;
        UINT    nMbReturn;

        szMessageBuffer = GlobalAlloc (GPTR, SMALL_BUFFER_SIZE);
        if (szMessageBuffer != NULL) {
            dwSourceAttr = QuietGetFileAttributes (pCF->szSourceDir);
            dwDestAttr = QuietGetFileAttributes (pCF->szDestDir);
            _stprintf (szMessageBuffer,
                fmtPrepareToCopy,
                pCF->szDisplayName,
                pCF->szSourceDir, dwSourceAttr,
                pCF->szDestDir, dwDestAttr,
                pCF->dwCopyFlags);
            nMbReturn = MessageBox (hwndDlg,
                szMessageBuffer,
                cszDebug,
                MB_OKCANCEL_TASK_INFO);
            FREE_IF_ALLOC (szMessageBuffer);
        } else {
            nMbReturn = IDOK;
        }

        if (nMbReturn == IDCANCEL) {
            // then bail here
            EndDialog (hwndDlg, IDCANCEL);
            return TRUE;
        }
    }
#endif

    if (CopyDir (
        hwndDlg,
        pCF->szSourceDir,
        pCF->szDestDir,
        pCF->dwCopyFlags,
        &pCF->dwFilesCopied,
        &pCF->dwDirsCreated)  != ERROR_SUCCESS) {

        // display error message
        DisplayMessageBox (
            hwndDlg,
            CSZ_COPY_ERROR,
            0L,
            MB_OK_TASK_EXCL);
        bCopying = FALSE;  // to indicate error or non-completion

    }

    EndDialog (hwndDlg, (bCopying ? IDOK : IDCANCEL));

    return TRUE;
}

static
BOOL
CopyFileDlg_WM_INITDIALOG (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Dialog box initialization routine.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        not used

    IN  LPARAM  lParam
        address of Copy file data structure passed by calling routine.

Return Value:

    FALSE   if valid param block address
    TRUE    if not

--*/
{
    PCF_DLG_DATA pCF;

    pCF = (PCF_DLG_DATA)lParam;

    if (pCF != NULL) {
        // intialize Global data
        bCopying = TRUE;

        dwBytesCopied = 0;
        dwCurrentPercent = 0;
        dwTotalCBytes = (pCF->dwTotalSize + 50) / 100;

        PositionWindow  (hwndDlg);
        SetDlgItemText (hwndDlg, NCDU_COPY_APPNAME, pCF->szDisplayName);
        SetDlgItemText (hwndDlg, NCDU_FROM_PATH, cszEmptyString);
        SetDlgItemText (hwndDlg, NCDU_TO_PATH, cszEmptyString);
        SetDlgItemText (hwndDlg, NCDU_PERCENT_COMPLETE,
            GetStringResource (FMT_ZERO_PERCENT_COMPLETE));
        SetFocus (GetDlgItem(hwndDlg, IDCANCEL));
        // start copying files
        PostMessage (hwndDlg, NCDU_START_FILE_COPY, 0, lParam);
        return FALSE;
    } else {
        // illegal parameter
        EndDialog (hwndDlg, IDCANCEL);
        return TRUE;
    }
}

static
BOOL
CopyFileDlg_WM_COMMAND (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes WM_COMMAND messages to dialog box.
        Only IDCANCEL button is processed here (ceasing copy function)
        all other button commands are ignored (since there aren't any)

Arguments:

    IN  HWND    hwndDlg
        handle to dialog box window

    IN  WPARAM  wParam
        LOWORD   has the id of the control that issued the message

    IN  LPARAM  lParam
        Not used.

Return Value:

    if button is IDCANCEL, then FALSE
    otherwise TRUE (i.e. not processed.)

--*/
{
    switch (LOWORD(wParam)) {
        case IDCANCEL:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
                    if (DisplayMessageBox(hwndDlg,
                        NCDU_RU_SURE, 0,
                        MB_OKCANCEL_TASK_EXCL_DEF2) == IDOK) {
                        bCopying = FALSE;
                    }
                    return TRUE;

                default:
                    return FALSE;
            }

        default:    return FALSE;
    }
}

INT_PTR CALLBACK
CopyFileDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Main Dialog box window proc. Processes the following windows messages:
        WM_INITDIALOG:          dialog box initialization procedure
        WM_COMMAND:             windows messages (resulting from user commands)
        NCDU_START_FILE_COPY:   local message to begin copying files

    all other messages are processed by the DefDialogProc

Arguments:

    Standard WNDPROC arguments

Return Value:

    FALSE if not processed, otherwise value returned by
        called routine.

--*/
{
    switch (message) {
        case WM_INITDIALOG: return (CopyFileDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
        case WM_COMMAND:    return (CopyFileDlg_WM_COMMAND (hwndDlg, wParam, lParam));
        case NCDU_START_FILE_COPY: return (CopyFileDlg_NCDU_START_FILE_COPY (hwndDlg, wParam, lParam));
        default:            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\cdmodem\src\modem.c ===
/*************************************************************************
*
* modem.c
*
* Modem Routines
*
*
* Copyright 1996, Citrix Systems Inc.
*
* Author: Brad Pedersen (7/15/96)
*
* $Log:   M:\nt\private\citrix\cd\cdmodem\src\VCS\modem.c  $
*
*     Rev 1.7   23 Feb 1998 21:14:56   kurtp
*  fix CPR 8656, callback fails
*
*     Rev 1.6   26 Jun 1997 15:25:32   wf20r
*  move to WF40 tree
*
*     Rev 1.5   20 Jun 1997 18:06:56   butchd
*  update
*
*     Rev 1.4   06 Feb 1997 17:39:12   kurtp
*  update
*
*     Rev 1.3   17 Dec 1996 09:50:26   brucef
*  Do not close Connect Event if disconnect timeout.
*
*     Rev 1.2   09 Dec 1996 13:57:42   brucef
*  Return a true ERROR when STATUS_TIMEOUT occurs.
*
*     Rev 1.1   28 Oct 1996 08:47:08   bradp
*  update
*
*     Rev 1.0   16 Oct 1996 11:16:16   brucef
*  Initial revision.
*
*     Rev 1.5   25 Sep 1996 13:23:42   bradp
*  update
*
*     Rev 1.4   12 Sep 1996 13:40:14   brucef
*  update
*
*     Rev 1.3   11 Sep 1996 17:50:42   brucef
*  update
*
*     Rev 1.2   05 Sep 1996 11:18:18   brucef
*  update
*
*     Rev 1.1   20 Aug 1996 10:08:02   bradp
*  update
*
*     Rev 1.0   15 Jul 1996 11:04:10   bradp
*  Initial revision.
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <raserror.h>
#include <stdlib.h>
#include <tapi.h>
#include <winstaw.h>
#include <icadd.h>
#include <icaapi.h>

#include <rasman.h>
#include <rasmxs.h>
#include <media.h>
#include <cdmodem.h>

/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS IcaMemoryAllocate( ULONG, PVOID * );
VOID     IcaMemoryFree( PVOID );
NTSTATUS ModemAPIInit( PCDMODEM );
NTSTATUS ModemOpen( PCDMODEM );
NTSTATUS ModemClose( PCDMODEM );
NTSTATUS ModemInitialize( PCDMODEM );
NTSTATUS ModemHangup( PCDMODEM );
NTSTATUS ModemCallback( PCDMODEM, PICA_STACK_CALLBACK );

DWORD APIENTRY PortEnum(PCDMODEM, BYTE *pBuffer, WORD *pwSize, WORD *pwNumPorts);
DWORD APIENTRY PortSetInfo(HANDLE hIOPort, RASMAN_PORTINFO *pInfo);
DWORD APIENTRY PortOpen(char *pszPortName, HANDLE *phIOPort, HANDLE hNotify);
DWORD APIENTRY PortDisconnect(HANDLE hPort);
DWORD APIENTRY PortClose (HANDLE hIOPort);
DWORD APIENTRY PortDisconnect (HANDLE hPort);
DWORD APIENTRY DeviceListen(HANDLE hPort, char   *pszDeviceType,
                            char   *pszDeviceName,
                            HANDLE hNotifier);
DWORD APIENTRY DeviceConnect(HANDLE hPort, char   *pszDeviceType,
                             char   *pszDeviceName, HANDLE hNotifier);
DWORD APIENTRY DeviceWork(HANDLE hPort, HANDLE hNotifier);
VOID  APIENTRY DeviceDone(HANDLE hPort);
DWORD APIENTRY PortGetIOHandle(HANDLE hPort, HANDLE *FileHandle);

/*=============================================================================
==   Internal Functions Defined
=============================================================================*/


/*=============================================================================
==   Global variables
=============================================================================*/


/****************************************************************************
 *
 * ModemAPIInit
 *
 *   Initialize the Modem APIs and associated TAPI engine.
 *
 *
 * ENTRY:
 *
 * EXIT:
 *    STATUS_SUCCESS - Success
 *    STATUS_OPEN_FAILED - Unable to open/init TAPI engine
 *
 ****************************************************************************/

NTSTATUS
ModemAPIInit( PCDMODEM pCdModem )
{
    WORD Size;
    WORD NumPorts;

    /*
     *  We want TAPI to be initialized, the provided method is to call
     *  PortEnum() to enumerate all the TAPI ports.  The side effect of
     *  PortEnum() doing this is that it primes the entire TAPI engine first.
     *  It's this side effect that we are interested in; however, since
     *  at this point, we don't care about the data returned, a
     *  zero-byte buffer is supplied, which will cause BUFFER_TOO_SMALL
     *  to be returned if the TAPI engine got started to the point
     *  where it's usable.  So, anything other than BUFFER_TOO_SMALL
     *  means that TAPI didn't start properly, or if it did and no
     *  TAPI ports were found (0 bytes of buffer was sufficient).
     */
    Size = 0;
    if ( PortEnum( pCdModem, NULL, &Size, &NumPorts ) != ERROR_BUFFER_TOO_SMALL ) {
        /*
         *  Either there aren't any modems (size==0 resulted in SUCCESS), or
         *  another error was encountered.  In either case, the modem
         *  APIs aren't usable.
         */
        goto error;
    }

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error Returns
=============================================================================*/

error:

    return( STATUS_OPEN_FAILED ); //  - Better NTSTATUS code ???
}


/****************************************************************************
 *
 * ModemOpen
 *
 *   Open TAPI device
 *
 *
 * ENTRY:
 *    pCdModem (input)
 *       pointer modem connection driver data structure
 *    pEndpoint (input)
 *       pointer to a stack endpoint if reopening Modem Device.
 *
 * EXIT:
 *    STATUS_SUCCESS - Success
 *    other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
ModemOpen( PCDMODEM pCdModem )
{
    NTSTATUS Status;
    LONG TAPIStatus;
    DWORD NumDevs;
    static BOOL firsttime = TRUE;

    /*
     * Initialize the Modem APIs upon the first time through.
     * Note, that the underlying init routines have the necessary
     * syncronization in case mutilple "first time" callers make
     * it through the unsynchronized "firsttime" gate below.
     */
    if ( firsttime ) {
      if ( (Status = ModemAPIInit( pCdModem )) != STATUS_SUCCESS ) {
            goto error;
        }
        firsttime = FALSE;
    }

    DBGPRINT(( "CDMODEM: ModemOpen, Entry - opening \"%S\"\n",
               pCdModem->DeviceName
            ));


    Status = STATUS_SUCCESS;

error:

    DBGPRINT(( "CDMODEM: ModemOpen, 0x%x\n", Status ));
    return( Status );
}


/****************************************************************************
 *
 * ModemClose
 *
 *   Since closing the TAPI device would close all TAPI-based connections,
 *   we don't do anything here.
 *
 *
 * ENTRY:
 *    pCdModem (input)
 *       pointer modem connection driver data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - Success
 *    other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
ModemClose( PCDMODEM pCdModem )
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    DBGPRINT(( "CDMODEM: ModemClose, 0x%x\n", Status ));
    return( Status );
}

/****************************************************************************
 *
 * ModemInitialize
 *
 *   Initialize modem
 *
 *
 * ENTRY:
 *    pCdModem (input)
 *       pointer modem connection driver data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - Success
 *    other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
ModemInitialize( PCDMODEM pCdModem )
{

#define MI_EVENT_DISCONNECT 0
#define MI_EVENT_INCOMING   1
#define MI_EVENT_MAX        2
    HANDLE hEvents[MI_EVENT_MAX];

    NTSTATUS Status;
    DWORD Error;
    CHAR DeviceNameA[ DEVICENAME_LENGTH + 1 ];

    /*
     *  Initialize modem and wait for incoming call.
     */
    DBGPRINT(( "CDMODEM: ModemInitialize, Entry\n" ));

    hEvents[MI_EVENT_DISCONNECT] = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( !hEvents[MI_EVENT_DISCONNECT] ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
      goto baddiscevent;
    }
    pCdModem->hDiscEvent = hEvents[MI_EVENT_DISCONNECT];

    /*
     * TAPI does ANSI.
     */
    wcstombs( DeviceNameA, pCdModem->DeviceName, sizeof(DeviceNameA) );

    DBGPRINT(( "CDMODEM: ModemInitialize, opening \"%s\"\n", DeviceNameA ));

    Error = PortOpen( DeviceNameA,
                      &pCdModem->hPort,
               hEvents[MI_EVENT_DISCONNECT] );
    if ( Error ) {
        DBGPRINT(( "CDMODEM: ModemInitialize: PortOpen failed (%d)\n",
                   Error ));
      Status = STATUS_OPEN_FAILED;
        goto badportopen;
    }

    hEvents[MI_EVENT_INCOMING] = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( !hEvents[MI_EVENT_INCOMING] ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
      goto badicevent;
    }

    /*
     * Listen for the phone to ring.
     */
    Error = DeviceListen( pCdModem->hPort,
                          NULL,
              NULL,
              hEvents[MI_EVENT_INCOMING] );
    if ( Error != PENDING ) {
        DBGPRINT(( "CDMODEM: ModemInitialize: DeviceListen failed (%d)\n",
                   Error ));
      Status = STATUS_OPEN_FAILED;
        goto baddevicelisten;
    }

    /*
     * This simple state machine drives the more complex state machine
     * lifted from the RAS server, it advances the incoming call through
     * to the answered state.  If the INCOMING event is
     * signaled, the call is advanced to the next state via DeviceWork().
     * As long as future state transitions are required, DeviceWork() returns
     * a status of PENDING, when all state transitions are complete,
     * DeviceWork() returns SUCCESS; at which point the incoming call
     * has been answered and the communication port is ready for
     * data.
     */
nextstate:
    Error = IcaCdWaitForMultipleObjects( pCdModem->hStack, MI_EVENT_MAX, hEvents, FALSE, INFINITE );
    switch ( Error ) {
    case WAIT_TIMEOUT:
        DBGPRINT(( "CDMODEM: ModemInitialize: Timeout\n" ));
      Status = STATUS_OPEN_FAILED;
        goto timeout;

    case MI_EVENT_DISCONNECT + WAIT_OBJECT_0:
        DBGPRINT(( "CDMODEM: ModemInitialize: Disconnected\n" ));
      Status = STATUS_OPEN_FAILED;
        goto disconnect;

    case MI_EVENT_INCOMING + WAIT_OBJECT_0:
        DBGPRINT(( "CDMODEM: ModemInitialize: Incoming Call\n" ));
        Error = DeviceWork( pCdModem->hPort, hEvents[MI_EVENT_INCOMING] );
        if ( Error == SUCCESS ) {
            DeviceDone( pCdModem->hPort );
            break;
        }
        if ( Error != PENDING ) {
            DBGPRINT(( "CDMODEM: ModemInitialize: DeviceWork failed (%d)\n",
                Error ));
            Status = STATUS_OPEN_FAILED;
            goto baddevicework;
        }
        goto nextstate;

    case 0xffffffff:
        DBGPRINT(( "CDMODEM: ModemInitialize: Wait returned 0xffffffff\n" ));
      Status = STATUS_OPEN_FAILED;
        goto badwait;

    default:
        DBGPRINT(( "CDMODEM: ModemInitialize: Unknown return from Wait\n" ));
      Status = STATUS_OPEN_FAILED;
        goto badwait;
    }

    Error = PortGetIOHandle( pCdModem->hPort, &pCdModem->hCommDevice );
    if ( Error ) {
        DBGPRINT(( "CDMODEM: ModemInitialize: PortGetIOHandle failed (%d)\n",
                   Error ));
      Status = STATUS_OPEN_FAILED;
        goto badportgetiohandle;
    }

    CloseHandle( hEvents[MI_EVENT_INCOMING] );

    Status = STATUS_SUCCESS;

    DBGPRINT(( "CDMODEM: ModemInitialize, 0x%x\n", Status ));
    return( Status );

/*=============================================================================
==   Error Returns
=============================================================================*/
badportgetiohandle:
timeout:
disconnect:
badwait:
baddevicework:
baddevicelisten:
    CloseHandle( hEvents[MI_EVENT_INCOMING] );

badicevent:
    PortClose( pCdModem->hPort );
badportopen:
    CloseHandle( pCdModem->hDiscEvent );
    pCdModem->hDiscEvent = NULL;

baddiscevent:
    DBGPRINT(( "CDMODEM: ModemInitialize, ERROR 0x%x\n", Status ));
    return( Status );
}


/****************************************************************************
 *
 * ModemHangup
 *
 *   Hangup modem and close TAPI device
 *
 *
 * ENTRY:
 *    pCdModem (input)
 *       pointer modem connection driver data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - Success
 *    other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
ModemHangup( PCDMODEM pCdModem )
{
    NTSTATUS Status;
    DWORD Error;

    DBGPRINT(( "CDMODEM: ModemHangup, entry\n" ));
    /*
     *  Hangup and close modem
     */

    Error = PortDisconnect( pCdModem->hPort );
    if ( Error == PENDING ) {
        ASSERT( pCdModem->hDiscEvent );
        DBGPRINT(("CDMODEM: ModemHangup waiting for client to disconnect\n"));
        Error = IcaCdWaitForSingleObject( pCdModem->hStack,
                                          pCdModem->hDiscEvent,
                    DISCONN_TIMEOUT );
        DBGPRINT(("CDMODEM: ModemHangup wait complete Error 0x%x\n", Error ));
        switch ( Error ) {
        case WAIT_OBJECT_0:
            break;

        case WAIT_TIMEOUT:
            DBGPRINT(( "CDMODEM: ModemHangup: Timeout\n" ));
            break;

        case 0xffffffff:
            DBGPRINT(( "CDMODEM: ModemHangup: Wait returned 0xffffffff\n" ));
            break;

        default:
            DBGPRINT(( "CDMODEM: ModemHangup: Unknown return from Wait\n" ));
            break;
        }
    }

    if ( pCdModem->hPort ) {
        PortClose( pCdModem->hPort );
    }
    pCdModem->hPort = NULL;
    pCdModem->hCommDevice = NULL;

    if ( pCdModem->hDiscEvent ) {
        CloseHandle( pCdModem->hDiscEvent );
    }
    pCdModem->hDiscEvent = NULL;

    Status = STATUS_SUCCESS;

    DBGPRINT(( "CDMODEM: ModemHangup, 0x%x\n", Status ));
    return( Status );
}


/****************************************************************************
 *
 * ModemCallback
 *
 *   Dial modem for callback
 *
 *
 * ENTRY:
 *    pCdModem (input)
 *       pointer modem connection driver data structure
 *    pCallback (input)
 *       pointer to callback data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - Success
 *    other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
ModemCallback( PCDMODEM pCdModem,
               PICA_STACK_CALLBACK pCallback )
{
#define MC_EVENT_DISCONNECT 0
#define MC_EVENT_CONNECT    1
#define MC_EVENT_MAX        2
    HANDLE hEvents[MC_EVENT_MAX];
    NTSTATUS Status;
    DWORD Error;
    RASMAN_PORTINFO portinfo;
    RAS_PARAMS *params;
    CHAR PhoneNumberA[ CALLBACK_LENGTH + 1 ];

    /*
     * Disconnect Port, then make an outgoing call to
     * the supplied number.
     */

    ASSERT( pCdModem->hDiscEvent );
    DBGPRINT(("CDMODEM: ModemCallback waiting for client to disconnect\n"));

    /*
     *  Add extra delay (6X) because it takes time for local modem to detect
     *  carrier drop, when ModemHangup is called you don't need the extra
     *  time because we are dropping carrier locally.
     */
    Error = IcaCdWaitForSingleObject( pCdModem->hStack, pCdModem->hDiscEvent,
                                      6 * DISCONN_TIMEOUT );
    DBGPRINT(("CDMODEM: ModemCallback wait complete Error 0x%x\n", Error ));
    switch ( Error ) {
    case WAIT_OBJECT_0:
        break;

    case WAIT_TIMEOUT:
        DBGPRINT(( "CDMODEM: ModemCallback: Timeout\n" ));
      Status = STATUS_OPEN_FAILED;
        goto timeout1;

    case 0xffffffff:
        DBGPRINT(( "CDMODEM: ModemCallback: Wait returned 0xffffffff\n" ));
        Status = STATUS_OPEN_FAILED;
        goto badwait1;

    default:
        DBGPRINT(( "CDMODEM: ModemCallback: Unknown return from Wait\n" ));
        Status = STATUS_OPEN_FAILED;
        goto badwait1;
    }

    /*
     * TAPI does ANSI.
     */
    wcstombs( PhoneNumberA, pCallback->PhoneNumber, sizeof(PhoneNumberA) );

    /*
     *  Setup the number to call.
     */
    portinfo.PI_NumOfParams       = 1;
    params                        = &portinfo.PI_Params[0];
    params->P_Type                = String;
    params->P_Attributes          = 0;
    params->P_Value.String.Length = strlen ( PhoneNumberA );
    params->P_Value.String.Data   = PhoneNumberA;
    strcpy( params->P_Key,          MXS_PHONENUMBER_KEY );

    Error = PortSetInfo( pCdModem->hPort, &portinfo );
    if ( Error != SUCCESS ) {
        goto badportsetinfo;
    }

    hEvents[MC_EVENT_DISCONNECT] = pCdModem->hDiscEvent;

    hEvents[MC_EVENT_CONNECT] = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( !hEvents[MC_EVENT_CONNECT] ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
      goto badconnectevent;
    }

    /*
     * Make the call to the number given.
     */
    Error = DeviceConnect( pCdModem->hPort, NULL, NULL,
                           hEvents[MC_EVENT_CONNECT] );
    if ( Error != PENDING ) {
        DBGPRINT(( "CDMODEM: ModemCallback: DeviceConnect failed (%d)\n",
                   Error ));
      Status = STATUS_OPEN_FAILED;
        goto baddeviceconnect;
    }

    /*
     * This simple state machine drives the more complex state machine
     * lifted from the RAS server, it advances the incoming call through
     * to the call completed state.  If the CONNECT event is
     * signaled, the call is advanced to the next state via DeviceWork().
     * As long as future state transitions are required, DeviceWork() returns
     * a status of PENDING, when all state transitions are complete,
     * DeviceWork() returns SUCCESS; at which point the outgoing call
     * has been established and the communication port is ready for
     * data.
     */
nextstate:
    Error = IcaCdWaitForMultipleObjects( pCdModem->hStack, MC_EVENT_MAX, hEvents, FALSE,
                                         CALLBACK_TIMEOUT );
    switch ( Error ) {
    case WAIT_TIMEOUT:
        DBGPRINT(( "CDMODEM: ModemCallback: Timeout\n" ));
      Status = STATUS_OPEN_FAILED;
        goto timeout2;

    case MC_EVENT_DISCONNECT + WAIT_OBJECT_0:
        DBGPRINT(( "CDMODEM: ModemCallback: Disconnected\n" ));
      Status = STATUS_OPEN_FAILED;
        goto disconnect;

    case MC_EVENT_CONNECT + WAIT_OBJECT_0:
        DBGPRINT(( "CDMODEM: ModemCallback: Connecting\n" ));
        Error = DeviceWork( pCdModem->hPort, hEvents[MC_EVENT_CONNECT] );
        if ( Error == SUCCESS ) {
            DeviceDone( pCdModem->hPort );
            break; // call successful
        }
        if ( Error != PENDING ) {
            DBGPRINT(( "CDMODEM: ModemCallback: DeviceWork failed (%d)\n",
                Error ));
            Status = STATUS_OPEN_FAILED;
            goto baddevicework;
        }
        goto nextstate;
        break;

    case 0xffffffff:
        DBGPRINT(( "CDMODEM: ModemCallback: Wait returned 0xffffffff\n" ));
      Status = STATUS_OPEN_FAILED;
        goto badwait2;

    default:
        DBGPRINT(( "CDMODEM: ModemCallback: Unknown return from Wait\n" ));
      Status = STATUS_OPEN_FAILED;
        goto badwait2;
    }

    Error = PortGetIOHandle( pCdModem->hPort, &pCdModem->hCommDevice );
    if ( Error ) {
        DBGPRINT(( "CDMODEM: ModemCallback: PortGetIOHandle failed (%d)\n",
                   Error ));
      Status = STATUS_OPEN_FAILED;
        goto badportgetiohandle;
    }

    CloseHandle( hEvents[MC_EVENT_CONNECT] );
    Status = STATUS_SUCCESS;

    DBGPRINT(( "CDMODEM: ModemCallback, %S han 0x%x , 0x%x\n",
               pCallback->PhoneNumber, pCdModem->hCommDevice, Status ));
    return( Status );

/*=============================================================================
==   Error Returns
=============================================================================*/
badportgetiohandle:
badwait2:
timeout2:
disconnect:
baddevicework:
baddeviceconnect:
    CloseHandle( hEvents[MC_EVENT_CONNECT] );
badconnectevent:
badportsetinfo:
badwait1:
timeout1:
    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\copyflop.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    COPYFLOP.C

Abstract:

    Floppy disk creation setup dialog

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"

//
//  static data for this module
//
//
//  mszDirNameList is the local list of directories that corresponds to the
//  items displayed in the Client List. This buffer is loaded by the
//  LoadClientList routine and the entry index of the directory is the
//  Item Data for the list box name entry.
//
static  TCHAR   mszDirNameList[SMALL_BUFFER_SIZE];
//
//  These string arrays are used to cross reference the drive selected
//   to the "drive name" for IOCTL functions or the Dir name for file
//  operations.
//
static  LPCTSTR  szDriveNames[2] = {TEXT("\\\\.\\A:"), TEXT("\\\\.\\B:")};
static  LPCTSTR  szDriveDirs[2] = {TEXT("A:"), TEXT("B:")};

#ifdef TERMSRV
extern TCHAR szCommandLineVal[MAX_PATH];
extern BOOL bUseCleanDisks;
#endif // TERMSRV


static
MEDIA_TYPE
GetDriveTypeFromList (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Gets the selected drive from the drive list box and looks up the drive
        type using the IOCTL function. The drive type enum value is
        returned.

    NOTE: This function may cause a system error box if there is no media
    in the drive or there is a device/drive error.

Arguments:

    IN  HWND    hwndDlg
        handle to the dialog box window

Return Value:

    value of type MEDIA_TYPE that corresponds to the drive type of the
        drive selected in the drive list box.

--*/
{
    int nSelIndex;
    HANDLE  hFloppy;
    DWORD   dwRetSize;
    DISK_GEOMETRY   dgFloppy;

    // get selected drive
    nSelIndex = (int)SendDlgItemMessage (hwndDlg, NCDU_DRIVE_LIST,
        LB_GETCURSEL, 0, 0);

    // open device to get type
    hFloppy = CreateFile (
        szDriveNames[nSelIndex],
        0,
        (FILE_SHARE_READ | FILE_SHARE_WRITE),
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFloppy != INVALID_HANDLE_VALUE) {
        // get drive information
        if (!DeviceIoControl (hFloppy,
            IOCTL_DISK_GET_DRIVE_GEOMETRY,
            NULL, 0,
            &dgFloppy,
            sizeof(DISK_GEOMETRY),
            &dwRetSize,
            NULL) ){
            // unable to get data so set to unknown
            dgFloppy.MediaType = Unknown;
        } // else return data from returned structure
        CloseHandle (hFloppy);
    } else {
        // unable to access floppy, so return unknown
        dgFloppy.MediaType = Unknown;
    }

    return dgFloppy.MediaType;
}

static
VOID
FillDriveList (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Loads the text strings into the drive selection list box.

    NOTE: The order of these entries is significant in that it is
    used to index into the static device and drive name arrays.

Arguments:

    IN HWND hwndDlg
        handle to dialog box window

Return Value:

    NONE

--*/
{
#ifdef JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

    PDISK_GEOMETRY pDiskGeometry;
    HANDLE  hDrive;
    LPTSTR  szDrive;
    TCHAR   cDriveName;
    BYTE    nCounter;
    BOOL    bFloppy;
    BOOL    bRet;
    DWORD   dwArryCount;
    DWORD   dwLastError;
    DWORD   dwMediaType;
    DWORD       dwLogicalDrive;
    DWORD   dwReturnedByteCount;
#endif

    // clear list box
    SendDlgItemMessage (hwndDlg, NCDU_DRIVE_LIST, LB_RESETCONTENT, 0, 0);

#ifdef JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

    szDrive = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szDrive != NULL) {
        dwLogicalDrive = GetLogicalDrives();
        for (cDriveName = *cszAColon, nCounter = 0;
             cDriveName <= *cszLastDrive;
             cDriveName++, nCounter++) {

            if ((dwLogicalDrive>>nCounter)&NCDU_LOGICAL_DRIVE_MASK) {

                bFloppy = FALSE;

                wsprintf (szDrive, TEXT("%s%s%s%c%s"),
                          cszDoubleBackslash, cszDot, cszBackslash, cDriveName, cszColon);

                hDrive = CreateFile (szDrive,
                                     0,
                                     (FILE_SHARE_READ | FILE_SHARE_WRITE),
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL);

                if (hDrive != INVALID_HANDLE_VALUE) {

                    dwArryCount = 1;
                    pDiskGeometry = NULL;

                    do {
                        if (!pDiskGeometry)
                            pDiskGeometry = (PDISK_GEOMETRY)
                                            GlobalLock (GlobalAlloc (GHND,
                                                                     sizeof(DISK_GEOMETRY)*dwArryCount));
                        else
                            pDiskGeometry = (PDISK_GEOMETRY)
                                            GlobalLock (GlobalReAlloc (GlobalHandle (pDiskGeometry),
                                                                       sizeof(DISK_GEOMETRY)*dwArryCount,
                                                                       GHND));

                        if (!pDiskGeometry) break;

                        bRet = DeviceIoControl (hDrive,
                                                IOCTL_DISK_GET_MEDIA_TYPES,
                                                NULL,
                                                0,
                                                pDiskGeometry,
                                                sizeof(DISK_GEOMETRY)*dwArryCount,
                                                &dwReturnedByteCount,
                                                NULL);

                        dwLastError = GetLastError();

                        GlobalUnlock(GlobalHandle(pDiskGeometry));

                        dwArryCount++;
                    } while ( ! bRet && ( dwLastError == ERROR_INSUFFICIENT_BUFFER ||
                                          dwLastError == ERROR_MORE_DATA ) );

                    if (pDiskGeometry) {
                        pDiskGeometry = (PDISK_GEOMETRY)GlobalLock(GlobalHandle(pDiskGeometry));
                        for (dwMediaType = 0; dwMediaType < (dwArryCount-1); dwMediaType++) {
                           if (((pDiskGeometry+dwMediaType)->MediaType != Unknown)        &&
                               ((pDiskGeometry+dwMediaType)->MediaType != RemovableMedia) &&
                               ((pDiskGeometry+dwMediaType)->MediaType != FixedMedia))
                               bFloppy = TRUE;
                        }
                        GlobalUnlock(GlobalHandle(pDiskGeometry));
                        GlobalFree(GlobalHandle(pDiskGeometry));
                    }

                    if (bFloppy) {
                        wsprintf (szDrive, TEXT("%c%s"), cDriveName, cszColon);
                        SendDlgItemMessage (hwndDlg,
                                            NCDU_DRIVE_LIST,
                                            LB_ADDSTRING,
                                            0,
                                            (LPARAM)szDrive);
                    }

                    CloseHandle (hDrive);
                }
            }
        }
        FREE_IF_ALLOC (szDrive);
    } else {
#else
    SendDlgItemMessage (hwndDlg, NCDU_DRIVE_LIST, LB_ADDSTRING, 0, (LPARAM)cszAColon);
    SendDlgItemMessage (hwndDlg, NCDU_DRIVE_LIST, LB_ADDSTRING, 0, (LPARAM)cszBColon);
#endif

#ifdef  JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

    }
#endif

    SendDlgItemMessage (hwndDlg, NCDU_DRIVE_LIST, LB_SETCURSEL, 0, 0);

}

static
DWORD
NumberOfDisks (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Counts the number of "disk" directories in the currently selected client
        installation disk dir. The method used to count disks relies on the
        assumption that each disk's files are in a directory and the
        directories are mamed Disk1, Disk2, etc. The count is performed by
        looking for each disk directory in sequence and stopping when a
        dir is not found. i.e. if disk5 is not found, then 4 disks are
        assumed.

Arguments:

    Handle to dialog box window

Return Value:

    count of directorys ("disks") found

--*/
{
    LPTSTR  szFromPath;
    LPTSTR  szDirStart;
    BOOL    bCounting;
    UINT    nClientIndex;
    DWORD   nDiskNumber = 0;

    szFromPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szFromPath != NULL) {
        // get root dir of dist tree
        lstrcpy (szFromPath, pAppInfo->szDistPath);
        if (szFromPath[lstrlen(szFromPath)-1] != cBackslash) lstrcat (szFromPath, cszBackslash);

        // append client sw subdir
        nClientIndex = (UINT)SendDlgItemMessage (hwndDlg, NCDU_CLIENT_SOFTWARE_LIST,
            LB_GETCURSEL, 0, 0);
        lstrcat (szFromPath, GetEntryInMultiSz (mszDirNameList, nClientIndex+1));
        if (szFromPath[lstrlen(szFromPath)-1] != cBackslash) lstrcat (szFromPath, cszBackslash);
        lstrcat (szFromPath, cszDisksSubDir);
        if (szFromPath[lstrlen(szFromPath)-1] != cBackslash) lstrcat (szFromPath, cszBackslash);
        szDirStart = &szFromPath[lstrlen(szFromPath)];

        // count directories
        bCounting = TRUE;
        nDiskNumber = 0;
        while (bCounting) {
            nDiskNumber++;
            _stprintf (szDirStart, fmtDiskNumber,
                nDiskNumber);
            bCounting = IsPathADir (szFromPath);
        }
        // account for last directory that wasn't found
        nDiskNumber -= 1;

        FREE_IF_ALLOC (szFromPath);
    }

    return nDiskNumber;   // for now
}

static
BOOL
UpdateDiskCount (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    updates the disk count text displayed in the dialog box.

Arguments:

    IN  HWND    hwndDlg
        handle to dialog box window

Return Value:

    TRUE if display updated successfully
    FALSE if not.

--*/
{
    LPTSTR  szBuffer;
    DWORD   dwNumDisks;

    szBuffer = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szBuffer != NULL) {
        dwNumDisks = NumberOfDisks (hwndDlg);
        if (dwNumDisks == 1) {
            _stprintf (szBuffer, GetStringResource (FMT_1_DISK_REQUIRED));
        } else {
            _stprintf (szBuffer, GetStringResource (FMT_N_DISKS_REQUIRED),
                dwNumDisks);
        }
        SetDlgItemText (hwndDlg, NCDU_NUM_DISKS_REQUIRED, szBuffer);
        FREE_IF_ALLOC (szBuffer);
        return TRUE;
    } else {
        return FALSE;
    }
}

static
BOOL
CopyFlopDlg_WM_INITDIALOG (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Dialog box initialization routine. Loads list boxes in dialog

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        Not used

    IN  LPARAM  lParam
        Not used

Return Value:

    FALSE, always.

--*/
{
    // update dialog window menu and position
    RemoveMaximizeFromSysMenu (hwndDlg);
    PositionWindow  (hwndDlg);

    // load clients to display
    LoadClientList (hwndDlg, NCDU_CLIENT_SOFTWARE_LIST,
        pAppInfo->szDistPath, CLT_FLOPPY_INSTALL, mszDirNameList);

    // set selection
    SendDlgItemMessage (hwndDlg, NCDU_CLIENT_SOFTWARE_LIST,
        LB_SETCURSEL, (WPARAM)0, (LPARAM)0);

    // load drives to select from
    FillDriveList(hwndDlg);

    // update disk count to reflect default selection
    UpdateDiskCount (hwndDlg);

    // clear old Dialog and register current
    PostMessage (GetParent(hwndDlg), NCDU_CLEAR_DLG, (WPARAM)hwndDlg, IDOK);
    PostMessage (GetParent(hwndDlg), NCDU_REGISTER_DLG,
        NCDU_CREATE_INSTALL_DISKS_DLG, (LPARAM)hwndDlg);

    // set cursor and focus
    SetCursor(LoadCursor(NULL, IDC_ARROW));
    SetFocus (GetDlgItem(hwndDlg, NCDU_MAKE_DISKS));

    return FALSE;
}

static
BOOL
CopyFlopDlg_NCDU_MAKE_DISKS (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Function to copy the client files to the floppy disks.
        Selects the source directory using the client name and
        disk type then copies the files to the floppy disks
        sequentially assuming that the contents of each disk
        are stored in sub directory named "DiskX" where X is the
        decimal number indicating the disk sequence (e.g. 1, 2, 3, etc.)

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

Return Value:
    FALSE, always.

--*/
{
    MEDIA_TYPE  mtFloppy;
    LPTSTR      szFromPath;
    LPTSTR      szInfName;
    TCHAR       szSubDir[16];
    TCHAR       szDestRoot[4];
    TCHAR       szDriveRoot[8];
    LPTSTR      szClientName;
    LPTSTR      szDisplayName;
    LPTSTR      szDirStart;
    LPTSTR      szDiskName;
    LPTSTR      szClientSection;
    LPTSTR      szDisplayString;
    LPTSTR      szVolumeLabel;
    DWORD       dwFileAttr;
    BOOL        bCopyFiles;
    int         nSelIndex;
    int         nClientIndex;
    int         nCancelResult = 0;
    int         nDiskNumber;
    CF_DLG_DATA cfData;
    BOOL        bFormatDisks;
#ifdef TERMSRV
    int         nDiskCount;
#endif // TERMSRV

#ifdef JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

    //
    // Buffer for real FD path
    //
    TCHAR       szDriveName[10];
    TCHAR       szDriveDir[5];
#endif

    szFromPath = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szInfName = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szClientName = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szDisplayName = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szDiskName = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szClientSection = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szVolumeLabel = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if ((szFromPath == NULL) ||
        (szClientName == NULL) ||
        (szClientSection == NULL) ||
        (szInfName == NULL) ||
        (szDiskName == NULL) ||
        (szVolumeLabel == NULL) ||
        (szDisplayName == NULL)) {
        // message not processed
        return FALSE;
    }

    // check floppy selection to see if it's supported

    //
    //      This function is really flakey, so for now, (for ever?)
    //      we'll assume they are using a HD disk drive
    //
    //  mtFloppy = GetDriveTypeFromList (hwndDlg);
    //
    mtFloppy = F3_1Pt44_512;

    if ((mtFloppy == F5_1Pt2_512) || // 5.25 HD
        (mtFloppy == F3_1Pt44_512)) { // 3.5 HD
        // get format check box state
        bFormatDisks = (BOOL)(IsDlgButtonChecked (hwndDlg, NCDU_FORMAT_DISKS) == CHECKED);

        // then this is a supported format
        //  make source path using:
        //      dist tree + client type + "disks" + drive type
        //
        // get root dir of dist tree
        lstrcpy (szFromPath, pAppInfo->szDistPath);
        if (szFromPath[lstrlen(szFromPath)-1] != cBackslash) lstrcat (szFromPath, cszBackslash);

        // append client sw subdir
        nClientIndex = (int)SendDlgItemMessage (hwndDlg, NCDU_CLIENT_SOFTWARE_LIST,
            LB_GETCURSEL, 0, 0);
        lstrcat (szFromPath, GetEntryInMultiSz (mszDirNameList, nClientIndex+1));
        if (szFromPath[lstrlen(szFromPath)-1] != cBackslash) lstrcat (szFromPath, cszBackslash);
        lstrcat (szFromPath, cszDisksSubDir);

        // make INF file Name

        lstrcpy (szInfName, pAppInfo->szDistPath);
        if (szInfName[lstrlen(szInfName)-1] != cBackslash) lstrcat (szInfName, cszBackslash);
        lstrcat (szInfName, cszAppInfName);

        // get client name
        SendDlgItemMessage (hwndDlg, NCDU_CLIENT_SOFTWARE_LIST,
            LB_GETTEXT, (WPARAM)nClientIndex, (LPARAM)szClientName);

        if (szFromPath[lstrlen(szFromPath)-1] != cBackslash) lstrcat (szFromPath, cszBackslash);
        szDirStart = &szFromPath[lstrlen(szFromPath)];

        nSelIndex = (int)SendDlgItemMessage (hwndDlg, NCDU_DRIVE_LIST,
            LB_GETCURSEL, 0, 0);
#ifdef JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

        // get real FD path
        SendDlgItemMessage (hwndDlg, NCDU_DRIVE_LIST,
            LB_GETTEXT, nSelIndex, (LPARAM)szDriveDir);
        wsprintf(szDriveName, TEXT("%s%s%s%s"), cszBackslash,cszBackslash,cszColon,cszBackslash);
        lstrcat(szDriveName, szDriveDir);
#endif

        // format client name key used to look up disk names in INF
        lstrcpy (szClientSection, GetEntryInMultiSz (mszDirNameList, nClientIndex+1));
        lstrcat (szClientSection, cszNames);

        // set the destination path
#ifdef JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

        lstrcpy (szDestRoot, szDriveDir);
        lstrcpy (szDriveRoot, szDriveName);
        lstrcat (szDriveRoot, cszBackslash);
#else
        lstrcpy (szDestRoot, szDriveDirs[nSelIndex]);
        lstrcpy (szDriveRoot, szDriveNames[nSelIndex]);
        lstrcat (szDriveRoot, cszBackslash);
#endif

        nDiskNumber = 1;
        _stprintf (szSubDir, fmtDiskNumber, nDiskNumber);
        lstrcpy (szDirStart, szSubDir);
        if ((dwFileAttr = QuietGetFileAttributes(szFromPath)) != 0xFFFFFFFF) {
            bCopyFiles = TRUE;
        } else {
            bCopyFiles = FALSE;
        }
        // initialize counter fields
        cfData.dwFilesCopied = 0;
        cfData.dwDirsCreated = 0;

        while (bCopyFiles) {
            if ((dwFileAttr & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY) {
                // see if this disk has a name, if so display it, otherwise
                // just show the disk number
                if (QuietGetPrivateProfileString (szClientSection, szSubDir,
                    cszEmptyString, szDiskName, MAX_PATH, szInfName) == 0) {
                    lstrcpy (szDiskName, szSubDir);
                } else {
                    // append "disk" to the name string
                    lstrcat (szDiskName, cszDisk);
                }
                // display "load the floppy" message
                _stprintf (szDisplayName,
                    GetStringResource (FMT_CLIENT_DISK_AND_DRIVE),
#ifdef JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

                    szClientName, szDiskName, szDriveDir);
#else
                    szClientName, szDiskName, szDriveDirs[nSelIndex]);
#endif

                nCancelResult = MessageBox (
                    hwndDlg,
                    szDisplayName,
                    GetStringResource (FMT_INSERT_FLOPPY),
                    MB_OKCANCEL_TASK_INFO);

                if (nCancelResult == IDOK) {
                    // format  the copying files message
                    _stprintf (szDisplayName,
                        GetStringResource (FMT_CLIENT_DISPLAY_NAME),
                        szClientName, szDiskName);

                    // set the disk volume label if one is in the INF
                    lstrcat (szSubDir, cszLabel);
                    if (QuietGetPrivateProfileString (szClientSection, szSubDir,
                        cszEmptyString, szVolumeLabel, MAX_PATH, szInfName) > 0) {
                    }

                    if (bFormatDisks) {
                        while (!FormatDiskInDrive (hwndDlg,
                            szDestRoot[0],
                            szVolumeLabel,
                            TRUE)) {

                            // an error occured so see if they want to try again or bail out
                            if (DisplayMessageBox (hwndDlg,
                                IDS_CORRECT_FMT_ERROR,
                                FMT_INSERT_FLOPPY,
                                MB_OKCANCEL_TASK_EXCL) == IDCANCEL) {
                                bCopyFiles = FALSE;
                                nCancelResult = IDCANCEL;
                                break; // now exit retry loop
                            }
                        }
                        if (!bCopyFiles) continue; // bail out at the top
                    }

                    cfData.szDisplayName = szDisplayName;
                    cfData.szSourceDir = szFromPath;
                    cfData.szDestDir = szDestRoot;
                    cfData.dwCopyFlags = CD_FLAGS_COPY_SUB_DIR | CD_FLAGS_COPY_ATTR | CD_FLAGS_IGNORE_ERROR;
                    cfData.dwTotalSize = 0;

                    if (bUseCleanDisks) {
                        WIN32_FIND_DATA fdSearch;
                        TCHAR filesToFind[8];
                        HANDLE hSearch;
                        BOOL bDiskContainsFiles;

                        lstrcpy(filesToFind, szDestRoot);
                        if (filesToFind[lstrlen(filesToFind)-1] != cBackslash) {
                            lstrcat (filesToFind, cszBackslash);
                        }
                        lstrcat(filesToFind, cszWildcard);

                        // loop till the user inserts an empty disk, or hits cancel.

                        do {
                            nCancelResult = IDOK;
                            bDiskContainsFiles = FALSE;

                            hSearch = FindFirstFile(filesToFind, &fdSearch);

                            if(hSearch != INVALID_HANDLE_VALUE) {
                                BOOL bSearching = TRUE;
                                while (bSearching) {
                                    if (!DotOrDotDotDir(fdSearch.cFileName)) {
                                        //
                                        // looks like some files are already existing there..
                                        //
                                        bDiskContainsFiles = TRUE;
                                        nCancelResult = DisplayMessageBox (
                                            hwndDlg,
                                            NCDU_CLEAN_DISK_REQUIRED,
                                            0,
                                            (MB_OKCANCEL | MB_ICONERROR | MB_TASKMODAL));
                                        break;
                                    }
                                    bSearching = FindNextFile(hSearch, &fdSearch);
                                }
                                FindClose(hSearch);
                            }
                        }
                        while (bDiskContainsFiles && nCancelResult != IDCANCEL);

                        if (nCancelResult == IDCANCEL) {
                            bCopyFiles = FALSE;
                        }
                    }

                    if (!bCopyFiles) continue; // bail out at the top

                    nCancelResult = (int)DialogBoxParam (
                        (HANDLE)GetWindowLongPtr(GetParent(hwndDlg), GWLP_HINSTANCE),
                        MAKEINTRESOURCE(NCDU_COPYING_FILES_DLG),
                        hwndDlg,
                        CopyFileDlgProc,
                        (LPARAM)&cfData);

                    if (nCancelResult == IDCANCEL) {
                        bCopyFiles = FALSE;
                    } else {
                        // set volume label (if not set already)
                        if ((!bFormatDisks) & (lstrlen(szVolumeLabel) > 0)) {
                            // set volume label here
                            LabelDiskInDrive (hwndDlg, szDestRoot[0], szVolumeLabel);
                        }
                    }

                } else {
                    bCopyFiles = FALSE;
                }
            }
            if (bCopyFiles) {
                _stprintf (szSubDir, fmtDiskNumber, ++nDiskNumber);
                lstrcpy (szDirStart, szSubDir);
                if ((dwFileAttr = QuietGetFileAttributes(szFromPath)) != 0xFFFFFFFF) {
                    bCopyFiles = TRUE;
                } else {
                    bCopyFiles = FALSE;
                }
            }
        }

        if (nCancelResult != IDCANCEL) {
            szDisplayString = GlobalAlloc (GPTR, MAX_PATH_BYTES);
            if (szDisplayString == NULL) {
                // unable to allocate string buffer so try default message
                DisplayMessageBox (
                hwndDlg,
                NCDU_COPY_COMPLETE,
                0,
                MB_OK_TASK_INFO);
            } else {
#ifdef TERMSRV
                nDiskCount = NumberOfDisks(hwndDlg);
                _stprintf (szDisplayString,
                    GetStringResource (
                        //(cfData.dwDirsCreated == 1) ?
                        (nDiskCount == 1) ?
                            FMT_COPY_COMPLETE_STATS1 :
                            FMT_COPY_COMPLETE_STATS2),
                    nDiskCount, cfData.dwFilesCopied);
#else // TERMSRV
                _stprintf (szDisplayString,
                    GetStringResource (FMT_COPY_COMPLETE_STATS),
                    cfData.dwDirsCreated, cfData.dwFilesCopied);
#endif // TERMSRV
                MessageBox (
                    hwndDlg, szDisplayString,
                    GetStringResource (SZ_APP_TITLE),
                    MB_OK_TASK_INFO);
                FREE_IF_ALLOC (szDisplayString);
            }
        } else {
            DisplayMessageBox (
                hwndDlg,
                NCDU_DISK_NOT_DONE,
                0,
                MB_OK_TASK_EXCL);
        }

        PostMessage (GetParent(hwndDlg), NCDU_SHOW_SW_CONFIG_DLG, 0, 0);
        SetCursor(LoadCursor(NULL, IDC_WAIT));

    } else {
        // unsupported format
        nCancelResult = DisplayMessageBox (
            hwndDlg,
            NCDU_UNKNOWN_FLOPPY,
            0,
            MB_OK_TASK_EXCL);
    }

    FREE_IF_ALLOC (szFromPath);
    FREE_IF_ALLOC (szClientName);
    FREE_IF_ALLOC (szDisplayName);
    FREE_IF_ALLOC (szInfName);
    FREE_IF_ALLOC (szDiskName);
    FREE_IF_ALLOC (szVolumeLabel);
    FREE_IF_ALLOC (szClientSection);

    return TRUE;
}

static
BOOL
CopyFlopDlg_WM_COMMAND (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    processes the WM_COMMAND windows message. The only buttons processed
        are:
            IDCANCEL    which will cause the dlg box to exit.
            Make Disks  start the copy file process

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        LOWORD  has ID of control selected

    IN  LPARAM  lParam
        Not Used.

Return Value:

    TRUE if message not processed,
        otherwise value returned by selected function

--*/
{
    switch (LOWORD(wParam)) {
        case IDCANCEL:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
#ifdef TERMSRV
                    if ( szCommandLineVal[0] != 0x00 )
                       PostQuitMessage(ERROR_SUCCESS);
#endif // TERMSRV
                    PostMessage (GetParent(hwndDlg), NCDU_SHOW_SHARE_NET_SW_DLG, 0, 0);
                    SetCursor(LoadCursor(NULL, IDC_WAIT));
                    return TRUE;

                default:
                    return FALSE;
            }

        case NCDU_CLIENT_SOFTWARE_LIST:
            switch (HIWORD(wParam)) {
                case LBN_SELCHANGE:
                    // update the disk count for the currently selected client
                    UpdateDiskCount (hwndDlg);
                    return TRUE;

                case LBN_DBLCLK:
                    // pretend that the OK buton was pressed
                    PostMessage (hwndDlg, WM_COMMAND,
                        MAKEWPARAM (NCDU_MAKE_DISKS, BN_CLICKED),
                        (LPARAM)GetDlgItem(hwndDlg, NCDU_MAKE_DISKS));
                    return TRUE;

                default:
                    return FALSE;
            }

        case NCDU_MAKE_DISKS:   return CopyFlopDlg_NCDU_MAKE_DISKS (hwndDlg);
        case NCDU_CREATE_INSTALL_DISKS_HELP:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
//                    return ShowAppHelp (hwndDlg, LOWORD(wParam));
                    return PostMessage (GetParent(hwndDlg), WM_HOTKEY,
                        (WPARAM)NCDU_HELP_HOT_KEY, 0);

                default:
                    return FALSE;
            }

        default:                return TRUE;
    }
}

INT_PTR CALLBACK
CopyFlopDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Main window processing routine. Processes the following messages by
        dispatching to the local processing routine. All other messages
        are handled by the default dialog procedure.

            WM_INITDIALOG:  dialog box initialization
            WM_COMMAND:     user input message
            WM_PAINT:       for painting icon when minimized
            WM_MOVE:        for saving the new location of the window
            WM_SYSCOMMAND:  for processing menu messages


Arguments:

    standard WNDPROC arguments

Return Value:

    FALSE if message not processed here, otherwise
        value returned by dispatched routine.

--*/
{
    switch (message) {
        case WM_INITDIALOG: return (CopyFlopDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
        case WM_COMMAND:    return (CopyFlopDlg_WM_COMMAND (hwndDlg, wParam, lParam));
        case WM_PAINT:      return (Dlg_WM_PAINT (hwndDlg, wParam, lParam));
        case WM_MOVE:       return (Dlg_WM_MOVE (hwndDlg, wParam, lParam));
        case WM_SYSCOMMAND: return (Dlg_WM_SYSCOMMAND (hwndDlg, wParam, lParam));
        default:            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\dirbrows.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    DirBrows.H

Abstract:

    Directory browser dialog box functions

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"
//
//  static data
//
static  PDB_DATA    pDbData = NULL;
static  TCHAR       szSaveCurrentDir[MAX_PATH];
static  TCHAR       szReturnPath[MAX_PATH+1];

static
BOOL
UpdateReturnPath (
    LPCTSTR szNewDir
)
/*++

Routine Description:

    appends the "new dir" from the argument and updates the current
        fully qualified path in the return buffer (this is to accomodate
        relative directory entries (e.g. "..")).

Arguments:

    directory to add to current path

Return Value:

    TRUE if path updated
    FALSE if an error occured

--*/
{
    LPTSTR  szLocalPath;
    DWORD   dwLength;

    szLocalPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szLocalPath != NULL) {
        lstrcpy (szLocalPath, szReturnPath);
        if (szLocalPath[lstrlen(szLocalPath)-1] != cBackslash) {
            lstrcat (szLocalPath, cszBackslash);
        }
        lstrcat (szLocalPath, szNewDir);
        GetFullPathName (
            szLocalPath,
            MAX_PATH,
            szReturnPath,
            NULL);
        FREE_IF_ALLOC (szLocalPath);

        // remove trailing backslash if not the root dir
        dwLength = lstrlen(szReturnPath);
        if (dwLength > 3) {
            if (szReturnPath[dwLength-1] == cBackslash) {
                szReturnPath[dwLength-1] = 0;
            }
        }
        return TRUE;
    } else {
        return FALSE;
    }
}

static
LPCTSTR
GetDefaultDisplayDir (
    IN LPCTSTR szPath
)
/*++

Routine Description:

    returns a valid and existing path based on the path passed in the
        argument list using the following logic:
            if szPath is valid as is, then return it
            else
                search up the path to the root until a valid dir is
                    found in the path and return that
                if the path is completely bogus, then use the current
                    default direcotry

Arguments:

    IN  LPCTSTR  szPath
        initial path to try

Return Value:

    pointer to read only string containg a path from the logic described
        above.


--*/
{
    static TCHAR    szLocalPath[MAX_PATH];
    BOOL    bFound;
    LONG    lBsCount;
    LPTSTR  szLastBs;
    LPTSTR  szThisChar;
    LPTSTR  szRootBs = NULL;

    if (IsPathADir(szPath)) {
        // this one is valid so return it
        lstrcpy(szLocalPath, szPath);
    } else if ((pDbData->Flags & PDB_FLAGS_NOCHECKDIR) == PDB_FLAGS_NOCHECKDIR) {
        // they don't care about a valid path so just give it back
        lstrcpy(szLocalPath, szPath);
    } else {
        // is this a valid DRIVE?
        if (MediaPresent(szPath, TRUE)) {
            // well the drive is valid, so start backing up the path
            // until a valid dir is found
            lstrcpy (szLocalPath, szPath); // get a local copy of the path
            bFound = FALSE;
            while (!bFound) {
                if (IsUncPath(szPath)) {
                    // goto "root" backslash and save pointer
                    lBsCount = 0;
                    szThisChar = &szLocalPath[0];
                    while (*szThisChar != 0) {
                        if (*szThisChar == cBackslash) lBsCount++;
                        if (lBsCount == 4) {
                            szRootBs = szThisChar;
                            break;
                        }
                    }
                    if (lBsCount != 4) {
                        // bogus path
                        GetCurrentDirectory (MAX_PATH, szLocalPath);
                        bFound = TRUE;
                    } // else all should be OK so far
                } else {
                    szRootBs = &szLocalPath[2];    // dos "root" backslash
                    if (*szRootBs != cBackslash)  {
                        // then this is a bogus path so return the current
                        GetCurrentDirectory (MAX_PATH, szLocalPath);
                        bFound = TRUE;
                    }
                }
                if (!bFound) {
                    szLastBs = szThisChar = &szLocalPath[0];
                    while (*szThisChar != 0) {
                        if (*szThisChar == cBackslash) szLastBs = szThisChar;
                        szThisChar++;
                    }
                    // szThisChar should point to the last backslash found in
                    // the string. If this isn't the "root" backslash, then
                    // replace it with a NULL, otherwise just use the root path
                    if ((szThisChar != szLocalPath) && // not the beginning char
                        (szThisChar != szRootBs)) {     // not the root dir
                        *szLastBs = 0;  // terminate at the BS and see if
                                        //  this is a valid dir.
                        if (IsPathADir(szLocalPath)) {
                            // this works so use it
                            bFound = TRUE;
                        }
                    } else {
                        // hit the root so terminate AFTER the BS and
                        // return what's in the buffer
                        *++szLastBs = 0;
                        bFound = TRUE;
                    }
                }
            }
        } else {
            // this isnt' a valid drive so load current directory
            GetCurrentDirectory (MAX_PATH, szLocalPath);
        }
    }
    return (LPCTSTR)&szLocalPath[0];
}

static
BOOL
ListDirsInEditPath (
    IN  HWND    hwndDlg,
    IN  LPCTSTR szPath
)
/*++

Routine Description:

    Loads directory list box in dialog box using dirs found in path

Arguments:

    IN  HWND    hwndDlg,
        handle to dialog box window

    IN  LPCTSTR szPath
        path to list dirs in.

Return Value:

    TRUE if list box updated
    FALSE if error

--*/
{
    LPTSTR  szLocalPath;

    szLocalPath = GlobalAlloc (GPTR, (lstrlen(szPath) + 1) * sizeof(TCHAR) );

    if (szLocalPath != NULL) {
        lstrcpy (szLocalPath, szPath);
        if (IsPathADir (szLocalPath)) {
            // make a local copy of the path since this call will modify the v