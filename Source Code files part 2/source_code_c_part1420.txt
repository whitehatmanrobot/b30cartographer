0][2]);
                break;
            case 'n':
                g_dwNumEntries = atoi(&argv[0][2]);
                break;
            case 'v':
                g_bVerbose = TRUE;
                break;
            case '?':
                bRC = FALSE;
                break;
            default:
                bRC = FALSE;
                break;
        }
        argv++; argc--;
    }

    if(bRC == FALSE)
    {
        Display_Usage(argvIn[0]);
        bRC = FALSE;
    }

    return(bRC);

}

//=================================================================================
void __cdecl main(int argc,char *argv[])
{

    DWORD Error;
    DWORD i;
    DWORD dwEntries = 0;
    DWORD dwOldEntries = 0;

    if(!ParseCommandLine(argc, argv))
        return;
    
    //
    // init GlobalCacheHeaderInfo buffer.
    //
    for( i = 0; i < CACHE_HEADER_INFO_SIZE; i++) {
        GlobalCacheHeaderInfo[i] = (BYTE)((DWORD)'0' + i % 10);
    }

    if(g_bVerbose)
        printf("FileSize=%d InitEntries=%d NumEntries=%d\r\n", g_dwFileSize, g_dwInitEntries, g_dwNumEntries);

    if(g_dwInitEntries)
        ProcessSimulateCache(g_dwInitEntries);
        
    while(TRUE)
    {
        ProcessSimulateCache(g_dwNumEntries);
        
        dwOldEntries = dwEntries;
        EnumUrlCacheEntries(&dwEntries);
        if(dwEntries < dwOldEntries)    // Quota has been exceeded
            break;

        if(g_bVerbose)
            printf("Entries=%d\r\n", dwEntries);
    }

    printf("setperfmode on\n");
    printf("setquietmode on\n");
    printf("setfilesize %d\n", g_dwFileSize);
    printf("simcache %d\n", dwOldEntries - 4);
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\utils\refcount\refcount.h ===
//=--------------------------------------------------------------------------=
//  (C) Copyright 1997-1998 Microsoft Corporation. All Rights Reserved.
//	TriEdit SDK team
//	Author: Yury Polyakovsky
//	contact: a-yurip@microsof.com
//=--------------------------------------------------------------------------=
class CRefCount
{
public:
	CRefCount() {m_dwRefCount = 1;}
	void SetInstalFlag(BOOL flag) {m_fInstall = flag;}
	void Change(char *szName, PHKEY phkRef);
	BOOL ValueExist(char *sz_RegSubkey, char *sz_RegValue);
	void ValueGet(char *sz_RegSubkey, char *sz_ValueName, LPBYTE *p_Value, DWORD *pdwValueSize);
	void ValueSet(char *sz_RegSubkey, char *sz_RegValue);
	void ValueClear(char *sz_RegSubkey, char *sz_RegValue);
	DWORD GetCount() { return m_dwRefCount;}
private:
	BOOL m_fInstall;
	DWORD m_dwRefCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\place51.inc ===
#
#  Places all of the internet binaries into the inetsrv tree.
#  Also establishes some standard conventions used across the project.
#

#
# Override IISBASEDIR if you're one of those weirdos that didn't
# enlist the IIS project into the correct directory.
#

!IFNDEF IISBASEDIR
IISBASEDIR=$(PROJECT_ROOT)\iis
!ENDIF

#
# We'll use our own COFFBASE.TXT and PLACEFIL.TXT, thank you very much.
#

!IFNDEF COFFBASE_TXT_FILE
COFFBASE_TXT_FILE=$(IISBASEDIR)\coffbase.txt
!ENDIF

!IFNDEF BINPLACE_PLACEFILE
BINPLACE_PLACEFILE=$(IISBASEDIR)\placefil5.txt
!ENDIF

# This used to have the -y option.  Now, inetsrv binaries are binplaced
# to retail, so the symbols should be binplaced to symbols\retail.
# The -y switch causes the symbols to be binplaced to the wrong directory.

BINPLACE_FLAGS=$(BINPLACE_FLAGS)

# enable building legoizable binaries
!ifndef IIS_NO_BBT
NTBBT=1
!endif

# define CAP related options
CAP_LINK_OPTIONS=-debugtype:coff -debug:mapped,partial
CAP_LIBS=$(SDK_LIB_PATH)\cap.lib
CAP_FLAGS= -Zd -Gh

!IFDEF CAP_PROFILE
USER_C_FLAGS=$(USER_C_FLAGS) $(CAP_FLAGS)
LINK_OPTIONS=$(CAP_LINK_OPTIONS)
!ENDIF

# define ICE-CAP related options
ICAP_LINK_OPTIONS=-debugtype:coff -debug:mapped,partial
ICAP_LIBS=$(SDK_LIB_PATH)\icap.lib $(SDK_LIB_PATH)\penter.lib
ICAP_FLAGS= -Zi -Gh

!IFDEF ICAP_PROFILE
USER_C_FLAGS=$(USER_C_FLAGS) $(ICAP_FLAGS)
LINK_OPTIONS=$(ICAP_LINK_OPTIONS)
!ENDIF

!ifndef IIS_NO_PDB
USE_PDB=1
!endif

!if $(386)
!ifndef IIS_NO_SYM
USE_MAPSYM=1
!endif
!endif



#  !ifdef _NT386TREE
#  !if ("$(COMPUTERNAME)" == "X86CHK")
#  _NT386TREE=$(_NT386TREE)\InetSrv
#  !elseif ("$(COMPUTERNAME)" == "X86FRE")
#  _NT386TREE=$(_NT386TREE)\InetSrv
#  !else
#  _NT386TREE=$(_NT386TREE)\iis
#  !endif
#  !endif


#  !ifdef _NTMIPSTREE
#  _NTMIPSTREE=$(_NTMIPSTREE)\iis
#  !endif


#  !ifdef _NTALPHATREE
#  !if ("$(COMPUTERNAME)" == "ALPHACHK")
#  _NTALPHATREE=$(_NTALPHATREE)\InetSrv
#  !elseif ("$(COMPUTERNAME)" == "ALPHAFRE")
#  _NTALPHATREE=$(_NTALPHATREE)\InetSrv
#  !else
#  _NTALPHATREE=$(_NTALPHATREE)\iis
#  !endif
#  !endif


#  !ifdef _NTPPCTREE
#  _NTPPCTREE=$(_NTPPCTREE)\iis
#  !endif

#
# Enable warning level 3, treat warnings as errors
#

!ifndef MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3 /WX
!endif

#
# Don't allow anyone to disable warnings as errors.
#
# If any of the {platform}_WARNING_LEVEL macros are defined without
# the /WX switch, append /WX to the macro and whine about it.
#
!if 0

!ifdef 386_WARNING_LEVEL
! if ("$(386_WARNING_LEVEL:/WX=x)" == "$(386_WARNING_LEVEL)") && ("$(386_WARNING_LEVEL:-WX=x)" == "$(386_WARNING_LEVEL)")
!  message 386_WARNING_LEVEL defined without /WX
386_WARNING_LEVEL=$(386_WARNING_LEVEL) /WX
! endif
!endif

!ifdef MIPS_WARNING_LEVEL
! if ("$(MIPS_WARNING_LEVEL:/WX=x)" == "$(MIPS_WARNING_LEVEL)") && ("$(MIPS_WARNING_LEVEL:-WX=x)" == "$(MIPS_WARNING_LEVEL)")
!  message MIPS_WARNING_LEVEL defined without /WX
MIPS_WARNING_LEVEL=$(MIPS_WARNING_LEVEL) /WX
! endif
!endif

!ifdef ALPHA_WARNING_LEVEL
! if ("$(ALPHA_WARNING_LEVEL:/WX=x)" == "$(ALPHA_WARNING_LEVEL)") && ("$(ALPHA_WARNING_LEVEL:-WX=x)" == "$(ALPHA_WARNING_LEVEL)")
!  message ALPHA_WARNING_LEVEL defined without /WX
ALPHA_WARNING_LEVEL=$(ALPHA_WARNING_LEVEL) /WX
! endif
!endif

!ifdef PPC_WARNING_LEVEL
! if ("$(PPC_WARNING_LEVEL:/WX=x)" == "$(PPC_WARNING_LEVEL)") && ("$(PPC_WARNING_LEVEL:-WX=x)" == "$(PPC_WARNING_LEVEL)")
!  message PPC_WARNING_LEVEL defined without /WX
PPC_WARNING_LEVEL=$(PPC_WARNING_LEVEL) /WX
! endif
!endif

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\place.inc ===
#
#  Places all of the internet binaries into the inetsrv tree.
#  Also establishes some standard conventions used across the project.
#

#
# Override IISBASEDIR if you're one of those weirdos that didn't
# enlist the IIS project into the correct directory.
#

!IFNDEF IISBASEDIR
IISBASEDIR=$(PROJECT_ROOT)\iis
!ENDIF

#
# We'll use our own COFFBASE.TXT and PLACEFIL.TXT, thank you very much.
#

!IFNDEF COFFBASE_TXT_FILE
COFFBASE_TXT_FILE=$(IISBASEDIR)\coffbase.txt
!ENDIF

!IFNDEF BINPLACE_PLACEFILE
BINPLACE_PLACEFILE=$(IISBASEDIR)\placefil.txt
!ENDIF

# This used to have the -y option.  Now, inetsrv binaries are binplaced
# to retail, so the symbols should be binplaced to symbols\retail.
# The -y switch causes the symbols to be binplaced to the wrong directory.

BINPLACE_FLAGS=$(BINPLACE_FLAGS)

# enable building legoizable binaries
!ifndef IIS_NO_BBT
NTBBT=1
!endif

# define CAP related options
CAP_LINK_OPTIONS=-debugtype:coff -debug:mapped,partial
CAP_LIBS=$(SDK_LIB_PATH)\cap.lib
CAP_FLAGS= -Zd -Gh

!IFDEF CAP_PROFILE
USER_C_FLAGS=$(USER_C_FLAGS) $(CAP_FLAGS)
LINK_OPTIONS=$(CAP_LINK_OPTIONS)
!ENDIF

# define ICE-CAP related options
ICAP_LINK_OPTIONS=-debugtype:coff -debug:mapped,partial
ICAP_LIBS=$(SDK_LIB_PATH)\icap.lib $(SDK_LIB_PATH)\penter.lib
ICAP_FLAGS= -Zi -Gh

!IFDEF ICAP_PROFILE
USER_C_FLAGS=$(USER_C_FLAGS) $(ICAP_FLAGS)
LINK_OPTIONS=$(ICAP_LINK_OPTIONS)
!ENDIF

!ifndef IIS_NO_PDB
USE_PDB=1
!endif

!if $(386)
!ifndef IIS_NO_SYM
USE_MAPSYM=1
!endif
!endif



#  !ifdef _NT386TREE
#  !if ("$(COMPUTERNAME)" == "X86CHK")
#  _NT386TREE=$(_NT386TREE)\InetSrv
#  !elseif ("$(COMPUTERNAME)" == "X86FRE")
#  _NT386TREE=$(_NT386TREE)\InetSrv
#  !else
#  _NT386TREE=$(_NT386TREE)\iis
#  !endif
#  !endif


#  !ifdef _NTMIPSTREE
#  _NTMIPSTREE=$(_NTMIPSTREE)\iis
#  !endif


#  !ifdef _NTALPHATREE
#  !if ("$(COMPUTERNAME)" == "ALPHACHK")
#  _NTALPHATREE=$(_NTALPHATREE)\InetSrv
#  !elseif ("$(COMPUTERNAME)" == "ALPHAFRE")
#  _NTALPHATREE=$(_NTALPHATREE)\InetSrv
#  !else
#  _NTALPHATREE=$(_NTALPHATREE)\iis
#  !endif
#  !endif


#  !ifdef _NTPPCTREE
#  _NTPPCTREE=$(_NTPPCTREE)\iis
#  !endif

#
# Enable warning level 3, treat warnings as errors
#

!ifndef MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3 /WX
!endif

#
# Don't allow anyone to disable warnings as errors.
#
# If any of the {platform}_WARNING_LEVEL macros are defined without
# the /WX switch, append /WX to the macro and whine about it.
#
!if 0

!ifdef 386_WARNING_LEVEL
! if ("$(386_WARNING_LEVEL:/WX=x)" == "$(386_WARNING_LEVEL)") && ("$(386_WARNING_LEVEL:-WX=x)" == "$(386_WARNING_LEVEL)")
!  message 386_WARNING_LEVEL defined without /WX
386_WARNING_LEVEL=$(386_WARNING_LEVEL) /WX
! endif
!endif

!ifdef MIPS_WARNING_LEVEL
! if ("$(MIPS_WARNING_LEVEL:/WX=x)" == "$(MIPS_WARNING_LEVEL)") && ("$(MIPS_WARNING_LEVEL:-WX=x)" == "$(MIPS_WARNING_LEVEL)")
!  message MIPS_WARNING_LEVEL defined without /WX
MIPS_WARNING_LEVEL=$(MIPS_WARNING_LEVEL) /WX
! endif
!endif

!ifdef ALPHA_WARNING_LEVEL
! if ("$(ALPHA_WARNING_LEVEL:/WX=x)" == "$(ALPHA_WARNING_LEVEL)") && ("$(ALPHA_WARNING_LEVEL:-WX=x)" == "$(ALPHA_WARNING_LEVEL)")
!  message ALPHA_WARNING_LEVEL defined without /WX
ALPHA_WARNING_LEVEL=$(ALPHA_WARNING_LEVEL) /WX
! endif
!endif

!ifdef PPC_WARNING_LEVEL
! if ("$(PPC_WARNING_LEVEL:/WX=x)" == "$(PPC_WARNING_LEVEL)") && ("$(PPC_WARNING_LEVEL:-WX=x)" == "$(PPC_WARNING_LEVEL)")
!  message PPC_WARNING_LEVEL defined without /WX
PPC_WARNING_LEVEL=$(PPC_WARNING_LEVEL) /WX
! endif
!endif

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\utils\refcount\refcount.cxx ===
//=--------------------------------------------------------------------------=
//  (C) Copyright 1997-1998 Microsoft Corporation. All Rights Reserved.
//	TriEdit SDK team
//	Author: Yury Polyakovsky
//	contact: a-yurip@microsof.com
//=--------------------------------------------------------------------------=
// Refcount support for DLLs
// Call:	refcount < Install | Uninstall | CopyToClient | SetClient | ClearClient | Copy >, <registry key> [, <file name>[, <client subdirectory> I <destination for Copy>] | <component full path>]
// Call refcount.exe from an application's setup: 
// Install : Increment ref-count for the component if it was not installed before by the app
// Uninstall : Decrement ref-count for the component if it was installed before by the app, deletes it if ref-count goes to 0
// CopyToClient : Copies the component to the application's directory (from the registry)
// SetClient : Set the flag in the registry that the component was installed by the application
// CreateDir : Checks on the directory  "C:\Program Files\Common Files" and create one if it's not there
// ClearClient :  Clear the flag in the registry that the component was installed by the application
// Copy: Copy to specified destination.
#include <ctype.h>
#include <windef.h>
#include <stdarg.h>
#include <stdlib.h>
#include <winbase.h>
#include <winreg.h>
#include <winuser.h>
#include <crtdbg.h>
#include <shlwapi.h>
#include "RefCount.h"

#define STRINGOP(func, param1, param2) 	(func(param1, param2, sizeof(param1)/sizeof(param1[0])))
#define STRINGOPL(func, param1, param2) 	(func(param1, param2, strlen(param1)))
#define SKIPSPACES(psz)	{for (++psz; *psz == ' ' && *psz != '\0'; ++psz); if (!*psz) psz=NULL;}
BOOL PASCAL ReplaceFileOnReboot (LPCTSTR pszExisting, LPCTSTR pszNew);

int WINAPI WinMain(  HINSTANCE hInstance,  // handle to current instance
  HINSTANCE hPrevInstance,  // handle to previous instance
  LPSTR lpCmdLine,      // pointer to command line
  int nCmdShow)          // show state of window);int main(int argc, char** argv)
{
	_ASSERT(*lpCmdLine);
	if (!*lpCmdLine)
	{
		// No command line
		return 1;
	}

	CRefCount	RefCount;
	char szRegKey[MAX_PATH] = "";
	char szRegInstalling[MAX_PATH] = "";
	char szRegInstalled[MAX_PATH] = "";
	char sz_AppPath[MAX_PATH] = "";
	char sz_Application[MAX_PATH] = "";
	char sz_Dir[MAX_PATH] = "";
	char *pszAppPath = sz_AppPath;
	char *pszApplication = sz_Application;
	BOOL bMultiInstall = FALSE;
	BOOL *pbInstallMode = &bMultiInstall;
	DWORD dwValueSize = sizeof(sz_AppPath);

	//_ASSERT(FALSE);

	if (!STRINGOPL(_strnicmp, "CreateDir", lpCmdLine/*argv[1]*/))
	{
		dwValueSize = sizeof(sz_Application);
		RefCount.ValueGet("SOFTWARE\\Microsoft\\Windows\\CurrentVersion", "CommonFilesDir", (LPBYTE *)&pszApplication, &dwValueSize);
		_ASSERT(pszApplication);
		if (pszApplication)
		{
			if (!CreateDirectory(pszApplication, NULL))
				DWORD dwError = GetLastError();
		}
		return 0;
	}

	LPSTR pszRegName = strchr(lpCmdLine, ',');
	_ASSERT(pszRegName);
	if (!pszRegName)
		// command line not complete
		return 1;

	SKIPSPACES(pszRegName);
	_ASSERT(pszRegName);
	if (!pszRegName)
		// command line not complete
		return 1;

	LPSTR pszPathName = strchr(pszRegName, ',');
	if (pszPathName)
	{
		SKIPSPACES(pszPathName);
	}
	STRINGOP(strncpy, szRegKey, pszRegName/*argv[2]*/);
	if (LPSTR pszEndRegName = strchr(szRegKey, ','))
		*pszEndRegName = '\0';
	STRINGOP(strncpy, szRegInstalling, szRegKey/*argv[2]*/);
	STRINGOP(strncat , szRegInstalling, "\\InstallingClient");
	RefCount.ValueGet(szRegInstalling, "Path", (LPBYTE *)&pszAppPath, &dwValueSize);
	dwValueSize = sizeof(sz_Application);
	RefCount.ValueGet(szRegInstalling, "Application", (LPBYTE *)&pszApplication, &dwValueSize);
	dwValueSize = sizeof(BOOL);
	RefCount.ValueGet(szRegInstalling, "MultiInstall", (LPBYTE *)&pbInstallMode, &dwValueSize);
	if (pszAppPath && ((pbInstallMode && bMultiInstall) || !STRINGOPL(_strnicmp, "CopyToClient", lpCmdLine/*argv[1]*/)))
	{
		STRINGOP(strncat, pszAppPath, "\\");
		STRINGOP(strncpy, sz_Dir, pszAppPath);
		STRINGOP(strncat, sz_AppPath, sz_Application);
	}
	else 
		STRINGOP(strncpy, sz_AppPath, sz_Application);

	// FInd the path in InstalledClients
	STRINGOP(strncpy, szRegInstalled, szRegKey/*argv[2]*/);
	STRINGOP(strncat, szRegInstalled, "\\InstalledClients");

	char szTmp[MAX_PATH];
	strcpy(szTmp, pszPathName);
	char* x = strchr(szTmp, ',');
	char szGUID[MAX_PATH];
	char* pszGUID = NULL;

	if( x )
	{
		// IE passed component guid so we need to check...
		strcpy(szGUID, x);
		*x = '\0';
		strcpy(pszPathName, szTmp);

		// now szGuid = " , {aab-cc-dd-ee}", need to stript white space and ','
		pszGUID = szGUID;
		for( int i = 0; i < MAX_PATH; i++)
		{
			if( *pszGUID != ' ' && *pszGUID != ',')
				break;
			pszGUID++;
		}
		if( i == MAX_PATH || *pszGUID == '\0' )
        {
			pszGUID = NULL;
        }
	}


	if (!STRINGOPL(_strnicmp, "CopyToClient", lpCmdLine/*argv[1]*/))
	{
		_ASSERT(pszPathName);
		if (!pszPathName)
			return 2;
		else
		{
			LPSTR pszDestSubDir = strchr(pszPathName, ',');
			if (pszDestSubDir)
			{
				SKIPSPACES(pszDestSubDir);
				STRINGOP(strncat, sz_Dir, pszDestSubDir);
				STRINGOP(strncat, sz_Dir, "\\");
			}
			if (LPSTR pszPathNameEnd = strchr(pszPathName, ','))
				*pszPathNameEnd = '\0';
			// Copy files we need for Uninstall to the client location
			STRINGOP(strncat, sz_Dir, pszPathName);
			if (LPSTR pszDestDirEnd = strchr(sz_Dir, ','))
				*pszDestDirEnd = '\0';
			if (!CopyFile(pszPathName/*argv[3]*/, sz_Dir, FALSE))
			{
				DWORD dwError = GetLastError();
				_ASSERTE(!dwError);
				return 2;
			}
			return 0;
		}
	}
	else if (!STRINGOPL(_strnicmp, "Copy", lpCmdLine/*argv[1]*/))
	{
		_ASSERT(pszPathName);
		if (!pszPathName)
			return 2;
		else
		{
			LPSTR pszDestSubDir = strchr(pszPathName, ',');
			if (pszDestSubDir)
			{
				SKIPSPACES(pszDestSubDir);
				STRINGOP(strncpy, sz_Dir, pszDestSubDir);
			}
			if (LPSTR pszPathNameEnd = strchr(pszPathName, ','))
				*pszPathNameEnd = '\0';
			// Copy files we need for Uninstall to the client location
			if (LPSTR pszDestDirEnd = strchr(sz_Dir, ','))
				*pszDestDirEnd = '\0';
			if (!CopyFile(pszPathName/*argv[3]*/, sz_Dir, FALSE))
			{
				DWORD dwError = GetLastError();
				_ASSERTE(!dwError);
				return 2;
			}
			return 0;
		}
	}
		else if (!RefCount.ValueExist(szRegInstalled, sz_AppPath) && !STRINGOPL(_strnicmp, "Install", lpCmdLine/*argv[1]*/))
		{
			// Increment ref-count
			if( pszGUID )
			{
				// some check needed...
				// is the component installed?
				HKEY hkInstalled = NULL;
				char szKeyName[MAX_PATH];
				strcpy(szKeyName, "SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\");
				strcat(szKeyName, pszGUID);

				if( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_ALL_ACCESS, &hkInstalled) 
				)
				{
					DWORD dwType = 0;
					BYTE bValueData[16];
					DWORD cValueData = sizeof(bValueData);;
					if (ERROR_SUCCESS == RegQueryValueEx( hkInstalled, "IsInstalled", NULL, &dwType, bValueData, &cValueData))
					{
						if( *(LPDWORD)(bValueData) )
						{
							// this app has been installed, we need to do nothing... (do not perform refcount, just quit)
							RegCloseKey(hkInstalled);
							return 0;
						}
						
					}
					RegCloseKey(hkInstalled);
				}
			}

			// we are here because 
			// 1. no guid passed from cmd line
			// 2. or component not installed (the RegQueryValue failed..)
			// so we continue to do refcount...

			RefCount.SetInstalFlag(TRUE);
		}
		else if (!RefCount.ValueExist(szRegInstalled, sz_AppPath) && !STRINGOPL(_strnicmp, "SetClient", lpCmdLine/*argv[1]*/))
		{
			// Set the app's installed flag
			RefCount.ValueSet(szRegInstalled, sz_AppPath);
			RegDeleteKey (HKEY_LOCAL_MACHINE, szRegInstalling); // we don't need it anymore
			return 0;
		}
		else if (!STRINGOPL(_strnicmp, "Uninstall", lpCmdLine/*argv[1]*/))
		{
			// Decrement ref-count
			RefCount.SetInstalFlag(FALSE);
		}
		else if (!STRINGOPL(_strnicmp, "ClearClient", lpCmdLine/*argv[1]*/))
		{
			// Remove the app's installed flag
			RefCount.ValueClear(szRegInstalled, sz_AppPath);
			RegDeleteKey(HKEY_LOCAL_MACHINE, szRegInstalling); // we don't need it anymore
			return 0;
		}
		else if (!STRINGOPL(_strnicmp, "SetClient", lpCmdLine/*argv[1]*/))
		{
			// Subsequent Installation
			RegDeleteKey(HKEY_LOCAL_MACHINE, szRegInstalling); // we don't need it anymore
			return 0;
		}
		else
			// Subsequent Installation
			return 0;

	HKEY hkRef;    // address of handle to open key
	DWORD dwDisposition;   // address of disposition value buffer
	LONG lRet;

	lRet = RegCreateKeyEx  (HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs", 
		0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkRef, &dwDisposition);
	_ASSERT(REG_OPENED_EXISTING_KEY == dwDisposition);
	_ASSERT(ERROR_SUCCESS == lRet);
	if (ERROR_SUCCESS != lRet)
	{
		return 3;
	}

	_ASSERT(pszPathName);
	if (pszPathName)
	{
		RefCount.Change(pszPathName/*argv[3]*/, &hkRef);
		if (RefCount.GetCount() <= 0)
		{
			_ASSERT(RefCount.GetCount() == 0);
			//RegDeleteKey(HKEY_LOCAL_MACHINE, szRegInstalling); // we don't need it anymore
			//RegDeleteKey(HKEY_LOCAL_MACHINE, szRegInstalled); // we don't need it anymore
			//RegDeleteKey(HKEY_LOCAL_MACHINE, szRegKey); // we don't need it anymore
		}
	}

	RegCloseKey(hkRef);

	return 0;
}

void CRefCount::Change(char *szName, PHKEY phkRef)
{
	DWORD dwIndex = 0;
	DWORD cValueName = 0;
	DWORD dwType = 0;
	BYTE bValueData[16];
	DWORD cValueData = sizeof(bValueData);;

	// Check if the conponent exits
	if (ERROR_SUCCESS == RegQueryValueEx( *phkRef, szName, NULL, &dwType, bValueData, &cValueData))
	{
		// Found
		_ASSERT(dwType == REG_DWORD);
		m_dwRefCount = *(LPDWORD)(bValueData);
		(m_fInstall) ? ++m_dwRefCount : --m_dwRefCount;
	}
	else if (!m_fInstall)
	{
		// Trying to Uninstall the component that was not ref-counted before
		// Just delete it
//		_ASSERT(m_fInstall);
		if (!DeleteFile(szName))
		{
			if (!ReplaceFileOnReboot(szName, NULL))
			{
				DWORD dwError = GetLastError();
				_ASSERTE(!dwError);
			}
		}
		return;
	}
	// If not found, create new else just overwrite it.
	*(LPDWORD)(bValueData) = m_dwRefCount;
	if (m_dwRefCount == 0)
	{
        char szDllFullPath[MAX_PATH+1];
        DWORD dwLen = 0;
        dwLen = strlen(szName);
        char* p = NULL;
        if( dwLen <= MAX_PATH )
        {
            strcpy(szDllFullPath, szName);
            for( int i = dwLen; i >= 0; i--)
            {
                if( szDllFullPath[i] == '\\' ) 
                {
                    p = &(szDllFullPath[i+1]);    
                    break;
                }
            }
        }

		if( p && 
            !_stricmp(p, "msdapml.dll") && 
            !_stricmp(p, "msonsext.dll") &&
            !_stricmp(p, "ragent.tlb") &&
            !_stricmp(p, "ragent.dll") &&
            !_stricmp(p, "fp4autl.dll") &&
            !_stricmp(p, "fp4anwi.dll") 
        ) {
		    // Last rererence deleted
		    HINSTANCE hInst = LoadLibrary(szName);
		    FARPROC pDllUnregisterServer = NULL;
		    if (hInst && (pDllUnregisterServer = GetProcAddress(hInst, "DllUnregisterServer")))
		    {
			    pDllUnregisterServer();
		    }
		    else
		    {
			    DWORD dwError = GetLastError();
		    }

		    FreeLibrary(hInst);
        }

		RegDeleteValue(*phkRef, szName);

		if (!DeleteFile(szName))
		{
			if (!ReplaceFileOnReboot(szName, NULL))
			{
				DWORD dwError = GetLastError();
				_ASSERTE(!dwError);
			}
		}
        

		if( p && !_stricmp(p, "msonsext.dll") )
		{
	        LONG lRet =0;

			lRet = RegDeleteKey (HKEY_CLASSES_ROOT,"CLSID\\{BDEADF00-C265-11d0-BCED-00A0C90AB50F}");
			lRet = RegDeleteKey (HKEY_CLASSES_ROOT,"CLSID\\{BDEADF04-C265-11d0-BCED-00A0C90AB50F}");
			lRet = RegDeleteKey (HKEY_CLASSES_ROOT,"Publishing Folder");
			lRet = RegDeleteKey (HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{BDEADF00-C265-11d0-BCED-00A0C90AB50F}");

	        HKEY hkRef = NULL;  
			lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved", 0, KEY_ALL_ACCESS, &hkRef);
	
	        if (ERROR_SUCCESS == lRet)
	        {
		        RegDeleteValue(hkRef, "{BDEADF00-C265-11d0-BCED-00A0C90AB50F}"); 
                RegCloseKey(hkRef);
	        }
		}
	}
	else
		RegSetValueEx(*phkRef, szName, 0, REG_DWORD, bValueData, sizeof(DWORD));
}

BOOL CRefCount::ValueExist(char *sz_RegSubkey, char *sz_RegValue)
{
	HKEY hkRef = NULL;    // address of handle to open key
	LONG lRet =0;
	BOOL fret = FALSE;

	lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz_RegSubkey, 
		0, KEY_ALL_ACCESS, &hkRef);
	
	if (ERROR_SUCCESS != lRet)
	{
		return FALSE;
	}
	else 
	{
		lRet = RegQueryValueEx(hkRef, sz_RegValue, 0, NULL, NULL, NULL);
		if (ERROR_SUCCESS != lRet)
			fret = FALSE;
		else
			fret = TRUE;
	}
	RegCloseKey(hkRef);
	return fret;
}

void CRefCount::ValueSet(char *sz_RegSubkey, char *sz_RegValue)
{
	HKEY hkRef = NULL;    // address of handle to open key
	LONG lRet =0;
	DWORD dwValiue = 1;
	DWORD dwDisposition;   // address of disposition value buffer

	lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, sz_RegSubkey, 
		0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkRef, &dwDisposition);
	
	_ASSERT(ERROR_SUCCESS == lRet);
	if (ERROR_SUCCESS != lRet)
	{
		return;
	}
	else 
	{
		RegSetValueEx(hkRef, sz_RegValue, 0, REG_DWORD, (BYTE  *)&dwValiue, sizeof(dwValiue));
	}
}

void CRefCount::ValueGet(char *sz_RegSubkey,  char *sz_ValueName, LPBYTE *p_Value, DWORD *pdwValueSize)
{
	HKEY hkRef = NULL;    // address of handle to open key
	LONG lRet =0;
	DWORD dwValiue = 1;

	lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz_RegSubkey, 
		0, KEY_ALL_ACCESS, &hkRef);
	
	if (ERROR_SUCCESS != lRet)
	{
		*p_Value = NULL;
	}
	else 
	{
		lRet = RegQueryValueEx(hkRef, sz_ValueName, 0, NULL, *p_Value, pdwValueSize);
		if (ERROR_SUCCESS != lRet)
		{
			*p_Value = NULL;
		}
	}
}

void CRefCount::ValueClear(char *sz_RegSubkey, char *sz_RegValue)
{
	HKEY hkRef = NULL;    // address of handle to open key
	LONG lRet =0;
	DWORD dwValiue = 1;

	lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz_RegSubkey, 
		0, KEY_ALL_ACCESS, &hkRef);
	
	if (ERROR_SUCCESS != lRet)
	{
		return;
	}
	else 
	{
		RegDeleteValue(hkRef, sz_RegValue);
	}
}

BOOL PASCAL ReplaceFileOnReboot (LPCTSTR pszExisting, LPCTSTR pszNew) 
{
//	_ASSERT(FALSE);
   // First, attempt to use the MoveFileEx function.
   BOOL fOk = MoveFileEx(pszExisting, pszNew, MOVEFILE_DELAY_UNTIL_REBOOT);
   if (fOk) return(fOk);

   // If MoveFileEx failed, we are running on Windows 95 and need to add
   // entries to the WININIT.INI file (an ANSI file).
   // Start a new scope for local variables.
   {
   char szRenameLine[1024];   
   TCHAR szExistingShort[_MAX_PATH];

   GetShortPathName(pszExisting, szExistingShort, sizeof(szExistingShort) / sizeof(szExistingShort[0]));
   int cchRenameLine = wsprintfA(szRenameLine, 
#ifdef UNICODE
      "%ls=%ls\r\n", 
#else
      "%hs=%hs\r\n", 
#endif
      (pszNew == NULL) ? __TEXT("NUL") : pszNew, szExistingShort);
      char szRenameSec[] = "[Rename]\r\n";
      int cchRenameSec = sizeof(szRenameSec) - 1;
      HANDLE hfile, hfilemap;
      DWORD dwFileSize, dwRenameLinePos;
      TCHAR szPathnameWinInit[_MAX_PATH];

      // Construct the full pathname of the WININIT.INI file.
      GetWindowsDirectory(szPathnameWinInit, _MAX_PATH);
      lstrcat(szPathnameWinInit, __TEXT("\\WinInit.Ini"));

      // Open/Create the WININIT.INI file.
      hfile = CreateFile(szPathnameWinInit,      
         GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 
         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

      if (hfile == INVALID_HANDLE_VALUE) 
         return(fOk);	// It is still FALSE

      // Create a file mapping object that is the current size of 
      // the WININIT.INI file plus the length of the additional string
      // that we're about to insert into it plus the length of the section
      // header (which we might have to add).
      dwFileSize = GetFileSize(hfile, NULL);
      hfilemap = CreateFileMapping(hfile, NULL, PAGE_READWRITE, 0, 
         dwFileSize + cchRenameLine + cchRenameSec, NULL);

      if (hfilemap != NULL) {

         // Map the WININIT.INI file into memory.  Note: The contents 
         // of WININIT.INI are always ANSI; never Unicode.
         LPSTR pszWinInit = (LPSTR) MapViewOfFile(hfilemap, 
            FILE_MAP_WRITE, 0, 0, 0);
		 pszWinInit[dwFileSize] = 0;	// Make sure it is null terminated. Yury

         if (pszWinInit != NULL) {

            // Search for the [Rename] section in the file.
            LPSTR pszRenameSecInFile = strstr(pszWinInit, szRenameSec);

            if (pszRenameSecInFile == NULL) {

               // There is no [Rename] section in the WININIT.INI file.
               // We must add the section too.
               dwFileSize += wsprintfA(&pszWinInit[dwFileSize], "%s",
                                       szRenameSec);
               dwRenameLinePos = dwFileSize;

            } else {

               // We found the [Rename] section, shift all the lines down
               PSTR pszFirstRenameLine = strchr(pszRenameSecInFile, '\n');
               // Shift the contents of the file down to make room for 
               // the newly added line.  The new line is always added 
               // to the top of the list.
               pszFirstRenameLine++;   // 1st char on the next line
               memmove(pszFirstRenameLine + cchRenameLine, pszFirstRenameLine, 
                  pszWinInit + dwFileSize - pszFirstRenameLine);                  
               dwRenameLinePos = pszFirstRenameLine - pszWinInit;
            }

            // Insert the new line
            memcpy(&pszWinInit[dwRenameLinePos], szRenameLine, cchRenameLine);

            UnmapViewOfFile(pszWinInit);

            // Calculate the true, new size of the file.
            dwFileSize += cchRenameLine;

            // Everything was successful.
            fOk = TRUE; 
         }
         CloseHandle(hfilemap);
      }

      // Force the end of the file to be the calculated, new size.
      SetFilePointer(hfile, dwFileSize, NULL, FILE_BEGIN);
      SetEndOfFile(hfile);

      CloseHandle(hfile);
   }

   return(fOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cenumobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:      cenumobj.cxx
//
//  Contents:  IIS Object Enumeration Code
//
//              CIISGenObjectEnum::CIISGenObjectEnum()
//              CIISGenObjectEnum::CIISGenObjectEnum
//              CIISGenObjectEnum::Create
//              CIISGenObjectEnum::GetGenObjects
//              CIISGenObjectEnum::EnumGenericObjects
//              CIISGenObjectEnum::Next
//
//  History:    28-Feb-97   SophiaC     Created.
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:   
//
//----------------------------------------------------------------------------
/* INTRINSA suppress=null_pointers, uninitialized */
HRESULT
CIISGenObjectEnum::Create(
    CIISGenObjectEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    VARIANT var,
    CCredentials& Credentials
    )
{

    HRESULT hr = NOERROR;
    CIISGenObjectEnum FAR* penumvariant = NULL;

    LPWSTR pszIISPathName = NULL;
    DWORD dwStatus = 0;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = NULL;
    CLexer Lexer(ADsPath);

    *ppenumvariant = NULL;

    penumvariant = new CIISGenObjectEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    pObjectInfo = &ObjectInfo;
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);


    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    //
    // Store ServerName
    //

    penumvariant->_pszServerName = AllocADsStr(pObjectInfo->TreeName);
	

    if (!(penumvariant->_pszServerName)) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = InitServerInfo(penumvariant->_pszServerName,
                        &(penumvariant->_pAdminBase),
                        &(penumvariant->_pSchema));
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(ADsPath);

    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memset(pszIISPathName, 0, sizeof(pszIISPathName));

    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_pszMetaBasePath = AllocADsStr(pszIISPathName);

    if (!(penumvariant->_pszMetaBasePath)) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:

    if (FAILED(hr)) {
        if (penumvariant) {
            delete penumvariant;
            *ppenumvariant = NULL;
        }
    }

    if (pszIISPathName) {
        FreeADsStr(pszIISPathName);
    }

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);
}

CIISGenObjectEnum::CIISGenObjectEnum():
                    _ADsPath(NULL),
                    _pszServerName(NULL),
					_pSchema(NULL),
					_pAdminBase(NULL),
					_pszMetaBasePath(NULL)
{
    _dwObjectCurrentEntry = 0;
}


CIISGenObjectEnum::~CIISGenObjectEnum()
{
    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_pszServerName) {

        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath){

        FreeADsStr(_pszMetaBasePath);
    }

    //
    // Release everything
    //

}


HRESULT
CIISGenObjectEnum::EnumGenericObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements ) {

        hr = GetGenObject(&pDispatch);
        if (FAILED(hr)) {
            continue;
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


/* #pragma INTRINSA suppress=all */
HRESULT
CIISGenObjectEnum::GetGenObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    WCHAR NameBuf[MAX_PATH];
    WCHAR DataBuf[MAX_PATH];
    DWORD dwStatus = 0;
    DWORD dwReqdBufferLen;
    METADATA_HANDLE hObjHandle = NULL;
    METADATA_RECORD mdrData;
    IADs * pADs = NULL;

    *ppDispatch = NULL;

    hr = OpenAdminBaseKey(
                _pszServerName,
                _pszMetaBasePath,
                METADATA_PERMISSION_READ,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);
    
    hr = _pAdminBase->EnumKeys(
                hObjHandle,
                L"",
                (LPWSTR)NameBuf,
                _dwObjectCurrentEntry
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find out Class Name
    //

    mdrData.dwMDIdentifier = MD_KEY_TYPE;
    mdrData.dwMDDataType = STRING_METADATA;
    mdrData.dwMDUserType = ALL_METADATA;
    mdrData.dwMDAttributes = METADATA_INHERIT;
    mdrData.dwMDDataLen = MAX_PATH;
    mdrData.pbMDData = (PBYTE)DataBuf;

    hr = _pAdminBase->GetData(
                hObjHandle,
                (LPWSTR)NameBuf,
                &mdrData,
                &dwReqdBufferLen
                );

    if (FAILED(hr)) {
        if (hr == MD_ERROR_DATA_NOT_FOUND) {

            LPWSTR pszIISPath;
            pszIISPath = _wcsupr((LPWSTR)_pszMetaBasePath);

            if (wcsstr(pszIISPath, L"W3SVC") != NULL) {
                memcpy((LPWSTR)DataBuf, WEBDIR_CLASS_W,
                       SIZEOF_WEBDIR_CLASS_W);
            }
            else if (wcsstr(pszIISPath, L"MSFTPSVC") != NULL) {
                memcpy((LPWSTR)DataBuf, FTPVDIR_CLASS_W,
                       SIZEOF_FTPVDIR_CLASS_W);
            }
            else {
                memcpy((LPWSTR)DataBuf, DEFAULT_SCHEMA_CLASS_W,
                       SIZEOF_DEFAULT_CLASS_W);
            }
        }
        else {
            BAIL_ON_FAILURE(hr);
        }
    }
    else {
        hr = _pSchema->ValidateClassName((LPWSTR)DataBuf);
        if (hr == E_ADS_SCHEMA_VIOLATION) {
            memcpy((LPWSTR)DataBuf, DEFAULT_SCHEMA_CLASS_W,
                   SIZEOF_DEFAULT_CLASS_W);
        }
    }

    //
    // Bump up the object count. The instantiation of this object
    // may fail; if we come into this function again, we do not want
    // to pick up the same object.
    //

    _dwObjectCurrentEntry++;

    hr = CIISGenObject::CreateGenericObject(
                    _ADsPath,
                    (LPWSTR)NameBuf,
                    (LPWSTR)DataBuf, 
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IDispatch,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(
                IID_IDispatch,
                (void**)ppDispatch
                );

error:

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }


    if (pADs) {
        pADs->Release();
    }

    //
    // GetGenObject returns only S_FALSE
    //

    if (FAILED(hr)) {
        hr  = S_FALSE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISGenObjectEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISGenObjectEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGenericObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//		multiple IDispatch-callable interfaces.
//
//  Classes:	CAggregatorDispMgr
//
//  Functions:	None external.
//
//  History:    ??-???-??   KrishnaG   created
//		07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

#include "iis.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-	Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include ".\cdispmgr.hxx"
#include "iprops.hxx"

#endif	// ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-	End Non-ADSI compile stuff

//
// Error recovery.
//

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:	Simplified from Win4AssertEx, to make this dispatch manager
//  		not depend on other files.
//
//----------------------------------------------------------------------------
static void
AggregatorAssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[100];

    sprintf(szAssertCaption, "File: %s line %u, thread id %d",
	szFile, iLine, GetCurrentThreadId());

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
	    DebugBreak();
    }
}
# define AggregatorDispMgrAssert(x)  (void)((x) || (AggregatorAssertEx(__FILE__, __LINE__, #x),0))
#else
# define AggregatorAssertEx(f,l,m)
# define AggregatorDispMgrAssert(x)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(LONG TypeInfoId, LONG DispId, DISPID *pResult)
{
    if (DispId == DISPID_UNKNOWN)
	*pResult = DispId;
    else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
	DispId < 0 || DispId >= 0x10000)
    {
	//
	// Might happen if some object has very large dispid's.
	// But we can't handle it if it does.
	//
	*pResult = DISPID_UNKNOWN;
    }
    else
	*pResult = ((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

}

static inline void
IncDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
	if (rgdispid[i] == DISPID_UNKNOWN)
	    continue;

	//
	// This is either a stack of DispMgrs >127 high, or
	// a programming error.  More likely the latter.
	//
	AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) < 0x7f);

	rgdispid[i] =
	    (rgdispid[i] & 0x00ffffff) |
	    (((getDispMgrId(rgdispid[i]) + 1) & 0x7f) << 24);
    }
}

static inline void
DecDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
	//
	// It should never be less than zero, and the only place
	// this is called from guarantees it is not zero.
	//
	AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) > 0);

	rgdispid[i] =
	    (rgdispid[i] & 0x00ffffff) |
	    (((getDispMgrId(rgdispid[i]) - 1) & 0x7f) << 24);
    }
}

static inline void
MakeDISPIDs(LONG TypeInfoId, DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregatorDispMgr::CAggregatorDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
}

CAggregatorDispMgr::~CAggregatorDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

}

void
CAggregatorDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregatorDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregatorDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

//
// MAJOR NOTE This works only for single names; if multiple names are
// passed we die big time. This is help us get going using VB's _NewEnum
//

STDMETHODIMP
CAggregatorDispMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR *rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID *rgdispid
    )
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
	    hr = S_OK;
	    for (DWORD dw = 0; dw < cNames; dw++) {
	        if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
		        (PDWORD)(rgdispid + dw)))) {
		            hr = DISP_E_UNKNOWNNAME;
		            rgdispid[dw] = DISPID_UNKNOWN;
	        }
	    }
	    if (SUCCEEDED(hr)) {
	        MakeDISPIDs(_dwPropCacheID, rgdispid, cNames);
	    }
    }

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
	unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
	EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregatorDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregatorDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregatorDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr = S_OK;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

error:

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::TypeInfoInvoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
	unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
	EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

    	//
	    // One of the special DISPIDs.
	    //
	    // If we have an interface pointer for it, use that.
	    // If we don't, and we have a base IDispatch pointer,
	    //   pass it to the base pointer's Invoke() method.
	    // If we don't, and we don't have a base IDispatch pointer,
	    //   return failure.
	    //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
	    break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

	    if (!pInterfacePtr) {

	        BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

	    }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                           	
	    // A regular DISPID of ours.
	    //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

	    if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
	        pInterfacePtr = getInterfacePtr(typeinfoid);
	        pTypeInfo = getTypeInfo(typeinfoid);
	        if (!pTypeInfo)
		        //
		    // Shouldn't happen.
		    //
		    BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
	    }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = AggregatorDynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

error:
    return hr;
}


HRESULT
AggregatorDynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        //
        // NOTE: only handles one argument.
        //

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

error:
    return(hr);

}


HRESULT
CAggregatorDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregatorDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregatorDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    AggregatorDispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;


ITypeInfo *
AggregatorFindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
AggregatorLoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    AggregatorDispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (hr)
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregatorDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    hr = AggregatorLoadTypeInfo(libid, iid, &pTypeInfo);
    BAIL_ON_FAILURE(hr);

    hr = AddTypeInfo(pTypeInfo, pIntf);
    BAIL_ON_FAILURE(hr);

    if (SpecialId == -4) {
	    hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
	    hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

error:
    if (pTypeInfo)
	    pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregatorDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cenumns.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:  cenumns.cxx
//
//  Contents:  Windows NT 4.0 Enumerator Code
//
//             CIISNamespaceEnum::Create
//             CIISNamespaceEnum::CIISNamespaceEnum
//             CIISNamespaceEnum::~CIISNamespaceEnum
//             CIISNamespaceEnum::Next
//             CIISNamespaceEnum::GetServerObject
//             CIISNamespaceEnum::EnumServerObjects
//
//  History:    21-Feb-97   SophiaC     Created.
//----------------------------------------------------------------------------
#include "iis.hxx"
#include "charset.hxx"

#pragma hdrstop

#define ENUM_BUFFER_SIZE (1024 * 16)
#define DEFAULT_ADMIN_SERVER_KEY  \
            L"SOFTWARE\\Microsoft\\ADs\\Providers\\IIS\\"

#define DEFAULT_ADMIN_SERVER_VALUE_KEY      L"DefaultAdminServer"


//+---------------------------------------------------------------------------
//
//  Function:   CIISNamespaceEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
HRESULT
CIISNamespaceEnum::Create(
    CIISNamespaceEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    CCredentials& Credentials
    )
{
    RRETURN(E_NOTIMPL);
//     HRESULT hr = S_OK;
//     CIISNamespaceEnum FAR* penumvariant = NULL;
//     DWORD dwStatus;
// 
//     penumvariant = new CIISNamespaceEnum();
// 
//     if (penumvariant == NULL){
//         hr = E_OUTOFMEMORY;
//         BAIL_ON_FAILURE(hr);
//     }
// 
//     hr = ObjectTypeList::CreateObjectTypeList(
//             var,
//             &penumvariant->_pObjList
//             );
//     BAIL_ON_FAILURE(hr);
// 
//     penumvariant->_Credentials = Credentials;
// 
//     *ppenumvariant = penumvariant;
// 
//     RRETURN(hr);
// 
// error:
//     if (penumvariant) {
//         delete penumvariant;
//     }
//     RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISNamespaceEnum::CIISNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
CIISNamespaceEnum::CIISNamespaceEnum()
{
//     _pObjList       = NULL;
//     _fRegistryRead  = FALSE;
// 
//     _lpServerList         = NULL;
//     _iCurrentServer      = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISNamespaceEnum::~CIISNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
CIISNamespaceEnum::~CIISNamespaceEnum()
{
// 
//     if ( _pObjList )
//         delete _pObjList;
// 
//     FreeServerList();
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISNamespaceEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISNamespaceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    RRETURN(E_NOTIMPL);
// 
//     ULONG cElementFetched = 0;
//     HRESULT hr = S_OK;
// 
//     hr = EnumServerObjects(
//             cElements,
//             pvar,
//             &cElementFetched
//             );
// 
//     if (pcElementFetched) {
//         *pcElementFetched = cElementFetched;
//     }
//     RRETURN(hr);
// 
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISNamespaceEnum::Reset
//
//  Synopsis:   Resets the enumerator so that a new server list will
//              be generated on the next call to Next.
//
//  Arguments:  None.
//
//  Returns:    HRESULT -- S_OK if there was a previous server list
//                      -- S_FALSE if there was not a previous server list
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISNamespaceEnum::Reset(
    )
{
    RRETURN(E_NOTIMPL);
//     return FreeServerList();
// 
}

// Generate the server list and set flags
HRESULT
CIISNamespaceEnum::GenerateServerList()
{
    RRETURN(E_NOTIMPL);
//     DWORD Error;
// 
//     ADsAssert(_lpServerList==NULL);
// 
//     Error = INetDiscoverServers(
//                 INET_ALL_SERVICES_ID,
//                 SVC_DEFAULT_WAIT_TIME,
//                 &_lpServerList);
// 
//     if (Error != ERROR_SUCCESS) {
//         return HRESULT_FROM_WIN32(Error);
//     }
// 
//     // Set the current server to the first
//     _iCurrentServer = 0;
// 
// 
//     return S_OK;
// 
}

// Free the server list and set flags
HRESULT
CIISNamespaceEnum::FreeServerList(
    )
{
    RRETURN(E_NOTIMPL);
//     if ( _lpServerList ) {
//         // _lpServerList is set to NULL
//         INetFreeDiscoverServersList(&_lpServerList); // void return
//     }
//     ADsAssert(_lpServerList==NULL);
//     return S_OK;
}

HRESULT
CIISNamespaceEnum::EnumServerObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    RRETURN(E_NOTIMPL);
//     HRESULT hr = S_OK;
//     IDispatch *pDispatch = NULL;
//     DWORD i = 0;
// 
//     // perform this check once per call
//     if (!_lpServerList) {   // generate server list
//         GenerateServerList();
//     }
// 
//     while (i < cElements) {
// 
//         hr = GetServerObject(&pDispatch);
//         BAIL_ON_FAILURE(hr);
// 
//         if (hr == S_FALSE) {
//             break;
//         }
// 
//         VariantInit(&pvar[i]);
//         pvar[i].vt = VT_DISPATCH;
//         pvar[i].pdispVal = pDispatch;
//         (*pcElementFetched)++;
//         i++;
//     }
//     // we've received the entire block or we have
//     // reached the end of the list
// 
//     RRETURN(hr);
// 
// error:
//     // there was an error retrieving the current object
//     RRETURN(hr);
}


/* #pragma INTRINSA suppress=all */
HRESULT
CIISNamespaceEnum::GetServerObject(
    IDispatch ** ppDispatch
    )
{
    RRETURN(E_NOTIMPL);
//     HKEY             hKey = NULL;
// #if 0
//     WCHAR            szServerName[MAX_PATH];
// #endif
//     WCHAR           *lpwszServerName;
//     DWORD            dwStatus;
//     HRESULT          hr;
//     LPSTR            lpszServerName;
//     UINT             err;
// 
//     // while there are still more servers
//     if (_iCurrentServer < (_lpServerList->NumServers)) {
//         // get the next server name
//         lpszServerName = _lpServerList->Servers[_iCurrentServer]->ServerName;
// 
//         // convert the server name to unicode
// #if 0
//         AnsiToUnicodeString(
//             lpszServerName,
//             szServerName,
//             strlen(lpszServerName));
// #else
//         err = AllocUnicode(lpszServerName, &lpwszServerName);
//         if (err) {
//             RRETURN( HRESULT_FROM_WIN32(err) );
//         }
// 
// #endif
// 
//         // increment the current server index
//         ++_iCurrentServer;
// 
//     } else {
//         RRETURN(S_FALSE);
//     }
// 
//     *ppDispatch = NULL;
// 
//     //
//     // Now create and send back the current object
//     //
// 
//     hr = CIISTree::CreateServerObject(
//                 L"IIS:",
//                 lpwszServerName,
//                 COMPUTER_CLASS_W,
//                 _Credentials,
//                 ADS_OBJECT_BOUND,
//                 IID_IDispatch,
//                 (void **)ppDispatch
//                 );
//     BAIL_ON_FAILURE(hr);
// 
// 
// error:
// 
//     RRETURN_ENUM_STATUS(hr);
// 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cenumsch.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:      cenumsch.cxx
//
//  Contents:  IIS Schema Enumeration Code
//
//             CIISSchemaEnum::CIISSchemaEnum
//             CIISSchemaEnum::~CIISSchemaEnum
//             CIISSchemaEnum::EnumObjects
//             CIISSchemaEnum::EnumObjects
//             CIISSchemaEnum::Create
//             CIISSchemaEnum::Next
//
//  History:   01-02-98         sophiac
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISSchemaEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
HRESULT
CIISSchemaEnum::Create(
    CIISSchemaEnum FAR* FAR* ppenumvariant,
    IIsSchema * pSchema,
    BSTR bstrADsPath,
    BSTR bstrName
    )
{
    HRESULT hr = S_OK;
    CIISSchemaEnum FAR* penumvariant = NULL;
    VARIANT vFilter;

    *ppenumvariant = NULL;
    VariantInit(&vFilter);

    penumvariant = new CIISSchemaEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    penumvariant->_pSchema = pSchema;

    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrName, &penumvariant->_bstrName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            vFilter,
            &penumvariant->_pObjList );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    VariantClear(&vFilter);
    RRETURN(hr);

error:

    delete penumvariant;
    VariantClear(&vFilter);

    RRETURN(hr);
}

CIISSchemaEnum::CIISSchemaEnum()
    : _bstrADsPath( NULL ),
      _bstrName( NULL ),
      _pObjList( NULL ),
      _pSchema( NULL ),
      _dwCurrentEntry( 0 )
{
}

CIISSchemaEnum::~CIISSchemaEnum()
{
   ADsFreeString( _bstrName );
   ADsFreeString( _bstrADsPath );

   if ( _pObjList != NULL )
   {
       delete _pObjList;
       _pObjList = NULL;
   }
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISSchemaEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISSchemaEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects( cElements,
                      pvar,
                      &cElementFetched );

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    RRETURN(hr);
}

HRESULT
CIISSchemaEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType)
    {
        case IIS_CLASS_ID:
            RRETURN (EnumClasses(cElements, pvar, pcElementFetched));

        case IIS_SYNTAX_ID:
            RRETURN(EnumSyntaxObjects(cElements, pvar, pcElementFetched));

        case IIS_PROPERTY_ID:
            RRETURN(EnumProperties(cElements, pvar, pcElementFetched));

        default:
            RRETURN(S_FALSE);
    }
}

HRESULT
CIISSchemaEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN(hr);
}

HRESULT
CIISSchemaEnum::EnumClasses(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetClassObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CIISSchemaEnum::GetClassObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current ovbject
    //
    if ( _dwCurrentEntry >= _pSchema->GetClassEntries() )
        goto error;

    hr = CIISClass::CreateClass(
                        _bstrADsPath,
                        _pSchema->GetClassName(_dwCurrentEntry),
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CIISSchemaEnum::EnumSyntaxObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetSyntaxObject(&pDispatch);
        if ( hr == S_FALSE ) 
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CIISSchemaEnum::GetSyntaxObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current object
    //
    if ( _dwCurrentEntry >= g_cIISSyntax )
        goto error;

    hr = CIISSyntax::CreateSyntax(
                        _bstrADsPath,
                        &g_aIISSyntax[_dwCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}


HRESULT
CIISSchemaEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CIISSchemaEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current ovbject
    //
    if ( _dwCurrentEntry >= _pSchema->GetPropEntries() )
        goto error;

    hr = CIISProperty::CreateProperty(
                        _bstrADsPath,
                        _pSchema->GetPropName(_dwCurrentEntry),
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wrapmb.h ===
#ifndef _WRAPMB_
#define _WRAPMB_

/*++

Notes:  I made some changes to this library to build both a UNICODE and ANSI version

        RonaldM

--*/

#include "iadmw.h"

//--------------------------------------------------------
// startup & closeing utilities

BOOL     FInitMetabaseWrapper( OLECHAR* pocMachineName );
BOOL     FCloseMetabaseWrapper();

//
// As above, privately maintaining the interface
//
BOOL     FInitMetabaseWrapperEx( OLECHAR* pocMachineName, IMSAdminBase ** ppiab );
BOOL     FCloseMetabaseWrapperEx(IMSAdminBase ** ppiab);


//--------------------------------------------------------
class CWrapMetaBase
    {
    public:
    WORD m_count;
    // construct - destruct
    CWrapMetaBase();
    ~CWrapMetaBase();

    // second stage initialization
    BOOL FInit( PVOID pMBCom = NULL);

    // open, close and save the object and such
    BOOL Open( LPCTSTR pszPath, DWORD dwFlags = METADATA_PERMISSION_READ );
    BOOL Open( METADATA_HANDLE hOpenRoot, LPCTSTR pszPath,
               DWORD dwFlags = METADATA_PERMISSION_READ );

    BOOL Close( void );
    BOOL Save( void );

    // enumerate the objects
    BOOL EnumObjects( LPCTSTR pszPath, LPTSTR Name, DWORD cbNameBuf, DWORD Index );

    // Add and delete objects
    BOOL AddObject( LPCTSTR pszPath );
    BOOL DeleteObject( LPCTSTR pszPath );

    // rename an object
    BOOL RenameObject( LPCTSTR pszPathOld, LPCTSTR pszNewName );

    // access the metahandle
    METADATA_HANDLE QueryHandle();

    // setting values
    BOOL SetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL SetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, LPCTSTR dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL SetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            PVOID pData, DWORD cbData, DWORD dwFlags = METADATA_INHERIT );

    // getting values
    BOOL GetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD* dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL GetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, LPTSTR pszValue, DWORD cchValue,
                            DWORD dwFlags = METADATA_INHERIT );
    BOOL GetMultiSZString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, LPTSTR pszValue, DWORD cchValue,
                            DWORD dwFlags = METADATA_INHERIT );
    BOOL GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            PVOID pData, DWORD* pcbData, DWORD dwFlags = METADATA_INHERIT );
    PVOID GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            DWORD* pcbData, DWORD dwFlags = METADATA_INHERIT );

    // deleting values
    BOOL DeleteData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwDataType );

    // free memory returned by GetData
    void FreeWrapData( PVOID pData );

    protected:
    // pointer to the real metabase object as defined in mb.hxx
    // by casting it PVOID, those files including this will not have to include mb.hxx, which
    // is the whole point of wrapping it like this.
    // PVOID   m_pvMB;

    // pointer to the dcom interface it should use
    IMSAdminBase *       m_pMetabase;

    // the open metabase handle
    METADATA_HANDLE     m_hMeta;

    // size of the local buffer
    #define BUFFER_SIZE     2000

    // local buffer - allocated once, used many times
    PVOID   m_pBuffer;
    DWORD   m_cbBuffer;


    // path conversion utilities
    WCHAR * PrepPath( LPCTSTR psz );
    void UnprepPath();

    WCHAR * m_pPathBuffer;
    DWORD   m_cchPathBuffer;
    };

#endif //_WRAPMB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wrapmb.cpp ===
/*++

Module Name:

    wrapmb.cpp

Abstract:

    wrapper classes for the metabase class. Yes, I am wrapping a wrapper. Why?
        because including mb.hxx totally screws up the headers in my stdafx based
        MFC files. This way they can just include wrapmb.h and not have to worry
        about including all the other stuff. Also, I can set INITGUID here. That
        way I can use precompiled headers in the main project to Greatly increase
        compile times. If that isn't reason enough, then I can also manage the pointer
        to the interface object itself here.

Author:

   Boyd Multerer boydm

--*/
#include "stdafx.h"
#include <objbase.h>
#include <initguid.h>
#include <iadmw.h>

#include "iiscnfg.h"
#include "wrapmb.h"

#ifdef _NO_TRACING_
DECLARE_DEBUG_PRINTS_OBJECT();
#endif

#define     MB_TIMEOUT          5000


// a macro to automatically cast the pointer to the mb object
//#define _pmb    ((MB*)m_pvMB)


// globals
IMSAdminBase*                g_pMBCom = NULL;



//----------------------------------------------------------------
BOOL    FInitMetabaseWrapperEx( OLECHAR* pocMachineName, IMSAdminBase ** ppiab )
    {
    IClassFactory *  pcsfFactory = NULL;
    COSERVERINFO     csiMachineName;
    COSERVERINFO *   pcsiParam = NULL;

    HRESULT          hresError;

    if(!ppiab)
    {
        return FALSE;
    }

    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    csiMachineName.pwszName = pocMachineName;
    pcsiParam = &csiMachineName;

    hresError = CoGetClassObject(
        GETAdminBaseCLSID(TRUE),
        CLSCTX_SERVER,
        pcsiParam,
        IID_IClassFactory,
        (void**) &pcsfFactory
        );

    if (FAILED(hresError))
    {
        return FALSE;
    }

    // create the instance of the interface
    hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **)ppiab);
    if (FAILED(hresError))
    {
        *ppiab = NULL;
        return FALSE;
    }

    // release the factory
    pcsfFactory->Release();

    // success
    return TRUE;
    }

//----------------------------------------------------------------
BOOL    FCloseMetabaseWrapperEx(IMSAdminBase ** ppiab)
    {
    if ( ppiab && *ppiab)
        {
        (*ppiab)->Release();
        *ppiab = NULL;
        }

    return TRUE;
    }

//----------------------------------------------------------------
BOOL    FInitMetabaseWrapper( OLECHAR * pocMachineName )
    {
    //release previous interface if needed
    if( g_pMBCom != NULL )
        {
        g_pMBCom->Release();
        g_pMBCom = NULL;
        }

    return FInitMetabaseWrapperEx(pocMachineName, &g_pMBCom);
    }

//----------------------------------------------------------------
BOOL    FCloseMetabaseWrapper()
    {
    return FCloseMetabaseWrapperEx(&g_pMBCom);
    }


//=================================================================== The wrapper class

//----------------------------------------------------------------
CWrapMetaBase::CWrapMetaBase():
    m_pMetabase( NULL ),
    m_hMeta( NULL ),
    m_count(0),
    m_pBuffer( NULL ),
    m_cbBuffer(0),
    m_pPathBuffer( NULL ),
    m_cchPathBuffer( 0 )
    {
    // attempt to allocate the general buffer
    m_pBuffer = GlobalAlloc( GPTR, BUFFER_SIZE );
    if ( m_pBuffer )
        m_cbBuffer = BUFFER_SIZE;
    }

//----------------------------------------------------------------
CWrapMetaBase::~CWrapMetaBase()
    {
    // make sure the metabase handle is closed
    Close();

    // free the buffer
    if ( m_pBuffer )
        GlobalFree( m_pBuffer );
    m_pBuffer = NULL;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::FInit( PVOID pMBCom )
    {
    BOOL            fAnswer = FALSE;

    // NULL was passed in, use the global reference - most cases will do this
    if ( pMBCom )
    {
        m_pMetabase = (IMSAdminBase *)pMBCom;
    }
    else
    {
        m_pMetabase = g_pMBCom;
    }

    // if the interface is not there, fail
    if ( !m_pMetabase )
    {
        return FALSE;
    }

    // return success
    return TRUE;
    }


//==========================================================================================
// open, close and save the object and such

//----------------------------------------------------------------
BOOL CWrapMetaBase::Open( LPCTSTR pszPath, DWORD dwFlags )
    {
    return Open( METADATA_MASTER_ROOT_HANDLE, pszPath, dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Open( METADATA_HANDLE hOpenRoot, LPCTSTR pszPath, DWORD dwFlags )
    {
    m_count++;
    HRESULT hRes;

    // if a metabase handle is already open, close it
    if ( m_hMeta )
        Close();

    hRes = m_pMetabase->OpenKey( hOpenRoot, pszPath, dwFlags, MB_TIMEOUT, &m_hMeta );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Close( void )
    {
    if ( m_hMeta )
        {
        m_count--;
        m_pMetabase->CloseKey( m_hMeta );
        }
    m_hMeta = NULL;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Save( void )
        {
        HRESULT hRes = m_pMetabase->SaveData();

        if ( SUCCEEDED( hRes ))
            return TRUE;
        SetLastError( HRESULTTOWIN32( hRes ));
        return FALSE;
        }

// enumerate the objects
//----------------------------------------------------------------
// fortunately, we know that there is a max length to the name of any individual
// key in the metabase of 256 characters
BOOL CWrapMetaBase::EnumObjects(
    LPCTSTR pszPath,
    LPTSTR pName,
    DWORD cbNameBuf,
    DWORD Index
    )
    {
    // enumerate into the wide character buffer
    HRESULT hRes = m_pMetabase->EnumKeys( m_hMeta, pszPath, pName, Index );

    // Check for success
    if ( SUCCEEDED( hRes ))
        {
        return TRUE;
        }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }


//==========================================================================================
// Add and delete objects
//----------------------------------------------------------------
BOOL CWrapMetaBase::AddObject( LPCTSTR pszPath )
    {
    HRESULT hRes = m_pMetabase->AddKey( m_hMeta, pszPath );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::DeleteObject( LPCTSTR pszPath )
    {
    HRESULT hRes = m_pMetabase->DeleteKey( m_hMeta, pszPath );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }


//==========================================================================================
// access the metahandle
//----------------------------------------------------------------
METADATA_HANDLE CWrapMetaBase::QueryHandle()
        {
        return m_hMeta;
        }


//==========================================================================================
// setting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::SetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                                DWORD dwValue, DWORD dwFlags )
    {
    return SetData( pszPath,
            dwPropID,
            dwUserType,
            DWORD_METADATA,
            (PVOID) &dwValue,
            sizeof( DWORD ),
            dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::SetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                              LPCTSTR pszValue, DWORD dwFlags )
    {
    int len = wcslen( pszValue )+1;
    DWORD cbWide = len * sizeof(WCHAR);

    // set the string into place
    BOOL fAnswer = SetData( pszPath,
            dwPropID,
            dwUserType,
            STRING_METADATA,
            (PVOID)pszValue,
            cbWide,            // string length ignored for inprocess clients
            dwFlags );

    // return the answer
    return fAnswer;
    }

//==========================================================================================
// getting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::GetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                             DWORD* pdwValue, DWORD dwFlags )
    {
    DWORD cb = sizeof(DWORD);
    return GetData( pszPath,
            dwPropID,
            dwUserType,
            DWORD_METADATA,
            pdwValue,
            &cb,
            dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::GetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                              LPTSTR pszValue, DWORD cchValue, DWORD dwFlags )
    {
    BOOL    fAnswer = FALSE;

    // get the data and put it right into the buffer - this is the wide version
    if ( GetData( pszPath,
            dwPropID,
            dwUserType,
            STRING_METADATA,
            pszValue,
            &cchValue,
            dwFlags ) )
        {
        fAnswer = TRUE;
        }

    // return the answer
    return fAnswer;
    }

BOOL CWrapMetaBase::GetMultiSZString( 
       LPCTSTR pszPath, 
       DWORD dwPropID, 
       DWORD dwUserType, 
       LPTSTR pszValue, 
       DWORD cchValue, 
       DWORD dwFlags)
{
    BOOL    fAnswer = FALSE;

    // get the data and put it right into the buffer - this is the wide version
    if (GetData( pszPath,
            dwPropID,
            dwUserType,
            MULTISZ_METADATA,
            pszValue,
            &cchValue,
            dwFlags ) )
   {
       fAnswer = TRUE;
   }

   // return the answer
   return fAnswer;
}

//==========================================================================================
// deleting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::DeleteData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwDataType )
    {
    // go right ahead and delete it
    HRESULT hRes = m_pMetabase->DeleteData( m_hMeta, pszPath, dwPropID, dwDataType );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // clean up after a failure
    SetLastError( HRESULTTOWIN32( hRes ));
    return(FALSE);
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::RenameObject( LPCTSTR pszPathOld, LPCTSTR pszNewName )
    {
    // rename the key
    HRESULT hRes = m_pMetabase->RenameKey( m_hMeta, pszPathOld, pszNewName );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // clean up after a failure
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

//=====================================================================================

//----------------------------------------------------------------
BOOL CWrapMetaBase::SetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        PVOID pData, DWORD cbData, DWORD dwFlags )
    {
    METADATA_RECORD mdRecord;
    HRESULT         hRes;

    // prepare the set data record
    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = cbData;
    mdRecord.pbMDData        = (PBYTE)pData;

    // set the data
    hRes = m_pMetabase->SetData( m_hMeta, pszPath, &mdRecord );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // there was an error, clean up
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        PVOID pData, DWORD* pcbData, DWORD dwFlags )
    {
    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;

    // prepare the get data record
    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = *pcbData;
    mdRecord.pbMDData        = (PBYTE)pData;

    // get the data
    hRes = m_pMetabase->GetData( m_hMeta, pszPath, &mdRecord, &dwRequiredLen );

    // test for success
    if ( SUCCEEDED( hRes ))
        {
        *pcbData = mdRecord.dwMDDataLen;
        return TRUE;
        }

    // there was a failure - clean up
    *pcbData = dwRequiredLen;
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
// another form of GetData that automatically allocates the buffer. It should then be
// freed using GlobalFree(p);
PVOID CWrapMetaBase::GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        DWORD* pcbData, DWORD dwFlags )
    {
    PVOID           pData = m_pBuffer;
    DWORD           cbData = m_cbBuffer;
    DWORD           err = 0;
    BOOL            f;

    // first - attempt to get the data in the buffer that has already been allocated;
    f = GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, &cbData, dwFlags );

    // if the get data function worked, we can pretty much leave
    if ( f )
        {
        // set the data size
        *pcbData = cbData;
        // return the allocated buffer
        return pData;
        }

    // check the error - it could be some sort of memory error
    err = GetLastError();

    // it is ok that the GetData failed, but the reason had better be ERROR_INSUFFICIENT_BUFFER
    // otherwise, it is something we can't handle
    if ( err != ERROR_INSUFFICIENT_BUFFER )
        return NULL;

    // allocate the buffer
    pData = GlobalAlloc( GPTR, cbData );
    if ( !pData )
        return NULL;

    // first, get the size of the data that we are looking for
    f = GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, &cbData, dwFlags );

    // if that getting failed, we need to cleanup
    if ( !f )
        {
        GlobalFree( pData );
        pData = NULL;
        }

    // set the data size
    *pcbData = cbData;

    // return the allocated buffer
    return pData;
    }

//----------------------------------------------------------------
// free memory returned by GetData
void CWrapMetaBase::FreeWrapData( PVOID pData )
{
    // if it is trying to free the local buffer, do nothing
    if ( pData == m_pBuffer )
    {
        return;
    }

    // ah - but it was not the local buffer - we should dispose of it
    if ( pData )
    {
        GlobalFree( pData );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cenumt.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:      cenumt.cxx
//
//  Contents:  IIS Object Enumeration Code
//
//              CIISTreeEnum::CIISTreeEnum()
//              CIISTreeEnum::CIISTreeEnum
//              CIISTreeEnum::EnumObjects
//              CIISTreeEnum::EnumObjects
//
//  History:    25-Feb-97   SophiaC     Created.
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//
//----------------------------------------------------------------------------
/* INTRINSA suppress=null_pointers, uninitialized */
HRESULT
CIISTreeEnum::Create(
    CIISTreeEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    VARIANT var,
    CCredentials& Credentials
    )
{
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;

    HRESULT hr = NOERROR;
    CIISTreeEnum FAR* penumvariant = NULL;

    LPWSTR pszIISPathName = NULL;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = NULL;
    CLexer Lexer(ADsPath);

    *ppenumvariant = NULL;

    penumvariant = new CIISTreeEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    pObjectInfo = &ObjectInfo;
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    //
    // Store ServerName
    //

    penumvariant->_pszServerName = AllocADsStr(pObjectInfo->TreeName);

    if (!(penumvariant->_pszServerName)) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


	hr = InitServerInfo(penumvariant->_pszServerName, 
                        &(penumvariant->_pAdminBase),
                        &(penumvariant->_pSchema));
	BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(ADsPath);

    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

	memset(pszIISPathName, 0, sizeof(pszIISPathName));

    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_pszMetaBasePath = AllocADsStr(pszIISPathName);

    if (!(penumvariant->_pszMetaBasePath)) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:

    if (FAILED(hr)) {
        if (penumvariant) {
            delete penumvariant;
            *ppenumvariant = NULL;
        }
    }

    if (pszIISPathName) {
        FreeADsStr(pszIISPathName);
    }

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);
}

CIISTreeEnum::CIISTreeEnum():
                    _ADsPath(NULL),
                    _pszServerName(NULL),
					_pSchema(NULL),
					_pAdminBase(NULL),
                    _pszMetaBasePath(NULL)
{
    _dwObjectCurrentEntry = 0;
}


CIISTreeEnum::~CIISTreeEnum()
{
    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_pszServerName) {

        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath){

        FreeADsStr(_pszMetaBasePath);
    }

    //
    // Release everything
    //

}


HRESULT
CIISTreeEnum::EnumGenericObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements ) {

        hr = GetGenericObject(&pDispatch);
        if (FAILED(hr)) {
            continue;
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


/* #pragma INTRINSA suppress=all */
HRESULT
CIISTreeEnum::GetGenericObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    WCHAR NameBuf[MAX_PATH];
    WCHAR DataBuf[MAX_PATH];
    DWORD dwStatus = 0;
    DWORD dwReqdBufferLen;
    METADATA_HANDLE hObjHandle = NULL;
    METADATA_RECORD mdrData;

    *ppDispatch = NULL;

    hr = OpenAdminBaseKey(
                _pszServerName,
                _pszMetaBasePath,
                METADATA_PERMISSION_READ,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    hr = _pAdminBase->EnumKeys(
                hObjHandle,
                L"",
                (LPWSTR)NameBuf,
                _dwObjectCurrentEntry
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find out Class Name
    //

    mdrData.dwMDIdentifier = MD_KEY_TYPE;
    mdrData.dwMDDataType = STRING_METADATA;
    mdrData.dwMDUserType = ALL_METADATA;
    mdrData.dwMDAttributes = METADATA_INHERIT;
    mdrData.dwMDDataLen = MAX_PATH;
    mdrData.pbMDData = (PBYTE)DataBuf;

    hr = _pAdminBase->GetData(
                hObjHandle,
                (LPWSTR)NameBuf,
                &mdrData,
                &dwReqdBufferLen
                );


    if (FAILED(hr)) {
        if (hr == MD_ERROR_DATA_NOT_FOUND) {

            LPWSTR pszIISPath;
            pszIISPath = _wcsupr((LPWSTR)_pszMetaBasePath);

            if (wcsstr(_pszMetaBasePath, L"W3SVC") != NULL) {
                memcpy((LPWSTR)DataBuf, WEBDIR_CLASS_W,
                       SIZEOF_WEBDIR_CLASS_W);
            }
            else if (wcsstr(_pszMetaBasePath, L"MSFTPSVC") != NULL) {
                memcpy((LPWSTR)DataBuf, FTPVDIR_CLASS_W,
                       SIZEOF_FTPVDIR_CLASS_W);
            }
            else {
                memcpy((LPWSTR)DataBuf, DEFAULT_SCHEMA_CLASS_W,
                       SIZEOF_DEFAULT_CLASS_W);
            }
        }
        else {
            BAIL_ON_FAILURE(hr);
        }
    }
    else {
        hr = _pSchema->ValidateClassName((LPWSTR)DataBuf);
        if (hr == E_ADS_SCHEMA_VIOLATION) {
            memcpy((LPWSTR)DataBuf, DEFAULT_SCHEMA_CLASS_W,
                   SIZEOF_DEFAULT_CLASS_W);
        }
    }

    // Bump up the object count. The instantiation of this object
    // may fail; if we come into this function again, we do not want
    // to pick up the same object.
    //

    _dwObjectCurrentEntry++;

    hr = CIISGenObject::CreateGenericObject(
                    _ADsPath,
                    (LPWSTR)NameBuf,
                    (LPWSTR)DataBuf,
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IDispatch,
                    (void **)ppDispatch
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    //
    // GetTree returns only S_FALSE
    //

    if (FAILED(hr)) {
        hr  = S_FALSE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISTreeEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:  
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISTreeEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGenericObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cextmgr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cextmgr.cxx
//
//  Contents:  IIS ExtMgr Object
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


//  Class CADsExtMgr

CADsExtMgr::CADsExtMgr():
    _pClassEntry(NULL),
    _pDispMgr(NULL)
{

}

HRESULT
CADsExtMgr::CreateExtMgr(
    IUnknown FAR * pUnkOuter,
    CAggregatorDispMgr * pDispMgr,
    CCredentials& Credentials,
    LPTSTR pszClassName,
    CADsExtMgr ** ppExtMgr
    )
{
    PCLASS_ENTRY pClassEntry =  NULL;
    CADsExtMgr FAR * pExtMgr = NULL;
    HRESULT hr = S_OK;

    hr = AllocateExtMgrObject(
                &pExtMgr
                );
    BAIL_ON_FAILURE(hr);


    //
    // Now store the DispatchMgr of the Aggregator
    //

    pExtMgr->_pDispMgr = pDispMgr;

    hr = ADSIGetExtensionList(
            pszClassName,
            &(pExtMgr->_pClassEntry)
            );

    if (pExtMgr->_pClassEntry) {

        hr = ADSILoadExtensions2(
                    pUnkOuter,
                    Credentials,
                    pExtMgr->_pClassEntry
                    );
    }

    *ppExtMgr = pExtMgr;

    RRETURN(hr);

error:
    *ppExtMgr = NULL;
    delete pExtMgr;
    RRETURN(hr);
}


CADsExtMgr::~CADsExtMgr( )
{
    //
    // Free the ClassEntry
    //

    if (_pClassEntry) {

        FreeClassEntry(_pClassEntry);
    }

    //
    // And do nothing with the DispMgr - we just keep a pointer
    //

}

STDMETHODIMP
CADsExtMgr::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    IUnknown * pUnknown = NULL;
    PINTERFACE_ENTRY pIID = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    HRESULT hr = S_OK;

    if (!pClassEntry) {

        RRETURN(E_NOINTERFACE);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pUnknown = pExtensionEntry->pUnknown;
        pIID = pExtensionEntry->pIID;

        while (pIID) {

            if (IsEqualIID(pIID->iid, iid)) {


                if (!pUnknown) {

                    RRETURN(E_NOINTERFACE);
                }

                hr = pUnknown->QueryInterface(
                            iid,
                            ppv
                            );
                RRETURN(hr);
            }

            pIID = pIID->pNext;

        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    RRETURN(hr = E_NOINTERFACE);
}


HRESULT
CADsExtMgr::AllocateExtMgrObject(
    CADsExtMgr ** ppExtMgr
    )
{
    CADsExtMgr FAR * pExtMgr = NULL;
    HRESULT hr = S_OK;

    pExtMgr = new CADsExtMgr();
    if (pExtMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    *ppExtMgr = pExtMgr;

    RRETURN(hr);

error:

    if (pExtMgr) {
        delete pExtMgr;
    }

    RRETURN(hr);

}


HRESULT
ADSILoadExtensionManager(
    LPWSTR pszClassName,
    IUnknown * pUnkOuter,
    CCredentials& Credentials,
    CAggregatorDispMgr * pDispMgr,
    CADsExtMgr ** ppExtMgr
    )
{

    HRESULT hr = S_OK;

    hr = CADsExtMgr::CreateExtMgr(
            pUnkOuter,
            pDispMgr,
            Credentials,
            pszClassName,
            ppExtMgr
            );

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::GetTypeInfoCount(
    unsigned int FAR* pctinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetTypeInfo(
    unsigned int itinfo,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR FAR* rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID FAR* rgdispid
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch FAR * pPrivDisp = NULL;


    hr = _pDispMgr->GetIDsOfNames(
            iid,
            rgszNames,
            cNames,
            lcid,
            rgdispid
            );

    if (FAILED(hr)) {

        if (!_pClassEntry) {
            RRETURN(DISP_E_UNKNOWNNAME);
        }

        pExtension = _pClassEntry->pExtensionHead;

        while (pExtension) {

            if (pExtension->fDisp) {
                
                //
                // fDisp = TRUE indicates 
                //  1)  extension supports pADsExt AND 
                //  2)  either 
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL     
                //      OR
                //      b) we don't know if a) is true or not yet
                // 

                ASSERT(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateGetIDsOfNames(
                          iid,
                          rgszNames,
                          cNames,
                          lcid,
                          rgdispid
                          );

                if (SUCCEEDED(hr)) {

                    // 
                    // check & prefix extension id to dispid(s) returned 
                    // by extension
                    //  

                    hr = CheckAndPrefixExtIDArray(
                                pExtension->dwExtensionID,
                                cNames,
                                rgdispid
                                );
                                    
                    if (SUCCEEDED(hr) )
                    {
                        RRETURN(hr);
                    }

                    //
                    // if cannot prefix extension id because NOT ALL 
                    // dispids returned by PrivateGetIDsOfNames() are
                    // valid, this extension does not support this property
                    // or method -> try next extension
                    //
                }

                else if (hr == E_NOTIMPL) {
    
                    //
                    // extension object does not support the optional
                    // IADsExtension::PrivateGetIDsOfNames()/PrivateInvoke()
                    // -> remember this in cache & try next extension object
                    //

                    pExtension->fDisp = FALSE;
                }

                else {

                    // 
                    // extens'n object supports PrivateGetIDsOfNames()/Invoke()
                    // but does not know about this property or method 
                    // -> try next extension object
                    //
                }

            } // end "if (pExtension->pADs && pExtension->fDisp)"

            pExtension = pExtension->pNext;

        } // end while

    }

    
    // 
    // Unify the final error code retuned to ADSI client to DISP_E_UNKNOWNNAME 
    //

    if ( FAILED(hr) && hr!=E_OUTOFMEMORY) {

        hr = DISP_E_UNKNOWNNAME;
    }

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    unsigned int FAR* puArgErr
    )
{
    DWORD dwExtensionId = 0;
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch * pPrivDisp = NULL;
    DISPID rgExtDispid = DISPID_UNKNOWN;

    //
    // This could be a special dispatch id - pass it to
    // the aggregator
    //

    if (dispidMember <= 0) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    //
    // It is not a special dispatch id, so compute the extension
    // id and pass it to the appropriate dispatch manager
    //

    dwExtensionId = EXTRACT_EXTENSION_ID(dispidMember);

    if (!dwExtensionId) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    if (!_pClassEntry) {

        RRETURN(DISP_E_MEMBERNOTFOUND);
    }


    pExtension = _pClassEntry->pExtensionHead;

    rgExtDispid = REMOVE_EXTENSION_ID(dispidMember);

    while (pExtension) {

        if (dwExtensionId == pExtension->dwExtensionID) {

            if (pExtension->fDisp) {

                //
                // fDisp = TRUE indicates 
                //  1)  extension supports pADsExt AND 
                //  2)  either 
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL 
                //      OR
                //      b) we don't know if a) is true or not yet (client bug)
                //

                ASSERT(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateInvoke(
                        rgExtDispid, 
                        iid,
                        lcid,
                        wFlags,
                        pdispparams,
                        pvarResult,
                        pexcepinfo,
                        puArgErr
                        );
                RRETURN(hr);

            } else {

                //
                // A dwExtensionId match indicates THIS extens'n has returned 
                // a valid dispid to clients thru' pADs->PrivateGetIDsOfNames. 
                // Thus, fDisp should be TURE.
                //
                // But since dispid goes thru' clients before passed back to
                // PrivateInovke(), don't ASSERT in case of clients errors.
                //

                RRETURN(DISP_E_MEMBERNOTFOUND);
            }
        }

        pExtension = pExtension->pNext;

    } // end while

    RRETURN(DISP_E_MEMBERNOTFOUND);
}


HRESULT
CADsExtMgr::CheckAndPrefixExtIDArray(
    IN      DWORD dwExtensionID,
    IN      unsigned int cDispids, 
    IN OUT  DISPID * rgDispids
    )
{
    
    HRESULT hrEach = S_OK;
    HRESULT hrAll = S_OK;


    ASSERT_VALID_EXTENSION_ID(dwExtensionID);


    for (unsigned int i = 0; i<cDispids; i++) 
    {
        hrEach = CheckAndPrefixExtID(
                    dwExtensionID,
                    rgDispids[i],
                    rgDispids+i
                    );

        if (FAILED(hrEach)) 
        {
            hrAll = E_FAIL;
            
            // 
            // The entire operation is considered as failure as a whole.
            // But continue to get other dispid s.t. debugger or user knows 
            // which dispid in the array is causing problem -> DISPID_UNKOWN
            //
        }
    }
    
    RRETURN(hrAll);

}


HRESULT
CADsExtMgr::CheckAndPrefixExtID(
    IN      DWORD   dwExtensionID,
    IN      DISPID  dispid,
    IN OUT  DISPID  * pNewDispid
    )
{
    ASSERT(pNewDispid);
    
    if  ( (dispid>= ADS_EXT_MINEXTDISPID) &&
          (dispid<= ADS_EXT_MAXEXTDISPID) ) 
    {
        *pNewDispid = PREFIX_EXTENSION_ID(dwExtensionID, dispid) ;

        RRETURN(S_OK);
    }    
    else
    {
        *pNewDispid = DISPID_UNKNOWN;

        RRETURN(E_FAIL);
    }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\charset.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    charset.cxx

Abstract:

    Contains some functions to do Unicode <-> Ansi/MBCS convertsions.

Author:

    Danilo Almeida  (t-danal)  06-17-96

Revision History:

--*/


//
// INCLUDES
//

#include "iis.hxx"

/*
 *  AnsiBytesFromUnicode
 *
 *  Description:
 *      Given a Unicode string, returns number of bytes needed for Ansi version
 *
 *  In:
 *      pwszUnicode - pointer to Unicode string
 */

int
AnsiBytesFromUnicode(
    LPCWSTR pwszUnicode
    )
{
    return WideCharToMultiByte(CP_ACP,
                               0,
                               pwszUnicode,
                               -1,
                               NULL,
                               0,
                               NULL,
                               NULL);
}


/*
 *  AllocAnsi
 *
 *  Description:
 *      Given a Unicode string, allocate a new Ansi translation of that string
 *
 *  In:
 *      pwszUnicode - pointer to original Unicode string
 *      ppszAnsi    - pointer to cell to hold new MCBS string addr
 *
 *  Out:
 *      ppszAnsi    - contains new MBCS string
 *
 *  Returns:
 *      Error code or 0 if successful.
 *
 *  Notes:
 *      The client must free the allocated string with FreeAnsi.
 */

UINT
AllocAnsi(
    LPCWSTR pwszUnicode,
    LPSTR* ppszAnsi
    )
{
    UINT     err;
    BYTE *   pbAlloc;
    INT      cbUnicode;
    INT      cbAnsi;

    if (pwszUnicode == NULL)
    {
        *ppszAnsi = NULL;
        return 0;
    }

    cbAnsi = AnsiBytesFromUnicode(pwszUnicode);
    err = AllocMem(cbAnsi, &pbAlloc);
    if (err)
        return err;

    cbUnicode = wcslen(pwszUnicode)+1;

    *ppszAnsi = (LPSTR)pbAlloc;

    err = (UINT) !WideCharToMultiByte(CP_ACP,
                                      0,
                                      pwszUnicode,
                                      cbUnicode,
                                      *ppszAnsi,
                                      cbAnsi,
                                      NULL,
                                      NULL);
    if (err)
    {
        *ppszAnsi = NULL;
        FreeMem(pbAlloc);
        return ( (UINT)GetLastError() );
    }

    return 0;
}


/*
 *  FreeAnsi
 *
 *  Description:
 *      Deallocates an Ansi string allocated by AllocAnsi
 *
 *  In:
 *      pszAnsi - pointer to the Ansi string
 *
 *  Out:
 *      pszAnsi - invalid pointer - string has been freed
 */

VOID
FreeAnsi(LPSTR pszAnsi)
{
    if (pszAnsi != NULL)
        FreeMem((LPBYTE)pszAnsi);
}

/*
 *  AllocUnicode
 *
 *  Description:
 *      Given an Ansi string, allocates an Unicode version of that string
 *
 *  In:
 *      pszAnsi         - pointer to original MBCS string
 *      ppwszUnicode    - pointer to new Unicode string address
 *
 *  Out:
 *      ppwszUnicode    - points to new Unicode string
 *
 *  Returns:
 *      Error code or 0 if successful.
 *
 *  Notes:
 *      The client must free the allocated string with FreeUnicode.
 */

UINT
AllocUnicode(
    LPCSTR   pszAnsi,
    LPWSTR * ppwszUnicode )
{
    UINT     err;
    BYTE *   pbAlloc;
    INT      cbAnsi;

    if (pszAnsi == NULL)
    {
        *ppwszUnicode = NULL;
        return 0;
    }

    // Allocate space for Unicode string (may be a little extra if MBCS)

    cbAnsi = strlen(pszAnsi)+1;
    err = AllocMem(sizeof(WCHAR) * cbAnsi, &pbAlloc);
    if (err)
        return err;

    *ppwszUnicode = (LPWSTR)pbAlloc;

    err = (UINT) !MultiByteToWideChar(CP_ACP,
                                      MB_PRECOMPOSED,
                                      pszAnsi,
                                      cbAnsi,
                                      *ppwszUnicode,
                                      cbAnsi);
    if (err)
    {
        *ppwszUnicode = NULL;
        FreeMem(pbAlloc);
        return ( (UINT)GetLastError() );
    }

    return 0;
}

/*
 *  AllocUnicode2
 *
 *  Description:
 *      Given a MBCS string, allocates a new Unicode version of that string
 *
 *  In:
 *      pszAnsi         - pointer to original MBCS string
 *      cbAnsi          - number of bytes to convert
 *      ppwszUnicode    - pointer to where to return new Unicode string address
 *
 *  Out:
 *      ppwszUnicode    - contains new Unicode string
 *
 *  Returns:
 *      Returns number of characters written.
 *
 *  Notes:
 *      The client must free the allocated string with FreeUnicode.
 */

int
AllocUnicode2(
    LPCSTR   pszAnsi,
    int      cbAnsi,
    LPWSTR * ppwszUnicode)
{
    UINT     err;
    BYTE *   pbAlloc;
    INT      cwch;

    *ppwszUnicode = NULL;
    SetLastError(ERROR_SUCCESS);

    if (cbAnsi == 0)
        return 0;

    err = AllocMem(sizeof(WCHAR) * cbAnsi, &pbAlloc);
    if (err)
    {
        SetLastError(err);
        return 0;
    }

    *ppwszUnicode = (LPWSTR)pbAlloc;

    cwch = MultiByteToWideChar(CP_ACP,
                               MB_PRECOMPOSED,
                               pszAnsi,
                               cbAnsi,
                               *ppwszUnicode,
                               cbAnsi);

    if (cwch == 0)
    {
        *ppwszUnicode = NULL;
        FreeMem(pbAlloc);
    }

    return cwch;
}

/*
 *  FreeUnicode
 *
 *  Description:
 *      Deallocates a Unicode string allocatedd by AllocUnicode/AllocUnicode2
 *
 *  In:
 *      pwszUnicode - pointer to the Unicode string
 *
 *  Out:
 *      pwszUnicode - invalid pointer - string has been freed
 */

VOID
FreeUnicode( LPWSTR pwszUnicode )
{
    if (pwszUnicode != NULL)
        FreeMem((LPBYTE)pwszUnicode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cipseccf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cipseccf.cxx
//
//  Contents:  Windows NT 4.0 IP Security Object Class Factory Code
//
//             CIISIPSecurityCF::CreateInstance
//
//  History:   21-04-97     sophiac    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISIPSecurityCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    21-04-97   sophiac     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISIPSecurityCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CIPSecurity::CreateIPSecurity(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cenumvar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 4.0 Enumerator Code
//
//             CIISEnumVariant::Create
//             CIISEnumVariant::CIISEnumVariant
//             CIISEnumVariant::~CIISEnumVariant
//             CIISEnumVariant::QueryInterface
//             CIISEnumVariant::AddRef
//             CIISEnumVariant::Release
//             CIISEnumVariant::Next
//             CIISEnumVariant::Skip
//             CIISEnumVariant::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::CIISEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CIISEnumVariant::CIISEnumVariant()
{
    //
    // Set the reference count on the enumerator.
    //
    m_cRef = 1;

}

//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::~CIISEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CIISEnumVariant::~CIISEnumVariant()
{
    //
    // Bump down the reference count on the Collection object
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CIISEnumVariant::AddRef(void)
{

    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CIISEnumVariant::Release(void)
{


    if(--m_cRef == 0){

        delete this;
        return 0;
    }

    return m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISEnumVariant::Skip(ULONG cElements)
{

    RRETURN(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISEnumVariant::Reset()
{

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cmacro.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cmacro.h
//
//  Contents:  Macros for adsi methods
//
//  History:   21-04-97     sophiac    Created.
//
//----------------------------------------------------------------------------

#define DEFINE_CONTAINED_IADs_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_Name(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                              \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_ADsPath(retval));                            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_Class(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Parent(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Schema(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_GUID(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(_pADs->Get(bstrName, pvProp));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(_pADs->Put(bstrName, vProp));                             \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(_pADs->GetEx(bstrName, pvProp));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(_pADs->PutEx(lnControlCode, bstrName, vProp));            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetInfo(THIS_)                                                   \
{                                                                     \
    RRETURN(_pADs->GetInfo());                                        \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetInfo(THIS_ )                                                  \
{                                                                     \
    RRETURN(_pADs->SetInfo());                                        \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(_pADs->GetInfoEx(vProperties, lnReserved));               \
}


#define DEFINE_CONTAINED_IDSObject_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetObjectAttributes(                                             \
    PADS_ATTR_DEF pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    DWORD *pdwNumAttributesModified                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->SetObjectAttributes(                             \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        pdwNumAttributesModified                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectAttributes(                                             \
    PADS_ATTR_NAME pAttributeNames,                                   \
    DWORD dwNumberAttributes,                                         \
    PADS_ATTR_DEF *ppAttributeEntries,                                \
    DWORD * pdwNumAttributesReturned                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectAttributes(                             \
                        pAttributeNames,                              \
                        dwNumberAttributes,                           \
                        ppAttributeEntries,                           \
                        pdwNumAttributesReturned                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateDSObject(                                                  \
    LPWSTR pszRDNName,                                                \
    PADS_ATTR_DEF pAttributeEntries,                                  \
    DWORD dwNumAttributes                                             \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->CreateDSObject(                                  \
                        pszRDNName,                                   \
                        pAttributeEntries,                            \
                        dwNumAttributes                               \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteDSObject(                                                  \
    LPWSTR pszRDNName                                                 \
    )                                                                 \
                                                                      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->DeleteDSObject(                                  \
                        pszRDNName                                    \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectInformation(                                            \
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo                              \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectInformation(                            \
                            ppObjInfo                                 \
                            );                                        \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IADsContainer_Implementation(cls)          \
STDMETHODIMP                                                          \
cls::get_Filter(THIS_ VARIANT FAR* pVar )                             \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Filter( pVar );                    \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Filter(THIS_ VARIANT Var )                                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Filter( Var );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Hints(THIS_ VARIANT FAR* pVar )                              \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Hints( pVar );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Hints(THIS_ VARIANT Var )                                    \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Hints( Var );                      \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Count(THIS_ long FAR* retval)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Count( retval );                   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get__NewEnum(THIS_ IUnknown * FAR * retval )                     \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get__NewEnum( retval );                \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObject(THIS_ BSTR ClassName, BSTR RelativeName,               \
               IDispatch * FAR * ppObject )                           \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->GetObject( ClassName, RelativeName, ppObject ); \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Create(THIS_ BSTR ClassName, BSTR RelativeName,                  \
            IDispatch * FAR * ppObject )                               \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr =_pADsContainer->Create( ClassName, RelativeName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Delete(THIS_ BSTR ClassName, BSTR SourceName )                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->Delete( ClassName, SourceName );       \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::CopyHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                           \
        hr = _pADsContainer->CopyHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::MoveHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                           \
        hr = _pADsContainer->MoveHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     

#define DEFINE_CONTAINED_IIsBaseObject_Implementation(cls)            \
STDMETHODIMP                                                          \
cls::GetDataPaths(THIS_ BSTR bstrName, LONG lnAttribute,              \
                  VARIANT FAR* pvProp)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pIIsBaseObject) {                                           \
        hr = _pIIsBaseObject->GetDataPaths( bstrName, lnAttribute, pvProp);   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetPropertyAttribObj(THIS_ BSTR bstrName,                        \
                          IDispatch * FAR *ppObject)                  \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pIIsBaseObject) {                                           \
        hr = _pIIsBaseObject->GetPropertyAttribObj(bstrName, ppObject); \
    }                                                                 \
    RRETURN(hr);                                                      \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cmime.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  cmime.cxx
//
//  Contents:  MimeType object
//
//  History:   04-1-97     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "iis.hxx"
#pragma hdrstop

//  Class CMimeType

DEFINE_Simple_IDispatch_Implementation(CMimeType)

CMimeType::CMimeType():
        _pDispMgr(NULL),
        _lpMimeType(NULL),
        _lpExtension(NULL)
{
    ENLIST_TRACKING(CMimeType);
}

HRESULT
CMimeType::CreateMimeType(
    REFIID riid,
    void **ppvObj
    )
{
    CMimeType FAR * pMimeType = NULL;
    HRESULT hr = S_OK;

    hr = AllocateMimeTypeObject(&pMimeType);
    BAIL_ON_FAILURE(hr);

    hr = pMimeType->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pMimeType->Release();

    RRETURN(hr);

error:
    delete pMimeType;

    RRETURN(hr);

}


CMimeType::~CMimeType( )
{
    if (_lpMimeType) {
        FreeADsStr(_lpMimeType);
    }

    if (_lpExtension) {
        FreeADsStr(_lpExtension);
    }

    delete _pDispMgr;
}

STDMETHODIMP
CMimeType::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IISMimeType FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IISMimeType))
    {
        *ppv = (IISMimeType FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IISMimeType FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


HRESULT
CMimeType::InitFromIISString(
    LPWSTR pszStr
    )
{
    LPWSTR pszToken = NULL;
    DWORD dwLen = 0;

    if (!pszStr) {
        return S_FALSE;
    }

    //
    // get length of pszStr; do not count ',' ; + 1 for null pointer and -1
    // for ','  so dwLen is = wcslen
    //

    dwLen = wcslen(pszStr);

    //
    // first token is extension
    //

    pszToken = wcstok(pszStr, L",");
    if (pszToken) {
        _lpExtension = AllocADsStr(pszToken);

        //
        // second token is mimetype
        //

        if (wcslen(pszStr) + 1 < dwLen) {
            pszToken = pszStr + wcslen(pszStr) + 1;
           _lpMimeType = AllocADsStr(pszToken);
        }
    }


    return S_OK;
}

HRESULT
CMimeType::CopyMimeType(
    LPWSTR *ppszMimeType
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszMimeType = NULL;
    DWORD dwLen = 0;

    if (!ppszMimeType) {
        return S_FALSE;
    }

    if (_lpExtension) {
        dwLen = wcslen(_lpExtension);
    }

    if (_lpMimeType) {
        dwLen += wcslen(_lpMimeType);
    }

    //
    // dwLen +2 to include comma and null terminator
    //

    pszMimeType = (LPWSTR)AllocADsMem((dwLen+2) * sizeof(WCHAR));

    if (!pszMimeType) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // empty contents
    //

    wcscpy(pszMimeType, L"");

    if (_lpExtension) {
        wcscpy(pszMimeType, _lpExtension);
    }

    wcscat(pszMimeType, L",");

    if (_lpMimeType) {
        wcscat(pszMimeType, _lpMimeType);
    }

    pszMimeType[wcslen(pszMimeType)] = L'\0';

    *ppszMimeType = pszMimeType;

error:

    RRETURN(hr);
}



HRESULT
CMimeType::AllocateMimeTypeObject(
    CMimeType ** ppMimeType
    )
{
    CMimeType FAR * pMimeType = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pMimeType = new CMimeType();
    if (pMimeType == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISOle,
                IID_IISMimeType,
                (IISMimeType *)pMimeType,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pMimeType->_pDispMgr = pDispMgr;
    *ppMimeType = pMimeType;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CMimeType::get_MimeType(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpMimeType, retval);
    RRETURN(hr);
}

STDMETHODIMP
CMimeType::put_MimeType(THIS_ BSTR bstrMimeType)
{
    if (!bstrMimeType) {
        RRETURN(E_FAIL);
    }
    if (_lpMimeType) {
        FreeADsStr(_lpMimeType);
    }
    _lpMimeType = AllocADsStr(bstrMimeType);
    if (!_lpMimeType) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CMimeType::get_Extension(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpExtension, retval);
    RRETURN(hr);
}

STDMETHODIMP
CMimeType::put_Extension(THIS_ BSTR bstrExtension)
{
    if (!bstrExtension) {
        RRETURN(E_FAIL);
    }
    if (_lpExtension) {
        FreeADsStr(_lpExtension);
    }
    _lpExtension = AllocADsStr(bstrExtension);
    if (!_lpExtension) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cgenobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  cgenobj.cxx
//
//  Contents:  Microsoft ADs IIS Provider Generic Object
//
//
//  History:   28-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//  Class CIISGenObject

DEFINE_IDispatch_ExtMgr_Implementation(CIISGenObject)
DEFINE_IADs_Implementation(CIISGenObject)


CIISGenObject::CIISGenObject():
                _pExtMgr(NULL),
                _pPropertyCache(NULL),
                _pszServerName(NULL),
                _pszMetaBasePath(NULL),
                _pAdminBase(NULL),
                _pSchema(NULL)
{

    VariantInit(&_vFilter);

    ENLIST_TRACKING(CIISGenObject);
}

HRESULT
CIISGenObject::CreateGenericObject(
    BSTR bstrADsPath,
    BSTR ClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszADsParent = NULL;
    WCHAR szCommonName[MAX_PATH+MAX_PROVIDER_TOKEN_LENGTH];

    pszADsParent = AllocADsStr((LPWSTR)bstrADsPath);

    if (!pszADsParent) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszADsParent = L'\0';

    //
    // Determine the parent and rdn name
    //

    hr = BuildADsParentPath(
                bstrADsPath,
                pszADsParent,
                szCommonName
                );

    //
    // call the helper function
    //

    hr = CIISGenObject::CreateGenericObject(
                 pszADsParent,
                 szCommonName,
                 ClassName,
                 Credentials,
                 dwObjectState,
                 riid,
                 ppvObj
                );

error:

    if (pszADsParent) {
        FreeADsStr(pszADsParent);
    }

    RRETURN(hr);
}


HRESULT
CIISGenObject::CreateGenericObject(
    BSTR Parent,
    BSTR CommonName,
    BSTR ClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CIISGenObject FAR * pGenObject = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszClassName = ClassName;

    hr = AllocateGenObject(ClassName, Credentials, &pGenObject);
    BAIL_ON_FAILURE(hr);

    hr = pGenObject->InitializeCoreObject(
                Parent,
                CommonName,
                ClassName,
                L"",
                CLSID_IISGenObject,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr =  pGenObject->CacheMetaDataPath();
    BAIL_ON_FAILURE(hr);

    hr = pGenObject->_pPropertyCache->InitializePropertyCache( 
            pGenObject->_pszServerName 
            );
    BAIL_ON_FAILURE(hr);

    //
    // To maintain compatibility with IIS4 we want to fail when
    // creating a new object if the metabase path already exists.
    //
    if( ADS_OBJECT_UNBOUND == pGenObject->_dwObjectState )
    {
        hr = ::MetaBaseDetectKey( pGenObject->_pAdminBase,
                                  pGenObject->_pszMetaBasePath
                                  );
        if( SUCCEEDED(hr) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS );
        }
        else if( ERROR_PATH_NOT_FOUND == HRESULT_CODE(hr) )
        {
            hr = S_OK;
        }
        
        BAIL_ON_FAILURE(hr);
    }

    if ( !_wcsicmp(ClassName, L"IIsFtpServer") ||
         !_wcsicmp(ClassName, L"IIsWebServer") ||
         !_wcsicmp(ClassName, L"IIsNntpServer") ||
         !_wcsicmp(ClassName, L"IIsSmtpServer") ||
         !_wcsicmp(ClassName, L"IIsPop3Server") ||
		 !_wcsicmp(ClassName, L"IIsImapServer")
		 ) 
	{
         pszClassName = L"IIsServer";
    }
    else if ( !_wcsicmp(ClassName, L"IIsWebDirectory") ||
         !_wcsicmp(ClassName, L"IIsWebVirtualDir")) 
	{
         pszClassName = L"IIsApp";
    }

    hr = ADSILoadExtensionManager(
                    pszClassName,
                    (IADs *)pGenObject,
                    Credentials,
                    pGenObject->_pDispMgr,
                    &pExtensionMgr
                    );
    BAIL_ON_FAILURE(hr);

    pGenObject->_pExtMgr = pExtensionMgr;

    hr = pGenObject->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGenObject->Release();

    RRETURN(hr);

error:

    delete pGenObject;
    RRETURN(hr);
}

CIISGenObject::~CIISGenObject( )
{
    delete _pExtMgr;

    VariantClear(&_vFilter);

    delete _pDispMgr;

    delete _pPropertyCache;

    if (_pszServerName) {

        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath){

        FreeADsStr(_pszMetaBasePath);
    }

}




STDMETHODIMP
CIISGenObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IISBaseObject))
    {
        *ppv = (IISBaseObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN(_pExtMgr->QueryInterface(iid,ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CIISGenObject::SetInfo()
{
    HRESULT hr = S_OK;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IIISApplicationAdmin * pAppAdmin = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        // Check to see if we're creating an IIsApplicationPool
        // If so, use the IISApplicationAdmin interface

        if ( !_wcsicmp(_ADsClass, L"IIsApplicationPool")) 
	    {
            memset(pcsiParam, 0, sizeof(COSERVERINFO));

            //
            // special case to handle "localhost" to work-around ole32 bug
            //

            if (_pszServerName == NULL || _wcsicmp(_pszServerName,L"localhost") == 0) {
                pcsiParam->pwszName =  NULL;
            }
            else {
                pcsiParam->pwszName = _pszServerName;
            }

            hr = CoGetClassObject(
                        CLSID_WamAdmin,
                        CLSCTX_SERVER,
                        pcsiParam,
                        IID_IClassFactory,
                        (void**) &pcsfFactory
                        );

            BAIL_ON_FAILURE(hr);
    
            hr = pcsfFactory->CreateInstance(
                        NULL,
                        IID_IIISApplicationAdmin,
                       (void **) &pAppAdmin
                        );
            BAIL_ON_FAILURE(hr);

            hr = pAppAdmin->CreateApplicationPool( _Name );

            // Don't BAIL_ON_FAILURE here!  Check the HR below first...
        }

        // Otherwise do the creation the old fashioned way

        else {
            hr = IISCreateObject();
        }

        //
        // Since methods that we aggregate like IIsApp::AppCreate may
        // persist our path in the metabase we don't want to fail just
        // because the path exists. This is done to maintain backward
        // compatibility with IIS4.
        //
        if( ERROR_ALREADY_EXISTS != HRESULT_CODE(hr) )
        {
            BAIL_ON_FAILURE(hr);
        }

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }

    hr = IISSetObject();
    BAIL_ON_FAILURE(hr);

error:

    if (pcsfFactory) {
        pcsfFactory->Release();
    }
 
    if (pAppAdmin) {
        pAppAdmin->Release();
    } 

    RRETURN(hr);
}


HRESULT
CIISGenObject::IISSetObject()
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    PMETADATA_RECORD pMetaDataArray = NULL;
    DWORD dwMDNumDataEntries = 0;


    //
    // Add SetObject functionality : sophiac
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = OpenAdminBaseKey(
                _pszServerName,
                (LPWSTR) _pszMetaBasePath,
                METADATA_PERMISSION_WRITE,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);


    hr = _pPropertyCache->IISMarshallProperties(
                            &pMetaDataArray,
                            &dwMDNumDataEntries
                            );
    BAIL_ON_FAILURE(hr);

    hr = MetaBaseSetAllData(
                _pAdminBase,
                hObjHandle,
                L"",
                (PMETADATA_RECORD)pMetaDataArray,
                dwMDNumDataEntries
                );
    BAIL_ON_FAILURE(hr);


error:

    if (pMetaDataArray) {
        FreeMetaDataRecordArray(pMetaDataArray, dwMDNumDataEntries);
    }

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }


    RRETURN(hr);
}


HRESULT
CIISGenObject::IISCreateObject()
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    METADATA_RECORD mdrData;
    WCHAR DataBuf[MAX_PATH];


    //
    // Add CreateObject functionality : sophiac
    //

    hr = OpenAdminBaseKey(
                _pszServerName,
                L"",
                METADATA_PERMISSION_WRITE,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    //
    // Pass in full path
    //

    hr = MetaBaseCreateObject(
                _pAdminBase,
                hObjHandle,
                _pszMetaBasePath
                );

    if( ERROR_ALREADY_EXISTS != HRESULT_CODE(hr) )
    {
        BAIL_ON_FAILURE(hr);
    }

    //
    // Set KeyType
    //

    wcscpy((LPWSTR)DataBuf, _ADsClass);

    mdrData.dwMDIdentifier = MD_KEY_TYPE;
    mdrData.dwMDDataType = STRING_METADATA;
    mdrData.dwMDUserType = IIS_MD_UT_SERVER;
    mdrData.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdrData.dwMDDataLen = (wcslen(DataBuf)+1)*2;
    mdrData.pbMDData = (PBYTE)DataBuf;

    hr = _pAdminBase->SetData(
                hObjHandle,
                _pszMetaBasePath,
                &mdrData);
    BAIL_ON_FAILURE(hr);

error:

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

HRESULT
CIISGenObject::GetInfo()
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(TRUE));
}

HRESULT
CIISGenObject::GetInfo(
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    DWORD dwMDAttributes =  METADATA_INHERIT;
    DWORD dwMDUserType = ALL_METADATA;
    DWORD dwMDDataType = ALL_METADATA;
    DWORD dwMDNumDataEntries;
    DWORD dwMDDataSetNumber;
    LPBYTE pBuffer = NULL;


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = OpenAdminBaseKey(
                _pszServerName,
                _pszMetaBasePath,
                METADATA_PERMISSION_READ,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);


    hr = MetaBaseGetAllData(
                _pAdminBase,
                hObjHandle,
                L"",
                dwMDAttributes,
                dwMDUserType,
                dwMDDataType,
                &dwMDNumDataEntries,
                &dwMDDataSetNumber,
                (LPBYTE *)&pBuffer
                );
    BAIL_ON_FAILURE(hr);


    hr = _pPropertyCache->IISUnMarshallProperties(
                            pBuffer,
                            pBuffer,
                            dwMDNumDataEntries,
                            fExplicit
                            );
    BAIL_ON_FAILURE(hr);

error:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

/* IADsContainer methods */

STDMETHODIMP
CIISGenObject::get_Count(long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISGenObject::get_Filter(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISGenObject::put_Filter(THIS_ VARIANT Var)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISGenObject::put_Hints(THIS_ VARIANT Var)
{
    RRETURN( E_NOTIMPL);
}


STDMETHODIMP
CIISGenObject::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISGenObject::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                    _ADsPath,
                    ClassName,
                    RelativeName,
                    _Credentials,
                    ppObject,
                    FALSE
                    );
    RRETURN(hr);

}

STDMETHODIMP
CIISGenObject::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CIISGenObjectEnum::Create(
                (CIISGenObjectEnum **)&penum,
                _ADsPath,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN(hr);
}

inline
HRESULT
ValidateRelativePath(
    IN LPCWSTR wszRelativePath
    )
/*++

Routine Description:

    Determine if a relative path is valid. This is really just to check
    assumptions that are made about the relative path. 
    
    It doesn't do much now, but might be expanded and moved to a common
    location if necessary.

Arguments:

    IN wszRelativePath  : a relative ads path

Return Value:

    E_ADS_BAD_PATHNAME if the path is not valid

--*/
{
    HRESULT hr = E_ADS_BAD_PATHNAME;

    if( wszRelativePath && *wszRelativePath != L'/' )
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISGenObject::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT   hr = S_OK;
    IADs *    pADs  = NULL;
 
    BOOL      bRelativeNameExtended = FALSE;
    LPWSTR    pwszParentClass = NULL;
    LPWSTR    pwszParentADsPath = NULL;
    LPWSTR    pwszRelativeName = NULL;
    DWORD     i = 0;

    //
    // Validate if this class really exists in the schema
    // and validate that this object can be created in this
    // container
    //
    hr = _pSchema->ValidateClassName(ClassName);
    BAIL_ON_FAILURE(hr);

    //
    // Handle case where RelativeName may be an extended path,
    // such as foo/bar/baz.
    //
    hr = ValidateRelativePath( RelativeName );
    BAIL_ON_FAILURE(hr);

    bRelativeNameExtended = ( wcschr( RelativeName, L'/' ) != NULL );
    if( bRelativeNameExtended )
    {
        pwszRelativeName = wcsrchr( RelativeName, L'/' ) + 1;

        hr = ResolveExtendedChildPath( RelativeName, 
                                       &pwszParentADsPath,
                                       &pwszParentClass );

        BAIL_ON_FAILURE(hr);
    }
    else
    {
        pwszParentClass = _ADsClass;
        pwszParentADsPath = _ADsPath;
        pwszRelativeName = RelativeName;
    }

    //
    // validate name --> can't have ',' in the name
    //

    while (RelativeName[i] != L'\0' && RelativeName[i] != L',')
       i++;

    if (RelativeName[i] != L'\0' || i >= METADATA_MAX_NAME_LEN) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    } 
  
    hr = _pSchema->ValidateContainedClassName(pwszParentClass, ClassName);
    BAIL_ON_FAILURE(hr);

    hr = CIISGenObject::CreateGenericObject(
                    pwszParentADsPath,
                    pwszRelativeName,
                    ClassName,
                    _Credentials,
                    ADS_OBJECT_UNBOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(
                    IID_IDispatch,
                    (void **)ppObject
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pADs) {
        pADs->Release();
    }
    
    if( bRelativeNameExtended )
    {
        ADsFreeString( pwszParentClass );
        ADsFreeString( pwszParentADsPath );
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISGenObject::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IIISApplicationAdmin * pAppAdmin = NULL;

    //
    // Get Server and Path name
    //

    hr = CacheMetaDataPath();
    BAIL_ON_FAILURE(hr);

    // Check to see if we're deleting an IIsApplicationPool
    // If so, use the IISApplicationAdmin interface

    if ( !_wcsicmp(bstrClassName, L"IIsApplicationPool")) 
	{
        memset(pcsiParam, 0, sizeof(COSERVERINFO));

        //
        // special case to handle "localhost" to work-around ole32 bug
        //

        if (_pszServerName == NULL || _wcsicmp(_pszServerName,L"localhost") == 0) {
            pcsiParam->pwszName =  NULL;
        }
        else {
            pcsiParam->pwszName = _pszServerName;
        }

        hr = CoGetClassObject(
                    CLSID_WamAdmin,
                    CLSCTX_SERVER,
                    pcsiParam,
                    IID_IClassFactory,
                    (void**) &pcsfFactory
                    );

        BAIL_ON_FAILURE(hr);
    
        hr = pcsfFactory->CreateInstance(
                    NULL,
                    IID_IIISApplicationAdmin,
                   (void **) &pAppAdmin
                    );
        BAIL_ON_FAILURE(hr);

        hr = pAppAdmin->DeleteApplicationPool( bstrRelativeName );

        BAIL_ON_FAILURE(hr);
        
    }

    // Otherwise do the delete the old fashioned way

    else {
        hr = OpenAdminBaseKey(
                    _pszServerName,
                    _pszMetaBasePath,
                    METADATA_PERMISSION_WRITE,
                    &_pAdminBase,
                    &hObjHandle
                    );
        BAIL_ON_FAILURE(hr);

        //
        // Pass in full path
        //

        hr = MetaBaseDeleteObject(
                    _pAdminBase,
                    hObjHandle,
                    (LPWSTR)bstrRelativeName
                    );
        BAIL_ON_FAILURE(hr);
    }

error:

    if (pcsfFactory) {
        pcsfFactory->Release();
    }
 
    if (pAppAdmin) {
        pAppAdmin->Release();
    } 

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISGenObject::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IUnknown *pUnk = NULL;
    METADATA_HANDLE hObjHandle = NULL;
    LPWSTR pszIISPathName = NULL;
    IADs  *pADs = NULL;
    BSTR bstrClassName = NULL;
    LPWSTR pszPath = NULL;
    IWamAdmin2 *pWamAdmin = NULL;
    LPWSTR pszIISNewName = NULL;
    
    hr = InitWamAdmin(_pszServerName, &pWamAdmin);
    BAIL_ON_FAILURE(hr);

    //
    // open common path node
    //

    hr = BuildIISPathFromADsPath(
                _ADsPath,
                &pszIISPathName
                );
    BAIL_ON_FAILURE(hr);

    hr = OpenAdminBaseKey(
                _pszServerName,
                pszIISPathName,
                METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    //
    // Do Copy operation
    //

    hr = MetaBaseCopyObject(
                _pAdminBase,
                hObjHandle,
                (LPWSTR)SourceName,
                hObjHandle,
                (LPWSTR)NewName
                );
    BAIL_ON_FAILURE(hr);

    if (hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
        hObjHandle = NULL;
    }

    if (pszIISPathName) {
        DWORD dwLen;
        dwLen = wcslen(pszIISPathName) + wcslen(NewName) + 2;

        pszIISNewName = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));

        if (!pszIISNewName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(pszIISNewName, pszIISPathName);
        if (NewName) {
            wcscat(pszIISNewName, L"/");
            wcscat(pszIISNewName, (LPWSTR)NewName);
        }
    }

    hr = pWamAdmin->AppRecover((LPWSTR) pszIISNewName, TRUE);
    BAIL_ON_FAILURE(hr);

    hr = get_CoreADsClass(&bstrClassName);
    BAIL_ON_FAILURE(hr);

    hr = CIISGenObject::CreateGenericObject(
                    _ADsPath,
                    NewName,
                    bstrClassName,
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);

    pszPath = ((CIISGenObject*)pADs)->ReturnMetaDataPath();

    hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppObject
                        );
    BAIL_ON_FAILURE(hr);

error:

    if (_pAdminBase) {
        if (hObjHandle) {
            CloseAdminBaseKey(_pAdminBase, hObjHandle);
        }
    }

    if (pWamAdmin) {
        UninitWamAdmin(pWamAdmin);
    }

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    if (pszIISPathName) {
        FreeADsStr(pszIISPathName);
    }

    if (pszIISNewName) {
        FreeADsMem(pszIISNewName);
    }

    if (pADs){
        pADs->Release();
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISGenObject::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IUnknown *pUnk = NULL;
    METADATA_HANDLE hObjHandle = NULL;
    LPWSTR pszIISPathName = NULL;
    IADs  *pADs = NULL;
    BSTR bstrClassName = NULL;
    LPWSTR pszPath = NULL;
    IWamAdmin2 *pWamAdmin = NULL;
    LPWSTR pszIISOldName = NULL;
    LPWSTR pszIISNewName = NULL;
    
    hr = InitWamAdmin(_pszServerName, &pWamAdmin);
    BAIL_ON_FAILURE(hr);

    //
    // open common path node
    //

    hr = BuildIISPathFromADsPath(
                _ADsPath,
                &pszIISPathName
                );
    BAIL_ON_FAILURE(hr);

    if (pszIISPathName) {

        DWORD dwLen;
        dwLen = wcslen(pszIISPathName) + wcslen(SourceName) + 2;

        pszIISOldName = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));

        if (!pszIISOldName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(pszIISOldName, pszIISPathName);
        if (NewName) {
            wcscat(pszIISOldName, L"/");
            wcscat(pszIISOldName, (LPWSTR)SourceName);
        }
    }

    hr = pWamAdmin->AppDeleteRecoverable((LPWSTR) pszIISOldName, TRUE);
    BAIL_ON_FAILURE(hr);

    hr = OpenAdminBaseKey(
                _pszServerName,
                pszIISPathName,
                METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    //
    // Do Move operation
    //

    hr = MetaBaseMoveObject(
                _pAdminBase,
                hObjHandle,
                (LPWSTR)SourceName,
                hObjHandle,
                (LPWSTR)NewName
                );
    BAIL_ON_FAILURE(hr);

    if (hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
        hObjHandle = NULL;
    }

    if (pszIISPathName) {
        DWORD dwLen;
        dwLen = wcslen(pszIISPathName) + wcslen(NewName) + 2;

        pszIISNewName = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));

        if (!pszIISNewName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(pszIISNewName, pszIISPathName);
        if (NewName) {
            wcscat(pszIISNewName, L"/");
            wcscat(pszIISNewName, (LPWSTR)NewName);
        }
    }

    hr = pWamAdmin->AppRecover((LPWSTR) pszIISNewName, TRUE);
    BAIL_ON_FAILURE(hr);

    hr = get_CoreADsClass(&bstrClassName);
    BAIL_ON_FAILURE(hr);

    hr = CIISGenObject::CreateGenericObject(
                    _ADsPath,
                    NewName,
                    bstrClassName,
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);

    pszPath = ((CIISGenObject*)pADs)->ReturnMetaDataPath();

    hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppObject
                        );
    BAIL_ON_FAILURE(hr);

error:

    if (_pAdminBase) {
        if (hObjHandle) {
            CloseAdminBaseKey(_pAdminBase, hObjHandle);
        }
    }

    if (pWamAdmin) {
        UninitWamAdmin(pWamAdmin);
    }

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    if (pszIISPathName) {
        FreeADsStr(pszIISPathName);
    }

    if (pszIISOldName) {
        FreeADsMem(pszIISOldName);
    }

    if (pszIISNewName) {
        FreeADsMem(pszIISNewName);
    }

    if (pADs){
        pADs->Release();
    }

    RRETURN(hr);
}


HRESULT
CIISGenObject::AllocateGenObject(
    LPWSTR pszClassName,
    CCredentials& Credentials,
    CIISGenObject ** ppGenObject
    )
{
    CIISGenObject FAR * pGenObject = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pGenObject = new CIISGenObject();
    if (pGenObject == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pGenObject,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_IISOle,
                           IID_IISBaseObject,
                           (IISBaseObject *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                        (CCoreADsObject FAR *)pGenObject,
                        &pPropertyCache
                        );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache((IPropertyCache*)pPropertyCache);

    pGenObject->_Credentials = Credentials;
    pGenObject->_pPropertyCache = pPropertyCache;
    pGenObject->_pDispMgr = pDispMgr;
    *ppGenObject = pGenObject;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}

/* INTRINSA suppress=null_pointers, uninitialized */
STDMETHODIMP
CIISGenObject::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwSyntax;
    DWORD dwNumValues = 0;
    LPIISOBJECT pIISSrcObjects = NULL;
    WCHAR wchName[MAX_PATH];
    BSTR bstrClassName = NULL;

    //
    // check if property is a supported property
    //

    hr = get_CoreADsClass(&bstrClassName);
    BAIL_ON_FAILURE(hr);
    hr = _pSchema->ValidateProperty(bstrClassName, bstrName);
    BAIL_ON_FAILURE(hr);

    //
    // lookup ADSI IIS syntax Id
    //

    hr = _pSchema->LookupSyntaxID(bstrName, &dwSyntax);
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //
    // check if property is RAW BINARY type;
    // if RAW BINARY type, get corresponding NTACL flag property
    //
    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
    }


    //
    // retrieve data object from cache; if one exists
    //
    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY)
    {
    hr = _pPropertyCache->getproperty(
                wchName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    else
    {
    hr = _pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    BAIL_ON_FAILURE(hr);

    //
    // reset it to its syntax id if BITMASK type
    //

    pIISSrcObjects->IISType = dwSyntax;

    //
    // translate the IIS objects to variants
    //

    //
    // always return an array for multisz type
    //

    if (dwNumValues == 1 && dwSyntax != IIS_SYNTAX_ID_MULTISZ &&
        dwSyntax != IIS_SYNTAX_ID_MIMEMAP ) {

        hr  = IISTypeToVarTypeCopy(
                   _pSchema,
                   bstrName,
                   pIISSrcObjects,
                   pvProp,
                   FALSE
                   );
    }else {

        hr = IISTypeToVarTypeCopyConstruct(
                    _pSchema,
                    bstrName,
                    pIISSrcObjects,
                    dwNumValues,
                    pvProp,
                    FALSE
                    );

    }

    BAIL_ON_FAILURE(hr);

error:

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    if (pIISSrcObjects) {

        IISTypeFreeIISObjects(
            pIISSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISGenObject::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPIISOBJECT pIISDestObjects = NULL;
    DWORD dwNumValues = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vVar;
    WCHAR wchName[MAX_PATH];
    BSTR bstrClassName = NULL;

    //
    // check if property is a supported property
    //

    hr = get_CoreADsClass(&bstrClassName);
    BAIL_ON_FAILURE(hr);
    hr = _pSchema->ValidateProperty(bstrClassName, bstrName);
    BAIL_ON_FAILURE(hr);

    //
    // lookup its syntax ID
    //

    hr = _pSchema->LookupSyntaxID( bstrName, &dwSyntaxId);
    BAIL_ON_FAILURE(hr);

    //
    // Issue: How do we handle multi-valued support
    //

    VariantInit(&vVar);
    VariantCopyInd(&vVar, &vProp);

    if ((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar)) {
        hr  = ConvertArrayToVariantArray(
                    vVar,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;
    }
    else {

        dwNumValues = 1;
        pvProp = &vVar;
    }


    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToIISTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pIISDestObjects,
                    FALSE
                    );
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //

    if (dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
        VARIANT vGetProp;
        DWORD dwMask;
        DWORD dwFlagValue;

        hr = _pSchema->LookupBitMask(bstrName, &dwMask);
        BAIL_ON_FAILURE(hr);

        // 
        // get its corresponding DWORD flag value
        // 

        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);

        VariantInit(&vGetProp);
        hr = Get(wchName, &vGetProp);
        BAIL_ON_FAILURE(hr);

        dwFlagValue = V_I4(&vGetProp);
 
        if (pIISDestObjects->IISValue.value_1.dwDWORD) {
            dwFlagValue |= dwMask;
        }
        else {
            dwFlagValue &= ~dwMask;
        }

        pIISDestObjects->IISValue.value_1.dwDWORD = dwFlagValue;
        pIISDestObjects->IISType = IIS_SYNTAX_ID_DWORD;
        bstrName = wchName;
    }

    if (dwSyntaxId == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
        bstrName = wchName;
    }
    

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //

    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    CACHE_PROPERTY_MODIFIED,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pIISDestObjects) {
        IISTypeFreeIISObjects(
                pIISDestObjects,
                dwNumValues
                );

    }

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    VariantClear(&vVar);

    RRETURN(hr);
}


STDMETHODIMP
CIISGenObject::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPIISOBJECT pIISDestObjects = NULL;
    DWORD dwNumValues = 0;
    DWORD dwFlags = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vVar;
    WCHAR wchName[MAX_PATH];
    BSTR bstrClassName = NULL;

    METADATA_HANDLE hObjHandle = NULL;

    //
    // check if property is a supported property
    //

    hr = get_CoreADsClass(&bstrClassName);
    BAIL_ON_FAILURE(hr);
    hr = _pSchema->ValidateProperty(bstrClassName, bstrName);
    BAIL_ON_FAILURE(hr);

    //
    // lookup its syntax Id
    //

    hr = _pSchema->LookupSyntaxID( bstrName, &dwSyntaxId);
    BAIL_ON_FAILURE(hr);

    switch (lnControlCode) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = CACHE_PROPERTY_CLEARED;

        pIISDestObjects = NULL;
        dwNumValues = 0;

        break;

    case ADS_PROPERTY_UPDATE:
        dwFlags = CACHE_PROPERTY_MODIFIED;

        //
        // Now begin the rest of the processing
        //
  
        VariantInit(&vVar);
        VariantCopyInd(&vVar, &vProp);

        if ((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar)) {
            hr  = ConvertArrayToVariantArray(
                        vVar,
                        &pVarArray,
                        &dwNumValues
                        );

            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;
        }
        else {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

		VariantClear(&vVar);

        //
        // check if the variant maps to the syntax of this property
        //

        hr = VarTypeToIISTypeCopyConstruct(
                        dwSyntaxId,
                        pvProp,
                        dwNumValues,
                        &pIISDestObjects,
                        TRUE
                        );
        BAIL_ON_FAILURE(hr);

        break;

    default:
       RRETURN(hr = E_ADS_BAD_PARAMETER);

    }

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //

    if (dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
        VARIANT vGetProp;
        DWORD dwMask;
        DWORD dwFlagValue;

        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);

        if (dwFlags != CACHE_PROPERTY_CLEARED) {

            hr = _pSchema->LookupBitMask(bstrName, &dwMask);
            BAIL_ON_FAILURE(hr);

            // 
            // get its corresponding DWORD flag value
            // 

            VariantInit(&vGetProp);
            hr = Get(wchName, &vGetProp);
            BAIL_ON_FAILURE(hr);

            dwFlagValue = V_I4(&vGetProp);
 
            if (pIISDestObjects->IISValue.value_1.dwDWORD) {
                dwFlagValue |= dwMask;
            }
            else {
                dwFlagValue &= ~dwMask;
            }

            pIISDestObjects->IISValue.value_1.dwDWORD = dwFlagValue;
            pIISDestObjects->IISType = IIS_SYNTAX_ID_DWORD;
        }

        bstrName = wchName;
    }

    if (dwSyntaxId == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
        bstrName = wchName;
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //

    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    dwFlags,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    if (dwFlags == CACHE_PROPERTY_CLEARED) {
        DWORD dwMetaId;

        hr = _pSchema->LookupMetaID(bstrName, &dwMetaId);
        BAIL_ON_FAILURE(hr);

        hr = OpenAdminBaseKey(
                    _pszServerName,
                    _pszMetaBasePath,
                    METADATA_PERMISSION_WRITE,
                    &_pAdminBase,
                    &hObjHandle
                    );
        BAIL_ON_FAILURE(hr);

        hr = _pAdminBase->DeleteData(
                              hObjHandle,
                              (LPWSTR)L"",
                              dwMetaId,
                              ALL_METADATA
                              );

        if (hr == MD_ERROR_DATA_NOT_FOUND) {
            hr = S_OK;
        }
    }

error:

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    if (pIISDestObjects) {
        IISTypeFreeIISObjects(
                pIISDestObjects,
                dwNumValues
                );

    }

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}

/* INTRINSA suppress=null_pointers, uninitialized */
STDMETHODIMP
CIISGenObject::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwSyntax;
    DWORD dwNumValues = 0;
    LPIISOBJECT pIISSrcObjects = NULL;
    WCHAR wchName[MAX_PATH];
    BSTR bstrClassName = NULL;

    //
    // check if property is a supported property
    //

    hr = get_CoreADsClass(&bstrClassName);
    BAIL_ON_FAILURE(hr);
    hr = _pSchema->ValidateProperty(bstrClassName, bstrName);
    BAIL_ON_FAILURE(hr);

    //
    // lookup its syntax Id
    //

    hr = _pSchema->LookupSyntaxID(bstrName, &dwSyntax);
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //
    // check if property is RAW BINARY type;
    // if RAW BINARY type, get corresponding NTACL flag property
    //
    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
    }

    //
    // retrieve data object from cache; if one exists
    //
    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY)
    {
    hr = _pPropertyCache->getproperty(
                wchName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    else
    {
    hr = _pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    BAIL_ON_FAILURE(hr);

    //
    // reset it to its syntax id if BITMASK type
    //

    pIISSrcObjects->IISType = dwSyntax;

    //
    // translate the IIS objects to variants
    //

    hr = IISTypeToVarTypeCopyConstruct(
                    _pSchema,
                    bstrName,
                    pIISSrcObjects,
                    dwNumValues,
                    pvProp,
                    TRUE
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    if (pIISSrcObjects) {

        IISTypeFreeIISObjects(
            pIISSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}

HRESULT
CIISGenObject::CacheMetaDataPath()
{
    HRESULT hr = E_FAIL;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(_ADsPath);
    LPWSTR pszIISPathName =  NULL;


    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    _pszServerName = AllocADsStr(pObjectInfo->TreeName);

    if (!_pszServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = InitServerInfo(_pszServerName, &_pAdminBase, &_pSchema);
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(_ADsPath);

    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';

    hr = BuildIISPathFromADsPath(
                pObjectInfo,
                pszIISPathName
                );
    BAIL_ON_FAILURE(hr);

    _pszMetaBasePath = AllocADsStr(pszIISPathName);

    if (!_pszMetaBasePath) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:

    if (pszIISPathName) {
        FreeADsStr(pszIISPathName);
    }

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);

}

STDMETHODIMP
CIISGenObject::GetDataPaths(
    THIS_ BSTR bstrName,
    THIS_ LONG lnAttribute,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwMetaId;
    DWORD dwAttribute;
    DWORD dwTemp;
    METADATA_HANDLE hObjHandle = NULL;
    LPBYTE pBuffer = NULL;

    //
    // check if property is a supported property
    //

    hr = _pSchema->LookupMetaID(bstrName, &dwMetaId);
    BAIL_ON_FAILURE(hr);

    hr = _pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwTemp);
    BAIL_ON_FAILURE(hr);

    switch (lnAttribute) {
    case IIS_ANY_PROPERTY:
       break;

    case IIS_INHERITABLE_ONLY:
       if ((METADATA_INHERIT & dwAttribute) != METADATA_INHERIT) {
          RRETURN(hr = MD_ERROR_DATA_NOT_FOUND); 
       }
       break;

    default :
       RRETURN(hr = E_ADS_BAD_PARAMETER);
    }  

    //
    // Get Server and Path name
    //

    hr = CacheMetaDataPath();
    BAIL_ON_FAILURE(hr);

    hr = OpenAdminBaseKey(
                _pszServerName,
                _pszMetaBasePath,
                METADATA_PERMISSION_READ,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    hr =  MetaBaseGetDataPaths(_pAdminBase,
                               hObjHandle,
                               dwMetaId,
                               (LPBYTE *)&pBuffer
                               ); 
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromPathArray( (LPWSTR)_ADsPath, (LPWSTR)pBuffer, pvProp);
    BAIL_ON_FAILURE(hr);

error:

    if (pBuffer) {
        FreeADsMem(pBuffer);
    }

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISGenObject::GetPropertyAttribObj(
    THIS_ BSTR bstrName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwMetaId;
    DWORD i = 0;
    PROPERTYINFO *pPropertyInfo = NULL;
    IISPropertyAttribute * pPropAttrib = NULL;
    WCHAR wchName[MAX_PATH];

    METADATA_HANDLE hObjHandle = NULL;
    DWORD dwBufferSize = 0;
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = NULL;
    VARIANT vVar;

    VariantInit(&vVar);
    *ppObject = NULL;

    //
    // if passed in bstrName is a meta id, then convert it to property name
    //

    if (wcslen(bstrName) >= MAX_PATH) bstrName[MAX_PATH - 1] = L'\0';
    wcscpy((LPWSTR)wchName, bstrName);
    
    while (wchName[i] != L'\0' && wchName[i] >= L'0' && 
           wchName[i] <= L'9') {
       i++;
    }
 
    if (i == wcslen((LPWSTR)wchName)) {
        dwMetaId = _wtoi((LPWSTR)wchName);
        hr = _pSchema->ConvertID_To_PropName(dwMetaId, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
    }
    else {

        //
        // check if property is a supported property
        //

        hr = _pSchema->LookupMetaID(bstrName, &dwMetaId);
        BAIL_ON_FAILURE(hr);
    }

    hr = OpenAdminBaseKey(
            _pszServerName,
            _pszMetaBasePath,
            METADATA_PERMISSION_READ,
            &_pAdminBase,
            &hObjHandle
            );
    BAIL_ON_FAILURE(hr);

    MD_SET_DATA_RECORD(&mdrMDData,
                   dwMetaId,
                   METADATA_INHERIT | METADATA_ISINHERITED,
                   ALL_METADATA,
                   ALL_METADATA,
                   dwBufferSize,
                   pBuffer);

    hr = _pAdminBase->GetData(
            hObjHandle,
            L"",
            &mdrMDData,
            &dwBufferSize
            );

    pBuffer = (LPBYTE) AllocADsMem(dwBufferSize);
    mdrMDData.pbMDData = pBuffer;
    mdrMDData.dwMDDataLen = dwBufferSize; 

    hr = _pAdminBase->GetData(
            hObjHandle,
            L"",
            &mdrMDData,
            &dwBufferSize
            );
    BAIL_ON_FAILURE(hr);

    //
    // get default value
    //

    pPropertyInfo = _pSchema->GetPropertyInfo(wchName);
    ASSERT(pPropertyInfo != NULL);

    if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_DWORD ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MIMEMAP ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_IPSECLIST ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BINARY ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_NTACL) {
        vVar.vt = VT_I4;
        vVar.lVal = pPropertyInfo->dwDefault;
    }
    else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL ||
             pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
        vVar.vt = VT_BOOL;
        vVar.boolVal = pPropertyInfo->dwDefault ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MULTISZ) {
        LPWSTR pszStr = pPropertyInfo->szDefault;

        hr = MakeVariantFromStringArray(NULL,
                                        pszStr,
                                        &vVar);
        BAIL_ON_FAILURE(hr);
    }
    else {
        vVar.vt = VT_BSTR;
        hr = ADsAllocString( pPropertyInfo->szDefault, &(vVar.bstrVal));
        BAIL_ON_FAILURE(hr);
    }

    hr = CPropertyAttribute::CreatePropertyAttribute(
                           IID_IISPropertyAttribute,
                           (VOID**)&pPropAttrib
                           );
    BAIL_ON_FAILURE(hr);

    hr = ((CPropertyAttribute*)pPropAttrib)->InitFromRawData(
                           (LPWSTR) wchName,
                           dwMetaId,
                           mdrMDData.dwMDUserType,   // usertype
                           mdrMDData.dwMDAttributes,  // attributes
                           &vVar
                           );
    BAIL_ON_FAILURE(hr);

    *ppObject = (IDispatch*)pPropAttrib;

error:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    if (hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

HRESULT
CIISGenObject::ResolveExtendedChildPath(
    IN   BSTR RelativeChildPath,
    OUT  BSTR *pParentPath,
    OUT  BSTR *pParentClass
)
/*++

Routine Description:

    Helper method called from CIISGenObject::Create() finds the
    metabase key that is most proximate to RelativeChildPath and
    returns the ADS class for this key along with adjusted path
    for the parent.

Arguments:

    IN  RelativeChildPath : An extended subpath, such as foo/bar
    OUT pParentPath       : Allocated with ADsAllocString
    OUT pParentClass      : Allocated with ADsAllocString

Return Value:

    S_OK
    S_FALSE               : No path found in the metabase

--*/
{
    ADsAssert( RelativeChildPath );
    ADsAssert( pParentPath );
    ADsAssert( pParentClass );

    *pParentPath = NULL;
    *pParentClass = NULL;

    HRESULT hr = S_OK;
    DWORD   cbBuffSize;
    LPWSTR  pwszPathBuffer = NULL;
    DWORD   dwLen;
    BOOL    bFound;
    WCHAR   *pch = NULL;
    WCHAR   wszParentClassBuffer[MAX_PATH];    

    //
    // Build buffer to hold the metabase and ads paths
    //
    cbBuffSize = (wcslen(_ADsPath) + wcslen(RelativeChildPath) + 2)
                 * sizeof(WCHAR);
    
    pwszPathBuffer = (LPWSTR)AllocADsMem( cbBuffSize );
    if( !pwszPathBuffer )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    
    ZeroMemory( pwszPathBuffer, cbBuffSize );
    
    //
    // Build the metabase path for the child
    //
    wcscpy( pwszPathBuffer, _pszMetaBasePath );
    
    dwLen = wcslen( pwszPathBuffer );
    ADsAssert( dwLen );

    if( pwszPathBuffer[dwLen - 1] != L'/' )
    {
        pwszPathBuffer[dwLen] = L'/';
    }
    wcscat( pwszPathBuffer, RelativeChildPath );

    //
    // Look for the closest path in the metabase to our child
    //
    bFound = FALSE;
    
    pch = wcsrchr( pwszPathBuffer, L'/' );
    if (pch != NULL)
      *pch = 0;
    
    while( !bFound && 0 != wcscmp( pwszPathBuffer, _pszMetaBasePath ) )
    {
        hr = MetaBaseDetectKey( _pAdminBase, pwszPathBuffer );
        if( SUCCEEDED(hr) )
        {
            bFound = TRUE;
        }
        else if( ERROR_PATH_NOT_FOUND == HRESULT_CODE(hr) )
        {
            // Continue up the path buffer
            pch = wcsrchr( pwszPathBuffer, L'/' );
            if (pch != NULL)
               *pch = 0;

            hr = S_FALSE;
        }
        else
        {
            BAIL_ON_FAILURE( hr );
        }
    }

    //
    // Get pParentClass
    //
    if( bFound )
    {
        // Get the key type from the node
        hr = MetaBaseGetADsClass( _pAdminBase, 
                                  pwszPathBuffer, 
                                  _pSchema, 
                                  wszParentClassBuffer,
                                  MAX_PATH
                                  );
        BAIL_ON_FAILURE( hr );
    }
    else
    {
        // Use our own key type
        wcscpy( wszParentClassBuffer, _ADsClass );
    }

    hr = ADsAllocString( wszParentClassBuffer, pParentClass );
    BAIL_ON_FAILURE( hr );

    //
    // Get pParentPath
    //
    wcscpy( pwszPathBuffer, _ADsPath );
    wcscat( pwszPathBuffer, L"/" );
    wcscat( pwszPathBuffer, RelativeChildPath );
    pch = wcsrchr( pwszPathBuffer, L'/' );
    if (pch != NULL)
      *pch = 0;

    hr = ADsAllocString( pwszPathBuffer, pParentPath );
    BAIL_ON_FAILURE( hr );
    
error:

    if( pwszPathBuffer )
    {
        FreeADsMem( pwszPathBuffer );
    }

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cipsec.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cipsec.cxx
//
//  Contents:  IPSecurity object
//
//  History:   21-4-97     SophiaC    Created.
//
//----------------------------------------------------------------------------

#include "iis.hxx"
#pragma hdrstop

#define _RDNS_STANDALONE

#define ILIST_DENY      0
#define ILIST_GRANT     1

#define ITYPE_DNS       0
#define ITYPE_IP        1

#define SENTINEL_ADDR   "0.0.0.0, 255.255.255.255"
#define DEFAULT_MASK    "255.255.255.255"

LPBYTE
GetIp(
    LPSTR               pArg
    );

BOOL
FreeIp(
    LPBYTE              pIp
    );

//  Class CIPSecurity

DEFINE_Simple_IDispatch_Implementation(CIPSecurity)

CIPSecurity::CIPSecurity():
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CIPSecurity);
}

HRESULT
CIPSecurity::CreateIPSecurity(
    REFIID riid,
    void **ppvObj
    )
{
    CIPSecurity FAR * pIPSecurity = NULL;
    HRESULT hr = S_OK;

    hr = AllocateIPSecurityObject(&pIPSecurity);
    BAIL_ON_FAILURE(hr);

    hr = pIPSecurity->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pIPSecurity->Release();

    RRETURN(hr);

error:
    delete pIPSecurity;

    RRETURN(hr);

}


CIPSecurity::~CIPSecurity( )
{
    delete _pDispMgr;

    _AddrChk.UnbindCheckList();
}

STDMETHODIMP
CIPSecurity::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IISIPSecurity FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IISIPSecurity))
    {
        *ppv = (IISIPSecurity FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IISIPSecurity FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


HRESULT
CIPSecurity::InitFromBinaryBlob(
    LPBYTE pByte,
    DWORD dwLength
    )
{

    DWORD dwDenyEntries, dwGrantEntries;
    LPBYTE pBuffer = NULL;

    if (pByte && dwLength) {
        pBuffer = (LPBYTE) AllocADsMem(dwLength);

        if (!pBuffer) {
            return(E_OUTOFMEMORY);
        }

        memcpy(pBuffer, pByte, dwLength);
    }

    //
    // Length of 0 is the default value for empty blob
    //

    if ((pByte == NULL) || (dwLength == 0)) {
        _AddrChk.BindCheckList(NULL, 0);
    } else {
        _AddrChk.BindCheckList(pBuffer, dwLength);
    }

    dwDenyEntries = _AddrChk.GetNbAddr(FALSE) +
                    _AddrChk.GetNbName(FALSE);

    dwGrantEntries = _AddrChk.GetNbAddr(TRUE) +
                     _AddrChk.GetNbName(TRUE);

    if (dwGrantEntries > dwDenyEntries) {
        _bGrantByDefault = FALSE;

        // 
        // check if entry is a sentinel address
        // 

        if (dwGrantEntries == 1 && _AddrChk.GetNbAddr(TRUE) == 1) {
            DWORD dwFlags;
            LPBYTE pM;
            LPBYTE pA;
            CHAR achE[80];

            if (_AddrChk.GetAddr(TRUE, 0, &dwFlags, &pM, &pA) == TRUE) {

	            wsprintfA( (LPSTR)achE, "%d.%d.%d.%d, %d.%d.%d.%d",
    	            pA[3], pA[2], pA[1], pA[0],
        	        pM[3], pM[2], pM[1], pM[0] );
			}

            if (strcmp(achE, SENTINEL_ADDR) == 0) {
                _AddrChk.DeleteAllAddr(TRUE);
            }
        }
    }
    else {
        _bGrantByDefault = TRUE;
    }

    return S_OK;
}

HRESULT
CIPSecurity::CopyIPSecurity(
    LPBYTE *ppByte,
    PDWORD pdwLength
    )
{
    //
    // Remove the other list if default by grant
    //

    _AddrChk.DeleteAllAddr(_bGrantByDefault);
    _AddrChk.DeleteAllName(_bGrantByDefault);

    //
    // List is empty.  If deny by default is on, create
    // a dummy sentinel entry to grant access to single
    // address 0.0.0.0, otherwise we're ok.
    //

    if (!_bGrantByDefault && 
        !_AddrChk.GetNbAddr(TRUE) &&
        !_AddrChk.GetNbName(TRUE)) {

        BYTE bMask[4] = { 0xff, 0xff, 0xff, 0xff };
        BYTE bIp[4] = { 0, 0, 0, 0 };

        _AddrChk.AddAddr(
            ILIST_GRANT,
            AF_INET,
            bMask,
            bIp
            ); 
    }

    *ppByte = _AddrChk.QueryCheckListPtr();
    *pdwLength = _AddrChk.QueryCheckListSize();

    return S_OK;
}


HRESULT
CIPSecurity::AllocateIPSecurityObject(
    CIPSecurity ** ppIPSecurity
    )
{
    CIPSecurity FAR * pIPSecurity = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pIPSecurity = new CIPSecurity();
    if (pIPSecurity == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISOle,
                IID_IISIPSecurity,
                (IISIPSecurity *)pIPSecurity,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pIPSecurity->_pDispMgr = pDispMgr;
    *ppIPSecurity = pIPSecurity;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CIPSecurity::get_IPDeny(THIS_ VARIANT FAR * retval)
{
    long i = 0;
    HRESULT hr = S_OK;
    DWORD dwNumEntries = _AddrChk.GetNbAddr(FALSE);

    VariantInit(retval);

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumEntries;   // number of entries

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumEntries; i++ )
    {
        VARIANT v;
        LPBYTE pByte = NULL;
        DWORD dwStatus;

        VariantInit(&v);

        v.vt = VT_BSTR;
        GetEntry(ITYPE_IP, ILIST_DENY, &pByte, i);

        hr = ADsAllocString((LPWSTR)pByte, &(v.bstrVal));

        if (pByte) {
            FreeADsMem(pByte);
        }
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(retval) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(retval) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}


STDMETHODIMP
CIPSecurity::put_IPDeny(THIS_ VARIANT pVarIPDeny)
{
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vVar;
    DWORD dwNumValues;
    DWORD dwStatus;
    DWORD i;
    LPSTR pszAnsiName = NULL;
    HRESULT hr = S_OK;

    VariantInit(&vVar);
    VariantCopyInd(&vVar, &pVarIPDeny);

    if ((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar)) {
        hr  = ConvertArrayToVariantArray(
                    vVar,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;
    } 
    else {

        dwNumValues = 1;
        pvProp = &pVarIPDeny;
    }

    _AddrChk.DeleteAllAddr(FALSE);

    for (i = 0; i < dwNumValues; i++ ) {
        dwStatus = AllocAnsi(
                        (LPWSTR)pvProp->bstrVal,
                        &pszAnsiName
                        );

        if (dwStatus) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwStatus));
        }

        if (pszAnsiName) {
            if (!AddToList(ITYPE_IP, ILIST_DENY, pszAnsiName)) {
                hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
            }
            FreeAnsi(pszAnsiName);
            pszAnsiName = NULL;
            BAIL_ON_FAILURE(hr);
        }

        pvProp++;
    }

error:

    if (pVarArray) {

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    VariantClear(&vVar);

    RRETURN(hr);
}

STDMETHODIMP
CIPSecurity::get_IPGrant(THIS_ VARIANT FAR * retval)
{
    long i = 0;
    HRESULT hr = S_OK;
    DWORD dwNumEntries = _AddrChk.GetNbAddr(TRUE);

    VariantInit(retval);

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumEntries;   // number of entries

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumEntries; i++ )
    {
        VARIANT v;
        LPBYTE pByte = NULL;
        DWORD dwStatus;
        LPWSTR pszUnicode;

        VariantInit(&v);
        v.vt = VT_BSTR;

        GetEntry(ITYPE_IP, ILIST_GRANT, &pByte, i);

        hr = ADsAllocString((LPWSTR)pByte, &(v.bstrVal));

        if (pByte) {
            FreeADsMem(pByte);
        }

        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(retval) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(retval) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}

STDMETHODIMP
CIPSecurity::put_IPGrant(THIS_ VARIANT pVarIPGrant)
{
    HRESULT hr = S_OK;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vVar;
    DWORD dwNumValues;
    DWORD dwStatus;
    DWORD i;
    LPSTR pszAnsiName = NULL;

    VariantInit(&vVar);
    VariantCopyInd(&vVar, &pVarIPGrant);

    if ((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar)) {
        hr  = ConvertArrayToVariantArray(
                    vVar,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;
    } 
    else {

        dwNumValues = 1;
        pvProp = &pVarIPGrant;
    }

    _AddrChk.DeleteAllAddr(TRUE);

    for (i = 0; i < dwNumValues; i++ ) {
        dwStatus = AllocAnsi(
                        (LPWSTR)pvProp->bstrVal,
                        &pszAnsiName
                        );

        if (dwStatus) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwStatus));
        }

        if (pszAnsiName) {
            if (!AddToList(ITYPE_IP, ILIST_GRANT, pszAnsiName) ) {
                hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
            }
            FreeAnsi(pszAnsiName);
            pszAnsiName = NULL;
            BAIL_ON_FAILURE(hr);
        }

        pvProp++;
    }

error:

    if (pVarArray) {

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    VariantClear(&vVar);

    RRETURN(hr);
}


STDMETHODIMP
CIPSecurity::get_DomainDeny(THIS_ VARIANT FAR * retval)
{
    long i = 0;
    HRESULT hr = S_OK;
    DWORD dwNumEntries = _AddrChk.GetNbName(FALSE);

    VariantInit(retval);

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumEntries;   // number of entries

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumEntries; i++ )
    {
        VARIANT v;
        LPBYTE pByte = NULL;
        DWORD dwStatus;

        VariantInit(&v);
        v.vt = VT_BSTR;

        GetEntry(ITYPE_DNS, ILIST_DENY, &pByte, i);

        hr = ADsAllocString((LPWSTR)pByte, &(v.bstrVal));

        if (pByte) {
            FreeADsMem(pByte);
        }

        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(retval) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(retval) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}

STDMETHODIMP
CIPSecurity::put_DomainDeny(THIS_ VARIANT pVarDomainDeny)
{
    HRESULT hr = S_OK;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vVar;
    DWORD dwNumValues;
    DWORD dwStatus;
    DWORD i;
    LPSTR pszAnsiName = NULL;

    VariantInit(&vVar);
    VariantCopyInd(&vVar, &pVarDomainDeny);

    if ((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar)) {
        hr  = ConvertArrayToVariantArray(
                    vVar,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;
    } 
    else {

        dwNumValues = 1;
        pvProp = &pVarDomainDeny;
    }

    _AddrChk.DeleteAllName(FALSE);

    for (i = 0; i < dwNumValues; i++ ) {
        dwStatus = AllocAnsi(
                        (LPWSTR)pvProp->bstrVal,
                        &pszAnsiName
                        );

        if (dwStatus) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwStatus));
        }

        if (pszAnsiName) {
            if (!AddToList(ITYPE_DNS, ILIST_DENY, pszAnsiName)) {
                hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
            }
            FreeAnsi(pszAnsiName);
            pszAnsiName = NULL;
            BAIL_ON_FAILURE(hr);
        }

        pvProp++;
    }

error:

    if (pVarArray) {

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    VariantClear(&vVar);

    RRETURN(hr);
}


STDMETHODIMP
CIPSecurity::get_DomainGrant(THIS_ VARIANT FAR * retval)
{
    long i = 0;
    HRESULT hr = S_OK;
    DWORD dwNumEntries = _AddrChk.GetNbName(TRUE);

    VariantInit(retval);

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumEntries;   // number of entries

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumEntries; i++ )
    {
        VARIANT v;
        LPBYTE pByte = NULL;
        DWORD dwStatus;

        VariantInit(&v);
        v.vt = VT_BSTR;

        GetEntry(ITYPE_DNS, ILIST_GRANT, &pByte, i);

        hr = ADsAllocString((LPWSTR)pByte, &(v.bstrVal));

        if (pByte) {
            FreeADsMem(pByte);
        }

        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(retval) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(retval) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}

STDMETHODIMP
CIPSecurity::put_DomainGrant(THIS_ VARIANT pVarDomainGrant)
{
    HRESULT hr = S_OK;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vVar;
    DWORD dwNumValues;
    DWORD dwStatus;
    DWORD i;
    LPSTR pszAnsiName = NULL;

    VariantInit(&vVar);
    VariantCopyInd(&vVar, &pVarDomainGrant);

    if ((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar)) {
        hr  = ConvertArrayToVariantArray(
                    vVar,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;
    } 
    else {

        dwNumValues = 1;
        pvProp = &pVarDomainGrant;
    }

    _AddrChk.DeleteAllName(TRUE);

    for (i = 0; i < dwNumValues; i++ ) {
        dwStatus = AllocAnsi(
                        (LPWSTR)pvProp->bstrVal,
                        &pszAnsiName
                        );

        if (dwStatus) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwStatus));
        }

        if (pszAnsiName) {

            if (!AddToList(ITYPE_DNS, ILIST_GRANT, pszAnsiName)) {
                hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
            }

            FreeAnsi(pszAnsiName);
            pszAnsiName = NULL;
            BAIL_ON_FAILURE(hr);
        }

        pvProp++;
    }

error:

    if (pVarArray) {

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    VariantClear(&vVar);

    RRETURN(hr);
}



STDMETHODIMP
CIPSecurity::get_GrantByDefault(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bGrantByDefault ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CIPSecurity::put_GrantByDefault(THIS_ VARIANT_BOOL bGrantByDefault)
{
    _bGrantByDefault = bGrantByDefault ? TRUE : FALSE;
    RRETURN(S_OK);
}

/* INTRINSA suppress=null_pointers */
BOOL
CIPSecurity::AddToList(
    int                 iType,
    int                 iList,
    LPSTR               pArg
    )
{
    BOOL        fSt;
    LPBYTE      pMask = NULL;
    LPBYTE      pAddr = NULL;
    DWORD       dwFlags = 0;
    int *               piArg;

    switch ( iType )
    {
        case ITYPE_IP:
            if (pAddr = GetIp( strtok(pArg,",") )) 
            {
                pMask = GetIp( pArg+strlen(pArg)+1 );
                if (!pMask) {
                    pMask = GetIp(DEFAULT_MASK);
                }
                fSt = _AddrChk.AddAddr( iList, AF_INET, pMask, pAddr );
            }
            else
            {
                fSt = FALSE;
            }
            FreeIp( pMask );
            FreeIp( pAddr );
            return fSt;

        case ITYPE_DNS:
            if ( !strncmp( pArg, "*.", 2 ) )
            {
                pArg += 2;
            }
            else
            {
                dwFlags |= DNSLIST_FLAG_NOSUBDOMAIN;
            }
            return _AddrChk.AddName( iList, pArg, dwFlags );
            break;
    }

    return FALSE;
}


BOOL
CIPSecurity::GetEntry(
    int                 iType,
    int                 iList,
    LPBYTE            * ppbyte,
    int                 dwEntry
    )
{
    UINT    i;
    UINT    x;
    DWORD   dwF;
    DWORD   dwStatus;
    BOOL    fSt = FALSE;
    LPWSTR  pszStr = NULL;

    *ppbyte = NULL;

    switch ( iType )
    {
        case ITYPE_IP:
            LPBYTE pM;
            LPBYTE pA;
            CHAR achE[80];

            fSt = _AddrChk.GetAddr( iList, dwEntry, &dwF, &pM, &pA );

            if (fSt) {
                wsprintfA( (LPSTR)achE, "%d.%d.%d.%d, %d.%d.%d.%d",
                    pA[0], pA[1], pA[2], pA[3],
                    pM[0], pM[1], pM[2], pM[3] );

                dwStatus = AllocUnicode(
                                (LPSTR)achE,
                                &pszStr
                                );
                if (dwStatus == ERROR_SUCCESS) {
                    *ppbyte = (LPBYTE) pszStr;
                }
                else {
                    fSt = FALSE;
                }
            }
            break;

        case ITYPE_DNS:
            LPSTR pN;
            DWORD dwLen;
            UINT  err;

            // Use break to exit on error condition

            fSt = _AddrChk.GetName( iList, dwEntry, &pN, &dwF );
            if( !fSt )
            {
                break;
            }

            dwLen = strlen(pN) + 1;

            // pszStr is the working copy of our memory
            // *ppbyte is the data to be returned
            
            if ( dwF & DNSLIST_FLAG_NOSUBDOMAIN )
            {
                pszStr = (LPWSTR) AllocADsMem(dwLen*sizeof(WCHAR));
                if( !pszStr )
                {
                    fSt = FALSE;
                    break;
                }
                *ppbyte = (LPBYTE)pszStr;
            }
            else 
            {
                // In this case we have a subdomain restriction, so
                // we want to pre-pend "*." to the string.
                pszStr = (LPWSTR) AllocADsMem((dwLen+2)*sizeof(WCHAR));
                if( !pszStr )
                {
                    fSt = FALSE;
                    break;
                }
                
                // Save the address to return
                *ppbyte = (LPBYTE)pszStr;

                wcscpy((LPWSTR)pszStr, L"*.");
                pszStr += wcslen(pszStr);

            }

            err = (UINT) !MultiByteToWideChar(CP_ACP,
                              MB_PRECOMPOSED,
                              pN,
                              dwLen,
                              pszStr,
                              dwLen);
            if (err)
            {
                FreeADsMem( *ppbyte );
                *ppbyte = NULL;
                fSt = FALSE;
                break;
            }

            // Final break
            break;
    }

    return fSt;
}


LPBYTE
GetIp(
    LPSTR               pArg
    )
{
    if (pArg)
    {
        LPBYTE p;
        if ( p = (LPBYTE)LocalAlloc( LMEM_FIXED, 4 ) )
        {
            int p0, p1, p2, p3;
            if ( sscanf( pArg, "%d.%d.%d.%d", &p0, &p1, &p2, &p3 ) == 4 )
            {
                //
                // network byte order
                //
                 
                p[3] = (BYTE)(p3 & 0xFF);
                p[2] = (BYTE)(p2 & 0xFF);
                p[1] = (BYTE)(p1 & 0xFF);
                p[0] = (BYTE)(p0 & 0xFF);
                return p;
            }
            LocalFree( p );
            return NULL;
        }
    }

    return NULL;
}


BOOL
FreeIp(
    LPBYTE              pIp
    )
{
    if ( pIp )
    {
        LocalFree( pIp );
    }

    return TRUE;
}

typedef
VOID
(* PFN_SCHED_CALLBACK)(
    VOID * pContext
    );

dllexp
DWORD
ScheduleWorkItem(
    PFN_SCHED_CALLBACK pfnCallback,
    PVOID              pContext,
    DWORD              msecTimeInterval,
    BOOL               fPeriodic = FALSE
    )
{
    return 0;
}

dllexp
BOOL
RemoveWorkItem(
    DWORD  pdwCookie
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cmimecf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  cmimecf.cxx
//
//  Contents:  MimeType Object Class Factory Code
//
//  History:   04-01-97     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISMimeTypeCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISMimeTypeCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CMimeType::CreateMimeType(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cnamcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  cnamcf.cxx
//
//  Contents:  Windows NT 4.0 Namespace Object Class Factory Code
//
//             CIISNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CIISNamespaceCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISNamespaceCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;
    CCredentials Credentials;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISNamespace::CreateNamespace(
                L"ADs:",
                L"IIS:",
                Credentials,
                ADS_OBJECT_BOUND,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\common.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  common.cxx
//
//  Contents:  Microsoft ADs IIS Common routines 
//
//  History:   28-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"

extern SERVER_CACHE * g_pServerCache;
extern WIN32_CRITSEC * g_pGlobalLock;

#pragma hdrstop

FILTERS Filters[] = {
                    {L"user", IIS_USER_ID},
                    {L"group", IIS_GROUP_ID},
                    {L"queue", IIS_PRINTER_ID},
                    {L"domain", IIS_DOMAIN_ID},
                    {L"computer", IIS_COMPUTER_ID},
                    {L"service", IIS_SERVICE_ID},
                    {L"fileservice", IIS_FILESERVICE_ID},
                    {L"fileshare", IIS_FILESHARE_ID},
                    {L"class", IIS_CLASS_ID},
                    {L"functionalset", IIS_FUNCTIONALSET_ID},
                    {L"syntax", IIS_SYNTAX_ID},
                    {L"property", IIS_PROPERTY_ID},
                    {L"tree", IIS_TREE_ID},
                    {L"Organizational Unit", IIS_OU_ID},
                    {L"Organization", IIS_O_ID},
                    {L"Locality", IIS_LOCALITY_ID}
                  };

#define MAX_FILTERS  (sizeof(Filters)/sizeof(FILTERS))

#define DEFAULT_TIMEOUT_VALUE                    30000

PFILTERS  gpFilters = Filters;
DWORD gdwMaxFilters = MAX_FILTERS;
extern WCHAR * szProviderName;


//+------------------------------------------------------------------------
//
//  Class:      Common
//
//  Purpose:    Contains Winnt routines and properties that are common to
//              all Winnt objects. Winnt objects get the routines and
//              properties through C++ inheritance.
//
//-------------------------------------------------------------------------


HRESULT
BuildADsPath(
    BSTR Parent,
    BSTR Name,
    BSTR *pADsPath
    )
{
    LPWSTR lpADsPath = NULL;
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;
    DWORD dwLen = 0;

    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent && Name);
    ADsAssert(pADsPath);


    //
    // Special case the Namespace object; if
    // the parent is L"ADs:", then Name = ADsPath
    //

    if (!_wcsicmp(Parent, L"ADs:")) {
        RRETURN(ADsAllocString( Name, pADsPath));
    }

    //
    // Allocate the right side buffer
    // 2 for // + a buffer of MAX_PATH
    //
    dwLen = wcslen(Parent) + wcslen(Name) + 2 + MAX_PATH;

    lpADsPath = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));
    if (!lpADsPath) {
        RRETURN(E_OUTOFMEMORY);
    }



    //
    // The rest of the cases we expect valid data,
    // Path, Parent and Name are read-only, the end-user
    // cannot modify this data
    //

    //
    // For the first object, the domain object we do not add
    // the first backslash; so we examine that the parent is
    // L"WinNT:" and skip the slash otherwise we start with
    // the slash
    //

    wsprintf(ProviderName, L"%s:", szProviderName);

    wcscpy(lpADsPath, Parent);

    if (_wcsicmp(lpADsPath, ProviderName)) {
        wcscat(lpADsPath, L"/");
    }else {
        wcscat(lpADsPath, L"//");
    }
    wcscat(lpADsPath, Name);

    hr = ADsAllocString( lpADsPath, pADsPath);


    if (lpADsPath) {
        FreeADsMem(lpADsPath);
    }

    RRETURN(hr);
}

HRESULT
BuildSchemaPath(
    BSTR bstrADsPath,
    BSTR bstrClass,
    BSTR *pSchemaPath
    )
{
    WCHAR ADsSchema[MAX_PATH];
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(bstrADsPath);
    HRESULT hr = S_OK;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    wcscpy(ADsSchema, L"");
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    if (bstrClass && *bstrClass) {
        hr = ADsObject(&Lexer, pObjectInfo);
        BAIL_ON_FAILURE(hr);

        if (pObjectInfo->TreeName) {

            wsprintf(ADsSchema,L"%s://",pObjectInfo->ProviderName);
            wcscat(ADsSchema, pObjectInfo->TreeName);
            wcscat(ADsSchema,L"/schema/");
            wcscat(ADsSchema, bstrClass);

        }
    }

    hr = ADsAllocString( ADsSchema, pSchemaPath);

error:

    if (pObjectInfo) {

        FreeObjectInfo( pObjectInfo );
    }
    RRETURN(hr);
}



HRESULT
BuildADsGuid(
    REFCLSID clsid,
    BSTR *pADsClass
    )
{
    WCHAR ADsClass[MAX_PATH];

    StringFromGUID2(clsid, ADsClass, 256);

    RRETURN(ADsAllocString( ADsClass, pADsClass));
}


HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}


HRESULT
OpenAdminBaseKey(
    IN LPWSTR pszServerName,
    IN LPWSTR pszPathName,
    IN DWORD dwAccessType,
    IN OUT IMSAdminBase **ppAdminBase,
    OUT METADATA_HANDLE *phHandle
    )
{
    HRESULT hr;
    IMSAdminBase *pAdminBase = *ppAdminBase;
    METADATA_HANDLE RootHandle = NULL;
    DWORD dwThreadId;

    hr = pAdminBase->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                pszPathName,
                dwAccessType,
                DEFAULT_TIMEOUT_VALUE,
                &RootHandle
                );

    if (FAILED(hr)) {
        if ((HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE) ||
            ((HRESULT_CODE(hr) >= RPC_S_NO_CALL_ACTIVE) &&
             (HRESULT_CODE(hr) <= RPC_S_CALL_FAILED_DNE)) || 
            hr == RPC_E_DISCONNECTED) {

            SERVER_CACHE_ITEM * item = NULL;

            IMSAdminBase * pOldAdminBase = pAdminBase;

            //
            // RPC error, try to recover connection
            //

            hr = InitAdminBase(pszServerName, &pAdminBase);
            BAIL_ON_FAILURE(hr);

            *ppAdminBase = pAdminBase; 

            hr = pAdminBase->OpenKey(
                        METADATA_MASTER_ROOT_HANDLE,
                        pszPathName,
                        dwAccessType,
                        DEFAULT_TIMEOUT_VALUE,
                        &RootHandle
                        );

            //
            // update cache item
            //

            dwThreadId = GetCurrentThreadId();
            item = g_pServerCache->Find(pszServerName, dwThreadId);

            ASSERT(item != NULL);

            if (item != NULL)
            {
                UninitAdminBase(pOldAdminBase);
                item->UpdateAdminBase(pAdminBase, dwThreadId);
            }
        }
    }

error :

    if (FAILED(hr)) {

        if (pAdminBase && RootHandle) {
            pAdminBase->CloseKey(RootHandle);
        }
    }
    else {
        *phHandle = RootHandle;
    }

    RRETURN(hr);
}


VOID
CloseAdminBaseKey(
    IN IMSAdminBase *pAdminBase,
    IN METADATA_HANDLE hHandle
    )
{
    HRESULT hr;

    if (pAdminBase) {
        hr = pAdminBase->CloseKey(hHandle);
    }

    return;
}


HRESULT
MetaBaseGetAllData(
    IN IMSAdminBase *pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN LPWSTR pszIISPathName,
    IN DWORD dwMDAttributes,
    IN DWORD dwMDUserType,
    IN DWORD dwMDDataType,
    OUT PDWORD pdwMDNumDataEntries,
    OUT PDWORD pdwMDDataSetNumber,
    OUT LPBYTE * ppBuffer
    )
{

    LPBYTE pBuffer = NULL;
    HRESULT hr = S_OK;
    DWORD dwBufferSize = 0;
    DWORD dwReqdBufferSize = 0;

    hr = pAdminBase->GetAllData(
                        hObjHandle,
                        pszIISPathName,
                        dwMDAttributes,
                        dwMDUserType,
                        dwMDDataType,
                        pdwMDNumDataEntries,
                        pdwMDDataSetNumber,
                        dwBufferSize,
                        (LPBYTE)"",
                        &dwReqdBufferSize
                        );


    pBuffer = (LPBYTE) AllocADsMem(dwReqdBufferSize);

    if (!pBuffer) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwBufferSize = dwReqdBufferSize;

    hr = pAdminBase->GetAllData(
                        hObjHandle,
                        pszIISPathName,
                        dwMDAttributes,
                        dwMDUserType,
                        dwMDDataType,
                        pdwMDNumDataEntries,
                        pdwMDDataSetNumber,
                        dwBufferSize,
                        pBuffer,
                        &dwReqdBufferSize
                        );
    BAIL_ON_FAILURE(hr);


    *ppBuffer = pBuffer;


    RRETURN(hr);

error:


    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);
}



HRESULT
MetaBaseSetAllData(
    IN IMSAdminBase *pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN LPWSTR pszIISPathName,
    IN PMETADATA_RECORD pMetaDataArray,
    IN DWORD dwNumEntries
    )
{
    HRESULT hr = S_OK;
    PMETADATA_RECORD pTemp = NULL;
    METADATA_RECORD mdrMDData;
    DWORD i;

    //
    // Set each METADATA record one at a time
    //

    for (i = 0; i < dwNumEntries; i++) {

        pTemp = pMetaDataArray + i;

        mdrMDData.dwMDIdentifier = pTemp->dwMDIdentifier;
        mdrMDData.dwMDAttributes = pTemp->dwMDAttributes;
        mdrMDData.dwMDUserType = pTemp->dwMDUserType;
        mdrMDData.dwMDDataType = pTemp->dwMDDataType;
        mdrMDData.dwMDDataLen = pTemp->dwMDDataLen;
        mdrMDData.dwMDDataTag = pTemp->dwMDDataTag;
        mdrMDData.pbMDData = pTemp->pbMDData;

        hr = pAdminBase->SetData(
                hObjHandle,
                pszIISPathName,
                &mdrMDData
                );

        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}

HRESULT
MetaBaseDeleteObject(
    IN IMSAdminBase * pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN LPWSTR pszIISPathName
    )
{
    HRESULT hr = S_OK;


    hr = pAdminBase->DeleteKey(
             hObjHandle,
             pszIISPathName
             );

    RRETURN(hr);
}


HRESULT
MetaBaseCreateObject(
    IN IMSAdminBase * pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN LPWSTR pszIISPathName
    )
{
    HRESULT hr = S_OK;


    hr = pAdminBase->AddKey(
             hObjHandle,
             pszIISPathName
             );

    RRETURN(hr);
}

HRESULT
MetaBaseCopyObject(
    IN IMSAdminBase * pAdminBase,
    IN METADATA_HANDLE hSrcObjHandle,
    IN LPWSTR pszIISSrcPathName,
    IN METADATA_HANDLE hDestObjHandle,
    IN LPWSTR pszIISDestPathName
    )
{
    HRESULT hr = S_OK;

    hr = pAdminBase->CopyKey(
             hSrcObjHandle,
             pszIISSrcPathName,
             hDestObjHandle,
             pszIISDestPathName,
             TRUE,
             TRUE
             );

    RRETURN(hr);
}

HRESULT
MetaBaseMoveObject(
    IN IMSAdminBase * pAdminBase,
    IN METADATA_HANDLE hSrcObjHandle,
    IN LPWSTR pszIISSrcPathName,
    IN METADATA_HANDLE hDestObjHandle,
    IN LPWSTR pszIISDestPathName
    )
{
    HRESULT hr = S_OK;

    hr = pAdminBase->CopyKey(
             hSrcObjHandle,
             pszIISSrcPathName,
             hDestObjHandle,
             pszIISDestPathName,
             FALSE,
             FALSE
             );

    RRETURN(hr);
}

HRESULT
MetaBaseGetAdminACL(
    IN IMSAdminBase * pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN LPWSTR pszIISPathName,
    OUT LPBYTE *ppBuffer
    )
{
    HRESULT hr = S_OK;
    DWORD dwBufferSize = 0;
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = NULL;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_ADMIN_ACL,    // admin acl
                       METADATA_INHERIT,
                       IIS_MD_UT_FILE,
                       BINARY_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = pAdminBase->GetData(
             hObjHandle,
             pszIISPathName,
             &mdrMDData,
             &dwBufferSize
             );

    pBuffer = (LPBYTE) AllocADsMem(dwBufferSize);

    if (!pBuffer) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_ADMIN_ACL,    // admin acl
                       METADATA_INHERIT,
                       IIS_MD_UT_FILE,
                       BINARY_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = pAdminBase->GetData(
             hObjHandle,
             pszIISPathName,
             &mdrMDData,
             &dwBufferSize
             );

    BAIL_ON_FAILURE(hr);

    *ppBuffer = pBuffer;

    RRETURN(hr);

error:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);
}

HRESULT
MetaBaseDetectKey(
    IN IMSAdminBase *pAdminBase,
    IN LPCWSTR pszIISPathName
    )
{
    HRESULT   hr = S_OK;
    FILETIME  ft;

    hr = pAdminBase->GetLastChangeTime( METADATA_MASTER_ROOT_HANDLE,
                                        pszIISPathName,
                                        &ft,
                                        FALSE 
                                        );
    RRETURN(hr);
}

HRESULT
MetaBaseGetADsClass(
    IN  IMSAdminBase  *pAdminBase,
    IN  LPWSTR        pszIISPathName,
    IN  IIsSchema     *pSchema,
    OUT LPWSTR        pszDataBuffer,
    IN  DWORD         dwBufferLen
    )
/*++

Routine Description:

    Get the ADsClass from the metabase path.

Arguments:

    IN  pAdminBase      : the metabase
    IN  pszIISPathName  : the full metabase path (may be upcased)
    IN  pSchema         : schema against which to validate
    OUT pszDataBuffer   : the class name
    IN  dwBufferLen     : number of characters allocated for class name

Return Value:

--*/
{
    // CODEWORK - There are at least two other places that do essentially
    // the same thing. It should be possible to replace that code with a
    // call to this routine

    HRESULT         hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    METADATA_RECORD mdrData;
    DWORD           dwReqdBufferLen = 0;

    hr = pAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                              pszIISPathName,
                              METADATA_PERMISSION_READ,
                              DEFAULT_TIMEOUT_VALUE,
                              &hObjHandle
                              );
    BAIL_ON_FAILURE(hr);
    
    //
    // Find out Class Name
    //
    mdrData.dwMDIdentifier  = MD_KEY_TYPE;
    mdrData.dwMDDataType    = STRING_METADATA;
    mdrData.dwMDUserType    = ALL_METADATA;
    mdrData.dwMDAttributes  = METADATA_INHERIT;
    mdrData.dwMDDataLen     = dwBufferLen * sizeof(WCHAR);
    mdrData.pbMDData        = (PBYTE)pszDataBuffer;

    hr = pAdminBase->GetData(
                hObjHandle,
                L"",
                &mdrData,
                &dwReqdBufferLen
                );

    if (FAILED(hr)) 
    {
        if (hr == MD_ERROR_DATA_NOT_FOUND) 
        {
            //
            // If the key does not have a KeyType we will do our best
            // to guess. This is pretty bogus, but there is existing code
            // that depends on this behavior.
            //
            _wcsupr(pszIISPathName);
            if (wcsstr(pszIISPathName, L"W3SVC") != NULL)
            {
                wcscpy( pszDataBuffer, WEBDIR_CLASS_W );
            }
            else if (wcsstr(pszIISPathName, L"MSFTPSVC") != NULL)
            {
                wcscpy( pszDataBuffer, FTPVDIR_CLASS_W );
            }
            else 
            {
                wcscpy( pszDataBuffer, DEFAULT_SCHEMA_CLASS_W );
            }
            hr = S_FALSE;
        }
        else 
        {
            BAIL_ON_FAILURE(hr);
        }
    }
    else
    {
        hr = pSchema->ValidateClassName( pszDataBuffer );
        if (hr == E_ADS_UNKNOWN_OBJECT) 
        {
            wcscpy( pszDataBuffer, DEFAULT_SCHEMA_CLASS_W );
        }
    }

error:
    //
    // Close the handle now
    //
    if (hObjHandle) 
    {
        CloseAdminBaseKey(pAdminBase, hObjHandle);
        hObjHandle = NULL;
    }

    RRETURN(hr);
}

static HRESULT 
GetSchema(
    LPWSTR machineNameW, 
    IIsSchema **out
    ) 
/*++

Routine Description:

    Creates and initializes a new IIsSchema object.

Arguments:

Return Value:

Notes:
    
    This routine should only be used internally. If it is necessary
    to get a reference to the schema for the current machine, use
    InitServerInfo().

--*/
{
    IIsSchema *schema=NULL;
    HRESULT hr = S_OK;
    schema = new IIsSchema();

    if (schema) {
        hr = schema->InitSchema(machineNameW);
        if (FAILED(hr)) {
                delete schema;
                schema = 0;
                *out = 0;
                return hr;
        }
    }
    else {
        return E_OUTOFMEMORY;
    }
    *out = schema;
    return hr;
}



HRESULT
FreeMetaDataRecordArray(
    PMETADATA_RECORD pMetaDataArray,
    DWORD dwNumEntries
    )
{

    DWORD i;
    DWORD dwIISType; 
    PMETADATA_RECORD pMetaData;

    for (i = 0; i < dwNumEntries; i++ ) {
       pMetaData = pMetaDataArray + i;
       dwIISType = pMetaData->dwMDDataType;
    
       switch(dwIISType) {
       case DWORD_METADATA:
           break;

       case STRING_METADATA:
       case EXPANDSZ_METADATA:
           FreeADsStr((LPWSTR)pMetaData->pbMDData);
           break;

       case MULTISZ_METADATA:
       case BINARY_METADATA:
           FreeADsMem(pMetaData->pbMDData);
           break;

       default:
           break;
       }
    }

    FreeADsMem(pMetaDataArray);

    RRETURN(S_OK);
}




HRESULT
InitAdminBase(
    IN LPWSTR pszServerName,
    OUT IMSAdminBase **ppAdminBase
    )
{
    HRESULT hr = S_OK;

    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IMSAdminBase * pAdminBase = NULL;
    IMSAdminBase * pAdminBaseT = NULL;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (pszServerName == NULL || _wcsicmp(pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName =  pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    hr = CoGetClassObject(
                CLSID_MSAdminBase,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IMSAdminBase,
                (void **) &pAdminBaseT
                );
    BAIL_ON_FAILURE(hr);

	hr = pAdminBaseT->UnmarshalInterface((IMSAdminBaseW **)&pAdminBase);
    pAdminBaseT->Release();
    pAdminBaseT = NULL;
	BAIL_ON_FAILURE(hr);
    *ppAdminBase = pAdminBase;

error:

    if (pcsfFactory) {
        pcsfFactory->Release();
    }

    RRETURN(hr);
}

VOID
UninitAdminBase(
    IN IMSAdminBase * pAdminBase
    )
{
    if (pAdminBase != NULL) {
        pAdminBase->Release();
    }
}

HRESULT
InitServerInfo(
    IN LPWSTR pszServerName,
    OUT IMSAdminBase ** ppObject,
    OUT IIsSchema **ppSchema
    )
{
    HRESULT hr = S_OK;
    IMSAdminBase * pAdminBase = NULL;
    IIsSchema * pSchema = NULL;
    SERVER_CACHE_ITEM * item;
    BOOL Success;
    DWORD dwThreadId;

    ASSERT(g_pServerCache != NULL);

    //
    // We'll return the localhost machine config to the users if 
    // pszServerName == NULL, e.g. IIS:
    //

    if (pszServerName == NULL) {
        pszServerName = L"Localhost";
    }

    dwThreadId = GetCurrentThreadId();

    if ((item = g_pServerCache->Find(pszServerName, dwThreadId)) == NULL) {

        //
        // get pAdminBase and pSchema
        //

        hr = InitAdminBase(pszServerName, &pAdminBase);
        BAIL_ON_FAILURE(hr);

        hr = GetSchema(pszServerName, &pSchema);

        if( ERROR_PATH_NOT_FOUND == HRESULT_CODE(hr) ||
            MD_ERROR_DATA_NOT_FOUND == hr
            )
        {
            // Return custom error.
            hr = MD_ERROR_IISAO_INVALID_SCHEMA;
        }
        BAIL_ON_FAILURE(hr);

        item = new SERVER_CACHE_ITEM(pszServerName,
                                     pAdminBase,
                                     pSchema,
                                     dwThreadId,
                                     Success);

        if (item == NULL || !Success) {
            if (item != NULL) {
                delete pSchema;
                UninitAdminBase(pAdminBase);
                delete item;
            }
            RRETURN(E_OUTOFMEMORY); // OUT_OF_MEMORY;
        }

        if (g_pServerCache->Insert(item) == FALSE) {
            delete pSchema;
            UninitAdminBase(pAdminBase);
            delete item;
            RRETURN(E_OUTOFMEMORY); // OUT_OF_MEMORY;
        }
    }

    *ppSchema = item->pSchema;
    *ppObject = item->pAdminBase;

error :

    RRETURN(hr);

}

HRESULT
MetaBaseGetDataPaths(
    IN IMSAdminBase *pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN DWORD dwMDMetaID,
    OUT LPBYTE * ppBuffer
    )
{

    LPBYTE pBuffer = NULL;
    HRESULT hr = S_OK;
    DWORD dwBufferSize = 0;
    DWORD dwReqdBufferSize = 0;

    hr = pAdminBase->GetDataPaths(
                        hObjHandle,
                        (LPWSTR)L"",
                        dwMDMetaID,
                        ALL_METADATA,
                        dwBufferSize,
                        (LPWSTR)L"",
                        &dwReqdBufferSize
                        );


    pBuffer = (LPBYTE) AllocADsMem(dwReqdBufferSize*sizeof(WCHAR));

    if (!pBuffer) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwBufferSize = dwReqdBufferSize;

    hr = pAdminBase->GetDataPaths(
                        hObjHandle,
                        (LPWSTR)L"",
                        dwMDMetaID,
                        ALL_METADATA,
                        dwBufferSize,
                        (LPWSTR)pBuffer,
                        &dwReqdBufferSize
                        );
    BAIL_ON_FAILURE(hr);

    *ppBuffer = pBuffer;

    RRETURN(hr);

error:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);
}


HRESULT
MakeVariantFromStringArray(
    LPWSTR pszStr,
    LPWSTR pszList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    LPWSTR pszStrList;
    WCHAR wchPath[MAX_PATH];


    if  (pszList != NULL)
    {
        long nCount = 0;
        long i = 0;
        pszStrList = pszList;

        if (*pszStrList == L'\0') {
            nCount = 1;
            pszStrList++;
        }

        while (*pszStrList != L'\0') {
            while (*pszStrList != L'\0') {
                pszStrList++;
            }
            nCount++;
            pszStrList++;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszStrList = pszList;
        for (i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            if (pszStr) {
                wcscpy((LPWSTR)wchPath, pszStr);
                wcscat((LPWSTR)wchPath, pszStrList);
                hr = ADsAllocString((LPWSTR)wchPath, &(V_BSTR(&v)));
            }
            else {
                hr = ADsAllocString( pszStrList, &(V_BSTR(&v)));
            }

            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList, &i, &v );

            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszStrList += wcslen(pszStrList) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    return S_OK;

error:

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}

HRESULT
MakeVariantFromPathArray(
    LPWSTR pszStr,
    LPWSTR pszList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    LPWSTR pszStrList;

    LPWSTR pszConcatBuffer = NULL;
    DWORD  cbConcatBuffer = 0;
    DWORD  cbRequiredConcatBuffer = 0;
    DWORD  nStrLen = 0;
    DWORD  nPathStrLen = 0;

    if  (pszList != NULL)
    {
        //
        // Count strings in pszList
        //
        long nCount = 0;
        long i = 0;
        pszStrList = pszList;
        while (*pszStrList != L'\0') {
            while (*pszStrList != L'\0') {
                pszStrList++;
            }
            nCount++;
            pszStrList++;
        }

        //
        // Allocate output array
        //
        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Prepare to copy our values from pszList to aList
        //
        if( pszStr )
        {
            nStrLen = wcslen( pszStr );
        }

        pszStrList = pszList;
        while ( *pszStrList != L'\0' )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            if (pszStr) 
            {
                //
                // Reallocate our string buffer. Since the strings are 
                // generally increasing in size, we'll allocate more space 
                // than we need so we don't have to reallocate every time.
                //
                nPathStrLen = wcslen(pszStrList);
                cbRequiredConcatBuffer = ( nStrLen + nPathStrLen + 1 )
                                         * sizeof(WCHAR);
                if( cbRequiredConcatBuffer > cbConcatBuffer )
                {
                    pszConcatBuffer = (LPWSTR)ReallocADsMem( 
                                           pszConcatBuffer,
                                           cbConcatBuffer,
                                           2 * cbRequiredConcatBuffer 
                                           );
                    if( pszConcatBuffer == NULL )
                    {
                        hr = E_OUTOFMEMORY;
                        BAIL_ON_FAILURE(hr);
                    }
                    if( cbConcatBuffer == 0 )
                    {
                        // This is our first time through.
                        wcscpy(pszConcatBuffer, pszStr);
                    }
                    cbConcatBuffer = 2 * cbRequiredConcatBuffer;
                }

                //
                // Copy the returned value into the buffer.
                //
                wcscpy(pszConcatBuffer + nStrLen, pszStrList);
               
                if (pszConcatBuffer[nStrLen + nPathStrLen - 1] == L'/') 
                {
                    pszConcatBuffer[nStrLen + nPathStrLen - 1] = L'\0';
                }

                hr = ADsAllocString(pszConcatBuffer, &(V_BSTR(&v)));
            }
            else {
                hr = ADsAllocString( pszStrList, &(V_BSTR(&v)));
            }

            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList, &i, &v );

            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszStrList += wcslen(pszStrList) + 1;
            i++;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    if( pszConcatBuffer )
    {
        FreeADsMem( pszConcatBuffer );
    }

    return S_OK;

error:

    if( pszConcatBuffer )
    {
        FreeADsMem( pszConcatBuffer );
    }

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}

HRESULT
InitWamAdmin(
    IN LPWSTR pszServerName,
    OUT IWamAdmin2 **ppWamAdmin
    )
{
    HRESULT hr = S_OK;

    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IWamAdmin2 * pWamAdmin = NULL;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (pszServerName == NULL || _wcsicmp(pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName =  pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    hr = CoGetClassObject(
                CLSID_WamAdmin,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IWamAdmin2,
                (void **) &pWamAdmin
                );
    BAIL_ON_FAILURE(hr);

    *ppWamAdmin = pWamAdmin;

error:

    if (pcsfFactory) {
        pcsfFactory->Release();
    }

    RRETURN(hr);
}


VOID
UninitWamAdmin(
    IN IWamAdmin2 *pWamAdmin
    )
{
    if (pWamAdmin != NULL) {
        pWamAdmin->Release();
    }
}


HRESULT
ConvertArrayToVariantArray(
    VARIANT varSafeArray,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    VARIANT * pVarArray = NULL;
    SAFEARRAY * pArray = NULL;

    *pdwNumVariants = 0;
    *ppVarArray  = 0;

    if(!(V_ISARRAY(&varSafeArray)))
       RRETURN(E_FAIL);

    //
    // This handles by-ref and regular SafeArrays.
    //

    if (V_VT(&varSafeArray) & VT_BYREF)
        pArray = *(V_ARRAYREF(&varSafeArray));
    else
        pArray = V_ARRAY(&varSafeArray);


    //
    // Check that there is only one dimension in this array
    //
    if (pArray && pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (!pArray ||  
        ( pArray->rgsabound[0].cElements == 0) ) {

        dwNumVariants = 1;

        pVarArray = (PVARIANT)AllocADsMem(
                                    sizeof(VARIANT)*dwNumVariants
                                    );
        if (!pVarArray) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit(pVarArray);
        pVarArray->vt = VT_BSTR;
        pVarArray->bstrVal = NULL;
       
    } 
    else {  

        //
        // We know that this is a valid single dimension array
        //

        hr = SafeArrayGetLBound(pArray,
                                1,
                                (long FAR *)&dwSLBound
                                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayGetUBound(pArray,
                                1,
                                (long FAR *)&dwSUBound
                                );
        BAIL_ON_FAILURE(hr);

        dwNumVariants = dwSUBound - dwSLBound + 1;
        pVarArray = (PVARIANT)AllocADsMem(
                                    sizeof(VARIANT)*dwNumVariants
                                    );
        if (!pVarArray) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        for (i = dwSLBound; i <= dwSUBound; i++) {
    
            VariantInit(pVarArray + i);
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    (pVarArray + i)
                                    );
            CONTINUE_ON_FAILURE(hr);
        }
    }

    *ppVarArray = pVarArray;
    *pdwNumVariants = dwNumVariants;

error:

    RRETURN(hr);
}


//
// Property helper functions
//
//

#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);


HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( ppDestStringProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( plDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}


HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pfDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pvDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
MetaBaseGetStringData(
    IN IMSAdminBase * pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN LPWSTR pszIISPathName,
    IN DWORD  dwMetaId,
    OUT LPBYTE *ppBuffer
    )
{
    HRESULT hr = S_OK;
    DWORD dwBufferSize = 0;
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = NULL;

    MD_SET_DATA_RECORD(&mdrMDData,
                       dwMetaId, 
                       METADATA_NO_ATTRIBUTES,
                       ALL_METADATA,
                       STRING_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = pAdminBase->GetData(
             hObjHandle,
             pszIISPathName,
             &mdrMDData,
             &dwBufferSize
             );

    pBuffer = (LPBYTE) AllocADsMem(dwBufferSize);

    if (!pBuffer) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    MD_SET_DATA_RECORD(&mdrMDData,
                       dwMetaId, 
                       METADATA_NO_ATTRIBUTES,
                       ALL_METADATA,
                       STRING_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = pAdminBase->GetData(
             hObjHandle,
             pszIISPathName,
             &mdrMDData,
             &dwBufferSize
             );

    BAIL_ON_FAILURE(hr);

    *ppBuffer = pBuffer;

    RRETURN(hr);

error:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);
}

HRESULT
MetaBaseGetDwordData(
    IN IMSAdminBase * pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN LPWSTR pszIISPathName,
    IN DWORD  dwMetaId,
    OUT PDWORD pdwData
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)pdwData;

    MD_SET_DATA_RECORD(&mdrMDData,
                       dwMetaId, 
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = pAdminBase->GetData(
             hObjHandle,
             pszIISPathName,
             &mdrMDData,
             &dwBufferSize
             );

    RRETURN(hr);
}


HRESULT
MakeStringFromVariantArray(
    VARIANT *pvVariant,
    LPBYTE* ppBuffer 
    )
{
    HRESULT hr = S_OK;
    DWORD i;
    DWORD dwLen = 0;
    VARIANT *pVar;
    LPBYTE pBuffer = NULL;
    DWORD dwNumVars = 0;
    VARIANT * pVarArray = NULL;

    pVar = pvVariant;

    if (pVar->vt == VT_EMPTY) {
        RRETURN(S_OK);
    }

    hr  = ConvertArrayToVariantArray(
                *pVar,
                &pVarArray,
                &dwNumVars
                );
    BAIL_ON_FAILURE(hr);

    if (dwNumVars == 0) {
        RRETURN(S_OK);
    }

    //
    // find out total length 
    //
         
    pVar = pVarArray;
    for (i = 0; i < dwNumVars; i++ ) {
         //
         // add 1 for comma
         //

         if (pVar->vt == VT_BSTR || pVar->vt == VT_EMPTY) {
             if (pVar->bstrVal && *(pVar->bstrVal)) {

                 //
                 // validate parameter; check for ','
                 //

                 if (wcschr(pVar->bstrVal, L',')) { 
                     hr = E_ADS_BAD_PARAMETER; 
                     BAIL_ON_FAILURE(hr);
                 }
                 dwLen += (wcslen(pVar->bstrVal) + 1);
             }
         }
         else {
             hr = E_ADS_CANT_CONVERT_DATATYPE;
             BAIL_ON_FAILURE(hr);
         }
         pVar++;
    }

    //
    // if there are non-empty entries found in the array, copy them to buffer
    //

    if (dwLen != 0) {
        pBuffer = (LPBYTE) AllocADsMem(dwLen*sizeof(WCHAR));

        if (!pBuffer) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *ppBuffer = pBuffer;

        pVar = pVarArray;

        for (i = 0; i < dwNumVars; i++, pVar++ ) {
             
             if (pVar->bstrVal && *(pVar->bstrVal)) {
    
                 memcpy(pBuffer, pVar->bstrVal, 
                        wcslen(pVar->bstrVal)*sizeof(WCHAR));
                 pBuffer = pBuffer + wcslen(pVar->bstrVal)*sizeof(WCHAR);
    
                 if (i != dwNumVars -1) {
                    memcpy(pBuffer, L",", sizeof(WCHAR));
                    pBuffer = pBuffer + sizeof(WCHAR);
                 }
             }
        }

        if (*ppBuffer == pBuffer - dwLen*sizeof(WCHAR)) {
            pBuffer -= sizeof(WCHAR);
            *pBuffer = L'\0';
        }
        else {
            *pBuffer = L'\0';
        }
    }

error:

    if (pVarArray) {

        for (i = 0; i < dwNumVars; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    if (FAILED(hr) && pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);
}


HRESULT
CheckVariantDataType(
    PVARIANT pVar,
    VARTYPE vt
    )
{
    HRESULT hr;

    hr = VariantChangeType(pVar,
                           pVar,
                           0,
                           vt);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    RRETURN(hr);
}

HRESULT
MakeMultiStringFromVariantArray(
    VARIANT *pvVariant,
    LPBYTE* ppBuffer 
    )
{
    HRESULT hr = S_OK;
    DWORD i;
    DWORD dwLen = 0;
    VARIANT *pVar;
    LPBYTE pBuffer = NULL;
    DWORD dwNumVars = 0;
    VARIANT * pVarArray = NULL;

    pVar = pvVariant;

    if (pVar->vt == VT_EMPTY) {
        RRETURN(S_OK);
    }

    hr  = ConvertArrayToVariantArray(
                *pVar,
                &pVarArray,
                &dwNumVars
                );
    BAIL_ON_FAILURE(hr);

    if (dwNumVars == 0) {
        RRETURN(S_OK);
    }

    //
    // find out total length 
    //
         
    pVar = pVarArray;
    for (i = 0; i < dwNumVars; i++ ) {
         if (pVar->vt == VT_BSTR) {
             if (pVar->bstrVal && *(pVar->bstrVal)) {
                 dwLen += (wcslen(pVar->bstrVal) + 1);
             }
             else {

                 //
                 // add 1 for \0
                 //

                 dwLen++;
             }
         }
         else {
             hr = E_ADS_CANT_CONVERT_DATATYPE;
             BAIL_ON_FAILURE(hr);
         }
         pVar++;
    }

    //
    // +1 for extra \0
    //

    dwLen++;

    //
    // copy entries to buffer
    //

    if (dwLen != 0) {
        pBuffer = (LPBYTE) AllocADsMem(dwLen*sizeof(WCHAR));

        if (!pBuffer) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *ppBuffer = pBuffer;

        pVar = pVarArray;

        for (i = 0; i < dwNumVars; i++, pVar++ ) {
             
             if (pVar->bstrVal && *(pVar->bstrVal)) {
    
                 memcpy(pBuffer, pVar->bstrVal, 
                        wcslen(pVar->bstrVal)*sizeof(WCHAR));
                 pBuffer = pBuffer + wcslen(pVar->bstrVal)*sizeof(WCHAR);
             }
             memcpy(pBuffer, L"\0", sizeof(WCHAR));
             pBuffer = pBuffer + sizeof(WCHAR);
        }

        *pBuffer = L'\0';
    }

error:

    if (pVarArray) {

        for (i = 0; i < dwNumVars; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    if (FAILED(hr) && pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cnamesp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  cnamesp.cxx
//
//  Contents:  Namespace Object
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


DEFINE_IDispatch_Implementation(CIISNamespace)
DEFINE_IADs_Implementation(CIISNamespace)

//  Class CIISNamespace

CIISNamespace::CIISNamespace()
{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CIISNamespace);
}

HRESULT
CIISNamespace::CreateNamespace(
    BSTR Parent,
    BSTR NamespaceName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CIISNamespace FAR * pNamespace = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNamespaceObject(
                Credentials,
                &pNamespace
                );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->InitializeCoreObject(
                Parent,
                NamespaceName,
                L"Namespace",
                L"",
                CLSID_IISNamespace,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNamespace->Release();

    RRETURN(hr);

error:

    delete pNamespace;
    RRETURN(hr);
}


CIISNamespace::~CIISNamespace( )
{
    VariantClear(&_vFilter);
    delete _pDispMgr;
}

STDMETHODIMP
CIISNamespace::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *)this;
    }else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOpenDSObject))
    {
        *ppv = (IADsOpenDSObject FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


STDMETHODIMP
CIISNamespace::SetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::GetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CIISNamespace::get_Count(long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::get_Filter(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::put_Filter(THIS_ VARIANT Var)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::put_Hints(THIS_ VARIANT Var)
{
    RRETURN( E_NOTIMPL);
}


STDMETHODIMP
CIISNamespace::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                _ADsPath,
                ClassName,
                RelativeName,
                _Credentials,
                ppObject,
                TRUE
                );
    RRETURN(hr);

}

STDMETHODIMP
CIISNamespace::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CIISNamespaceEnum::Create(
                (CIISNamespaceEnum **)&penum,
                _vFilter,
                _Credentials
                );
    if (FAILED(hr)){

        goto error;
    }
    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );

    if (FAILED(hr)){
       goto error;
    }

    if (penum) {
        penum->Release();
    }

    return NOERROR;

error:

    if (penum) {
        delete penum;
    }

    return hr;
}

STDMETHODIMP
CIISNamespace::Create(THIS_ BSTR ClassName, BSTR RelativeName, IDispatch * FAR* ppObject)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::Delete(THIS_ BSTR SourceName, BSTR Type)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::CopyHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::MoveHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CIISNamespace::AllocateNamespaceObject(
    CCredentials& Credentials,
    CIISNamespace ** ppNamespace
    )
{
    CIISNamespace FAR * pNamespace = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNamespace = new CIISNamespace();
    if (pNamespace == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsOpenDSObject,
                           (IADsOpenDSObject *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pNamespace,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pNamespace->_Credentials = Credentials;
    pNamespace->_pDispMgr = pDispMgr;
    *ppNamespace = pNamespace;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}




STDMETHODIMP
CIISNamespace::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    //
    // retrieve dataobject from cache; if one exists
    //



    //
    //
    //
    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CIISNamespace::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CIISNamespace::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CIISNamespace::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CIISNamespace::OpenDSObject(
    BSTR lpszDNName,
    BSTR lpszUserName,
    BSTR lpszPassword,
    LONG lnReserved,
    IDispatch FAR * * ppADsObj
    )
{
    HRESULT hr = S_OK;
    IUnknown * pObject = NULL;
    CCredentials Credentials;

    hr = ::GetObject(
                lpszDNName,
                Credentials,
                (LPVOID *)&pObject
                );
    BAIL_ON_FAILURE(hr);



    hr = pObject->QueryInterface(
                        IID_IDispatch,
                        (void **)ppADsObj
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pObject) {
        pObject->Release();
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\core.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  core.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

HRESULT
CCoreADsObject::InitializeCoreObject(
        BSTR Parent,
        BSTR Name,
        BSTR ClassName,
        BSTR Schema,
        REFCLSID rclsid,
        DWORD dwObjectState
        )
{
    HRESULT hr = S_OK;
    ADsAssert(Parent);
    ADsAssert(Name);
    ADsAssert(ClassName);

    hr = BuildADsPath(
            Parent,
            Name,
            &_ADsPath
            );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsGuid(
            rclsid,
            &_ADsGuid
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( Parent, &_Parent);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( Name, &_Name);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ClassName, &_ADsClass);
    BAIL_ON_FAILURE(hr);

    hr = BuildSchemaPath(
            _ADsPath,
            ClassName,
            &_Schema
            );
    BAIL_ON_FAILURE(hr);

    _dwObjectState = dwObjectState;

error:
    RRETURN(hr);

}

CCoreADsObject::CCoreADsObject():
                        _Name(NULL),
                        _ADsPath(NULL),
                        _Parent(NULL),
                        _ADsClass(NULL),
                        _Schema(NULL),
                        _ADsGuid(NULL),
                        _dwObjectState(0)
{
}

CCoreADsObject::~CCoreADsObject()
{
    if (_Name) {
        ADsFreeString(_Name);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_ADsClass) {
        ADsFreeString(_ADsClass);
    }

    if (_Schema) {
        ADsFreeString(_Schema);
    }

    if (_ADsGuid) {
        ADsFreeString(_ADsGuid);
    }

}

HRESULT
CCoreADsObject::get_CoreName(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_Name, retval));
}


HRESULT
CCoreADsObject::get_CoreADsPath(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsPath, retval));

}

HRESULT
CCoreADsObject::get_CoreADsClass(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsClass, retval));
}

HRESULT
CCoreADsObject::get_CoreParent(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_Parent, retval));
}

HRESULT
CCoreADsObject::get_CoreSchema(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    if ( _Schema == NULL || *_Schema == 0 )
        RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);

    RRETURN(ADsAllocString(_Schema, retval));
}

HRESULT
CCoreADsObject::get_CoreGUID(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsGuid, retval));
}

STDMETHODIMP
CCoreADsObject::GetInfo(
    BOOL fExplicit
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cpobjcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cpobjcf.cxx
//
//  Contents:  Windows NT 4.0 Property Attribute Object Class Factory Code
//
//             CIISPropertyAttributeCF::CreateInstance
//
//  History:   21-04-97     sophiac    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISPropertyAttributeCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    21-04-97   sophiac     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISPropertyAttributeCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CPropertyAttribute::CreatePropertyAttribute(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cpobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cpobj.cxx
//
//  Contents:  Property Attribute object
//
//  History:   21-1-98     SophiaC    Created.
//
//----------------------------------------------------------------------------

#include "iis.hxx"
#pragma hdrstop


//  Class CPropertyAttribute

DEFINE_Simple_IDispatch_Implementation(CPropertyAttribute)

CPropertyAttribute::CPropertyAttribute():
        _pDispMgr(NULL)
{
    VariantInit(&_vDefault);
    ENLIST_TRACKING(CPropertyAttribute);
}

HRESULT
CPropertyAttribute::CreatePropertyAttribute(
    REFIID riid,
    void **ppvObj
    )
{
    CPropertyAttribute FAR * pPropertyAttribute = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePropertyAttributeObject(&pPropertyAttribute);
    BAIL_ON_FAILURE(hr);

    hr = pPropertyAttribute->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pPropertyAttribute->Release();

    RRETURN(hr);

error:
    delete pPropertyAttribute;

    RRETURN(hr);

}


CPropertyAttribute::~CPropertyAttribute( )
{
    VariantClear(&_vDefault);
    delete _pDispMgr;
}

STDMETHODIMP
CPropertyAttribute::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IISPropertyAttribute FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IISPropertyAttribute))
    {
        *ppv = (IISPropertyAttribute FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IISPropertyAttribute FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


HRESULT
CPropertyAttribute::InitFromRawData(
    LPWSTR pszName,
    DWORD dwMetaId,
    DWORD dwUserType,
    DWORD dwAttribute,
    VARIANT *pvVal
    )
{
    wcscpy((LPWSTR)_wcName, pszName);
    _lMetaId = (long) dwMetaId;
    _lUserType = (long) dwUserType;
    _lAllAttributes = (long) dwAttribute;
    _bInherit = dwAttribute & METADATA_INHERIT;
    _bPartialPath = dwAttribute & METADATA_PARTIAL_PATH;
    _bSecure = dwAttribute & METADATA_SECURE;
    _bReference = dwAttribute & METADATA_REFERENCE;
    _bVolatile = dwAttribute & METADATA_VOLATILE;
    _bIsinherit = dwAttribute & METADATA_ISINHERITED;
    _bInsertPath = dwAttribute & METADATA_INSERT_PATH;
    VariantCopy(&_vDefault, pvVal);

    return S_OK;
}

HRESULT
CPropertyAttribute::AllocatePropertyAttributeObject(
    CPropertyAttribute ** ppPropertyAttribute
    )
{
    CPropertyAttribute FAR * pPropertyAttribute = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pPropertyAttribute = new CPropertyAttribute();
    if (pPropertyAttribute == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISOle,
                IID_IISPropertyAttribute,
                (IISPropertyAttribute *)pPropertyAttribute,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pPropertyAttribute->_pDispMgr = pDispMgr;
    *ppPropertyAttribute = pPropertyAttribute;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CPropertyAttribute::get_PropName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString((LPWSTR)_wcName, retval);
    RRETURN(hr);
}

STDMETHODIMP
CPropertyAttribute::get_MetaId(THIS_ LONG FAR * retval)
{
    *retval = _lMetaId;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_MetaId(THIS_ LONG lMetaId)
{
   RRETURN(E_ADS_PROPERTY_NOT_SET);
}

STDMETHODIMP
CPropertyAttribute::get_UserType(THIS_ LONG FAR * retval)
{
    *retval = _lUserType;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_UserType(THIS_ LONG lUserType)
{
    _lUserType = lUserType;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_AllAttributes(THIS_ LONG FAR * retval)
{
    *retval = _lAllAttributes;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_Inherit(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bInherit ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_Inherit(THIS_ VARIANT_BOOL bInherit)
{
    _bInherit = bInherit ? TRUE : FALSE;
    _lAllAttributes |= (_bInherit ? METADATA_INHERIT : 0);
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_PartialPath(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bPartialPath ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_PartialPath(THIS_ VARIANT_BOOL bPartialPath)
{
    _bPartialPath = bPartialPath ? TRUE : FALSE;
    _lAllAttributes |= (_bPartialPath ?  METADATA_PARTIAL_PATH : 0);
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_Reference(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bReference ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_Reference(THIS_ VARIANT_BOOL bReference)
{
    _bReference = bReference ? TRUE : FALSE;
    _lAllAttributes |= (_bReference ? METADATA_REFERENCE : 0);
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_Secure(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bSecure ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_Secure(THIS_ VARIANT_BOOL bSecure)
{
    _bSecure = bSecure ? TRUE : FALSE;
    _lAllAttributes |= (_bSecure ? METADATA_SECURE : 0);
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_Volatile(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bVolatile ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_Volatile(THIS_ VARIANT_BOOL bVolatile)
{
    _bVolatile = bVolatile ? TRUE : FALSE;
    _lAllAttributes |= (_bVolatile ? METADATA_VOLATILE : 0);
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_Isinherit(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bIsinherit ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_Isinherit(THIS_ VARIANT_BOOL bIsinherit)
{
    _bIsinherit = bIsinherit ? TRUE : FALSE;
    _lAllAttributes |= (_bIsinherit ? METADATA_ISINHERITED : 0);
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_InsertPath(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bInsertPath ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_InsertPath(THIS_ VARIANT_BOOL bInsertPath)
{
    _bInsertPath = bInsertPath ? TRUE : FALSE;
    _lAllAttributes |= (_bInsertPath ? METADATA_INSERT_PATH : 0);
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_Default(THIS_ VARIANT FAR * retval)
{
    VariantInit(retval);
    RRETURN(VariantCopy(retval, &_vDefault));
}

STDMETHODIMP
CPropertyAttribute::put_Default(THIS_ VARIANT vVarDefault)
{
    VariantClear(&_vDefault);
    RRETURN(VariantCopy(&_vDefault, &vVarDefault));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cprovcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  cprovcf.cxx
//
//  Contents:  IIS Provider Object Class Factory Code
//
//             CIISProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CIISProviderCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISProviderCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr;
    CIISProvider *     pProvider;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CIISProvider::Create(&pProvider);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pProvider)
    {
        hr = pProvider->QueryInterface(iid, ppv);
        pProvider->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cprov.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  cprov.cxx
//
//  Contents:  Provider Object Code
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//  Class CIISProvider

CIISProvider::CIISProvider()
{

}

HRESULT
CIISProvider::Create(CIISProvider FAR * FAR * ppProvider)
{
    CIISProvider FAR * pProvider = NULL;
    HRESULT hr = S_OK;

    //Create the Provider Object

    pProvider = new CIISProvider();
    if (pProvider == NULL) {
        RRETURN(ResultFromScode(E_OUTOFMEMORY));
    }

    if (FAILED(hr)) {
        delete pProvider;
        RRETURN(hr);
    }


    *ppProvider = pProvider;
    RRETURN(hr);
}

CIISProvider::~CIISProvider( )
{
    ENLIST_TRACKING(CIISProvider);
}

STDMETHODIMP
CIISProvider::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
        *ppv = (IParseDisplayName FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CIISProvider::ParseDisplayName(
    IBindCtx* pbc,
    WCHAR* szDisplayName,
    ULONG* pchEaten,
    IMoniker** ppmk
    )
{
    HRESULT hr;

    *ppmk = NULL;

    if (pchEaten != NULL){
        *pchEaten = 0;
    }

    hr = ResolvePathName(
                pbc,
                szDisplayName,
                pchEaten,
                ppmk
                );

    RRETURN(hr);
}

HRESULT
CIISProvider::ResolvePathName(
    IBindCtx* pbc,
    WCHAR* szDisplayName,
    ULONG* pchEaten,
    IMoniker** ppmk
    )
{
    HRESULT hr;
    LPUNKNOWN pUnknown = NULL;
    CCredentials Credentials;

    *pchEaten = 0;
    hr = GetObject(
            szDisplayName,
            Credentials,
            (LPVOID *)&pUnknown
            );
    BAIL_IF_ERROR(hr);

    hr = CreatePointerMoniker(pUnknown, ppmk);
    BAIL_IF_ERROR(hr);

    *pchEaten += wcslen(szDisplayName);

cleanup:

    if (pUnknown) {
        pUnknown->Release();
    }

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cprops.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for IIS
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      17-June-1997   sophiac Created.
//                cloned off NT property cache code
//
//
//----------------------------------------------------------------------------

#include "iis.hxx"
#pragma  hdrstop

#if DBG
DECLARE_INFOLEVEL(IISMarshall);
DECLARE_DEBUG(IISMarshall);
#define IISMarshallDebugOut(x) IISMarshallInlineDebugOut x
#endif



//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::addproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vt]                --
//              [vaData]            --
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
addproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PIISOBJECT pIISObject
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pNewProperty = NULL;

    //
    //  extend the property cache by adding a new property entry
    //

    _pProperties = (PPROPERTY)ReallocADsMem(
                                _pProperties,
                                _cb,
                                _cb + sizeof(PROPERTY)
                                );
    if (!_pProperties) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    pNewProperty = (PPROPERTY)((LPBYTE)_pProperties + _cb);

    wcscpy(pNewProperty->szPropertyName, szPropertyName);

    //
    // Update the index
    //

    _dwMaxProperties++;
    _cb += sizeof(PROPERTY);

error:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::updateproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vaData]    --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::updateproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PIISOBJECT pIISObject,
    BOOL fExplicit
    )
{
    HRESULT hr;
    DWORD dwIndex;
    DWORD dwMetaId;
    PIISOBJECT pIISTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (!fExplicit) {
        if ((PROPERTY_FLAGS(pThisProperty) == CACHE_PROPERTY_MODIFIED) ||
            (PROPERTY_FLAGS(pThisProperty) == CACHE_PROPERTY_CLEARED))    {
            hr = S_OK;
            goto error;
        }
    }

    //
    //   Factor in cases where object state is necessary to
    //   decide on update.
    //

    if (PROPERTY_IISOBJECT(pThisProperty)) {

        IISTypeFreeIISObjects(
                PROPERTY_IISOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_IISOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;
    _pSchema->ConvertPropName_To_ID(szPropertyName, &dwMetaId);

    PROPERTY_METAID(pThisProperty) = dwMetaId;

    hr = IISTypeCopyConstruct(
            pIISObject,
            dwNumValues,
            &pIISTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_IISOBJECT(pThisProperty) = pIISTempObject;

    PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_INITIALIZED;

error:

    RRETURN(hr);

}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::findproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::findproperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )

{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        if (!_wcsicmp(pThisProperty->szPropertyName, szPropertyName)) {
            *pdwIndex = i;
            RRETURN(S_OK);
        }
    }
    *pdwIndex = 0;
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
getproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PIISOBJECT * ppIISObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;
    DWORD dwResult;
    DWORD dwInfoLevel = 0;

    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {

        //
        // Now call the GetInfo function
        //

        if (!_bPropsLoaded) {
            hr = _pCoreADsObject->GetInfo(FALSE);
            if (FAILED(hr) && hr != E_ADS_OBJECT_UNBOUND) {
                BAIL_ON_FAILURE(hr);
            }

            hr = findproperty(
                        szPropertyName,
                        &dwIndex
                        );
        }
    }
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        LPBYTE propvalue;
        DWORD dwSyntax;
        DWORD dwNumValues;

        hr = _pSchema->GetDefaultProperty(szPropertyName, &dwNumValues,
                                          &dwSyntax, &propvalue);
        BAIL_ON_FAILURE(hr);
        hr = unmarshallproperty(
                    szPropertyName,
                    propvalue,
                    dwNumValues,
                    dwSyntax,
                    0
                    );
        BAIL_ON_FAILURE(hr);
        hr = findproperty (szPropertyName,
                           &dwIndex
                           );

    }
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_IISOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = IISTypeCopyConstruct(PROPERTY_IISOBJECT(pThisProperty),
                                 PROPERTY_NUMVALUES(pThisProperty),
                                 ppIISObject );
        BAIL_ON_FAILURE(hr);
    }else {

        *ppIISObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_ADS_PROPERTY_NOT_SET;
    }

error:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Clsid index
//              [vaData]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::putproperty(
    LPWSTR szPropertyName,
    DWORD  dwFlags,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PIISOBJECT pIISObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    DWORD dwMetaId = 0;
    PIISOBJECT pIISTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_IISOBJECT(pThisProperty)) {

        IISTypeFreeIISObjects(
                PROPERTY_IISOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_IISOBJECT(pThisProperty) = NULL;
    }

    _pSchema->ConvertPropName_To_ID(szPropertyName, &dwMetaId);

    switch (dwFlags) {

    case CACHE_PROPERTY_MODIFIED:

        PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

        PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

        PROPERTY_METAID(pThisProperty) = dwMetaId;

        hr = IISTypeCopyConstruct(
                pIISObject,
                dwNumValues,
                &pIISTempObject
                );
        BAIL_ON_FAILURE(hr);

        PROPERTY_IISOBJECT(pThisProperty) = pIISTempObject;

        PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_MODIFIED;
        break;

    case CACHE_PROPERTY_CLEARED:

        PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

        PROPERTY_NUMVALUES(pThisProperty) = 0;

        PROPERTY_IISOBJECT(pThisProperty) = NULL;

        PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_CLEARED;

        break;

    }

error:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::CPropertyCache():
    _pCoreADsObject(NULL),
    _pSchema(NULL),
    _bPropsLoaded(FALSE),
    _dwMaxProperties(0),
    _dwCurrentIndex(0),
    _pProperties(NULL),
    _cb(0),
    _pDispProperties(NULL),
    _dwDispMaxProperties(0),
    _cbDisp(0),
    _bstrServerName(NULL)
{

}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
~CPropertyCache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;
    PDISPPROPERTY pThisDispProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (PROPERTY_IISOBJECT(pThisProperty)) {

                IISTypeFreeIISObjects(
                        PROPERTY_IISOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_IISOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }


    //
    // Free Dynamic Dispid Table
    //

    if (_pDispProperties) {

        FreeADsMem(_pDispProperties);
    }

    if( _bstrServerName )
    {
        ADsFreeString( _bstrServerName );
    }
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::createpropertycache(
    CCoreADsObject FAR * pCoreADsObject,
    CPropertyCache FAR *FAR * ppPropertyCache
    )
{
    CPropertyCache FAR * pPropertyCache = NULL;
    BSTR serverName=NULL;
    HRESULT hr;

    hr = pCoreADsObject->get_CoreName(&serverName);
    BAIL_ON_FAILURE(hr);

    pPropertyCache = new CPropertyCache();

    if (!pPropertyCache) {
        RRETURN(E_OUTOFMEMORY);
    }

    pPropertyCache->_pCoreADsObject = pCoreADsObject;
    
    *ppPropertyCache = pPropertyCache;
    RRETURN(S_OK);

error :

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::
unmarshallproperty(
    LPWSTR szPropertyName,
    LPBYTE lpValue,
    DWORD  dwNumValues,
    DWORD  dwSyntaxId,
    BOOL fExplicit
    )
{
    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    PIISOBJECT pIISObject = NULL;

    hr = UnMarshallIISToIISSynId(
                dwSyntaxId,
                dwNumValues,
                lpValue,
                &pIISObject
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = findproperty(
                szPropertyName,
                &dwIndex
                );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //

    if (FAILED(hr)) {
        hr = addproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pIISObject
                    );

        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = updateproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pIISObject,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pIISObject) {
        IISTypeFreeIISObjects(
                pIISObject,
                dwNumValues
                );

    }

    RRETURN(hr);
}

HRESULT
CPropertyCache::
IISUnMarshallProperties(
    LPBYTE pBase,
    LPBYTE pBuffer,
    DWORD  dwMDNumDataEntries,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    PMETADATA_GETALL_RECORD pmdgarData = NULL, pTemp = NULL;
    DWORD i = 0;
    WCHAR szPropertyName[MAX_PATH];
    DWORD dwSyntaxID;
    DWORD dwNumValues;
   
    ZeroMemory(szPropertyName, MAX_PATH);
    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    _bPropsLoaded = TRUE;
    pmdgarData = (PMETADATA_GETALL_RECORD)pBuffer;

    for (i = 0; i < dwMDNumDataEntries; i++) {

        //
        // unmarshall this property into the
        // property cache
        //

        pTemp = pmdgarData + i;

        hr = _pSchema->ConvertID_To_PropName(pTemp->dwMDIdentifier, 
                                             szPropertyName);

        CONTINUE_ON_FAILURE(hr);

        hr = _pSchema->LookupSyntaxID(szPropertyName, &dwSyntaxID);

        CONTINUE_ON_FAILURE(hr);

        //
        // find out number of strings within the multi-sz string
        //

        if (pTemp->dwMDDataType == MULTISZ_METADATA) {
            LPWSTR pszStr = (LPWSTR) (pBase + pTemp->dwMDDataOffset);

            if (*pszStr == 0) {
                dwNumValues = 1;
            }
            else {
                dwNumValues = 0;
            }

            while (*pszStr != L'\0') {
                while (*pszStr != L'\0') {
                    pszStr++;
                }
                dwNumValues++;
                pszStr++;
            }
        }
        else if (pTemp->dwMDDataType == BINARY_METADATA) {

            //
            // if DataType == BINARY, pass the length to dwNumValues
            //

            dwNumValues = pTemp->dwMDDataLen;
        }
        else {
            dwNumValues = 1;
        }

        hr = unmarshallproperty(
                    szPropertyName,
                    pBase + pTemp->dwMDDataOffset,
                    dwNumValues,
                    dwSyntaxID,
                    fExplicit
                    );

        CONTINUE_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}


HRESULT
CPropertyCache::
IISMarshallProperties(
    PMETADATA_RECORD *  ppMetaDataRecords,
    PDWORD pdwMDNumDataEntries
    )
{

    HRESULT hr = S_OK;
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;
    PMETADATA_RECORD pMetaDataArray = NULL;
    DWORD dwCount = 0;

    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    pMetaDataArray = (PMETADATA_RECORD) AllocADsMem(
                          _dwMaxProperties * sizeof(METADATA_RECORD));
    if (!pMetaDataArray ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *ppMetaDataRecords = pMetaDataArray;

    for (i = 0; i < _dwMaxProperties ; i++) {

        pThisProperty = _pProperties + i;

        //
        // Bypass any property that has not been
        // modified
        //

        if (PROPERTY_FLAGS(pThisProperty) == 0 ||
            PROPERTY_FLAGS(pThisProperty) == CACHE_PROPERTY_CLEARED) {
            continue;
        }

        hr = MarshallIISSynIdToIIS(
                _pSchema,
                PROPERTY_SYNTAX(pThisProperty),
                PROPERTY_METAID(pThisProperty),
                PROPERTY_IISOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                pMetaDataArray
                );
        CONTINUE_ON_FAILURE(hr);

        pMetaDataArray++;
        dwCount++;
    }

    *pdwMDNumDataEntries = dwCount;

error:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
void
CPropertyCache::
flushpropcache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (PROPERTY_IISOBJECT(pThisProperty)) {

                IISTypeFreeIISObjects(
                        PROPERTY_IISOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_IISOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }

    //
    // Reset the property cache
    //

    _pProperties = NULL;
    _dwMaxProperties = 0;
    _cb = 0;
}


BOOL
CPropertyCache::
index_valid(
   )
{
    //
    // need to check separately since a negative DWORD is equal to +ve large #
    //
    if (_dwMaxProperties==0)
        return(FALSE);
   
    if (_dwCurrentIndex > _dwMaxProperties - 1)
        return(FALSE);
    else
        return(TRUE);
}


BOOL
CPropertyCache::
index_valid(
   DWORD dwIndex
   )
{
    //
    // need to check separately since a negative DWORD is equal to +ve large #
    //
    if (_dwMaxProperties==0)
        return(FALSE);

    if (dwIndex > _dwMaxProperties - 1)
        return(FALSE);
    else
        return(TRUE);
}


void
CPropertyCache::
reset_propindex(
    )
{
  _dwCurrentIndex = 0;

}


HRESULT
CPropertyCache::
skip_propindex(
    DWORD dwElements
    )
{
    DWORD newIndex = _dwCurrentIndex + dwElements;

    if (!index_valid())
        RRETURN(E_ADS_BAD_PARAMETER);

    if (newIndex > _dwMaxProperties) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    
    _dwCurrentIndex = newIndex;

    RRETURN(S_OK);

}


HRESULT
CPropertyCache::
get_PropertyCount(
    PDWORD pdwMaxProperties
    )
{
    *pdwMaxProperties = _dwMaxProperties;

    RRETURN(S_OK);
}

DWORD
CPropertyCache::
get_CurrentIndex(
    )
{
    return(_dwCurrentIndex);
}


LPWSTR
CPropertyCache::
get_CurrentPropName(
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!_dwMaxProperties)      // if !_dwMaxProperties, pThisProperty=NULL, AV
        return NULL;            // in PROPERTY_NAME(pThisProperty) 

    if (!index_valid())
        return(PROPERTY_NAME(pThisProperty));

    pThisProperty = _pProperties + _dwCurrentIndex;

    return(PROPERTY_NAME(pThisProperty));
}

LPWSTR
CPropertyCache::
get_PropName(
    DWORD dwIndex
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex))
       return(NULL);

    pThisProperty = _pProperties + dwIndex;

    return(PROPERTY_NAME(pThisProperty));
}


HRESULT
CPropertyCache::
deleteproperty(
    DWORD dwIndex
    )
{
   HRESULT hr = S_OK;
   PPROPERTY pNewProperties = NULL;
   PPROPERTY pThisProperty = _pProperties + dwIndex;

   if (!index_valid(dwIndex)) {
      hr = E_FAIL;
      BAIL_ON_FAILURE(hr);
   }

   if (_dwMaxProperties == 1) {
      //
      // Deleting everything
      //
      if (PROPERTY_IISOBJECT(pThisProperty)) {
          IISTypeFreeIISObjects(
                  PROPERTY_IISOBJECT(pThisProperty),
                  PROPERTY_NUMVALUES(pThisProperty)
                  );
          PROPERTY_IISOBJECT(pThisProperty) = NULL;
      }

      FreeADsMem(_pProperties);
      _pProperties = NULL;
      _dwMaxProperties = 0;
      _cb = 0;
      RRETURN(hr);
   }

   pNewProperties = (PPROPERTY)AllocADsMem(
                               _cb - sizeof(PROPERTY)
                               );
   if (!pNewProperties) {
       hr = E_OUTOFMEMORY;
       BAIL_ON_FAILURE(hr);
   }

   //
   // Copying the memory before the deleted item
   //
   if (dwIndex != 0) {
      memcpy( pNewProperties,
              _pProperties,
              dwIndex * sizeof(PROPERTY));
   }

   //
   // Copying the memory following the deleted item
   //
   if (dwIndex != (_dwMaxProperties-1)) {
      memcpy( pNewProperties + dwIndex,
              _pProperties + dwIndex + 1,
              (_dwMaxProperties - dwIndex - 1) * sizeof(PROPERTY));
   }

   if (PROPERTY_IISOBJECT(pThisProperty)) {
       IISTypeFreeIISObjects(
               PROPERTY_IISOBJECT(pThisProperty),
               PROPERTY_NUMVALUES(pThisProperty)
               );
       PROPERTY_IISOBJECT(pThisProperty) = NULL;
   }
   FreeADsMem(_pProperties);
   _pProperties = pNewProperties;
   _dwMaxProperties--;
   _cb -= sizeof(PROPERTY);
error:

   RRETURN(hr);
}


////////////////////////////////////////////////////////////////////////
//
//  IPropertyCache
//

HRESULT
CPropertyCache::
locateproperty(
    LPWSTR  szPropertyName,
    PDWORD  pdwDispid
    )
{
    HRESULT hr;

    hr = DispatchLocateProperty(
            szPropertyName,
            pdwDispid
            );

    RRETURN(hr);
}

HRESULT
CPropertyCache::
putproperty(
    DWORD   dwDispid,
    VARIANT varValue
    )
{
    HRESULT hr;

    hr = DispatchPutProperty(
            dwDispid, 
            varValue 
            );

    RRETURN(hr);
}

HRESULT
CPropertyCache::
getproperty(
    DWORD   dwDispid,
    VARIANT * pvarValue
    )
{
    HRESULT hr;

    hr = DispatchGetProperty(
            dwDispid, 
            pvarValue 
            );

    RRETURN(hr);
}
 

////////////////////////////////////////////////////////////////////////
//
// Dynamic Dispid Table
//

HRESULT
CPropertyCache::
DispatchFindProperty(
    LPWSTR szPropertyName,
    PDWORD pdwDispid 
    )
{
    DWORD i = 0;
    PDISPPROPERTY pDispProp = NULL;

    //
    // use ADs Error codes since this funct'n does not go directly into
    // the dispatch interface
    //
    if (!pdwDispid || !szPropertyName)  
        RRETURN(E_ADS_BAD_PARAMETER);

    for (i=0; i<_dwDispMaxProperties; i++) {
        
        pDispProp = _pDispProperties + i;
    
        if (!_wcsicmp(DISPATCH_NAME(pDispProp), szPropertyName)) {
            *pdwDispid=i;
            RRETURN(S_OK);
        }
    }

    *pdwDispid = -1;
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}

HRESULT
CPropertyCache::
DispatchAddProperty(
    LPWSTR szPropertyName,
    PDWORD pdwDispid    /* optional */
    )
{

    HRESULT hr = E_FAIL;
    DWORD dwDispid = -1;
    PDISPPROPERTY pNewDispProps = NULL;

    //
    // use ADs Error codes since this funct'n does not go directly into
    // the dispatch interface
    //
    if (!szPropertyName)  
        RRETURN(E_ADS_BAD_PARAMETER);

    hr = DispatchFindProperty(
            szPropertyName,
            &dwDispid
            );
    
    if (hr==E_ADS_PROPERTY_NOT_FOUND) {
        
        // 
        // increase the size of Dynamic Dispid Table by 1 property
        //
        pNewDispProps = (PDISPPROPERTY) ReallocADsMem(
                                            _pDispProperties,
                                            _cbDisp,
                                            _cbDisp + sizeof(DISPPROPERTY)
                                            );
        if (!pNewDispProps)
            BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);

        //
        // must succeeded at this pt. okay to change table & indexes 
        //
        _pDispProperties = pNewDispProps;
        wcscpy((_pDispProperties+_dwDispMaxProperties)->szPropertyName, 
               szPropertyName);
        dwDispid = _dwDispMaxProperties++;
        _cbDisp += sizeof(DISPPROPERTY);

        hr = S_OK;
    }

    // 
    // return valid, or invalid (-1) in case of failure, dispid of
    // szProperty iff asked for
    //
    if (pdwDispid)            
        *pdwDispid = dwDispid;
        
error:
    
    RRETURN(hr);
} 
        
HRESULT
CPropertyCache::
DispatchLocateProperty(
    LPWSTR szPropertyName,
    PDWORD pdwDispid 
    )
{
    HRESULT hr;
    DWORD dwSyntaxId;   // (dummy)
    BSTR bstrClassName = NULL;

    //
    // - pdwDispid not optional here
    // - Use DISP_E_ERROR codes since this function directly called by
    //   the dispatch manager 
    //
    if (!pdwDispid || !szPropertyName)  
        RRETURN(DISP_E_PARAMNOTOPTIONAL);

    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    //
    // return dispid of property if already in table; 
    // 
    hr = DispatchFindProperty(
            szPropertyName,
            pdwDispid
            );
   
    if (hr==E_ADS_PROPERTY_NOT_FOUND) {
                 
        //
        // check if property in schema
        //      - this is necessary; otherwise, property not in schema will 
        //        be allowed to be added to cache and will not be given the 
        //        chance to be handled by 3rd party extension.
        //      - note that property not in schema but added to the cache
        //        thru' IADsProperty list will not be handled by 3rd
        //        party extension either. 
        //
        hr = _pCoreADsObject->get_CoreADsClass(&bstrClassName);
        BAIL_ON_FAILURE(hr);
        hr = _pSchema->ValidateProperty(bstrClassName, szPropertyName);
        BAIL_ON_FAILURE(hr);

        //
        // Add property that is in the schema but not in the cache to
        // the dynamic dispid table. That is, property which is in the 
        // schema will always be handled by the cache/server thur ADSI but 
        // will NOT be handled by 3rd party extension.
        //
        if (SUCCEEDED(hr)) {
    
            hr = DispatchAddProperty(
                        szPropertyName,
                        pdwDispid
                        );
            BAIL_ON_FAILURE(hr);

        }

        //
        // Property Not in the schema will nto be added to the dynamic
        // dispid table and could be handled by 3rd party extension.
        //
        else {

            hr = DISP_E_MEMBERNOTFOUND;
            BAIL_ON_FAILURE(hr); 

        }
    }

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    RRETURN(hr);

error:

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    *pdwDispid = DISPID_UNKNOWN;

    RRETURN(hr);
}

/* INTRINSA suppress=null_pointers, uninitialized */
HRESULT
CPropertyCache::
DispatchGetProperty(
    DWORD dwDispid,
    VARIANT * pvarVal
    )
{
    HRESULT hr;
    LPWSTR szPropName = NULL;
    DWORD dwSyntaxId = -1;
    DWORD dwSyntax;
    DWORD dwNumValues = 0;
    PIISOBJECT pIISObjs = NULL;
    WCHAR wchName[MAX_PATH];
      
    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    //
    // Use DISP_E_ERROR codes since this function directly called by
    // the dispatch manager 
    //
    if (!pvarVal) 
        RRETURN(DISP_E_PARAMNOTOPTIONAL);

    if (!DISPATCH_INDEX_VALID(dwDispid)) 
        RRETURN(DISP_E_MEMBERNOTFOUND);

    szPropName = DISPATCH_PROPERTY_NAME(dwDispid); 

    //
    // lookup ADSI IIS syntax Id
    //

    hr = _pSchema->LookupSyntaxID(szPropName, &dwSyntax);
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //

    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(szPropName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
    }

    // 
    // return value in cache for szPropName; retrieve value from server 
    // if not already in cache; fail if none on sever
    //
    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY) 
    {
    hr = getproperty(
            wchName, 
            &dwSyntaxId, 
            &dwNumValues,
            &pIISObjs
            );
    }
    else
    {
    hr = getproperty(
            szPropName, 
            &dwSyntaxId, 
            &dwNumValues,
            &pIISObjs
            );
    }
    BAIL_ON_FAILURE(hr);

    //
    // reset it to its syntax id if BITMASK type
    //

    pIISObjs->IISType = dwSyntax;

    //
    // translate IIS objects into variants 
    //
    //
    // always return an array for multisz type
    //

    if (dwNumValues == 1 && dwSyntax != IIS_SYNTAX_ID_MULTISZ &&
        dwSyntax != IIS_SYNTAX_ID_MIMEMAP ) {
        
        hr = IISTypeToVarTypeCopy(
                _pSchema,
                szPropName,
                pIISObjs,
                pvarVal,
                FALSE
                );

    } else {
        
        hr = IISTypeToVarTypeCopyConstruct(
                _pSchema,
                szPropName,
                pIISObjs,
                dwNumValues,
                pvarVal,
                FALSE
                );
    }         
    BAIL_ON_FAILURE(hr);

error:
 
    if (pIISObjs) {
        
        IISTypeFreeIISObjects(
            pIISObjs,
            dwNumValues
            );
    }

    if (FAILED(hr)) {

        V_VT(pvarVal) = VT_ERROR;
    }    

    RRETURN(hr);
}

HRESULT
CPropertyCache::
DispatchPutProperty(
    DWORD dwDispid,
    VARIANT& varVal
    )
{
    HRESULT hr;
    DWORD dwSyntaxId = -1;
    DWORD dwIndex = -1;
    LPIISOBJECT pIISObjs = NULL;
    DWORD dwNumValues = 0;

    VARIANT * pVarArray = NULL;     // to be freed
    VARIANT * pvProp = NULL;            // do not free
    VARIANT vVar;
    WCHAR wchName[MAX_PATH];
    LPWSTR szPropName = NULL;
    
    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    //
    // Use DISP_E_ERROR codes since this function directly called by
    // the dispatch manager 
    //
    if (!DISPATCH_INDEX_VALID(dwDispid)) 
        RRETURN(DISP_E_MEMBERNOTFOUND);

    // 
    // retreive property name from Dynamic Dispatch Table
    //
    szPropName = DISPATCH_PROPERTY_NAME(dwDispid); 

    //
    // lookup its syntax ID
    //

    hr = _pSchema->LookupSyntaxID(szPropName, &dwSyntaxId);
    BAIL_ON_FAILURE(hr);

    //
    // Issue: How do we handle multi-valued support
    //

    VariantInit(&vVar);
    VariantCopyInd(&vVar, &varVal);

    if ((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar)) {
        hr  = ConvertArrayToVariantArray(
                    vVar,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;
    }
    else {

        dwNumValues = 1;
        pvProp = &vVar;
    }

    //
    // Variant Array to IIS Objects
    //
    hr = VarTypeToIISTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pIISObjs,
                    FALSE
                    );
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //

    if (dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
        DWORD dwMask;
        DWORD dwFlagValue;
        DWORD Temp;
        LPIISOBJECT pIISObject = NULL;

        hr = _pSchema->LookupBitMask(szPropName, &dwMask);
        BAIL_ON_FAILURE(hr);

        //
        // get its corresponding DWORD flag value
        //

        hr = _pSchema->LookupFlagPropName(szPropName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);

        hr = getproperty(wchName, 
                         &Temp,
                         &Temp,
                         &pIISObject);
        BAIL_ON_FAILURE(hr);

        dwFlagValue = pIISObject->IISValue.value_1.dwDWORD;

        if (pIISObjs->IISValue.value_1.dwDWORD) {
            dwFlagValue |= dwMask;
        }
        else {
            dwFlagValue &= ~dwMask;
        }

        pIISObjs->IISValue.value_1.dwDWORD = dwFlagValue;
        pIISObjs->IISType = IIS_SYNTAX_ID_DWORD;
        szPropName = wchName;

        if (pIISObject) {
            IISTypeFreeIISObjects(
                pIISObject,
                1
                );
        }
    }

    if (dwSyntaxId == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(szPropName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
        szPropName = wchName;
    }

    //
    // add the property to cache if not already in since DispatchAddProperty
    // does not addproperty
    //
    hr = findproperty(
                szPropName,
                &dwIndex
                );

    if (FAILED(hr)) {
        hr = addproperty(
                    szPropName,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ?
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISObjs
                    );
        BAIL_ON_FAILURE(hr);
    }
    
    //
    // update property value in cache
    //

    hr = putproperty(
                szPropName, 
                CACHE_PROPERTY_MODIFIED,
                dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ?
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                dwNumValues,
                pIISObjs
                );
    BAIL_ON_FAILURE(hr);


error:
 
    if (pIISObjs) {
        IISTypeFreeIISObjects(
            pIISObjs,
            dwNumValues
            );
    }

    if (pVarArray) {

        DWORD i = 0;
        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    VariantClear(&vVar);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cschobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:  cschobj.cxx
//
//  Contents:  Microsoft ADs IIS Provider Schema Object
//
//
//  History:   01-30-98     sophiac    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//  Class CIISSchema

DEFINE_IDispatch_Implementation(CIISSchema)
DEFINE_IADs_Implementation(CIISSchema)


CIISSchema::CIISSchema() :
      _pSchema(NULL),
      _pDispMgr(NULL),
      _pszServerName(NULL),
      _pAdminBase(NULL)
{

    ENLIST_TRACKING(CIISSchema);
}

HRESULT
CIISSchema::CreateSchema(
    LPWSTR pszServerName,
    BSTR Parent,
    BSTR CommonName,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CIISSchema FAR * pSchema = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSchemaObject(&pSchema);
    BAIL_ON_FAILURE(hr);

    hr = InitServerInfo(pszServerName, 
                        &pSchema->_pAdminBase, 
                        &pSchema->_pSchema);
    BAIL_ON_FAILURE(hr);

    pSchema->_pszServerName = AllocADsStr(pszServerName);

    if (!pSchema->_pszServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = pSchema->InitializeCoreObject(
                Parent,
                CommonName,
                SCHEMA_CLASS_NAME,
                L"",
                CLSID_IISSchema,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pSchema->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pSchema->Release();

    RRETURN(hr);

error:

    delete pSchema;
    RRETURN(hr);
}

CIISSchema::~CIISSchema( )
{
    delete _pDispMgr;

    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

}

STDMETHODIMP
CIISSchema::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IISSchemaObject))
    {
        *ppv = (IISSchemaObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CIISSchema::SetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISSchema::GetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CIISSchema::get_Count(long FAR* retval)
{
    HRESULT hr;
    DWORD dwEntries;

    if ( !retval )
        RRETURN(E_ADS_BAD_PARAMETER);

    hr = _pSchema->GetTotalEntries(&dwEntries);

    if ( SUCCEEDED(hr))
        *retval = dwEntries + g_cIISSyntax;

    RRETURN(hr);

}

STDMETHODIMP
CIISSchema::get_Filter(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISSchema::put_Filter(THIS_ VARIANT Var)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISSchema::put_Hints(THIS_ VARIANT Var)
{
    RRETURN( E_NOTIMPL);
}


STDMETHODIMP
CIISSchema::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISSchema::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{

    LPWSTR pszBuffer = NULL;
    HRESULT hr = S_OK;
    DWORD dwLen;
    CCredentials Credentials;

    *ppObject = NULL;

    if (!RelativeName || !*RelativeName) {
        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

    dwLen = wcslen(_ADsPath) + wcslen(RelativeName) + wcslen(ClassName) + 4;

    pszBuffer = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));

    if (!pszBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    wcscpy(pszBuffer, _ADsPath);
    wcscat(pszBuffer, L"/");
    wcscat(pszBuffer, RelativeName);

    if (ClassName && *ClassName) {
        wcscat(pszBuffer,L",");
        wcscat(pszBuffer, ClassName);
    }

    hr = ::GetObject(
                pszBuffer,
                Credentials,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pszBuffer) {
        FreeADsMem(pszBuffer);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISSchema::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;

    if ( !retval )
        RRETURN(E_ADS_BAD_PARAMETER);

    *retval = NULL;

    hr = CIISSchemaEnum::Create(
                (CIISSchemaEnum **)&penum,
                _pSchema,
                _ADsPath,
                _Name
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISSchema::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{

    HRESULT hr = S_OK;
    DWORD i = 1;

    //
    // We can only create "Class","Property" here, "Syntax" is read-only
    //

    //
    // check if property/class already exists
    //

    if (_pSchema->ValidateClassName(RelativeName) == ERROR_SUCCESS ||
        _pSchema->ValidatePropertyName(RelativeName) == ERROR_SUCCESS ) {
        hr = E_ADS_OBJECT_EXISTS;
        BAIL_ON_FAILURE(hr);
    }

    //
    // validate name -->
    //                  must start w/ a-z, A-Z, or underscore
    //                  must only contain a-z, A-Z, 0-9, or underscore
    //

    // check first character
    if (                                                    // if first char is
        (RelativeName[0] < 65 || RelativeName[0] > 90)  &&  // not uppercase letter and
        (RelativeName[0] < 97 || RelativeName[0] > 122) &&  // not lowercase letter and
         RelativeName[0] != 95                              // not underscore
       )                                                    // then bail
    {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }
     
    while (                                                       // while characters are
            (RelativeName[i] >= 65 && RelativeName[i] <= 90)  ||  // uppercase letters or
            (RelativeName[i] >= 97 && RelativeName[i] <= 122) ||  // lowercase letters or
            (RelativeName[i] >= 48 && RelativeName[i] <= 57)  ||  // digits or
             RelativeName[i] == 95                                // underscores
          )                                                       // then things are okay
            i++;

    if (RelativeName[i] != L'\0' || i >= METADATA_MAX_NAME_LEN) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    } 

    if (  ( _wcsicmp( ClassName, CLASS_CLASS_NAME ) == 0 ) )
    {

        //
        // Now, create the class
        //
        hr = CIISClass::CreateClass(
                         _ADsPath,
                         RelativeName,
                         ADS_OBJECT_UNBOUND,
                         IID_IUnknown,
                         (void **) ppObject );
    }
    else if (  ( _wcsicmp( ClassName, PROPERTY_CLASS_NAME ) == 0 ) )
    {

        hr = CIISProperty::CreateProperty(
                         _ADsPath,
                         RelativeName,
                         ADS_OBJECT_UNBOUND,
                         IID_IUnknown,
                         (void **) ppObject );
    }
    else
    {
        hr = E_ADS_BAD_PARAMETER;
    }

error:

    RRETURN(hr);

}

STDMETHODIMP
CIISSchema::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr;
    BOOL bClass;
    METADATA_HANDLE hObjHandle = NULL;

    if (  ( _wcsicmp( bstrClassName, CLASS_CLASS_NAME ) == 0 ) )
    {
        hr = _pSchema->ValidateClassName(bstrRelativeName);
        BAIL_ON_FAILURE(hr);
        bClass = TRUE;

        //
        // remove entry from metabase
        //

        hr = OpenAdminBaseKey(
                    _pszServerName,
                    SCHEMA_CLASS_METABASE_PATH,
                    METADATA_PERMISSION_WRITE,
                    &_pAdminBase,
                    &hObjHandle
                    );
        BAIL_ON_FAILURE(hr);

        hr = MetaBaseDeleteObject(
                    _pAdminBase,
                    hObjHandle,
                    (LPWSTR)bstrRelativeName
                    );
        if (hr == MD_ERROR_DATA_NOT_FOUND) {
            hr = S_OK;
        }
        BAIL_ON_FAILURE(hr);
    }
    else if (  ( _wcsicmp( bstrClassName, PROPERTY_CLASS_NAME ) == 0 ) )
    {
        DWORD dwMetaId;

        hr = _pSchema->ValidatePropertyName(bstrRelativeName);
        BAIL_ON_FAILURE(hr);
        bClass = FALSE;

        //
        // Lookup metaid
        //

        hr = _pSchema->LookupMetaID(bstrRelativeName, &dwMetaId);
        BAIL_ON_FAILURE(hr);

        //
        // remove entry from metabase
        //
        hr = OpenAdminBaseKey(
                    _pszServerName,
                    SCHEMA_PROP_METABASE_PATH,
                    METADATA_PERMISSION_WRITE,
                    &_pAdminBase,
                    &hObjHandle
                    );
        BAIL_ON_FAILURE(hr);

        hr = _pAdminBase->DeleteData(
                              hObjHandle,
                              (LPWSTR)L"Names",
                              dwMetaId,
                              ALL_METADATA
                              );

        if (hr == MD_ERROR_DATA_NOT_FOUND) {
            hr = S_OK;
        }
        BAIL_ON_FAILURE(hr);

        hr = _pAdminBase->DeleteData(
                              hObjHandle,
                              (LPWSTR)L"Types",
                              dwMetaId,
                              ALL_METADATA
                              );

        if (hr == MD_ERROR_DATA_NOT_FOUND) {
            hr = S_OK;
        }
        BAIL_ON_FAILURE(hr);
       
        hr = _pAdminBase->DeleteData(
                              hObjHandle,
                              (LPWSTR)L"Defaults",
                              dwMetaId,
                              ALL_METADATA
                              );

        if (hr == MD_ERROR_DATA_NOT_FOUND) {
            hr = S_OK;
        }
        BAIL_ON_FAILURE(hr);
    }
    else
    {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    //
    // remove entry from schema cache
    //

    hr = _pSchema->RemoveEntry(bClass, bstrRelativeName);

error:

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISSchema::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISSchema::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CIISSchema::AllocateSchemaObject(
    CIISSchema ** ppSchema
    )
{
    CIISSchema FAR * pSchema = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSchema = new CIISSchema();
    if (pSchema == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pSchema,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pSchema,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_IISOle,
                           IID_IISSchemaObject,
                           (IISSchemaObject *)pSchema,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    pSchema->_pDispMgr = pDispMgr;
    *ppSchema = pSchema;

    RRETURN(hr);

error:
    delete pDispMgr;
    delete pSchema;

    RRETURN(hr);

}


STDMETHODIMP
CIISSchema::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CIISSchema::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CIISSchema::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CIISSchema::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CIISSchema::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISSchema::GetSchemaPropertyAttributes(
    THIS_ BSTR bstrName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwMetaId;
    PROPERTYINFO *pPropertyInfo = NULL;
    DWORD i = 0;
    IISPropertyAttribute * pPropAttrib = NULL;
    WCHAR wchName[MAX_PATH];
    VARIANT vVar;

    VariantInit(&vVar);
    *ppObject = NULL;

    //
    // if passed in bstrName is a meta id, then convert it to property name
    //
    if (wcslen(bstrName) >= MAX_PATH) bstrName[MAX_PATH - 1] = L'\0';
    wcscpy((LPWSTR)wchName, bstrName);

    while (wchName[i] != L'\0' && wchName[i] >= L'0' &&
           wchName[i] <= L'9') {
       i++;
    }

    if (i == wcslen((LPWSTR)wchName)) {
        dwMetaId = _wtoi((LPWSTR)wchName);
        hr = _pSchema->ConvertID_To_PropName(dwMetaId, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
    }
    else {

        //
        // check if property is a supported property
        //

        hr = _pSchema->LookupMetaID(wchName, &dwMetaId);
        BAIL_ON_FAILURE(hr);
    }

    //
    // get property attribute value
    //

    pPropertyInfo = _pSchema->GetPropertyInfo(wchName);
    ASSERT(pPropertyInfo != NULL);

    if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_DWORD ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_IPSECLIST ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_NTACL ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BINARY ) {
        vVar.vt = VT_I4;
        vVar.lVal = pPropertyInfo->dwDefault;
    }
    else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
        vVar.vt = VT_BOOL;
        vVar.boolVal = pPropertyInfo->dwDefault ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MULTISZ ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MIMEMAP ) {
        LPWSTR pszStr = pPropertyInfo->szDefault;

        hr = MakeVariantFromStringArray(NULL,
                                        pszStr,
                                        &vVar);
        BAIL_ON_FAILURE(hr);
    }
    else {
        vVar.vt = VT_BSTR;
        hr = ADsAllocString( pPropertyInfo->szDefault, &(vVar.bstrVal));
        BAIL_ON_FAILURE(hr);
    }

    hr = CPropertyAttribute::CreatePropertyAttribute(
                           IID_IISPropertyAttribute,
                           (VOID**)&pPropAttrib
                           );
    BAIL_ON_FAILURE(hr);

    hr = ((CPropertyAttribute*)pPropAttrib)->InitFromRawData(
                           (LPWSTR) wchName,
                           dwMetaId,
                           pPropertyInfo->dwUserGroup,
                           pPropertyInfo->dwMetaFlags,
                           &vVar
                           );
    BAIL_ON_FAILURE(hr);

    *ppObject = (IDispatch*)pPropAttrib;

error:

    VariantClear(&vVar);
    RRETURN(hr);
}

STDMETHODIMP
CIISSchema::PutSchemaPropertyAttributes(
    THIS_ IDispatch * pObject
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\cschema.cxx ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cschema.cxx
//
//  Contents:  Windows NT 4.0
//
//
//  History:   01-09-98     sophiac    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

#define PROP_RW     0x0000001

SCHEMAOBJPROPS g_pClassObjProps[] = {
          {L"PrimaryInterface", IIS_SYNTAX_ID_STRING, CLASS_PRIMARY_INTERFACE},
          {L"CLSID", IIS_SYNTAX_ID_STRING, CLASS_CLSID},
          {L"OID", IIS_SYNTAX_ID_STRING, CLASS_OID},
          {L"Abstract",  IIS_SYNTAX_ID_BOOL, CLASS_ABSTRACT},
          {L"Auxiliary",  IIS_SYNTAX_ID_BOOL, CLASS_AUXILIARY},
          {L"MandatoryProperties", IIS_SYNTAX_ID_STRING, CLASS_MAND_PROPERTIES},
          {L"OptionalProperties", IIS_SYNTAX_ID_STRING, CLASS_OPT_PROPERTIES},
          {L"NamingProperties", IIS_SYNTAX_ID_STRING, CLASS_NAMING_PROPERTIES},
          {L"DerivedFrom", IIS_SYNTAX_ID_STRING, CLASS_DERIVEDFROM},
          {L"AuxDerivedFrom", IIS_SYNTAX_ID_STRING, CLASS_AUX_DERIVEDFROM},
          {L"PossibleSuperiors", IIS_SYNTAX_ID_STRING, CLASS_POSS_SUPERIORS},
          {L"Containment", IIS_SYNTAX_ID_STRING, CLASS_CONTAINMENT},
          {L"Container",  IIS_SYNTAX_ID_BOOL, CLASS_CONTAINER},
          {L"HelpFileName", IIS_SYNTAX_ID_STRING, CLASS_HELPFILENAME},
          {L"HelpFileContext", IIS_SYNTAX_ID_DWORD, CLASS_HELPFILECONTEXT}
        };

SCHEMAOBJPROPS g_pPropertyObjProps[] = {
          {L"OID", IIS_SYNTAX_ID_STRING, PROP_OID},
          {L"Syntax", IIS_SYNTAX_ID_STRING, PROP_SYNTAX},
          {L"MaxRange", IIS_SYNTAX_ID_DWORD, PROP_MAXRANGE},
          {L"MinRange", IIS_SYNTAX_ID_DWORD, PROP_MINRANGE},
          {L"MultiValued", IIS_SYNTAX_ID_BOOL, PROP_MULTIVALUED},
          {L"PropName", IIS_SYNTAX_ID_STRING, PROP_PROPNAME},
          {L"MetaId", IIS_SYNTAX_ID_DWORD, PROP_METAID},
          {L"UserType", IIS_SYNTAX_ID_DWORD, PROP_USERTYPE},
          {L"AllAttributes", IIS_SYNTAX_ID_DWORD, PROP_ALLATTRIBUTES},
          {L"Inherit", IIS_SYNTAX_ID_BOOL, PROP_INHERIT},
          {L"PartialPath", IIS_SYNTAX_ID_BOOL, PROP_PARTIALPATH},
          {L"Secure", IIS_SYNTAX_ID_BOOL, PROP_SECURE},
          {L"Reference", IIS_SYNTAX_ID_BOOL, PROP_REFERENCE},
          {L"Volatile", IIS_SYNTAX_ID_BOOL, PROP_VOLATILE},
          {L"Isinherit", IIS_SYNTAX_ID_BOOL, PROP_ISINHERIT},
          {L"InsertPath", IIS_SYNTAX_ID_BOOL, PROP_INSERTPATH},
          {L"Default", IIS_SYNTAX_ID_STRING_DWORD, PROP_DEFAULT}
        };

DWORD g_cPropertyObjProps (sizeof(g_pPropertyObjProps)/sizeof(SCHEMAOBJPROPS));
DWORD g_cClassObjProps (sizeof(g_pClassObjProps)/sizeof(SCHEMAOBJPROPS));

/******************************************************************/
/*  Class CIISClass
/******************************************************************/

DEFINE_IDispatch_Implementation(CIISClass)
DEFINE_IADs_Implementation(CIISClass)

CIISClass::CIISClass()
    : _pDispMgr( NULL ),
      _bstrCLSID( NULL ),
      _bstrOID( NULL ),
      _bstrPrimaryInterface( NULL ),
      _fAbstract( FALSE ),
      _fContainer( FALSE ),
      _bstrHelpFileName( NULL ),
      _lHelpFileContext( 0 ),
	  _bExistClass(FALSE),
	  _pSchema(NULL),
      _pszServerName(NULL),
      _pszClassName(NULL),
      _pAdminBase(NULL)
{
    VariantInit( &_vMandatoryProperties );
    VariantInit( &_vOptionalProperties );
    VariantInit( &_vPossSuperiors );
    VariantInit( &_vContainment );

    ENLIST_TRACKING(CIISClass);
}

CIISClass::~CIISClass()
{

    if ( _bstrCLSID ) {
        ADsFreeString( _bstrCLSID );
    }

    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrPrimaryInterface ) {
        ADsFreeString( _bstrPrimaryInterface );
    }

    if ( _bstrHelpFileName ) {
        ADsFreeString( _bstrHelpFileName );
    }

    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszClassName) {
        FreeADsStr(_pszClassName);
    }

    VariantClear( &_vMandatoryProperties );
    VariantClear( &_vOptionalProperties );
    VariantClear( &_vPossSuperiors );
    VariantClear( &_vContainment );

    delete _pDispMgr;
}

HRESULT
CIISClass::CreateClass(
    BSTR   bstrParent,
    BSTR   bstrRelative,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CIISClass FAR *pClass = NULL;
    HRESULT hr = S_OK;
    BSTR bstrTmp = NULL;
    CLASSINFO *pClassInfo;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(bstrParent);

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = AllocateClassObject( &pClass );
    BAIL_ON_FAILURE(hr);

    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = InitServerInfo(pObjectInfo->TreeName,
                        &pClass->_pAdminBase,
                        &pClass->_pSchema);
    BAIL_ON_FAILURE(hr);

    pClass->_pszServerName = AllocADsStr(pObjectInfo->TreeName);

    if (!pClass->_pszServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pClass->_pszClassName = AllocADsStr(bstrRelative);

    if (!pClass->_pszClassName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pClassInfo = pClass->_pSchema->GetClassInfo(bstrRelative);

    //
    //  an existing class
    //

    if (pClassInfo) {
  
        pClass->_bExistClass = TRUE;
        pClass->_lHelpFileContext = pClassInfo->lHelpFileContext;
        pClass->_fContainer = (VARIANT_BOOL)pClassInfo->fContainer;
        pClass->_fAbstract = (VARIANT_BOOL)pClassInfo->fAbstract;


        if (pClassInfo->pPrimaryInterfaceGUID) {
            hr = StringFromCLSID( (REFCLSID) *(pClassInfo->pPrimaryInterfaceGUID),
                              &bstrTmp );
            BAIL_ON_FAILURE(hr);

            hr = ADsAllocString( bstrTmp,
                                 &pClass->_bstrPrimaryInterface);
            BAIL_ON_FAILURE(hr);

            CoTaskMemFree(bstrTmp);
            bstrTmp = NULL;
        }

        if (pClassInfo->pCLSID) {
            hr = StringFromCLSID( (REFCLSID) *(pClassInfo->pCLSID),
                                  &bstrTmp );
            BAIL_ON_FAILURE(hr);
    
            hr = ADsAllocString( bstrTmp,
                                 &pClass->_bstrCLSID );
            BAIL_ON_FAILURE(hr);

            CoTaskMemFree(bstrTmp);
            bstrTmp = NULL;
        }

        hr = ADsAllocString( pClassInfo->bstrOID, &pClass->_bstrOID);
        BAIL_ON_FAILURE(hr);

        hr = MakeVariantFromStringList( pClassInfo->bstrMandatoryProperties,
                                        &(pClass->_vMandatoryProperties));
        BAIL_ON_FAILURE(hr);


        hr = MakeVariantFromStringList( pClassInfo->bstrOptionalProperties,
                                        &(pClass->_vOptionalProperties));
        BAIL_ON_FAILURE(hr);

        hr = MakeVariantFromStringList( pClassInfo->bstrPossSuperiors,
                                        &(pClass->_vPossSuperiors));
        BAIL_ON_FAILURE(hr);

        hr = MakeVariantFromStringList( pClassInfo->bstrContainment,
                                        &(pClass->_vContainment));
        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString(pClassInfo->bstrHelpFileName,
                            &pClass->_bstrHelpFileName);
        BAIL_ON_FAILURE(hr);
    }


    hr = pClass->InitializeCoreObject(
         bstrParent,
         bstrRelative,
         CLASS_CLASS_NAME,
         NO_SCHEMA,
         CLSID_IISClass,
         dwObjectState );

    BAIL_ON_FAILURE(hr);

    hr = pClass->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pClass->Release();

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);

error:

    if ( bstrTmp != NULL )
        CoTaskMemFree(bstrTmp);

    *ppvObj = NULL;
    delete pClass;

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);
}


STDMETHODIMP
CIISClass::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsClass FAR * ) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsClass))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* IADs methods */

STDMETHODIMP
CIISClass::SetInfo(THIS)
{
    HRESULT hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = IISCreateObject();
        BAIL_ON_FAILURE(hr);

        //
        // If the create succeeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }

    hr = IISSetObject();
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


/* INTRINSA suppress=null_pointers, uninitialized */
HRESULT
CIISClass::IISSetObject()
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    PMETADATA_RECORD pMetaDataArray = NULL;
    DWORD dwMDNumDataEntries = 0;
    CLASSINFO ClassInfo;
    LPBYTE pBuffer = NULL;

    memset(&ClassInfo, 0, sizeof(CLASSINFO));

    //
    // Add SetObject functionality : sophiac
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = OpenAdminBaseKey(
                _pszServerName,
                SCHEMA_CLASS_METABASE_PATH,
                METADATA_PERMISSION_WRITE,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    hr = MakeStringFromVariantArray(&_vMandatoryProperties, (LPBYTE*)&pBuffer);
    BAIL_ON_FAILURE(hr);
    hr = ValidateProperties((LPWSTR)pBuffer, TRUE);
    BAIL_ON_FAILURE(hr);
    hr = CheckDuplicateNames((LPWSTR)pBuffer);
    BAIL_ON_FAILURE(hr);
    ClassInfo.bstrMandatoryProperties = (BSTR)pBuffer;

    pBuffer = NULL;
    hr = MakeStringFromVariantArray(&_vOptionalProperties, (LPBYTE*)&pBuffer);
    BAIL_ON_FAILURE(hr);
    hr = ValidateProperties((LPWSTR)pBuffer, FALSE);
    BAIL_ON_FAILURE(hr);
    hr = CheckDuplicateNames((LPWSTR)pBuffer);
    BAIL_ON_FAILURE(hr);
    ClassInfo.bstrOptionalProperties = (BSTR)pBuffer;

    pBuffer = NULL;
    hr = MakeStringFromVariantArray(&_vContainment, (LPBYTE*)&pBuffer);
    BAIL_ON_FAILURE(hr);
    hr = ValidateClassNames((LPWSTR)pBuffer);
    BAIL_ON_FAILURE(hr);
    hr = CheckDuplicateNames((LPWSTR)pBuffer);
    BAIL_ON_FAILURE(hr);
    ClassInfo.bstrContainment = (BSTR)pBuffer;

    pBuffer = NULL;
    ClassInfo.fContainer = _fContainer;

    //
    // validate data
    //
  
    if ((ClassInfo.fContainer && !ClassInfo.bstrContainment) ||
        (!ClassInfo.fContainer && ClassInfo.bstrContainment) ) {
        hr = E_ADS_SCHEMA_VIOLATION;
        BAIL_ON_FAILURE(hr);
    }

    // Things are okay, so reset the _v members just incase things have changed
    hr = MakeVariantFromStringList( ClassInfo.bstrMandatoryProperties,
                                    &(_vMandatoryProperties));
    BAIL_ON_FAILURE(hr);
    
    hr = MakeVariantFromStringList( ClassInfo.bstrOptionalProperties,
                                    &(_vOptionalProperties));
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringList( ClassInfo.bstrContainment,
                                    &(_vContainment));
    BAIL_ON_FAILURE(hr);

    hr = IISMarshallClassProperties(
                            &ClassInfo,
                            &pMetaDataArray,
                            &dwMDNumDataEntries
                            );
    BAIL_ON_FAILURE(hr);

    hr = MetaBaseSetAllData(
                _pAdminBase,
                hObjHandle,
                _pszClassName,
                (PMETADATA_RECORD)pMetaDataArray,
                dwMDNumDataEntries
                );
    BAIL_ON_FAILURE(hr);

    // 
    // update schema cache
    // 

    _pSchema->SetClassInfo(_pszClassName, &ClassInfo);
    BAIL_ON_FAILURE(hr);

    _bExistClass = TRUE;

error:

    //
    // if failed to create properties for new class, delete class node
    //

    if (FAILED(hr) && !_bExistClass && hObjHandle) {

        MetaBaseDeleteObject(
                _pAdminBase,
                hObjHandle,
                (LPWSTR)_pszClassName
                );
    }

    if (ClassInfo.bstrOptionalProperties) {
        FreeADsMem(ClassInfo.bstrOptionalProperties);
    }

    if (ClassInfo.bstrMandatoryProperties) {
        FreeADsMem(ClassInfo.bstrMandatoryProperties);
    }

    if (ClassInfo.bstrContainment) {
        FreeADsMem(ClassInfo.bstrContainment);
    }

    if (pBuffer) {
        FreeADsMem(pBuffer);
    }

    if (pMetaDataArray) {
        FreeADsMem(pMetaDataArray);
    }

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

HRESULT
CIISClass::IISCreateObject()
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;

    //
    // Add CreateObject functionality : sophiac
    //

    hr = OpenAdminBaseKey(
                _pszServerName,
                SCHEMA_CLASS_METABASE_PATH,
                METADATA_PERMISSION_WRITE,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    //
    // Pass in full path
    //

    hr = MetaBaseCreateObject(
                _pAdminBase,
                hObjHandle,
                _pszClassName
                );
    BAIL_ON_FAILURE(hr);

error:

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISClass::GetInfo(THIS)
{
    HRESULT hr = S_OK;
    PCLASSINFO pClassInfo = NULL;

    //
    // free up memory first
    //

    VariantClear( &_vMandatoryProperties );
    VariantClear( &_vOptionalProperties );
    VariantClear( &_vContainment );

    //
    // get classinfo from schema cache 
    //

    pClassInfo = _pSchema->GetClassInfo(_pszClassName);

    if (pClassInfo) {
  
        _fContainer = (VARIANT_BOOL)pClassInfo->fContainer;
        hr = MakeVariantFromStringList( pClassInfo->bstrMandatoryProperties,
                                        &_vMandatoryProperties);
        BAIL_ON_FAILURE(hr);


        hr = MakeVariantFromStringList( pClassInfo->bstrOptionalProperties,
                                        &_vOptionalProperties);
        BAIL_ON_FAILURE(hr);


        hr = MakeVariantFromStringList( pClassInfo->bstrContainment,
                                        &_vContainment);
        BAIL_ON_FAILURE(hr);

    }

error:

    RRETURN(hr);
}

/* IADsClass methods */

STDMETHODIMP
CIISClass::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwID;

    //
    // check if property is a supported property
    //

    hr = ValidateClassObjProps(bstrName, &dwSyntaxId, &dwID);
    BAIL_ON_FAILURE(hr);

    switch(dwID) {
    case CLASS_OPT_PROPERTIES:
        hr = get_OptionalProperties(pvProp);
        break;
    case CLASS_CONTAINMENT: 
        hr = get_Containment(pvProp);
        break;
    case CLASS_CONTAINER:
        pvProp->vt = VT_BOOL;
        pvProp->boolVal = _fContainer? VARIANT_TRUE : VARIANT_FALSE;
        break;
    default:
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
    }

error:

    RRETURN(hr);
}


HRESULT
CIISClass::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwID;

    VARIANT vVar;

    //
    // check if property is a supported property and 
    // loop up its syntax id
    //

    hr = ValidateClassObjProps(bstrName, &dwSyntaxId, &dwID);
    BAIL_ON_FAILURE(hr);

    VariantInit(&vVar);
    VariantCopyInd(&vVar, &vProp);

    //
    // update both classinfo and member variables
    //

    switch(dwID) {
    case CLASS_OPT_PROPERTIES:
        if (vVar.vt != VT_EMPTY &&
            !((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar))) {
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            BAIL_ON_FAILURE(hr);
        }
        VariantCopy(&_vOptionalProperties, &vVar);
        break;

    case CLASS_CONTAINMENT: 
        if (vVar.vt != VT_EMPTY &&
            !((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar))) {
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            BAIL_ON_FAILURE(hr);
        }
        VariantCopy(&_vContainment, &vVar);
        break;

    case CLASS_CONTAINER:
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        _fContainer = (vProp.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
        break;

    default:
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
    }

error:

    VariantClear(&vVar);

    RRETURN(hr);
}


STDMETHODIMP
CIISClass::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;

    //
    // Get and GetEx are the same for class schema object
    //

    hr = Get(bstrName, pvProp);
    RRETURN(hr);
}


STDMETHODIMP
CIISClass::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CIISClass::ValidateProperties(
    LPWSTR pszList,
    BOOL bMandatory
    )
{
    WCHAR *pszNewList;
    WCHAR szName[MAX_PATH];
    LPWSTR ObjectList = (LPWSTR)pszList;
    HRESULT hr;

    if (pszList == NULL) RRETURN(S_OK);

    // need to allocate +2 = 1 for null, 1 for extra comma
    pszNewList = new WCHAR[wcslen(pszList)+2];

    if (pszNewList == NULL) RRETURN(E_OUTOFMEMORY);

    wcscpy(pszNewList, L"");

    while ((ObjectList = grabProp(szName, ObjectList)) != NULL) {
        if (*szName != L'\0') {
            hr = _pSchema->ValidatePropertyName(szName);
            if (hr == E_ADS_PROPERTY_NOT_SUPPORTED) {
            
                hr = PropertyInMetabase(szName, bMandatory);
            }
            else {

                // form the new list
                wcscat(pszNewList, szName);
                wcscat(pszNewList, L",");
            }

            BAIL_ON_FAILURE(hr);  // if it's a legit bad name
        }
    }

    // get rid of the last comma
    pszNewList[wcslen(pszNewList) - 1] = 0;

    wcscpy(pszList, pszNewList);

    delete [] pszNewList;
    RRETURN(S_OK);

error: 

    //
    // return E_ADS_SCHEMA_VIOLATION if property not found in global list
    //

    delete [] pszNewList;
    RRETURN(E_ADS_SCHEMA_VIOLATION);
}

HRESULT
CIISClass::PropertyInMetabase( 
    LPWSTR szPropName,
    BOOL bMandatory 
    )
{
    // Oops - somethings wrong.  What do we do?  Depends...
    //
    // Check to see if the bad property name exists in the associated list
    // in the metabase.
    //
    // If so (case 1), then we are trying to SetInfo after having deleted a property from
    // the schema - so just silently remove the name from metabase & the cached class.
    //
    // If not (case 2), we are trying to SetInfo w/ a bogus property name, 
    // so throw an exception.

    HRESULT hr = E_ADS_PROPERTY_NOT_SUPPORTED;
    CLASSINFO *pClassInfo;
    LPWSTR ObjectList;
    WCHAR szTestProp[MAX_PATH];

    pClassInfo = _pSchema->GetClassInfo(_pszClassName);

    if (pClassInfo == NULL) {
        RRETURN(hr);
    }

    if (bMandatory == TRUE) {
        ObjectList = pClassInfo->bstrMandatoryProperties;
    }
    else {
        ObjectList = pClassInfo->bstrOptionalProperties;
    }

    while ((ObjectList = grabProp(szTestProp, ObjectList)) != NULL) {
        if (wcscmp(szTestProp, szPropName) == 0) {
        
            hr = S_OK;  // clear the error - we'll fix it (case 1)
        }
    }

    RRETURN(hr);
}

HRESULT
CIISClass::ValidateClassNames(
    LPWSTR pszList
    )
{
    WCHAR szName[MAX_PATH];
    LPWSTR ObjectList = (LPWSTR)pszList;
    HRESULT hr;

    while ((ObjectList = grabProp(szName, ObjectList)) != NULL) {
        if (*szName != L'\0') {
            hr = _pSchema->ValidateClassName(szName);
            if (FAILED(hr)) {
                if (_wcsicmp(szName, _pszClassName)) {
                    BAIL_ON_FAILURE(hr);
                }
            }
        }

    }

    RRETURN(S_OK);

error: 

    //
    // return E_ADS_SCHEMA_VIOLATION if classname not found in global list
    //

    RRETURN(E_ADS_SCHEMA_VIOLATION);
}

STDMETHODIMP
CIISClass::get_PrimaryInterface( THIS_ BSTR FAR *pbstrGUID )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_CLSID( THIS_ BSTR FAR *pbstrCLSID )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_CLSID( THIS_ BSTR bstrCLSID )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_Abstract( THIS_ VARIANT_BOOL FAR *pfAbstract )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_Abstract( THIS_ VARIANT_BOOL fAbstract )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_Auxiliary( THIS_ VARIANT_BOOL FAR *pfAuxiliary)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_Auxiliary( THIS_ VARIANT_BOOL fAuxiliary )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_NamingProperties( THIS_ VARIANT FAR *retval )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_NamingProperties( THIS_ VARIANT vNamingProperties )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_MandatoryProperties( THIS_ VARIANT FAR *retval )
{
    if ( !retval )
        RRETURN(E_ADS_BAD_PARAMETER);

    VariantInit( retval );

    RRETURN(VariantCopy(retval, &_vMandatoryProperties));
}

STDMETHODIMP
CIISClass::put_MandatoryProperties( THIS_ VARIANT vMandatoryProperties )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_OptionalProperties( THIS_ VARIANT FAR *retval )
{
    if ( !retval )
        RRETURN(E_ADS_BAD_PARAMETER);

    VariantInit( retval );

    RRETURN(VariantCopy(retval, &_vOptionalProperties));
}

STDMETHODIMP
CIISClass::put_OptionalProperties( THIS_ VARIANT vOptionalProperties )
{
    HRESULT hr = put_VARIANT_Property( this, TEXT("OptionalProperties"),
                                       vOptionalProperties );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        hr = E_NOTIMPL;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISClass::get_DerivedFrom( THIS_ VARIANT FAR *pvDerivedFrom )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_DerivedFrom( THIS_ VARIANT vDerivedFrom )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_AuxDerivedFrom( THIS_ VARIANT FAR *pvAuxDerivedFrom )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_AuxDerivedFrom( THIS_ VARIANT vAuxDerivedFrom )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_PossibleSuperiors( THIS_ VARIANT FAR *pvPossSuperiors )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_PossibleSuperiors( THIS_ VARIANT vPossSuperiors )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_Containment( THIS_ VARIANT FAR *pvContainment )
{
    if ( !pvContainment )
        RRETURN(E_ADS_BAD_PARAMETER);
    VariantInit( pvContainment );
    RRETURN( VariantCopy( pvContainment, &_vContainment ));
}

STDMETHODIMP
CIISClass::put_Containment( THIS_ VARIANT vContainment )
{
    HRESULT hr = put_VARIANT_Property( this, TEXT("Containment"),
                                       vContainment );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        hr = E_NOTIMPL;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISClass::get_Container( THIS_ VARIANT_BOOL FAR *pfContainer )
{
    if ( !pfContainer )
        RRETURN(E_ADS_BAD_PARAMETER);

    *pfContainer = _fContainer? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISClass::put_Container( THIS_ VARIANT_BOOL fContainer )
{
    HRESULT hr = put_VARIANT_BOOL_Property( this, TEXT("Container"),
                                       fContainer );
    RRETURN(hr);
}

STDMETHODIMP
CIISClass::get_HelpFileName( THIS_ BSTR FAR *pbstrHelpFileName )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_HelpFileName( THIS_ BSTR bstrHelpFile )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_HelpFileContext( THIS_ long FAR *plHelpContext )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_HelpFileContext( THIS_ long lHelpContext )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CIISClass::AllocateClassObject(CIISClass FAR * FAR * ppClass)
{

    CIISClass FAR  *pClass = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pClass = new CIISClass();
    if ( pClass == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADsClass,
                            (IADsClass *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pClass->_pDispMgr = pDispMgr;
    *ppClass = pClass;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pClass;

    RRETURN(hr);

}

/******************************************************************/
/*  Class CIISProperty
/******************************************************************/

DEFINE_IDispatch_Implementation(CIISProperty)
DEFINE_IADs_Implementation(CIISProperty)

CIISProperty::CIISProperty()
    : _pDispMgr( NULL ),
      _bstrOID( NULL ),
      _bstrSyntax( NULL ),
      _lMaxRange( 0 ),
      _lMinRange( 0 ),
      _fMultiValued( FALSE ),
      _lMetaId( 0 ),
      _lUserType(IIS_MD_UT_SERVER ),
      _lAllAttributes( 0),
      _dwSyntaxId( IIS_SYNTAX_ID_DWORD ),
      _dwFlags( PROP_RW ),
      _dwMask( 0 ),
      _dwPropID( 0 ),
	  _bExistProp(FALSE),
	  _pSchema(NULL),
      _pszServerName(NULL),
      _pszPropName(NULL),
      _pAdminBase(NULL)
{

    VariantInit(&_vDefault);

    ADsAllocString(L"Integer", &_bstrSyntax);
    
    ENLIST_TRACKING(CIISProperty);
}

CIISProperty::~CIISProperty()
{
    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrSyntax ) {
        ADsFreeString( _bstrSyntax );
    }

    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszPropName) {
        FreeADsStr(_pszPropName);
    }

    VariantClear( &_vDefault );
    delete _pDispMgr;
}

/* #pragma INTRINSA suppress=all */
HRESULT
CIISProperty::CreateProperty(
    BSTR   bstrParent,
    BSTR   bstrRelative,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CIISProperty FAR * pProperty = NULL;
    HRESULT hr = S_OK;
    PROPERTYINFO *pPropertyInfo;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = NULL;
    CLexer Lexer(bstrParent);

    hr = AllocatePropertyObject( &pProperty );
    BAIL_ON_FAILURE(hr);

    pObjectInfo = &ObjectInfo;
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = InitServerInfo(pObjectInfo->TreeName,
                        &pProperty->_pAdminBase,
                        &pProperty->_pSchema);
    BAIL_ON_FAILURE(hr);

    pProperty->_pszServerName = AllocADsStr(pObjectInfo->TreeName);

    if (!pProperty->_pszServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pProperty->_pszPropName = AllocADsStr(bstrRelative);

    if (!pProperty->_pszPropName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pPropertyInfo = pProperty->_pSchema->GetPropertyInfo(bstrRelative);

    if (pPropertyInfo) {

        LPWSTR pszSyntax;

        pProperty->_bExistProp = TRUE;
        hr = ADsAllocString( pPropertyInfo->bstrOID, &pProperty->_bstrOID);
        BAIL_ON_FAILURE(hr);

        pProperty->_lMaxRange = pPropertyInfo->lMaxRange;
        pProperty->_lMinRange = pPropertyInfo->lMinRange;
        pProperty->_fMultiValued  = (VARIANT_BOOL)pPropertyInfo->fMultiValued;

        pProperty->_lMetaId = pPropertyInfo->dwMetaID;
        pProperty->_lUserType = pPropertyInfo->dwUserGroup;
        pProperty->_lAllAttributes = pPropertyInfo->dwMetaFlags;
        pProperty->_dwSyntaxId = pPropertyInfo->dwSyntaxId;
        pProperty->_dwFlags = pPropertyInfo->dwFlags;
        pProperty->_dwMask = pPropertyInfo->dwMask;
        pProperty->_dwPropID = pPropertyInfo->dwPropID;

        pszSyntax = SyntaxIdToString(pProperty->_dwSyntaxId);
        hr = ADsAllocString(pszSyntax, &(pProperty->_bstrSyntax));
        BAIL_ON_FAILURE(hr);

        if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_DWORD ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_IPSECLIST ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_NTACL ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BINARY ) {
            (pProperty->_vDefault).vt = VT_I4;
            (pProperty->_vDefault).lVal = pPropertyInfo->dwDefault;
        }
        else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
            (pProperty->_vDefault).vt = VT_BOOL;
            (pProperty->_vDefault).boolVal = 
                  pPropertyInfo->dwDefault ? VARIANT_TRUE : VARIANT_FALSE;
        }
        else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MULTISZ ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MIMEMAP ) {
            LPWSTR pszStr = pPropertyInfo->szDefault;

            hr = MakeVariantFromStringArray(NULL,
                                            pszStr,
                                            &(pProperty->_vDefault));
            BAIL_ON_FAILURE(hr);
        }
        else {
            (pProperty->_vDefault).vt = VT_BSTR;
            hr = ADsAllocString( pPropertyInfo->szDefault, 
                                 &(pProperty->_vDefault.bstrVal));
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = pProperty->InitializeCoreObject(
             bstrParent,
             bstrRelative,
             PROPERTY_CLASS_NAME,
             NO_SCHEMA,
             CLSID_IISProperty,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    hr = pProperty->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pProperty->Release();

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);

error:

    *ppvObj = NULL;

    delete pProperty;

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);
}

STDMETHODIMP
CIISProperty::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IISSchemaObject))
    {
        *ppv = (IISSchemaObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsProperty))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* IADs methods */

STDMETHODIMP
CIISProperty::SetInfo(THIS)
{
    HRESULT hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        //
        // fill in all unset fields
        //

        // User set an explicit the MetaID for a new object
        // we need to validate it.
        if( _lMetaId != 0 &&
            !IsMetaIdAvailable( _lMetaId ) 
            )
        {
            return E_ADS_SCHEMA_VIOLATION;
        }

        if (!_bstrSyntax) {
            LPWSTR pszSyntax;
            pszSyntax = SyntaxIdToString(_dwSyntaxId);
            hr = ADsAllocString(pszSyntax, &_bstrSyntax);
            BAIL_ON_FAILURE(hr);
        }

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }

    hr = IISSetObject();
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

HRESULT
CIISProperty::IISSetObject()
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    METADATA_RECORD mdr;
    PropValue pv;
    PROPERTYINFO PropertyInfo;

    memset(&PropertyInfo, 0, sizeof(PROPERTYINFO));

    //
    // Add SetObject functionality : sophiac
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    //
    // validate data
    //

    switch(_dwSyntaxId) {
    case IIS_SYNTAX_ID_DWORD:
        if (_vDefault.vt != VT_EMPTY) {
            hr = CheckVariantDataType(&_vDefault, VT_I4);
            if (FAILED(hr)) {
                hr = E_ADS_SCHEMA_VIOLATION;
            }
            BAIL_ON_FAILURE(hr);
        }
        if (_lMaxRange < _lMinRange) {
            hr = E_ADS_SCHEMA_VIOLATION;
            BAIL_ON_FAILURE(hr);
        }
        break;

    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
        if ((_vDefault.vt != VT_EMPTY && _vDefault.vt != VT_BOOL) ||
            _lMaxRange != 0 || _lMinRange != 0 ) {
            hr = E_ADS_SCHEMA_VIOLATION;
            BAIL_ON_FAILURE(hr);
        }
        break;

    case IIS_SYNTAX_ID_STRING:
    case IIS_SYNTAX_ID_EXPANDSZ:
        if ((_vDefault.vt != VT_EMPTY && _vDefault.vt != VT_BSTR) ||
            _lMaxRange != 0 || _lMinRange != 0 ) {
            hr = E_ADS_SCHEMA_VIOLATION;
            BAIL_ON_FAILURE(hr);
        }
        break;

    case IIS_SYNTAX_ID_MIMEMAP: 
    case IIS_SYNTAX_ID_MULTISZ:
        if ((_vDefault.vt != VT_EMPTY &&
             _vDefault.vt != VT_VARIANT &&
             !((V_VT(&_vDefault) & VT_VARIANT) && V_ISARRAY(&_vDefault))) ||
            _lMaxRange != 0 || _lMinRange != 0 ) {
            hr = E_ADS_SCHEMA_VIOLATION;
            BAIL_ON_FAILURE(hr);
        }
        break;

    case IIS_SYNTAX_ID_IPSECLIST:     
        if (_vDefault.vt != VT_EMPTY || _lMaxRange != 0 ||  _lMinRange != 0 ) {
            hr = E_ADS_SCHEMA_VIOLATION;
            BAIL_ON_FAILURE(hr);
        }
        break;

    case IIS_SYNTAX_ID_BINARY:         
    case IIS_SYNTAX_ID_NTACL:
        if (_vDefault.vt != VT_EMPTY || _lMaxRange != 0 ||  _lMinRange != 0 ) {
            hr = E_ADS_SCHEMA_VIOLATION;
            BAIL_ON_FAILURE(hr);
        }
        break;

    default:
        break;

    }

    //
    // set property Default values
    //

    PropertyInfo.lMaxRange = _lMaxRange;
    PropertyInfo.lMinRange = _lMinRange;
    PropertyInfo.fMultiValued = _fMultiValued;
    PropertyInfo.dwFlags = _dwFlags;
    PropertyInfo.dwSyntaxId = _dwSyntaxId;
    PropertyInfo.dwMask = _dwMask;   
    PropertyInfo.dwMetaFlags = _lAllAttributes;
    PropertyInfo.dwUserGroup = _lUserType;

    hr = ConvertDefaultValue(&_vDefault, &PropertyInfo);
    BAIL_ON_FAILURE(hr);

    hr = SetMetaID();
    BAIL_ON_FAILURE(hr);

    PropertyInfo.dwMetaID = _lMetaId;
    PropertyInfo.dwPropID = _dwPropID; 

    hr = OpenAdminBaseKey(
                _pszServerName,
                SCHEMA_PROP_METABASE_PATH,
                METADATA_PERMISSION_WRITE,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    //
    // set property name under Properties/Names
    //

    MD_SET_DATA_RECORD(&mdr,
                       (DWORD)_lMetaId,
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       STRING_METADATA,
                       (wcslen((LPWSTR)_pszPropName)+1)*2,
                       (unsigned char *)_pszPropName);

    hr = _pAdminBase->SetData(hObjHandle, L"Names", &mdr);
    BAIL_ON_FAILURE(hr);

    //
    // set property attributes/types under Properties/Types
    //

    InitPropValue(&pv, &PropertyInfo);
    mdr.dwMDDataType = BINARY_METADATA;
    mdr.dwMDDataLen = sizeof(PropValue);
    mdr.pbMDData = (unsigned char *)&pv;
    hr = _pAdminBase->SetData(hObjHandle, L"Types", &mdr);
    BAIL_ON_FAILURE(hr);

    DataForSyntaxID(&PropertyInfo, &mdr);
    hr = _pAdminBase->SetData(hObjHandle, L"Defaults", &mdr);
    BAIL_ON_FAILURE(hr);

    //
    //  update schema cache
    //

    hr = _pSchema->SetPropertyInfo(_pszPropName, &PropertyInfo);
    BAIL_ON_FAILURE(hr);

    _bExistProp = TRUE;

error:

    if (PropertyInfo.szDefault) {
        if (PropertyInfo.dwSyntaxId == IIS_SYNTAX_ID_STRING ||
            PropertyInfo.dwSyntaxId == IIS_SYNTAX_ID_EXPANDSZ) {
            FreeADsStr(PropertyInfo.szDefault );
        }
        else if (PropertyInfo.dwSyntaxId == IIS_SYNTAX_ID_MULTISZ) {
            FreeADsMem(PropertyInfo.szDefault );
        }
    }

    //
    // if validation failed and new prop, delete class node
    //

    if (FAILED(hr) && !_bExistProp && hObjHandle) {

        _pAdminBase->DeleteData(
                         hObjHandle,
                         (LPWSTR)L"Names",
                         _lMetaId,
                         ALL_METADATA
                         );
        _pAdminBase->DeleteData(
                         hObjHandle,
                         (LPWSTR)L"Types",
                         _lMetaId,
                         ALL_METADATA
                         );
        _pAdminBase->DeleteData(
                         hObjHandle,
                         (LPWSTR)L"Defaults",
                         _lMetaId,
                         ALL_METADATA
                         );
    }

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISProperty::GetInfo(THIS)
{
    HRESULT hr = S_OK;
    PROPERTYINFO *pPropertyInfo = NULL;

    //
    // free up memory first
    //

    VariantClear( &_vDefault );

    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrSyntax ) {
        ADsFreeString( _bstrSyntax );
    }

    pPropertyInfo = _pSchema->GetPropertyInfo(_pszPropName);

    if (pPropertyInfo) {

        hr = ADsAllocString( pPropertyInfo->bstrOID, &_bstrOID);
        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString( pPropertyInfo->bstrSyntax, &_bstrSyntax);
        BAIL_ON_FAILURE(hr);

        _lMaxRange = pPropertyInfo->lMaxRange;
        _lMinRange = pPropertyInfo->lMinRange;
        _fMultiValued  = (VARIANT_BOOL)pPropertyInfo->fMultiValued;

        _lMetaId = pPropertyInfo->dwMetaID;
        _lUserType = pPropertyInfo->dwUserGroup;
        _lAllAttributes = pPropertyInfo->dwMetaFlags;
        _dwSyntaxId = pPropertyInfo->dwSyntaxId;
        _dwFlags = pPropertyInfo->dwFlags;
        _dwMask = pPropertyInfo->dwMask;
        _dwPropID = pPropertyInfo->dwPropID;

        if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_DWORD ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_IPSECLIST ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_NTACL ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BINARY ) {
            _vDefault.vt = VT_I4;
            _vDefault.lVal = pPropertyInfo->dwDefault;
        }
        else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
            _vDefault.vt = VT_BOOL;
            _vDefault.boolVal =
                  pPropertyInfo->dwDefault ? VARIANT_TRUE : VARIANT_FALSE;
        }
        else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MULTISZ ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MIMEMAP ) {
            LPWSTR pszStr = pPropertyInfo->szDefault;

            hr = MakeVariantFromStringArray(NULL,
                                            pszStr,
                                            &_vDefault);
            BAIL_ON_FAILURE(hr);
        }
        else {
            _vDefault.vt = VT_BSTR;
            hr = ADsAllocString( pPropertyInfo->szDefault, &(_vDefault.bstrVal));
            BAIL_ON_FAILURE(hr);
        }
    }

error:

    RRETURN(hr);
}

STDMETHODIMP
CIISProperty::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwID;

    //
    // check if property is a supported property
    //

    hr = ValidatePropertyObjProps(bstrName, &dwSyntaxId, &dwID);
    BAIL_ON_FAILURE(hr);

    switch(dwID) {
    case PROP_SYNTAX:
        pvProp->vt = VT_BSTR;
        hr = ADsAllocString( _bstrSyntax, &pvProp->bstrVal);
        break;

    case PROP_MAXRANGE:
        pvProp->vt = VT_I4;
        pvProp->lVal = _lMaxRange;
        break;

    case PROP_MINRANGE:
        pvProp->vt = VT_I4;
        pvProp->lVal = _lMinRange;
        break;

    case PROP_MULTIVALUED:
        pvProp->vt = VT_BOOL;
        pvProp->boolVal = _fMultiValued? VARIANT_TRUE : VARIANT_FALSE;
        break;

    case PROP_PROPNAME:                      
        pvProp->vt = VT_BSTR;
        hr = ADsAllocString( _pszPropName, &pvProp->bstrVal);
        break;

    case PROP_METAID:                           
        if (_lMetaId == 0) {
            hr = E_ADS_PROPERTY_NOT_SET;
        }
        else {
            pvProp->vt = VT_I4;
            pvProp->lVal = _lMetaId;
        }
        break;

    case PROP_USERTYPE:                         
        pvProp->vt = VT_I4;
        pvProp->lVal = _lUserType;
        break;

    case PROP_ALLATTRIBUTES:                    
        pvProp->vt = VT_I4;
        pvProp->lVal = _lAllAttributes;
        break;

    case PROP_INHERIT:                          
        pvProp->vt = VT_BOOL;
        pvProp->boolVal = _lAllAttributes & METADATA_INHERIT ?
                                     VARIANT_TRUE : VARIANT_FALSE;
        break;

    case PROP_SECURE:                           
        pvProp->vt = VT_BOOL;
        pvProp->boolVal = _lAllAttributes & METADATA_SECURE ?
                                     VARIANT_TRUE : VARIANT_FALSE;
        break;

    case PROP_REFERENCE:                        
        pvProp->vt = VT_BOOL;
        pvProp->boolVal = _lAllAttributes & METADATA_REFERENCE ?
                                     VARIANT_TRUE : VARIANT_FALSE;
        break;

    case PROP_VOLATILE:                         
        pvProp->vt = VT_BOOL;
        pvProp->boolVal = _lAllAttributes & METADATA_VOLATILE ?
                                     VARIANT_TRUE : VARIANT_FALSE;
        break;

    case PROP_INSERTPATH:                      
        pvProp->vt = VT_BOOL;
        pvProp->boolVal = _lAllAttributes & METADATA_INSERT_PATH ?
                                     VARIANT_TRUE : VARIANT_FALSE;
        break;

    case PROP_DEFAULT:                          
        VariantCopy(pvProp, &_vDefault);
        break;

    default:
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
    }

error:

    RRETURN(hr);
}


HRESULT
CIISProperty::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwID;             
    VARIANT vVar;


    //
    // check if property is a supported property
    //

    hr = ValidatePropertyObjProps(bstrName, &dwSyntaxId, &dwID);
    BAIL_ON_FAILURE(hr);

    switch(dwID) {
    case PROP_SYNTAX:
        if (_bExistProp) {
            hr = E_ADS_SCHEMA_VIOLATION;
            BAIL_ON_FAILURE(hr);
        }

        hr = ValidateSyntaxName(vProp.bstrVal, &dwSyntaxId);
        BAIL_ON_FAILURE(hr);
        hr = ADsReAllocString( &_bstrSyntax,
                               vProp.bstrVal ? vProp.bstrVal: TEXT("") );
        BAIL_ON_FAILURE(hr);
        _dwSyntaxId = dwSyntaxId;
        if (_dwSyntaxId == IIS_SYNTAX_ID_MIMEMAP ||
            _dwSyntaxId == IIS_SYNTAX_ID_MULTISZ) {
            _fMultiValued = VARIANT_TRUE;
        }

        break;

    case PROP_MAXRANGE:
        hr = CheckVariantDataType(&vProp, VT_I4);
        BAIL_ON_FAILURE(hr);
        _lMaxRange = vProp.lVal;
        break;

    case PROP_MINRANGE:
        hr = CheckVariantDataType(&vProp, VT_I4);
        BAIL_ON_FAILURE(hr);
        _lMinRange = vProp.lVal;
        break;

    case PROP_USERTYPE:                         
        hr = CheckVariantDataType(&vProp, VT_I4);
        BAIL_ON_FAILURE(hr);
        _lUserType = vProp.lVal;
        break;

    case PROP_INHERIT:
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        if (vProp.boolVal == VARIANT_TRUE) {
            _lAllAttributes |= METADATA_INHERIT;
        }
        else {
            _lAllAttributes &= ~METADATA_INHERIT;
        }
        break;

    case PROP_PARTIALPATH:                      
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        if (vProp.boolVal == VARIANT_TRUE) {
            _lAllAttributes |= METADATA_PARTIAL_PATH;
        }
        else {
            _lAllAttributes &= ~METADATA_PARTIAL_PATH;
        }
        break;

    case PROP_SECURE:                           
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        if (vProp.boolVal == VARIANT_TRUE) {
            _lAllAttributes |= METADATA_SECURE;
        }
        else {
            _lAllAttributes &= ~METADATA_SECURE;
        }
        break;

    case PROP_REFERENCE:                        
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        if (vProp.boolVal == VARIANT_TRUE) {
            _lAllAttributes |= METADATA_REFERENCE;
        }
        else {
            _lAllAttributes &= ~METADATA_REFERENCE;
        }
        break;

    case PROP_VOLATILE:                         
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        if (vProp.boolVal == VARIANT_TRUE) {
            _lAllAttributes |= METADATA_VOLATILE;
        }
        else {
            _lAllAttributes &= ~METADATA_VOLATILE;
        }
        break;

    case PROP_ISINHERIT:                        
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        if (vProp.boolVal == VARIANT_TRUE) {
            _lAllAttributes |= METADATA_ISINHERITED;
        }
        else {
            _lAllAttributes &= ~METADATA_ISINHERITED;
        }
        break;

    case PROP_INSERTPATH:                      
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        if (vProp.boolVal == VARIANT_TRUE) {
            _lAllAttributes |= METADATA_INSERT_PATH;
        }
        else {
            _lAllAttributes &= ~METADATA_INSERT_PATH;
        }
        break;

    case PROP_DEFAULT:                          
        VariantInit(&vVar);
        VariantCopyInd(&vVar, &vProp);

        VariantClear( &_vDefault );
        _vDefault = vVar;
        break;

    case PROP_METAID:
        hr = CheckVariantDataType(&vProp, VT_I4);
        BAIL_ON_FAILURE(hr);
        hr = put_MetaId( vProp.lVal );
        break;

    default:
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
    }

error:

    RRETURN(hr);
}


STDMETHODIMP
CIISProperty::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;

    //
    // Get and GetEx are the same for property schema object
    //

    hr = Get(bstrName, pvProp);
    RRETURN(hr);
}


STDMETHODIMP
CIISProperty::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CIISProperty::ConvertDefaultValue(
    PVARIANT pVar,
    PROPERTYINFO *pPropInfo
    )
{
    HRESULT hr = S_OK;
    LPBYTE *pBuffer;

    if (pVar->vt != VT_EMPTY) {
        if (pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_DWORD ||
            pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_IPSECLIST ||
            pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_NTACL ||
            pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_BINARY ) {
            pPropInfo->dwDefault = (DWORD)pVar->lVal;
        }
        else if (pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL ||
            pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
            pPropInfo->dwDefault = pVar->boolVal ? 1 : 0;
        }
        else if (pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_MULTISZ ||
            pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_MIMEMAP ) {
            hr = MakeMultiStringFromVariantArray(pVar, 
                                                 (LPBYTE*)&pBuffer);
            BAIL_ON_FAILURE(hr);
    
            pPropInfo->szDefault = (LPWSTR) pBuffer;
        }
        else {
            if (pVar->vt == VT_BSTR && pVar->bstrVal && *(pVar->bstrVal)) {
                pPropInfo->szDefault = AllocADsStr(pVar->bstrVal);
    
                if (!pPropInfo->szDefault) {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }
            }
        }
    }

error:

    RRETURN(hr);
}

HRESULT
CIISProperty::ValidateSyntaxName(
    LPWSTR pszName,
    PDWORD pdwSyntax
    )
{
    HRESULT hr = S_OK;
    DWORD i;

    //
    // Look for the given syntax name
    //

    for ( i = 0; i < g_cIISSyntax; i++ )
    {
         if ( _wcsicmp( g_aIISSyntax[i].bstrName, pszName ) == 0 ) {
             *pdwSyntax = g_aIISSyntax[i].dwIISSyntaxId;
             RRETURN(S_OK);
         }
    }

    RRETURN(E_ADS_BAD_PARAMETER);
}


/* IADsProperty methods */


STDMETHODIMP
CIISProperty::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISProperty::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISProperty::get_Syntax( THIS_ BSTR FAR *pbstrSyntax )
{
    if ( !pbstrSyntax )
        RRETURN(E_ADS_BAD_PARAMETER);

    RRETURN( ADsAllocString( _bstrSyntax, pbstrSyntax ));

}

STDMETHODIMP
CIISProperty::put_Syntax( THIS_ BSTR bstrSyntax )
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    HRESULT hr;
    DWORD dwSyntaxId;

    if (_bExistProp) {
        RRETURN(E_ADS_SCHEMA_VIOLATION);
    }

    hr = ValidateSyntaxName(bstrSyntax, &dwSyntaxId);
    BAIL_ON_FAILURE(hr);

    hr = ADsReAllocString( &_bstrSyntax, bstrSyntax);
    BAIL_ON_FAILURE(hr);
    _dwSyntaxId = dwSyntaxId;

    if (_dwSyntaxId == IIS_SYNTAX_ID_MIMEMAP ||
        _dwSyntaxId == IIS_SYNTAX_ID_MULTISZ) {
        _fMultiValued = VARIANT_TRUE;
    }

error:

    RRETURN(hr);
}

STDMETHODIMP
CIISProperty::get_MaxRange( THIS_ long FAR *plMaxRange )
{
    if ( !plMaxRange )
        RRETURN(E_ADS_BAD_PARAMETER);

    *plMaxRange = _lMaxRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_MaxRange( THIS_ long lMaxRange )
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    _lMaxRange = lMaxRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_MinRange( THIS_ long FAR *plMinRange )
{
    if ( !plMinRange )
        RRETURN(E_ADS_BAD_PARAMETER);

    *plMinRange = _lMinRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_MinRange( THIS_ long lMinRange )
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    _lMinRange = lMinRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_MultiValued( THIS_ VARIANT_BOOL FAR *pfMultiValued )
{
    if ( !pfMultiValued )
        RRETURN(E_ADS_BAD_PARAMETER);

    *pfMultiValued = _fMultiValued;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_MultiValued( THIS_ VARIANT_BOOL fMultiValued )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISProperty::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CIISProperty::AllocatePropertyObject(CIISProperty FAR * FAR * ppProperty)
{
    CIISProperty FAR *pProperty = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pProperty = new CIISProperty();
    if ( pProperty == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADsProperty,
                            (IADsProperty *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_IISOle,
                           IID_IISPropertyAttribute,
                           (IISPropertyAttribute *)pProperty,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    pProperty->_pDispMgr = pDispMgr;
    *ppProperty = pProperty;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pProperty;

    RRETURN(hr);

}

STDMETHODIMP
CIISProperty::get_PropName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString((LPWSTR)_pszPropName, retval);
    RRETURN(hr);
}

STDMETHODIMP
CIISProperty::get_MetaId(THIS_ LONG FAR * retval)
{
    HRESULT hr = S_OK;

    if (_lMetaId == 0) {
        hr = E_ADS_PROPERTY_NOT_SET;
    }
    else {
        *retval = _lMetaId;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISProperty::put_MetaId(THIS_ LONG lMetaId)
{
    if (GetObjectState() != ADS_OBJECT_UNBOUND) 
    {
        // Only valid for unsaved objects
        RRETURN( E_ADS_OBJECT_EXISTS );
    }
    if( lMetaId < 0 )
    {
        // Never a valid metabase id
        RRETURN( E_ADS_BAD_PARAMETER );
    }
    if( !IsMetaIdAvailable( (DWORD)lMetaId ) )
    {
        // This id is already in use
        RRETURN( E_ADS_SCHEMA_VIOLATION );
    }

     _lMetaId = (DWORD)lMetaId;
     RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_UserType(THIS_ LONG FAR * retval)
{
    *retval = _lUserType;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_UserType(THIS_ LONG lUserType)
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    _lUserType = (DWORD)lUserType;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_AllAttributes(THIS_ LONG FAR * retval)
{
    *retval = _lAllAttributes;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_Inherit(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _lAllAttributes & METADATA_INHERIT ? 
                                     VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_Inherit(THIS_ VARIANT_BOOL bInherit)
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    if (bInherit == VARIANT_TRUE) { 
        _lAllAttributes |= METADATA_INHERIT;
    }
    else {
        _lAllAttributes &= ~METADATA_INHERIT;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_PartialPath(THIS_ VARIANT_BOOL FAR * retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISProperty::put_PartialPath(THIS_ VARIANT_BOOL bPartialPath)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISProperty::get_Reference(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _lAllAttributes & METADATA_REFERENCE ? 
                                     VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_Reference(THIS_ VARIANT_BOOL bReference)
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    if (bReference == VARIANT_TRUE) { 
        _lAllAttributes |= METADATA_REFERENCE;
    }
    else {
        _lAllAttributes &= ~METADATA_REFERENCE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_Secure(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _lAllAttributes & METADATA_SECURE ? 
                                     VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_Secure(THIS_ VARIANT_BOOL bSecure)
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    if (bSecure == VARIANT_TRUE) {
        _lAllAttributes |= METADATA_SECURE;
    }
    else {
        _lAllAttributes &= ~METADATA_SECURE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_Volatile(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _lAllAttributes & METADATA_VOLATILE ? 
                                     VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_Volatile(THIS_ VARIANT_BOOL bVolatile)
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    if (bVolatile == VARIANT_TRUE) {
        _lAllAttributes |= METADATA_VOLATILE;
    }
    else {
        _lAllAttributes &= ~METADATA_VOLATILE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_Isinherit(THIS_ VARIANT_BOOL FAR * retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISProperty::put_Isinherit(THIS_ VARIANT_BOOL bIsinherit)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISProperty::get_InsertPath(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _lAllAttributes & METADATA_INSERT_PATH ? 
                                     VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_InsertPath(THIS_ VARIANT_BOOL bInsertPath)
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    if (bInsertPath == VARIANT_TRUE) {
        _lAllAttributes |= METADATA_INSERT_PATH;
    }
    else {
        _lAllAttributes &= ~METADATA_INSERT_PATH;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_Default(THIS_ VARIANT FAR * retval)
{
    VariantInit(retval);      
    RRETURN(VariantCopy(retval, &_vDefault));
}

STDMETHODIMP
CIISProperty::put_Default(THIS_ VARIANT vVarDefault)
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    VariantClear(&_vDefault);
    RRETURN(VariantCopy(&_vDefault, &vVarDefault));
}

HRESULT
CIISProperty::SetMetaID()
{
    HRESULT hr = S_OK;
    DWORD dwMetaId;

    //
    // get metaid 
    //

    if (_lMetaId == 0) {
        hr = _pSchema->LookupMetaID(_pszPropName, &dwMetaId);

        //
        // generate a meta id for this property
        //

        if (FAILED(hr)) {

            hr = GenerateNewMetaID(_pszServerName, _pAdminBase, &dwMetaId);
            BAIL_ON_FAILURE(hr);

            //
            // since we don't support bit mask property for ext. schema,
            // propid == metaid
            //

            _dwPropID = dwMetaId;
        }
        else {
            hr = _pSchema->LookupPropID(_pszPropName, &_dwPropID);
            ASSERT(hr);
        }

        //
        // assign new metaid to property
        //

        _lMetaId = (LONG)dwMetaId;
    
    }

error:

    RRETURN(hr);

}

BOOL
CIISProperty::IsMetaIdAvailable(
    DWORD MetaId
    )
/*++
Routine Description:

    Determine if the ID is valid to set on a new property.
    
    The determinination is based on whether the id is not 
    currently in use.

    NOTE - We will not respect ranges of IDs reserved for
    the base object. Unless that value is already defined
    (per vanvan)

Arguments:

    MetaId - The ID to validate

Return Value:

    TRUE if the specified id is valid to set, FALSE otherwise
--*/
{
    BOOL                fRet = FALSE;
    HRESULT             hr = NOERROR;
    METADATA_HANDLE     hObjHandle = NULL;

    // Is the property specified by MetaId defined in the schema

    hr = OpenAdminBaseKey(
                _pszServerName,
                SCHEMA_PROP_METABASE_PATH,
                METADATA_PERMISSION_READ,
                &_pAdminBase,
                &hObjHandle
                );

    if( SUCCEEDED(hr) )
    {
        METADATA_RECORD mdr;
        WCHAR           wcsPropertyName[MAX_PATH + 1];
        DWORD           cb;

        MD_SET_DATA_RECORD( &mdr,
                            MetaId,
                            METADATA_NO_ATTRIBUTES,
                            IIS_MD_UT_SERVER,
                            STRING_METADATA,
                            sizeof(wcsPropertyName),
                            (unsigned char *)wcsPropertyName
                            );

        hr = _pAdminBase->GetData( hObjHandle, L"Names", &mdr, &cb );

        if( MD_ERROR_DATA_NOT_FOUND == hr )
        {
            fRet = TRUE;
        }

        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    return fRet;
}

/******************************************************************/
/*  Class CIISSyntax
/******************************************************************/

DEFINE_IDispatch_Implementation(CIISSyntax)
DEFINE_IADs_Implementation(CIISSyntax)
DEFINE_IADs_PutGetUnImplementation(CIISSyntax)

CIISSyntax::CIISSyntax() : _pSchema(NULL),
                           _pDispMgr(NULL)
{
    ENLIST_TRACKING(CIISSyntax);
}

CIISSyntax::~CIISSyntax()
{
    delete _pDispMgr;
}

HRESULT
CIISSyntax::CreateSyntax(
    BSTR   bstrParent,
    SYNTAXINFO *pSyntaxInfo,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CIISSyntax FAR *pSyntax = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSyntaxObject( &pSyntax );
    BAIL_ON_FAILURE(hr);

    hr = pSyntax->InitializeCoreObject(
             bstrParent,
             pSyntaxInfo->bstrName,
             SYNTAX_CLASS_NAME,
             NO_SCHEMA,
             CLSID_IISSyntax,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSyntax->_lOleAutoDataType = pSyntaxInfo->lOleAutoDataType;

    hr = pSyntax->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSyntax->Release();

    RRETURN(hr);

error:

    delete pSyntax;
    RRETURN(hr);
}

STDMETHODIMP
CIISSyntax::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSyntax))
    {
        *ppv = (IADsSyntax FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* IADs methods */

STDMETHODIMP
CIISSyntax::SetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISSyntax::GetInfo(THIS)
{
    RRETURN(S_OK);
}

HRESULT
CIISSyntax::AllocateSyntaxObject(CIISSyntax FAR * FAR * ppSyntax)
{
    CIISSyntax FAR *pSyntax = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSyntax = new CIISSyntax();
    if ( pSyntax == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADsSyntax,
                            (IADsSyntax *) pSyntax,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pSyntax->_pDispMgr = pDispMgr;
    *ppSyntax = pSyntax;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSyntax;

    RRETURN(hr);

}

STDMETHODIMP
CIISSyntax::get_OleAutoDataType( THIS_ long FAR *plOleAutoDataType )
{
    if ( !plOleAutoDataType )
        RRETURN(E_ADS_BAD_PARAMETER);

    *plOleAutoDataType = _lOleAutoDataType;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISSyntax::put_OleAutoDataType( THIS_ long lOleAutoDataType )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}


/******************************************************************/
/*  Misc Helpers
/******************************************************************/

HRESULT
MakeVariantFromStringList(
    BSTR bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    BSTR pszTempList = NULL;

    if ( bstrList != NULL )
    {
        // If bstrList is not null, then there we consider there
        // to be one element
        long nCount = 1;

        long i = 0;
        TCHAR c;
        BSTR pszSrc;

        hr = ADsAllocString( bstrList, &pszTempList );
        BAIL_ON_FAILURE(hr);

        while ( c = pszTempList[i] )
        {
            if ( c == TEXT(','))
            {
                pszTempList[i] = 0;
                nCount++;
            }

            i++;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszSrc = pszTempList;

        for ( i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            hr = ADsAllocString( pszSrc, &(V_BSTR(&v)));
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );
            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszSrc += _tcslen( pszSrc ) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

        ADsFreeString( pszTempList );
        pszTempList = NULL;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    RRETURN(S_OK);

error:

    if ( pszTempList )
        ADsFreeString( pszTempList );

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}



HRESULT
ValidateClassObjProps(
    LPWSTR pszName,
    PDWORD pdwSyntax,
    PDWORD pdwID
    )
{
    DWORD i;

    //
    // Look for the given syntax name
    //

    for ( i = 0; i < g_cClassObjProps; i++ )
    {
         if ( _wcsicmp( g_pClassObjProps[i].szObjectName, pszName) == 0 ) {
             *pdwSyntax = g_pClassObjProps[i].dwSyntaxId;
             *pdwID = g_pClassObjProps[i].dwID;
             RRETURN(S_OK);
         }
    }

    RRETURN(E_ADS_BAD_PARAMETER);

}

HRESULT
ValidatePropertyObjProps(
    LPWSTR pszName,
    PDWORD pdwSyntax,
    PDWORD pdwID
    )
{
    DWORD i;

    //
    // Look for the given syntax name
    //

    for ( i = 0; i < g_cPropertyObjProps; i++ )
    {
         if ( _wcsicmp( g_pPropertyObjProps[i].szObjectName, pszName) == 0 ) {
             *pdwSyntax = g_pPropertyObjProps[i].dwSyntaxId;
             *pdwID = g_pPropertyObjProps[i].dwID;
             RRETURN(S_OK);
         }
    }

    RRETURN(E_ADS_BAD_PARAMETER);

}


HRESULT
IISMarshallClassProperties(
    CLASSINFO *pClassInfo,
    PMETADATA_RECORD *  ppMetaDataRecords,
    PDWORD pdwMDNumDataEntries
    )
{

    HRESULT hr = S_OK;
    PMETADATA_RECORD pMetaDataArray = NULL;
    static BOOL bTemp = FALSE; 

    //
    // set to 4 because we're supporting 4 properties only
    //
    *pdwMDNumDataEntries = 4;

    pMetaDataArray = (PMETADATA_RECORD) AllocADsMem(
                          *pdwMDNumDataEntries * sizeof(METADATA_RECORD));
    if (!pMetaDataArray ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *ppMetaDataRecords = pMetaDataArray;

    //
    // setting Containment and Container property for classes
    //
    pMetaDataArray->dwMDIdentifier = MD_SCHEMA_CLASS_CONTAINER;
    pMetaDataArray->dwMDAttributes = METADATA_NO_ATTRIBUTES;
    pMetaDataArray->dwMDUserType = IIS_MD_UT_SERVER;
    pMetaDataArray->dwMDDataType = DWORD_METADATA;
    pMetaDataArray->dwMDDataLen = sizeof(DWORD);
    if (pClassInfo) {
        pMetaDataArray->pbMDData = (unsigned char*)&(pClassInfo->fContainer);
    }
    else {
        pMetaDataArray->pbMDData = (BYTE*)&bTemp;
    }
    pMetaDataArray++;

    pMetaDataArray->dwMDIdentifier = MD_SCHEMA_CLASS_CONTAINMENT;
    pMetaDataArray->dwMDAttributes = METADATA_NO_ATTRIBUTES;
    pMetaDataArray->dwMDUserType = IIS_MD_UT_SERVER;
    pMetaDataArray->dwMDDataType = STRING_METADATA;
    if (pClassInfo && pClassInfo->bstrContainment) {
        pMetaDataArray->dwMDDataLen = (wcslen((LPWSTR)pClassInfo->bstrContainment)+ 1)*2;
        pMetaDataArray->pbMDData = (unsigned char *)pClassInfo->bstrContainment;
    }
    else {
        pMetaDataArray->dwMDDataLen = 0;
        pMetaDataArray->pbMDData = NULL;
    }

    pMetaDataArray++;


    //
    // setting Optional and Mandatory Properties
    //

    pMetaDataArray->dwMDIdentifier = MD_SCHEMA_CLASS_MAND_PROPERTIES;
    pMetaDataArray->dwMDAttributes = METADATA_NO_ATTRIBUTES;
    pMetaDataArray->dwMDUserType = IIS_MD_UT_SERVER;
    pMetaDataArray->dwMDDataType = STRING_METADATA;
    if (pClassInfo && pClassInfo->bstrMandatoryProperties) {
        pMetaDataArray->dwMDDataLen = (wcslen((LPWSTR)pClassInfo->bstrMandatoryProperties)+1)*2;
        pMetaDataArray->pbMDData = (unsigned char *)pClassInfo->bstrMandatoryProperties;
    }
    else {
        pMetaDataArray->dwMDDataLen = 0;
        pMetaDataArray->pbMDData = NULL;
    }

    pMetaDataArray++;

    pMetaDataArray->dwMDIdentifier = MD_SCHEMA_CLASS_OPT_PROPERTIES;
    pMetaDataArray->dwMDAttributes = METADATA_NO_ATTRIBUTES;
    pMetaDataArray->dwMDUserType = IIS_MD_UT_SERVER;
    pMetaDataArray->dwMDDataType = STRING_METADATA;
    if (pClassInfo && pClassInfo->bstrOptionalProperties) {
        pMetaDataArray->dwMDDataLen = (wcslen((LPWSTR)pClassInfo->bstrOptionalProperties)+1)*2;
        pMetaDataArray->pbMDData = (unsigned char *)pClassInfo->bstrOptionalProperties;
    }
    else {
        pMetaDataArray->dwMDDataLen = 0;
        pMetaDataArray->pbMDData = NULL;
    }


error:

    RRETURN(hr);
}



HRESULT
GenerateNewMetaID(
    LPWSTR pszServerName,
    IMSAdminBase *pAdminBase,
    PDWORD pdwMetaID
    )
{

    HRESULT hr = S_OK;
    DWORD dwMetaId = 0;
    METADATA_HANDLE hObjHandle = NULL;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)&dwMetaId;

    hr = OpenAdminBaseKey(
            pszServerName,
            IIS_MD_ADSI_SCHEMA_PATH_W,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            &pAdminBase,
            &hObjHandle
            );
    BAIL_ON_FAILURE(hr);

    MD_SET_DATA_RECORD(&mdrMDData,
                   MD_SCHEMA_METAID,
                   METADATA_NO_ATTRIBUTES,
                   IIS_MD_UT_SERVER,
                   DWORD_METADATA,
                   dwBufferSize,
                   pBuffer);

    hr = pAdminBase->GetData(
            hObjHandle,
            L"",
            &mdrMDData,
            &dwBufferSize
            );
    BAIL_ON_FAILURE(hr);

    *pdwMetaID = dwMetaId;

    //
    // increment metaid by 1 for next property
    //

    dwMetaId++;

    hr = pAdminBase->SetData(
             hObjHandle,
             L"",
             &mdrMDData
             );
    BAIL_ON_FAILURE(hr);
    
error:

    if (hObjHandle) {
        CloseAdminBaseKey(pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}
   

HRESULT
CheckDuplicateNames(
    LPWSTR pszNames
    ) 
{
    WCHAR szName[MAX_PATH];
    WCHAR szName2[MAX_PATH];
    LPWSTR ObjectList = (LPWSTR)pszNames;
    LPWSTR CheckList = (LPWSTR)pszNames;
    DWORD dwCount = 0;

    if (ObjectList == NULL ||
        (ObjectList != NULL && *ObjectList == NULL)) {
        RRETURN(S_OK);
    }

    while ((ObjectList = grabProp(szName, ObjectList)) != NULL) {
        if (*szName != L'\0') {
            CheckList = pszNames;
            while ((CheckList = grabProp(szName2, CheckList)) != NULL) {
                if (*szName2 != L'\0') {
                    if (!_wcsicmp(szName, szName2)) {
                        dwCount++; 
                    }
                }
            }
            if (dwCount > 1) {
                RRETURN(E_ADS_BAD_PARAMETER);
            }
            dwCount = 0;
        }
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\ctree.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  ctree.cxx
//
//  Contents:  Microsoft ADs IIS Provider Tree Object
//
//  History:   25-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//  Class CIISTree

DEFINE_IDispatch_Implementation(CIISTree)
DEFINE_IADs_Implementation(CIISTree)


CIISTree::CIISTree():
				_pAdminBase(NULL),
				_pSchema(NULL),
                _pPropertyCache(NULL)
{

    VariantInit(&_vFilter);

    ENLIST_TRACKING(CIISTree);
}

/* #pragma INTRINSA suppress=all */
HRESULT
CIISTree::CreateServerObject(
    BSTR bstrADsPath,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszADsParent = NULL;
    WCHAR szCommonName[MAX_PATH+MAX_PROVIDER_TOKEN_LENGTH];

    pszADsParent = AllocADsStr(bstrADsPath);

    if (!pszADsParent) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszADsParent = L'\0';

    //
    // Determine the parent and rdn name
    //

    hr = BuildADsParentPath(
                bstrADsPath,
                pszADsParent,
                szCommonName
                );

    //
    // call the helper function
    //

    hr = CIISTree::CreateServerObject(
                 pszADsParent,
                 szCommonName,
                 L"user",
                 Credentials,
                 dwObjectState,
                 riid,
                 ppvObj
                );

error:

    if (pszADsParent) {
        FreeADsStr(pszADsParent);
    }

    RRETURN(hr);
}


HRESULT
CIISTree::CreateServerObject(
    BSTR Parent,
    BSTR CommonName,
    BSTR ClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CIISTree FAR * pTree = NULL;
    HRESULT hr = S_OK;

    hr = AllocateTree(Credentials, &pTree);
    BAIL_ON_FAILURE(hr);

    hr = pTree->InitializeCoreObject(
                Parent,
                CommonName,
                ClassName,
                L"",
                CLSID_IISTree,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pTree->_pPropertyCache->InitializePropertyCache( CommonName );
    BAIL_ON_FAILURE(hr);

    hr = pTree->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pTree->Release();

    RRETURN(hr);

error:

    delete pTree;
    RRETURN(hr);
}

CIISTree::~CIISTree( )
{
    VariantClear(&_vFilter);

    delete _pDispMgr;

    delete _pPropertyCache;
}

STDMETHODIMP
CIISTree::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CIISTree::SetInfo()
{
    HRESULT hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = IISCreateObject();
        BAIL_ON_FAILURE(hr);

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        hr = IISSetObject();
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}


HRESULT
CIISTree::IISSetObject()
{
    DWORD dwStatus = 0L;
    LPWSTR pszIISPathName = NULL;
    HRESULT hr = S_OK;


    hr = BuildIISPathFromADsPath(
                _ADsPath,
                &pszIISPathName
                );
    BAIL_ON_FAILURE(hr);

    //
    // Add Set functionality: sophiac
    //


error:


    if (pszIISPathName) {

        FreeADsStr(pszIISPathName);
    }

    RRETURN(hr);
}

HRESULT
CIISTree::IISCreateObject()
{
    DWORD dwStatus = 0L;
    LPWSTR pszIISParentName = NULL;
    HRESULT hr = S_OK;


    hr = BuildIISPathFromADsPath(
                _Parent,
                &pszIISParentName
                );
    BAIL_ON_FAILURE(hr);

    // 
    //  Add Create functionality: sophiac
    // 

error:


    if (pszIISParentName) {

        FreeADsStr(pszIISParentName);
    }

    RRETURN(hr);
}

HRESULT
CIISTree::GetInfo()
{
    RRETURN(GetInfo(TRUE));
}

HRESULT
CIISTree::GetInfo(
    BOOL fExplicit
    )
{
    DWORD dwStatus = 0L;
    HANDLE hObject = NULL;
    LPWSTR pszIISPathName = NULL;
    HRESULT hr;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildIISPathFromADsPath(
                _ADsPath,
                &pszIISPathName
                );
    BAIL_ON_FAILURE(hr);

    //
    // Add get functionality : sophiac
    //

error:


    if (pszIISPathName) {

        FreeADsStr(pszIISPathName);
    }

    RRETURN(hr);
}

/* IADsContainer methods */

STDMETHODIMP
CIISTree::get_Count(long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISTree::get_Filter(THIS_ VARIANT FAR* pVar)
{
    VariantInit(pVar);
    RRETURN(VariantCopy(pVar, &_vFilter));
}

STDMETHODIMP
CIISTree::put_Filter(THIS_ VARIANT Var)
{
    RRETURN(VariantCopy(&_vFilter, &Var));
}

STDMETHODIMP
CIISTree::put_Hints(THIS_ VARIANT Var)
{
    RRETURN( E_NOTIMPL);
}


STDMETHODIMP
CIISTree::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISTree::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                _ADsPath,
                ClassName,
                RelativeName,
                _Credentials,
                ppObject,
                FALSE
                );

    RRETURN(hr);

}

STDMETHODIMP
CIISTree::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CIISTreeEnum::Create(
                (CIISTreeEnum **)&penum,
                _ADsPath,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISTree::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IADs * pADs  = NULL;
    VARIANT var;
    DWORD dwSyntaxId = 0;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    //
    // Validate if this class really exists in the schema
    // and validate that this object can be created in this
    // container
    //

    CLexer Lexer(_ADsPath);

    BAIL_ON_FAILURE(hr);
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);
    hr = InitServerInfo(pObjectInfo->TreeName, &_pAdminBase, &_pSchema);
    BAIL_ON_FAILURE(hr);
	hr = _pSchema->ValidateClassName(ClassName);
    BAIL_ON_FAILURE(hr);
	hr = CIISGenObject::CreateGenericObject(
                    _ADsPath,
                    RelativeName,
                    ClassName,
                    _Credentials,
                    ADS_OBJECT_UNBOUND,
                    IID_IDispatch,
                    (void **)ppObject
                    );
    BAIL_ON_FAILURE(hr);
    RRETURN(hr);
	
error:
    RRETURN(hr);
}

STDMETHODIMP
CIISTree::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    LPWSTR pszIISPathName = NULL;
    HRESULT hr = S_OK;

    hr = BuildIISPathFromADsPath(
                _ADsPath,
                &pszIISPathName
                );
    BAIL_ON_FAILURE(hr);

    //
    //
    // Add delete functionality : sophiac
    //

error:

    if (pszIISPathName) {
        FreeADsStr(pszIISPathName);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISTree::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISTree::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CIISTree::AllocateTree(
    CCredentials& Credentials,
    CIISTree ** ppTree
    )
{
    CIISTree FAR * pTree = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pTree = new CIISTree();
    if (pTree == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pTree,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pTree,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                        (CCoreADsObject FAR *)pTree,
                        &pPropertyCache
                        );
    BAIL_ON_FAILURE(hr);



    pTree->_Credentials = Credentials;
    pTree->_pPropertyCache = pPropertyCache;
    pTree->_pDispMgr = pDispMgr;
    *ppTree = pTree;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}

/* INTRINSA suppress=null_pointers, uninitialized */
STDMETHODIMP
CIISTree::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwSyntax;
    DWORD dwNumValues = 0;
    LPIISOBJECT pIISSrcObjects = NULL;
    WCHAR wchName[MAX_PATH];

    //
    // check if property is a supported property
    //

    hr = _pSchema->LookupSyntaxID(bstrName, &dwSyntax);
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //

    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY)
    {
    hr = _pPropertyCache->getproperty(
                wchName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    else
    {
    hr = _pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    BAIL_ON_FAILURE(hr);

    //
    // reset it to its syntax id if BITMASK type
    //

    pIISSrcObjects->IISType = dwSyntax;

    //
    // translate the IIS objects to variants
    //

    if (dwNumValues == 1) {

        hr  = IISTypeToVarTypeCopy(
                   _pSchema,
                   bstrName,
                   pIISSrcObjects,
                   pvProp,
                   FALSE
                   );
    }else {

        hr = IISTypeToVarTypeCopyConstruct(
                    _pSchema,
                    bstrName,
                    pIISSrcObjects,
                    dwNumValues,
                    pvProp,
                    FALSE
                    );

    }
    BAIL_ON_FAILURE(hr);

error:
    if (pIISSrcObjects) {

        IISTypeFreeIISObjects(
            pIISSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}

/* INTRINSA suppress=null_pointers, uninitialized */
STDMETHODIMP
CIISTree::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwSyntax;
    DWORD dwNumValues = 0;
    LPIISOBJECT pIISSrcObjects = NULL;
    WCHAR wchName[MAX_PATH];

    //
    // check if property is a supported property
    //

    hr = _pSchema->LookupSyntaxID(bstrName, &dwSyntax);
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //

    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY)
    {
    hr = _pPropertyCache->getproperty(
                wchName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    else
    {
    hr = _pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    BAIL_ON_FAILURE(hr);

    //
    // reset it to its syntax id if BITMASK type
    //

    pIISSrcObjects->IISType = dwSyntax;

    //
    // translate the IIS objects to variants
    //

    hr = IISTypeToVarTypeCopyConstruct(
                _pSchema,
                bstrName,
                pIISSrcObjects,
                dwNumValues,
                pvProp,
                TRUE
                );
    BAIL_ON_FAILURE(hr);

error:
    if (pIISSrcObjects) {

        IISTypeFreeIISObjects(
            pIISSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISTree::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPIISOBJECT pIISDestObjects = NULL;
    DWORD dwNumValues = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    WCHAR wchName[MAX_PATH];

    //
    // Issue: How do we handle multi-valued support
    //

    if ((V_VT(&vProp) &  VT_VARIANT) &&  V_ISARRAY(&vProp)) {
        if(V_ISBYREF(&vProp)) {

            hr  = ConvertByRefSafeArrayToVariantArray(
                        vProp,
                        &pVarArray,
                        &dwNumValues
                        );
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;
        }
        else {

            hr  = ConvertSafeArrayToVariantArray(
                        vProp,
                        &pVarArray,
                        &dwNumValues
                        );
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;
        }
    }
    else {

        dwNumValues = 1;
        pvProp = &vProp;
    }

    //
    // Check if this is a legal property and it syntax ID
    //

    hr = _pSchema->LookupSyntaxID( bstrName, &dwSyntaxId);
    BAIL_ON_FAILURE(hr);

    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToIISTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pIISDestObjects,
                    FALSE
                    );
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //
    if (dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
        VARIANT vGetProp;
        DWORD dwMask;
        DWORD dwFlagValue;

        hr = _pSchema->LookupBitMask(bstrName, &dwMask);
        BAIL_ON_FAILURE(hr);

        // 
        // get its corresponding DWORD flag value
        // 

        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);

        VariantInit(&vGetProp);
        hr = Get(wchName, &vGetProp);
        BAIL_ON_FAILURE(hr);

        dwFlagValue = V_I4(&vGetProp);
 
        if (pIISDestObjects->IISValue.value_1.dwDWORD) {
            dwFlagValue |= dwMask;
        }
        else {
            dwFlagValue &= ~dwMask;
        }

        pIISDestObjects->IISValue.value_1.dwDWORD = dwFlagValue;
        pIISDestObjects->IISType = IIS_SYNTAX_ID_DWORD;
        bstrName = wchName;
    }

    if (dwSyntaxId == IIS_SYNTAX_ID_BINARY) 
    {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
        bstrName = wchName;
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //

    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    CACHE_PROPERTY_MODIFIED,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pIISDestObjects) {
        IISTypeFreeIISObjects(
                pIISDestObjects,
                dwNumValues
                );

    }

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISTree::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPIISOBJECT pIISDestObjects = NULL;
    DWORD dwNumValues = 0;
    DWORD dwFlags = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    WCHAR wchName[MAX_PATH];

    switch (lnControlCode) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = CACHE_PROPERTY_CLEARED;

        pIISDestObjects = NULL;
        dwNumValues = 0;

        break;

    case ADS_PROPERTY_UPDATE:
        dwFlags = CACHE_PROPERTY_MODIFIED;

        //
        // Now begin the rest of the processing
        //

        if ((V_VT(&vProp) &  VT_VARIANT) &&  V_ISARRAY(&vProp)) {
            if (V_ISBYREF(&vProp)) {
                hr  = ConvertByRefSafeArrayToVariantArray(
                            vProp,
                            &pVarArray,
                            &dwNumValues
                            );
                BAIL_ON_FAILURE(hr);
            }
            else {
                hr  = ConvertSafeArrayToVariantArray(
                            vProp,
                            &pVarArray,
                            &dwNumValues
                            );
                BAIL_ON_FAILURE(hr);
            }
            pvProp = pVarArray;

        }else {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        //
        // check if the variant maps to the syntax of this property
        //

        hr = VarTypeToIISTypeCopyConstruct(
                        dwSyntaxId,
                        pvProp,
                        dwNumValues,
                        &pIISDestObjects,
                        TRUE
                        );
        BAIL_ON_FAILURE(hr);

        break;

    default:
       RRETURN(hr = E_ADS_BAD_PARAMETER);

    }

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //

    if (dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
        VARIANT vGetProp;
        DWORD dwMask;
        DWORD dwFlagValue;

        hr = _pSchema->LookupBitMask(bstrName, &dwMask);
        BAIL_ON_FAILURE(hr);

        // 
        // get its corresponding DWORD flag value
        // 

        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);

        VariantInit(&vGetProp);
        hr = Get(wchName, &vGetProp);
        BAIL_ON_FAILURE(hr);

        dwFlagValue = V_I4(&vGetProp);
 
        if (pIISDestObjects->IISValue.value_1.dwDWORD) {
            dwFlagValue |= dwMask;
        }
        else {
            dwFlagValue &= ~dwMask;
        }

        pIISDestObjects->IISValue.value_1.dwDWORD = dwFlagValue;
        pIISDestObjects->IISType = IIS_SYNTAX_ID_DWORD;
        bstrName = wchName;
    }

    if (dwSyntaxId == IIS_SYNTAX_ID_BINARY) 
    {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
        bstrName = wchName;
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //

    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    dwFlags,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pIISDestObjects) {
        IISTypeFreeIISObjects(
                pIISDestObjects,
                dwNumValues
                );

    }


    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\extension.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       extension.cxx
//
//  Contents:   3rd party extension mgmt functions 
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------

#include "iis.hxx"
#pragma hdrstop


LPCWSTR lpszTopLevel = L"SOFTWARE\\Microsoft\\ADs\\Providers\\IIS";
LPCWSTR lpszExtensions = L"Extensions";

PCLASS_ENTRY gpClassHead = NULL;

PCLASS_ENTRY
BuildClassesList()
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;
    HKEY hExtensionRootKey = NULL;

    HKEY hClassKey = NULL;

    DWORD dwIndex = 0;
    WCHAR lpszClassName[MAX_PATH];
    DWORD dwchClassName = 0;
    PCLASS_ENTRY pClassHead = NULL;
    PCLASS_ENTRY pClassEntry = NULL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     lpszTopLevel,
                     0,
                     KEY_READ,
                     &hTopLevelKey
                     ) != ERROR_SUCCESS)
    {
        goto CleanupAndExit;
    }

    if (RegOpenKeyEx(hTopLevelKey,
                     lpszExtensions,
                     0,
                     KEY_READ,
                     &hExtensionRootKey
                     ) != ERROR_SUCCESS)

    {
        goto CleanupAndExit;
    }

    memset(lpszClassName, 0, sizeof(lpszClassName));
    dwchClassName = (int) (sizeof(lpszClassName) / sizeof(WCHAR));

    while(RegEnumKeyEx(hExtensionRootKey,
                     dwIndex,
                     lpszClassName,
                     &dwchClassName,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hExtensionRootKey,
                         lpszClassName,
                         0,
                         KEY_READ,
                         &hClassKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        pClassEntry  = BuildClassEntry(
                                lpszClassName,
                                hClassKey
                                );

        if (pClassEntry) {

            pClassEntry->pNext = pClassHead;
            pClassHead = pClassEntry;
        }

        if (hClassKey) {
            CloseHandle(hClassKey);
        }

        memset(lpszClassName, 0, sizeof(lpszClassName));
        dwchClassName = (int) (sizeof(lpszClassName) / sizeof(WCHAR));
        dwIndex++;
    }

CleanupAndExit:

    if (hExtensionRootKey) {
        RegCloseKey(hExtensionRootKey);
    }

    if (hTopLevelKey) {
        RegCloseKey(hTopLevelKey);
    }

    return(pClassHead);
}

VOID
FreeClassesList(
    PCLASS_ENTRY pClassHead
    )
{
    PCLASS_ENTRY pDelete;

    while (pClassHead) {

        pDelete = pClassHead;
        pClassHead = pClassHead->pNext;

        FreeClassEntry(pDelete);
    }

    return;
}

PCLASS_ENTRY
BuildClassEntry(
    LPWSTR lpszClassName,
    HKEY hClassKey
    )
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;

    DWORD dwIndex = 0;
    DWORD dwchExtensionCLSID = 0;
    WCHAR lpszExtensionCLSID[MAX_PATH];
    PCLASS_ENTRY pClassEntry = NULL;
    PEXTENSION_ENTRY pExtensionHead = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;

    pClassEntry =  (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (!pClassEntry) {

        goto CleanupAndExit;
    }

    wcscpy(pClassEntry->szClassName, lpszClassName);

    memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
    dwchExtensionCLSID = (int) (sizeof(lpszExtensionCLSID) / sizeof(WCHAR));

    while(RegEnumKeyEx(hClassKey,
                     dwIndex,
                     lpszExtensionCLSID,
                     &dwchExtensionCLSID,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hClassKey,
                         lpszExtensionCLSID,
                         0,
                         KEY_READ,
                         &hExtensionKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        //
        // Read the Interfaces that this Extension supports
        //

        pExtensionEntry = BuildExtensionEntry(
                                lpszExtensionCLSID,
                                hExtensionKey
                                );

        if (pExtensionEntry) {

            wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);

            pExtensionEntry->pNext = pExtensionHead;
            pExtensionHead = pExtensionEntry;
        }


        if (hExtensionKey) {

            CloseHandle(hExtensionKey);
        }

        memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
        dwchExtensionCLSID = (int) (sizeof(lpszExtensionCLSID) / sizeof(WCHAR));
        dwIndex++;

    }

    pClassEntry->pExtensionHead = pExtensionHead;




CleanupAndExit:

    return(pClassEntry);
}


PEXTENSION_ENTRY
BuildExtensionEntry(
    LPWSTR lpszExtensionCLSID,
    HKEY hExtensionKey
    )
{
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pInterfaceHead = NULL;
    WCHAR lpszInterfaces[MAX_PATH];
    DWORD dwchInterfaces = 0;
    LPWSTR psz = NULL;
    WCHAR Interface[MAX_PATH];
    HRESULT hr = S_OK;


    pExtensionEntry =  (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (!pExtensionEntry) {

        goto CleanupAndExit;
    }

    memset(lpszInterfaces, 0, sizeof(lpszInterfaces));
    dwchInterfaces = sizeof(lpszInterfaces);

    RegQueryValueEx(
            hExtensionKey,
            L"Interfaces",
            NULL,
            NULL,
            (LPBYTE) lpszInterfaces,
            &dwchInterfaces
            );

    psz = lpszInterfaces;

    while (psz && *psz) {

       lstrcpy(Interface, psz);

       // skip (length) + 1
       // lstrlen returns length sans '\0'


       pInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

       if (pInterfaceEntry) {

           wcscpy(pInterfaceEntry->szInterfaceIID, Interface);

           hr = IIDFromString(Interface, &(pInterfaceEntry->iid));

           pInterfaceEntry->pNext = pInterfaceHead;
           pInterfaceHead = pInterfaceEntry;

       }

       psz = psz + lstrlen(psz) + 1;

    }

    wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);
    hr = CLSIDFromString(lpszExtensionCLSID, &(pExtensionEntry->ExtCLSID));

    pExtensionEntry->pIID = pInterfaceHead;

CleanupAndExit:

    return(pExtensionEntry);
}


void
FreeInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    if (pInterfaceEntry) {

        FreeADsMem(pInterfaceEntry);
    }
}


void
FreeExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pTemp = NULL;

    if (pExtensionEntry) {

        pInterfaceEntry = pExtensionEntry->pIID;

        while (pInterfaceEntry) {

            pTemp = pInterfaceEntry->pNext;

            if (pInterfaceEntry) {

                FreeInterfaceEntry(pInterfaceEntry);
            }

            pInterfaceEntry = pTemp;

        }

        //
        // Now unload the Extension Object
        //

        if (pExtensionEntry->pUnknown) {

            //
            // Call non-delegating Release to release ref. count on innner
            // object to inner object -> inner object self destroyed.
            // 
            (pExtensionEntry->pUnknown)->Release();

        }


        FreeADsMem(pExtensionEntry);
    }

    return;
}

void
FreeClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{

    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PEXTENSION_ENTRY pTemp = NULL;

    if (pClassEntry) {

        pExtensionEntry = pClassEntry->pExtensionHead;

        while (pExtensionEntry) {

            pTemp = pExtensionEntry->pNext;

            if (pExtensionEntry) {

                FreeExtensionEntry(pExtensionEntry);
            }

            pExtensionEntry = pTemp;

        }

        FreeADsMem(pClassEntry);
    }

    return;
}


PINTERFACE_ENTRY
MakeCopyofInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    pNewInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

    if (pNewInterfaceEntry) {

        wcscpy(pNewInterfaceEntry->szInterfaceIID, pInterfaceEntry->szInterfaceIID);
        memcpy(&(pNewInterfaceEntry->iid), &(pInterfaceEntry->iid), sizeof(GUID));
    }

    return(pNewInterfaceEntry);
}



PEXTENSION_ENTRY
MakeCopyofExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PINTERFACE_ENTRY pInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceHead = NULL;


    pInterfaceEntry = pExtensionEntry->pIID;

    while (pInterfaceEntry) {

        pNewInterfaceEntry = MakeCopyofInterfaceEntry(pInterfaceEntry);

        if (pNewInterfaceEntry) {

            pNewInterfaceEntry->pNext = pNewInterfaceHead;
            pNewInterfaceHead = pNewInterfaceEntry;
        }

        pInterfaceEntry = pInterfaceEntry->pNext;

    }

    pNewExtensionEntry = (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (pNewExtensionEntry) {

        wcscpy(
            pNewExtensionEntry->szExtensionCLSID, 
            pExtensionEntry->szExtensionCLSID
            );

        memcpy(
            &(pNewExtensionEntry->ExtCLSID), 
            &(pExtensionEntry->ExtCLSID), 
            sizeof(GUID)
            );

        pNewExtensionEntry->pIID = pNewInterfaceHead;


        //
        // Initialize fields we won't know the values of until an instacne of 
        // the extension is created and aggregated (loaded).
        //

        pNewExtensionEntry->pUnknown=NULL;
        pNewExtensionEntry->pPrivDisp=NULL;
        pNewExtensionEntry->pADsExt=NULL;
        pNewExtensionEntry->fDisp=FALSE;    
        pNewExtensionEntry->dwExtensionID = (DWORD) -1; //invalid dwExtensionID 

        //
        // let class entry handle pNext
        //
    }

    return(pNewExtensionEntry);
}


PCLASS_ENTRY
MakeCopyofClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{
    PCLASS_ENTRY pNewClassEntry = NULL;

    PEXTENSION_ENTRY pExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionHead = NULL;


    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pNewExtensionEntry = MakeCopyofExtensionEntry(pExtensionEntry);

        if (pNewExtensionEntry) {

            pNewExtensionEntry->pNext = pNewExtensionHead;
            pNewExtensionHead = pNewExtensionEntry;
        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    pNewClassEntry = (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (pNewClassEntry) {

        wcscpy(pNewClassEntry->szClassName, pClassEntry->szClassName);

        pNewClassEntry->pExtensionHead = pNewExtensionHead;

    }

    return(pNewClassEntry);
}


CRITICAL_SECTION g_ExtCritSect;

#define ENTER_EXTENSION_CRITSECT()  EnterCriticalSection(&g_ExtCritSect)
#define LEAVE_EXTENSION_CRITSECT()  LeaveCriticalSection(&g_ExtCritSect)

HRESULT
ADSIGetExtensionList(
    LPWSTR pszClassName,
    PCLASS_ENTRY * ppClassEntry
    )
{

    PCLASS_ENTRY pTempClassEntry = NULL;
    PCLASS_ENTRY pClassEntry = NULL;
    ENTER_EXTENSION_CRITSECT();

    pTempClassEntry = gpClassHead;

    while (pTempClassEntry) {


        if (!_wcsicmp(pTempClassEntry->szClassName, pszClassName)) {

            //
            // Make a copy of this entire extension and
            // hand it over to the calling entity.
            //

            pClassEntry = MakeCopyofClassEntry(pTempClassEntry);

            *ppClassEntry = pClassEntry;

            LEAVE_EXTENSION_CRITSECT();

            RRETURN(S_OK);

        }

        pTempClassEntry = pTempClassEntry->pNext;

   }


   *ppClassEntry = NULL;

   LEAVE_EXTENSION_CRITSECT();

   RRETURN(S_OK);

}


//
// Instantiate extension objects listed in <pClassEntry> as aggregatees of
// aggregator <pUnkOuter>. Initialize extensions with <Credentials>. 
//
// Max Load 127 extensions. Return S_FALSE if more extension in <pClassEntry>
// EXTTODO:   define S_??? in future for > unloaded extension -> passed to
//            ADSI clients.
//

HRESULT
ADSILoadExtensions2(
    IUnknown FAR * pUnkOuter,
    CCredentials& Credentials,
    PCLASS_ENTRY pClassEntry
    )

{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtEntry = NULL;
    DWORD dwExtensionID = MIN_EXTENSION_ID;  
    IPrivateDispatch * pPrivDisp = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    DWORD dwAuthFlags = 0;
    VARIANT varUserName;
    VARIANT varPassword;
    VARIANT varAuthFlags;
    PVARIANT pvarUserName = &varUserName;
    PVARIANT pvarPassword = &varPassword;
    PVARIANT pvarAuthFlags = &varAuthFlags;
    BOOL    fReturnError = FALSE;


    ASSERT(pUnkOuter);


    if (!pClassEntry || !(pExtEntry=pClassEntry->pExtensionHead) ) {
        RRETURN(S_OK);
    }


    VariantInit(pvarUserName);
    VariantInit(pvarPassword);
    VariantInit(pvarAuthFlags);


    hr = Credentials.GetUserName(&pszUserName);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }

    hr = Credentials.GetPassword(&pszPassword);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }

    dwAuthFlags = Credentials.GetAuthFlags();



    while (pExtEntry) {

        //
        // Max # of extension have been loaded, cannot load more
        //

        if (dwExtensionID>MAX_EXTENSION_ID) {
            
            //
            // EXTTODO: S_FALSE for now. See hdr doc for future plan.
            //
            hr = S_FALSE;   
            break;
        }

        // 
        // create extension object (aggregatee) and ask for Non-delegating
        // IUnknown. Ref count on extension object = 1.
        //

        hr = CoCreateInstance(
                    pExtEntry->ExtCLSID,
                    pUnkOuter,
                    CLSCTX_INPROC_SERVER,
                    IID_IUnknown,      
                    (void **)&(pExtEntry->pUnknown)
                    );

        //
        // if fail, go to next extesion entry s.t. bad individual extension 
        // cannot block other extensions from loading (no clean up needed)
        //
        // EXTTODO: no warning to user about failure
        //

        if (SUCCEEDED(hr)) {

            pExtEntry->dwExtensionID = dwExtensionID;


            hr = (pExtEntry->pUnknown)->QueryInterface(
                        IID_IADsExtension,
                        (void **) &(pExtEntry->pADsExt)
                        );

            if  (FAILED(hr)) {
            
                //
                // extension does not support the optioanl IADsExtension -> OK.
                // (no clean up needed)
                //

                pExtEntry->pADsExt=NULL;

                pExtEntry->fDisp = FALSE;

            } else {
                
                //
                // Cache the interface ptr but call Release() immediately to 
                // avoid aggregator having a ref count on itself 
                // since IADsExtension inherits from delegating IUnknown.
                // 
                // Note: codes still works if inherit from NonDelegatingIUknown
                //   

                (pExtEntry->pADsExt)->Release() ;

                //       
                // For efficiency, set this flag to FALSE on FIRST encounter of 
                // pADsExt->PrivateGetIDsOfNames()/Invoke() returning E_NOTIMPL.
                // Set as TRUE now s.t. at least first encounter will happen.
                //

                pExtEntry->fDisp = TRUE;


                //
                // Pass its own credentials to extension. Ignore error if any. 
                //

                hr = ADsAllocString(
                        pszUserName,
                        &(pvarUserName->bstrVal)
                        );
                if (FAILED(hr)) {
                    fReturnError = TRUE;
                    BAIL_ON_FAILURE(hr);        
                }
                V_VT(pvarUserName) = VT_BSTR;

                hr = ADsAllocString(
                        pszPassword,
                        &(pvarPassword->bstrVal)
                        );  
                if (FAILED(hr)) {
                    fReturnError = TRUE;
                    BAIL_ON_FAILURE(hr);        
                }
                V_VT(pvarPassword) = VT_BSTR;
            
                V_I4(pvarAuthFlags) = dwAuthFlags;
                V_VT(pvarAuthFlags) = VT_I4;

                hr = (pExtEntry->pADsExt)->Operate(
                        ADS_EXT_INITCREDENTIALS,
                        varUserName, 
                        varPassword,
                        varAuthFlags
                        );
            } 

        } // end if CoCreateInstance() succeeded  


        pExtEntry = pExtEntry->pNext;


        //
        // ++ extension ID even if creat'n of extension fails just to be safe 
        // - chuck's stuff :)
        //

        dwExtensionID++;                
    
    }   // end while 



error:

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        FreeADsStr(pszPassword);
    }

    VariantClear(pvarUserName);
    VariantClear(pvarPassword);
    VariantClear(pvarAuthFlags); 

    if (fReturnError) {
        RRETURN(hr);        // fetal error, 
    }
    else {
        RRETURN(S_OK);      // "okay" error if any, optional support 
    }
    
}

HRESULT
ADSILoadExtensions(
    IUnknown FAR * pUnkOuter,
    CCredentials& Credentials,
    PCLASS_ENTRY pClassEntry,
    LPTSTR pszClassName
    )

{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    DWORD dwExtensionID = 1;
    IPrivateDispatch * pPrivDisp = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    DWORD dwAuthFlags = 0;

    hr = Credentials.GetUserName(&pszUserName);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }

    hr = Credentials.GetPassword(&pszPassword);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }

    dwAuthFlags = Credentials.GetAuthFlags();


    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        hr = CoCreateInstance(
                    pExtensionEntry->ExtCLSID,
                    pUnkOuter,
                    CLSCTX_INPROC_SERVER,
                    IID_IPrivateUnknown,
                    (void **)&(pExtensionEntry->pUnknown)
                    );


        if (SUCCEEDED(hr)) {


            hr = (pExtensionEntry->pUnknown)->ADSIInitializeObject(
                                                    pszUserName,
                                                    pszPassword,
                                                    dwAuthFlags
                                                    );

            pExtensionEntry->dwExtensionID = dwExtensionID;

            hr = (pExtensionEntry->pUnknown)->QueryInterface(
                                    IID_IPrivateDispatch,
                                    (void **)&pPrivDisp
                                    );
            if (SUCCEEDED(hr)) {

                hr = pPrivDisp->ADSIInitializeDispatchManager(dwExtensionID);

                if (FAILED(hr)) {

                    //
                    // Remember NOT to do a Release here for IPrivateDispatch
                    //

                    pExtensionEntry->fDisp = FALSE;

                    (pExtensionEntry->pUnknown)->Release();


                }else {
                    pExtensionEntry->fDisp = TRUE;
                    pExtensionEntry->pPrivDisp = pPrivDisp;

                    //
                    // Now release  both pointers because we don't want to
                    // have a cyclic reference count
                    //

                    (pExtensionEntry->pPrivDisp)->Release();
                    (pExtensionEntry->pUnknown)->Release();
                }

            }else {
                pExtensionEntry->fDisp = FALSE;

                (pExtensionEntry->pUnknown)->Release();

            }

        }

        pExtensionEntry = pExtensionEntry->pNext;

        dwExtensionID++;

    }


    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        FreeADsStr(pszPassword);
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\fsmacro.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  fsmacro.h
//
//  Contents:  Macros for adsi put/get methods
//
//  History:   21-04-97     sophiac    Created.
//
//----------------------------------------------------------------------------
#define PUT_PROPERTY_LONG(this, Property) \
                RRETURN(put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ))

#define GET_PROPERTY_LONG(this, Property) \
                RRETURN(get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_BSTR(this, Property) \
                RRETURN(put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ))

#define GET_PROPERTY_BSTR(this, Property) \
                RRETURN(get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ))

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_DATE(this, Property) \
                RRETURN(put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ))

#define GET_PROPERTY_DATE(this, Property) \
                RRETURN(get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_VARIANT(this, Property) \
                RRETURN(put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ))

#define GET_PROPERTY_VARIANT(this, Property) \
                RRETURN(get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\globals.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  globals.cxx
//
//  Contents:
//
//  History:
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

#include "globdata.cxx"


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\getobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  getobj.cxx
//
//  Contents:  ADSI GetObject functionality
//
//  History:   25-Feb-97   SophiaC    Created.
//             25-Jun-97   MagnusH    Added private extension mechanism
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


extern LPWSTR szProviderName;

//+---------------------------------------------------------------------------
//  Function:   RelativeGetObject
//
//  Synopsis:   Gets object relative to given Active Directory path.
//
//  Arguments:  [BSTR ADsPath]
//              [BSTR ClassName]
//              [BSTR RelativeName]
//              [IUnknown** ppObject]
//              [BOOL bNamespaceRelative]
//
//  Returns:    HRESULT
//
//  Modifies:   *ppObject
//
//----------------------------------------------------------------------------
HRESULT
RelativeGetObject(
    BSTR ADsPath,
    BSTR ClassName,
    BSTR RelativeName,
    CCredentials& Credentials,
    IDispatch * FAR* ppObject,
    BOOL bNamespaceRelative
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszBuffer = NULL;
    DWORD dwLen;

    *ppObject = NULL;

    if (!RelativeName || !*RelativeName) {
        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

    dwLen = wcslen(ADsPath) + wcslen(RelativeName) + wcslen(ClassName) + 4;

    pszBuffer = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));

    if (!pszBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    wcscpy(pszBuffer, ADsPath);

    if (bNamespaceRelative)
        wcscat(pszBuffer, L"//");
    else
        wcscat(pszBuffer, L"/");
    wcscat(pszBuffer, RelativeName);

    if (ClassName && *ClassName) {
        wcscat(pszBuffer,L",");
        wcscat(pszBuffer, ClassName);
    }

    hr = ::GetObject(
                pszBuffer,
                Credentials,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pszBuffer) {
        FreeADsMem(pszBuffer);
    }

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//  Function:  GetObject
//
//  Synopsis:  Called by ResolvePathName to return an object
//
//  Arguments:  [LPWSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//----------------------------------------------------------------------------
HRESULT
GetObject(
    LPWSTR szBuffer,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr;
    DWORD dwStatus = NO_ERROR;

    WCHAR szCommonName[MAX_PATH+MAX_PROVIDER_TOKEN_LENGTH];
    LPWSTR pszParent = NULL;

    IMSAdminBase * pAdminBase = NULL;
    METADATA_HANDLE hObjHandle = NULL;
    METADATA_RECORD mdrData;

    LPWSTR pszIISPathName = NULL;

    WCHAR DataBuf[MAX_PATH];
    DWORD dwReqdBufferLen;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);

    IIsSchema *pSchema = NULL;

    IADs * pADs = NULL;

    //
    // Parse the pathname
    //

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    //
    // Validate that this ADs pathname is to be processed by
    // us - as in the provider name is @IIS!
    //

    hr = InitServerInfo(pObjectInfo->TreeName, &pAdminBase, &pSchema);
    BAIL_ON_FAILURE(hr);

    hr = ValidateProvider(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = ValidateObjectType(pObjectInfo);

    switch (pObjectInfo->ObjectType) {

    case TOKEN_NAMESPACE:
        //
        // This means that this is a namespace object;
        // instantiate the namespace object
        //

        hr = GetNamespaceObject(
                pObjectInfo,
                Credentials,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;

    case TOKEN_SCHEMA:

        hr = GetSchemaObject(
                pObjectInfo,
                pSchema,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;

    case TOKEN_CLASS:

        hr = GetClassObject(
                pObjectInfo,
                pSchema,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;

    case TOKEN_PROPERTY:

        hr = GetPropertyObject(
                pObjectInfo,
                pSchema,
                ppObject
                );
        BAIL_ON_FAILURE(hr);
        break;

    case TOKEN_SYNTAX:

        hr = GetSyntaxObject(
                pObjectInfo,
                ppObject
                );
        BAIL_ON_FAILURE(hr);
        break;

    default:

        pszIISPathName = AllocADsStr(szBuffer);

        if (!pszIISPathName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *pszIISPathName = L'\0';
        hr = BuildIISPathFromADsPath(
                        pObjectInfo,
                        pszIISPathName
                        );
        BAIL_ON_FAILURE(hr);

        hr = OpenAdminBaseKey(
                    pObjectInfo->TreeName,
                    (LPWSTR)pszIISPathName,
                    METADATA_PERMISSION_READ,
                    &pAdminBase,
                    &hObjHandle
                    );
        BAIL_ON_FAILURE(hr);

        //
        // Find out Class Name
        //

        mdrData.dwMDIdentifier = MD_KEY_TYPE;
        mdrData.dwMDDataType = STRING_METADATA;
        mdrData.dwMDUserType = ALL_METADATA;
        mdrData.dwMDAttributes = METADATA_INHERIT;
        mdrData.dwMDDataLen = MAX_PATH;
        mdrData.pbMDData = (PBYTE)DataBuf;

        hr = pAdminBase->GetData(
                    hObjHandle,
                    L"",
                    &mdrData,
                    &dwReqdBufferLen
                    );

        if (FAILED(hr)) {
            if (hr == MD_ERROR_DATA_NOT_FOUND) {

                memcpy((LPWSTR)DataBuf, DEFAULT_SCHEMA_CLASS_W, 
                       SIZEOF_DEFAULT_CLASS_W);

                if (pObjectInfo->ClassName[0] != L'\0' &&
                    _wcsicmp((LPWSTR)pObjectInfo->ClassName, DataBuf)) {
                    hr = E_ADS_BAD_PARAMETER;
                    BAIL_ON_FAILURE(hr);
                }
            }
            else {
                BAIL_ON_FAILURE(hr);
            }
        }
        else {

            if (pObjectInfo->ClassName[0] != L'\0' &&
                _wcsicmp((LPWSTR)pObjectInfo->ClassName, DataBuf)) {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            }

            hr = pSchema->ValidateClassName((LPWSTR)DataBuf);
            if (hr == E_ADS_SCHEMA_VIOLATION) {
                memcpy((LPWSTR)DataBuf, DEFAULT_SCHEMA_CLASS_W, 
                       SIZEOF_DEFAULT_CLASS_W);
            }
        }

        //
        // Close the handle now
        //

        if (hObjHandle) {
            CloseAdminBaseKey(pAdminBase, hObjHandle);
            hObjHandle = NULL;
        }

        pszParent = AllocADsStr(szBuffer);

        if (!pszParent) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *pszParent = L'\0';

        hr = BuildADsParentPath(
                    szBuffer,
                    pszParent,
                    szCommonName
                    );
        BAIL_ON_FAILURE(hr);

        hr = CIISGenObject::CreateGenericObject(
                        pszParent,
                        szCommonName,
                        (LPWSTR)DataBuf,
                        Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)&pADs
                        );
        BAIL_ON_FAILURE(hr);

        hr = pADs->QueryInterface(
                    IID_IDispatch,
                    ppObject
                    );
        BAIL_ON_FAILURE(hr);

    }

error:

    if (pAdminBase && hObjHandle) {
        CloseAdminBaseKey(pAdminBase, hObjHandle);
    }

    if (pADs) {
        pADs->Release();
    }

    if (pszIISPathName) {
        FreeADsStr(pszIISPathName);
    }

    if (pszParent) {
        FreeADsStr(pszParent);
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);
}

HRESULT
BuildIISPathFromADsPath(
    LPWSTR szADsPathName,
    LPWSTR * pszIISPathName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szADsPathName);
    DWORD i = 0;
    HRESULT hr;
    LPWSTR szIISPathName = NULL;

    *pszIISPathName = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    szIISPathName = AllocADsStr(szADsPathName);
    if (!szIISPathName) {

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *szIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(pObjectInfo, szIISPathName);
    BAIL_ON_FAILURE(hr);

    *pszIISPathName = szIISPathName;

error:

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

}


HRESULT
BuildIISPathFromADsPath(
    POBJECTINFO pObjectInfo,
    LPWSTR pszIISPathName
    )
{

    DWORD dwNumComponents = 0;
    DWORD i = 0;

    dwNumComponents = pObjectInfo->NumComponents;

    //
    // wcscat "LM" to IIS Metabase path
    //

    wcscat(pszIISPathName, L"/LM/");

    if (dwNumComponents) {

        for (i = 0; i < dwNumComponents; i++) {

            wcscat(pszIISPathName, pObjectInfo->ComponentArray[i].szComponent);
            if( i < dwNumComponents -1 ) {
                wcscat(pszIISPathName,L"/");
            }
        }
    }

    RRETURN(S_OK);

}


HRESULT
BuildADsParentPath(
    LPWSTR szBuffer,
    LPWSTR szParent,
    LPWSTR szCommonName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr;
    LPWSTR pszComponent = NULL, pszValue = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;


    if (!dwNumComponents && !pObjectInfo->TreeName) {
        //
        // There are no CNs in this pathname and
        // no tree name specified. This is the
        // namespace object - its parent is the
        // @ADs! object
        //

        wsprintf(szParent,L"ADs:");

        hr = S_OK;

    } else if (!dwNumComponents && pObjectInfo->TreeName) {
        //
        // There are no CNs in this pathname and a tree
        // name has been specified. This is the root
        // object - its parent is the  @IIS! object

        wsprintf(szParent, L"%s:", pObjectInfo->ProviderName);

        //
        // And the common name is the TreeName
        //

        wsprintf(szCommonName,L"%s", pObjectInfo->TreeName);

        hr = S_OK;

    }else {
        //
        // There are one or more CNs, a tree name has been
        // specified. In the worst case the parent is the
        // root object. In the best case a long CN.
        //

        wsprintf(
            szParent, L"%s://%s",
            pObjectInfo->ProviderName,
            pObjectInfo->TreeName
            );

        for (i = 0; i < dwNumComponents - 1; i++) {

            wcscat(szParent, L"/");


            pszComponent =  pObjectInfo->ComponentArray[i].szComponent;
            pszValue = pObjectInfo->ComponentArray[i].szValue;


            if (pszComponent && pszValue) {

                wcscat(
                    szParent,
                    pObjectInfo->ComponentArray[i].szComponent
                    );
                wcscat(szParent,L"=");
                wcscat(
                    szParent,
                    pObjectInfo->ComponentArray[i].szValue
                    );
            }else if (pszComponent){

                wcscat(
                    szParent,
                    pObjectInfo->ComponentArray[i].szComponent
                    );

            }else {
                //
                // Error - we should never hit this case!!
                //

            }
        }

        //
        // And the common name is the last component
        //

        pszComponent =  pObjectInfo->ComponentArray[dwNumComponents - 1].szComponent;
        pszValue = pObjectInfo->ComponentArray[dwNumComponents - 1].szValue;


        if (pszComponent && pszValue) {

            wsprintf(szCommonName, L"%s=%s",pszComponent, pszValue);

        }else if (pszComponent){

            wsprintf(szCommonName, L"%s", pszComponent);

        }else {
            //
            // Error - we should never hit this case!!
            //

        }

    }

error:

    FreeObjectInfo( &ObjectInfo );
    RRETURN(hr);

}

HRESULT
BuildADsParentPath(
    POBJECTINFO pObjectInfo,
    LPWSTR szParent,
    LPWSTR szCommonName
    )
{
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr;
    LPWSTR pszComponent = NULL, pszValue = NULL;

    dwNumComponents = pObjectInfo->NumComponents;

    if (!dwNumComponents && !pObjectInfo->TreeName) {
        //
        // There are no CNs in this pathname and
        // no tree name specified. This is the
        // namespace object - its parent is the
        // @ADs! object
        //

        wsprintf(szParent,L"ADs:");

        RRETURN(S_OK);

    } else if (!dwNumComponents && pObjectInfo->TreeName) {
        //
        // There are no CNs in this pathname and a tree
        // name has been specified. This is the root
        // object - its parent is the  @IIS! object

        wsprintf(szParent, L"%s:", pObjectInfo->ProviderName);

        //
        // And the common name is the TreeName. Remember the
        // "//" will be added on  when we reconstruct the full
        // pathname
        //

        wsprintf(szCommonName,L"%s", pObjectInfo->TreeName);


        RRETURN(S_OK);


    }else {
        //
        // There are one or more CNs, a tree name has been
        // specified. In the worst case the parent is the
        // root object. In the best case a long CN.
        //

        wsprintf(
            szParent, L"%s://%s",
            pObjectInfo->ProviderName,
            pObjectInfo->TreeName
            );

        for (i = 0; i < dwNumComponents - 1; i++) {

            wcscat(szParent, L"/");


            pszComponent =  pObjectInfo->ComponentArray[i].szComponent;
            pszValue = pObjectInfo->ComponentArray[i].szValue;


            if (pszComponent && pszValue) {

                wcscat(
                    szParent,
                    pObjectInfo->ComponentArray[i].szComponent
                    );
                wcscat(szParent,L"=");
                wcscat(
                    szParent,
                    pObjectInfo->ComponentArray[i].szValue
                    );
            }else if (pszComponent){

                wcscat(
                    szParent,
                    pObjectInfo->ComponentArray[i].szComponent
                    );

            }else {
                //
                // Error - we should never hit this case!!
                //

            }
        }

        //
        // And the common name is the last component
        //

        pszComponent =  pObjectInfo->ComponentArray[dwNumComponents - 1].szComponent;
        pszValue = pObjectInfo->ComponentArray[dwNumComponents - 1].szValue;


        if (pszComponent && pszValue) {

            wsprintf(szCommonName, L"%s=%s",pszComponent, pszValue);

        }else if (pszComponent){

            wsprintf(szCommonName, L"%s", pszComponent);

        }else {
            //
            // Error - we should never hit this case!!
            //
        }
    }

    RRETURN(S_OK);
}



VOID
FreeObjectInfo(
    POBJECTINFO pObjectInfo
    )
{
    if ( !pObjectInfo )
        return;

    FreeADsStr( pObjectInfo->ProviderName );
    FreeADsStr( pObjectInfo->TreeName );

    for ( DWORD i = 0; i < pObjectInfo->NumComponents; i++ ) {
        
        if (pObjectInfo->ComponentArray[i].szComponent) {
            FreeADsStr( pObjectInfo->ComponentArray[i].szComponent );
        }
        if (pObjectInfo->ComponentArray[i].szValue) {
            FreeADsStr( pObjectInfo->ComponentArray[i].szValue );
        }
    }

    if (pObjectInfo->ComponentArray) {
        FreeADsMem(pObjectInfo->ComponentArray);
    }

    // We don't need to free pObjectInfo since the object is always a static
    // variable on the stack.
}


//+---------------------------------------------------------------------------
// Function:    GetNamespaceObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
//----------------------------------------------------------------------------
HRESULT
GetNamespaceObject(
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr;

    hr = ValidateNamespaceObject(
                pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    hr = CIISNamespace::CreateNamespace(
                L"ADs:",
                L"IIS:",
                Credentials,
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                ppObject
                );


error:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    GetSchemaObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
//----------------------------------------------------------------------------
HRESULT
GetSchemaObject(
    POBJECTINFO pObjectInfo,
    IIsSchema *pSchemaCache,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwObjectType = 0;

    hr = ValidateSchemaObject(
                pObjectInfo,
                &dwObjectType
                );
    BAIL_ON_FAILURE(hr);

    //
    // Note: The "error:" tag is at the end of the switch statement,
    //       so we can simply break out.
    //

    switch (dwObjectType) {
    case IIS_SCHEMA_ID:
        hr = GetIntSchemaObject(
                pObjectInfo,
                ppObject
                );
        break;

    case IIS_CLASSPROP_ID:
        hr = GetClassObject(
                pObjectInfo,
                pSchemaCache,
                ppObject
                );
        if (FAILED(hr)) {

            hr = GetPropertyObject(
                        pObjectInfo,
                        pSchemaCache,
                        ppObject
                        );
            if (FAILED(hr)) {

                hr = GetSyntaxObject(
                            pObjectInfo,
                            ppObject
                            );
            }
            if (FAILED(hr)) {
                hr = E_ADS_UNKNOWN_OBJECT;
            }
        }
        break;

    default:
        hr = E_ADS_UNKNOWN_OBJECT;
        break;
    }

error:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetSchemaObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
HRESULT
GetIntSchemaObject(
    POBJECTINFO pObjInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_PATH+MAX_PROVIDER_TOKEN_LENGTH];
    WCHAR ADsName[MAX_PATH];
    HRESULT hr = S_OK;

    if (pObjInfo->NumComponents != 1)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjInfo->ComponentArray[0].szComponent, SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildADsParentPath(pObjInfo, ADsParent, ADsName);
    BAIL_ON_FAILURE(hr);

    hr = CIISSchema::CreateSchema( pObjInfo->TreeName,
                                   ADsParent,
                                   pObjInfo->ComponentArray[0].szComponent,
                                   ADS_OBJECT_BOUND,
                                   IID_IUnknown,
                                   (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetClassObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
HRESULT
GetClassObject(
    POBJECTINFO pObjInfo,
    IIsSchema *pSchemaCache,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_PATH+MAX_PROVIDER_TOKEN_LENGTH];
    WCHAR ADsName[MAX_PATH];
    HRESULT hr = S_OK;
    DWORD i;
    DWORD dwNumComponents = pObjInfo->NumComponents;

    if ( dwNumComponents != 2 && dwNumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( (dwNumComponents == 2 && 
         _wcsicmp( pObjInfo->ComponentArray[0].szComponent, SCHEMA_NAME ) != 0 ) || 
         (dwNumComponents == 3 && 
         _wcsicmp( pObjInfo->ComponentArray[0].szComponent, CLASS_CLASS_NAME ) != 0 )) 
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Validate the given class name
    //
    hr = pSchemaCache->ValidateClassName(
                pObjInfo->ComponentArray[dwNumComponents-1].szComponent);
    BAIL_ON_FAILURE(hr);
    
    //
    // Class name found, create and return the object
    //

    hr = BuildADsParentPath(pObjInfo, ADsParent, ADsName);
    BAIL_ON_FAILURE(hr);

    hr = CIISClass::CreateClass( ADsParent,
                                 pObjInfo->ComponentArray[dwNumComponents-1].szComponent,
                                 ADS_OBJECT_BOUND,
                                 IID_IUnknown,
                                 (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetSyntaxObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
HRESULT
GetSyntaxObject(
    POBJECTINFO pObjInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_PATH+MAX_PROVIDER_TOKEN_LENGTH];
    WCHAR ADsName[MAX_PATH];
    HRESULT hr = S_OK;
    DWORD i;
    DWORD dwNumComponents = pObjInfo->NumComponents;

    if (dwNumComponents != 2 && dwNumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( (dwNumComponents == 2 && 
         _wcsicmp( pObjInfo->ComponentArray[0].szComponent, SCHEMA_NAME ) != 0 ) || 
         (dwNumComponents == 3 && 
         _wcsicmp( pObjInfo->ComponentArray[0].szComponent, SYNTAX_CLASS_NAME ) != 0 )) 
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Look for the given syntax name
    //

    for ( i = 0; i < g_cIISSyntax; i++ )
    {
         if ( _wcsicmp( g_aIISSyntax[i].bstrName,
                        pObjInfo->ComponentArray[dwNumComponents-1].szComponent ) == 0 )
             break;
    }

    if ( i == g_cIISSyntax )
    {
        // Syntax name not found, return error

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Syntax name found, create and return the object
    //

    hr = BuildADsParentPath(pObjInfo, ADsParent, ADsName);
    BAIL_ON_FAILURE(hr);

    hr = CIISSyntax::CreateSyntax( ADsParent,
                                   &(g_aIISSyntax[i]),
                                   ADS_OBJECT_BOUND,
                                   IID_IUnknown,
                                   (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetPropertyObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
HRESULT
GetPropertyObject(
    POBJECTINFO pObjInfo,
    IIsSchema *pSchemaCache,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_PATH+MAX_PROVIDER_TOKEN_LENGTH];
    WCHAR ADsName[MAX_PATH];
    HRESULT hr = S_OK;
    DWORD i;
    DWORD dwNumComponents = pObjInfo->NumComponents;

    if (dwNumComponents != 2 && dwNumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( (dwNumComponents == 2 && 
         _wcsicmp( pObjInfo->ComponentArray[0].szComponent, SCHEMA_NAME ) != 0 ) || 
         (dwNumComponents == 3 && 
         _wcsicmp( pObjInfo->ComponentArray[0].szComponent, PROPERTY_CLASS_NAME ) != 0 )) 
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Validate the given property name
    //
    hr = pSchemaCache->ValidatePropertyName(
                pObjInfo->ComponentArray[dwNumComponents-1].szComponent);
    BAIL_ON_FAILURE(hr);
    
    //
    // Property name is found, so create and return the object
    //

    hr = BuildADsParentPath(pObjInfo, ADsParent, ADsName);
    BAIL_ON_FAILURE(hr);


    hr = CIISProperty::CreateProperty(
                             ADsParent,
                             pObjInfo->ComponentArray[dwNumComponents-1].szComponent,
                             ADS_OBJECT_BOUND,
                             IID_IUnknown,
                             (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}


HRESULT
ValidateNamespaceObject(
    POBJECTINFO pObjectInfo
    )
{
    if (!_wcsicmp(pObjectInfo->ProviderName, szProviderName)) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}


HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    )
{

    //
    // The provider name is case-sensitive.  This is a restriction that OLE
    // has put on us.
    //
    if (!(wcscmp(pObjectInfo->ProviderName, szProviderName))) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}


HRESULT
ValidateObjectType(
    POBJECTINFO pObjectInfo
    )
{

    if (pObjectInfo->ProviderName && !pObjectInfo->TreeName
            && !pObjectInfo->NumComponents) {
        pObjectInfo->ObjectType = TOKEN_NAMESPACE;
    }else if (pObjectInfo->ProviderName && pObjectInfo->TreeName
                && pObjectInfo->NumComponents) {

        if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent,L"schema")) {
            pObjectInfo->ObjectType = TOKEN_SCHEMA;
        }
        else if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent,L"class")) {
            pObjectInfo->ObjectType = TOKEN_CLASS;
        }
        else if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent,L"property")) {
            pObjectInfo->ObjectType = TOKEN_PROPERTY;
        }
        else if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent,L"syntax")) {
            pObjectInfo->ObjectType = TOKEN_SYNTAX;
        }

    }

    RRETURN(S_OK);
}


HRESULT
ValidateSchemaObject(
    POBJECTINFO pObjectInfo,
    PDWORD pdwObjectType
    )
{
    DWORD dwNumComponents = 0;

    dwNumComponents = pObjectInfo->NumComponents;

    switch (dwNumComponents) {

    case 1:
        if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent, L"schema")) {
            *pdwObjectType = IIS_SCHEMA_ID;
            RRETURN(S_OK);
        }
        break;

    case 2:

        *pdwObjectType = IIS_CLASSPROP_ID;
        RRETURN(S_OK);


    default:
        break;


    }

    RRETURN(E_FAIL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\iis2.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  iis2.h
//
//  Contents:  Macros for ADSI IIS methods
//
//  History:   25-Feb-97   SophiaC    Created.
//
//----------------------------------------------------------------------------
#define IIS_CLSID_IISNamespace             d6bfa35e-89f2-11d0-8527-00c04fd8d503
#define IIS_LIBIID_IISOle                  49d704a0-89f7-11d0-8527-00c04fd8d503
#define IIS_CLSID_IISProvider              d88966de-89f2-11d0-8527-00c04fd8d503
#define IIS_CLSID_MimeType                 9036B028-A780-11d0-9B3D-0080C710EF95
#define IIS_IID_IISMimeType                9036B027-A780-11d0-9B3D-0080C710EF95

#define IIS_CLSID_IPSecurity               F3287520-BBA3-11d0-9BDC-00A0C922E703
#define IIS_IID_IISIPSecurity              F3287521-BBA3-11d0-9BDC-00A0C922E703

#define IIS_CLSID_PropertyAttribute        FD2280A8-51A4-11D2-A601-3078302C2030
#define IIS_IID_IISPropertyAttribute       50E21930-A247-11D1-B79C-00A0C922E703

#define IIS_IID_IISBaseObject              4B42E390-0E96-11d1-9C3F-00A0C922E703
#define IIS_IID_IISSchemaObject            B6865A9C-3F64-11D2-A600-00A0C922E703


#define PROPERTY_RO(name,type, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] type * retval);

#define PROPERTY_LONG_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] long ln##name);

#define PROPERTY_LONG_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);

#define PROPERTY_BSTR_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] BSTR bstr##name);

#define PROPERTY_BSTR_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);

#define PROPERTY_VARIANT_BOOL_RW(name, prid)          \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT_BOOL * retval); \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] VARIANT_BOOL f##name);

#define PROPERTY_VARIANT_BOOL_RO(name, prid)          \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT_BOOL * retval);

#define PROPERTY_VARIANT_RW(name, prid)               \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT * retval); \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] VARIANT v##name);

#define PROPERTY_VARIANT_RO(name, prid)               \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT * retval); \

#define PROPERTY_DATE_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] DATE * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] DATE da##name);

#define PROPERTY_DATE_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] DATE * retval);

#define PROPERTY_DISPATCH_RW(name, prid)              \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] IDispatch ** retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] IDispatch * p##name);


#define DECLARE_IISMimeType_METHODS \
    STDMETHOD(get_MimeType)(THIS_ BSTR FAR* retval);  \
    STDMETHOD(put_MimeType)(THIS_ BSTR bstrMimeType); \
    STDMETHOD(get_Extension)(THIS_ BSTR FAR* retval); \
    STDMETHOD(put_Extension)(THIS_ BSTR bstrExtension);

#define DECLARE_IISIPSecurity_METHODS \
    STDMETHOD(get_IPDeny)(THIS_ VARIANT FAR* retval); \
    STDMETHOD(put_IPDeny)(THIS_ VARIANT pVarIPDeny); \
    STDMETHOD(get_IPGrant)(THIS_ VARIANT FAR* retval); \
    STDMETHOD(put_IPGrant)(THIS_ VARIANT pVarIPGrant); \
    STDMETHOD(get_DomainDeny)(THIS_ VARIANT FAR* retval); \
    STDMETHOD(put_DomainDeny)(THIS_ VARIANT pVarDomainDeny); \
    STDMETHOD(get_DomainGrant)(THIS_ VARIANT FAR* retval); \
    STDMETHOD(put_DomainGrant)(THIS_ VARIANT pVarDomainGrant); \
    STDMETHOD(get_GrantByDefault)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_GrantByDefault)(THIS_ VARIANT_BOOL bGrantByDefault);


#define DECLARE_IISBaseObject_METHODS \
    STDMETHOD(GetDataPaths) (         \
         THIS_ \
         BSTR bstrName, \
         LONG lnAttribute,      \
         VARIANT FAR* pvPaths); \
    STDMETHOD(GetPropertyAttribObj) ( \
         THIS_ \
         BSTR bstrName, \
         IDispatch **ppObject);

#define DECLARE_IISSchemaObject_METHODS \
    STDMETHOD(GetSchemaPropertyAttributes) (         \
         THIS_ \
         BSTR bstrName, \
         IDispatch **ppObject); \
    STDMETHOD(PutSchemaPropertyAttributes) (         \
         THIS_ \
         IDispatch *pObject);

#define DECLARE_IISPropertyAttribute_METHODS \
    STDMETHOD(get_PropName)(THIS_ BSTR FAR* retval);  \
    STDMETHOD(get_MetaId)(THIS_ LONG FAR* retval); \
    STDMETHOD(put_MetaId)(THIS_ LONG lMetaId); \
    STDMETHOD(get_UserType)(THIS_ LONG FAR* retval); \
    STDMETHOD(put_UserType)(THIS_ LONG lUserType); \
    STDMETHOD(get_AllAttributes)(THIS_ LONG FAR* retval); \
    STDMETHOD(get_Inherit)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_Inherit)(THIS_ VARIANT_BOOL bInherit); \
    STDMETHOD(get_PartialPath)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_PartialPath)(THIS_ VARIANT_BOOL bPartialPath); \
    STDMETHOD(get_Secure)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_Secure)(THIS_ VARIANT_BOOL bSecure); \
    STDMETHOD(get_Reference)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_Reference)(THIS_ VARIANT_BOOL bReference); \
    STDMETHOD(get_Volatile)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_Volatile)(THIS_ VARIANT_BOOL bVolatile); \
    STDMETHOD(get_Isinherit)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_Isinherit)(THIS_ VARIANT_BOOL bIsinherit); \
    STDMETHOD(get_InsertPath)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_InsertPath)(THIS_ VARIANT_BOOL bInsertPath);  \
    STDMETHOD(get_Default)(THIS_ VARIANT FAR* retval); \
    STDMETHOD(put_Default)(THIS_ VARIANT VarDefaults);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\guid.c ===
/*++

   Copyright (c) 1997-1999 Microsoft Corporation

   Module  Name :

       adsiis_guid.c

   Abstract:

        Contains IIDs, CLSIDs, and LIBIDs used by ADSIIS

   Environment:

      Win32 User Mode

--*/

#define INITGUID


#include <ole2.h>
#include "iwamreg.h"
#include "iadmw.h"


//--------------------------------------------------------------------------
//
//  IIS CLSIDs
//
//--------------------------------------------------------------------------

DEFINE_GUID(CLSID_IISGenObject,0x8B645280L,0x7BA4,0x11CF,0xB0,0x3D,0x00,0xAA,0x00,0x6E,0x09,0x75);

DEFINE_GUID(CLSID_IISTree,0x47E94340L,0x994F,0x11CF,0xA5,0xF2,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_IISSchema,0x65E252B0L,0xB4C8,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_IISClass,0x946260E0L,0xB505,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_IISProperty,0x93F8FBF0L,0xB67B,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_IISSyntax,0x953DBC50L,0xEBDB,0x11CF,0x8A,0xBC,0x00,0xC0,0x4F,0xD8,0xD5,0x03);



DEFINE_GUID(LIBID_IISOle,0x49D704A0L,0x89F7,0x11D0,0x85,0x27,0x00,0xC0,0x4F,0xD8,0xD5,0x03);

DEFINE_GUID(CLSID_IISNamespace,0xD6BFA35EL,0x89F2,0x11D0,0x85,0x27,0x00,0xC0,0x4F,0xD8,0xD5,0x03);

DEFINE_GUID(CLSID_IISProvider,0xD88966DEL,0x89F2,0x11D0,0x85,0x27,0x00,0xC0,0x4F,0xD8,0xD5,0x03);

DEFINE_GUID(IID_IISMimeType, 0x9036b027, 0xa780, 0x11d0, 0x9b, 0x3d, 0x0, 0x80, 0xc7, 0x10, 0xef, 0x95);

DEFINE_GUID(CLSID_IISMimeType, 0x9036b028, 0xa780, 0x11d0, 0x9b, 0x3d, 0x0, 0x80, 0xc7, 0x10, 0xef, 0x95);

DEFINE_GUID(CLSID_IPSecurity, 0xf3287520, 0xbba3, 0x11d0, 0x9b, 0xdc, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x3 );

DEFINE_GUID(IID_IISIPSecurity, 0xf3287521, 0xbba3, 0x11d0, 0x9b, 0xdc, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x3 );

DEFINE_GUID(IID_IISBaseObject, 0x4b42e390, 0xe96, 0x11d1, 0x9c, 0x3f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x3);

DEFINE_GUID(IID_IISSchemaObject, 0xb6865a9c, 0x3f64, 0x11d2, 0xa6, 0x00, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x3);

DEFINE_GUID(CLSID_IISPropertyAttribute, 0xFD2280A8, 0x51A4, 0x11d2, 0xa6, 0x01, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

DEFINE_GUID(IID_IISPropertyAttribute, 0x50e21930, 0xa247, 0x11d1, 0xb7, 0x9c, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x3 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\iiscopy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       IIScopy.cxx
//
//  Contents:   IIS Object Copy Routines
//
//  Functions:
//
//  History:    01-Mar-97   SophiaC   Created.
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//
//----------------------------------------------------------------------------
#include "iis.hxx"

//
// IISType objects copy code
//

HRESULT
IISTypeCopyIISSynIdDWORD(
    PIISOBJECT lpIISSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    lpIISDestObject->IISType = lpIISSrcObject->IISType;

    lpIISDestObject->IISValue.value_1.dwDWORD =
                                lpIISSrcObject->IISValue.value_1.dwDWORD;
    RRETURN(hr);
}

HRESULT
IISTypeCopyIISSynIdSTRING(
    PIISOBJECT lpIISSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    lpIISDestObject->IISType = lpIISSrcObject->IISType;

    lpIISDestObject->IISValue.value_2.String =
                    (LPWSTR)AllocADsStr(
                            lpIISSrcObject->IISValue.value_2.String
                            );

    RRETURN(hr);
}


HRESULT
IISTypeCopyIISSynIdEXPANDSZ(
    PIISOBJECT lpIISSrcObject,
    PIISOBJECT lpIISDestObject
    )

{
    HRESULT hr = S_OK;

    lpIISDestObject->IISType = lpIISSrcObject->IISType;

    lpIISDestObject->IISValue.value_3.ExpandSz =
                    (LPWSTR)AllocADsStr(
                            lpIISSrcObject->IISValue.value_3.ExpandSz
                            );
    RRETURN(hr);
}


HRESULT
IISTypeCopyIISSynIdMULTISZ(
    PIISOBJECT lpIISSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    lpIISDestObject->IISType = lpIISSrcObject->IISType;

    lpIISDestObject->IISValue.value_4.MultiSz =
                     (LPWSTR)AllocADsStr(
                                lpIISSrcObject->IISValue.value_4.MultiSz
                                );

    RRETURN(hr);
}


HRESULT
IISTypeCopyIISSynIdBINARY(
    PIISOBJECT lpIISSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD Length = 0;
    LPBYTE pBuffer = NULL;

    lpIISDestObject->IISType = lpIISSrcObject->IISType;
     
    Length = lpIISSrcObject->IISValue.value_5.Length;
    lpIISDestObject->IISValue.value_5.Length = Length;

    if (Length) {
        pBuffer = (LPBYTE)AllocADsMem(Length);
        if (!pBuffer) {
            RRETURN(S_FALSE);
        }
        memcpy(pBuffer, lpIISSrcObject->IISValue.value_5.Binary, Length);
    }

    lpIISDestObject->IISValue.value_5.Binary = pBuffer;

    RRETURN(hr);
}


HRESULT
IISTypeCopyIISSynIdMIMEMAP(
    PIISOBJECT lpIISSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    lpIISDestObject->IISType = lpIISSrcObject->IISType;

    lpIISDestObject->IISValue.value_6.MimeMap =
                     (LPWSTR)AllocADsStr(
                                lpIISSrcObject->IISValue.value_4.MultiSz
                                );

    RRETURN(hr);
}

HRESULT
IISTypeCopy(
    PIISOBJECT lpIISSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpIISSrcObject->IISType) {
    case IIS_SYNTAX_ID_DWORD:
        hr = IISTypeCopyIISSynIdDWORD(
                lpIISSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_STRING:
        hr = IISTypeCopyIISSynIdSTRING(
                lpIISSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_EXPANDSZ:
        hr = IISTypeCopyIISSynIdEXPANDSZ(
                lpIISSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_MULTISZ:
        hr = IISTypeCopyIISSynIdMULTISZ(
                lpIISSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_BINARY:
    case IIS_SYNTAX_ID_NTACL:
    case IIS_SYNTAX_ID_IPSECLIST:
        hr = IISTypeCopyIISSynIdBINARY(
                lpIISSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_MIMEMAP:
        hr = IISTypeCopyIISSynIdMIMEMAP(
                lpIISSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
        hr = IISTypeCopyIISSynIdDWORD(
                lpIISSrcObject,
                lpIISDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
IISTypeCopyConstruct(
    LPIISOBJECT pIISSrcObjects,
    DWORD dwNumObjects,
    LPIISOBJECT * ppIISDestObjects
    )
{

    DWORD i = 0;
    LPIISOBJECT pIISDestObjects = NULL;
    HRESULT hr = S_OK;
    DWORD dwNumObj;


    if (pIISSrcObjects->IISType == IIS_SYNTAX_ID_BINARY    ||
        pIISSrcObjects->IISType == IIS_SYNTAX_ID_IPSECLIST ||
        pIISSrcObjects->IISType == IIS_SYNTAX_ID_NTACL) {
        dwNumObj = 1;
    }
    else {
        dwNumObj = dwNumObjects;
    }

    pIISDestObjects = (LPIISOBJECT)AllocADsMem(
                                    dwNumObj * sizeof(IISOBJECT)
                                    );

    if (!pIISDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObj; i++ ) {
         hr = IISTypeCopy(pIISSrcObjects + i, pIISDestObjects + i);
     }

     *ppIISDestObjects = pIISDestObjects;

     RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\iisfree.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       IISfree.cxx
//
//  Contents:   IIS Object Free Routines
//
//  Functions:
//
//  History:    01-Mar-97   SophiaC   Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"

//
// IISType objects free code
//


HRESULT
IISTypeFreeIISSynIdDWORD(
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    RRETURN(hr);
}

HRESULT
IISTypeFreeIISSynIdSTRING(
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpIISDestObject->IISValue.value_2.String);

    RRETURN(hr);
}


HRESULT
IISTypeFreeIISSynIdEXPANDSZ(
    PIISOBJECT lpIISDestObject
    )

{
    HRESULT hr = S_OK;

    FreeADsStr(lpIISDestObject->IISValue.value_3.ExpandSz);
    RRETURN(hr);
}

HRESULT
IISTypeFreeIISSynIdMULTISZ(
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpIISDestObject->IISValue.value_4.MultiSz);

    RRETURN(hr);
}

HRESULT
IISTypeFreeIISSynIdBINARY(
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    if (lpIISDestObject->IISValue.value_5.Binary) {
        FreeADsMem(lpIISDestObject->IISValue.value_5.Binary);
    }

    RRETURN(hr);
}

HRESULT
IISTypeFreeIISSynIdBOOL(
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    RRETURN(hr);
}

HRESULT
IISTypeFreeIISSynIdMIMEMAP(
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpIISDestObject->IISValue.value_6.MimeMap);

    RRETURN(hr);
}

HRESULT
IISTypeClear(
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpIISDestObject->IISType) {
    case IIS_SYNTAX_ID_DWORD:
        hr = IISTypeFreeIISSynIdDWORD(
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_STRING:
        hr = IISTypeFreeIISSynIdSTRING(
                lpIISDestObject
                );
        break;


    case IIS_SYNTAX_ID_EXPANDSZ:
        hr = IISTypeFreeIISSynIdEXPANDSZ(
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_MULTISZ:
        hr = IISTypeFreeIISSynIdMULTISZ(
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_BINARY:
    case IIS_SYNTAX_ID_NTACL:
    case IIS_SYNTAX_ID_IPSECLIST:
        hr = IISTypeFreeIISSynIdBINARY(
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_MIMEMAP:
        hr = IISTypeFreeIISSynIdMIMEMAP(
                lpIISDestObject
                );
        break;


    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
        hr = IISTypeFreeIISSynIdBOOL(
                lpIISDestObject
                );
        break;


    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



void
IISTypeFreeIISObjects(
    PIISOBJECT pIISObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    if (pIISObject->IISType == IIS_SYNTAX_ID_BINARY ||
        pIISObject->IISType == IIS_SYNTAX_ID_IPSECLIST ||
        pIISObject->IISType == IIS_SYNTAX_ID_NTACL) {
        IISTypeClear(pIISObject);
    }
    else {
        for (i = 0; i < dwNumValues; i++ ) {
             IISTypeClear(pIISObject + i);
        }
    }

    FreeADsMem(pIISObject);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\iis2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       iis2var.cxx
//
//  Contents:   IIS Object to Variant Copy Routines
//
//  Functions:
//
//  History:    05-Mar-97   SophiaC   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//
//----------------------------------------------------------------------------
#include "iis.hxx"

//
//  IISType objects copy code
//

void
VarTypeFreeVarObjects(
    PVARIANT pVarObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumValues; i++ ) {
         VariantClear(pVarObject + i);
    }

    FreeADsMem(pVarObject);

    return;
}


HRESULT
IISTypeToVarTypeCopyIISSynIdDWORD(
								  IIsSchema *pSchema,
								  PIISOBJECT lpIISSrcObject,
								  PVARIANT lpVarDestObject
								 )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_I4;
    lpVarDestObject->lVal = lpIISSrcObject->IISValue.value_1.dwDWORD;

    RRETURN(hr);
}

HRESULT
IISTypeToVarTypeCopyIISSynIdSTRING(
								   IIsSchema *pSchema,
								   PIISOBJECT lpIISSrcObject,
								   PVARIANT lpVarDestObject
								  )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
            lpIISSrcObject->IISValue.value_2.String,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}


HRESULT
IISTypeToVarTypeCopyIISSynIdEXPANDSZ(
									 IIsSchema *pSchema,
									 PIISOBJECT lpIISSrcObject,
									 PVARIANT lpVarDestObject	
									)

{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr =  ADsAllocString(
            lpIISSrcObject->IISValue.value_3.ExpandSz,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}


HRESULT
IISTypeToVarTypeCopyIISSynIdMULTISZ(
									IIsSchema *pSchema,
									PIISOBJECT lpIISSrcObject,
									PVARIANT lpVarDestObject
								   )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr =  ADsAllocString(
               lpIISSrcObject->IISValue.value_4.MultiSz,
               &(lpVarDestObject->bstrVal)
               );

    RRETURN(hr);
}

HRESULT
IISTypeToVarTypeCopyIISSynIdBOOL(
								 IIsSchema *pSchema,
								 PIISOBJECT lpIISSrcObject,
								 PVARIANT lpVarDestObject
								)
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BOOL;
    lpVarDestObject->boolVal = lpIISSrcObject->IISValue.value_1.dwDWORD ?
                               VARIANT_TRUE : VARIANT_FALSE;

    RRETURN(hr);
}

HRESULT
IISTypeToVarTypeCopyIISSynIdBOOLBITMASK(
										IIsSchema *pSchema,
										LPWSTR pszPropertyName,
										PIISOBJECT lpIISSrcObject,
										PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwFlag = 0;

    pSchema->LookupBitMask(pszPropertyName, &dwFlag);

    lpVarDestObject->vt = VT_BOOL;
    lpVarDestObject->boolVal = 
           (lpIISSrcObject->IISValue.value_1.dwDWORD) & dwFlag ?
                               VARIANT_TRUE : VARIANT_FALSE;

    RRETURN(hr);
}


HRESULT
IISTypeToVarTypeCopyIISSynIdMIMEMAP(
									IIsSchema *pSchema,
									PIISOBJECT lpIISSrcObject,
									PVARIANT lpVarDestObject
								   )
{
    HRESULT hr = S_OK;

    IISMimeType * pMimeType = NULL;
 
    hr = CMimeType::CreateMimeType(
                IID_IISMimeType,
                (VOID**) &pMimeType
                );

    BAIL_ON_FAILURE(hr);

    hr = ((CMimeType*)pMimeType)->InitFromIISString( 
             lpIISSrcObject->IISValue.value_4.MultiSz);
    lpVarDestObject->vt = VT_DISPATCH;
    lpVarDestObject->pdispVal = pMimeType;

error:

    RRETURN(hr);
}

HRESULT
IISTypeToVarTypeCopyIISSynIdBinary(
    PIISOBJECT lpIISSrcObject,
    PVARIANT lpVarDestObject,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = lpIISSrcObject->IISValue.value_5.Length;;

    if (bReturnBinaryAsVT_VARIANT)
    {
       aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    }
    else
    {
       aList = SafeArrayCreate( VT_UI1, 1, &aBound );
    }
    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);
    memcpy( pArray, lpIISSrcObject->IISValue.value_5.Binary, aBound.cElements );
    SafeArrayUnaccessData( aList );

    if (bReturnBinaryAsVT_VARIANT)
    {
       V_VT(lpVarDestObject) = VT_ARRAY | VT_VARIANT;
    }
    else
    {
       V_VT(lpVarDestObject) = VT_ARRAY | VT_UI1;
    }
    V_ARRAY(lpVarDestObject) = aList;

    RRETURN(hr);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}

HRESULT
IISTypeToVarTypeCopyIISSynIdNTACL(
    PIISOBJECT lpIISSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
 
    lpVarDestObject->vt = VT_DISPATCH;

    hr = ConvertSecDescriptorToVariant(
                (PSECURITY_DESCRIPTOR)lpIISSrcObject->IISValue.value_5.Binary,
                lpVarDestObject
                );

    RRETURN(hr);
}

HRESULT
IISTypeToVarTypeCopyIISSynIdIPSECLIST(
    PIISOBJECT lpIISSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    IISIPSecurity * pIPSec = NULL;
 
    hr = CIPSecurity::CreateIPSecurity(
                IID_IISIPSecurity,
                (VOID**) &pIPSec
                );

    BAIL_ON_FAILURE(hr);

    hr = ((CIPSecurity*)pIPSec)->InitFromBinaryBlob( 
             lpIISSrcObject->IISValue.value_5.Binary,
             lpIISSrcObject->IISValue.value_5.Length);
    lpVarDestObject->vt = VT_DISPATCH;
    lpVarDestObject->pdispVal = pIPSec;

error:

    RRETURN(hr);
}

HRESULT
IISTypeToVarTypeCopy(
    IIsSchema *pSchema,
    LPWSTR pszPropertyName,
    PIISOBJECT lpIISSrcObject,
    PVARIANT lpVarDestObject,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    HRESULT hr = S_OK;
    switch (lpIISSrcObject->IISType) {
    case IIS_SYNTAX_ID_DWORD:
        hr = IISTypeToVarTypeCopyIISSynIdDWORD(
				pSchema,
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    case IIS_SYNTAX_ID_STRING:
        hr = IISTypeToVarTypeCopyIISSynIdSTRING(
				pSchema,
                lpIISSrcObject,
                lpVarDestObject
                );
        break;


    case IIS_SYNTAX_ID_EXPANDSZ:
        hr = IISTypeToVarTypeCopyIISSynIdEXPANDSZ(
				pSchema,
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    case IIS_SYNTAX_ID_MULTISZ:
        hr = IISTypeToVarTypeCopyIISSynIdMULTISZ(
				pSchema,
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    case IIS_SYNTAX_ID_BOOL:
        hr = IISTypeToVarTypeCopyIISSynIdBOOL(
				pSchema,
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    case IIS_SYNTAX_ID_BOOL_BITMASK:
        hr = IISTypeToVarTypeCopyIISSynIdBOOLBITMASK(
				pSchema,
                pszPropertyName,
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    case IIS_SYNTAX_ID_MIMEMAP:
        hr = IISTypeToVarTypeCopyIISSynIdMIMEMAP(
				pSchema,
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    case IIS_SYNTAX_ID_NTACL:
        hr = IISTypeToVarTypeCopyIISSynIdNTACL(
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    case IIS_SYNTAX_ID_BINARY:
        hr = IISTypeToVarTypeCopyIISSynIdBinary(
                lpIISSrcObject,
                lpVarDestObject,
                bReturnBinaryAsVT_VARIANT
                );
        break;

    case IIS_SYNTAX_ID_IPSECLIST:
        hr = IISTypeToVarTypeCopyIISSynIdIPSECLIST(
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
IISTypeToVarTypeCopyConstruct(
    IIsSchema *pSchema,
    LPWSTR pszPropertyName,
    LPIISOBJECT pIISSrcObjects,
    DWORD dwNumObjects,
    PVARIANT pVarDestObjects,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    long i = 0;
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;

    dwSyntaxId = pIISSrcObjects->IISType;
    if (dwSyntaxId == IIS_SYNTAX_ID_BINARY ||
        dwSyntaxId == IIS_SYNTAX_ID_IPSECLIST  ||
        dwSyntaxId == IIS_SYNTAX_ID_NTACL) {
        hr = IISTypeToVarTypeCopy( pSchema,
                                   pszPropertyName,
                                   pIISSrcObjects,
                                   pVarDestObjects,
                                   bReturnBinaryAsVT_VARIANT);
        RRETURN(hr);

    }

    VariantInit(pVarDestObjects);

    //  
    //  Check to see if IISType is a Multi-sz w/ only 1 empty string element
    //

    if (dwNumObjects == 1 && 
        (pIISSrcObjects->IISType == IIS_SYNTAX_ID_MULTISZ || 
         pIISSrcObjects->IISType == IIS_SYNTAX_ID_MIMEMAP )) {
         
        if (*pIISSrcObjects->IISValue.value_4.MultiSz == L'\0') {
            dwNumObjects = 0;
        }
    }

    // The following are for handling are multi-value properties
    //

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;

    aBound.cElements = dwNumObjects;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumObjects; i++ )
    {
        VARIANT v;

        VariantInit(&v);
        hr = IISTypeToVarTypeCopy( pSchema,
                                   pszPropertyName,
                                   pIISSrcObjects + i,
                                   &v,
                                   bReturnBinaryAsVT_VARIANT);
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarDestObjects) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       guid.h
//
//  Contents:   extern references for IIS guids
//
//  History:   
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// IISOle CLSIDs
//
//-------------------------------------------


//
// IISOle objects
//


extern const CLSID CLSID_IISGenObject;


extern const CLSID CLSID_IISTree;

extern const CLSID CLSID_IISSchema;

extern const CLSID CLSID_IISClass;

extern const CLSID CLSID_IISProperty;

extern const CLSID CLSID_IISSyntax;


extern const  CLSID LIBID_IISOle;

extern const  CLSID CLSID_IISNamespace;

extern const  CLSID CLSID_IISProvider;

extern const  CLSID CLSID_IISMimeType;

extern const  CLSID CLSID_IISPropertyAttribute;



#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\globdata.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  globdata.cxx
//
//  Contents:  Microsoft ADs IIS Provider schema/property tables
//
//  History:   28-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include "nntpmeta.h"
#include "smtpinet.h"
#include "pop3s.h"
#include "imaps.h"
#include "w3svc.h"

// Include iwamreg.h for EAppMode values
#include <iwamreg.h>

WCHAR *szProviderName = L"IIS";

#define MAX_LONG    (0x7FFFFFFF)
#define MIN_LONG    (0x80000000)
#define MAX_BOOLEAN 1
#define MAX_STRLEN  (256)

#define PROP_RW     0x0000001
#define PROP_RO     0x0000002

// -------------------------------------------------------------
// DANGER! DANGER! DANGER!
// 
// If you modify the property list for a class make sure there
// is a comma (,) between each name. Generally this means there
// should be a comma at the end of each line.
//
//--------------------------------------------------------------

CLASSINFO g_aIISClasses[] =
{
        //
        // IIS Classes
        //
        {
                TEXT("IIsObject"),      // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsComputer"),    // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxBandwidthBlocked,MimeMap"),
                NULL,
                TEXT("IIsObject,IIsWebService,IIsFtpService,IIsMimeMap,IIsNntpService,IIsSmtpService,IIsPop3Service,IIsImapService"),
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebService"),  // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,MaxConnections,MimeMap,AnonymousUserName,AnonymousUserPass,IgnoreTranslate,UseDigestSSP,")
                TEXT("ServerListenBacklog,ServerComment,ServerBindings,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AllowKeepAlive,ServerSize,DisableSocketPooling,AnonymousPasswordSync,DefaultLogonDomain,AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("Realm,EnableDirBrowsing,DefaultDoc,HttpExpires,HttpPics,HttpCustomHeaders,HttpErrors,")
                TEXT("EnableDocFooter,DefaultDocFooter,HttpRedirect,LogonMethod,")
                TEXT("CacheISAPI,CGITimeOut,DirectoryLevelsToScan,ContentIndexed,")
                TEXT("NTAuthenticationProviders,AuthBasic,AuthAnonymous,")
                TEXT("AuthNTLM,AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,CertCheckMode,RevocationFreshnessTime,RevocationURLRetrievalTimeout,")
                TEXT("CertNoRevocCheck,CertCacheRetrievalOnly,CertCheckRevocationFreshnessTime,CertNoUsageCheck,")
                TEXT("AccessSSLMapCert,AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("DoStaticCompression,DoDynamicCompression,")
                TEXT("AspBufferingOn,AspLogErrorRequests,AspScriptErrorSentToBrowser,AspScriptErrorMessage,AspAllowOutOfProcComponents,")
                TEXT("AspScriptFileCacheSize,AspDiskTemplateCacheDirectory,AspMaxDiskTemplateCacheFiles,AspScriptEngineCacheMax,AspScriptTimeout,AspSessionTimeout,")
                TEXT("AspEnableParentPaths,AspAllowSessionState,AspScriptLanguage,")
                TEXT("AspExceptionCatchEnable,AspCodepage,AspLCID,")
                TEXT("AspQueueTimeout,AspEnableAspHtmlFallback,AspEnableChunkedEncoding,")
                TEXT("AspEnableTypelibCache,AspErrorsToNTLog,AspProcessorThreadMax,")
                TEXT("AspTrackThreadingModel,AspRequestQueueMax,AspEnableApplicationRestart,")
                TEXT("AspQueueConnectionTestTime,AspSessionMax,")
                TEXT("AspThreadGateEnabled,AspThreadGateTimeSlice,AspThreadGateSleepDelay,")
                TEXT("AspThreadGateSleepMax,AspThreadGateLoadLow,AspThreadGateLoadHigh,")
                TEXT("AppRoot,AppFriendlyName,AppIsolated,AppPackageID,AppPackageName,AppAllowDebugging,AppAllowClientDebug,AspKeepSessionIDSecure,")
                TEXT("NetLogonWorkstation,UseHostName,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("PasswordExpirePrenotifyDays,PasswordCacheTTL,")
                TEXT("PasswordChangeFlags,")
                TEXT("UNCAuthenticationPassThrough,AppWamClsid,")
                TEXT("DirBrowseFlags,AuthFlags,AuthMD5,")
                TEXT("AuthPersistence,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole,")
                TEXT("ProcessNTCRIfLoggedOn,AllowPathInfoForScriptMappings,InProcessIsapiApps,")
                TEXT("EnableDefaultDoc,DirBrowseShowDate,DirBrowseShowTime,DirBrowseShowSize,DirBrowseShowExtension,DirBrowseShowLongDate,")
                TEXT("LogType,LogFilePeriod,LogFileLocaltimeRollover,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("CPUCGILimit,CPULimitLogEvent,CPULimitPriority,CPULimitProcStop,")
                TEXT("CPULimitPause,CPULoggingEnabled,CPULimitsEnabled,CPUResetInterval,")
                TEXT("CPULoggingInterval,CPULoggingOptions,CPUEnableAllProcLogging,")
                TEXT("CPUEnableCGILogging,CPUEnableAppLogging,CPULoggingMask,")
                TEXT("CPUEnableEvent,CPUEnableProcType,CPUEnableUserTime,")
                TEXT("CPUEnableKernelTime,CPUEnablePageFaults,CPUEnableTotalProcs,")
                TEXT("CPUEnableActiveProcs,CPUEnableTerminatedProcs,")
                TEXT("CPUAppEnabled,CPUCGIEnabled,SslUseDsMapper,")
                TEXT("WAMUserName,WAMUserPass,")
                TEXT("PeriodicRestartRequests,PeriodicRestartTime,PeriodicRestartSchedule,ShutdownTimeLimit,")
                TEXT("SSLCertHash,SSLStoreName")
#if defined(CAL_ENABLED)
                TEXT(",CalVcPerConnect,CalLimitHttpError,CalReserveTimeout,CalSSLReserveTimeout")
#endif
                TEXT(",AppPoolId,AllowTransientRegistration,AppAutoStart,BackwardCompatEnabled")
                ,NULL,
                TEXT("IIsObject,IIsWebInfo,IIsWebServer,IIsFilters,IIsApplicationPools"),
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsFtpService"),  // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,MaxConnections,AnonymousUserName,AnonymousUserPass,")
                TEXT("ServerListenBacklog,LogAnonymous,LogNonAnonymous,")
                TEXT("ServerComment,ServerBindings,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ExitMessage,GreetingMessage,BannerMessage,MaxClientsMessage,AnonymousOnly,MSDOSDirOutput,")
                TEXT("ServerSize,DisableSocketPooling,AnonymousPasswordSync,AllowAnonymous,DefaultLogonDomain,AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("DirectoryLevelsToScan,Realm,")
                TEXT("LogType,LogFilePeriod,LogFileLocaltimeRollover,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("FtpDirBrowseShowLongDate,AccessFlags,AccessRead,AccessWrite"),
                NULL,
                TEXT("IIsObject,IIsFtpInfo,IIsFtpServer"),
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebServer"),   // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("ContentIndexed,KeyType,ServerState,ServerComment,MaxBandwidth,")
                TEXT("ServerAutoStart,ServerSize,DisableSocketPooling,ServerListenBacklog,ServerListenTimeout,ServerBindings,SecureBindings,MaxConnections,ConnectionTimeout,")
                TEXT("AllowKeepAlive,CGITimeout,MaxEndpointConnections,IgnoreTranslate,UseDigestSSP,")
                TEXT("CacheISAPI,MimeMap,AnonymousUserName,AnonymousUserPass,FrontPageWeb,")
                TEXT("AnonymousPasswordSync,DefaultLogonDomain,AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("Realm,EnableDirBrowsing,DefaultDoc,HttpExpires,HttpPics,HttpCustomHeaders,HttpErrors,")
                TEXT("EnableDocFooter,DefaultDocFooter,HttpRedirect,LogonMethod,")
                TEXT("NTAuthenticationProviders,AuthBasic,AuthAnonymous,")
                TEXT("AuthNTLM,AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,CertCheckMode,RevocationFreshnessTime,RevocationURLRetrievalTimeout,")
                TEXT("CertNoRevocCheck,CertCacheRetrievalOnly,CertCheckRevocationFreshnessTime,CertNoUsageCheck,")
                TEXT("AccessSSLMapCert,AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("DoStaticCompression,DoDynamicCompression,")
                TEXT("AspBufferingOn,AspLogErrorRequests,AspScriptErrorSentToBrowser,AspScriptErrorMessage,AspAllowOutOfProcComponents,")
                TEXT("AspScriptFileCacheSize,AspDiskTemplateCacheDirectory,AspMaxDiskTemplateCacheFiles,AspScriptEngineCacheMax,AspScriptTimeout,")
                TEXT("AspEnableParentPaths,AspAllowSessionState,AspScriptLanguage,")
                TEXT("AspExceptionCatchEnable,AspCodepage,AspLCID,AspSessionTimeout,")
                TEXT("AspQueueTimeout,AspEnableAspHtmlFallback,AspEnableChunkedEncoding,")
                TEXT("AspEnableTypelibCache,AspErrorsToNTLog,AspProcessorThreadMax,")
                TEXT("AspTrackThreadingModel,AspRequestQueueMax,AspEnableApplicationRestart,")
                TEXT("AspQueueConnectionTestTime,AspSessionMax,")
                TEXT("AspThreadGateEnabled,AspThreadGateTimeSlice,AspThreadGateSleepDelay,")
                TEXT("AspThreadGateSleepMax,AspThreadGateLoadLow,AspThreadGateLoadHigh,")
                TEXT("AppRoot,AppFriendlyName,AppIsolated,AppPackageID,AppPackageName,AppOopRecoverLimit,")
                TEXT("AppAllowDebugging,AppAllowClientDebug,AspKeepSessionIDSecure,")
                TEXT("NetLogonWorkstation,UseHostName,ClusterEnabled,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("PasswordExpirePrenotifyDays,PasswordCacheTTL,")
                TEXT("PasswordChangeFlags,MaxBandwidthBlocked,")
                TEXT("UNCAuthenticationPassThrough,AppWamClsid,")
                TEXT("DirBrowseFlags,AuthFlags,AuthMD5,")
                TEXT("AuthPersistence,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole,")
                TEXT("EnableDefaultDoc,DirBrowseShowDate,DirBrowseShowTime,DirBrowseShowSize,DirBrowseShowExtension,DirBrowseShowLongDate,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileLocaltimeRollover,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("CPULoggingEnabled,CPULimitsEnabled,CPUResetInterval,")
                TEXT("CPULoggingInterval,CPULoggingOptions,CPUEnableAllProcLogging,")
                TEXT("CPUEnableCGILogging,CPUEnableAppLogging,CPULoggingMask,")
                TEXT("CPUEnableEvent,CPUEnableProcType,CPUEnableUserTime,")
                TEXT("CPUEnableKernelTime,CPUEnablePageFaults,CPUEnableTotalProcs,")
                TEXT("CPUEnableActiveProcs,CPUEnableTerminatedProcs,CPUCGILimit,")
                TEXT("CPULimitLogEvent,CPULimitPriority,CPULimitProcStop,")
                TEXT("CPULimitPause,CPUAppEnabled,CPUCGIEnabled,NotDeletable,")
                TEXT("PeriodicRestartRequests,PeriodicRestartTime,PeriodicRestartSchedule,ShutdownTimeLimit,")
                TEXT("SSLCertHash,SSLStoreName,")
                TEXT("ProcessNTCRIfLoggedOn,AllowPathInfoForScriptMappings,")
                TEXT("AppPoolId,AllowTransientRegistration,AppAutoStart"),
                NULL,
                TEXT("IIsObject,IIsCertMapper,IIsFilters,IIsWebVirtualDir"),
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsFtpServer"),   // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,MaxConnections,ServerState,AnonymousUserName,AnonymousUserPass,")
                TEXT("ServerListenBacklog,DisableSocketPooling,LogAnonymous,LogNonAnonymous,")
                TEXT("ServerComment,ServerBindings,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ExitMessage,GreetingMessage,BannerMessage,MaxClientsMessage,AnonymousOnly,MSDOSDirOutput,")
                TEXT("ServerSize,AnonymousPasswordSync,AllowAnonymous,DefaultLogonDomain,AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("Realm,ClusterEnabled,FtpDirBrowseShowLongDate,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileLocaltimeRollover,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("AccessFlags,AccessRead,AccessWrite"),
                NULL,
                TEXT("IIsObject,IIsFtpVirtualDir"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsWebFile"),     // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,AnonymousUserName,AnonymousUserPass,AnonymousPasswordSync,")
                TEXT("AuthBasic,AuthAnonymous,AuthNTLM,UNCAuthenticationPassThrough,IgnoreTranslate,UseDigestSSP,")
                TEXT("CGITimeOut,DefaultLogonDomain,LogonMethod,Realm,MimeMap,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,IPSecurity,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("DoStaticCompression,DoDynamicCompression,")
                TEXT("DontLog,HttpExpires,HttpPics,HttpCustomHeaders,HttpErrors,EnableDocFooter,DefaultDocFooter,HttpRedirect,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("AuthFlags,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AuthMD5,AuthPersistence,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("CPUAppEnabled,CPUCGIEnabled,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole"),
                NULL,                           // Inherits from
                NULL,   // Can Contain
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebDirectory"),// Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,AnonymousUserName,AnonymousUserPass,AnonymousPasswordSync,IgnoreTranslate,UseDigestSSP,")
                TEXT("AppRoot,AppFriendlyName,AppOopRecoverLimit,AppIsolated,AppPackageName,AppPackageID,")
                TEXT("AuthBasic,AuthAnonymous,AuthNTLM,")
                TEXT("CacheISAPI,AppAllowDebugging,AppAllowClientDebug,AspKeepSessionIDSecure,")
                TEXT("DefaultLogonDomain,LogonMethod,")
                TEXT("CGITimeOut,Realm,EnableDefaultDoc,")
                TEXT("DirBrowseShowDate,DirBrowseShowTime,DirBrowseShowSize,DirBrowseShowExtension,DirBrowseShowLongDate,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,IPSecurity,DontLog,HttpExpires,HttpPics,HttpCustomHeaders,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("DoStaticCompression,DoDynamicCompression,")
                TEXT("HttpErrors,EnableDocFooter,DefaultDocFooter,HttpRedirect,")
                TEXT("EnableDirBrowsing,DefaultDoc,ContentIndexed,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("FrontPageWeb,UNCAuthenticationPassThrough,AppWamClsid,")
                TEXT("AuthPersistence,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole,")
                TEXT("AspBufferingOn,AspLogErrorRequests,AspScriptErrorSentToBrowser,AspScriptErrorMessage,AspAllowOutOfProcComponents,")
                TEXT("AspScriptFileCacheSize,AspDiskTemplateCacheDirectory,AspMaxDiskTemplateCacheFiles,AspScriptEngineCacheMax,AspScriptTimeout,AspSessionTimeout,")
                TEXT("AspEnableParentPaths,AspAllowSessionState,AspScriptLanguage,")
                TEXT("AspExceptionCatchEnable,AspCodepage,AspLCID,MimeMap,")
                TEXT("AspQueueTimeout,CPUAppEnabled,CPUCGIEnabled,")
                TEXT("AspEnableAspHtmlFallback,AspEnableChunkedEncoding,")
                TEXT("AspEnableTypelibCache,AspErrorsToNTLog,AspProcessorThreadMax,")
                TEXT("AspTrackThreadingModel,AspRequestQueueMax,AspEnableApplicationRestart,")
                TEXT("AspQueueConnectionTestTime,AspSessionMax,")
                TEXT("AspThreadGateEnabled,AspThreadGateTimeSlice,AspThreadGateSleepDelay,")
                TEXT("AspThreadGateSleepMax,AspThreadGateLoadLow,AspThreadGateLoadHigh,")
                TEXT("PeriodicRestartRequests,PeriodicRestartTime,PeriodicRestartSchedule,ShutdownTimeLimit,")
                TEXT("DirBrowseFlags,AuthMD5,AuthFlags,")
                TEXT("AppPoolId,AllowTransientRegistration,AppAutoStart"),
                NULL,
                TEXT("IIsWebDirectory,IIsWebVirtualDir,IIsWebFile,IIsObject"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebVirtualDir"), // Class Name
                NULL,                     // GUID *objectClassID
                NULL,                     // PrimaryInterfaceGUID
                TEXT(""),                 // bstrOID
                FALSE,                    // fAbstract
                NULL,                     // bstrMandatoryProperties
                TEXT("KeyType,AnonymousUserName,AnonymousUserPass,AnonymousPasswordSync,IgnoreTranslate,UseDigestSSP,")
                TEXT("AppRoot,AppFriendlyName,AppOopRecoverLimit,AppIsolated,AppPackageName,AppPackageID,")
                TEXT("CacheISAPI,AppAllowDebugging,AppAllowClientDebug,")
                TEXT("AuthBasic,AuthAnonymous,AuthNTLM,")
                TEXT("DefaultLogonDomain,LogonMethod,")
                TEXT("CGITimeOut,Realm,EnableDefaultDoc,")
                TEXT("DirBrowseShowDate,DirBrowseShowTime,DirBrowseShowSize,DirBrowseShowExtension,DirBrowseShowLongDate,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,IPSecurity,DontLog,HttpExpires,HttpPics,HttpCustomHeaders,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("DoStaticCompression,DoDynamicCompression,")
                TEXT("HttpErrors,EnableDocFooter,DefaultDocFooter,HttpRedirect,")
                TEXT("EnableDirBrowsing,DefaultDoc,ContentIndexed,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("FrontPageWeb,Path,UNCUserName,UNCPassword,")
                TEXT("UNCAuthenticationPassThrough,AppWamClsid,")
                TEXT("AuthPersistence,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole,")
                TEXT("AspBufferingOn,AspLogErrorRequests,AspScriptErrorSentToBrowser,AspScriptErrorMessage,AspAllowOutOfProcComponents,")
                TEXT("AspScriptFileCacheSize,AspDiskTemplateCacheDirectory,AspMaxDiskTemplateCacheFiles,AspScriptEngineCacheMax,AspScriptTimeout,AspSessionTimeout,")
                TEXT("AspEnableParentPaths,AspAllowSessionState,AspScriptLanguage,AspKeepSessionIDSecure,")
                TEXT("AspExceptionCatchEnable,AspCodepage,AspLCID,MimeMap,")
                TEXT("AspQueueTimeout,CPUAppEnabled,CPUCGIEnabled,")
                TEXT("AspEnableAspHtmlFallback,AspEnableChunkedEncoding,")
                TEXT("AspEnableTypelibCache,AspErrorsToNTLog,AspProcessorThreadMax,")
                TEXT("AspTrackThreadingModel,AspRequestQueueMax,AspEnableApplicationRestart,")
                TEXT("AspQueueConnectionTestTime,AspSessionMax,")
                TEXT("AspThreadGateEnabled,AspThreadGateTimeSlice,AspThreadGateSleepDelay,")
                TEXT("AspThreadGateSleepMax,AspThreadGateLoadLow,AspThreadGateLoadHigh,")
                TEXT("PeriodicRestartRequests,PeriodicRestartTime,PeriodicRestartSchedule,ShutdownTimeLimit,")
                TEXT("DirBrowseFlags,AuthMD5,AuthFlags,")
                TEXT("AppPoolId,AllowTransientRegistration,AppAutoStart"),
                NULL,
                TEXT("IIsWebDirectory,IIsWebFile,IIsWebVirtualDir,IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsFtpVirtualDir"), // Class Name
                NULL,                     // GUID *objectClassID
                NULL,                     // PrimaryInterfaceGUID
                TEXT(""),                 // bstrOID
                FALSE,                    // fAbstract
                NULL,                     // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,AccessFlags,AccessRead,AccessWrite,DontLog,IPSecurity,FtpDirBrowseShowLongDate"),
                NULL,
                TEXT("IIsFtpVirtualDir"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsFilter"),       // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,FilterPath,FilterDescription,FilterFlags,FilterState,FilterEnabled,")
                TEXT("NotifySecurePort,NotifyNonSecurePort,NotifyReadRawData,NotifyPreProcHeaders,")
                TEXT("NotifyAuthentication,NotifyAuthComplete,NotifyUrlMap,NotifyAccessDenied,NotifySendResponse,")
                TEXT("NotifySendRawData,NotifyLog,NotifyEndOfRequest,NotifyEndOfNetSession,")
                TEXT("NotifyOrderHigh,NotifyOrderMedium,NotifyOrderLow"),
                NULL,
                NULL,
                FALSE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsFilters"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,FilterLoadOrder"),
                NULL,
                TEXT("IIsObject,IIsFilter,IIsCompressionSchemes"),
                TRUE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsCompressionScheme"),   // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,HcDoDynamicCompression,HcDoStaticCompression,")
                TEXT("HcDoOnDemandCompression,HcCompressionDll,HcFileExtensions,HcScriptFileExtensions,")
                TEXT("HcMimeType,HcPriority,HcDynamicCompressionLevel,")
                TEXT("HcOnDemandCompLevel,HcCreateFlags"),
                NULL,
                NULL,
                FALSE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsCompressionSchemes"), // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,HcCompressionDirectory,HcCacheControlHeader,")
                TEXT("HcExpiresHeader,HcDoDynamicCompression,HcDoStaticCompression,")
                TEXT("HcDoOnDemandCompression,HcDoDiskSpaceLimiting,")
                TEXT("HcNoCompressionForHttp10,HcNoCompressionForProxies,")
                TEXT("HcNoCompressionForRange,HcSendCacheHeaders,HcMaxDiskSpaceUsage,")
                TEXT("HcIoBufferSize,HcCompressionBufferSize,HcMaxQueueLength,")
                TEXT("HcFilesDeletedPerDiskFree,HcMinFileSizeForComp"),
                NULL,
                TEXT("IIsObject,IIsCompressionScheme"),
                TRUE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsCertMapper"),   // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsMimeMap"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,MimeMap"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsLogModules"),   // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType"),
                NULL,
                TEXT("IIsObject,IIsLogModule,IIsCustomLogModule"),
                TRUE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsLogModule"),    // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleId,LogModuleUiId"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsCustomLogModule"),    // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogCustomPropertyName,LogCustomPropertyHeader,")
                TEXT("LogCustomPropertyID,LogCustomPropertyMask,")
                TEXT("LogCustomPropertyDataType,LogCustomPropertyServicesString"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebInfo"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,ServerConfigFlags,CustomErrorDescriptions,AdminServer,")
                TEXT("ServerConfigSSL40,ServerConfigSSL128,ServerConfigSSLAllowEncrypt,ServerConfigAutoPWSync,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsFtpInfo"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                FALSE,
                TEXT(""),
                0
        },


                //------------------------------------------------------------
                //
                //      -- BEGIN EXTENSION CLASSES -- magnush
                //
                //------------------------------------------------------------

                //
                //      Objects that are handled by the adsiis dll:
                //

        {
                TEXT("IIsNntpService"),                                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,AnonymousUserName,AnonymousUserPass,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AnonymousPasswordSync,AdminACL,AdminACLBin,IPSecurity,DontLog,ContentIndexed,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,")

                TEXT("ArticleTimeLimit,HistoryExpiration,HonorClientMsgIds,SmtpServer,AdminEmail,AdminName,")
                TEXT("AllowClientPosts,AllowFeedPosts,AllowControlMsgs,")
                TEXT("DefaultModeratorDomain,NntpCommandLogMask,DisableNewNews,")
                TEXT("NewsCrawlerTime,ShutdownLatency,GroupvarListFile,")

                TEXT("ClientPostHardLimit,ClientPostSoftLimit,FeedPostHardLimit,FeedPostSoftLimit,")
                TEXT("FeedReportPeriod,MaxSearchResults,")
                TEXT("NntpServiceVersion,")

                TEXT("LogType,LogFilePeriod,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,AccessSSLFlags,")
                TEXT("AccessWrite,AccessExecute,AccessFlags,")
                TEXT("AllowAnonymous,DirectoryLevelsToScan,")
                TEXT("NTAuthenticationProviders"),
                NULL,
                TEXT("IIsObject,IIsNntpInfo,IIsNntpServer"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpServer"),                                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                TEXT("GroupHelpFile,GroupListFile,ArticleTableFile,HistoryTableFile,ModeratorFile,")
                TEXT("XoverTableFile,ListFile,PrettyNamesFile"),   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,AnonymousUserName,AnonymousUserPass,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ServerBindings,SecureBindings,ClusterEnabled,")
                TEXT("AnonymousPasswordSync,AdminACL,AdminACLBin,IPSecurity,DontLog,ContentIndexed,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,Win32Error,ServerState,")

                TEXT("ArticleTimeLimit,HistoryExpiration,HonorClientMsgIds,SmtpServer,AdminEmail,AdminName,")
                TEXT("AllowClientPosts,AllowFeedPosts,AllowControlMsgs,")
                TEXT("DefaultModeratorDomain,NntpCommandLogMask,DisableNewNews,")
                TEXT("NewsCrawlerTime,ShutdownLatency,GroupvarListFile,")

                TEXT("ClientPostHardLimit,ClientPostSoftLimit,FeedPostHardLimit,FeedPostSoftLimit,")
                TEXT("NntpUucpName,NntpOrganization,NewsPickupDirectory,NewsFailedPickupDirectory,")
                TEXT("NntpServiceVersion,NewsDropDirectory,NntpClearTextProvider,")
                TEXT("FeedReportPeriod,MaxSearchResults,")

                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,AccessSSLFlags,")
                TEXT("AccessWrite,AccessExecute,AccessFlags,")
                TEXT("SSLCertHash,")
                TEXT("NTAuthenticationProviders"),
                NULL,
                TEXT("IIsObject,IIsNntpVirtualDir,IIsNntpFeeds,IIsNntpExpiration,")                                                                                            // Real objects
                TEXT("IIsNntpRebuild,IIsNntpSessions,IIsNntpGroups"),       // Class extensions
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpVirtualDir"),// Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,Win32Error,ContentIndexed,DontLog,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,AccessSSLFlags,")
                TEXT("AccessAllowPosting,AccessRestrictGroupVisibility,AccessFlags,")
                TEXT("VrDriverClsid,VrDriverProgid,FsPropertyPath,VrUseAccount,VrDoExpire,ExMdbGuid,VrOwnModerator"),
                NULL,
                TEXT("IIsObject,IIsNntpVirtualDir"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },

        {               // Taken from as IIsFtpInfo
                TEXT("IIsNntpInfo"),     // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpService"),                                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("LogType,LogFilePeriod,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("SmtpServiceVersion,")
                TEXT("EnableReverseDnsLookup,ShouldDeliver,AlwaysUseSsl,LimitRemoteConnections,")
                TEXT("SmartHostType,DoMasquerade,RemoteSmtpPort,RemoteSmtpSecurePort,HopCount,")
                TEXT("MaxOutConnections,MaxOutConnectionsPerDomain,RemoteTimeout,MaxMessageSize,MaxSessionSize,MaxRecipients,")
                TEXT("LocalRetryInterval,RemoteRetryInterval,LocalRetryAttempts,RemoteRetryAttempts,EtrnDays,")
                TEXT("MaxBatchedMessages,SmartHost,FullyQualifiedDomainName,DefaultDomain,")
                TEXT("DropDirectory,BadMailDirectory,PickupDirectory,QueueDirectory,")
                TEXT("MasqueradeDomain,SendNdrTo,SendBadTo,")
                TEXT("RoutingDll,RoutingSources,DomainRouting,")
                TEXT("RouteAction,RouteUserName,RoutePassword,")
                TEXT("SaslLogonDomain,SmtpClearTextProvider,NTAuthenticationProviders,")
                TEXT("SmtpRemoteProgressiveRetry,SmtpLocalDelayExpireMinutes,SmtpLocalNDRExpireMinutes,")
                TEXT("SmtpRemoteDelayExpireMinutes,SmtpRemoteNDRExpireMinutes,")
                TEXT("SmtpRemoteRetryThreshold,")
                TEXT("SmtpDSNOptions,SmtpDSNLanguageID,")
                TEXT("SmtpAdvQueueDll,")
                TEXT("SmtpInboundCommandSupportOptions,SmtpOutboundCommandSupportOptions,")
                TEXT("SmtpCommandLogMask,SmtpFlushMailFile,")
                TEXT("RelayIpList,RelayForAuth,")
                TEXT("SmtpConnectTimeout,SmtpMailFromTimeout,SmtpRcptToTimeout,")
                TEXT("SmtpDataTimeout,SmtpBdatTimeout,SmtpAuthTimeout,SmtpSaslTimeout,")
                TEXT("SmtpTurnTimeout,SmtpRsetTimeout,")
                TEXT("SmtpHeloTimeout,")
                TEXT("DisableSocketPooling,SmtpUseTcpDns,SmtpDomainValidationFlags,SmtpSSLRequireTrustedCA,")
                TEXT("SmtpSSLCertHostnameValidation,MaxMailObjects,ShouldPickupMail,MaxDirChangeIOSize,")
                TEXT("NameResolutionType,MaxSmtpErrors,ShouldPipelineIn,ShouldPipelineOut,")
                TEXT("ConnectResponse,UpdatedFQDN,UpdatedDefaultDomain,EtrnSubdomains,")
                TEXT("SmtpMaxRemoteQThreads,SmtpDisableRelay,SmtpHeloNoDomain,")
                TEXT("SmtpMailNoHelo,SmtpAqueueWait,AddNoHeaders,SmtpEventlogLevel,")
                TEXT("AllowAnonymous,AnonymousOnly,AnonymousPasswordSync,AnonymousUserName,")
                TEXT("AnonymousUserPass,Realm,DefaultLogonDomain"),
                NULL,
                TEXT("IIsObject,IIsSmtpInfo,IIsSmtpServer"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpServer"),                                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                                                   // bstrMandatoryProperties

                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ServerBindings,SecureBindings,ClusterEnabled,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,Win32Error,ServerState,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("SmtpServiceVersion,")
                TEXT("EnableReverseDnsLookup,ShouldDeliver,AlwaysUseSsl,LimitRemoteConnections,")
                TEXT("SmartHostType,DoMasquerade,RemoteSmtpPort,RemoteSmtpSecurePort,HopCount,")
                TEXT("MaxOutConnections,MaxOutConnectionsPerDomain,RemoteTimeout,MaxMessageSize,MaxSessionSize,MaxRecipients,")
                TEXT("LocalRetryInterval,RemoteRetryInterval,LocalRetryAttempts,RemoteRetryAttempts,EtrnDays,")
                TEXT("MaxBatchedMessages,SmartHost,FullyQualifiedDomainName,DefaultDomain,")
                TEXT("DropDirectory,BadMailDirectory,PickupDirectory,QueueDirectory,")
                TEXT("MasqueradeDomain,SendNdrTo,SendBadTo,")
                TEXT("RoutingDll,RoutingSources,DomainRouting,")
                TEXT("RouteAction,RouteUserName,RoutePassword,")
                TEXT("SaslLogonDomain,SmtpClearTextProvider,NTAuthenticationProviders,")
                TEXT("SmtpRemoteProgressiveRetry,SmtpLocalDelayExpireMinutes,SmtpLocalNDRExpireMinutes,")
                TEXT("SmtpRemoteDelayExpireMinutes,SmtpRemoteNDRExpireMinutes,")
                TEXT("SmtpRemoteRetryThreshold,SmtpDSNOptions,SmtpDSNLanguageID,")
                TEXT("SmtpInboundCommandSupportOptions,SmtpOutboundCommandSupportOptions,")
                TEXT("RelayIpList,RelayForAuth,")
                TEXT("SmtpConnectTimeout,SmtpMailFromTimeout,SmtpRcptToTimeout,")
                TEXT("SmtpDataTimeout,SmtpBdatTimeout,SmtpAuthTimeout,SmtpSaslTimeout,")
                TEXT("SmtpTurnTimeout,SmtpRsetTimeout,")
                TEXT("SmtpHeloTimeout,")
                TEXT("DisableSocketPooling,SmtpUseTcpDns,SmtpDomainValidationFlags,SmtpSSLRequireTrustedCA,")
                TEXT("SmtpSSLCertHostnameValidation,MaxMailObjects,ShouldPickupMail,MaxDirChangeIOSize,")
                TEXT("NameResolutionType,MaxSmtpErrors,ShouldPipelineIn,ShouldPipelineOut,")
                TEXT("ConnectResponse,UpdatedFQDN,UpdatedDefaultDomain,EtrnSubdomains,")
                TEXT("SmtpMaxRemoteQThreads,SmtpDisableRelay,SmtpHeloNoDomain,")
                TEXT("SmtpMailNoHelo,SmtpAqueueWait,AddNoHeaders,SmtpEventlogLevel,")
                TEXT("AllowAnonymous,AnonymousOnly,AnonymousPasswordSync,AnonymousUserName,")
                TEXT("AnonymousUserPass,Realm,DefaultLogonDomain")
                TEXT("SSLCertHash"),
                NULL,
                TEXT("IIsObject,IIsSmtpVirtualDir,IIsSmtpRoutingSource,IIsSmtpDomain,")     // Real objects
                TEXT("IIsSmtpSessions"),   // Class extensions
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpVirtualDir"),              // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,Win32Error,DontLog,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags"),
                NULL,
                TEXT("IIsObject,IIsSmtpVirtualDir"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpDomain"),                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,RouteAction,RouteActionString,RouteUserName,RoutePassword,")
                          TEXT("RelayIpList,RelayForAuth,AuthTurnList,CSideEtrnDomains"),        //
                NULL,
                TEXT("IIsSmtpDomain"),
                TRUE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpRoutingSource"),           // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,")
                TEXT("SmtpRoutingTableType,SmtpDsDataDirectory,SmtpDsDefaultMailRoot,")
                TEXT("SmtpDsBindType,SmtpDsSchemaType,SmtpDsHost,SmtpDsNamingContext,")
                TEXT("SmtpDsAccount,SmtpDsPassword,SmtpDsUseCat,SmtpDsPort,SmtpDsDomain,SmtpDsFlags"),
                NULL,
                NULL,           // Can Contain
                TRUE,
                TEXT(""),           //
                0
        },

        {               // Taken from as IIsFtpInfo
                TEXT("IIsSmtpInfo"),     // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3Service"),                                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,")
                TEXT("DefaultLogonDomain,NTAuthenticationProviders,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("LogType,LogFilePeriod,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("Pop3ServiceVersion,")
                TEXT("Pop3ExpireMail,Pop3ExpireDelay,Pop3ExpireStart,Pop3MailExpirationTime,")
                TEXT("Pop3ClearTextProvider,Pop3DefaultDomain,")
                TEXT("Pop3RoutingDll,Pop3RoutingSources,"),
                NULL,
                TEXT("IIsObject,IIsPop3Info,IIsPop3Server"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3Server"),                                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                                                   // bstrMandatoryProperties

                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ServerBindings,SecureBindings,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("DefaultLogonDomain,NTAuthenticationProviders,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("ServerListenBacklog,Win32Error,ServerState,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("Pop3ServiceVersion,")
                TEXT("Pop3ExpireMail,Pop3ExpireDelay,Pop3ExpireStart,Pop3MailExpirationTime,")
                TEXT("Pop3ClearTextProvider,Pop3DefaultDomain,")
                TEXT("Pop3RoutingDll,Pop3RoutingSources,")
                TEXT("SSLCertHash"),
                NULL,
                TEXT("IIsObject,IIsPop3VirtualDir,IIsPop3RoutingSource,")       // Real objects
                TEXT("IIsPop3Sessions"),    // Class extensions
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3VirtualDir"),              // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,Win32Error,DontLog,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("Pop3ExpireMail,Pop3MailExpirationTime"),
                NULL,
                TEXT("IIsObject,IIsPop3VirtualDir"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3RoutingSource"),           // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,")
                TEXT("Pop3RoutingTableType,Pop3DsDataDirectory,Pop3DsDefaultMailRoot,")
                TEXT("Pop3DsBindType,Pop3DsSchemaType,Pop3DsHost,Pop3DsNamingContext,")
                TEXT("Pop3DsAccount,Pop3DsPassword"),
                NULL,
                NULL,           // Can Contain
                TRUE,
                TEXT(""),           //
                0
        },

        {               // Taken from as IIsFtpInfo
                TEXT("IIsPop3Info"),     // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapService"),                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,")
                TEXT("DefaultLogonDomain,NTAuthenticationProviders,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("LogType,LogFilePeriod,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("ImapServiceVersion,")
                TEXT("ImapExpireMail,ImapExpireDelay,ImapExpireStart,ImapMailExpirationTime,")
                TEXT("ImapClearTextProvider,ImapDefaultDomain,")
                TEXT("ImapRoutingDll,ImapRoutingSources"),
                NULL,
                TEXT("IIsObject,IIsImapInfo,IIsImapServer"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapServer"),                                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                                                   // bstrMandatoryProperties

                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ServerBindings,SecureBindings,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("DefaultLogonDomain,NTAuthenticationProviders,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("ServerListenBacklog,Win32Error,ServerState,")
                TEXT("ImapServiceVersion,")
                TEXT("ImapExpireMail,ImapExpireDelay,ImapExpireStart,ImapMailExpirationTime,")
                TEXT("ImapClearTextProvider,ImapDefaultDomain,")
                TEXT("ImapRoutingDll,ImapRoutingSources,")
                TEXT("SSLCertHash"),
                NULL,
                TEXT("IIsObject,IIsImapVirtualDir,IIsImapRoutingSource,")       // Real objects
                TEXT("IIsImapSessions"),        // Class extensions
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapVirtualDir"),// Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,Win32Error,DontLog,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("ImapExpireMail,ImapMailExpirationTime"),
                NULL,
                TEXT("IIsObject,IIsImapVirtualDir"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapRoutingSource"),           // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,")
                TEXT("ImapRoutingTableType,ImapDsDataDirectory,ImapDsDefaultMailRoot,")
                TEXT("ImapDsBindType,ImapDsSchemaType,ImapDsHost,ImapDsNamingContext,")
                TEXT("ImapDsAccount,ImapDsPassword"),
                NULL,
                NULL,           // Can Contain
                TRUE,
                TEXT(""),           //
                0
        },

        {               // Taken from as IIsFtpInfo
                TEXT("IIsImapInfo"),     // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        //
        //      Place holders for extension classes:
        //

        {
                TEXT("IIsNntpRebuild"),                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpSessions"),                // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpFeeds"),                   // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,")        //
                TEXT("FeedPeerTempDirectory"),
                NULL,
                TEXT("IIsNntpFeed"),
                TRUE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpFeed"),                   // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,")
                TEXT("FeedServerName,FeedType,FeedNewsgroups,FeedSecurityType,")
                TEXT("FeedAuthenticationType,FeedAccountName,FeedPassword,FeedStartTimeHigh,")
                TEXT("FeedStartTimeLow,FeedInterval,FeedAllowControlMsgs,FeedCreateAutomatically,")
                TEXT("FeedDisabled,FeedDistribution,FeedConcurrentSessions,FeedMaxConnectionAttempts,")
                TEXT("FeedUucpName,FeedTempDirectory,FeedNextPullHigh,FeedNextPullLow,FeedPeerTempDirectory,")
                TEXT("FeedPeerGapSize,FeedOutgoingPort,FeedFeedpairId,FeedHandshake,FeedAdminError,FeedErrParmMask"),
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpExpiration"),              // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                TEXT("IIsNntpExpire"),
                TRUE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpExpire"),              // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,ExpireSpace,ExpireTime,ExpireNewsgroups,ExpirePolicyName"),
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpGroups"),                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpSessions"),                // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3Sessions"),                // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapSessions"),                // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsApplicationPools"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("PeriodicRestartTime,PeriodicRestartRequests,PeriodicRestartSchedule,MaxProcesses,PingingEnabled,IdleTimeout,RapidFailProtection,SMPAffinitized,SMPProcessorAffinityMask,StartupTimeLimit,ShutdownTimeLimit,PingInterval,PingResponseTime,DisallowOverlappingRotation,DisallowRotationOnConfigChange,OrphanWorkerProcess,OrphanAction,UlAppPoolQueueLength,KeyType"),
                NULL,
                TEXT("IIsApplicationPool,IIsStreamFilter"),
                TRUE,   // is a containter?
                TEXT(""),
                0
        },

        {
                TEXT("IIsApplicationPool"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("AppPoolFriendlyName,PeriodicRestartTime,PeriodicRestartRequests,MaxProcesses,PingingEnabled,IdleTimeout,RapidFailProtection,SMPAffinitized,SMPProcessorAffinityMask,StartupTimeLimit,ShutdownTimeLimit,PingInterval,PingResponseTime,DisallowOverlappingRotation,DisallowRotationOnConfigChange,OrphanWorkerProcess,OrphanAction,UlAppPoolQueueLength,KeyType"),
                NULL,
                TEXT(""),
                TRUE,
                TEXT(""),                
                0
        },

        {
                TEXT("IIsStreamFilter"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("PeriodicRestartTime,PeriodicRestartConnections,PingingEnabled,IdleTimeout,RapidFailProtection,SMPAffinitized,SMPProcessorAffinityMask,StartupTimeLimit,ShutdownTimeLimit,PingInterval,PingResponseTime,DisallowOverlappingRotation,DisallowRotationOnConfigChange,OrphanWorkerProcess,OrphanAction,KeyType"),
                NULL,
                TEXT(""),
                FALSE,
                TEXT(""),
                0
        },


                //------------------------------------------------------------
                //
                //      -- END EXTENSION CLASSES -- magnush
                //
                //------------------------------------------------------------
};

SYNTAXINFO g_aIISSyntax[] =
{ {  TEXT("Boolean"),  IIS_SYNTAX_ID_BOOL,     VT_BOOL },
  {  TEXT("Integer"),  IIS_SYNTAX_ID_DWORD,    VT_I4 },
  {  TEXT("String"),   IIS_SYNTAX_ID_STRING,   VT_BSTR },
  {  TEXT("ExpandSz"), IIS_SYNTAX_ID_EXPANDSZ, VT_BSTR },
  {  TEXT("List"),     IIS_SYNTAX_ID_MULTISZ,  VT_VARIANT }, // VT_BSTR|VT_ARR

  {  TEXT("IPSec"),    IIS_SYNTAX_ID_IPSECLIST,VT_VARIANT }, // IP Sec object
  {  TEXT("NTAcl"),    IIS_SYNTAX_ID_NTACL,    VT_VARIANT }, // NT ACL object
  {  TEXT("Binary"),    IIS_SYNTAX_ID_BINARY,    VT_VARIANT }, // NT ACL object but in Raw Binary Form
  {  TEXT("MimeMapList"), IIS_SYNTAX_ID_MIMEMAP, VT_VARIANT } // VT_ARRAY of Mime Map object
};

DWORD g_cIISClasses = (sizeof(g_aIISClasses)/sizeof(g_aIISClasses[0]));
DWORD g_cIISSyntax = (sizeof(g_aIISSyntax)/sizeof(g_aIISSyntax[0]));



PROPERTYINFO g_aIISProperties[] =
{

// Global Properties
      { TEXT("BackwardCompatEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_GLOBAL_STANDARD_APP_MODE_ENABLED, MD_GLOBAL_STANDARD_APP_MODE_ENABLED, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

//
// Computer properties
//
      { TEXT("KeyType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_KEY_TYPE, MD_KEY_TYPE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,0, TEXT("")},

      { TEXT("MaxBandwidth"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_BANDWIDTH, MD_MAX_BANDWIDTH, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0xffffffff, TEXT("")},

      { TEXT("MimeMap"),
        TEXT(""), TEXT("MimeMapList"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MIMEMAP, MD_MIME_MAP, MD_MIME_MAP, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("\0")},

//
// Service properties
//

      { TEXT("AnonymousUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ANONYMOUS_USER_NAME, MD_ANONYMOUS_USER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AnonymousUserPass"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ANONYMOUS_PWD, MD_ANONYMOUS_PWD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AnonymousPasswordSync"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ANONYMOUS_USE_SUBAUTH, MD_ANONYMOUS_USE_SUBAUTH, 0, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("AllowAnonymous"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_ANONYMOUS, MD_ALLOW_ANONYMOUS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("WAMUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_WAM_USER_NAME, MD_WAM_USER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("WAMUserPass"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_WAM_PWD, MD_WAM_PWD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("DefaultLogonDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DEFAULT_LOGON_DOMAIN, MD_DEFAULT_LOGON_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AdminACL"),
        TEXT(""), TEXT("NTAcl"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_NTACL, MD_ADMIN_ACL, MD_ADMIN_ACL, 0, METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AdminACLBin"),
        TEXT(""), TEXT("Binary"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BINARY, MD_ADMIN_ACL, MD_VPROP_ADMIN_ACL_RAW_BINARY, 0, METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("IPSecurity"),
        TEXT(""), TEXT("IPSec"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_IPSECLIST, MD_IP_SEC, MD_IP_SEC, 0, METADATA_INHERIT | METADATA_REFERENCE, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("DontLog"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DONT_LOG, MD_DONT_LOG, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("Realm"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_REALM, MD_REALM, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("ServerListenTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_LISTEN_TIMEOUT, MD_SERVER_LISTEN_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 120, TEXT("")},

      { TEXT("MaxEndpointConnections"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_ENDPOINT_CONNECTIONS, MD_MAX_ENDPOINT_CONNECTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0xffffffff, TEXT("")},

      { TEXT("DisableSocketPooling"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DISABLE_SOCKET_POOLING, MD_DISABLE_SOCKET_POOLING, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PeriodicRestartRequests"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT, MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PeriodicRestartTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_PERIODIC_RESTART_TIME, MD_APPPOOL_PERIODIC_RESTART_TIME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PeriodicRestartSchedule"),
        TEXT(""), TEXT("List"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_APPPOOL_PERIODIC_RESTART_SCHEDULE, MD_APPPOOL_PERIODIC_RESTART_SCHEDULE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ShutdownTimeLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_SHUTDOWN_TIMELIMIT, MD_APPPOOL_SHUTDOWN_TIMELIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 600, TEXT("")},
//
//
//  IW3Service Properties
//
//

      { TEXT("AdminServer"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ADMIN_INSTANCE, MD_ADMIN_INSTANCE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("1")},

      { TEXT("EnableDirBrowsing"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_ENABLED, MD_DIRBROW_ENABLED, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("DirBrowseShowDate"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_SHOW_DATE, MD_DIRBROW_SHOW_DATE, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DirBrowseShowTime"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_SHOW_TIME, MD_DIRBROW_SHOW_TIME, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DirBrowseShowSize"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_SHOW_SIZE, MD_DIRBROW_SHOW_SIZE, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DirBrowseShowExtension"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_SHOW_EXTENSION, MD_DIRBROW_SHOW_EXTENSION, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DirBrowseShowLongDate"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_LONG_DATE, MD_DIRBROW_LONG_DATE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("EnableDefaultDoc"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_LOADDEFAULT, MD_DIRBROW_LOADDEFAULT, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DefaultDoc"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DEFAULT_LOAD_FILE, MD_DEFAULT_LOAD_FILE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("default.htm")},

      { TEXT("HttpExpires"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HTTP_EXPIRES, MD_HTTP_EXPIRES, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("D, 0x15180")},

      { TEXT("HttpPics"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_HTTP_PICS, MD_HTTP_PICS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("HttpCustomHeaders"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_HTTP_CUSTOM, MD_HTTP_CUSTOM, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("\0")},

      { TEXT("CustomErrorDescriptions"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_CUSTOM_ERROR_DESC, MD_CUSTOM_ERROR_DESC, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("HttpErrors"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_CUSTOM_ERROR, MD_CUSTOM_ERROR, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("\0")},

      { TEXT("EnableDocFooter"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_FOOTER_ENABLED, MD_FOOTER_ENABLED, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("DefaultDocFooter"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FOOTER_DOCUMENT, MD_FOOTER_DOCUMENT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("HttpRedirect"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HTTP_REDIRECT, MD_HTTP_REDIRECT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("LogonMethod"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGON_METHOD, MD_LOGON_METHOD, 0, METADATA_INHERIT, IIS_MD_UT_FILE, MD_LOGON_INTERACTIVE, TEXT("")},

      { TEXT("NTAuthenticationProviders"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_NTAUTHENTICATION_PROVIDERS, MD_NTAUTHENTICATION_PROVIDERS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")}, 

      { TEXT("AuthBasic"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION, MD_VPROP_AUTH_BASIC, MD_AUTH_BASIC, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AuthAnonymous"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION, MD_VPROP_AUTH_ANONYMOUS, MD_AUTH_ANONYMOUS, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("AuthNTLM"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION, MD_VPROP_AUTH_NT, MD_AUTH_NT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AuthMD5"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION, MD_VPROP_AUTH_MD5, MD_AUTH_MD5, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessExecute"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_EXECUTE, MD_ACCESS_EXECUTE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSource"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_READ_SOURCE, MD_ACCESS_SOURCE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSL"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_SSL, MD_ACCESS_SSL, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSL128"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_SSL128, MD_ACCESS_SSL128, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSLNegotiateCert"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_NEGO_CERT, MD_ACCESS_NEGO_CERT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSLRequireCert"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_REQUIRE_CERT, MD_ACCESS_REQUIRE_CERT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSLMapCert"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_MAP_CERT, MD_ACCESS_MAP_CERT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CertCheckMode"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CERT_CHECK_MODE, MD_CERT_CHECK_MODE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CertNoRevocCheck"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CERT_CHECK_MODE, MD_VPROP_CERT_NO_REVOC_CHECK, MD_CERT_NO_REVOC_CHECK, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CertCacheRetrievalOnly"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CERT_CHECK_MODE, MD_VPROP_CERT_CACHE_RETRIEVAL_ONLY, MD_CERT_CACHE_RETRIEVAL_ONLY, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("CertCheckRevocationFreshnessTime"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CERT_CHECK_MODE, MD_VPROP_CERT_CHECK_REVOCATION_FRESHNESS_TIME, MD_CERT_CHECK_REVOCATION_FRESHNESS_TIME, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("CertNoUsageCheck"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CERT_CHECK_MODE, MD_VPROP_CERT_NO_USAGE_CHECK, MD_CERT_NO_USAGE_CHECK , METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("AccessRead"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_READ, MD_ACCESS_READ, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("AccessWrite"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_WRITE, MD_ACCESS_WRITE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessScript"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_SCRIPT, MD_ACCESS_SCRIPT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessNoRemoteExecute"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_NO_REMOTE_EXECUTE, MD_ACCESS_NO_REMOTE_WRITE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessNoRemoteRead"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_NO_REMOTE_READ, MD_ACCESS_NO_REMOTE_READ, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessNoRemoteWrite"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_NO_REMOTE_WRITE, MD_ACCESS_NO_REMOTE_WRITE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessNoRemoteScript"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_NO_REMOTE_SCRIPT, MD_ACCESS_NO_REMOTE_SCRIPT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("FilterLoadOrder"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FILTER_LOAD_ORDER, MD_FILTER_LOAD_ORDER, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_CONFIGURATION_INFO, MD_SERVER_CONFIGURATION_INFO, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigSSL40"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SERVER_CONFIGURATION_INFO, MD_VPROP_SERVER_CONFIG_SSL_40, MD_SERVER_CONFIG_SSL_40, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigSSL128"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SERVER_CONFIGURATION_INFO, MD_VPROP_SERVER_CONFIG_SSL_128, MD_SERVER_CONFIG_SSL_128, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigSSLAllowEncrypt"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SERVER_CONFIGURATION_INFO, MD_VPROP_SERVER_CONFIG_ALLOW_ENCRYPT, MD_SERVER_CONFIG_ALLOW_ENCRYPT, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigAutoPWSync"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SERVER_CONFIGURATION_INFO, MD_VPROP_SERVER_CONFIG_AUTO_PW_SYNC, MD_SERVER_CONFIG_AUTO_PW_SYNC, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

#if defined(CAL_ENABLED)
      { TEXT("CalVcPerConnect"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CAL_VC_PER_CONNECT, MD_CAL_VC_PER_CONNECT, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DEFAULT_W3_CAL_VC_PER_CONNECT, TEXT("")},

      { TEXT("CalReserveTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CAL_AUTH_RESERVE_TIMEOUT, MD_CAL_AUTH_RESERVE_TIMEOUT, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DEFAULT_W3_CAL_AUTH_RESERVE_TIMEOUT, TEXT("")},

      { TEXT("CalSSLReserveTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CAL_SSL_RESERVE_TIMEOUT, MD_CAL_SSL_RESERVE_TIMEOUT, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DEFAULT_W3_CAL_SSL_RESERVE_TIMEOUT, TEXT("")},

      { TEXT("CalLimitHttpError"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CAL_W3_ERROR, MD_CAL_W3_ERROR, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DEFAULT_W3_CAL_W3_ERROR , TEXT("")},
#endif

//
// IIsFtpService
//

      { TEXT("LogAnonymous"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_LOG_ANONYMOUS, MD_LOG_ANONYMOUS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogNonAnonymous"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_LOG_NONANONYMOUS, MD_LOG_NONANONYMOUS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},


//
// IIsVirtualServer
//

      { TEXT("ServerState"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_STATE, MD_SERVER_STATE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MD_SERVER_STATE_STOPPED, TEXT("")},

      { TEXT("ServerComment"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SERVER_COMMENT, MD_SERVER_COMMENT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerAutoStart"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SERVER_AUTOSTART, MD_SERVER_AUTOSTART, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("ServerSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_SIZE, MD_SERVER_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, MD_SERVER_SIZE_MEDIUM, TEXT("")},

      { TEXT("ServerListenBacklog"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_LISTEN_BACKLOG, MD_SERVER_LISTEN_BACKLOG, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 40, TEXT("")},

      { TEXT("ServerBindings"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_SERVER_BINDINGS, MD_SERVER_BINDINGS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("SecureBindings"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_SECURE_BINDINGS, MD_SECURE_BINDINGS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("MaxConnections"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_CONNECTIONS, MD_MAX_CONNECTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ConnectionTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CONNECTION_TIMEOUT, MD_CONNECTION_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 900, TEXT("")},

//
// IIsWebServer
//

      { TEXT("AllowKeepAlive"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_KEEPALIVES, MD_ALLOW_KEEPALIVES, 0, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("CGITimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SCRIPT_TIMEOUT, MD_SCRIPT_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 300, TEXT("")},

      { TEXT("CacheISAPI"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CACHE_EXTENSIONS, MD_CACHE_EXTENSIONS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("FrontPageWeb"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_FRONTPAGE_WEB, MD_FRONTPAGE_WEB, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RevocationFreshnessTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REVOCATION_FRESHNESS_TIME, MD_REVOCATION_FRESHNESS_TIME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 86400, TEXT("")},
      
      { TEXT("RevocationURLRetrievalTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REVOCATION_URL_RETRIEVAL_TIMEOUT, MD_REVOCATION_URL_RETRIEVAL_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

//
// IIsFtpServer
//


      { TEXT("ExitMessage"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_EXIT_MESSAGE, MD_EXIT_MESSAGE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("GreetingMessage"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_GREETING_MESSAGE, MD_GREETING_MESSAGE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("BannerMessage"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_BANNER_MESSAGE, MD_BANNER_MESSAGE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("\0")},
      
      { TEXT("MaxClientsMessage"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MAX_CLIENTS_MESSAGE, MD_MAX_CLIENTS_MESSAGE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AnonymousOnly"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ANONYMOUS_ONLY, MD_ANONYMOUS_ONLY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MSDOSDirOutput"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_MSDOS_DIR_OUTPUT, MD_MSDOS_DIR_OUTPUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

//
// IIsW3File
//




// IIsW3Directory


      { TEXT("AppRoot"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_STRING, MD_APP_ROOT, MD_APP_ROOT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AppFriendlyName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_APP_FRIENDLY_NAME, MD_APP_FRIENDLY_NAME, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AppOopRecoverLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APP_OOP_RECOVER_LIMIT, MD_APP_OOP_RECOVER_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_WAM, APP_OOP_RECOVER_LIMIT_DEFAULT, TEXT("")},

      { TEXT("AppIsolated"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_APP_ISOLATED, MD_APP_ISOLATED, 0, METADATA_INHERIT, IIS_MD_UT_WAM, eAppRunOutProcInDefaultPool, TEXT("")},

      { TEXT("AppPackageName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_STRING, MD_APP_PACKAGE_NAME, MD_APP_PACKAGE_NAME, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AppPackageID"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_STRING, MD_APP_PACKAGE_ID, MD_APP_PACKAGE_ID, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("ContentIndexed"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_IS_CONTENT_INDEXED, MD_IS_CONTENT_INDEXED, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("IgnoreTranslate"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_VR_IGNORE_TRANSLATE, MD_VR_IGNORE_TRANSLATE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("UseDigestSSP"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_USE_DIGEST_SSP, MD_USE_DIGEST_SSP, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

//
// IIsW3VirtualDir
//

      { TEXT("Path"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_VR_PATH, MD_VR_PATH, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("UNCUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_VR_USERNAME, MD_VR_USERNAME, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("UNCPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_VR_PASSWORD, MD_VR_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_FILE, 0, TEXT("")},


//
// IIsFtpVirtualDir
//

      { TEXT("FtpDirBrowseShowLongDate"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SHOW_4_DIGIT_YEAR, MD_SHOW_4_DIGIT_YEAR, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

//
// IIsFilter
//

      { TEXT("FilterPath"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FILTER_IMAGE_PATH, MD_FILTER_IMAGE_PATH, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FilterState"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FILTER_STATE, MD_FILTER_STATE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FilterDescription"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FILTER_DESCRIPTION, MD_FILTER_DESCRIPTION, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FilterEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_FILTER_ENABLED, MD_FILTER_ENABLED, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("FilterFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FILTER_FLAGS, MD_FILTER_FLAGS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifySecurePort"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_SECURE_PORT, MD_NOTIFY_SECURE_PORT, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyNonSecurePort"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_NONSECURE_PORT, MD_NOTIFY_NONSECURE_PORT, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyReadRawData"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_READ_RAW_DATA, MD_NOTIFY_READ_RAW_DATA, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyPreProcHeaders"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_PREPROC_HEADERS, MD_NOTIFY_PREPROC_HEADERS, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyAuthentication"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_AUTHENTICATION, MD_NOTIFY_AUTHENTICATION, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyAuthComplete"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_AUTH_COMPLETE, MD_NOTIFY_AUTH_COMPLETE, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyUrlMap"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_URL_MAP, MD_NOTIFY_URL_MAP, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyAccessDenied"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_ACCESS_DENIED, MD_NOTIFY_ACCESS_DENIED, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifySendResponse"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_SEND_RESPONSE, MD_NOTIFY_SEND_RESPONSE, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifySendRawData"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_SEND_RAW_DATA, MD_NOTIFY_SEND_RAW_DATA, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyLog"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_LOG, MD_NOTIFY_LOG, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyEndOfRequest"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_END_OF_REQUEST, MD_NOTIFY_END_OF_REQUEST, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyEndOfNetSession"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_END_OF_NET_SESSION, MD_NOTIFY_END_OF_NET_SESSION, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyOrderHigh"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_ORDER_HIGH, MD_NOTIFY_ORDER_HIGH, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyOrderMedium"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_ORDER_MEDIUM, MD_NOTIFY_ORDER_MEDIUM, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyOrderLow"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_ORDER_LOW, MD_NOTIFY_ORDER_MEDIUM, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},


//
//
//
//

      { TEXT("AspBufferingOn"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_BUFFERINGON, MD_ASP_BUFFERINGON, 0, METADATA_INHERIT, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspLogErrorRequests"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_LOGERRORREQUESTS, MD_ASP_LOGERRORREQUESTS, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspScriptErrorSentToBrowser"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_SCRIPTERRORSSENTTOBROWSER, MD_ASP_SCRIPTERRORSSENTTOBROWSER, 0, METADATA_INHERIT, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspScriptErrorMessage"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ASP_SCRIPTERRORMESSAGE, MD_ASP_SCRIPTERRORMESSAGE, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("An error occurred on the server when processing the URL. Please contact the system administrator.")},

      { TEXT("AspMaxDiskTemplateCacheFiles"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_MAXDISKTEMPLATECACHEFILES, MD_ASP_MAXDISKTEMPLATECACHEFILES, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0xffffffff, TEXT("")},

      { TEXT("AspScriptFileCacheSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SCRIPTFILECACHESIZE, MD_ASP_SCRIPTFILECACHESIZE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0xffffffff, TEXT("")},

      { TEXT("AspDiskTemplateCacheDirectory"),
        TEXT(""), TEXT("ExpandSz"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_EXPANDSZ, MD_ASP_DISKTEMPLATECACHEDIRECTORY, MD_ASP_DISKTEMPLATECACHEDIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("%Windir%\\System32\\inetsrv\\ASP Compiled Templates")},

      { TEXT("AspScriptEngineCacheMax"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SCRIPTENGINECACHEMAX, MD_ASP_SCRIPTENGINECACHEMAX, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 120, TEXT("")},

      { TEXT("AspScriptTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SCRIPTTIMEOUT, MD_ASP_SCRIPTTIMEOUT, 0, METADATA_INHERIT, ASP_MD_UT_APP, 90, TEXT("")},

      { TEXT("AspSessionTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SESSIONTIMEOUT, MD_ASP_SESSIONTIMEOUT, 0, METADATA_INHERIT, ASP_MD_UT_APP, 10, TEXT("")},

      { TEXT("AspEnableParentPaths"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLEPARENTPATHS, MD_ASP_ENABLEPARENTPATHS, 0, METADATA_INHERIT, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspAllowSessionState"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ALLOWSESSIONSTATE, MD_ASP_ALLOWSESSIONSTATE, 0, METADATA_INHERIT, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspScriptLanguage"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ASP_SCRIPTLANGUAGE, MD_ASP_SCRIPTLANGUAGE, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("Vbscript")},

      { TEXT("AspQueueTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_QUEUETIMEOUT, MD_ASP_QUEUETIMEOUT, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0xffffffff, TEXT("")},

      { TEXT("AspAllowOutOfProcComponents"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ALLOWOUTOFPROCCOMPONENTS, MD_ASP_ALLOWOUTOFPROCCOMPONENTS, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspExceptionCatchEnable"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_EXCEPTIONCATCHENABLE, MD_ASP_EXCEPTIONCATCHENABLE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspCodepage"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_CODEPAGE, MD_ASP_CODEPAGE, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},

      { TEXT("AspLCID"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_LCID, MD_ASP_LCID, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},

      { TEXT("AppAllowDebugging"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLESERVERDEBUG, MD_ASP_ENABLESERVERDEBUG, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},

      { TEXT("AppAllowClientDebug"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLECLIENTDEBUG, MD_ASP_ENABLECLIENTDEBUG, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},

      { TEXT("AspKeepSessionIDSecure"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_KEEPSESSIONIDSECURE, MD_ASP_KEEPSESSIONIDSECURE, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},
//
//
      { TEXT("NetLogonWorkstation"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_NET_LOGON_WKS, MD_NET_LOGON_WKS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("UseHostName"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_USE_HOST_NAME, MD_USE_HOST_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PasswordExpirePrenotifyDays"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ADV_NOTIFY_PWD_EXP_IN_DAYS, MD_ADV_NOTIFY_PWD_EXP_IN_DAYS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PasswordCacheTTL"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ADV_CACHE_TTL, MD_ADV_CACHE_TTL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 600, TEXT("")},

      { TEXT("PasswordChangeFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_AUTH_CHANGE_FLAGS, MD_AUTH_CHANGE_FLAGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ProcessNTCRIfLoggedOn"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_PROCESS_NTCR_IF_LOGGED_ON, MD_PROCESS_NTCR_IF_LOGGED_ON, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("AllowPathInfoForScriptMappings"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS, MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("UNCAuthenticationPassThrough"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_VR_PASSTHROUGH, MD_VR_PASSTHROUGH, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AppWamClsid"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_APP_WAM_CLSID, MD_APP_WAM_CLSID, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("DirBrowseFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_DIRECTORY_BROWSING, MD_DIRECTORY_BROWSING, 0, METADATA_INHERIT, IIS_MD_UT_FILE,
        MD_DIRBROW_SHOW_DATE
        |MD_DIRBROW_SHOW_TIME
        |MD_DIRBROW_SHOW_SIZE
        |MD_DIRBROW_SHOW_EXTENSION
        |MD_DIRBROW_LOADDEFAULT
        , TEXT("")},

      { TEXT("AuthFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_AUTHORIZATION, MD_AUTHORIZATION, 0, METADATA_INHERIT, IIS_MD_UT_FILE, MD_AUTH_ANONYMOUS, TEXT("")},

      { TEXT("AuthPersistence"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_AUTHORIZATION_PERSISTENCE, MD_AUTHORIZATION_PERSISTENCE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, MD_AUTH_SINGLEREQUESTIFPROXY, TEXT("")},

      { TEXT("AuthPersistSingleRequest"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION_PERSISTENCE, MD_VPROP_AUTH_SINGLEREQUEST, MD_AUTH_SINGLEREQUEST, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AuthPersistSingleRequestIfProxy"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION_PERSISTENCE, MD_VPROP_AUTH_SINGLEREQUESTIFPROXY, MD_AUTH_SINGLEREQUESTIFPROXY, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AuthPersistSingleRequestAlwaysIfProxy"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION_PERSISTENCE, MD_VPROP_AUTH_SINGLEREQUESTALWAYSIFPROXY, MD_AUTH_SINGLEREQUESTALWAYSIFPROXY, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ACCESS_PERM, MD_ACCESS_PERM, 0, METADATA_INHERIT, IIS_MD_UT_FILE, MD_ACCESS_READ, TEXT("")},

      { TEXT("AccessSSLFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SSL_ACCESS_PERM, MD_SSL_ACCESS_PERM, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("ScriptMaps"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_SCRIPT_MAPS, MD_SCRIPT_MAPS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("\0")},

      { TEXT("InProcessIsapiApps"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_IN_PROCESS_ISAPI_APPS, MD_IN_PROCESS_ISAPI_APPS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("SSIExecDisable"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SSI_EXEC_DISABLED, MD_SSI_EXEC_DISABLED, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("EnableReverseDns"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DO_REVERSE_DNS, MD_DO_REVERSE_DNS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CreateCGIWithNewConsole"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CREATE_PROC_NEW_CONSOLE, MD_CREATE_PROC_NEW_CONSOLE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("LogModuleId"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOG_PLUGIN_MOD_ID, MD_LOG_PLUGIN_MOD_ID, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogModuleUiId"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOG_PLUGIN_UI_ID, MD_LOG_PLUGIN_UI_ID, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOG_TYPE, MD_LOG_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 1, TEXT("")},

      { TEXT("LogFilePeriod"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGFILE_PERIOD, MD_LOGFILE_PERIOD, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 1, TEXT("")},

      { TEXT("LogPluginClsid"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOG_PLUGIN_ORDER, MD_LOG_PLUGIN_ORDER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogModuleList"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOG_PLUGINS_AVAILABLE, MD_LOG_PLUGINS_AVAILABLE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("NCSA Common Log File Format, Microsoft IIS Log File Format, W3C Extended Log File Format")},

      { TEXT("LogFileDirectory"),
        TEXT(""), TEXT("ExpandSz"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_EXPANDSZ, MD_LOGFILE_DIRECTORY, MD_LOGFILE_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("%Windir%\\System32\\LogExtFiles")},

      { TEXT("LogFileTruncateSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGFILE_TRUNCATE_SIZE, MD_LOGFILE_TRUNCATE_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 2000000, TEXT("")},

      { TEXT("LogFileLocaltimeRollover"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_LOGFILE_LOCALTIME_ROLLOVER, MD_LOGFILE_LOCALTIME_ROLLOVER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileDate"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_DATE, MD_EXTLOG_DATE, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileTime"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_TIME, MD_EXTLOG_TIME, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileClientIp"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_CLIENT_IP, MD_EXTLOG_CLIENT_IP, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileUserName"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_USERNAME, MD_EXTLOG_USERNAME, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileSiteName"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_SITE_NAME, MD_EXTLOG_SITE_NAME, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileComputerName"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_COMPUTER_NAME, MD_EXTLOG_COMPUTER_NAME, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileServerIp"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_SERVER_IP, MD_EXTLOG_SERVER_IP, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileMethod"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_METHOD, MD_EXTLOG_METHOD, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileUriStem"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_URI_STEM, MD_EXTLOG_URI_STEM, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileUriQuery"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_URI_QUERY, MD_EXTLOG_URI_QUERY, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileHttpStatus"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_HTTP_STATUS, MD_EXTLOG_HTTP_STATUS, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileWin32Status"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_WIN32_STATUS, MD_EXTLOG_WIN32_STATUS, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileBytesSent"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_BYTES_SENT, MD_EXTLOG_BYTES_SENT, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileBytesRecv"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_BYTES_RECV, MD_EXTLOG_BYTES_RECV, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileTimeTaken"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_TIME_TAKEN, MD_EXTLOG_TIME_TAKEN, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileServerPort"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_SERVER_PORT, MD_EXTLOG_SERVER_PORT, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileUserAgent"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_USER_AGENT, MD_EXTLOG_USER_AGENT, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileCookie"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_COOKIE, MD_EXTLOG_COOKIE, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileReferer"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_REFERER, MD_EXTLOG_REFERER, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileProtocolVersion"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_PROTOCOL_VERSION , MD_EXTLOG_PROTOCOL_VERSION, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGEXT_FIELD_MASK, MD_LOGEXT_FIELD_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, MD_DEFAULT_EXTLOG_FIELDS, TEXT("")},

      { TEXT("LogExtFileHost"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_HOST, MD_EXTLOG_HOST, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogOdbcDataSource"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGSQL_DATA_SOURCES, MD_LOGSQL_DATA_SOURCES, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("HTTPLOG")},

      { TEXT("LogOdbcTableName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGSQL_TABLE_NAME, MD_LOGSQL_TABLE_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("InternetLog")},

      { TEXT("LogOdbcUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGSQL_USER_NAME, MD_LOGSQL_USER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("InternetAdmin")},

      { TEXT("LogOdbcPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGSQL_PASSWORD, MD_LOGSQL_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CacheControlMaxAge"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CC_MAX_AGE, MD_CC_MAX_AGE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CacheControlNoCache"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CC_NO_CACHE, MD_CC_NO_CACHE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CacheControlCustom"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_CC_OTHER, MD_CC_OTHER, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CreateProcessAsUser"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CREATE_PROCESS_AS_USER, MD_CREATE_PROCESS_AS_USER, 0, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD(-1), TEXT("")},

      { TEXT("DirectoryLevelsToScan"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LEVELS_TO_SCAN, MD_LEVELS_TO_SCAN, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 2, TEXT("")},

      { TEXT("MaxBandwidthBlocked"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_BANDWIDTH_BLOCKED, MD_MAX_BANDWIDTH_BLOCKED, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0xffffffff, TEXT("")},

      { TEXT("PoolIdcTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POOL_IDC_TIMEOUT, MD_POOL_IDC_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("PutReadSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_PUT_READ_SIZE, MD_PUT_READ_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 8192, TEXT("")},

      { TEXT("RedirectHeaders"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_REDIRECT_HEADERS, MD_REDIRECT_HEADERS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("UploadReadAheadSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_UPLOAD_READAHEAD_SIZE, MD_UPLOAD_READAHEAD_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 49152, TEXT("")},

      { TEXT("CPULimitsEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CPU_LIMITS_ENABLED, MD_CPU_LIMITS_ENABLED, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPUResetInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_RESET_INTERVAL, MD_CPU_RESET_INTERVAL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 24, TEXT("")},

      { TEXT("CPULoggingInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_LOGGING_INTERVAL, MD_CPU_LOGGING_INTERVAL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},

      { TEXT("CPULoggingOptions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_LOGGING_OPTIONS, MD_CPU_LOGGING_OPTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 1, TEXT("")},

      { TEXT("CPUEnableAllProcLogging"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_OPTIONS, MD_VPROP_CPU_ENABLE_ALL_PROC_LOGGING, MD_CPU_ENABLE_ALL_PROC_LOGGING, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnableCGILogging"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_OPTIONS, MD_VPROP_CPU_ENABLE_CGI_LOGGING, MD_CPU_ENABLE_CGI_LOGGING, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPUEnableAppLogging"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_OPTIONS, MD_VPROP_CPU_ENABLE_APP_LOGGING, MD_CPU_ENABLE_APP_LOGGING, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPULoggingMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_LOGGING_MASK, MD_CPU_LOGGING_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0x11111111, TEXT("")},

      { TEXT("CPULoggingEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_LOGGING, MD_CPU_ENABLE_LOGGING, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPUEnableEvent"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_EVENT, MD_CPU_ENABLE_EVENT, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnableProcType"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_PROC_TYPE, MD_CPU_ENABLE_PROC_TYPE, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnableUserTime"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_USER_TIME, MD_CPU_ENABLE_USER_TIME, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnableKernelTime"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_KERNEL_TIME, MD_CPU_ENABLE_KERNEL_TIME, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnablePageFaults"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_PAGE_FAULTS, MD_CPU_ENABLE_PAGE_FAULTS, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnableTotalProcs"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_TOTAL_PROCS, MD_CPU_ENABLE_TOTAL_PROCS, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnableActiveProcs"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_ACTIVE_PROCS, MD_CPU_ENABLE_ACTIVE_PROCS, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnableTerminatedProcs"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_TERMINATED_PROCS, MD_CPU_ENABLE_TERMINATED_PROCS, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUCGILimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_CGI_LIMIT, MD_CPU_CGI_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPULimitLogEvent"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_LIMIT_LOGEVENT, MD_CPU_LIMIT_LOGEVENT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPULimitPriority"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_LIMIT_PRIORITY, MD_CPU_LIMIT_PRIORITY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPULimitProcStop"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_LIMIT_PROCSTOP, MD_CPU_LIMIT_PROCSTOP, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPULimitPause"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_LIMIT_PAUSE, MD_CPU_LIMIT_PAUSE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPUAppEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CPU_APP_ENABLED, MD_CPU_APP_ENABLED, 0, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("CPUCGIEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CPU_CGI_ENABLED, MD_CPU_CGI_ENABLED, 0, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("LogCustomPropertyName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGCUSTOM_PROPERTY_NAME, MD_LOGCUSTOM_PROPERTY_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyHeader"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGCUSTOM_PROPERTY_HEADER, MD_LOGCUSTOM_PROPERTY_HEADER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyID"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGCUSTOM_PROPERTY_ID, MD_LOGCUSTOM_PROPERTY_ID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGCUSTOM_PROPERTY_MASK, MD_LOGCUSTOM_PROPERTY_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyDataType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGCUSTOM_PROPERTY_DATATYPE, MD_LOGCUSTOM_PROPERTY_DATATYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyServicesString"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_LOGCUSTOM_SERVICES_STRING, MD_LOGCUSTOM_SERVICES_STRING, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("W3Svc\0MSFTPSvc\0SmtpSvc\0NNTPSvc\0\0")},

      { TEXT("HcCompressionDirectory"),
        TEXT(""), TEXT("ExpandSz"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_EXPANDSZ, MD_HC_COMPRESSION_DIRECTORY, MD_HC_COMPRESSION_DIRECTORY, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("%Windir%\\IIS Temporary Compressed Files")},

      { TEXT("HcCacheControlHeader"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HC_CACHE_CONTROL_HEADER, MD_HC_CACHE_CONTROL_HEADER, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("max-age=86400")},

      { TEXT("HcExpiresHeader"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HC_EXPIRES_HEADER, MD_HC_EXPIRES_HEADER, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcDoDynamicCompression"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_DYNAMIC_COMPRESSION, MD_HC_DO_DYNAMIC_COMPRESSION, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcDoStaticCompression"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_STATIC_COMPRESSION, MD_HC_DO_STATIC_COMPRESSION, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("DoDynamicCompression"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_NAMESPACE_DYNAMIC_COMPRESSION, MD_HC_DO_NAMESPACE_DYNAMIC_COMPRESSION, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("DoStaticCompression"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_NAMESPACE_STATIC_COMPRESSION, MD_HC_DO_NAMESPACE_STATIC_COMPRESSION, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("HcDoOnDemandCompression"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_ON_DEMAND_COMPRESSION, MD_HC_DO_ON_DEMAND_COMPRESSION, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("HcDoDiskSpaceLimiting"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_DISK_SPACE_LIMITING, MD_HC_DO_DISK_SPACE_LIMITING, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcNoCompressionForHttp10"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_NO_COMPRESSION_FOR_HTTP_10, MD_HC_NO_COMPRESSION_FOR_HTTP_10, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("HcNoCompressionForProxies"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_NO_COMPRESSION_FOR_PROXIES, MD_HC_NO_COMPRESSION_FOR_PROXIES, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcNoCompressionForRange"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_NO_COMPRESSION_FOR_RANGE, MD_HC_NO_COMPRESSION_FOR_RANGE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("HcSendCacheHeaders"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_SEND_CACHE_HEADERS, MD_HC_SEND_CACHE_HEADERS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("HcMaxDiskSpaceUsage"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_MAX_DISK_SPACE_USAGE, MD_HC_MAX_DISK_SPACE_USAGE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 1000000, TEXT("")},

      { TEXT("HcIoBufferSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_IO_BUFFER_SIZE, MD_HC_IO_BUFFER_SIZE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 8192, TEXT("")},

      { TEXT("HcCompressionBufferSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_COMPRESSION_BUFFER_SIZE, MD_HC_COMPRESSION_BUFFER_SIZE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 8192, TEXT("")},

      { TEXT("HcMaxQueueLength"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_MAX_QUEUE_LENGTH, MD_HC_MAX_QUEUE_LENGTH, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 1000, TEXT("")},

      { TEXT("HcFilesDeletedPerDiskFree"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_FILES_DELETED_PER_DISK_FREE, MD_HC_FILES_DELETED_PER_DISK_FREE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 256, TEXT("")},

      { TEXT("HcMinFileSizeForComp"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_MIN_FILE_SIZE_FOR_COMP, MD_HC_MIN_FILE_SIZE_FOR_COMP, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 256, TEXT("")},

      { TEXT("HcCompressionDll"),
        TEXT(""), TEXT("ExpandSz"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_EXPANDSZ, MD_HC_COMPRESSION_DLL, MD_HC_COMPRESSION_DLL, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcFileExtensions"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_HC_FILE_EXTENSIONS, MD_HC_FILE_EXTENSIONS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("HcScriptFileExtensions"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_HC_SCRIPT_FILE_EXTENSIONS, MD_HC_SCRIPT_FILE_EXTENSIONS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("HcMimeType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HC_MIME_TYPE, MD_HC_MIME_TYPE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcPriority"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_PRIORITY, MD_HC_PRIORITY, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 1, TEXT("")},

      { TEXT("HcDynamicCompressionLevel"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_DYNAMIC_COMPRESSION_LEVEL, MD_HC_DYNAMIC_COMPRESSION_LEVEL, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcOnDemandCompLevel"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_ON_DEMAND_COMP_LEVEL, MD_HC_ON_DEMAND_COMP_LEVEL, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 10, TEXT("")},

      { TEXT("HcCreateFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_CREATE_FLAGS, MD_HC_CREATE_FLAGS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AspEnableAspHtmlFallback"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLEASPHTMLFALLBACK, MD_ASP_ENABLEASPHTMLFALLBACK, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AspEnableChunkedEncoding"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLECHUNKEDENCODING, MD_ASP_ENABLECHUNKEDENCODING, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspEnableTypelibCache"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLETYPELIBCACHE, MD_ASP_ENABLETYPELIBCACHE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspErrorsToNTLog"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ERRORSTONTLOG, MD_ASP_ERRORSTONTLOG, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AspProcessorThreadMax"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_PROCESSORTHREADMAX, MD_ASP_PROCESSORTHREADMAX, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 10, TEXT("")},

      { TEXT("AspTrackThreadingModel"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_TRACKTHREADINGMODEL, MD_ASP_TRACKTHREADINGMODEL, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AspRequestQueueMax"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_REQEUSTQUEUEMAX, MD_ASP_REQEUSTQUEUEMAX, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 500, TEXT("")},

      { TEXT("AspEnableApplicationRestart"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLEAPPLICATIONRESTART, MD_ASP_ENABLEAPPLICATIONRESTART, 0, METADATA_NO_ATTRIBUTES, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspQueueConnectionTestTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_QUEUECONNECTIONTESTTIME, MD_ASP_QUEUECONNECTIONTESTTIME, 0, METADATA_INHERIT, ASP_MD_UT_APP, 3, TEXT("")},

      { TEXT("AspSessionMax"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SESSIONMAX, MD_ASP_SESSIONMAX, 0, METADATA_INHERIT, ASP_MD_UT_APP, -1, TEXT("")},

      { TEXT("AspThreadGateEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_THREADGATEENABLED, MD_ASP_THREADGATEENABLED, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspThreadGateTimeSlice"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_THREADGATETIMESLICE, MD_ASP_THREADGATETIMESLICE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 1000, TEXT("")},

      { TEXT("AspThreadGateSleepDelay"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_THREADGATESLEEPDELAY, MD_ASP_THREADGATESLEEPDELAY, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 100, TEXT("")},

      { TEXT("AspThreadGateSleepMax"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_THREADGATESLEEPMAX, MD_ASP_THREADGATESLEEPMAX, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 50, TEXT("")},

      { TEXT("AspThreadGateLoadLow"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_THREADGATELOADLOW, MD_ASP_THREADGATELOADLOW, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 75, TEXT("")},

      { TEXT("AspThreadGateLoadHigh"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_THREADGATELOADHIGH, MD_ASP_THREADGATELOADHIGH, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 90, TEXT("")},

      { TEXT("SslUseDsMapper"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SSL_USE_DS_MAPPER, MD_SSL_USE_DS_MAPPER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotDeletable"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_NOT_DELETABLE, MD_NOT_DELETABLE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ClusterEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CLUSTER_ENABLED, MD_CLUSTER_ENABLED, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SSLCertHash"),
        TEXT(""), TEXT("Binary"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_BINARY, MD_SSL_CERT_HASH, MD_SSL_CERT_HASH, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SSLStoreName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_STRING, MD_SSL_CERT_STORE_NAME, MD_SSL_CERT_STORE_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

//--------------------------------------------------------------------
//
//      -- BEGIN EXTENSION PROPERTIES -- magnush
//
//--------------------------------------------------------------------

                // I think this one should be added to the standard IIS properties:

      { TEXT("Win32Error"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_WIN32_ERROR, MD_WIN32_ERROR, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},



        //
        //      NNTP service:
        //

      { TEXT("ArticleTimeLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ARTICLE_TIME_LIMIT, MD_ARTICLE_TIME_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("HistoryExpiration"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HISTORY_EXPIRATION, MD_HISTORY_EXPIRATION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("HonorClientMsgIds"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HONOR_CLIENT_MSGIDS, MD_HONOR_CLIENT_MSGIDS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, TRUE, TEXT("")},

      { TEXT("SmtpServer"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_SERVER, MD_SMTP_SERVER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AdminEmail"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ADMIN_EMAIL, MD_ADMIN_EMAIL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AdminName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ADMIN_NAME, MD_ADMIN_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AllowClientPosts"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_CLIENT_POSTS, MD_ALLOW_CLIENT_POSTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, TRUE, TEXT("")},

      { TEXT("AllowFeedPosts"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_FEED_POSTS, MD_ALLOW_FEED_POSTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, TRUE, TEXT("")},

      { TEXT("AllowControlMsgs"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_CONTROL_MSGS, MD_ALLOW_CONTROL_MSGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, TRUE, TEXT("")},

      { TEXT("DefaultModeratorDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DEFAULT_MODERATOR, MD_DEFAULT_MODERATOR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NntpCommandLogMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_NNTP_COMMAND_LOG_MASK, MD_NNTP_COMMAND_LOG_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("DisableNewNews"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DISABLE_NEWNEWS, MD_DISABLE_NEWNEWS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NewsCrawlerTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_NEWS_CRAWLER_TIME, MD_NEWS_CRAWLER_TIME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("ShutdownLatency"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SHUTDOWN_LATENCY, MD_SHUTDOWN_LATENCY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

        //
        //      NNTP Virtual Server:
        //

      { TEXT("GroupHelpFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_GROUP_HELP_FILE, MD_GROUP_HELP_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("GroupListFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_GROUP_LIST_FILE, MD_GROUP_LIST_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ArticleTableFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ARTICLE_TABLE_FILE, MD_ARTICLE_TABLE_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HistoryTableFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HISTORY_TABLE_FILE, MD_HISTORY_TABLE_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ModeratorFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MODERATOR_FILE, MD_MODERATOR_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("XoverTableFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_XOVER_TABLE_FILE, MD_XOVER_TABLE_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ClientPostHardLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CLIENT_POST_HARD_LIMIT, MD_CLIENT_POST_HARD_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("ClientPostSoftLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CLIENT_POST_SOFT_LIMIT, MD_CLIENT_POST_SOFT_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("FeedPostHardLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_POST_HARD_LIMIT, MD_FEED_POST_HARD_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("FeedPostSoftLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_POST_SOFT_LIMIT, MD_FEED_POST_SOFT_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("NntpUucpName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_NNTP_UUCP_NAME, MD_NNTP_UUCP_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NntpOrganization"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_NNTP_ORGANIZATION, MD_NNTP_ORGANIZATION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ListFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LIST_FILE, MD_LIST_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NewsPickupDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_PICKUP_DIRECTORY, MD_PICKUP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NewsFailedPickupDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FAILED_PICKUP_DIRECTORY, MD_FAILED_PICKUP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NntpServiceVersion"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_NNTP_SERVICE_VERSION, MD_NNTP_SERVICE_VERSION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NewsDropDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DROP_DIRECTORY, MD_DROP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PrettyNamesFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_PRETTYNAMES_FILE, MD_PRETTYNAMES_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NntpClearTextProvider"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_NNTP_CLEARTEXT_AUTH_PROVIDER, MD_NNTP_CLEARTEXT_AUTH_PROVIDER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedReportPeriod"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_REPORT_PERIOD, MD_FEED_REPORT_PERIOD, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxSearchResults"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_SEARCH_RESULTS, MD_MAX_SEARCH_RESULTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("GroupvarListFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_GROUPVAR_LIST_FILE, MD_GROUPVAR_LIST_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

    //
    // IIsNntpFeed
    //

      { TEXT("FeedServerName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_SERVER_NAME, MD_FEED_SERVER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_TYPE, MD_FEED_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedNewsgroups"),
        TEXT(""), TEXT("List"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_FEED_NEWSGROUPS, MD_FEED_NEWSGROUPS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedSecurityType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_SECURITY_TYPE, MD_FEED_SECURITY_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedAuthenticationType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_AUTHENTICATION_TYPE, MD_FEED_AUTHENTICATION_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedAccountName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_ACCOUNT_NAME, MD_FEED_ACCOUNT_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_PASSWORD, MD_FEED_PASSWORD, 0, METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedStartTimeHigh"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_START_TIME_HIGH, MD_FEED_START_TIME_HIGH, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedStartTimeLow"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_START_TIME_LOW, MD_FEED_START_TIME_LOW, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_INTERVAL, MD_FEED_INTERVAL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedAllowControlMsgs"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_ALLOW_CONTROL_MSGS, MD_FEED_ALLOW_CONTROL_MSGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedCreateAutomatically"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_CREATE_AUTOMATICALLY, MD_FEED_CREATE_AUTOMATICALLY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedDisabled"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_DISABLED, MD_FEED_DISABLED, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedDistribution"),
        TEXT(""), TEXT("List"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_FEED_DISTRIBUTION, MD_FEED_DISTRIBUTION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedConcurrentSessions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_CONCURRENT_SESSIONS, MD_FEED_CONCURRENT_SESSIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedMaxConnectionAttempts"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_MAX_CONNECTION_ATTEMPTS, MD_FEED_MAX_CONNECTION_ATTEMPTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedUucpName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_UUCP_NAME, MD_FEED_UUCP_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedTempDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_TEMP_DIRECTORY, MD_FEED_TEMP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedNextPullHigh"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_NEXT_PULL_HIGH, MD_FEED_NEXT_PULL_HIGH, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedNextPullLow"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_NEXT_PULL_LOW, MD_FEED_NEXT_PULL_LOW, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedPeerTempDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_PEER_TEMP_DIRECTORY, MD_FEED_PEER_TEMP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedPeerGapSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_PEER_GAP_SIZE, MD_FEED_PEER_GAP_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedOutgoingPort"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_OUTGOING_PORT, MD_FEED_OUTGOING_PORT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedFeedpairId"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_FEEDPAIR_ID, MD_FEED_FEEDPAIR_ID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},
	
      { TEXT("FeedHandshake"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_HANDSHAKE, MD_FEED_HANDSHAKE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedAdminError"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_ADMIN_ERROR, MD_FEED_ADMIN_ERROR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedErrParmMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_ERR_PARM_MASK, MD_FEED_ERR_PARM_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

    //
    // IIsNntpExpire
    //

      { TEXT("ExpireSpace"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_EXPIRE_SPACE, MD_EXPIRE_SPACE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("ExpireTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_EXPIRE_TIME, MD_EXPIRE_TIME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("ExpireNewsgroups"),
        TEXT(""), TEXT("List"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_EXPIRE_NEWSGROUPS, MD_EXPIRE_NEWSGROUPS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ExpirePolicyName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_EXPIRE_POLICY_NAME, MD_EXPIRE_POLICY_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

     //
     // IIsNntpVirtualDir
     //
      { TEXT("VrDriverClsid"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_VR_DRIVER_CLSID, MD_VR_DRIVER_CLSID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("VrDriverProgid"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_VR_DRIVER_PROGID, MD_VR_DRIVER_PROGID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FsPropertyPath"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FS_PROPERTY_PATH, MD_FS_PROPERTY_PATH, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("VrUseAccount"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_VR_USE_ACCOUNT, MD_VR_USE_ACCOUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("VrDoExpire"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_VR_DO_EXPIRE, MD_VR_DO_EXPIRE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ExMdbGuid"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_EX_MDB_GUID, MD_EX_MDB_GUID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("VrOwnModerator"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_VR_OWN_MODERATOR, MD_VR_OWN_MODERATOR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AccessAllowPosting"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_NNTP_ALLOW_POSTING, MD_ACCESS_WRITE, METADATA_INHERIT, IIS_MD_UT_FILE, TRUE, TEXT("")},

      { TEXT("AccessRestrictGroupVisibility"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_NNTP_RESTRICT_GROUP_VISIBILITY, MD_ACCESS_EXECUTE, METADATA_INHERIT, IIS_MD_UT_FILE, FALSE, TEXT("")},

    //
    // IIsSmtpService
    //
      { TEXT("SmtpServiceVersion"),
        TEXT(""), TEXT("Integer"), 0, 1, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_SERVICE_VERSION, MD_SMTP_SERVICE_VERSION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},


      { TEXT("EnableReverseDnsLookup"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_REVERSE_NAME_LOOKUP, MD_REVERSE_NAME_LOOKUP, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ShouldDeliver"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SHOULD_DELIVER, MD_SHOULD_DELIVER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 1, TEXT("")},

      { TEXT("AlwaysUseSsl"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALWAYS_USE_SSL, MD_ALWAYS_USE_SSL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("AlwaysUseSasl"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALWAYS_USE_SASL, MD_ALWAYS_USE_SASL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

      { TEXT("LimitRemoteConnections"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_LIMIT_REMOTE_CONNECTIONS, MD_LIMIT_REMOTE_CONNECTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("DoMasquerade"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DO_MASQUERADE, MD_DO_MASQUERADE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmartHostType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMARTHOST_TYPE, MD_SMARTHOST_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RemoteSmtpPort"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_SMTP_PORT, MD_REMOTE_SMTP_PORT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 25, TEXT("")},

      { TEXT("RemoteSmtpSecurePort"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_SECURE_PORT, MD_REMOTE_SECURE_PORT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 465, TEXT("")},

      { TEXT("HopCount"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HOP_COUNT, MD_HOP_COUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 10, TEXT("")},

      { TEXT("MaxOutConnections"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_OUTBOUND_CONNECTION, MD_MAX_OUTBOUND_CONNECTION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxOutConnectionsPerDomain"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_OUT_CONN_PER_DOMAIN, MD_MAX_OUT_CONN_PER_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RemoteTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_TIMEOUT, MD_REMOTE_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxMessageSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_MSG_SIZE, MD_MAX_MSG_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0x2000000, TEXT("")},

      { TEXT("MaxSessionSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_MSG_SIZE_B4_CLOSE, MD_MAX_MSG_SIZE_B4_CLOSE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0x10000000, TEXT("")},

      { TEXT("MaxRecipients"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_RECIPIENTS, MD_MAX_RECIPIENTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 100, TEXT("")},

      { TEXT("LocalRetryInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOCAL_RETRY_MINUTES, MD_LOCAL_RETRY_MINUTES, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},

      { TEXT("RemoteRetryInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_RETRY_MINUTES, MD_REMOTE_RETRY_MINUTES, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},

      { TEXT("LocalRetryAttempts"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOCAL_RETRY_ATTEMPTS, MD_LOCAL_RETRY_ATTEMPTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 48, TEXT("")},

      { TEXT("RemoteRetryAttempts"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_RETRY_ATTEMPTS, MD_REMOTE_RETRY_ATTEMPTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 48, TEXT("")},

      { TEXT("EtrnDays"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ETRN_DAYS, MD_ETRN_DAYS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxBatchedMessages"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_BATCH_MSG_LIMIT, MD_BATCH_MSG_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxSmtpLogonErrors"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_SMTP_AUTHLOGON_ERRORS, MD_MAX_SMTP_AUTHLOGON_ERRORS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 4, TEXT("")},

      { TEXT("SmartHost"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMARTHOST_NAME, MD_SMARTHOST_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FullyQualifiedDomainName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FQDN_VALUE, MD_FQDN_VALUE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("DefaultDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DEFAULT_DOMAIN_VALUE, MD_DEFAULT_DOMAIN_VALUE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("DropDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MAIL_DROP_DIR, MD_MAIL_DROP_DIR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("BadMailDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_BAD_MAIL_DIR, MD_BAD_MAIL_DIR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PickupDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MAIL_PICKUP_DIR, MD_MAIL_PICKUP_DIR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("QueueDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MAIL_QUEUE_DIR, MD_MAIL_QUEUE_DIR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RoutingDll"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ROUTING_DLL, MD_ROUTING_DLL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MasqueradeDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MASQUERADE_NAME, MD_MASQUERADE_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SendNdrTo"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SEND_NDR_TO, MD_SEND_NDR_TO, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SaslLogonDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SASL_LOGON_DOMAIN, MD_SASL_LOGON_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("ServerSsAuthMapping"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SERVER_SS_AUTH_MAPPING, MD_SERVER_SS_AUTH_MAPPING, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

      { TEXT("SmtpClearTextProvider"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_CLEARTEXT_AUTH_PROVIDER, MD_SMTP_CLEARTEXT_AUTH_PROVIDER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SendBadTo"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SEND_BAD_TO, MD_SEND_BAD_TO, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RoutingSources"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RO, 0, IIS_SYNTAX_ID_MULTISZ, MD_ROUTING_SOURCES, MD_ROUTING_SOURCES, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("DomainRouting"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RO, 0, IIS_SYNTAX_ID_MULTISZ, MD_DOMAIN_ROUTING, MD_DOMAIN_ROUTING, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      //SMTP Retry related data
      { TEXT("SmtpRemoteProgressiveRetry"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_REMOTE_PROGRESSIVE_RETRY_MINUTES, MD_SMTP_REMOTE_PROGRESSIVE_RETRY_MINUTES, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpLocalDelayExpireMinutes"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EXPIRE_LOCAL_DELAY_MIN, MD_SMTP_EXPIRE_LOCAL_DELAY_MIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},

      { TEXT("SmtpLocalNDRExpireMinutes"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EXPIRE_LOCAL_NDR_MIN, MD_SMTP_EXPIRE_LOCAL_NDR_MIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 2880, TEXT("")},

      { TEXT("SmtpRemoteDelayExpireMinutes"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EXPIRE_REMOTE_DELAY_MIN, MD_SMTP_EXPIRE_REMOTE_DELAY_MIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},

      { TEXT("SmtpRemoteNDRExpireMinutes"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EXPIRE_REMOTE_NDR_MIN, MD_SMTP_EXPIRE_REMOTE_NDR_MIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 2880, TEXT("")},

      { TEXT("SmtpRemoteRetryThreshold"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_REMOTE_RETRY_THRESHOLD, MD_SMTP_REMOTE_RETRY_THRESHOLD, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 3, TEXT("")},

      { TEXT("SmtpDSNOptions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DSN_OPTIONS, MD_SMTP_DSN_OPTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDSNLanguageID"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DSN_LANGUAGE_ID, MD_SMTP_DSN_LANGUAGE_ID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpInboundCommandSupportOptions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_INBOUND_COMMAND_SUPPORT_OPTIONS, MD_INBOUND_COMMAND_SUPPORT_OPTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, SMTP_DEFAULT_CMD_SUPPORT, TEXT("")},

      { TEXT("SmtpOutboundCommandSupportOptions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_OUTBOUND_COMMAND_SUPPORT_OPTIONS, MD_OUTBOUND_COMMAND_SUPPORT_OPTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, SMTP_DEFAULT_CMD_SUPPORT, TEXT("")},

      { TEXT("SmtpAdvQueueDll"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_AQUEUE_DLL, MD_AQUEUE_DLL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      // props below added by awetmore- 11/09/2000
      { TEXT("DisableSocketPooling"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DISABLE_SOCKET_POOLING, MD_DISABLE_SOCKET_POOLING, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpUseTcpDns"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SMTP_USE_TCP_DNS, MD_SMTP_USE_TCP_DNS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpDomainValidationFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_DOMAIN_VALIDATION_FLAGS, MD_DOMAIN_VALIDATION_FLAGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpSSLRequireTrustedCA"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SMTP_SSL_REQUIRE_TRUSTED_CA, MD_SMTP_SSL_REQUIRE_TRUSTED_CA, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpSSLCertHostnameValidation"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SMTP_SSL_CERT_HOSTNAME_VALIDATION, MD_SMTP_SSL_CERT_HOSTNAME_VALIDATION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("MaxMailObjects"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_MAIL_OBJECTS, MD_MAX_MAIL_OBJECTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("ShouldPickupMail"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SHOULD_PICKUP_MAIL, MD_SHOULD_PICKUP_MAIL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("MaxDirChangeIOSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_DIR_CHANGE_IO_SIZE, MD_MAX_DIR_CHANGE_IO_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("NameResolutionType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_NAME_RESOLUTION_TYPE, MD_NAME_RESOLUTION_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("MaxSmtpErrors"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_SMTP_ERRORS, MD_MAX_SMTP_ERRORS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("ShouldPipelineIn"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SHOULD_PIPELINE_IN, MD_SHOULD_PIPELINE_IN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("ShouldPipelineOut"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SHOULD_PIPELINE_OUT, MD_SHOULD_PIPELINE_OUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("ConnectResponse"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_CONNECT_RESPONSE, MD_CONNECT_RESPONSE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("UpdatedFQDN"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_UPDATED_FQDN, MD_UPDATED_FQDN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("UpdatedDefaultDomain"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_UPDATED_DEFAULT_DOMAIN, MD_UPDATED_DEFAULT_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("EtrnSubdomains"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ETRN_SUBDOMAINS, MD_ETRN_SUBDOMAINS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpMaxRemoteQThreads"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_MAX_REMOTEQ_THREADS, MD_SMTP_MAX_REMOTEQ_THREADS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpDisableRelay"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SMTP_DISABLE_RELAY, MD_SMTP_DISABLE_RELAY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpHeloNoDomain"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SMTP_HELO_NODOMAIN, MD_SMTP_HELO_NODOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpMailNoHelo"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SMTP_MAIL_NO_HELO, MD_SMTP_MAIL_NO_HELO, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpAqueueWait"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_AQUEUE_WAIT, MD_SMTP_AQUEUE_WAIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("AddNoHeaders"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ADD_NOHEADERS, MD_ADD_NOHEADERS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpEventlogLevel"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EVENTLOG_LEVEL, MD_SMTP_EVENTLOG_LEVEL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

    // IIsSmtpDomain
    //
      { TEXT("RouteAction"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ROUTE_ACTION, MD_ROUTE_ACTION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RouteActionString"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ROUTE_ACTION_TYPE, MD_ROUTE_ACTION_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RouteUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ROUTE_USER_NAME, MD_ROUTE_USER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RoutePassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ROUTE_PASSWORD, MD_ROUTE_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpCommandLogMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_COMMAND_LOG_MASK, MD_COMMAND_LOG_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpFlushMailFile"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FLUSH_MAIL_FILE, MD_FLUSH_MAIL_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RelayIpList"),
        TEXT(""), TEXT("IPSec"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_IPSECLIST, MD_SMTP_IP_RELAY_ADDRESSES, MD_SMTP_IP_RELAY_ADDRESSES, 0, METADATA_INHERIT | METADATA_REFERENCE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RelayForAuth"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_RELAY_FOR_AUTH_USERS, MD_SMTP_RELAY_FOR_AUTH_USERS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AuthTurnList"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_SMTP_AUTHORIZED_TURN_LIST, MD_SMTP_AUTHORIZED_TURN_LIST, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CSideEtrnDomains"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_CSIDE_ETRN_DOMAIN, MD_SMTP_CSIDE_ETRN_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      // ---

      { TEXT("SmtpConnectTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_CONNECT_TIMEOUT, MD_SMTP_CONNECT_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpMailFromTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_MAILFROM_TIMEOUT, MD_SMTP_MAILFROM_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpRcptToTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_RCPTTO_TIMEOUT, MD_SMTP_RCPTTO_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDataTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DATA_TIMEOUT, MD_SMTP_DATA_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpBdatTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_BDAT_TIMEOUT, MD_SMTP_BDAT_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpAuthTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_AUTH_TIMEOUT, MD_SMTP_AUTH_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpSaslTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_SASL_TIMEOUT, MD_SMTP_SASL_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("SmtpEtrnTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_ETRN_TIMEOUT, MD_SMTP_ETRN_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

      { TEXT("SmtpTurnTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_TURN_TIMEOUT, MD_SMTP_TURN_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpRsetTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_RSET_TIMEOUT, MD_SMTP_RSET_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("SmtpQuitTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_QUIT_TIMEOUT, MD_SMTP_QUIT_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

      { TEXT("SmtpHeloTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_HELO_TIMEOUT, MD_SMTP_HELO_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("SmtpEhloTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EHLO_TIMEOUT, MD_SMTP_EHLO_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDataTermTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DATATERMINATION_TIMEOUT, MD_SMTP_DATATERMINATION_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpBdatTermTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_BDATTERMINATION_TIMEOUT, MD_SMTP_BDATTERMINATION_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpTlsTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_TLS_TIMEOUT, MD_SMTP_TLS_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

    // IIsPop3Service
    //
      { TEXT("Pop3ServiceVersion"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_SERVICE_VERSION, MD_POP3_SERVICE_VERSION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3ExpireMail"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_EXPIRE_INSTANCE_MAIL, MD_POP3_EXPIRE_INSTANCE_MAIL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3ExpireDelay"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_EXPIRE_DELAY, MD_POP3_EXPIRE_DELAY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (24*60), TEXT("")},

      { TEXT("Pop3ExpireStart"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_EXPIRE_START, MD_POP3_EXPIRE_START, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3ClearTextProvider"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_CLEARTEXT_AUTH_PROVIDER, MD_POP3_CLEARTEXT_AUTH_PROVIDER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DefaultDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DEFAULT_DOMAIN_VALUE, MD_POP3_DEFAULT_DOMAIN_VALUE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3RoutingDll"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_ROUTING_DLL, MD_POP3_ROUTING_DLL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3RoutingSources"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RO, 0, IIS_SYNTAX_ID_MULTISZ, MD_POP3_ROUTING_SOURCE, MD_POP3_ROUTING_SOURCE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},


    // IIsImapService
    //
      { TEXT("ImapServiceVersion"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_SERVICE_VERSION, MD_IMAP_SERVICE_VERSION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapExpireMail"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_EXPIRE_INSTANCE_MAIL, MD_IMAP_EXPIRE_INSTANCE_MAIL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapExpireDelay"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_EXPIRE_DELAY, MD_IMAP_EXPIRE_DELAY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (24*60), TEXT("")},

      { TEXT("ImapExpireStart"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_EXPIRE_START, MD_IMAP_EXPIRE_START, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapClearTextProvider"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_CLEARTEXT_AUTH_PROVIDER, MD_IMAP_CLEARTEXT_AUTH_PROVIDER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDefaultDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DEFAULT_DOMAIN_VALUE, MD_IMAP_DEFAULT_DOMAIN_VALUE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapRoutingDll"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_ROUTING_DLL, MD_IMAP_ROUTING_DLL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapRoutingSources"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RO, 0, IIS_SYNTAX_ID_MULTISZ, MD_IMAP_ROUTING_SOURCE, MD_IMAP_ROUTING_SOURCE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

    // IIsPop3VirtualDir
    //
      { TEXT("Pop3MailExpirationTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_EXPIRE_MSG_HOURS, MD_POP3_EXPIRE_MSG_HOURS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

    // IIsImapVirtualDir
    //
      { TEXT("ImapMailExpirationTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_EXPIRE_MSG_HOURS, MD_IMAP_EXPIRE_MSG_HOURS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

    // IIsSmtpRoutingSource
    //
      { TEXT("SmtpRoutingTableType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_TYPE, MD_SMTP_DS_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("LDAP")},

      { TEXT("SmtpDsDataDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_DATA_DIRECTORY, MD_SMTP_DS_DATA_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsDefaultMailRoot"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_DEFAULT_MAIL_ROOT, MD_SMTP_DS_DEFAULT_MAIL_ROOT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsBindType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_BIND_TYPE, MD_SMTP_DS_BIND_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsSchemaType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_SCHEMA_TYPE, MD_SMTP_DS_SCHEMA_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsHost"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_HOST, MD_SMTP_DS_HOST, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsNamingContext"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_NAMING_CONTEXT, MD_SMTP_DS_NAMING_CONTEXT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_DOMAIN, MD_SMTP_DS_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsAccount"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_ACCOUNT, MD_SMTP_DS_ACCOUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_PASSWORD, MD_SMTP_DS_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsUseCat"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DS_USE_CAT, MD_SMTP_DS_USE_CAT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DS_FLAGS, MD_SMTP_DS_FLAGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsPort"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DS_PORT, MD_SMTP_DS_PORT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

    // IIsPop3RoutingSource
    //
      { TEXT("Pop3RoutingTableType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_TYPE, MD_POP3_DS_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("LDAP")},

      { TEXT("Pop3DsDataDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_DATA_DIRECTORY, MD_POP3_DS_DATA_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsDefaultMailRoot"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_DEFAULT_MAIL_ROOT, MD_POP3_DS_DEFAULT_MAIL_ROOT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsBindType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_BIND_TYPE, MD_POP3_DS_BIND_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsSchemaType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_SCHEMA_TYPE, MD_POP3_DS_SCHEMA_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsHost"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_HOST, MD_POP3_DS_HOST, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsNamingContext"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_NAMING_CONTEXT, MD_POP3_DS_NAMING_CONTEXT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsAccount"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_ACCOUNT, MD_POP3_DS_ACCOUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_PASSWORD, MD_POP3_DS_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},


    // IIsImapRoutingSource
    //
      { TEXT("ImapRoutingTableType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_TYPE, MD_IMAP_DS_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("LDAP")},

      { TEXT("ImapDsDataDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_DATA_DIRECTORY, MD_IMAP_DS_DATA_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsDefaultMailRoot"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_DEFAULT_MAIL_ROOT, MD_IMAP_DS_DEFAULT_MAIL_ROOT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsBindType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_BIND_TYPE, MD_IMAP_DS_BIND_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsSchemaType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_SCHEMA_TYPE, MD_IMAP_DS_SCHEMA_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsHost"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_HOST, MD_IMAP_DS_HOST, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsNamingContext"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_NAMING_CONTEXT, MD_IMAP_DS_NAMING_CONTEXT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsAccount"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_ACCOUNT, MD_IMAP_DS_ACCOUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_PASSWORD, MD_IMAP_DS_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PeriodicRestartTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_PERIODIC_RESTART_TIME, MD_APPPOOL_PERIODIC_RESTART_TIME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},
      { TEXT("PeriodicRestartRequests"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT, MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 10000, TEXT("")},
      { TEXT("MaxProcesses"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_MAX_PROCESS_COUNT, MD_APPPOOL_MAX_PROCESS_COUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 1, TEXT("")},
      { TEXT("PingingEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_PINGING_ENABLED, MD_APPPOOL_PINGING_ENABLED, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},
      { TEXT("IdleTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_IDLE_TIMEOUT, MD_APPPOOL_IDLE_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 10, TEXT("")},
      { TEXT("RapidFailProtection"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED, MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},
      { TEXT("SMPAffinitized"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_SMP_AFFINITIZED, MD_APPPOOL_SMP_AFFINITIZED, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},
      { TEXT("SMPProcessorAffinityMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_SMP_AFFINITIZED_PROCESSOR_MASK, MD_APPPOOL_SMP_AFFINITIZED_PROCESSOR_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},
      { TEXT("OrphanWorkerProcess"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING, MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},
      { TEXT("StartupTimeLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_STARTUP_TIMELIMIT, MD_APPPOOL_STARTUP_TIMELIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 30, TEXT("")},
      { TEXT("ShutdownTimeLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_SHUTDOWN_TIMELIMIT, MD_APPPOOL_SHUTDOWN_TIMELIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},
      { TEXT("PingInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_PING_INTERVAL, MD_APPPOOL_PING_INTERVAL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 300, TEXT("")},
      { TEXT("PingResponseTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_PING_RESPONSE_TIMELIMIT, MD_APPPOOL_PING_RESPONSE_TIMELIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},
      { TEXT("DisallowOverlappingRotation"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_DISALLOW_OVERLAPPING_ROTATION, MD_APPPOOL_DISALLOW_OVERLAPPING_ROTATION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},
      { TEXT("OrphanAction"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_APPPOOL_ORPHAN_ACTION, MD_APPPOOL_ORPHAN_ACTION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
      { TEXT("UlAppPoolQueueLength"),
        TEXT(""), TEXT("Integer"), -1, 4000000, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH, MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 3000, TEXT("")},
      { TEXT("DisallowRotationOnConfigChange"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_DISALLOW_ROTATION_ON_CONFIG_CHANGE, MD_APPPOOL_DISALLOW_ROTATION_ON_CONFIG_CHANGE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},
      { TEXT("AppPoolFriendlyName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_APPPOOL_FRIENDLY_NAME, MD_APPPOOL_FRIENDLY_NAME, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},
      { TEXT("AppPoolId"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_APPPOOL_APPPOOL_ID, MD_APPPOOL_APPPOOL_ID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
      { TEXT("AllowTransientRegistration"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_ALLOW_TRANSIENT_REGISTRATION, MD_APPPOOL_ALLOW_TRANSIENT_REGISTRATION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},
      { TEXT("AppAutoStart"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_AUTO_START, MD_APPPOOL_AUTO_START, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},
      { TEXT("PeriodicRestartConnections"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_PERIODIC_RESTART_CONNECTIONS, MD_APPPOOL_PERIODIC_RESTART_CONNECTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 10000, TEXT("")},

//--------------------------------------------------------------------
//
//      -- END EXTENSION PROPERTIES -- magnush
//
//--------------------------------------------------------------------

#if 0
        // THis is the blank property template
      { TEXT(""),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FILTER_LOAD_ORDER, MD_FILTER_LOAD_ORDER, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif
};


DWORD g_cIISProperties = sizeof(g_aIISProperties)/sizeof(PROPERTYINFO);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\iismrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       iismrshl.cxx
//
//  Contents:   IIS marshalling code
//
//  Functions:
//
//  History:    27-Feb-97  Sophiac Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"

#define MAX_PATH_MULTISZ_STRING         256
#define MAX_PATH_MIMEMAP_STRING         100

PMETADATA_RECORD
CopyIISSynIdDWORD_To_IISDWORD(
	IIsSchema *pSchema,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject
    )
{
    DWORD dwAttribute = ALL_METADATA;
    DWORD dwUserType = ALL_METADATA;

    pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwUserType);

    pMetaDataRec->dwMDIdentifier = dwMetaId;
    pMetaDataRec->dwMDAttributes = dwAttribute;
    pMetaDataRec->dwMDUserType = dwUserType;
    pMetaDataRec->dwMDDataType = DWORD_METADATA;
    pMetaDataRec->dwMDDataLen = sizeof(DWORD);
    pMetaDataRec->pbMDData = (LPBYTE)&(lpIISObject->IISValue.value_1.dwDWORD);

    return(pMetaDataRec);
}

PMETADATA_RECORD
CopyIISSynIdSTRING_To_IISSTRING(
	IIsSchema *pSchema,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject
    )
{
    DWORD dwStatus = 0;
    DWORD dwAttribute = ALL_METADATA;
    DWORD dwUserType = ALL_METADATA;
    LPWSTR pszData = NULL;

    pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwUserType);

    pMetaDataRec->dwMDIdentifier = dwMetaId;
    pMetaDataRec->dwMDAttributes = dwAttribute;
    pMetaDataRec->dwMDUserType = dwUserType;
    pMetaDataRec->dwMDDataType = STRING_METADATA;
    pMetaDataRec->dwMDDataLen = 0;

    if (lpIISObject) {
        pszData = AllocADsStr((LPWSTR)lpIISObject->IISValue.value_2.String);

        if (!pszData) {
            return(pMetaDataRec);
        }

        pMetaDataRec->dwMDDataLen = (wcslen(pszData) + 1)*2;
    }

    pMetaDataRec->pbMDData = (LPBYTE)pszData;

    return(pMetaDataRec);
}

PMETADATA_RECORD
CopyIISSynIdEXPANDSZ_To_IISEXPANDSZ(
	IIsSchema *pSchema,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject
    )
{
    DWORD dwStatus = 0;
    DWORD dwAttribute = ALL_METADATA;
    DWORD dwUserType = ALL_METADATA;
    LPWSTR pszData = NULL;

    pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwUserType);

    pMetaDataRec->dwMDIdentifier = dwMetaId;
    pMetaDataRec->dwMDAttributes = dwAttribute;
    pMetaDataRec->dwMDUserType = dwUserType;
    pMetaDataRec->dwMDDataType = EXPANDSZ_METADATA;
    pMetaDataRec->dwMDDataLen = 0;

    if (lpIISObject) {
        pszData = AllocADsStr((LPWSTR)lpIISObject->IISValue.value_3.ExpandSz);

        if (!pszData) {
            return(pMetaDataRec);
        }
        pMetaDataRec->dwMDDataLen = (wcslen(pszData) + 1)*2;
    }

    pMetaDataRec->pbMDData = (LPBYTE)pszData;

    return(pMetaDataRec);
}

PMETADATA_RECORD
CopyIISSynIdMULTISZ_To_IISMULTISZ(
	IIsSchema *pSchema,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject,
    DWORD dwNumValues
    )
{
    DWORD dwStatus = 0;
    DWORD i;
    DWORD dwAttribute = ALL_METADATA;
    DWORD dwUserType = ALL_METADATA;
    LPWSTR pszStr = NULL;
    LPWSTR pszData = NULL;

    pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwUserType);

    pMetaDataRec->dwMDIdentifier = dwMetaId;
    pMetaDataRec->dwMDAttributes = dwAttribute;
    pMetaDataRec->dwMDUserType = dwUserType;
    pMetaDataRec->dwMDDataType = MULTISZ_METADATA;
    pMetaDataRec->dwMDDataLen = 0;

    //
    // Calculate buffer length to allocate
    //

    for (i = 0; i < dwNumValues; i++) {
        pszData = (LPWSTR)lpIISObject[i].IISValue.value_4.MultiSz;
        pMetaDataRec->dwMDDataLen += (wcslen(pszData) + 1)*2;
    }

    //
    // +2 for the extra null terminator
    //

    pszStr = (LPWSTR) AllocADsMem(pMetaDataRec->dwMDDataLen + 2);

    if (pszStr == NULL) {
        return(pMetaDataRec);
    }

    //
    // empty contents
    //

    wcscpy(pszStr, L"");

    pMetaDataRec->pbMDData = (LPBYTE)pszStr;

    for (i = 0; i < dwNumValues; i++) {

        pszData = (LPWSTR)lpIISObject[i].IISValue.value_4.MultiSz;
        wcscat(pszStr, pszData);
        pszStr += wcslen(pszData);
        *pszStr = L'\0';
        pszStr++;

    }

    *pszStr = L'\0';
    pMetaDataRec->dwMDDataLen += 2;

    return(pMetaDataRec);
}

PMETADATA_RECORD
CopyIISSynIdBINARY_To_IISBINARY(
	IIsSchema *pSchema,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject
    )
{
    DWORD dwStatus = 0;
    DWORD dwAttribute = ALL_METADATA;
    DWORD dwUserType = ALL_METADATA;
    LPBYTE pBuffer = NULL;

    pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwUserType);

    pMetaDataRec->dwMDIdentifier = dwMetaId;
    pMetaDataRec->dwMDAttributes = dwAttribute;
    pMetaDataRec->dwMDUserType = dwUserType;
    pMetaDataRec->dwMDDataType = BINARY_METADATA;
    pMetaDataRec->dwMDDataLen = 0;

    pBuffer = (LPBYTE) AllocADsMem(
                    lpIISObject->IISValue.value_5.Length);

    if (!pBuffer) {
        return(pMetaDataRec);
    }

    memcpy(pBuffer,
           lpIISObject->IISValue.value_5.Binary,
           lpIISObject->IISValue.value_5.Length);

    pMetaDataRec->pbMDData = (LPBYTE)pBuffer;
    pMetaDataRec->dwMDDataLen = lpIISObject->IISValue.value_5.Length;

    return(pMetaDataRec);
}

PMETADATA_RECORD
CopyIISSynIdMIMEMAP_To_IISMIMEMAP(
	IIsSchema *pSchema,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject,
    DWORD dwNumValues
    )
{
    DWORD dwStatus = 0;
    DWORD i;
    DWORD dwAttribute = ALL_METADATA;
    DWORD dwUserType = ALL_METADATA;
    LPWSTR pszData = NULL;
    LPWSTR pszStr = NULL;

    pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwUserType);

    pMetaDataRec->dwMDIdentifier = dwMetaId;
    pMetaDataRec->dwMDAttributes = dwAttribute;
    pMetaDataRec->dwMDUserType = dwUserType;
    pMetaDataRec->dwMDDataType = MULTISZ_METADATA;
    pMetaDataRec->dwMDDataLen = 0;

    //
    // Calculate buffer length to allocate
    //

    for (i = 0; i < dwNumValues; i++) {
        pszData = (LPWSTR)lpIISObject[i].IISValue.value_4.MultiSz;
        pMetaDataRec->dwMDDataLen += (wcslen(pszData) + 1)*2;
    }

    //
    // +2 for the extra null terminator
    //

    pszStr = (LPWSTR) AllocADsMem(pMetaDataRec->dwMDDataLen + 2);

    if (pszStr == NULL) {
        return(pMetaDataRec);
    }

    //
    // empty contents
    //

    wcscpy(pszStr, L"");

    pMetaDataRec->pbMDData = (LPBYTE)pszStr;

    for (i = 0; i < dwNumValues; i++) {

        pszData = (LPWSTR)lpIISObject[i].IISValue.value_4.MultiSz;
        wcscat(pszStr, pszData);
        pszStr += wcslen(pszData);
        *pszStr = L'\0';
        pszStr++;

    }

    *pszStr = L'\0';
    pMetaDataRec->dwMDDataLen += 2;

    return(pMetaDataRec);
}

PMETADATA_RECORD
CopyIISSynIdBOOL_To_IISBOOL(
	IIsSchema *pSchema,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject
    )
{
    DWORD dwAttribute = ALL_METADATA;
    DWORD dwUserType = ALL_METADATA;

    pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwUserType);

    pMetaDataRec->dwMDIdentifier = dwMetaId;
    pMetaDataRec->dwMDAttributes = dwAttribute;
    pMetaDataRec->dwMDUserType = dwUserType;
    pMetaDataRec->dwMDDataType = DWORD_METADATA;
    pMetaDataRec->dwMDDataLen = sizeof(DWORD);
    pMetaDataRec->pbMDData = (LPBYTE)&(lpIISObject->IISValue.value_1.dwDWORD);

    return(pMetaDataRec);

}


PMETADATA_RECORD
CopyIISSynIdToIIS(
	IIsSchema *pSchema,
    DWORD dwSyntaxId,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject,
    DWORD dwNumValues
    )
{
    switch (dwSyntaxId) {
    case IIS_SYNTAX_ID_DWORD:
        pMetaDataRec = CopyIISSynIdDWORD_To_IISDWORD(
						 pSchema,
                         dwMetaId,
                         pMetaDataRec,
                         lpIISObject
                         );
        break;

    case IIS_SYNTAX_ID_STRING:
        pMetaDataRec = CopyIISSynIdSTRING_To_IISSTRING(
						 pSchema,
                         dwMetaId,
                         pMetaDataRec,
                         lpIISObject
                         );
        break;

    case IIS_SYNTAX_ID_EXPANDSZ:
        pMetaDataRec = CopyIISSynIdEXPANDSZ_To_IISEXPANDSZ(
						 pSchema,
                         dwMetaId,
                         pMetaDataRec,
                         lpIISObject
                         );
        break;

    case IIS_SYNTAX_ID_MULTISZ:
        pMetaDataRec = CopyIISSynIdMULTISZ_To_IISMULTISZ(
						 pSchema,
                         dwMetaId,
                         pMetaDataRec,
                         lpIISObject,
                         dwNumValues
                         );
        break;

    case IIS_SYNTAX_ID_BINARY:
    case IIS_SYNTAX_ID_IPSECLIST:
    case IIS_SYNTAX_ID_NTACL:
        pMetaDataRec = CopyIISSynIdBINARY_To_IISBINARY(
						 pSchema,
                         dwMetaId,
                         pMetaDataRec,
                         lpIISObject
                         );
        break;

    case IIS_SYNTAX_ID_MIMEMAP:
        pMetaDataRec = CopyIISSynIdMIMEMAP_To_IISMIMEMAP(
						 pSchema,
                         dwMetaId,
                         pMetaDataRec,
                         lpIISObject,
                         dwNumValues
                         );
        break;

    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
        pMetaDataRec = CopyIISSynIdBOOL_To_IISBOOL(
						 pSchema,
                         dwMetaId,
                         pMetaDataRec,
                         lpIISObject
                         );
        break;

    default:
        break;

    }

    return(pMetaDataRec);
}


HRESULT
MarshallIISSynIdToIIS(
	IIsSchema *pSchema,
    DWORD dwSyntaxId,
    DWORD dwMDIdentifier,
    PIISOBJECT pIISObject,
    DWORD dwNumValues,
    PMETADATA_RECORD pMetaDataRecord
    )
{
    CopyIISSynIdToIIS(
			pSchema,
             dwSyntaxId,
             dwMDIdentifier,
             pMetaDataRecord,
             pIISObject,
             dwNumValues
             );

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\iisres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       iisres.h
//
//  Contents:   IIS provider ID
//
//  Functions:
//
//----------------------------------------------------------------------------
#define IIS_PROVIDER_ID    1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\iissynid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       iissynid.h
//
//  Contents:   IIS syntax id
//
//  Functions:
//
//----------------------------------------------------------------------------

#define     IIS_SYNTAX_ID_DWORD         1
#define     IIS_SYNTAX_ID_STRING        2
#define     IIS_SYNTAX_ID_EXPANDSZ      3
#define     IIS_SYNTAX_ID_MULTISZ       4
#define     IIS_SYNTAX_ID_BINARY        5
#define	    IIS_SYNTAX_ID_BOOL          6
#define	    IIS_SYNTAX_ID_BOOL_BITMASK  7
#define	    IIS_SYNTAX_ID_MIMEMAP       8
#define		IIS_SYNTAX_ID_IPSECLIST		9
#define		IIS_SYNTAX_ID_NTACL  		10
#define		IIS_SYNTAX_ID_HTTPERRORS	11
#define		IIS_SYNTAX_ID_HTTPHEADERS	12

//
// special type used for propertyobjprops[]
//
#define		IIS_SYNTAX_ID_STRING_DWORD  13
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\iistypes.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       iistypes.h
//
//  Contents:   IIS syntax type structure
//
//  Functions:
//
//----------------------------------------------------------------------------

#ifndef __IISTYPES_HXX
#define __IISTYPES_HXX

typedef struct
{
    DWORD dwDWORD;

} IIS_SYNTAX_DWORD, * LPIIS_SYNTAX_DWORD;

typedef struct
{
    LPWSTR String;

} IIS_SYNTAX_STRING, * LPIIS_SYNTAX_STRING;

typedef struct
{
    LPWSTR ExpandSz;

} IIS_SYNTAX_EXPANDSZ, * LPIIS_SYNTAX_EXPANDSZ;

typedef struct
{
    LPWSTR MultiSz;

} IIS_SYNTAX_MULTISZ, * LPIIS_SYNTAX_MULTISZ;

typedef struct
{
    DWORD Length;
    LPBYTE Binary;

} IIS_SYNTAX_BINARY, * LPIIS_SYNTAX_BINARY;

typedef struct
{
    LPWSTR MimeMap;

} IIS_SYNTAX_MIMEMAP, * LPIIS_SYNTAX_MIMEMAP;

typedef struct _iistype{
    DWORD IISType;
    union {
        IIS_SYNTAX_DWORD value_1;
        IIS_SYNTAX_STRING value_2;
        IIS_SYNTAX_EXPANDSZ value_3;
        IIS_SYNTAX_MULTISZ value_4;
        IIS_SYNTAX_BINARY value_5;
        IIS_SYNTAX_MIMEMAP value_6;
    }IISValue;
} IISOBJECT, *PIISOBJECT, *LPIISOBJECT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for adsiis.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

HINSTANCE g_hInst = NULL;
WCHAR * szIISPrefix = L"@IIS!";

STDAPI
DllRegisterServerWin95(VOID);
STDAPI
DllUnregisterServerWin95(VOID);

//
//  Global Data
//

WIN32_CRITSEC * g_pGlobalLock = NULL;
SERVER_CACHE * g_pServerCache = NULL;

extern CRITICAL_SECTION  g_ExtCritSect;

extern PCLASS_ENTRY gpClassHead;

DECLARE_DEBUG_PRINTS_OBJECT()
#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#endif

//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    WCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(L"IIS",L"heapInfoLevel", L"00000003", awcs,MAXINFOLEN))
        heapInfoLevel = wcstoul(awcs, NULL, 16);

    if (GetProfileString(L"IIS",L"Ot", L"00000003", awcs, MAXINFOLEN))
        OtInfoLevel = wcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(L"IIS",L"ADsInfoLevel", L"00000003", awcs,MAXINFOLEN))
        ADsInfoLevel = wcstoul(awcs, NULL, 16);
#endif
}

//  Globals


ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll


//+------------------------------------------------------------------------
//
//  Macro that calculates the number of elements in a statically-defined
//  array.
//
//  Note - I swiped this from ADsary.cxx - A type-safe array class. Remember
//  to swipe the whole thing as required.
//-------------------------------------------------------------------------
#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))

CIISProviderCF               g_cfProvider;
CIISNamespaceCF              g_cfNamespace;
CIISMimeTypeCF               g_cfMimeType;
CIISPropertyAttributeCF      g_cfPropertyAttribute;


//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};



CLSCACHE g_aclscache[] =
{
    &CLSID_IISProvider,                        &g_cfProvider,
    &CLSID_IISNamespace,                       &g_cfNamespace,
    &CLSID_IISMimeType,                        &g_cfMimeType,
    &CLSID_IISPropertyAttribute,               &g_cfPropertyAttribute
};


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been called with an unknown CLSID.
    //

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInst);
        g_pGlobalLock = new WIN32_CRITSEC();
        g_pServerCache = new SERVER_CACHE();

        g_hInst = hInst;


#if DBG==1
#ifndef MSVC
        INITIALIZE_CRITICAL_SECTION(&g_csOT);
        INITIALIZE_CRITICAL_SECTION(&g_csMem);
#endif
        INITIALIZE_CRITICAL_SECTION(&g_csDP);
#endif

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT("adsiis");
        SET_DEBUG_FLAGS(DEBUG_ERROR);
#endif

        InitializeCriticalSection(&g_ExtCritSect);

        gpClassHead = BuildClassesList();
        break;


    case DLL_PROCESS_DETACH:

#ifdef _NO_TRACING_
        DELETE_DEBUG_PRINT_OBJECT();
#endif

        //
        // free global list of class entries for 3rd party ext
        //

        FreeClassesList(gpClassHead);

        DeleteCriticalSection(&g_ExtCritSect);

        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsidIndex
//
//  Synopsis:   Returns the index of the given CLSID in the cache, or
//              -1 if the CLSID is not present in the cache
//
//  Arguments:  [clsid]
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetCachedClsidIndex(REFCLSID clsid)
{
    int             i;
    CLSCACHE *      pclscache;

    for (i = 0, pclscache = g_aclscache;
         i < ARRAY_SIZE(g_aclscache);
         i ++, pclscache++)
    {
        if (IsEqualCLSID(*pclscache->pclsid, clsid))
            return i;
    }

    return -1;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClassFactory
//
//  Synopsis:   Returns the cached class factory with the given index.
//              The pointer returned has been AddRef'd.
//
//  Arguments:  [iclsid]
//
//  Returns:    IClassFactory *
//
//-------------------------------------------------------------------------

IClassFactory *
GetCachedClassFactory(int iclsid)
{
    IClassFactory * pCF;

    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    pCF = g_aclscache[iclsid].pCF;
    pCF->AddRef();

    return pCF;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsid
//
//  Synopsis:   Returns the CLSID corresponding to the given index.
//              Normally, code should call GetCachedClassFactory to get
//              the class factory directly.
//
//  Arguments:  [iclsid]    --  Clsid index
//              [pclsid]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

void
GetCachedClsid(int iclsid, CLSID * pclsid)
{
    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    *pclsid = *g_aclscache[iclsid].pclsid;
}


//+------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Register registry keys for adsiis
//
//  Arguments:  None
//
//-------------------------------------------------------------------------

STDAPI DllRegisterServer(
    )
{
    HKEY hKeyCLSID, hKeyTemp;
    DWORD dwDisposition;
    HMODULE hModule;
    HRESULT hr;
    ITypeLib   *pITypeLib;
    WCHAR pszName[MAX_PATH +1];
    int i;

    if ( IISGetPlatformType() == PtWindows95 ) {
        return(DllRegisterServerWin95());
    }

    hModule=GetModuleHandle(TEXT("ADSIIS.DLL"));

    if (!hModule) {
            return E_UNEXPECTED;
            }

    if (GetModuleFileName(hModule, pszName, MAX_PATH+1)==0) {
            return E_UNEXPECTED;
            }

    hr=LoadTypeLibEx(pszName, REGKIND_REGISTER, &pITypeLib);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }

    pITypeLib->Release();

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISNamespace"),
                      sizeof(TEXT("IISNamespace")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISNamespace\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{d6bfa35e-89f2-11d0-8527-00c04fd8d503}"),
                      sizeof(TEXT("{d6bfa35e-89f2-11d0-8527-00c04fd8d503}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS Namespace Object"),
                      sizeof(TEXT("IIS Namespace Object")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("adsiis.dll"),
                      sizeof(TEXT("adsiis.dll")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISNamespace"),
                      sizeof(TEXT("IISNamespace")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{49d704a0-89f7-11d0-8527-00c04fd8d503}"),
                      sizeof(TEXT("{49d704a0-89f7-11d0-8527-00c04fd8d503}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IIS\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{d88966de-89f2-11d0-8527-00c04fd8d503}"),
                      sizeof(TEXT("{d88966de-89f2-11d0-8527-00c04fd8d503}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS Provider Object"),
                      sizeof(TEXT("IIS Provider Object")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("adsiis.dll"),
                      sizeof(TEXT("adsiis.dll")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS"),
                      sizeof(TEXT("IIS")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{49d704a0-89f7-11d0-8527-00c04fd8d503}"),
                      sizeof(TEXT("{49d704a0-89f7-11d0-8527-00c04fd8d503}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("Mimemap\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{9036b028-a780-11d0-9b3d-0080c710ef95}"),
                      sizeof(TEXT("{9036b028-a780-11d0-9b3d-0080c710ef95}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS Mimemap Object"),
                      sizeof(TEXT("IIS Mimemap Object")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("adsiis.dll"),
                      sizeof(TEXT("adsiis.dll")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISMimemap"),
                      sizeof(TEXT("IISMimemap")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{49d704a0-89f7-11d0-8527-00c04fd8d503}"),
                      sizeof(TEXT("{49d704a0-89f7-11d0-8527-00c04fd8d503}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "PropertyAttribute\\CLSID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{FD2280A8-51A4-11D2-A601-3078302C2030}",
                      sizeof("{FD2280A8-51A4-11D2-A601-3078302C2030}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "CLSID\\{FD2280A8-51A4-11D2-A601-3078302C2030}",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyCLSID, "", NULL, REG_SZ,
                      (BYTE*) "IIS PropertyAttribute Object",
                      sizeof("IIS PropertyAttribute Object"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyExA(hKeyCLSID,
                       "InprocServer32",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "adsiis.dll",
                      sizeof("adsiis.dll"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "ThreadingModel", NULL, REG_SZ,
                      (BYTE*) "Both",
                      sizeof("Both"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "ProgID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "IISPropertyAttribute",
                      sizeof("IISPropertyAttribute"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "TypeLib",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{49d704a0-89f7-11d0-8527-00c04fd8d503}",
                      sizeof("{49d704a0-89f7-11d0-8527-00c04fd8d503}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "Version",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "0.0",
                      sizeof("0.0"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);


    return NOERROR;
}

//+------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Register registry keys for adsiis
//
//  Arguments:  None
//
//+------------------------------------------------------------------------
/* #pragma INTRINSA suppress=all */
STDAPI DllUnregisterServer(void) {

    if ( IISGetPlatformType() == PtWindows95 ) {
        return(DllUnregisterServerWin95());
    }

    UnRegisterTypeLib(LIBID_IISOle,
                      1,
                      0,
                      0,
                      SYS_WIN32);

    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISNamespace\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISNamespace"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IIS\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IIS"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Mimemap\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Mimemap"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("PropertyAttribute\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("PropertyAttribute"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{FD2280A8-51A4-11D2-A601-3078302C2030}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{FD2280A8-51A4-11D2-A601-3078302C2030}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{FD2280A8-51A4-11D2-A601-3078302C2030}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{FD2280A8-51A4-11D2-A601-3078302C2030}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{FD2280A8-51A4-11D2-A601-3078302C2030}"));

    return NOERROR;
}



//+------------------------------------------------------------------------
//
//  Function:   DllRegisterServerWin95
//
//  Synopsis:   Register registry keys for adsiis on win95
//
//  Arguments:  None
//
//-------------------------------------------------------------------------

STDAPI
DllRegisterServerWin95(
    )
{
    HKEY hKeyCLSID, hKeyTemp;
    DWORD dwDisposition;
    HMODULE hModule;
    HRESULT hr;
    ITypeLib   *pITypeLib;
    WCHAR pszName[MAX_PATH +1];
    CHAR pszNameA[MAX_PATH +1];
    int i;

    hModule=GetModuleHandleA("ADSIIS.DLL");
    if (!hModule) {
            return E_UNEXPECTED;
            }

    if (GetModuleFileNameA(hModule, pszNameA, MAX_PATH+1)==0) {
            return E_UNEXPECTED;
            }

    swprintf(pszName, OLESTR("%S"), pszNameA);

    hr=LoadTypeLibEx(pszName, REGKIND_REGISTER, &pITypeLib);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }

    pITypeLib->Release();

    if (RegCreateKeyExA(HKEY_LOCAL_MACHINE,
                       "Software\\Microsoft\\ADs\\Providers\\IIS",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "IISNamespace",
                      sizeof("IISNamespace"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "IISNamespace\\CLSID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{d6bfa35e-89f2-11d0-8527-00c04fd8d503}",
                      sizeof("{d6bfa35e-89f2-11d0-8527-00c04fd8d503}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register CLSID
    //

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyCLSID, "", NULL, REG_SZ,
                      (BYTE*) "IIS Namespace Object",
                      sizeof("IIS Namespace Object"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyExA(hKeyCLSID,
                       "InprocServer32",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "adsiis.dll",
                      sizeof("adsiis.dll"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "ThreadingModel", NULL, REG_SZ,
                      (BYTE*) "Both",
                      sizeof("Both"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "ProgID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "IISNamespace",
                      sizeof("IISNamespace"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "TypeLib",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{49d704a0-89f7-11d0-8527-00c04fd8d503}",
                      sizeof("{49d704a0-89f7-11d0-8527-00c04fd8d503}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "Version",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "0.0",
                      sizeof("0.0"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "IIS\\CLSID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{d88966de-89f2-11d0-8527-00c04fd8d503}",
                      sizeof("{d88966de-89f2-11d0-8527-00c04fd8d503}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyCLSID, "", NULL, REG_SZ,
                      (BYTE*) "IIS Provider Object",
                      sizeof("IIS Provider Object"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyExA(hKeyCLSID,
                       "InprocServer32",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "adsiis.dll",
                      sizeof("adsiis.dll"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "ThreadingModel", NULL, REG_SZ,
                      (BYTE*) "Both",
                      sizeof("Both"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "ProgID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "IIS",
                      sizeof("IIS"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "TypeLib",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{49d704a0-89f7-11d0-8527-00c04fd8d503}",
                      sizeof("{49d704a0-89f7-11d0-8527-00c04fd8d503}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "Version",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "0.0",
                      sizeof("0.0"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "Mimemap\\CLSID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{9036b028-a780-11d0-9b3d-0080c710ef95}",
                      sizeof("{9036b028-a780-11d0-9b3d-0080c710ef95}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyCLSID, "", NULL, REG_SZ,
                      (BYTE*) "IIS Mimemap Object",
                      sizeof("IIS Mimemap Object"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyExA(hKeyCLSID,
                       "InprocServer32",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "adsiis.dll",
                      sizeof("adsiis.dll"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "ThreadingModel", NULL, REG_SZ,
                      (BYTE*) "Both",
                      sizeof("Both"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "ProgID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "IISMimemap",
                      sizeof("IISMimemap"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "TypeLib",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{49d704a0-89f7-11d0-8527-00c04fd8d503}",
                      sizeof("{49d704a0-89f7-11d0-8527-00c04fd8d503}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "Version",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "0.0",
                      sizeof("0.0"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    return NOERROR;
}

//+------------------------------------------------------------------------
//
//  Function:   DllUnregisterServerWin95
//
//  Synopsis:   Register registry keys for adsiis on win95
//
//  Arguments:  None
//
//+------------------------------------------------------------------------
/* #pragma INTRINSA suppress=all */
STDAPI
DllUnregisterServerWin95(void) {

    UnRegisterTypeLib(LIBID_IISOle,
                      1,
                      0,
                      0,
                      SYS_WIN32);

    RegDeleteKeyA(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\ADs\\Providers\\IIS");

    RegDeleteKeyA(HKEY_CLASSES_ROOT, "IISNamespace\\CLSID");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "IISNamespace");

    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\InprocServer32");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\ProgID");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\TypeLib");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\Version");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}");

    RegDeleteKeyA(HKEY_CLASSES_ROOT, "IIS\\CLSID");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "IIS");

    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\InprocServer32");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\ProgID");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\TypeLib");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\Version");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}");

    RegDeleteKeyA(HKEY_CLASSES_ROOT, "Mimemap\\CLSID");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "Mimemap");

    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\InprocServer32");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\ProgID");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\TypeLib");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\Version");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}");


    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\imaps.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    IMAPS.h

    This file contains constants & type definitions shared between the
    IMAP Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.
        Ahalim      Added K2 support (6/17/97).

*/


#ifndef _IMAPS_H_
#define _IMAPS_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus


///////////////////////////////////////////////////////////////////////////////////////
// 
//  IMAP Metabase Properties
//

//  
// Metabase path: /LM/ImapSvc
//
#define IIS_MD_IMAP_SERVICE_BASE            (IMAP_MD_ID_BEGIN_RESERVED + 500)
#define MD_IMAP_SERVICE_VERSION             (IIS_MD_IMAP_SERVICE_BASE + 0)
#define MD_IMAP_UPDATED_DEFAULT_DOMAIN      (IIS_MD_IMAP_SERVICE_BASE + 1)
/*
Standard properties used here:
MD_CONNECTION_TIMEOUT
MD_MAX_CONNECTION
MD_SERVER_COMMENT
MD_SERVER_AUTOSTART
MD_SERVER_SIZE
MD_SERVER_LISTEN_BACKLOG
MD_SERVER_BINDINGS
MD_SECURE_PORT
MD_LOGON_METHOD
MD_AUTHORIZATION
MD_LOG_TYPE
MD_LOGFILE_DIRECTORY
MD_LOGFILE_PERIOD
MD_LOGFILE_TRUNCATE_SIZE
MD_NTAUTHENTICATION_PROVIDERS
*/


//
// Metabase path: /LM/ImapSvc/<inst#>/Root/<vroot>
//
#define IIS_MD_IMAP_BASE                    (IMAP_MD_ID_BEGIN_RESERVED)
#define MD_IMAP_EXPIRE_MAIL                 (IIS_MD_IMAP_BASE + 0)
#define MD_IMAP_EXPIRE_MSG_HOURS            (IIS_MD_IMAP_BASE + 1)
/*
Standard properties used here:
MD_VR_PATH
MD_VR_USERNAME
MD_VR_PASSWORD
*/

//  
// Metabase path: /LM/ImapSvc/<inst#>
//
#define IIS_MD_IMAP_PARAMS_BASE             (IMAP_MD_ID_BEGIN_RESERVED + 200)
#define MD_IMAP_CMD_LOG_FLAGS               (IIS_MD_IMAP_PARAMS_BASE + 0)
#define MD_IMAP_NO_TRANSMITFILES            (IIS_MD_IMAP_PARAMS_BASE + 1)
#define MD_IMAP_STATIC_BUFFER_SIZE          (IIS_MD_IMAP_PARAMS_BASE + 2)
#define MD_IMAP_FILE_IO_BUFFER_SIZE         (IIS_MD_IMAP_PARAMS_BASE + 3)
#define MD_IMAP_MAX_OUTSTANDING_IO          (IIS_MD_IMAP_PARAMS_BASE + 4)
#define MD_IMAP_SHARING_RETRY_ATTEMPTS      (IIS_MD_IMAP_PARAMS_BASE + 5)
#define MD_IMAP_SHARING_RETRY_SLEEP         (IIS_MD_IMAP_PARAMS_BASE + 6)
#define MD_IMAP_MSGS_PER_MAILBAG            (IIS_MD_IMAP_PARAMS_BASE + 7)
#define MD_IMAP_BUFFERED_WRITES             (IIS_MD_IMAP_PARAMS_BASE + 9)
#define MD_IMAP_SEND_BUFFER_SIZE            (IIS_MD_IMAP_PARAMS_BASE + 10)
#define MD_IMAP_RECV_BUFFER_SIZE            (IIS_MD_IMAP_PARAMS_BASE + 11)
#define MD_IMAP_MAX_NUM_CONNECTIONS         (IIS_MD_IMAP_PARAMS_BASE + 12)
#define MD_IMAP_MAX_MAILBAG_INSTANCES       (IIS_MD_IMAP_PARAMS_BASE + 13)
#define MD_IMAP_ROUTING_SOURCE              (IIS_MD_IMAP_PARAMS_BASE + 14)
#define MD_IMAP_INFO_MAX_ERRORS             (IIS_MD_IMAP_PARAMS_BASE + 15)
#define MD_IMAP_DEFAULT_DOMAIN_VALUE        (IIS_MD_IMAP_PARAMS_BASE + 16)
#define MD_IMAP_ROUTING_DLL                 (IIS_MD_IMAP_PARAMS_BASE + 17)      
#define MD_IMAP_EXPIRE_DELAY                (IIS_MD_IMAP_PARAMS_BASE + 18)
#define MD_IMAP_EXPIRE_START                (IIS_MD_IMAP_PARAMS_BASE + 19)
#define MD_IMAP_EXPIRE_DIRS_MAX             (IIS_MD_IMAP_PARAMS_BASE + 20)
#define MD_IMAP_EXPIRE_INSTANCE_MAIL        (IIS_MD_IMAP_PARAMS_BASE + 21)
#define MD_IMAP_QUERY_IDQ_PATH              (IIS_MD_IMAP_PARAMS_BASE + 22)
#define MD_IMAP_CLEARTEXT_AUTH_PROVIDER     (IIS_MD_IMAP_PARAMS_BASE + 23)
#define MD_IMAP_DS_TYPE                     (IIS_MD_IMAP_PARAMS_BASE + 24)
#define MD_IMAP_DS_DATA_DIRECTORY           (IIS_MD_IMAP_PARAMS_BASE + 25)
#define MD_IMAP_DS_DEFAULT_MAIL_ROOT        (IIS_MD_IMAP_PARAMS_BASE + 26)
#define MD_IMAP_DS_BIND_TYPE                (IIS_MD_IMAP_PARAMS_BASE + 27)
#define MD_IMAP_DS_SCHEMA_TYPE              (IIS_MD_IMAP_PARAMS_BASE + 28)
#define MD_IMAP_DS_HOST                     (IIS_MD_IMAP_PARAMS_BASE + 29)
#define MD_IMAP_DS_NAMING_CONTEXT           (IIS_MD_IMAP_PARAMS_BASE + 30)
#define MD_IMAP_DS_ACCOUNT                  (IIS_MD_IMAP_PARAMS_BASE + 31)
#define MD_IMAP_DS_PASSWORD                 (IIS_MD_IMAP_PARAMS_BASE + 32)
#define MD_IMAP_DS_MAX_RESOLVE_BUFFERS      (IIS_MD_IMAP_PARAMS_BASE + 33)
#define MD_IMAP_DS_MAX_VIRTUAL_SERVERS      (IIS_MD_IMAP_PARAMS_BASE + 34)
#define MD_IMAP_DS_MAX_HANDLE_CACHE_ENTRIES (IIS_MD_IMAP_PARAMS_BASE + 35)
#define MD_IMAP_DS_SORT_THRESHOLD           (IIS_MD_IMAP_PARAMS_BASE + 36)

#ifdef __cplusplus
}
#endif  // _cplusplus

#endif  // _IMAPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\object.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:  object.cxx
//
//  Contents:  ADSI object type code
//
//  History:
//----------------------------------------------------------------------------

#include "iis.hxx"
#pragma hdrstop

ObjectTypeList::ObjectTypeList()
{
    _pObjList = NULL;
    _dwCurrentIndex = 0;
    _dwMaxElements = 0;
    _dwUBound  = 0;
    _dwLBound = 0;

}


HRESULT
ObjectTypeList::CreateObjectTypeList(
    VARIANT vFilter,
    ObjectTypeList ** ppObjectTypeList
    )
{
    ObjectTypeList * pObjectTypeList = NULL;
    HRESULT hr = S_OK;

    pObjectTypeList = new ObjectTypeList;

    if (!pObjectTypeList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildObjectArray(
            vFilter,
            &pObjectTypeList->_pObjList,
            &pObjectTypeList->_dwMaxElements
            );

    if (FAILED(hr)) {

        hr = BuildDefaultObjectArray(
                gpFilters,
                gdwMaxFilters,
                &pObjectTypeList->_pObjList,
                &pObjectTypeList->_dwMaxElements
                );

        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetUBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetLBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwLBound
                );
    BAIL_ON_FAILURE(hr);

    pObjectTypeList->_dwCurrentIndex = pObjectTypeList->_dwLBound;

    *ppObjectTypeList = pObjectTypeList;

    RRETURN(S_OK);


error:
    if (pObjectTypeList) {
        delete pObjectTypeList;
    }
    RRETURN(hr);

}


ObjectTypeList::~ObjectTypeList()
{
    HRESULT hr = S_OK;
    if (_pObjList) {
        hr = SafeArrayDestroy(_pObjList);
    }
}


HRESULT
ObjectTypeList::GetCurrentObject(
    PDWORD pdwObject
    )
{
    HRESULT hr = S_OK;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    hr = SafeArrayGetElement(
                    _pObjList,
                    (long FAR *)&_dwCurrentIndex,
                    (void *)pdwObject
                    );
    RRETURN(hr);
}

HRESULT
ObjectTypeList::Next()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex++;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    return(hr);
}



HRESULT
ObjectTypeList::Reset()
{
    HRESULT hr = S_OK;

    return(hr);

}


HRESULT
IsValidFilter(
    LPWSTR ObjectName,
    DWORD *pdwFilterId,
    PFILTERS pFilters,
    DWORD dwMaxFilters
    )
{

    DWORD i = 0;

    for (i = 0; i < dwMaxFilters; i++) {

        if (!_wcsicmp(ObjectName, (pFilters + i)->szObjectName)) {
            *pdwFilterId = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }

    }
    *pdwFilterId = 0;
    RRETURN(E_FAIL);
}



HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;

    sabNewArray.cElements = dwMaxFilters;
    sabNewArray.lLbound =  0;

    pFilter =   SafeArrayCreate(
                        VT_I4,
                        1,
                        &sabNewArray
                        );
    if (!pFilter){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwMaxFilters; i++) {

        hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&((pFilters + i)->dwFilterId)
            );
        BAIL_ON_FAILURE(hr);
    }

    *ppFilter = pFilter;
    *pdwNumElements = dwMaxFilters;

    RRETURN(S_OK);

error:
    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}



HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    VARIANT varDest;
    LONG i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    DWORD dwFilterId;
    SAFEARRAY * pFilter = NULL;

    if(!((V_VT(&var) &  VT_VARIANT) &&  V_ISARRAY(&var))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    sabNewArray.cElements = dwSUBound - dwSLBound + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_I4,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        hr = IsValidFilter(
                V_BSTR(&v),
                &dwFilterId,
                gpFilters,
                gdwMaxFilters
                );

        if (FAILED(hr)) {

            VariantClear(&v);
            continue;
        }

        VariantClear(&v);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&uDestCount,
                (void *)&dwFilterId
                );

        if(FAILED(hr)){
            continue;
        }

        uDestCount++;

    }

    //
    // There was nothing of value that could be retrieved from the
    // filter.
    //

    if (!uDestCount ) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    *pdwNumElements  = uDestCount;
    *ppFilter = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {

        SafeArrayDestroy(pFilter);
    }
    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\iisurshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       iisurshl.cxx
//
//  Contents:   IIS unmarshalling code
//
//  Functions:
//
//  History:      01-Mar-97   SophiaC   Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"



HRESULT
IISTypeInit(
    PIISOBJECT pIISType
    )
{
    memset(pIISType, 0, sizeof(IISOBJECT));

    RRETURN(S_OK);
}


LPBYTE
CopyIISDWORD_To_IISSynIdDWORD(
    LPBYTE lpByte,
    PIISOBJECT lpIISObject
    )
{
    lpIISObject->IISType = IIS_SYNTAX_ID_DWORD;

    lpIISObject->IISValue.value_1.dwDWORD = *(DWORD UNALIGNED *)lpByte;


    return(lpByte);
}

LPBYTE
CopyIISSTRING_To_IISSynIdSTRING(
    LPBYTE lpByte,
    PIISOBJECT lpIISObject
    )
{
    DWORD dwStatus = 0;

    lpIISObject->IISType = IIS_SYNTAX_ID_STRING;

    lpIISObject->IISValue.value_2.String =
            (LPWSTR)AllocADsStr((LPWSTR)lpByte);

    return(lpByte);
}


LPBYTE
CopyIISEXPANDSZ_To_IISSynIdEXPANDSZ(
    LPBYTE lpByte,
    PIISOBJECT lpIISObject
    )
{
    DWORD dwStatus = 0;

    lpIISObject->IISType = IIS_SYNTAX_ID_EXPANDSZ;

    lpIISObject->IISValue.value_3.ExpandSz =
            (LPWSTR)AllocADsStr((LPWSTR)lpByte);

    return(lpByte);
}

LPBYTE
CopyIISMULTISZ_To_IISSynIdMULTISZ(
    LPBYTE lpByte,
    PIISOBJECT lpIISObject,
    DWORD dwNumValues
    )
{
    DWORD dwStatus = 0;
    LPWSTR pszCurrPosition = NULL;
    DWORD i;

    //
    // scan multi-sz string and store each string in an IISObject object
    //

    pszCurrPosition = (LPWSTR) lpByte;

    for (i = 0; i < dwNumValues; i++) {

        //
        // copy each string to IISObject structure
        //

        lpIISObject[i].IISType = IIS_SYNTAX_ID_MULTISZ;

        lpIISObject[i].IISValue.value_4.MultiSz =
                    (LPWSTR)AllocADsStr((LPWSTR)pszCurrPosition);

        while (*pszCurrPosition != L'\0') {
            pszCurrPosition++;
        }

        pszCurrPosition++;
    }

    return(lpByte);
}

LPBYTE
CopyIISBINARY_To_IISSynIdBINARY(
    LPBYTE lpByte,
    PIISOBJECT lpIISObject,
    DWORD dwSyntaxId,
    DWORD dwNumValues
    )
{
    LPBYTE pBuffer = NULL;

    lpIISObject->IISType = dwSyntaxId;

    pBuffer = (LPBYTE) AllocADsMem(dwNumValues);
    if (!pBuffer) {
        return(lpByte);
    }

    memcpy(pBuffer, lpByte, dwNumValues);

    lpIISObject->IISValue.value_5.Binary = pBuffer;
    lpIISObject->IISValue.value_5.Length = dwNumValues;

    return(lpByte);
}

LPBYTE
CopyIISMIMEMAP_To_IISSynIdMIMEMAP(
    LPBYTE lpByte,
    PIISOBJECT lpIISObject,
    DWORD dwNumValues
    )
{
    DWORD dwStatus = 0;
    LPWSTR pszUnicode = NULL;
    LPWSTR pszCurrPosition = NULL;
    DWORD i;

    //
    // scan multi-sz string and store each string in an IISObject object
    //

    pszCurrPosition = (LPWSTR) lpByte;

    for (i = 0; i < dwNumValues; i++) {

        //
        // copy each string to IISObject structure
        //

        lpIISObject[i].IISType = IIS_SYNTAX_ID_MIMEMAP;

        lpIISObject[i].IISValue.value_6.MimeMap =
                    (LPWSTR)AllocADsStr((LPWSTR)pszCurrPosition);

        while (*pszCurrPosition != L'\0') {
            pszCurrPosition++;
        }

        pszCurrPosition++;
    }

    return(lpByte);
}

LPBYTE
CopyIISBOOL_To_IISSynIdBOOL(
    LPBYTE lpByte,
    PIISOBJECT lpIISObject,
    DWORD dwSyntaxId
    )
{
    lpIISObject->IISType = dwSyntaxId;

    lpIISObject->IISValue.value_1.dwDWORD = *(PDWORD)lpByte;

    return(lpByte);
}


LPBYTE
CopyIISToIISSynId(
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    LPBYTE pTemp,
    PIISOBJECT lpIISObject
    )
{               
    switch (dwSyntaxId) {
    case IIS_SYNTAX_ID_DWORD:
        pTemp = CopyIISDWORD_To_IISSynIdDWORD(
                         pTemp,
                         lpIISObject
                         );
        break;

    case IIS_SYNTAX_ID_STRING:
        pTemp = CopyIISSTRING_To_IISSynIdSTRING(
                         pTemp,
                         lpIISObject
                         );
        break;

    case IIS_SYNTAX_ID_EXPANDSZ:
        pTemp = CopyIISEXPANDSZ_To_IISSynIdEXPANDSZ(
                         pTemp,
                         lpIISObject
                         );
        break;

    case IIS_SYNTAX_ID_MULTISZ:
        pTemp = CopyIISMULTISZ_To_IISSynIdMULTISZ(
                         pTemp,
                         lpIISObject,
                         dwNumValues
                         );
        break;

    case IIS_SYNTAX_ID_BINARY:
    case IIS_SYNTAX_ID_IPSECLIST:
    case IIS_SYNTAX_ID_NTACL:
        pTemp = CopyIISBINARY_To_IISSynIdBINARY(
                         pTemp,
                         lpIISObject,
                         dwSyntaxId,
                         dwNumValues
                         );
        break;

    case IIS_SYNTAX_ID_MIMEMAP:
        pTemp = CopyIISMIMEMAP_To_IISSynIdMIMEMAP(
                         pTemp,
                         lpIISObject,
                         dwNumValues
                         );
        break;

    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
        pTemp = CopyIISBOOL_To_IISSynIdBOOL(
                         pTemp,
                         lpIISObject,
                         dwSyntaxId
                         );
        break;

    default:
        break;

    }

    return(pTemp);
}


HRESULT
UnMarshallIISToIISSynId(
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    LPBYTE lpByte,
    PIISOBJECT * ppIISObject
    )
{
    DWORD  i = 0;
    PIISOBJECT pIISObject = NULL;

    //
    // For binary type, dwNumValues is the number of bytes
    //

    if (dwSyntaxId == IIS_SYNTAX_ID_BINARY ||
        dwSyntaxId == IIS_SYNTAX_ID_IPSECLIST  ||
        dwSyntaxId == IIS_SYNTAX_ID_NTACL) {
        pIISObject = (PIISOBJECT)AllocADsMem(
                            sizeof(IISOBJECT)
                            );
    }
    else {
        pIISObject = (PIISOBJECT)AllocADsMem(
                            dwNumValues * sizeof(IISOBJECT)
                            );
    }

    if (!pIISObject) {
        RRETURN(E_FAIL);
    }

    lpByte = CopyIISToIISSynId(
                       dwSyntaxId,
                       dwNumValues,
                       lpByte,
                       pIISObject
                       );

    *ppIISObject = pIISObject;

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\parse.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:  parse.cxx
//
//  Contents:  IIS Pathname Parser
//
//    The Pathname Parser is a key component in ADs providers. It checks for
//    syntactic validity of an ADs pathname that has been passed to this
//    provider. If the syntax is valid, then an OBJECTINFO structure is
//    constructed. This OBJECTINFO structure contains a componentized version
//    of the ADs pathname for this object.
//
//    Note all that is being done is a syntax check. Rather than special-case
//    every single new nuance to pathnames, all path checking must conform to
//    the grammar rules laid out by the parser.
//
//
//
//  History:
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

KWDLIST KeywordList[MAX_KEYWORDS] =
{
    { TOKEN_SCHEMA, SCHEMA_CLASS_NAME},
    { TOKEN_CLASS, CLASS_CLASS_NAME },
    { TOKEN_PROPERTY, PROPERTY_CLASS_NAME },
    { TOKEN_SYNTAX, SYNTAX_CLASS_NAME },
};


// Object -> PathName, Type, eos
// Object -> PathName, eos

//+---------------------------------------------------------------------------
//  Function:   ADsObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <ADsObject> -> <ProviderName> <IISObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//----------------------------------------------------------------------------
HRESULT
ADsObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = ProviderName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    pObjectInfo->ObjectType = TOKEN_IISOBJECT;
    pObjectInfo->ComponentArray = NULL;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    switch (dwToken) {

    case TOKEN_END:
        RRETURN(S_OK);

    case TOKEN_COMMA:
        hr = Type(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
        if (dwToken == TOKEN_END) {
            RRETURN(S_OK);
        }else {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    default:
        hr = pTokenizer->PushBackToken();


        hr = IISObject(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        switch (dwToken) {
        case TOKEN_END:
            RRETURN(S_OK);

        case TOKEN_COMMA:
            hr = Type(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);
            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);
            if (dwToken == TOKEN_END) {
                RRETURN(S_OK);
            }else {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

        default:
            RRETURN(E_FAIL);

        }
    }

cleanup:
    RRETURN(hr);

}


//+---------------------------------------------------------------------------
//  Function:   IISObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <IISObject> -> "\\""identifier""\" <IISObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//----------------------------------------------------------------------------

HRESULT
IISObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) &&  (dwToken != TOKEN_BSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) && (dwToken != TOKEN_BSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = AddTreeName(pObjectInfo, szToken);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    //
    // If we get an TOKEN_END, then we have a tree name only \\<tree_name>
    //

    if (dwToken == TOKEN_END || dwToken == TOKEN_COMMA) {
        hr = pTokenizer->PushBackToken();
        RRETURN(S_OK);
    }

    if ((dwToken != TOKEN_BSLASH) && (dwToken != TOKEN_FSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

cleanup:
    RRETURN(hr);
}

HRESULT
ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_ATSIGN) {

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_EXCLAMATION) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else if (dwToken == TOKEN_IDENTIFIER) {

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_COLON) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // You can now disable the processing for "@" and "!" treat them
    // as ordinary characters.
    //

    pTokenizer->SetAtDisabler(TRUE);


    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
HRESULT
PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    HRESULT hr;
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;

    do
    {
        hr = Component(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
    }
    while( (dwToken == TOKEN_BSLASH) || (dwToken == TOKEN_FSLASH) );

    hr = pTokenizer->PushBackToken();
    BAIL_IF_ERROR(hr);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:  Component -> <identifier>
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
HRESULT
Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szValue[MAX_TOKEN_LENGTH];
    WCHAR szComponent[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szComponent, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = AddComponent(pObjectInfo, szComponent, NULL);
    BAIL_IF_ERROR(hr);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
CLexer::CLexer(LPWSTR szBuffer):
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE)
{
    if (!szBuffer || !*szBuffer) {
        return;
    }
    _Buffer = AllocADsStr(szBuffer);
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    FreeADsStr(_Buffer);
}

/*++
    This routine assumes that szToken is a buffer of at least MAX_TOKEN_LENGTH
--*/
HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPDWORD pdwToken)
{
    WCHAR c;
    DWORD state = 0;
    LPWSTR pch = szToken;

    memset(szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH);
    _dwLastTokenLength = 0;
    while (1) {
        c = NextChar();
        switch (state) {
        case  0:
            if (_dwLastTokenLength++ >= MAX_TOKEN_LENGTH) {
                RRETURN(RETURNCODETOHRESULT(ERROR_INVALID_NAME));
            }
            *pch++ = c;

            if (c == L'\\') {
                *pdwToken = TOKEN_BSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'/') {
                *pdwToken = TOKEN_FSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L',') {
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'='){
                *pdwToken = TOKEN_EQUAL;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }
            else if (c == L':'){
                *pdwToken = TOKEN_COLON;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'\0'){
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'@') {

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_ATSIGN;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);

                }else {
                    state = 1;
                }

            }else if (c == L'!'){

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_EXCLAMATION;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else {

                state = 1;
            }
            break;


        case 1:
            if (c == L'\\' || c == L'\0' || c == L',' ||
                    c == L'=' ||
                    c == L':' || c == L'/') {
                PushbackChar();

                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                RRETURN (S_OK);

            }else if (c == L'@' || c == L'!') {

                if (!_bAtDisabled) {

                    PushbackChar();

                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {

                    if (_dwLastTokenLength++ >= MAX_TOKEN_LENGTH) {
                        RRETURN(RETURNCODETOHRESULT(ERROR_INVALID_NAME));
                    }
                    *pch++ = c;
                    state = 1;
                    break;

                }

            }else {
                if (_dwLastTokenLength++ >= MAX_TOKEN_LENGTH) {
                    RRETURN(RETURNCODETOHRESULT(ERROR_INVALID_NAME));
                }
                *pch++ = c;
                state = 1;
                break;
            }

        default:
            RRETURN(RETURNCODETOHRESULT(ERROR_INVALID_NAME));
        }
    }
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
HRESULT
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }
    _ptr -= _dwLastTokenLength;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
BOOL
CLexer::IsKeyword(LPWSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < MAX_KEYWORDS; i++) {
        if (!_wcsicmp(szToken, KeywordList[i].Keyword)) {
            *pdwToken = KeywordList[i].dwTokenId;
            return(TRUE);
        }
    }
    *pdwToken = 0;
    return(FALSE);
}

//+---------------------------------------------------------------------------
//Function:
//
//Synopsis:
//
//Arguments:
//
//Returns:
//
//Modifies:
//
//History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
AddComponent(POBJECTINFO pObjectInfo, LPWSTR szComponent, LPWSTR szValue)
{
    if (!szComponent || !*szComponent) {
        RRETURN(E_FAIL);
    }

    if (pObjectInfo->ComponentArray == NULL) {
        pObjectInfo->ComponentArray =
               (PCOMPONENT) AllocADsMem(sizeof(COMPONENT)*MAXCOMPONENTS);
        pObjectInfo->MaxComponents = MAXCOMPONENTS;
    }
    else if (pObjectInfo->NumComponents == pObjectInfo->MaxComponents) {
        pObjectInfo->ComponentArray =
               (PCOMPONENT) ReallocADsMem(
                                  pObjectInfo->ComponentArray,
                                  sizeof(COMPONENT)*pObjectInfo->MaxComponents,
                                  sizeof(COMPONENT)*(
                                    pObjectInfo->MaxComponents+MAXCOMPONENTS)
                                  );
        pObjectInfo->MaxComponents += MAXCOMPONENTS;
    }

    pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szComponent =
                        AllocADsStr(szComponent);

    if (szValue && *szValue) {
        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szValue =
                        AllocADsStr(szValue);
    }
    else {
        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szValue = NULL;
    }

    pObjectInfo->NumComponents++;

    RRETURN(S_OK);
}

HRESULT
AddProviderName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->ProviderName = AllocADsStr(szToken);

    RRETURN(S_OK);
}


HRESULT
AddTreeName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->TreeName = AllocADsStr(szToken);

    RRETURN(S_OK);
}

HRESULT
AddClassName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    wcscpy(pObjectInfo->ClassName, szToken);

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
SetType(POBJECTINFO pObjectInfo, DWORD dwToken)
{
    pObjectInfo->ObjectType = dwToken;
    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:    Type
//
// Synopsis:    Parses Type-> "user" | "group" etc
//
// Arguments:   [CLexer * pTokenizer]
//              [POBJECTINFo pObjectInfo]
//
// Returns:     HRESULT
//
// Modifies:    -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------


HRESULT
Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_PATH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_IDENTIFIER ) {
        if (pTokenizer->IsKeyword(szToken, &dwToken)) {
            hr = SetType(pObjectInfo, dwToken);
            RRETURN(hr);
        }
        hr = AddClassName(pObjectInfo, szToken);
        RRETURN(hr);
    }

    RRETURN(E_FAIL);

cleanup:
    RRETURN(hr);
}


void
CLexer::SetAtDisabler(
    BOOL bFlag
    )
{
    _bAtDisabled = bFlag;
}

BOOL
CLexer::GetAtDisabler()
{
    return(_bAtDisabled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\macro.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  cmacro.h
//
//  Contents:  Macros for adsi IIS provider
//
//  History:   21-04-97     sophiac    Created.
//
//----------------------------------------------------------------------------
#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                hr = NO_ERROR; \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        DWORD MetaID;                                                 \
                                                                      \
        HRESULT hr = (_pDispMgr->GetIDsOfNames(iid,                   \
                                       rgszNames,                     \
                                       cNames,                        \
                                       lcid,                          \
                                       rgdispid                       \
                                       ));                            \
                                                                      \
                                                                      \
        RRETURN(hr);                                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        HRESULT hr;                                                   \
        WCHAR szPropName[64];                                         \
        BSTR bstrPropName = NULL;                                     \
                                                                      \
		RRETURN (_pDispMgr->Invoke(dispidMember,                     \
                                    iid,                              \
                                    lcid,                             \
                                    wFlags,                           \
                                    pdispparams,                      \
                                    pvarResult,                       \
                                    pexcepinfo,                       \
                                    puArgErr                          \
                                    ));                               \
}
 

#define DEFINE_Simple_IDispatch_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}



#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}


#define CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr)                    \
    if (dwStatus) {                                                   \
        hr = CheckAndSetExtendedError(dwStatus);                      \
        BAIL_ON_FAILURE(hr);                                          \
    }



#define DEFINE_IADs_PutGetUnImplementation(cls)                       \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}


#define DEFINE_IDispatch_ExtMgr_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pExtMgr->GetTypeInfoCount(pctinfo));                 \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pExtMgr->GetTypeInfo(itinfo,                         \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pExtMgr->GetIDsOfNames(iid,                          \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pExtMgr->Invoke(dispidMember,                       \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\pop3s.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    POP3S.h

    This file contains constants & type definitions shared between the
    POP3 Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.

*/
#ifndef _POP3S_H_
#define _POP3S_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus
#if !defined(MIDL_PASS)
#include <winsock.h>
#endif


///////////////////////////////////////////////////////////////////////////////////////
// 
//	POP3 Metabase Properties
//

#define IIS_MD_POP3_SERVICE_BASE			(POP3_MD_ID_BEGIN_RESERVED + 500)
//	
// Metabase path: /LM/Pop3Svc
//
#define MD_POP3_SERVICE_VERSION				(IIS_MD_POP3_SERVICE_BASE + 0)
#define MD_POP3_UPDATED_DEFAULT_DOMAIN		(IIS_MD_POP3_SERVICE_BASE + 2)

/*
Standard properties used here:
MD_CONNECTION_TIMEOUT
MD_MAX_CONNECTION
MD_SERVER_COMMENT
MD_SERVER_AUTOSTART
MD_SERVER_SIZE
MD_SERVER_LISTEN_BACKLOG
MD_SERVER_BINDINGS
MD_SECURE_PORT
MD_LOGON_METHOD
MD_AUTHORIZATION
MD_LOG_TYPE
MD_LOGFILE_DIRECTORY
MD_LOGFILE_PERIOD
MD_LOGFILE_TRUNCATE_SIZE
MD_NTAUTHENTICATION_PROVIDERS
*/


#define IIS_MD_POP3_BASE					(POP3_MD_ID_BEGIN_RESERVED)
//
// Metabase path: /LM/Pop3Svc/<inst#>/Root/<vroot>
//
#define MD_POP3_EXPIRE_MAIL					(IIS_MD_POP3_BASE + 0)
#define MD_POP3_EXPIRE_MSG_HOURS			(IIS_MD_POP3_BASE + 1)
/*
Standard properties used here:
MD_VR_PATH
MD_VR_USERNAME
MD_VR_PASSWORD
*/


//	
// Metabase path: /LM/Pop3Svc/<inst#>/Parameters
//
#define IIS_MD_POP3_PARAMS_BASE             (POP3_MD_ID_BEGIN_RESERVED + 200)
#define MD_POP3_CMD_LOG_FLAGS               (IIS_MD_POP3_PARAMS_BASE + 0)
#define MD_POP3_NO_TRANSMITFILES            (IIS_MD_POP3_PARAMS_BASE + 1)
#define MD_POP3_STATIC_BUFFER_SIZE          (IIS_MD_POP3_PARAMS_BASE + 2)
#define MD_POP3_FILE_IO_BUFFER_SIZE         (IIS_MD_POP3_PARAMS_BASE + 3)
#define MD_POP3_MAX_OUTSTANDING_IO          (IIS_MD_POP3_PARAMS_BASE + 4)
#define MD_POP3_SHARING_RETRY_ATTEMPTS      (IIS_MD_POP3_PARAMS_BASE + 5)
#define MD_POP3_SHARING_RETRY_SLEEP         (IIS_MD_POP3_PARAMS_BASE + 6)
#define MD_POP3_MSGS_PER_MAILBAG            (IIS_MD_POP3_PARAMS_BASE + 7)
#define MD_POP3_BUFFERED_WRITES             (IIS_MD_POP3_PARAMS_BASE + 9)
#define MD_POP3_SEND_BUFFER_SIZE            (IIS_MD_POP3_PARAMS_BASE + 10)
#define MD_POP3_RECV_BUFFER_SIZE            (IIS_MD_POP3_PARAMS_BASE + 11)
#define MD_POP3_MAX_NUM_CONNECTIONS         (IIS_MD_POP3_PARAMS_BASE + 12)
#define MD_POP3_MAX_MAILBAG_INSTANCES       (IIS_MD_POP3_PARAMS_BASE + 13)
#define MD_POP3_ROUTING_SOURCE              (IIS_MD_POP3_PARAMS_BASE + 14)
#define MD_POP3_INFO_MAX_ERRORS             (IIS_MD_POP3_PARAMS_BASE + 15)
#define MD_POP3_DEFAULT_DOMAIN_VALUE        (IIS_MD_POP3_PARAMS_BASE + 16)
#define MD_POP3_ROUTING_DLL                 (IIS_MD_POP3_PARAMS_BASE + 17)
#define MD_POP3_EXPIRE_DELAY                (IIS_MD_POP3_PARAMS_BASE + 18)
#define MD_POP3_EXPIRE_START                (IIS_MD_POP3_PARAMS_BASE + 19)
#define MD_POP3_EXPIRE_DIRS_MAX             (IIS_MD_POP3_PARAMS_BASE + 20)
#define MD_POP3_EXPIRE_INSTANCE_MAIL        (IIS_MD_POP3_PARAMS_BASE + 21)
#define MD_POP3_CLEARTEXT_AUTH_PROVIDER     (IIS_MD_POP3_PARAMS_BASE + 22)
#define MD_POP3_DS_TYPE                     (IIS_MD_POP3_PARAMS_BASE + 23)
#define MD_POP3_DS_DATA_DIRECTORY           (IIS_MD_POP3_PARAMS_BASE + 24)
#define MD_POP3_DS_DEFAULT_MAIL_ROOT        (IIS_MD_POP3_PARAMS_BASE + 25)
#define MD_POP3_DS_BIND_TYPE                (IIS_MD_POP3_PARAMS_BASE + 26)
#define MD_POP3_DS_SCHEMA_TYPE              (IIS_MD_POP3_PARAMS_BASE + 27)
#define MD_POP3_DS_HOST                     (IIS_MD_POP3_PARAMS_BASE + 28)
#define MD_POP3_DS_NAMING_CONTEXT           (IIS_MD_POP3_PARAMS_BASE + 29)
#define MD_POP3_DS_ACCOUNT                  (IIS_MD_POP3_PARAMS_BASE + 30)
#define MD_POP3_DS_PASSWORD                 (IIS_MD_POP3_PARAMS_BASE + 31)
#define MD_POP3_DS_MAX_RESOLVE_BUFFERS      (IIS_MD_POP3_PARAMS_BASE + 32)
#define MD_POP3_DS_MAX_VIRTUAL_SERVERS      (IIS_MD_POP3_PARAMS_BASE + 33)
#define MD_POP3_DS_MAX_HANDLE_CACHE_ENTRIES (IIS_MD_POP3_PARAMS_BASE + 34)
#define MD_POP3_DS_SORT_THRESHOLD           (IIS_MD_POP3_PARAMS_BASE + 35)

#ifdef __cplusplus
}
#endif  // _cplusplus

#endif  // _POP3S_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\schemini.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  schemini.cxx
//
//  Contents:  Loading Schema/Property from metabase code
//
//  History:   28-Apr-97     Markand    Created.
//  History:   18-Aug-98     sophiac    Extensible schema
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#define INITGUID
#pragma hdrstop
#include "mddef.h"
#include <tchar.h>

#define DEFAULT_TIMEOUT_VALUE                    30000

StrMap::StrMap() {
	count = 0;
	mapSize = 64;
	map = (StrMapEntry *)malloc(sizeof(StrMapEntry) * mapSize);
}

StrMap::~StrMap() {
	free(map);
}

DWORD StrMap::GetEntries() {
	return count;
}

LPWSTR StrMap::GetEntryName(DWORD dwIndex) {
	return map[dwIndex].m_str;
}


BOOL StrMap::CheckSpace() {
	if (count < mapSize)
		return TRUE;
	mapSize += 32;
	if ((map = (StrMapEntry *)realloc(map, sizeof(StrMapEntry)*mapSize)) == NULL)
		return FALSE;
	return TRUE;
}

BOOL StrMap::Add(LPWSTR str, void *data) {
	if (!CheckSpace())
		return FALSE;
	map[count].m_str = str;
	map[count].m_data = data;
	count++;
	return TRUE;
}

BOOL StrMap::ClearEntry(DWORD dwIndex) {

	count--;

	void* prop = map[count].m_data;
	
	// replace object to be deleted by last object in list and decrement count

	map[dwIndex].m_str  = map[count].m_str;
	map[dwIndex].m_data = map[count].m_data; 
	map[count].m_str  = NULL;
	map[count].m_data = NULL;

	if (prop)
		delete prop;

	return TRUE;
}

void *StrMap::Find(LPWSTR str) {
	for (int i=0; i < count; i++) {
		if (!_wcsicmp(str, map[i].m_str))
			return map[i].m_data;
	}
	return NULL;
}

void *StrMap::operator[] (LPWSTR str) {
	return Find(str);
}	


DWORDMap::DWORDMap() {
	count = 0;
	mapSize = 64;
	map = (DWORDMapEntry *)malloc(sizeof(DWORDMapEntry) * mapSize);
}

DWORDMap::~DWORDMap() {
	free(map);
}

BOOL DWORDMap::CheckSpace() {
	if (count < mapSize)
		return TRUE;
	mapSize += 32;
	if ((map = (DWORDMapEntry *)realloc(map, sizeof(DWORDMapEntry)*mapSize)) == NULL)
		return FALSE;
	return TRUE;
}

BOOL DWORDMap::Add(DWORD val, void *data) {
	if (!CheckSpace())
		return FALSE;
	map[count].m_val = val;
	map[count].m_data = data;
	count++;
	return TRUE;
}

BOOL DWORDMap::ClearEntry(DWORD id) {
	//  !! don't delete the m_data here
	//  !! it will be or already has been deleted
	//  !! by StrMap::ClearEntry

	int ri = 0;

	for (int i=0; i < count; i++) {
		if (id == map[i].m_val)
			ri = i;		
	}

	count--;

	map[ri].m_val  = map[count].m_val;
	map[ri].m_data = map[count].m_data;
	map[count].m_val  = NULL;
	map[count].m_data = NULL;

	return TRUE;
}

void *DWORDMap::Find(DWORD val) {
	for (int i=0; i < count; i++) {
		if (val == map[i].m_val)
			return map[i].m_data;
	}
	return NULL;
}

void *DWORDMap::operator[] (DWORD val) {
	return Find(val);
}	

IIsSchemaClass::IIsSchemaClass(LPWSTR _name) {
    memset(&classInfo, 0, sizeof(CLASSINFO));
	name = new WCHAR[wcslen(_name)+1];
	wcscpy(name, _name);
}

IIsSchemaClass::~IIsSchemaClass() {
	delete[] name;

	if (classInfo.bstrContainment)
		FreeADsMem(classInfo.bstrContainment);
	if (classInfo.bstrOptionalProperties)
		FreeADsMem(classInfo.bstrOptionalProperties);
	if (classInfo.bstrMandatoryProperties)
		FreeADsMem(classInfo.bstrMandatoryProperties);
}

HRESULT
IISSchemaProperty::SetpropInfo(PROPERTYINFO *ppropInfo) {

    HRESULT hr = S_OK;
    LPWSTR pszStr;
 
    if (propInfo.bstrOID) {
        ADsFreeString( propInfo.bstrOID );
    }
    if (propInfo.bstrSyntax) {
        ADsFreeString( propInfo.bstrSyntax );
    }
    if (propInfo.szDefault) {
        if (propInfo.dwSyntaxId == IIS_SYNTAX_ID_STRING ||
            propInfo.dwSyntaxId == IIS_SYNTAX_ID_EXPANDSZ) {
            FreeADsStr( propInfo.szDefault );
        }
        else if (propInfo.dwSyntaxId == IIS_SYNTAX_ID_MULTISZ) {
            FreeADsMem( propInfo.szDefault );
        }
    }

    memset(&propInfo, 0, sizeof(PROPERTYINFO));
    memcpy(&propInfo, ppropInfo, sizeof(PROPERTYINFO));

    hr = ADsAllocString(ppropInfo->bstrSyntax, &propInfo.bstrSyntax);
    BAIL_ON_FAILURE(hr);
    hr = ADsAllocString(ppropInfo->bstrOID, &propInfo.bstrOID);
    BAIL_ON_FAILURE(hr);

    switch(ppropInfo->dwSyntaxId) {
    case IIS_SYNTAX_ID_DWORD:
    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
         propInfo.dwDefault = ppropInfo->dwDefault;
         break;

    case IIS_SYNTAX_ID_STRING:
    case IIS_SYNTAX_ID_EXPANDSZ:
         if (ppropInfo->szDefault) {
             propInfo.szDefault = AllocADsStr((LPWSTR)(ppropInfo->szDefault));
             if (!propInfo.szDefault) {
                 hr = E_OUTOFMEMORY;
                 BAIL_ON_FAILURE(hr);
             }
         }
         break;

    case IIS_SYNTAX_ID_MIMEMAP:
    case IIS_SYNTAX_ID_MULTISZ:
        pszStr = ppropInfo->szDefault;

        //
        // calculate length
        //

        if (pszStr) {
           DWORD dwLen = 0;

           //
           // if first char is a null char
           //

           if (*pszStr == L'\0') {
               dwLen = 1;
               pszStr++;
           }

           while (*pszStr != L'\0') {
               while (*pszStr != L'\0') {
                   pszStr++;
                   dwLen++;
               }
               pszStr++;
               dwLen++;
           }
           propInfo.szDefault = (LPWSTR)AllocADsMem((dwLen +1) * sizeof(WCHAR));
           if (!propInfo.szDefault) {
               hr = E_OUTOFMEMORY;
               BAIL_ON_FAILURE(hr);
           }
           memcpy(propInfo.szDefault, (LPWSTR)ppropInfo->szDefault, 
              (dwLen+1)*sizeof(WCHAR));
        }

        break;

    default:
        break;

    }

error:

    RRETURN(hr); 
}

IISSchemaProperty::IISSchemaProperty(DWORD id, LPWSTR _name, int nameLen) {
    memset(&propInfo, 0, sizeof(PROPERTYINFO));
	name = new WCHAR[nameLen];
	wcscpy(name, _name);
	propID = id;
}

IISSchemaProperty::~IISSchemaProperty() {
	delete[] name;
    if (propInfo.szDefault) {
        if (propInfo.dwSyntaxId == IIS_SYNTAX_ID_MULTISZ) {
            FreeADsMem(propInfo.szDefault);
        }
        else {
            FreeADsStr(propInfo.szDefault);
        }
    }
}

HRESULT IIsSchemaClass::findContainedClassName(LPWSTR pszContainName) {
    WCHAR szName[MAX_PATH];
    LPWSTR ObjectList = (LPWSTR)classInfo.bstrContainment;

    while ((ObjectList = grabProp(szName, ObjectList)) != NULL) {
        if (*szName != L'\0') {
            if (!_wcsicmp(szName, pszContainName)) {
			   return S_OK;
            }
        }

    }

	return E_ADS_SCHEMA_VIOLATION;
}

HRESULT IIsSchemaClass::SetclassInfo(PCLASSINFO pClassInfo) {
    HRESULT hr = S_OK;
    LPBYTE pBuffer = NULL;
    DWORD dwSize;

	if (classInfo.bstrContainment)
		FreeADsMem(classInfo.bstrContainment);
	if (classInfo.bstrOptionalProperties)
		FreeADsMem(classInfo.bstrOptionalProperties);
	if (classInfo.bstrMandatoryProperties)
		FreeADsMem(classInfo.bstrMandatoryProperties);

    memset(&classInfo, 0, sizeof(CLASSINFO));

    if (pClassInfo) {
        if (pClassInfo->bstrContainment) {
            dwSize = (wcslen(pClassInfo->bstrContainment)+1)*sizeof(WCHAR);
            pBuffer = (LPBYTE)AllocADsMem(dwSize);
            if (!pBuffer) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            memcpy(pBuffer, pClassInfo->bstrContainment, dwSize);
            classInfo.bstrContainment = (BSTR)pBuffer;
        }

        if (pClassInfo->bstrMandatoryProperties) {
            dwSize = (wcslen(pClassInfo->bstrMandatoryProperties)+1)*sizeof(WCHAR);
            pBuffer = (LPBYTE)AllocADsMem(dwSize);
            if (!pBuffer) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            memcpy(pBuffer, pClassInfo->bstrMandatoryProperties, dwSize);
            classInfo.bstrMandatoryProperties = (BSTR)pBuffer;
        }

        if (pClassInfo->bstrOptionalProperties) {
            dwSize = (wcslen(pClassInfo->bstrOptionalProperties)+1)*sizeof(WCHAR);
            pBuffer = (LPBYTE)AllocADsMem(dwSize);
            if (!pBuffer) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            memcpy(pBuffer, pClassInfo->bstrOptionalProperties, dwSize);
            classInfo.bstrOptionalProperties = (BSTR)pBuffer;
        }
        classInfo.fContainer = pClassInfo->fContainer;
    }

error:

    RRETURN(hr); 
}

HRESULT IIsSchemaClass::findProp(LPWSTR pszPropName) {
    WCHAR szName[MAX_PATH];
    LPWSTR ObjectList = (LPWSTR)classInfo.bstrOptionalProperties;

    while ((ObjectList = grabProp(szName, ObjectList)) != NULL) {
        if (*szName != L'\0') {
            if (!_wcsicmp(szName, pszPropName)) {
			   return S_OK;
            }
        }

    }

    ObjectList = (LPWSTR)classInfo.bstrMandatoryProperties;

    while ((ObjectList = grabProp(szName, ObjectList)) != NULL) {
        if (*szName != L'\0') {
            if (!_wcsicmp(szName, pszPropName)) {
			   return S_OK;
            }
        }
	}

	return E_ADS_PROPERTY_NOT_SUPPORTED;
}

BOOL IISSchemaProperty::InitFromMetaData(METADATA_GETALL_RECORD *mdga, BYTE *data) {
    PropValue pv;

	if (mdga->dwMDDataType == BINARY_METADATA  && 
        mdga->dwMDDataLen >= sizeof(PropValue) - sizeof(LPWSTR)) {
		memcpy(&pv, (data+mdga->dwMDDataOffset), sizeof(PropValue));

        propInfo.dwMetaID = pv.dwMetaID;
        propInfo.dwPropID = pv.dwPropID;
        propInfo.dwSyntaxId = pv.dwSynID;
        propInfo.lMaxRange = (long)pv.dwMaxRange;
        propInfo.lMinRange = (long)pv.dwMinRange;
        propInfo.dwFlags = pv.dwFlags;
        propInfo.dwMask = pv.dwMask;
        propInfo.dwMetaFlags = pv.dwMetaFlags;
        propInfo.dwUserGroup = pv.dwUserGroup;
        propInfo.fMultiValued = pv.fMultiValued;
        propInfo.bstrSyntax = SyntaxIdToString(pv.dwSynID);

		return TRUE;
	}
	return FALSE;
}

BOOL IISSchemaProperty::InitPropertyDefaults(METADATA_GETALL_RECORD *mdga, BYTE *data) {

    WCHAR *ptr;

    propInfo.dwDefault = 0;
    propInfo.szDefault = NULL;

    switch(mdga->dwMDDataType) {
    case DWORD_METADATA:
         propInfo.dwDefault = *(DWORD *)(data+mdga->dwMDDataOffset);
         break;
    case STRING_METADATA:
    case EXPANDSZ_METADATA:
         propInfo.szDefault = AllocADsStr((LPWSTR)(data+mdga->dwMDDataOffset));
         break;
    case MULTISZ_METADATA:   
        ptr = (LPWSTR)(data+mdga->dwMDDataOffset);
        propInfo.szDefault = (LPWSTR) AllocADsMem(mdga->dwMDDataLen);
        memcpy(propInfo.szDefault, (LPWSTR)ptr, mdga->dwMDDataLen);
        break;

    case BINARY_METADATA:
        break;

    }
	return TRUE;
}

WCHAR *grabProp(WCHAR *out, WCHAR *in) {
	if (!in || *in == L'\0') {
		*out = L'\0';
		return NULL;
	}
	while (*in != L',' && *in != L'\0') {
		*out++ = *in++;
	}
	*out = L'\0';
	if (*in == L',')
		return ++in;
	return in;
}

WCHAR *SyntaxIdToString(DWORD syntaxID) {
	switch(syntaxID) {
	case IIS_SYNTAX_ID_BOOL:
	case IIS_SYNTAX_ID_BOOL_BITMASK:
		return L"Boolean";
	case IIS_SYNTAX_ID_DWORD:
		return L"Integer";
	case IIS_SYNTAX_ID_STRING:
		return L"String";
	case IIS_SYNTAX_ID_EXPANDSZ:
		return L"ExpandSz";
	case IIS_SYNTAX_ID_MIMEMAP:
		return L"MimeMapList";
	case IIS_SYNTAX_ID_MULTISZ:
		return L"List";
	case IIS_SYNTAX_ID_IPSECLIST:
		return L"IPSec";
	case IIS_SYNTAX_ID_NTACL:
		return L"NTAcl";
	case IIS_SYNTAX_ID_BINARY:
		return L"Binary";
	default:
		return L"(ERROR -- UNDEFINED SYNTAX ID)";
	}
}

BOOL DataForSyntaxID(PROPERTYINFO *pp, METADATA_RECORD *mdr) {
    static DWORD value=0;
    WCHAR *ptr;
    int i;

    switch(pp->dwSyntaxId) {
    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
    case IIS_SYNTAX_ID_DWORD:
        mdr->dwMDDataType = DWORD_METADATA;
        mdr->dwMDDataLen = sizeof(DWORD);
        mdr->pbMDData = (unsigned char *)&(pp->dwDefault);
        break;
    case IIS_SYNTAX_ID_STRING:
        mdr->dwMDDataType = STRING_METADATA;
        if (pp->szDefault) {
            mdr->dwMDDataLen = (wcslen(pp->szDefault)+1)*2;
        }
        else {
            mdr->dwMDDataLen = 0;
        }
        mdr->pbMDData = (unsigned char *)pp->szDefault;
        break;
    case IIS_SYNTAX_ID_EXPANDSZ:
        mdr->dwMDDataType = EXPANDSZ_METADATA;
        if (pp->szDefault) {
            mdr->dwMDDataLen = (wcslen(pp->szDefault)+1)*2;
        }
        else {
            mdr->dwMDDataLen = 0;
        }
        mdr->pbMDData = (unsigned char *)pp->szDefault;
        break;
    case IIS_SYNTAX_ID_MIMEMAP:
    case IIS_SYNTAX_ID_MULTISZ:
        //
        // Note, ALL multisz types must have an extra \0 in the table.
        //
        mdr->dwMDDataType = MULTISZ_METADATA;
        if (pp->szDefault) {
            ptr = pp->szDefault;
            if (*ptr == L'\0') {
                ptr++;
            }
            while (*ptr!=0) {
                ptr += wcslen(ptr)+1;
            } 
            mdr->dwMDDataLen = DIFF((char *)ptr - (char *)pp->szDefault)+2;
        }
        else {
            mdr->dwMDDataLen = 0;
        }
        mdr->pbMDData = (unsigned char *)pp->szDefault;
        break;
    case IIS_SYNTAX_ID_IPSECLIST:
    case IIS_SYNTAX_ID_NTACL:
    case IIS_SYNTAX_ID_BINARY:
        mdr->dwMDDataType = BINARY_METADATA;
        mdr->dwMDDataLen = 0;
        mdr->pbMDData = NULL;
        break;
    default:
        mdr->dwMDDataType = DWORD_METADATA;
        mdr->dwMDDataLen = sizeof(DWORD);
        mdr->pbMDData = (unsigned char *)&value;
        return FALSE;
    }
    return TRUE;
}

DWORD SyntaxToMetaID(DWORD syntaxID) {
	switch(syntaxID) {
	case IIS_SYNTAX_ID_BOOL:
	case IIS_SYNTAX_ID_BOOL_BITMASK:
	case IIS_SYNTAX_ID_DWORD:
		return DWORD_METADATA;

	case IIS_SYNTAX_ID_STRING:
		return STRING_METADATA;

	case IIS_SYNTAX_ID_EXPANDSZ:
		return EXPANDSZ_METADATA;

	case IIS_SYNTAX_ID_MIMEMAP:
	case IIS_SYNTAX_ID_MULTISZ:
	case IIS_SYNTAX_ID_HTTPERRORS:
	case IIS_SYNTAX_ID_HTTPHEADERS:
		return MULTISZ_METADATA;

	case IIS_SYNTAX_ID_IPSECLIST:
	case IIS_SYNTAX_ID_NTACL:
	case IIS_SYNTAX_ID_BINARY:
		return  BINARY_METADATA;

	default:
//		printf("ERROR, Unknown Syntax Type %x", syntaxID);
		return 0;
	}
	return 0;
}

MetaHandle::MetaHandle(IMSAdminBasePtr _pmb) : pmb(_pmb) {
	if (pmb)
		pmb->AddRef();
	h = 0;
}
MetaHandle::~MetaHandle() {
	if (pmb) {
		if (h)
			pmb->CloseKey(h);
		pmb->Release();
	}
}

HRESULT IIsSchema::IdToPropNameW(DWORD id, LPWSTR buf) {
	IISSchemaProperty *prop = (IISSchemaProperty *)idToProp[id];
	if (!prop)
		return E_ADS_PROPERTY_NOT_SUPPORTED;
    wcscpy(buf, prop->getName());
	return S_OK;
}

HRESULT IIsSchema::PropNameWToId(LPWSTR propNameW, DWORD *id) {
	IISSchemaProperty *prop = (IISSchemaProperty *)nameToProp[propNameW];
	if (!prop)
		return E_ADS_PROPERTY_NOT_SUPPORTED;
	*id = prop->getPropID();
	return S_OK;
}

HRESULT IIsSchema::LookupFlagPropName(LPWSTR propNameW, LPWSTR FlagPropName) {
    DWORD id;
	IISSchemaProperty *prop = (IISSchemaProperty *)nameToProp[propNameW];
	if (!prop)
		return E_ADS_PROPERTY_NOT_SUPPORTED;
	id = prop->getMetaID();
    return (ConvertID_To_PropName(id, FlagPropName));
}

HRESULT IIsSchema::LookupMetaID(LPWSTR propNameW, PDWORD pdwMetaId) {
	IISSchemaProperty *prop = (IISSchemaProperty *)nameToProp[propNameW];
	if (!prop)
		return E_ADS_PROPERTY_NOT_SUPPORTED;
	*pdwMetaId = prop->getMetaID();
	return S_OK;
}


HRESULT IIsSchema::LookupPropID(LPWSTR propNameW, PDWORD pdwPropId) {
	IISSchemaProperty *prop = (IISSchemaProperty *)nameToProp[propNameW];
	if (!prop)
		return E_ADS_PROPERTY_NOT_SUPPORTED;
	*pdwPropId = prop->getPropID();
	return S_OK;
}

HRESULT IIsSchema::PropNameWToIISSchemaProp(LPWSTR propNameW, IISSchemaProperty **prop) {
	*prop = NULL;
	*prop = (IISSchemaProperty *)nameToProp[propNameW];
	if (!*prop)
		return E_ADS_PROPERTY_NOT_SUPPORTED;
	return S_OK;
}

HRESULT IIsSchema::ValidatePropertyName( LPWSTR szPropName) {
	DWORD propID;
	HRESULT hr;

	hr = PropNameWToId(szPropName, &propID);
	RRETURN(hr);
}

HRESULT IIsSchema::ValidateProperty(LPWSTR szClassName, LPWSTR szPropName) {
	HRESULT hr;
	IIsSchemaClass *sc;

	sc = (IIsSchemaClass*)nameToClass[szClassName];
	if (!sc)
		return E_ADS_PROPERTY_NOT_SUPPORTED;
	hr = sc->findProp(szPropName);

	RRETURN(hr);
}

HRESULT IIsSchema::ValidateContainedClassName(LPWSTR szClassName, LPWSTR szContainName) {
	HRESULT hr;
	IIsSchemaClass *sc;

	sc = (IIsSchemaClass *)nameToClass[szClassName];
	if (!sc)
		RRETURN(E_ADS_UNKNOWN_OBJECT);
	hr = sc->findContainedClassName(szContainName);
	RRETURN(hr);
}

HRESULT 
IIsSchema::GetDefaultProperty(
    LPWSTR szPropName, 
    PDWORD pdwNumValues, 
    PDWORD pdwSyntax, 
    LPBYTE *pBuffer
    ) 
/*++

Routine Description:

Arguments:

    LPBYTE *pBuffer     - pBuffer is not allocated, it just holds the
                          address of the default value in the PROPINFO
                          structure

Return Value:

Notes:

    Called by CPropertyCache::getproperty

    Currently binary values are not supported correctly, we
    may not ever support them.

--*/
{
	HRESULT hr = S_OK;

    IISSchemaProperty *prop = (IISSchemaProperty *)nameToProp[szPropName];

	if (!prop)
		return E_ADS_PROPERTY_NOT_SUPPORTED;

    *pdwSyntax = prop->getSyntaxID();

    switch(*pdwSyntax) {
    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
    case IIS_SYNTAX_ID_DWORD:
        *pBuffer = (LPBYTE)prop->getdwDefaultAddr();
        *pdwNumValues = 1;
        break;
    case IIS_SYNTAX_ID_BINARY:
    case IIS_SYNTAX_ID_IPSECLIST:
    case IIS_SYNTAX_ID_NTACL:
        //
        // We don't currently support setting or getting default values,
        // so pBuffer should always be NULL. To support default values
        // on binaries, we need to transmit the length in the PROPINFO
        // structure.
        //
        *pBuffer = (LPBYTE)prop->getszDefault();
        ADsAssert( *pBuffer == NULL );
        *pdwNumValues = 0;
        break;
    case IIS_SYNTAX_ID_MULTISZ:
    {
        *pBuffer = (LPBYTE)prop->getszDefault();
        LPWSTR pszStr = (LPWSTR)*pBuffer;

        if (*pszStr == 0) {
            *pdwNumValues = 1;
        }
        else {
            *pdwNumValues = 0;
        }

        while (*pszStr != L'\0') {
            while (*pszStr != L'\0') {
                pszStr++;
            }
            (*pdwNumValues)++;
            pszStr++;
        }
        break;
    }   
	default:
        *pBuffer = (LPBYTE)prop->getszDefault();
        *pdwNumValues = 1;
        break;
    }

	RRETURN(hr);
}

HRESULT IIsSchema::PropNameWToSyntaxId(LPWSTR propNameW, DWORD *syntaxID) {
	IISSchemaProperty *prop;
	HRESULT hr;
	
	hr = PropNameWToIISSchemaProp(propNameW, &prop);
	BAIL_ON_FAILURE(hr);
	*syntaxID = prop->getSyntaxID();
	return S_OK;
error:
	return E_ADS_PROPERTY_NOT_SUPPORTED;
}

HRESULT IIsSchema::ValidateClassName(LPWSTR classNameW) {
	if (nameToClass[classNameW])
		RRETURN(ERROR_SUCCESS);
	else
        RRETURN(E_ADS_SCHEMA_VIOLATION);
}


HRESULT IIsSchema::ConvertID_To_PropName(
    DWORD dwIdentifier,
    LPWSTR pszPropertyName
    )
{
	HRESULT hr = S_OK;

	hr = IdToPropNameW(dwIdentifier, pszPropertyName);
    RRETURN(hr);
}

HRESULT IIsSchema::ConvertPropName_To_ID(
    LPWSTR pszPropertyName,
    PDWORD pdwIdentifier
    )
{
    HRESULT hr = S_OK;
    DWORD i;

    if (!pszPropertyName) {
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
        BAIL_ON_FAILURE(hr);
    }
	hr = PropNameWToId(pszPropertyName, pdwIdentifier);
error:

    RRETURN(hr);
}


HRESULT IIsSchema::LookupSyntaxID(
    LPWSTR pszPropertyName,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    DWORD i;

    if (!pszPropertyName) {
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
        BAIL_ON_FAILURE(hr);
    }
	hr = PropNameWToSyntaxId(pszPropertyName, pdwSyntaxId);
error:

    RRETURN(hr);
}


HRESULT IIsSchema::LookupMDFlags(
    DWORD dwPropID,
    PDWORD pdwAttribute,
    PDWORD pdwUserType
    )
{
    HRESULT hr = S_OK;
	IISSchemaProperty *prop=(IISSchemaProperty *)idToProp[dwPropID];
	if (prop) {
		*pdwAttribute = prop->getMetaFlags();
		*pdwUserType = prop->getUserGroup();
	} else {
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
        BAIL_ON_FAILURE(hr);
	}
	return S_OK;
error:
    RRETURN(hr);
}

HRESULT
IIsSchema::LookupBitMask(
    LPWSTR pszPropertyName,
    PDWORD pdwMaskBits
    )
{
    HRESULT hr = S_OK;
	IISSchemaProperty *prop=NULL;
	
	hr = PropNameWToIISSchemaProp(pszPropertyName, &prop);
	BAIL_ON_FAILURE(hr);

	if (prop) {
		*pdwMaskBits = prop->getMask();
	} else {
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
        BAIL_ON_FAILURE(hr);
	}
	return S_OK;
error:
    RRETURN(hr);
}

HRESULT IIsSchema::LoadAllData(IMSAdminBasePtr &pmb, 
					   MetaHandle &root, 
					   WCHAR *subdir, 
					   BYTE **buf, 
					   DWORD *size,
					   DWORD *count) {
	DWORD dataSet;
	DWORD neededSize;
	HRESULT hr;
	//
	// Try to get the property names.
	//
	hr = pmb->GetAllData(root,
					subdir,
					METADATA_NO_ATTRIBUTES,
					ALL_METADATA,
					ALL_METADATA,
					count,
					&dataSet,
					*size,
					*buf,
					&neededSize);
	if (!SUCCEEDED(hr)) {
		DWORD code = ERROR_INSUFFICIENT_BUFFER;
		if (hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
//			printf("Names buf of %d not big enough.  Need %d bytes\n", 
//					getAllBufSize,
//					neededSize);
			delete *buf;
			*buf = 0;
			*size = neededSize;
			*buf = new BYTE[neededSize];
			hr = pmb->GetAllData(root,
							subdir,
							METADATA_NO_ATTRIBUTES,
							ALL_METADATA,
							ALL_METADATA,
							count,
							&dataSet,
	 						*size,
							*buf,
							&neededSize);

		}
	}
	return hr;
}

// BUGBUG: Get rid of this constant ASAP!
// Sergeia: fix for bug 189797, buffer was too small
const DWORD getAllBufSize = 4096*2;
 
HRESULT IIsSchema::InitSchema(WCHAR *baseName){
//	IUnknown* pIUnknown;
	DWORD bufSize = getAllBufSize;
	BYTE *buf = new BYTE[bufSize];
	HRESULT hr;
	COSERVERINFO csiName;
	COSERVERINFO *pcsiParam = &csiName;
	IClassFactory * pcsfFactory = NULL;
    IMSAdminBase * pAdminBase = NULL;
    IMSAdminBase * pAdminBaseT = NULL;
	DWORD count=0, dataSet=0, neededSize=0, dwStatus;
	METADATA_GETALL_RECORD *pmd;
	DWORD propBufSize = 128;
	DWORD i;
	MetaHandle root(NULL);
    LPWSTR pContainment = NULL;
    LPWSTR pOptProp = NULL;
    LPWSTR pMandProp = NULL;
    DWORD  dwData = 0;
    CLASSINFO classInfo;

//	printf("Loading schema....\n");

	memset(pcsiParam, 0, sizeof(COSERVERINFO));
	
	pcsiParam->pwszName =  baseName;
	csiName.pAuthInfo = NULL;
	pcsiParam = &csiName;

	hr = CoGetClassObject(
						  CLSID_MSAdminBase,
						  CLSCTX_SERVER,
						  pcsiParam,
						  IID_IClassFactory,
						  (void**) &pcsfFactory
						 );

	BAIL_ON_FAILURE(hr);

	hr = pcsfFactory->CreateInstance(
									 NULL,
									 IID_IMSAdminBase,
									 (void **) &pAdminBase
									);
	BAIL_ON_FAILURE(hr);

	root.setpointer(pAdminBase);
	hr = pAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
							 L"/Schema/Properties",
							 METADATA_PERMISSION_READ,
							 DEFAULT_TIMEOUT_VALUE,
							 root);

	BAIL_ON_FAILURE(hr);

	hr = LoadAllData(pAdminBase, root, L"Names", &buf, &bufSize, &count);

	BAIL_ON_FAILURE(hr);

	//		printf("Loaded %d Properties\n", count);
	//
	// Now, here we've gotten the list of properties/names.
	// Create IIsSchemaProperty objects for each.  We then
	// Add the object to the two maps.  Later, we will load
	// all of the "Properties/Values" properties, look up (by
	// id) the object, and initialize the property value.
	//
	pmd = (METADATA_GETALL_RECORD *)buf;
	for ( i=0;i < count; i++, pmd++) {
		if (pmd->dwMDDataType != STRING_METADATA) {
			//				printf("Error: Property name not a string, need to figure out what to do.\n");
			continue;
		}
		LPWSTR name = (WCHAR *)(buf + pmd->dwMDDataOffset);
		//			printf("  Loading %s\n", name);
		IISSchemaProperty *pProp 
				= new IISSchemaProperty(
										pmd->dwMDIdentifier,
										name,
										pmd->dwMDDataLen);
		idToProp.Add(pmd->dwMDIdentifier, pProp);
		nameToProp.Add(pProp->getName(), pProp);

	}
	hr = LoadAllData(pAdminBase, root, L"Types", &buf, &bufSize, &count);

	BAIL_ON_FAILURE(hr);

	//
	// Now, here we've gotten the list of properties/values.
	// We then need to look up the properties by id (since that's
	// what we have) and initialize the property type information.
	//
	for (i=0;i < count; i++) {
		pmd = ((METADATA_GETALL_RECORD*)buf) + i;


		IISSchemaProperty *pProp = (IISSchemaProperty *)(idToProp[pmd->dwMDIdentifier]);
		if (pProp == NULL) {
			//				printf("Error finding prop value %x", pmd->dwMDIdentifier);
			continue;
		}
		pProp->InitFromMetaData(pmd, buf);
	}

	hr = LoadAllData(pAdminBase, root, L"Defaults", &buf, &bufSize, &count);
	BAIL_ON_FAILURE(hr);

	//
	// Now, here we've gotten the list of properties/defaults.
	// We then need to look up the properties by id (since that's
	// what we have) and initialize the property type information.
	//
	for (i=0;i < count; i++) {
		pmd = ((METADATA_GETALL_RECORD*)buf) + i;


		IISSchemaProperty *pProp = (IISSchemaProperty *)(idToProp[pmd->dwMDIdentifier]);
		if (pProp == NULL) {
			//				printf("Error finding prop value %x", pmd->dwMDIdentifier);
			continue;
		}
  
		pProp->InitPropertyDefaults(pmd, buf);
	}

	root.close();
	// Next, we need to initialize the class map.
	WCHAR className[METADATA_MAX_NAME_LEN];

	hr = pAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
							 L"/Schema/Classes",
							 METADATA_PERMISSION_READ,
							 DEFAULT_TIMEOUT_VALUE,
							 root);
	BAIL_ON_FAILURE(hr);

	for (i=0; TRUE ; i++) {
        hr = pAdminBase->EnumKeys(root, L"", (LPWSTR)className, i);
        if (!SUCCEEDED(hr)) {
            hr = ERROR_SUCCESS ;
            break;
        }

		IIsSchemaClass *psc = new IIsSchemaClass(className);

		//
		// Load the Containment, Mandatory, Optional, and Container properties.
	    //	

        hr = MetaBaseGetStringData(pAdminBase,
                                   root,
                                   className,
                                   MD_SCHEMA_CLASS_CONTAINMENT,
                                   (LPBYTE*)&pContainment
                                   );
     	BAIL_ON_FAILURE(hr);

        hr = MetaBaseGetStringData(pAdminBase,
                                   root,
                                   className,
                                   MD_SCHEMA_CLASS_OPT_PROPERTIES,
                                   (LPBYTE*)&pOptProp
                                   );
     	BAIL_ON_FAILURE(hr);

        hr = MetaBaseGetStringData(pAdminBase,
                                   root,
                                   className,
                                   MD_SCHEMA_CLASS_MAND_PROPERTIES,
                                   (LPBYTE*)&pMandProp
                                   );
     	BAIL_ON_FAILURE(hr);

        hr = MetaBaseGetDwordData(pAdminBase,
                                  root,
                                  className,
                                  MD_SCHEMA_CLASS_CONTAINER,
                                  &dwData
                                  );
        BAIL_ON_FAILURE(hr);
       
        classInfo.bstrContainment = pContainment;
        classInfo.bstrOptionalProperties = pOptProp;
        classInfo.bstrMandatoryProperties = pMandProp;
        classInfo.fContainer = dwData ? TRUE : FALSE;

        psc->SetclassInfo(&classInfo);
		nameToClass.Add(psc->getName(), psc);
	}
error:

    if (pAdminBase) {
        pAdminBase->Release();
    }
    if (pContainment) {
        FreeADsMem(pContainment);
    }
    if (pOptProp) {
        FreeADsMem(pOptProp);
    }

    if (pMandProp) {
        FreeADsMem(pMandProp);
    }

    if (hr != ERROR_SUCCESS) {

		if (buf)
			delete buf;
    }
    if (pcsfFactory) {
        pcsfFactory->Release();
    }

    RRETURN(hr);
}

HRESULT IIsSchema::GetTotalEntries(PDWORD pdwEntries) { 
    *pdwEntries = nameToClass.GetEntries() + nameToProp.GetEntries();
    RRETURN(S_OK); 
}			

DWORD IIsSchema::GetClassEntries() { 
    return nameToClass.GetEntries();
}			

DWORD IIsSchema::GetPropEntries() { 
    return nameToProp.GetEntries();
}			

LPWSTR IIsSchema::GetClassName(DWORD dwIndex) { 
    return nameToClass.GetEntryName(dwIndex);
}			

LPWSTR IIsSchema::GetPropName(DWORD dwIndex) { 
    return nameToProp.GetEntryName(dwIndex);
}			

HRESULT IIsSchema::RemoveEntry(BOOL bClass, LPWSTR pszName) { 

	DWORD i;
	DWORD id = 0;
	LPWSTR pszPropName;
	LPWSTR pszClassName;
	IISSchemaProperty *prop;
	if (bClass)
	{
		// clear nameToClass entry using pszName
		for ( i = 0; i < nameToClass.GetEntries(); i++ )
		{
			pszClassName = nameToClass.GetEntryName(i);
			if (pszClassName != NULL && _wcsicmp( pszClassName, pszName) == 0 ) {
				nameToClass.ClearEntry(i);
			}
		}
	}
	else 
	{
		// clear nameToProp entry using pszName
		for ( i = 0; i < nameToProp.GetEntries(); i++ )
		{
			pszPropName = nameToProp.GetEntryName(i);
			if (pszPropName != NULL && _wcsicmp( pszPropName, pszName) == 0 ) {
				prop = (IISSchemaProperty *)nameToProp[pszPropName];
	
				if (!prop)
					RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);

				id = prop->getPropID();
				nameToProp.ClearEntry(i);
			}
		}
		// clear idToProp entry using id

		if (id != 0)
		{
			idToProp.ClearEntry(id);					
		}
	}

    RRETURN(S_OK); 
}			

PCLASSINFO IIsSchema::GetClassInfo(LPWSTR pszName) {

    DWORD i;
    LPWSTR pszClassName;
	IIsSchemaClass *sc;

    for ( i = 0; i < nameToClass.GetEntries(); i++ )
    {
         pszClassName = nameToClass.GetEntryName(i);
         if (pszClassName != NULL && _wcsicmp( pszClassName, pszName) == 0 ) {
             sc = (IIsSchemaClass *)nameToClass[pszClassName];
             return sc != NULL ? sc->GetclassInfo() : NULL;
         }
    }

    return NULL;

}

PPROPERTYINFO IIsSchema::GetPropertyInfo(LPWSTR pszName) {

    DWORD i;
    LPWSTR pszPropName;
	IISSchemaProperty *prop;

    for ( i = 0; i < nameToProp.GetEntries(); i++ )
    {
         pszPropName = nameToProp.GetEntryName(i);
         if (pszPropName != NULL && _wcsicmp( pszPropName, pszName) == 0 ) {
             prop = (IISSchemaProperty *)nameToProp[pszPropName];
             return prop->GetpropInfo();
         }
    }

   return NULL;
}


HRESULT IIsSchema::SetClassInfo(LPWSTR pszName, PCLASSINFO pClassInfo) {
    DWORD i;
    LPWSTR pszClassName;
	IIsSchemaClass *sc;

    for ( i = 0; i < nameToClass.GetEntries(); i++ )
    {
         pszClassName = nameToClass.GetEntryName(i);
         if (pszClassName != NULL && _wcsicmp( pszClassName, pszName) == 0 ) {
             sc = (IIsSchemaClass *)nameToClass[pszClassName];
             return sc != NULL ? sc->SetclassInfo(pClassInfo) : E_FAIL;
         }
    }

    //
    //  add to schema cache if doesn't exist
    //

    sc = new IIsSchemaClass(pszName);
    sc->SetclassInfo(pClassInfo);
    nameToClass.Add(sc->getName(), sc);

	RRETURN(S_OK);
}

HRESULT IIsSchema::SetPropertyInfo(LPWSTR pszName, PPROPERTYINFO pPropInfo) {
    DWORD i;
    LPWSTR pszPropName;
	IISSchemaProperty *prop;

    for ( i = 0; i < nameToProp.GetEntries(); i++ )
    {
         pszPropName = nameToProp.GetEntryName(i);
         if ( _wcsicmp( pszPropName, pszName) == 0 ) {
             prop = (IISSchemaProperty *)nameToProp[pszPropName];
             return prop != NULL ? prop->SetpropInfo(pPropInfo) : E_FAIL;
         }
    }

    //
    //  add to schema cache if doesn't exist
    //

    prop = new IISSchemaProperty(pPropInfo->dwPropID,
                                 pszName, 
                                 wcslen(pszName)+1);
    if (prop != NULL)
       prop->SetpropInfo(pPropInfo);
    else 
       return E_FAIL;
    idToProp.Add(pPropInfo->dwPropID, prop);
    nameToProp.Add(prop->getName(), prop);

	RRETURN(S_OK);
}



IIsSchema::IIsSchema() {}			

void InitPropValue(PropValue *pv, PROPERTYINFO *pi) {
    pv->dwSynID = pi->dwSyntaxId;
    pv->dwMetaID = pi->dwMetaID;
    pv->dwPropID = pi->dwPropID;
    pv->dwMaxRange = (DWORD)pi->lMaxRange;
    pv->dwMinRange = (DWORD)pi->lMinRange;

    switch(pi->dwSyntaxId) {
    case IIS_SYNTAX_ID_DWORD:
    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
        pv->dwMetaType = DWORD_METADATA;
        break;
    case IIS_SYNTAX_ID_STRING:
        pv->dwMetaType = STRING_METADATA;
        break;
    case IIS_SYNTAX_ID_EXPANDSZ:
        pv->dwMetaType = EXPANDSZ_METADATA;
        break;
    case IIS_SYNTAX_ID_MIMEMAP:
    case IIS_SYNTAX_ID_MULTISZ:
        pv->dwMetaType = MULTISZ_METADATA;
        break;
    case IIS_SYNTAX_ID_NTACL:
    case IIS_SYNTAX_ID_BINARY:
    case IIS_SYNTAX_ID_IPSECLIST:
        pv->dwMetaType = BINARY_METADATA;
        break;

    }
    pv->dwFlags = pi->dwFlags;
    pv->fMultiValued = pi->fMultiValued;
    pv->dwMask = pi->dwMask;
    pv->dwMetaFlags = pi->dwMetaFlags;
    pv->dwUserGroup = pi->dwUserGroup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\iis51\globals.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  globals.cxx
//
//  Contents:
//
//  History:
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

#include "globdata.cxx"


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\svrcache.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  svrcache.cxx
//
//  Contents:  Caching code for com interface pointer and schema pointer
//
//  History:   28-Apr-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include <iis.hxx>

BOOL SERVER_CACHE::Insert(SERVER_CACHE_ITEM * item)
// returns TRUE if succeed
{
    ASSERT(NULL != item);
    CLock lock;
#ifdef DBG
    SERVER_CACHE_ITEM * item2;
    Cache.Reset();
    while (NULL != (item2 = Cache.Next()))
        {
        if ((0 == _wcsicmp(item->ServerName, item2->ServerName)) &&
            (item->dwThreadId == item2->dwThreadId))
            {
            ASSERT(!"item already exists");
            }
        }
#endif
    item->key = Cache.Insert(item);
    return item->key != -1;
}

SERVER_CACHE_ITEM * SERVER_CACHE::Delete(LPWSTR ServerName, DWORD dwThreadId)
// returns item found
{
    SERVER_CACHE_ITEM * item;
    CLock lock;
    Cache.Reset();
    while (NULL != (item = Cache.Next()))
        {
        if ((0 == _wcsicmp(ServerName, item->ServerName)) &&
            (dwThreadId == item->dwThreadId))
            {
            Cache.Delete(item->key);
            if (item->ServerName) {
                delete item->ServerName;
            }
            return item; 
            }
        }
    return NULL;
}

SERVER_CACHE_ITEM * SERVER_CACHE::Find(LPWSTR ServerName, DWORD dwThreadId)
// returns pointer to the item found
{
    SERVER_CACHE_ITEM * item;
    CLock lock;
    Cache.Reset();
    while (NULL != (item = Cache.Next()))
        {
        if ((0 == _wcsicmp(ServerName, item->ServerName)) &&
            (dwThreadId == item->dwThreadId))
            {
            return item;
            }
        }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\sdict.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  sdict.cxx
//
//  Contents:  simple dictionary 
//
//  History:   28-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include <iis.hxx>

SIMPLE_DICT::SIMPLE_DICT()
{
    cDictSize = 0;
    iNextItem = 0;
    cDictSlots = INITIALDICTSLOTS;

    DictSlots = InitialDictSlots;
    memset(DictSlots, 0, sizeof(void *) * cDictSlots);
}

SIMPLE_DICT::~SIMPLE_DICT()
{
    if (DictSlots != InitialDictSlots)
        delete DictSlots;
}

int
SIMPLE_DICT::Insert (
    void *Item
    )
{
    int iDictSlots;
    void * * NewDictSlots;

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)

        if (DictSlots[iDictSlots] == NULL)
            {
            DictSlots[iDictSlots] = Item;
            cDictSize += 1;
            return(iDictSlots);
            }

    // If we fell through to here, it must mean that the dictionary is
    // full; hence we need to allocate more space and copy the old
    // dictionary into it.

    NewDictSlots = (void * *) new char[sizeof(void *)*cDictSlots*2];
    if (!NewDictSlots)
        return(-1);

    memcpy(NewDictSlots, DictSlots, sizeof(void *) * cDictSlots);
    memset(NewDictSlots+iDictSlots, 0,  sizeof(void *) * cDictSlots);

    if (DictSlots != InitialDictSlots)
        delete DictSlots;
    DictSlots = NewDictSlots;

    cDictSlots *= 2;

    DictSlots[iDictSlots] = Item;
    cDictSize += 1;
    return(iDictSlots);
}

void *
SIMPLE_DICT::Find (
    int Key
    )
{
    if (Key >= cDictSlots)
        return(NULL);

    return(DictSlots[Key]);
}

void *
SIMPLE_DICT::DeleteItemByBruteForce(
    void * Item
    )
{

    if (Item == 0)
       {
       return (0);
       }

    for (int i = 0; i < cDictSlots; i++)
        {
        if (DictSlots[i] == Item)
           {
           DictSlots[i] = NULL;
           cDictSize -= 1;
           return (Item);
           }
        }

    return (0);
}

void *
SIMPLE_DICT::Delete (
    int Key
    )
{
    void *Item;

    if (Key >= cDictSlots)
        {
        return(NULL);
        }

    Item = DictSlots[Key];
    ASSERT((DictSlots[Key]));

    cDictSize -= 1;
    DictSlots[Key] = NULL;

    return(Item);
}

void *
SIMPLE_DICT::Next (
    )
{
    for ( ; iNextItem < cDictSlots; iNextItem++)
        {
        if (DictSlots[iNextItem])
            return(DictSlots[iNextItem++]);
        }

    iNextItem = NULL;
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\sec2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       sec2var.cxx
//
//  Contents:   
//
//  Functions:  
//
//  History:    25-Apr-97   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


HRESULT
ConvertSidToString(
    PSID pSid,
    LPWSTR   String
    );


HRESULT
ConvertSecDescriptorToVariant(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    VARIANT * pVarSec
    )
{
    IADsSecurityDescriptor * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    LPWSTR pszGroup = NULL;
    LPWSTR pszOwner = NULL;

    BOOL fOwnerDefaulted = 0;
    BOOL fGroupDefaulted = 0;
    BOOL fDaclDefaulted = 0;
    BOOL fSaclDefaulted = 0;

    BOOL fSaclPresent = 0;
    BOOL fDaclPresent = 0;

    LPBYTE pOwnerSidAddress = NULL;
    LPBYTE pGroupSidAddress = NULL;
    LPBYTE pDACLAddress = NULL;
    LPBYTE pSACLAddress = NULL;

    DWORD dwRet = 0;

    VARIANT varDACL;
    VARIANT varSACL;

    HRESULT hr = S_OK;

    DWORD dwRevision = 0;
    WORD  wControl = 0;

    VariantInit(pVarSec);
    memset(&varSACL, 0, sizeof(VARIANT));
    memset(&varDACL, 0, sizeof(VARIANT));

    if (!pSecurityDescriptor) {
        RRETURN(E_FAIL);
    }


    dwRet = GetSecurityDescriptorControl(
                        pSecurityDescriptor,
                        &wControl,
                        &dwRevision
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwRet = GetSecurityDescriptorOwner(
                        pSecurityDescriptor,
                        (PSID *)&pOwnerSidAddress,
                        &fOwnerDefaulted
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = ConvertSidToFriendlyName(
                pOwnerSidAddress,
                &pszOwner
                );
    BAIL_ON_FAILURE(hr);


    dwRet = GetSecurityDescriptorGroup(
                        pSecurityDescriptor,
                        (PSID *)&pGroupSidAddress,
                        &fGroupDefaulted
                        );

    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = ConvertSidToFriendlyName(
                pGroupSidAddress,
                &pszGroup
                );
    BAIL_ON_FAILURE(hr);


    dwRet = GetSecurityDescriptorDacl(
                        pSecurityDescriptor,
                        &fDaclPresent,
                        (PACL*)&pDACLAddress,
                        &fDaclDefaulted
                        );

    if (pDACLAddress) {
        hr = ConvertACLToVariant(
                (PACL)pDACLAddress,
                &varDACL
                );
        BAIL_ON_FAILURE(hr);
    }

    dwRet = GetSecurityDescriptorSacl(
                        pSecurityDescriptor,
                        &fSaclPresent,
                        (PACL *)&pSACLAddress,
                        &fSaclDefaulted
                        );

    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (pSACLAddress) {
        hr = ConvertACLToVariant(
                (PACL)pSACLAddress,
                &varSACL
                );
        BAIL_ON_FAILURE(hr);
    }

    hr = CoCreateInstance(
                CLSID_SecurityDescriptor,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsSecurityDescriptor,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Owner(pszOwner);

    hr = pSecDes->put_Group(pszGroup);

    hr = pSecDes->put_Revision(dwRevision);

    hr = pSecDes->put_Control((DWORD)wControl);

    hr = pSecDes->put_DiscretionaryAcl(V_DISPATCH(&varDACL));

    hr = pSecDes->put_SystemAcl(V_DISPATCH(&varSACL));

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);


    V_VT(pVarSec) = VT_DISPATCH;
    V_DISPATCH(pVarSec) =  pDispatch;

error:

    VariantClear(&varSACL);
    VariantClear(&varDACL);

    if (pszOwner) {
        FreeADsStr(pszOwner);
    }

    if (pszGroup) {
        FreeADsStr(pszGroup);
    }

    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}


HRESULT
ConvertSidToFriendlyName(
    PSID pSid,
    LPWSTR * ppszAccountName
    )
{
    HRESULT hr = S_OK;
    SID_NAME_USE eUse;
    WCHAR szAccountName[MAX_PATH];
    WCHAR szDomainName[MAX_PATH];
    DWORD dwLen = 0;
    DWORD dwRet = 0;

    LPWSTR pszAccountName = NULL;

    DWORD dwAcctLen = 0;
    DWORD dwDomainLen = 0;

    dwAcctLen = sizeof(szAccountName);
    dwDomainLen = sizeof(szDomainName);

    dwRet = LookupAccountSid(
                NULL,
                pSid,
                szAccountName,
                &dwAcctLen,
                szDomainName,
                &dwDomainLen,
                (PSID_NAME_USE)&eUse
                );
    if (!dwRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }else {

        dwLen = wcslen(szAccountName) + wcslen(szDomainName) + 1 + 1;

        pszAccountName = (LPWSTR)AllocADsMem(dwLen * sizeof(WCHAR));
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        if (szDomainName[0] && szAccountName[0]) {
            wsprintf(pszAccountName,L"%s\\%s",szDomainName, szAccountName);
        }else if (szAccountName[0]) {
            wsprintf(pszAccountName,L"%s", szAccountName);
        }
    }

    if (FAILED(hr)) {

        hr = ConvertSidToString(
                    pSid,
                    szAccountName
                    );
        BAIL_ON_FAILURE(hr);

        pszAccountName = AllocADsStr(szAccountName);
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    *ppszAccountName = pszAccountName;

error:

    RRETURN(hr);
}


HRESULT
ConvertACLToVariant(
    PACL pACL,
    PVARIANT pvarACL
    )
{
    IADsAccessControlList * pAccessControlList = NULL;
    IDispatch * pDispatch = NULL;

    VARIANT varAce;
    DWORD dwAclSize = 0;
    DWORD dwAclRevision = 0;
    DWORD dwAceCount = 0;

    ACL_SIZE_INFORMATION AclSize;
    ACL_REVISION_INFORMATION AclRevision;
    DWORD dwStatus = 0;

    DWORD i = 0;
    DWORD dwNewAceCount = 0;

    HRESULT hr = S_OK;
    LPBYTE pAceAddress = NULL;


    memset(&AclSize, 0, sizeof(ACL_SIZE_INFORMATION));
    memset(&AclRevision, 0, sizeof(ACL_REVISION_INFORMATION));


    dwStatus = GetAclInformation(
                        pACL,
                        &AclSize,
                        sizeof(ACL_SIZE_INFORMATION),
                        AclSizeInformation
                        );


    dwStatus = GetAclInformation(
                        pACL,
                        &AclRevision,
                        sizeof(ACL_REVISION_INFORMATION),
                        AclRevisionInformation
                        );

    dwAceCount = AclSize.AceCount;
    dwAclRevision = AclRevision.AclRevision;

    VariantInit(pvarACL);

    hr = CoCreateInstance(
                CLSID_AccessControlList,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlList,
                (void **)&pAccessControlList
                );
    BAIL_ON_FAILURE(hr);

    for (i = 0; i < dwAceCount; i++) {

        dwStatus = GetAce(pACL, i, (void **)&pAceAddress);

        hr = ConvertAceToVariant(
                    pAceAddress,
                    (PVARIANT)&varAce
                    );

        hr = pAccessControlList->AddAce(V_DISPATCH(&varAce));
        if (SUCCEEDED(hr)) {
           dwNewAceCount++;
        }

        VariantClear(&varAce);
    }

    pAccessControlList->put_AclRevision(dwAclRevision);

    pAccessControlList->put_AceCount(dwNewAceCount);


    hr = pAccessControlList->QueryInterface(
                        IID_IDispatch,
                        (void **)&pDispatch
                        );
    V_VT(pvarACL) = VT_DISPATCH;
    V_DISPATCH(pvarACL) = pDispatch;

error:

    if (pAccessControlList) {

        pAccessControlList->Release();
    }

    RRETURN(hr);
}


/* INTRINSA suppress=null_pointers, uninitialized */
HRESULT
ConvertAceToVariant(
    PBYTE pAce,
    PVARIANT pvarAce
    )
{
    IADsAccessControlEntry * pAccessControlEntry = NULL;
    IDispatch * pDispatch = NULL;

    DWORD dwAceType = 0;
    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    LPWSTR pszAccountName = NULL;
    PACE_HEADER pAceHeader = NULL;
    LPBYTE pSidAddress = NULL;
    LPBYTE pOffset = NULL;
    DWORD dwFlags = 0;

    GUID ObjectGUID;
    GUID InheritedObjectGUID;
    WCHAR szObjectGUID[MAX_PATH];
    WCHAR szInheritedObjectGUID[MAX_PATH];

    HRESULT hr = S_OK;

    szObjectGUID[0] = L'\0';
    szInheritedObjectGUID[0] = L'\0';


    VariantInit(pvarAce);

    hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (void **)&pAccessControlEntry
                );
    BAIL_ON_FAILURE(hr);

    pAceHeader = (ACE_HEADER *)pAce;


    dwAceType = pAceHeader->AceType;
    dwAceFlags = pAceHeader->AceFlags;
    dwAccessMask = *(PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        pSidAddress =  (LPBYTE)pAceHeader + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        pOffset = (LPBYTE)((LPBYTE)pAceHeader +  sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
        dwFlags = (DWORD)(*(PDWORD)pOffset);

        //
        // Now advance by the size of the flags
        //
        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            memcpy(&ObjectGUID, pOffset, sizeof(GUID));

            StringFromGUID2(ObjectGUID, szObjectGUID, MAX_PATH);

            pOffset += sizeof (GUID);

        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            memcpy(&InheritedObjectGUID, pOffset, sizeof(GUID));

            StringFromGUID2(InheritedObjectGUID, szInheritedObjectGUID, MAX_PATH);

            pOffset += sizeof (GUID);

        }

        pSidAddress = pOffset;
        break;

    default:
        break;

    }


    hr = ConvertSidToFriendlyName(
                pSidAddress,
                &pszAccountName
                );

    if (FAILED(hr)){
        pszAccountName = AllocADsStr(L"Unknown Trustee");
    }

    //
    // Now set all the information in the Access Control Entry
    //

    hr = pAccessControlEntry->put_AccessMask(dwAccessMask);
    hr = pAccessControlEntry->put_AceFlags(dwAceFlags);
    hr = pAccessControlEntry->put_AceType(dwAceType);

    //
    // Extended ACE information
    //
    hr = pAccessControlEntry->put_Flags(dwFlags);

    if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

        //
        // Add in the Object Type GUID
        //
        hr = pAccessControlEntry->put_ObjectType(szObjectGUID);

    }

    if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

        //
        // Add in the Inherited Object Type GUID
        //

        hr = pAccessControlEntry->put_InheritedObjectType(szInheritedObjectGUID);

    }

    hr = pAccessControlEntry->put_Trustee(pszAccountName);

    hr = pAccessControlEntry->QueryInterface(
                IID_IDispatch,
                (void **)&pDispatch
                );
    BAIL_ON_FAILURE(hr);

    V_DISPATCH(pvarAce) =  pDispatch;
    V_VT(pvarAce) = VT_DISPATCH;

cleanup:

    if (pszAccountName) {

        FreeADsStr(pszAccountName);
    }

    if (pAccessControlEntry) {

        pAccessControlEntry->Release();
    }

    RRETURN(hr);


error:

    if (pDispatch) {

        pDispatch->Release();

    }

    goto cleanup;
}


HRESULT
ConvertSidToString(
    PSID pSid,
    LPWSTR   String
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal


Arguments:

    pSid - opaque pointer that supplies the SID that is to be
    converted to Unicode.

Return Value:

    If the Sid is successfully converted to a Unicode string, a
    pointer to the Unicode string is returned, else NULL is
    returned.

--*/

{
    WCHAR Buffer[256];
    UCHAR   i;
    ULONG   Tmp;
    HRESULT hr = S_OK;

    SID_IDENTIFIER_AUTHORITY    *pSidIdentifierAuthority;
    PUCHAR                      pSidSubAuthorityCount;


    if (!IsValidSid( pSid )) {
        *String= L'\0';
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        RRETURN(hr);
    }

    wsprintf(Buffer, L"S-%u-", (USHORT)(((PISID)pSid)->Revision ));
    wcscpy(String, Buffer);

    pSidIdentifierAuthority = GetSidIdentifierAuthority(pSid);

    if (  (pSidIdentifierAuthority->Value[0] != 0)  ||
          (pSidIdentifierAuthority->Value[1] != 0)     ){
        wsprintf(Buffer, L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)pSidIdentifierAuthority->Value[0],
                    (USHORT)pSidIdentifierAuthority->Value[1],
                    (USHORT)pSidIdentifierAuthority->Value[2],
                    (USHORT)pSidIdentifierAuthority->Value[3],
                    (USHORT)pSidIdentifierAuthority->Value[4],
                    (USHORT)pSidIdentifierAuthority->Value[5] );
        wcscat(String, Buffer);

    } else {

        Tmp = (ULONG)pSidIdentifierAuthority->Value[5]          +
              (ULONG)(pSidIdentifierAuthority->Value[4] <<  8)  +
              (ULONG)(pSidIdentifierAuthority->Value[3] << 16)  +
              (ULONG)(pSidIdentifierAuthority->Value[2] << 24);
        wsprintf(Buffer, L"%lu", Tmp);
        wcscat(String, Buffer);
    }

    pSidSubAuthorityCount = GetSidSubAuthorityCount(pSid);

    for (i=0;i< *(pSidSubAuthorityCount);i++ ) {
        wsprintf(Buffer, L"-%lu", *(GetSidSubAuthority(pSid, i)));
        wcscat(String, Buffer);
    }

    RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\var2sec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       var2sec.cxx
//
//  Contents:
//
//  Functions:
//
//  History:    25-Apr-97   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop



HRESULT
ConvertSecurityDescriptorToSecDes(
    IADsSecurityDescriptor FAR * pSecDes,
    PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    PDWORD pdwSDLength
    )
{
    HRESULT hr = S_OK;

    SECURITY_DESCRIPTOR AbsoluteSD;
    PSECURITY_DESCRIPTOR pRelative = NULL;
    BOOL Defaulted = FALSE;
    BOOL DaclPresent = FALSE;
    BOOL SaclPresent = FALSE;

    BOOL fDaclDefaulted = FALSE;
    BOOL fSaclDefaulted = FALSE;
    BOOL fOwnerDefaulted = FALSE;
    BOOL fGroupDefaulted = FALSE;

    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    DWORD   dwSDLength = 0;
    DWORD dwRet = 0;
    BOOL dwStatus = 0;
    LONG     lControlFlags = 0;
    SECURITY_DESCRIPTOR_CONTROL dwControlFlags = 0;
    SECURITY_DESCRIPTOR_CONTROL dwControlMask = 
                SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED |
                SE_DACL_PROTECTED | SE_SACL_AUTO_INHERIT_REQ |
                SE_SACL_AUTO_INHERITED | SE_SACL_PROTECTED;

    //
    // Initialize *pSizeSD = 0;
    //

    dwRet = InitializeSecurityDescriptor (
                &AbsoluteSD,
                SECURITY_DESCRIPTOR_REVISION1
                );
    if (!dwRet) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = pSecDes->get_Control(&lControlFlags);
    BAIL_ON_FAILURE(hr);
    
    dwControlFlags = dwControlMask & (SECURITY_DESCRIPTOR_CONTROL)lControlFlags;
        
    dwStatus = SetSecurityDescriptorControl(
                &AbsoluteSD,
                dwControlMask,
                dwControlFlags
                );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = GetOwnerSecurityIdentifier(
                pSecDes,
                &pOwnerSid,
                &fOwnerDefaulted
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = SetSecurityDescriptorOwner(
                    &AbsoluteSD,
                    pOwnerSid,
                    fOwnerDefaulted
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetGroupSecurityIdentifier(
                pSecDes,
                &pGroupSid,
                &fGroupDefaulted
                );
    BAIL_ON_FAILURE(hr);


    dwStatus = SetSecurityDescriptorGroup(
                    &AbsoluteSD,
                    pGroupSid,
                    fGroupDefaulted
                    );

    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetDacl(
            pSecDes,
            &pDacl,
            &fDaclDefaulted
            );
    BAIL_ON_FAILURE(hr);


    if (pDacl || fDaclDefaulted) {
        DaclPresent = TRUE;
    }

    dwStatus = SetSecurityDescriptorDacl(
                    &AbsoluteSD,
                    DaclPresent,
                    pDacl,
                    fDaclDefaulted
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }



    hr = GetSacl(
            pSecDes,
            &pSacl,
            &fSaclDefaulted
            );
    BAIL_ON_FAILURE(hr);


    if (pSacl || fSaclDefaulted) {
        SaclPresent = TRUE;
    }

    dwStatus = SetSecurityDescriptorSacl(
                    &AbsoluteSD,
                    SaclPresent,
                    pSacl,
                    fSaclDefaulted
                    );

    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwSDLength = GetSecurityDescriptorLength(
                        &AbsoluteSD
                        );

    pRelative = AllocADsMem(dwSDLength);
    if (!pRelative) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if (!MakeSelfRelativeSD (&AbsoluteSD, pRelative, &dwSDLength)) {
        FreeADsMem(pRelative);

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    *ppSecurityDescriptor = pRelative;
    *pdwSDLength = dwSDLength;

cleanup:

    if (pDacl) {
        FreeADsMem(pDacl);
    }

    if (pSacl) {
        FreeADsMem(pSacl);
    }

    if (pOwnerSid) {
        FreeADsMem(pOwnerSid);
    }

    if (pGroupSid) {
        FreeADsMem(pGroupSid);
    }

    RRETURN(hr);

error:
    if (pRelative) {
        FreeADsMem(pRelative);
    }

    *ppSecurityDescriptor = NULL;
    *pdwSDLength = 0;

    goto cleanup;

}

HRESULT
GetOwnerSecurityIdentifier(
    IADsSecurityDescriptor FAR * pSecDes,
    PSID * ppSid,
    PBOOL pfOwnerDefaulted
    )
{
    BSTR bstrOwner = NULL;
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_Owner(
                    &bstrOwner
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_OwnerDefaulted(
                      &varBool
                      );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {

        if (bstrOwner && *bstrOwner) {

          hr = ConvertTrusteeToSid(
                    bstrOwner,
                    ppSid,
                    &dwSidSize
                    );
          BAIL_ON_FAILURE(hr);
          *pfOwnerDefaulted = FALSE;
        }else {

            *ppSid = NULL;
            *pfOwnerDefaulted = FALSE;
        }

    }else {
        *ppSid = NULL;
        dwSidSize = 0;
        *pfOwnerDefaulted = TRUE;
    }

error:

    if (bstrOwner) {
        ADsFreeString(bstrOwner);
    }

    RRETURN(hr);
}

HRESULT
GetGroupSecurityIdentifier(
    IADsSecurityDescriptor FAR * pSecDes,
    PSID * ppSid,
    PBOOL pfGroupDefaulted
    )
{
    BSTR bstrGroup = NULL;
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_Group(
                    &bstrGroup
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_GroupDefaulted(
                      &varBool
                      );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {

        if (bstrGroup && *bstrGroup) {

            hr = ConvertTrusteeToSid(
                    bstrGroup,
                    ppSid,
                    &dwSidSize
                    );
            BAIL_ON_FAILURE(hr);
            *pfGroupDefaulted = FALSE;
        }else {
            *ppSid = NULL;
            *pfGroupDefaulted = FALSE;
        }

    }else {
        *ppSid = NULL;
        dwSidSize = 0;
        *pfGroupDefaulted = TRUE;
    }

error:

    if (bstrGroup) {
        ADsFreeString(bstrGroup);
    }

    RRETURN(hr);

}

HRESULT
GetDacl(
    IADsSecurityDescriptor FAR * pSecDes,
    PACL * ppDacl,
    PBOOL pfDaclDefaulted
    )
{
    IADsAccessControlList FAR * pDiscAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_DaclDefaulted(
                        &varBool
                        );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {
        *pfDaclDefaulted = FALSE;
    }else {
        *pfDaclDefaulted = TRUE;
    }

    hr = pSecDes->get_DiscretionaryAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        *ppDacl = NULL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pDiscAcl
                    );
    BAIL_ON_FAILURE(hr);


    hr = ConvertAccessControlListToAcl(
                pDiscAcl,
                ppDacl
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pDiscAcl) {
        pDiscAcl->Release();
    }

    RRETURN(hr);
}


HRESULT
GetSacl(
    IADsSecurityDescriptor FAR * pSecDes,
    PACL * ppSacl,
    PBOOL pfSaclDefaulted
    )
{
    IADsAccessControlList FAR * pSystemAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_SaclDefaulted(
                        &varBool
                        );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {
        *pfSaclDefaulted = FALSE;
    }else {
        *pfSaclDefaulted = TRUE;
    }

    hr = pSecDes->get_SystemAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        *ppSacl = NULL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pSystemAcl
                    );
    BAIL_ON_FAILURE(hr);


    hr = ConvertAccessControlListToAcl(
                pSystemAcl,
                ppSacl
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pSystemAcl) {
        pSystemAcl->Release();
    }

    RRETURN(hr);
}

HRESULT
ConvertAccessControlListToAcl(
    IADsAccessControlList FAR * pAccessList,
    PACL * ppAcl
    )
{
    IUnknown * pUnknown = NULL;
    IEnumVARIANT * pEnumerator  = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD cReturned = 0;
    VARIANT varAce;

    DWORD dwAceCount = 0;

    IADsAccessControlEntry FAR * pAccessControlEntry = NULL;
    LPBYTE pTempAce = NULL;
    DWORD dwCount = 0;

    PACL pAcl = NULL;
    DWORD dwAclSize = 0;
    PACE_HEADER * ppAceHdr = NULL;

    DWORD dwRet = 0;
    BOOL  bRet = 0;
    DWORD dwAclRevision = 0;


    hr = pAccessList->get_AceCount((long *)&dwAceCount);
    BAIL_ON_FAILURE(hr);


    hr = pAccessList->get__NewEnum(
                    &pUnknown
                    );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                        IID_IEnumVARIANT,
                        (void FAR * FAR *)&pEnumerator
                        );
    BAIL_ON_FAILURE(hr);



    ppAceHdr = (PACE_HEADER *)AllocADsMem(sizeof(PACE_HEADER)*dwAceCount);
    if (!ppAceHdr) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwAceCount; i++) {

        VariantInit(&varAce);

        hr = pEnumerator->Next(
                    1,
                    &varAce,
                    &cReturned
                    );

        CONTINUE_ON_FAILURE(hr);


        hr = (V_DISPATCH(&varAce))->QueryInterface(
                    IID_IADsAccessControlEntry,
                    (void **)&pAccessControlEntry
                    );
        CONTINUE_ON_FAILURE(hr);

        hr = ConvertAccessControlEntryToAce(
                    pAccessControlEntry,
                    &(pTempAce)
                    );

        VariantClear(&varAce);
        if (pAccessControlEntry) {
            pAccessControlEntry->Release();
            pAccessControlEntry = NULL;
        }

        BAIL_ON_FAILURE(hr);

        *(ppAceHdr + dwCount) = (PACE_HEADER)pTempAce;

        dwCount++;
    }

    hr = ComputeTotalAclSize(ppAceHdr, dwCount, &dwAclSize);
    BAIL_ON_FAILURE(hr);

    pAcl = (PACL)AllocADsMem(dwAclSize);
    if (!pAcl) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

#if 0
    hr = pAccessList->get_AclRevision((long *)&dwAclRevision);
    BAIL_ON_FAILURE(hr);
#else
    dwAclRevision = ACL_REVISION;
#endif


    bRet  = InitializeAcl(
                    pAcl,
                    dwAclSize,
                    dwAclRevision
                    );

    if (!bRet) {
       dwRet = GetLastError();
       hr = HRESULT_FROM_WIN32(dwRet);
       BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwCount; i++) {

        bRet = AddAce(
            pAcl,
            dwAclRevision,
            i,
            (LPBYTE)*(ppAceHdr + i),
            (*(ppAceHdr + i))->AceSize
            );
        if (!bRet) {
           dwRet = GetLastError();
           hr = HRESULT_FROM_WIN32(dwRet);
           BAIL_ON_FAILURE(hr);
        }
    }

    *ppAcl = pAcl;

error:

    if (ppAceHdr) {
        for (i = 0; i < dwCount; i++) {
            if (*(ppAceHdr + i)) {

                FreeADsMem(*(ppAceHdr + i));
            }
        }

        FreeADsMem(ppAceHdr);
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pEnumerator) {
        pEnumerator->Release();
    }


    RRETURN(hr);
}

HRESULT
ConvertAccessControlEntryToAce(
    IADsAccessControlEntry * pAccessControlEntry,
    LPBYTE * ppAce
    )
{

    DWORD dwAceType = 0;
    HRESULT hr = S_OK;
    BSTR bstrTrustee = NULL;
    PSID pSid = NULL;
    DWORD dwSidSize = 0;

    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    DWORD dwAceSize = 0;
    LPBYTE pAce = NULL;
    PACCESS_MASK pAccessMask = NULL;
    PSID pSidAddress = NULL;

    PUSHORT pCompoundAceType = NULL;
    DWORD dwCompoundAceType = 0;

    PACE_HEADER pAceHeader = NULL;

    LPBYTE pOffset = NULL;

    BSTR bstrObjectTypeClsid = NULL;
    BSTR bstrInheritedObjectTypeClsid = NULL;

    GUID ObjectTypeGUID;
    GUID InheritedObjectTypeGUID;
    PULONG pFlags;
    DWORD dwFlags = 0;


    hr = pAccessControlEntry->get_AceType((LONG *)&dwAceType);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_Trustee(&bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = ConvertTrusteeToSid(
                bstrTrustee,
                &pSid,
                &dwSidSize
                );
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AceFlags((long *)&dwAceFlags);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AccessMask((long *)&dwAccessMask);
    BAIL_ON_FAILURE(hr);

    //
    // we will compensateby adding the entire ACE size
    //

    dwAceSize = dwSidSize - sizeof(ULONG);

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_DENIED_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;


        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;


        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case SYSTEM_AUDIT_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;


        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;


        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        dwAceSize += sizeof(COMPOUND_ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

         pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pCompoundAceType = (PUSHORT)(pAccessMask + sizeof(ACCESS_MASK));
        *pCompoundAceType = (USHORT)dwCompoundAceType;

        //
        // Fill in the reserved field here.
        //

        pSidAddress = (PSID)((LPBYTE)pCompoundAceType + sizeof(DWORD));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

    case ACCESS_DENIED_OBJECT_ACE_TYPE:

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:


        hr = pAccessControlEntry->get_AceFlags((LONG *)&dwAceFlags);
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlEntry->get_Flags((LONG *)&dwFlags);
        BAIL_ON_FAILURE(hr);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {
            dwAceSize += sizeof(GUID);
        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            dwAceSize += sizeof(GUID);
        }

        hr = pAccessControlEntry->get_ObjectType(&bstrObjectTypeClsid);
        BAIL_ON_FAILURE(hr);

        hr = CLSIDFromString(bstrObjectTypeClsid, &ObjectTypeGUID);
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlEntry->get_InheritedObjectType(&bstrInheritedObjectTypeClsid);
        BAIL_ON_FAILURE(hr);

        hr = CLSIDFromString(bstrInheritedObjectTypeClsid, &InheritedObjectTypeGUID);
        BAIL_ON_FAILURE(hr);



        dwAceSize += sizeof(ACCESS_ALLOWED_OBJECT_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        //
        // Fill in Flags
        //

        pOffset = (LPBYTE)((LPBYTE)pAceHeader +  sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));

        pFlags = (PULONG)(pOffset);

        *pFlags = dwFlags;

        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            memcpy(pOffset, &ObjectTypeGUID, sizeof(GUID));

            pOffset += sizeof(GUID);

        }


        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

            memcpy(pOffset, &InheritedObjectTypeGUID, sizeof(GUID));

            pOffset += sizeof(GUID);
        }

        pSidAddress = (PSID)((LPBYTE)pOffset);
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    }

    *ppAce = pAce;

error:

    if (bstrTrustee) {
        ADsFreeString(bstrTrustee);
    }

    if (pSid) {
        FreeADsMem(pSid);
    }

    RRETURN(hr);
}

HRESULT
ComputeTotalAclSize(
    PACE_HEADER * ppAceHdr,
    DWORD dwAceCount,
    PDWORD pdwAclSize
    )
{
    DWORD i = 0;
    PACE_HEADER pAceHdr = NULL;
    DWORD dwAceSize = 0;
    DWORD dwAclSize = 0;

    for (i = 0; i < dwAceCount; i++) {

        pAceHdr = *(ppAceHdr + i);
        dwAceSize = pAceHdr->AceSize;
        dwAclSize += dwAceSize;
    }

    dwAclSize += sizeof(ACL);

    *pdwAclSize = dwAclSize;

    RRETURN(S_OK);

}


HRESULT
ConvertTrusteeToSid(
    BSTR bstrTrustee,
    PSID * ppSid,
    PDWORD pdwSidSize
    )
{
    HRESULT hr = S_OK;
    BYTE Sid[MAX_PATH];
    DWORD dwSidSize = sizeof(Sid);
    DWORD dwRet = 0;
    WCHAR szDomainName[MAX_PATH];
    DWORD dwDomainSize = sizeof(szDomainName)/sizeof(WCHAR);
    SID_NAME_USE eUse;
    LPWSTR pszTrustee = (LPWSTR)bstrTrustee;

    PSID pSid = NULL;

    dwSidSize = sizeof(Sid);

    if ((*pszTrustee == (WCHAR)'\\') || (*pszTrustee == WCHAR('/'))){
        pszTrustee++;
    }

    dwRet = LookupAccountName(
                NULL,
                pszTrustee,
                Sid,
                &dwSidSize,
                szDomainName,
                &dwDomainSize,
                (PSID_NAME_USE)&eUse
                );

    if (!dwRet) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    pSid = AllocADsMem(dwSidSize);
    if (!pSid) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(pSid, Sid, dwSidSize);

    *pdwSidSize = dwSidSize;

    *ppSid = pSid;

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\sources.inc ===
!IF 0

Copyright (c) 1995-96  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:


NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

DLLDEF=..\iis.def
TARGETTYPE=DYNLINK
DLLENTRY=_DllMainCRTStartup
TARGETPATH=obj

INCLUDES= ..;\
          ..\$(O);\
          $(O);\
          $(IISBASEDIR)\staxinc;\
          $(IISBASEDIR)\inc;\
          $(IISBASEDIR)\inc\$(O);\
          $(IISBASEDIR)\svcs\infocomm\common; \
	  $(IISBASEDIR)\svcs\nntp\core\include; \
	  $(IISBASEDIR)\staxinc\export; \
          ..\..\oleds2.0\include;

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=\
        ..\iis.rc \
        ..\cprovcf.cxx \
        ..\cprov.cxx \
        ..\cnamcf.cxx \
        ..\cnamesp.cxx \
        ..\cenumns.cxx \
        ..\ctree.cxx \
        ..\cenumt.cxx \
        ..\cgenobj.cxx \
        ..\cschobj.cxx \
        ..\cschema.cxx \
        ..\cenumsch.cxx \
        ..\cenumvar.cxx \
        ..\cenumobj.cxx \
        ..\cmimecf.cxx   \
        ..\cmime.cxx \
        ..\cipseccf.cxx  \
        ..\cipsec.cxx \
        ..\cpobjcf.cxx  \
        ..\cpobj.cxx \
        ..\cprops.cxx \
        ..\var2sec.cxx \
        ..\sec2var.cxx \
        ..\common.cxx \
        ..\core.cxx \
        ..\object.cxx \
        ..\getobj.cxx \
        ..\parse.cxx \
        ..\libmain.cxx \
        ..\cdispmgr.cxx \
        ..\cextmgr.cxx \
        ..\extension.cxx \
        ..\iismrshl.cxx \
        ..\iisurshl.cxx \
        ..\iiscopy.cxx \
        ..\iisfree.cxx \
        ..\iis2var.cxx \
        ..\var2iis.cxx \
        ..\schemini.cxx \
        ..\charset.cxx \
        ..\sdict.cxx \
        ..\svrcache.cxx \
        ..\guid.c

UMTYPE=console

TARGETLIBS = \
             $(SDK_LIB_PATH)\uuid.lib  \
             $(SDK_LIB_PATH)\imagehlp.lib \
             $(SDK_LIB_PATH)\ole32.lib    \
             $(SDK_LIB_PATH)\advapi32.lib \
             $(SDK_LIB_PATH)\comdlg32.lib \
             $(SDK_LIB_PATH)\kernel32.lib \
             $(SDK_LIB_PATH)\shell32.lib  \
             $(SDK_LIB_PATH)\user32.lib   \
             $(SDK_LIB_PATH)\gdi32.lib    \
             $(SDK_LIB_PATH)\oleaut32.lib \
             $(SDK_LIB_PATH)\ws2_32.lib   \
             $(SDK_LIB_PATH)\activeds.lib \
             $(SDK_LIB_PATH)\adsiid.lib   \
             $(IISBASEDIR)\svcs\iisrtl\$(O)\iisrtl.lib   \
             $(SDK_LIB_PATH)\crypt32.lib  \
             $(IISBASEDIR)\svcs\infocomm\rdns\$(O)\isrdns.lib  \
             $(IISBASEDIR)\admin\adsi\helper\noole\winnt\$(O)\noole.lib      \
             $(IISBASEDIR)\admin\adsi\helper\nocairo\winnt\$(O)\nocairo.lib    \
             $(IISBASEDIR)\admin\adsi\helper\utils\winnt\$(O)\noutils.lib    

C_DEFINES=$(C_DEFINES) -DDAYTONA -DCAL_ENABLED

PRECOMPILED_INCLUDE=..\iis.hxx
PRECOMPILED_OBJ=iis.obj
PRECOMPILED_PCH=iis.pch
PRECOMPILED_CXX=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\var2iis.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       var2IIS.cxx
//
//  Contents:   IIS Object to Variant Copy Routines
//
//  Functions:
//
//  History:    01-Mar-97   SophiaC   Created.
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------
#include "iis.hxx"

//
// IISType objects copy code
//


HRESULT
VarTypeToIISTypeCopyIISSynIdDWORD(
								  PVARIANT lpVarSrcObject,
								  PIISOBJECT lpIISDestObject
								 )
{
    HRESULT hr = S_OK;


    hr = VariantChangeType(lpVarSrcObject,
                           lpVarSrcObject,
                           0,
                           VT_UI4);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_DWORD;

    lpIISDestObject->IISValue.value_1.dwDWORD =
                            lpVarSrcObject->lVal;

    RRETURN(hr);
}

HRESULT
VarTypeToIISTypeCopyIISSynIdSTRING(
								   PVARIANT lpVarSrcObject,
								   PIISOBJECT lpIISDestObject
								  )
{
    HRESULT hr = S_OK;

    hr = VariantChangeType(lpVarSrcObject,
                           lpVarSrcObject,
                           0,
                           VT_BSTR);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_STRING;

    lpIISDestObject->IISValue.value_2.String =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    RRETURN(hr);
}


HRESULT
VarTypeToIISTypeCopyIISSynIdEXPANDSZ(
									 PVARIANT lpVarSrcObject,
									 PIISOBJECT lpIISDestObject
									)

{
    HRESULT hr = S_OK;

    hr = VariantChangeType(lpVarSrcObject,
                           lpVarSrcObject,
                           0,
                           VT_BSTR);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_EXPANDSZ;

    lpIISDestObject->IISValue.value_3.ExpandSz =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    RRETURN(hr);

}

HRESULT
VarTypeToIISTypeCopyIISSynIdMULTISZ(
									PVARIANT lpVarSrcObject,
									PIISOBJECT lpIISDestObject
								   )
{
    HRESULT hr = S_OK;

    hr = VariantChangeType(lpVarSrcObject,
                           lpVarSrcObject,
                           0,
                           VT_BSTR);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_MULTISZ;

    lpIISDestObject->IISValue.value_4.MultiSz =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    RRETURN(hr);
}

HRESULT
VarTypeToIISTypeCopyIISSynIdMIMEMAP(
									PVARIANT lpVarSrcObject,
									PIISOBJECT lpIISDestObject
								   )
{
    HRESULT hr = S_OK;
    LPWSTR pszStr;
    IISMimeType * pMimeType = NULL;

    if(lpVarSrcObject->vt != VT_DISPATCH){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_MIMEMAP;
    pMimeType = (IISMimeType *)lpVarSrcObject->pdispVal;

    hr = ((CMimeType*) pMimeType)->CopyMimeType(
                        &pszStr
                        );
    BAIL_ON_FAILURE(hr);

    lpIISDestObject->IISValue.value_6.MimeMap = pszStr;

error:

    RRETURN(hr);
}




HRESULT
VarTypeToIISTypeCopyIISSynIdBinary(
    PVARIANT lpVarSrcObject,
    PIISOBJECT lpIISDestObject,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;

    if (bReturnBinaryAsVT_VARIANT)
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_VARIANT);
    }
    else
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_UI1);
    }

    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (bReturnBinaryAsVT_VARIANT)
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_VARIANT)) {
            RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }
    }
    else
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_UI1)) {
            RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }
    }

    hr = SafeArrayGetLBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    lpIISDestObject->IISValue.value_5.Binary = (LPBYTE) AllocADsMem(dwSUBound - dwSLBound + 1);
    if (lpIISDestObject->IISValue.value_5.Binary == NULL)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_BINARY;
    lpIISDestObject->IISValue.value_5.Length = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(lpVarSrcObject),(void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);
    memcpy( lpIISDestObject->IISValue.value_5.Binary,pArray,dwSUBound-dwSLBound+1);
    SafeArrayUnaccessData( V_ARRAY(lpVarSrcObject) );

error:
    RRETURN(hr);
}


HRESULT
VarTypeToIISTypeCopyIISSynIdNTACL(
    PVARIANT lpVarSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;
    IADsSecurityDescriptor FAR * pSecDes = NULL;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD Length = 0;
    IDispatch FAR * pDispatch = NULL;

    if(lpVarSrcObject->vt != VT_DISPATCH){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_BINARY;
    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsSecurityDescriptor,
                    (void **)&pSecDes
                    );
    BAIL_ON_FAILURE(hr);

    hr = ConvertSecurityDescriptorToSecDes(
                pSecDes,
                &pSecurityDescriptor,
                &Length
                );
    BAIL_ON_FAILURE(hr);

    lpIISDestObject->IISValue.value_5.Binary = (LPBYTE)AllocADsMem(Length);
    if ((lpIISDestObject->IISValue.value_5.Binary) == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpIISDestObject->IISValue.value_5.Length = Length;
    memcpy(lpIISDestObject->IISValue.value_5.Binary, pSecurityDescriptor,
           Length);

error:

    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToIISTypeCopyIISSynIdIPSECLIST(
    PVARIANT lpVarSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;
    LPBYTE pBuffer;  
    DWORD Length = 0;
    IISIPSecurity * pIPSec = NULL;

    if(lpVarSrcObject->vt != VT_DISPATCH){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_IPSECLIST;
    pIPSec = (IISIPSecurity*)lpVarSrcObject->pdispVal;

    hr = ((CIPSecurity*) pIPSec)->CopyIPSecurity(
                        &pBuffer, 
                        &Length
                        );

	if (pBuffer == NULL) {
		RRETURN(E_OUTOFMEMORY);
	}

    lpIISDestObject->IISValue.value_5.Length = Length;
    lpIISDestObject->IISValue.value_5.Binary = (LPBYTE)AllocADsMem(Length);
    memcpy(lpIISDestObject->IISValue.value_5.Binary, pBuffer, Length);

    RRETURN(hr);
}


HRESULT
VarTypeToIISTypeCopyIISSynIdBOOL(
								 PVARIANT lpVarSrcObject,
								 PIISOBJECT lpIISDestObject
								)
{
    HRESULT hr = S_OK;

    hr = VariantChangeType(lpVarSrcObject,
                           lpVarSrcObject,
                           0,
                           VT_BOOL);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_BOOL;

    lpIISDestObject->IISValue.value_1.dwDWORD =
                            (lpVarSrcObject->boolVal) ? 1 : 0;

    RRETURN(hr);
}

HRESULT
VarTypeToIISTypeCopyIISSynIdBOOLBITMASK(
										PVARIANT lpVarSrcObject,
										PIISOBJECT lpIISDestObject
									   )
{
    HRESULT hr = S_OK;

    hr = VariantChangeType(lpVarSrcObject,
                           lpVarSrcObject,
                           0,
                           VT_BOOL);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_BOOL_BITMASK;

    lpIISDestObject->IISValue.value_1.dwDWORD =
        (lpVarSrcObject->boolVal) ? 1 : 0;

    RRETURN(hr);
}


HRESULT
VarTypeToIISTypeCopy(
    DWORD dwIISType,
    PVARIANT lpVarSrcObject,
    PIISOBJECT lpIISDestObject,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    HRESULT hr = S_OK;
    switch (dwIISType){
    case IIS_SYNTAX_ID_DWORD:
        hr = VarTypeToIISTypeCopyIISSynIdDWORD(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_STRING:
        hr = VarTypeToIISTypeCopyIISSynIdSTRING(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;


    case IIS_SYNTAX_ID_EXPANDSZ:
        hr = VarTypeToIISTypeCopyIISSynIdEXPANDSZ(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_MULTISZ:
        hr = VarTypeToIISTypeCopyIISSynIdMULTISZ(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_MIMEMAP:
        hr = VarTypeToIISTypeCopyIISSynIdMIMEMAP(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_NTACL:
        hr = VarTypeToIISTypeCopyIISSynIdNTACL(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_BINARY:
        hr = VarTypeToIISTypeCopyIISSynIdBinary(
                lpVarSrcObject,
                lpIISDestObject,
                bReturnBinaryAsVT_VARIANT
                );
        break;

    case IIS_SYNTAX_ID_IPSECLIST:
        hr = VarTypeToIISTypeCopyIISSynIdIPSECLIST(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_BOOL:
        hr = VarTypeToIISTypeCopyIISSynIdBOOL(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_BOOL_BITMASK:
        hr = VarTypeToIISTypeCopyIISSynIdBOOLBITMASK(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
VarTypeToIISTypeCopyConstruct(
    DWORD dwIISType,
    LPVARIANT pVarSrcObjects,
    DWORD dwNumObjects,
    LPIISOBJECT * ppIISDestObjects,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{

    DWORD i = 0;
    LPIISOBJECT pIISDestObjects = NULL;
    HRESULT hr = S_OK;

    pIISDestObjects = (LPIISOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(IISOBJECT)
                                    );

    if (!pIISDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = VarTypeToIISTypeCopy(
                    dwIISType,
                    pVarSrcObjects + i,
                    pIISDestObjects + i,
                    bReturnBinaryAsVT_VARIANT
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppIISDestObjects = pIISDestObjects;

     RRETURN(S_OK);

error:

     if (pIISDestObjects) {

        IISTypeFreeIISObjects(
                pIISDestObjects,
                dwNumObjects
                );
     }

     *ppIISDestObjects = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\oleds.inc ===
OLEDSLIB_W95=$(PROJECT_ROOT)\adsi\public\lib\win95

!IF "$(ADSI_NT40_BUILD)" == "1"
C_DEFINES=$(C_DEFINES) -DBUILD_FOR_NT40 -DUSE_DS_VER
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\sources.inc ===
!INCLUDE ..\common\sources
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\adsiis\iis51\globdata.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  globdata.cxx
//
//  Contents:  Microsoft ADs IIS Provider schema/property tables
//
//  History:   28-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include "nntpmeta.h"
#include "smtpinet.h"
#include "pop3s.h"
#include "imaps.h"
#include "w3svc.h"

// Include iwamreg.h for EAppMode values
#include <iwamreg.h>

WCHAR *szProviderName = L"IIS";

#define MAX_LONG    (0x7FFFFFFF)
#define MIN_LONG    (0x80000000)
#define MAX_BOOLEAN 1
#define MAX_STRLEN  (256)

#define PROP_RW     0x0000001
#define PROP_RO     0x0000002

// -------------------------------------------------------------
// DANGER! DANGER! DANGER!
// 
// If you modify the property list for a class make sure there
// is a comma (,) between each name. Generally this means there
// should be a comma at the end of each line.
//
//--------------------------------------------------------------

CLASSINFO g_aIISClasses[] =
{
        //
        // IIS Classes
        //
        {
                TEXT("IIsObject"),      // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsComputer"),    // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxBandwidthBlocked,MimeMap"),
                NULL,
                TEXT("IIsObject,IIsWebService,IIsFtpService,IIsMimeMap,IIsNntpService,IIsSmtpService,IIsPop3Service,IIsImapService"),
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebService"),  // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,MaxConnections,MimeMap,AnonymousUserName,AnonymousUserPass,IgnoreTranslate,UseDigestSSP,")
                TEXT("ServerListenBacklog,ServerComment,ServerBindings,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AllowKeepAlive,ServerSize,DisableSocketPooling,AnonymousPasswordSync,DefaultLogonDomain,AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("Realm,EnableDirBrowsing,DefaultDoc,HttpExpires,HttpPics,HttpCustomHeaders,HttpErrors,")
                TEXT("EnableDocFooter,DefaultDocFooter,HttpRedirect,LogonMethod,")
                TEXT("CacheISAPI,CGITimeOut,DirectoryLevelsToScan,ContentIndexed,")
                TEXT("NTAuthenticationProviders,AuthBasic,AuthAnonymous,")
                TEXT("AuthNTLM,AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,CertCheckMode,RevocationFreshnessTime,RevocationURLRetrievalTimeout,")
                TEXT("CertNoRevocCheck,CertCacheRetrievalOnly,CertCheckRevocationFreshnessTime,CertNoUsageCheck,")
                TEXT("AccessSSLMapCert,AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("AspBufferingOn,AspLogErrorRequests,AspScriptErrorSentToBrowser,AspScriptErrorMessage,AspAllowOutOfProcComponents,")
                TEXT("AspScriptFileCacheSize,AspDiskTemplateCacheDirectory,AspMaxDiskTemplateCacheFiles,AspScriptEngineCacheMax,AspScriptTimeout,AspSessionTimeout,")
                TEXT("AspEnableParentPaths,AspAllowSessionState,AspScriptLanguage,")
                TEXT("AspExceptionCatchEnable,AspCodepage,AspLCID,")
                TEXT("AspQueueTimeout,AspEnableAspHtmlFallback,AspEnableChunkedEncoding,")
                TEXT("AspEnableTypelibCache,AspErrorsToNTLog,AspProcessorThreadMax,")
                TEXT("AspTrackThreadingModel,AspRequestQueueMax,AspEnableApplicationRestart,")
                TEXT("AspQueueConnectionTestTime,AspSessionMax,")
                TEXT("AspThreadGateEnabled,AspThreadGateTimeSlice,AspThreadGateSleepDelay,")
                TEXT("AspThreadGateSleepMax,AspThreadGateLoadLow,AspThreadGateLoadHigh,")
                TEXT("AppRoot,AppFriendlyName,AppIsolated,AppPackageID,AppPackageName,AppAllowDebugging,AppAllowClientDebug,AspKeepSessionIDSecure,")
                TEXT("NetLogonWorkstation,UseHostName,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("PasswordExpirePrenotifyDays,PasswordCacheTTL,")
                TEXT("PasswordChangeFlags,")
                TEXT("UNCAuthenticationPassThrough,AppWamClsid,")
                TEXT("DirBrowseFlags,AuthFlags,AuthMD5,")
                TEXT("AuthPersistence,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole,")
                TEXT("ProcessNTCRIfLoggedOn,AllowPathInfoForScriptMappings,InProcessIsapiApps,")
                TEXT("EnableDefaultDoc,DirBrowseShowDate,DirBrowseShowTime,DirBrowseShowSize,DirBrowseShowExtension,DirBrowseShowLongDate,")
                TEXT("LogType,LogFilePeriod,LogFileLocaltimeRollover,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("CPUCGILimit,CPULimitLogEvent,CPULimitPriority,CPULimitProcStop,")
                TEXT("CPULimitPause,CPULoggingEnabled,CPULimitsEnabled,CPUResetInterval,")
                TEXT("CPULoggingInterval,CPULoggingOptions,CPUEnableAllProcLogging,")
                TEXT("CPUEnableCGILogging,CPUEnableAppLogging,CPULoggingMask,")
                TEXT("CPUEnableEvent,CPUEnableProcType,CPUEnableUserTime,")
                TEXT("CPUEnableKernelTime,CPUEnablePageFaults,CPUEnableTotalProcs,")
                TEXT("CPUEnableActiveProcs,CPUEnableTerminatedProcs,")
                TEXT("CPUAppEnabled,CPUCGIEnabled,SslUseDsMapper,")
                TEXT("WAMUserName,WAMUserPass,")
                TEXT("PeriodicRestartRequests,PeriodicRestartTime,PeriodicRestartSchedule,ShutdownTimeLimit,")
                TEXT("SSLCertHash,SSLStoreName")
#if defined(CAL_ENABLED)
                TEXT(",CalVcPerConnect,CalLimitHttpError,CalReserveTimeout,CalSSLReserveTimeout")
#endif
                ,NULL,
                TEXT("IIsObject,IIsWebInfo,IIsWebServer,IIsFilters"),
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsFtpService"),  // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,MaxConnections,AnonymousUserName,AnonymousUserPass,")
                TEXT("ServerListenBacklog,LogAnonymous,LogNonAnonymous,")
                TEXT("ServerComment,ServerBindings,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ExitMessage,GreetingMessage,BannerMessage,MaxClientsMessage,AnonymousOnly,MSDOSDirOutput,")
                TEXT("ServerSize,DisableSocketPooling,AnonymousPasswordSync,AllowAnonymous,DefaultLogonDomain,AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("DirectoryLevelsToScan,Realm,")
                TEXT("LogType,LogFilePeriod,LogFileLocaltimeRollover,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("FtpDirBrowseShowLongDate,AccessFlags,AccessRead,AccessWrite"),
                NULL,
                TEXT("IIsObject,IIsFtpInfo,IIsFtpServer"),
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebServer"),   // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("ContentIndexed,KeyType,ServerState,ServerComment,MaxBandwidth,")
                TEXT("ServerAutoStart,ServerSize,DisableSocketPooling,ServerListenBacklog,ServerListenTimeout,ServerBindings,SecureBindings,MaxConnections,ConnectionTimeout,")
                TEXT("AllowKeepAlive,CGITimeout,MaxEndpointConnections,IgnoreTranslate,UseDigestSSP,")
                TEXT("CacheISAPI,MimeMap,AnonymousUserName,AnonymousUserPass,FrontPageWeb,")
                TEXT("AnonymousPasswordSync,DefaultLogonDomain,AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("Realm,EnableDirBrowsing,DefaultDoc,HttpExpires,HttpPics,HttpCustomHeaders,HttpErrors,")
                TEXT("EnableDocFooter,DefaultDocFooter,HttpRedirect,LogonMethod,")
                TEXT("NTAuthenticationProviders,AuthBasic,AuthAnonymous,")
                TEXT("AuthNTLM,AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,CertCheckMode,RevocationFreshnessTime,RevocationURLRetrievalTimeout,")
                TEXT("CertNoRevocCheck,CertCacheRetrievalOnly,CertCheckRevocationFreshnessTime,CertNoUsageCheck,")
                TEXT("AccessSSLMapCert,AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("AspBufferingOn,AspLogErrorRequests,AspScriptErrorSentToBrowser,AspScriptErrorMessage,AspAllowOutOfProcComponents,")
                TEXT("AspScriptFileCacheSize,AspDiskTemplateCacheDirectory,AspMaxDiskTemplateCacheFiles,AspScriptEngineCacheMax,AspScriptTimeout,")
                TEXT("AspEnableParentPaths,AspAllowSessionState,AspScriptLanguage,")
                TEXT("AspExceptionCatchEnable,AspCodepage,AspLCID,AspSessionTimeout,")
                TEXT("AspQueueTimeout,AspEnableAspHtmlFallback,AspEnableChunkedEncoding,")
                TEXT("AspEnableTypelibCache,AspErrorsToNTLog,AspProcessorThreadMax,")
                TEXT("AspTrackThreadingModel,AspRequestQueueMax,AspEnableApplicationRestart,")
                TEXT("AspQueueConnectionTestTime,AspSessionMax,")
                TEXT("AspThreadGateEnabled,AspThreadGateTimeSlice,AspThreadGateSleepDelay,")
                TEXT("AspThreadGateSleepMax,AspThreadGateLoadLow,AspThreadGateLoadHigh,")
                TEXT("AppRoot,AppFriendlyName,AppIsolated,AppPackageID,AppPackageName,AppOopRecoverLimit,")
                TEXT("AppAllowDebugging,AppAllowClientDebug,AspKeepSessionIDSecure,")
                TEXT("NetLogonWorkstation,UseHostName,ClusterEnabled,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("PasswordExpirePrenotifyDays,PasswordCacheTTL,")
                TEXT("PasswordChangeFlags,MaxBandwidthBlocked,")
                TEXT("UNCAuthenticationPassThrough,AppWamClsid,")
                TEXT("DirBrowseFlags,AuthFlags,AuthMD5,")
                TEXT("AuthPersistence,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole,")
                TEXT("EnableDefaultDoc,DirBrowseShowDate,DirBrowseShowTime,DirBrowseShowSize,DirBrowseShowExtension,DirBrowseShowLongDate,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileLocaltimeRollover,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("CPULoggingEnabled,CPULimitsEnabled,CPUResetInterval,")
                TEXT("CPULoggingInterval,CPULoggingOptions,CPUEnableAllProcLogging,")
                TEXT("CPUEnableCGILogging,CPUEnableAppLogging,CPULoggingMask,")
                TEXT("CPUEnableEvent,CPUEnableProcType,CPUEnableUserTime,")
                TEXT("CPUEnableKernelTime,CPUEnablePageFaults,CPUEnableTotalProcs,")
                TEXT("CPUEnableActiveProcs,CPUEnableTerminatedProcs,CPUCGILimit,")
                TEXT("CPULimitLogEvent,CPULimitPriority,CPULimitProcStop,")
                TEXT("CPULimitPause,CPUAppEnabled,CPUCGIEnabled,NotDeletable,")
                TEXT("PeriodicRestartRequests,PeriodicRestartTime,PeriodicRestartSchedule,ShutdownTimeLimit,")
                TEXT("SSLCertHash,SSLStoreName,")
                TEXT("ProcessNTCRIfLoggedOn,AllowPathInfoForScriptMappings"),
                NULL,
                TEXT("IIsObject,IIsCertMapper,IIsFilters,IIsWebVirtualDir"),
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsFtpServer"),   // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,MaxConnections,ServerState,AnonymousUserName,AnonymousUserPass,")
                TEXT("ServerListenBacklog,DisableSocketPooling,LogAnonymous,LogNonAnonymous,")
                TEXT("ServerComment,ServerBindings,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ExitMessage,GreetingMessage,BannerMessage,MaxClientsMessage,AnonymousOnly,MSDOSDirOutput,")
                TEXT("ServerSize,AnonymousPasswordSync,AllowAnonymous,DefaultLogonDomain,AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("Realm,ClusterEnabled,FtpDirBrowseShowLongDate,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileLocaltimeRollover,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("AccessFlags,AccessRead,AccessWrite"),
                NULL,
                TEXT("IIsObject,IIsFtpVirtualDir"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsWebFile"),     // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,AnonymousUserName,AnonymousUserPass,AnonymousPasswordSync,")
                TEXT("AuthBasic,AuthAnonymous,AuthNTLM,UNCAuthenticationPassThrough,IgnoreTranslate,UseDigestSSP,")
                TEXT("CGITimeOut,DefaultLogonDomain,LogonMethod,Realm,MimeMap,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,IPSecurity,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("DontLog,HttpExpires,HttpPics,HttpCustomHeaders,HttpErrors,EnableDocFooter,DefaultDocFooter,HttpRedirect,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("AuthFlags,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AuthMD5,AuthPersistence,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("CPUAppEnabled,CPUCGIEnabled,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole"),
                NULL,                           // Inherits from
                NULL,   // Can Contain
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebDirectory"),// Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,AnonymousUserName,AnonymousUserPass,AnonymousPasswordSync,IgnoreTranslate,UseDigestSSP,")
                TEXT("AppRoot,AppFriendlyName,AppOopRecoverLimit,AppIsolated,AppPackageName,AppPackageID,")
                TEXT("AuthBasic,AuthAnonymous,AuthNTLM,")
                TEXT("CacheISAPI,AppAllowDebugging,AppAllowClientDebug,AspKeepSessionIDSecure,")
                TEXT("DefaultLogonDomain,LogonMethod,")
                TEXT("CGITimeOut,Realm,EnableDefaultDoc,")
                TEXT("DirBrowseShowDate,DirBrowseShowTime,DirBrowseShowSize,DirBrowseShowExtension,DirBrowseShowLongDate,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,IPSecurity,DontLog,HttpExpires,HttpPics,HttpCustomHeaders,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("HttpErrors,EnableDocFooter,DefaultDocFooter,HttpRedirect,")
                TEXT("EnableDirBrowsing,DefaultDoc,ContentIndexed,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("FrontPageWeb,UNCAuthenticationPassThrough,AppWamClsid,")
                TEXT("AuthPersistence,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole,")
                TEXT("AspBufferingOn,AspLogErrorRequests,AspScriptErrorSentToBrowser,AspScriptErrorMessage,AspAllowOutOfProcComponents,")
                TEXT("AspScriptFileCacheSize,AspDiskTemplateCacheDirectory,AspMaxDiskTemplateCacheFiles,AspScriptEngineCacheMax,AspScriptTimeout,AspSessionTimeout,")
                TEXT("AspEnableParentPaths,AspAllowSessionState,AspScriptLanguage,")
                TEXT("AspExceptionCatchEnable,AspCodepage,AspLCID,MimeMap,")
                TEXT("AspQueueTimeout,CPUAppEnabled,CPUCGIEnabled,")
                TEXT("AspEnableAspHtmlFallback,AspEnableChunkedEncoding,")
                TEXT("AspEnableTypelibCache,AspErrorsToNTLog,AspProcessorThreadMax,")
                TEXT("AspTrackThreadingModel,AspRequestQueueMax,AspEnableApplicationRestart,")
                TEXT("AspQueueConnectionTestTime,AspSessionMax,")
                TEXT("AspThreadGateEnabled,AspThreadGateTimeSlice,AspThreadGateSleepDelay,")
                TEXT("AspThreadGateSleepMax,AspThreadGateLoadLow,AspThreadGateLoadHigh,")
                TEXT("PeriodicRestartRequests,PeriodicRestartTime,PeriodicRestartSchedule,ShutdownTimeLimit,")
                TEXT("DirBrowseFlags,AuthMD5,AuthFlags"),
                NULL,
                TEXT("IIsWebDirectory,IIsWebVirtualDir,IIsWebFile,IIsObject"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebVirtualDir"), // Class Name
                NULL,                     // GUID *objectClassID
                NULL,                     // PrimaryInterfaceGUID
                TEXT(""),                 // bstrOID
                FALSE,                    // fAbstract
                NULL,                     // bstrMandatoryProperties
                TEXT("KeyType,AnonymousUserName,AnonymousUserPass,AnonymousPasswordSync,IgnoreTranslate,UseDigestSSP,")
                TEXT("AppRoot,AppFriendlyName,AppOopRecoverLimit,AppIsolated,AppPackageName,AppPackageID,")
                TEXT("CacheISAPI,AppAllowDebugging,AppAllowClientDebug,")
                TEXT("AuthBasic,AuthAnonymous,AuthNTLM,")
                TEXT("DefaultLogonDomain,LogonMethod,")
                TEXT("CGITimeOut,Realm,EnableDefaultDoc,")
                TEXT("DirBrowseShowDate,DirBrowseShowTime,DirBrowseShowSize,DirBrowseShowExtension,DirBrowseShowLongDate,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,IPSecurity,DontLog,HttpExpires,HttpPics,HttpCustomHeaders,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("HttpErrors,EnableDocFooter,DefaultDocFooter,HttpRedirect,")
                TEXT("EnableDirBrowsing,DefaultDoc,ContentIndexed,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("FrontPageWeb,Path,UNCUserName,UNCPassword,")
                TEXT("UNCAuthenticationPassThrough,AppWamClsid,")
                TEXT("AuthPersistence,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole,")
                TEXT("AspBufferingOn,AspLogErrorRequests,AspScriptErrorSentToBrowser,AspScriptErrorMessage,AspAllowOutOfProcComponents,")
                TEXT("AspScriptFileCacheSize,AspDiskTemplateCacheDirectory,AspMaxDiskTemplateCacheFiles,AspScriptEngineCacheMax,AspScriptTimeout,AspSessionTimeout,")
                TEXT("AspEnableParentPaths,AspAllowSessionState,AspScriptLanguage,AspKeepSessionIDSecure,")
                TEXT("AspExceptionCatchEnable,AspCodepage,AspLCID,MimeMap,")
                TEXT("AspQueueTimeout,CPUAppEnabled,CPUCGIEnabled,")
                TEXT("AspEnableAspHtmlFallback,AspEnableChunkedEncoding,")
                TEXT("AspEnableTypelibCache,AspErrorsToNTLog,AspProcessorThreadMax,")
                TEXT("AspTrackThreadingModel,AspRequestQueueMax,AspEnableApplicationRestart,")
                TEXT("AspQueueConnectionTestTime,AspSessionMax,")
                TEXT("AspThreadGateEnabled,AspThreadGateTimeSlice,AspThreadGateSleepDelay,")
                TEXT("AspThreadGateSleepMax,AspThreadGateLoadLow,AspThreadGateLoadHigh,")
                TEXT("PeriodicRestartRequests,PeriodicRestartTime,PeriodicRestartSchedule,ShutdownTimeLimit,")
                TEXT("DirBrowseFlags,AuthMD5,AuthFlags"),
                NULL,
                TEXT("IIsWebDirectory,IIsWebFile,IIsWebVirtualDir,IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsFtpVirtualDir"), // Class Name
                NULL,                     // GUID *objectClassID
                NULL,                     // PrimaryInterfaceGUID
                TEXT(""),                 // bstrOID
                FALSE,                    // fAbstract
                NULL,                     // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,AccessFlags,AccessRead,AccessWrite,DontLog,IPSecurity,FtpDirBrowseShowLongDate"),
                NULL,
                TEXT("IIsFtpVirtualDir"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsFilter"),       // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,FilterPath,FilterDescription,FilterFlags,FilterState,FilterEnabled,")
                TEXT("NotifySecurePort,NotifyNonSecurePort,NotifyReadRawData,NotifyPreProcHeaders,")
                TEXT("NotifyAuthentication,NotifyAuthComplete,NotifyUrlMap,NotifyAccessDenied,NotifySendResponse,")
                TEXT("NotifySendRawData,NotifyLog,NotifyEndOfRequest,NotifyEndOfNetSession,")
                TEXT("NotifyOrderHigh,NotifyOrderMedium,NotifyOrderLow"),
                NULL,
                NULL,
                FALSE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsFilters"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,FilterLoadOrder"),
                NULL,
                TEXT("IIsObject,IIsFilter,IIsCompressionSchemes"),
                TRUE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsCompressionScheme"),   // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,HcDoDynamicCompression,HcDoStaticCompression,")
                TEXT("HcDoOnDemandCompression,HcCompressionDll,HcFileExtensions,HcScriptFileExtensions,")
                TEXT("HcMimeType,HcPriority,HcDynamicCompressionLevel,")
                TEXT("HcOnDemandCompLevel,HcCreateFlags"),
                NULL,
                NULL,
                FALSE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsCompressionSchemes"), // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,HcCompressionDirectory,HcCacheControlHeader,")
                TEXT("HcExpiresHeader,HcDoDynamicCompression,HcDoStaticCompression,")
                TEXT("HcDoOnDemandCompression,HcDoDiskSpaceLimiting,")
                TEXT("HcNoCompressionForHttp10,HcNoCompressionForProxies,")
                TEXT("HcNoCompressionForRange,HcSendCacheHeaders,HcMaxDiskSpaceUsage,")
                TEXT("HcIoBufferSize,HcCompressionBufferSize,HcMaxQueueLength,")
                TEXT("HcFilesDeletedPerDiskFree,HcMinFileSizeForComp"),
                NULL,
                TEXT("IIsObject,IIsCompressionScheme"),
                TRUE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsCertMapper"),   // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsMimeMap"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,MimeMap"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsLogModules"),   // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType"),
                NULL,
                TEXT("IIsObject,IIsLogModule,IIsCustomLogModule"),
                TRUE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsLogModule"),    // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleId,LogModuleUiId"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsCustomLogModule"),    // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogCustomPropertyName,LogCustomPropertyHeader,")
                TEXT("LogCustomPropertyID,LogCustomPropertyMask,")
                TEXT("LogCustomPropertyDataType,LogCustomPropertyServicesString"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebInfo"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,ServerConfigFlags,CustomErrorDescriptions,AdminServer,")
                TEXT("ServerConfigSSL40,ServerConfigSSL128,ServerConfigSSLAllowEncrypt,ServerConfigAutoPWSync,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsFtpInfo"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                FALSE,
                TEXT(""),
                0
        },


                //------------------------------------------------------------
                //
                //      -- BEGIN EXTENSION CLASSES -- magnush
                //
                //------------------------------------------------------------

                //
                //      Objects that are handled by the adsiis dll:
                //

        {
                TEXT("IIsNntpService"),                                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,AnonymousUserName,AnonymousUserPass,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AnonymousPasswordSync,AdminACL,AdminACLBin,IPSecurity,DontLog,ContentIndexed,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,")
                TEXT("HonorClientMsgIds,SmtpServer,AdminEmail,AdminName,")
                TEXT("AllowClientPosts,AllowFeedPosts,AllowControlMsgs,")
                TEXT("DefaultModeratorDomain,NntpCommandLogMask,DisableNewNews,")
                TEXT("ClientPostHardLimit,ClientPostSoftLimit,FeedPostHardLimit,FeedPostSoftLimit,")
                TEXT("LogType,LogFilePeriod,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("FeedReportPeriod,MaxSearchResults,")
                TEXT("NntpServiceVersion,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,AccessSSLFlags,")
                TEXT("AccessWrite,AccessExecute,AccessFlags"),
                NULL,
                TEXT("IIsObject,IIsNntpInfo,IIsNntpServer"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpServer"),                                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                TEXT("GroupHelpFile,GroupListFile,ArticleTableFile,HistoryTableFile,ListFile,")
                TEXT("ModeratorFile,XoverTableFile,PrettyNamesFile"),   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,AnonymousUserName,AnonymousUserPass,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ServerBindings,SecureBindings,ClusterEnabled,")
                TEXT("AnonymousPasswordSync,AdminACL,AdminACLBin,IPSecurity,DontLog,ContentIndexed,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,Win32Error,ServerState,")
                TEXT("HonorClientMsgIds,SmtpServer,AdminEmail,AdminName,")
                TEXT("AllowClientPosts,AllowFeedPosts,AllowControlMsgs,")
                TEXT("DefaultModeratorDomain,NntpCommandLogMask,DisableNewNews,")
                TEXT("ClientPostHardLimit,ClientPostSoftLimit,FeedPostHardLimit,FeedPostSoftLimit,")
                TEXT("NewsPickupDirectory,NewsFailedPickupDirectory,NewsDropDirectory,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("FeedReportPeriod,MaxSearchResults,")
                TEXT("NntpUucpName,NntpServiceVersion,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,AccessSSLFlags,")
                TEXT("AccessWrite,AccessExecute,AccessFlags,")
                TEXT("SSLCertHash,")
                TEXT("ArticleTimeLimit,HistoryExpiration,NewsCrawlerTime,ShutdownLatency,GroupvarListFile,NntpOrganization"),
                NULL,
                TEXT("IIsObject,IIsNntpVirtualDir,")                                                                                            // Real objects
                TEXT("IIsNntpRebuild,IIsNntpSessions,IIsNntpFeeds,IIsNntpExpires,IIsNntpGroups"),       // Class extensions
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpVirtualDir"),// Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,Win32Error,ContentIndexed,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,AccessSSLFlags,")
                TEXT("AccessWrite,AccessExecute,AccessFlags,")
                TEXT("VrUseAccount,VrDoExpire,VrOwnModerator,VrDriverProgid,FsPropertyPath,ExMdbGuid"),
                NULL,
                TEXT("IIsObject,IIsNntpVirtualDir"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },

        {               // Taken from as IIsFtpInfo
                TEXT("IIsNntpInfo"),     // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpService"),                                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("LogType,LogFilePeriod,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("SmtpServiceVersion,")
                TEXT("EnableReverseDnsLookup,ShouldDeliver,AlwaysUseSsl,LimitRemoteConnections,")
                TEXT("SmartHostType,DoMasquerade,RemoteSmtpPort,RemoteSmtpSecurePort,HopCount,")
                TEXT("MaxOutConnections,MaxOutConnectionsPerDomain,RemoteTimeout,MaxMessageSize,MaxSessionSize,MaxRecipients,")
                TEXT("LocalRetryInterval,RemoteRetryInterval,LocalRetryAttempts,RemoteRetryAttempts,EtrnDays,")
                TEXT("MaxBatchedMessages,SmartHost,FullyQualifiedDomainName,DefaultDomain,")
                TEXT("DropDirectory,BadMailDirectory,PickupDirectory,QueueDirectory,")
                TEXT("MasqueradeDomain,SendNdrTo,SendBadTo,")
                TEXT("RoutingDll,RoutingSources,DomainRouting,")
                TEXT("RouteAction,RouteUserName,RoutePassword,")
                TEXT("SaslLogonDomain,SmtpClearTextProvider,NTAuthenticationProviders,")
                TEXT("SmtpRemoteProgressiveRetry,SmtpLocalDelayExpireMinutes,SmtpLocalNDRExpireMinutes,")
                TEXT("SmtpRemoteDelayExpireMinutes,SmtpRemoteNDRExpireMinutes,")
                TEXT("SmtpRemoteRetryThreshold,")
                TEXT("SmtpDSNOptions,SmtpDSNLanguageID,")
                TEXT("SmtpAdvQueueDll,")
                TEXT("SmtpInboundCommandSupportOptions,SmtpOutboundCommandSupportOptions,")
                TEXT("SmtpCommandLogMask,SmtpFlushMailFile,")
                TEXT("RelayIpList,RelayForAuth,")
                TEXT("SmtpConnectTimeout,SmtpMailFromTimeout,SmtpRcptToTimeout,")
                TEXT("SmtpDataTimeout,SmtpBdatTimeout,SmtpAuthTimeout,SmtpSaslTimeout,")
                TEXT("SmtpTurnTimeout,SmtpRsetTimeout,")
                TEXT("SmtpHeloTimeout"),
                NULL,
                TEXT("IIsObject,IIsSmtpInfo,IIsSmtpServer"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpServer"),                                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                                                   // bstrMandatoryProperties

                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ServerBindings,SecureBindings,ClusterEnabled,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,Win32Error,ServerState,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("SmtpServiceVersion,")
                TEXT("EnableReverseDnsLookup,ShouldDeliver,AlwaysUseSsl,LimitRemoteConnections,")
                TEXT("SmartHostType,DoMasquerade,RemoteSmtpPort,RemoteSmtpSecurePort,HopCount,")
                TEXT("MaxOutConnections,MaxOutConnectionsPerDomain,RemoteTimeout,MaxMessageSize,MaxSessionSize,MaxRecipients,")
                TEXT("LocalRetryInterval,RemoteRetryInterval,LocalRetryAttempts,RemoteRetryAttempts,EtrnDays,")
                TEXT("MaxBatchedMessages,SmartHost,FullyQualifiedDomainName,DefaultDomain,")
                TEXT("DropDirectory,BadMailDirectory,PickupDirectory,QueueDirectory,")
                TEXT("MasqueradeDomain,SendNdrTo,SendBadTo,")
                TEXT("RoutingDll,RoutingSources,DomainRouting,")
                TEXT("RouteAction,RouteUserName,RoutePassword,")
                TEXT("SaslLogonDomain,SmtpClearTextProvider,NTAuthenticationProviders,")
                TEXT("SmtpRemoteProgressiveRetry,SmtpLocalDelayExpireMinutes,SmtpLocalNDRExpireMinutes,")
                TEXT("SmtpRemoteDelayExpireMinutes,SmtpRemoteNDRExpireMinutes,")
                TEXT("SmtpRemoteRetryThreshold,SmtpDSNOptions,SmtpDSNLanguageID,")
                TEXT("SmtpInboundCommandSupportOptions,SmtpOutboundCommandSupportOptions,")
                TEXT("RelayIpList,RelayForAuth,")
                TEXT("SmtpConnectTimeout,SmtpMailFromTimeout,SmtpRcptToTimeout,")
                TEXT("SmtpDataTimeout,SmtpBdatTimeout,SmtpAuthTimeout,SmtpSaslTimeout,")
                TEXT("SmtpTurnTimeout,SmtpRsetTimeout,")
                TEXT("SmtpHeloTimeout,")
                TEXT("SSLCertHash"),
                NULL,
                TEXT("IIsObject,IIsSmtpVirtualDir,IIsSmtpRoutingSource,IIsSmtpDomain,")     // Real objects
                TEXT("IIsSmtpSessions"),   // Class extensions
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpVirtualDir"),              // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,Win32Error,DontLog,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags"),
                NULL,
                TEXT("IIsObject,IIsSmtpVirtualDir"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpDomain"),                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,RouteAction,RouteActionString,RouteUserName,RoutePassword,")
                          TEXT("RelayIpList,RelayForAuth,AuthTurnList,CSideEtrnDomains"),        //
                NULL,
                TEXT("IIsSmtpDomain"),
                TRUE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpRoutingSource"),           // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,")
                TEXT("SmtpRoutingTableType,SmtpDsDataDirectory,SmtpDsDefaultMailRoot,")
                TEXT("SmtpDsBindType,SmtpDsSchemaType,SmtpDsHost,SmtpDsNamingContext,")
                TEXT("SmtpDsAccount,SmtpDsPassword,SmtpDsUseCat,SmtpDsPort,SmtpDsDomain,SmtpDsFlags"),
                NULL,
                NULL,           // Can Contain
                TRUE,
                TEXT(""),           //
                0
        },

        {               // Taken from as IIsFtpInfo
                TEXT("IIsSmtpInfo"),     // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3Service"),                                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,")
                TEXT("DefaultLogonDomain,NTAuthenticationProviders,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("LogType,LogFilePeriod,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("Pop3ServiceVersion,")
                TEXT("Pop3ExpireMail,Pop3ExpireDelay,Pop3ExpireStart,Pop3MailExpirationTime,")
                TEXT("Pop3ClearTextProvider,Pop3DefaultDomain,")
                TEXT("Pop3RoutingDll,Pop3RoutingSources,"),
                NULL,
                TEXT("IIsObject,IIsPop3Info,IIsPop3Server"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3Server"),                                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                                                   // bstrMandatoryProperties

                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ServerBindings,SecureBindings,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("DefaultLogonDomain,NTAuthenticationProviders,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("ServerListenBacklog,Win32Error,ServerState,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("Pop3ServiceVersion,")
                TEXT("Pop3ExpireMail,Pop3ExpireDelay,Pop3ExpireStart,Pop3MailExpirationTime,")
                TEXT("Pop3ClearTextProvider,Pop3DefaultDomain,")
                TEXT("Pop3RoutingDll,Pop3RoutingSources,")
                TEXT("SSLCertHash"),
                NULL,
                TEXT("IIsObject,IIsPop3VirtualDir,IIsPop3RoutingSource,")       // Real objects
                TEXT("IIsPop3Sessions"),    // Class extensions
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3VirtualDir"),              // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,Win32Error,DontLog,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("Pop3ExpireMail,Pop3MailExpirationTime"),
                NULL,
                TEXT("IIsObject,IIsPop3VirtualDir"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3RoutingSource"),           // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,")
                TEXT("Pop3RoutingTableType,Pop3DsDataDirectory,Pop3DsDefaultMailRoot,")
                TEXT("Pop3DsBindType,Pop3DsSchemaType,Pop3DsHost,Pop3DsNamingContext,")
                TEXT("Pop3DsAccount,Pop3DsPassword"),
                NULL,
                NULL,           // Can Contain
                TRUE,
                TEXT(""),           //
                0
        },

        {               // Taken from as IIsFtpInfo
                TEXT("IIsPop3Info"),     // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapService"),                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,")
                TEXT("DefaultLogonDomain,NTAuthenticationProviders,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("LogType,LogFilePeriod,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("ImapServiceVersion,")
                TEXT("ImapExpireMail,ImapExpireDelay,ImapExpireStart,ImapMailExpirationTime,")
                TEXT("ImapClearTextProvider,ImapDefaultDomain,")
                TEXT("ImapRoutingDll,ImapRoutingSources"),
                NULL,
                TEXT("IIsObject,IIsImapInfo,IIsImapServer"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapServer"),                                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                                                   // bstrMandatoryProperties

                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ServerBindings,SecureBindings,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("DefaultLogonDomain,NTAuthenticationProviders,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("ServerListenBacklog,Win32Error,ServerState,")
                TEXT("ImapServiceVersion,")
                TEXT("ImapExpireMail,ImapExpireDelay,ImapExpireStart,ImapMailExpirationTime,")
                TEXT("ImapClearTextProvider,ImapDefaultDomain,")
                TEXT("ImapRoutingDll,ImapRoutingSources,")
                TEXT("SSLCertHash"),
                NULL,
                TEXT("IIsObject,IIsImapVirtualDir,IIsImapRoutingSource,")       // Real objects
                TEXT("IIsImapSessions"),        // Class extensions
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapVirtualDir"),// Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,Win32Error,DontLog,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("ImapExpireMail,ImapMailExpirationTime"),
                NULL,
                TEXT("IIsObject,IIsImapVirtualDir"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapRoutingSource"),           // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,")
                TEXT("ImapRoutingTableType,ImapDsDataDirectory,ImapDsDefaultMailRoot,")
                TEXT("ImapDsBindType,ImapDsSchemaType,ImapDsHost,ImapDsNamingContext,")
                TEXT("ImapDsAccount,ImapDsPassword"),
                NULL,
                NULL,           // Can Contain
                TRUE,
                TEXT(""),           //
                0
        },

        {               // Taken from as IIsFtpInfo
                TEXT("IIsImapInfo"),     // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        //
        //      Place holders for extension classes:
        //

        {
                TEXT("IIsNntpRebuild"),                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpSessions"),                // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpFeeds"),                   // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                TEXT("IIsNntpFeed"),
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpFeed"),                   // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,")
                TEXT("FeedServerName,FeedType,FeedNewsgroups,FeedSecurityType,")
                TEXT("FeedAuthenticationType,FeedAcountName,FeedPassword,FeedStartTimeHigh,")
                TEXT("FeedStartTimeLow,FeedInterval,FeedAllowControlMsgs,FeedCreateAutomatically,")
                TEXT("FeedDisabled,FeedDistribution,FeedConcurrentSessions,FeedMaxConnectionAttempts,")
                TEXT("FeedUucpName,FeedTempDirectory,FeedNextPullHigh,FeedNextPullLow,FeedPeerTempDirectory,")
                TEXT("FeedPeerGapSize,FeedOutgoingPort,FeedFeedpaisId,FeedHandshake,FeedAdminError,FeedErrParmMask"),
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpExpiration"),              // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpExpire"),              // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,ExpireSpace,ExpireTime,ExpireNewsgroups,ExpirePolicyName"),
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpGroups"),                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpSessions"),                // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3Sessions"),                // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapSessions"),                // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

                //------------------------------------------------------------
                //
                //      -- END EXTENSION CLASSES -- magnush
                //
                //------------------------------------------------------------
};

SYNTAXINFO g_aIISSyntax[] =
{ {  TEXT("Boolean"),  IIS_SYNTAX_ID_BOOL,     VT_BOOL },
  {  TEXT("Integer"),  IIS_SYNTAX_ID_DWORD,    VT_I4 },
  {  TEXT("String"),   IIS_SYNTAX_ID_STRING,   VT_BSTR },
  {  TEXT("ExpandSz"), IIS_SYNTAX_ID_EXPANDSZ, VT_BSTR },
  {  TEXT("List"),     IIS_SYNTAX_ID_MULTISZ,  VT_VARIANT }, // VT_BSTR|VT_ARR

  {  TEXT("IPSec"),    IIS_SYNTAX_ID_IPSECLIST,VT_VARIANT }, // IP Sec object
  {  TEXT("NTAcl"),    IIS_SYNTAX_ID_NTACL,    VT_VARIANT }, // NT ACL object
  {  TEXT("Binary"),    IIS_SYNTAX_ID_BINARY,    VT_VARIANT }, // NT ACL object but in Raw Binary Form
  {  TEXT("MimeMapList"), IIS_SYNTAX_ID_MIMEMAP, VT_VARIANT } // VT_ARRAY of Mime Map object
};

DWORD g_cIISClasses = (sizeof(g_aIISClasses)/sizeof(g_aIISClasses[0]));
DWORD g_cIISSyntax = (sizeof(g_aIISSyntax)/sizeof(g_aIISSyntax[0]));



PROPERTYINFO g_aIISProperties[] =
{

//
// Computer properties
//
      { TEXT("KeyType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_KEY_TYPE, MD_KEY_TYPE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,0, TEXT("")},

      { TEXT("MaxBandwidth"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_BANDWIDTH, MD_MAX_BANDWIDTH, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0xffffffff, TEXT("")},

      { TEXT("MimeMap"),
        TEXT(""), TEXT("MimeMapList"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MIMEMAP, MD_MIME_MAP, MD_MIME_MAP, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("\0")},

//
// Service properties
//

      { TEXT("AnonymousUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ANONYMOUS_USER_NAME, MD_ANONYMOUS_USER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AnonymousUserPass"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ANONYMOUS_PWD, MD_ANONYMOUS_PWD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AnonymousPasswordSync"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ANONYMOUS_USE_SUBAUTH, MD_ANONYMOUS_USE_SUBAUTH, 0, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("AllowAnonymous"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_ANONYMOUS, MD_ALLOW_ANONYMOUS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("WAMUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_WAM_USER_NAME, MD_WAM_USER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("WAMUserPass"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_WAM_PWD, MD_WAM_PWD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("DefaultLogonDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DEFAULT_LOGON_DOMAIN, MD_DEFAULT_LOGON_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AdminACL"),
        TEXT(""), TEXT("NTAcl"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_NTACL, MD_ADMIN_ACL, MD_ADMIN_ACL, 0, METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AdminACLBin"),
        TEXT(""), TEXT("Binary"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BINARY, MD_ADMIN_ACL, MD_VPROP_ADMIN_ACL_RAW_BINARY, 0, METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("IPSecurity"),
        TEXT(""), TEXT("IPSec"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_IPSECLIST, MD_IP_SEC, MD_IP_SEC, 0, METADATA_INHERIT | METADATA_REFERENCE, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("DontLog"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DONT_LOG, MD_DONT_LOG, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("Realm"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_REALM, MD_REALM, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("ServerListenTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_LISTEN_TIMEOUT, MD_SERVER_LISTEN_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 120, TEXT("")},

      { TEXT("MaxEndpointConnections"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_ENDPOINT_CONNECTIONS, MD_MAX_ENDPOINT_CONNECTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0xffffffff, TEXT("")},

      { TEXT("DisableSocketPooling"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DISABLE_SOCKET_POOLING, MD_DISABLE_SOCKET_POOLING, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PeriodicRestartRequests"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APP_PERIODIC_RESTART_REQUESTS, MD_APP_PERIODIC_RESTART_REQUESTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PeriodicRestartTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APP_PERIODIC_RESTART_TIME, MD_APP_PERIODIC_RESTART_TIME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PeriodicRestartSchedule"),
        TEXT(""), TEXT("List"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_APP_PERIODIC_RESTART_SCHEDULE, MD_APP_PERIODIC_RESTART_SCHEDULE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ShutdownTimeLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APP_SHUTDOWN_TIME_LIMIT, MD_APP_SHUTDOWN_TIME_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 600, TEXT("")},
//
//
//  IW3Service Properties
//
//

      { TEXT("AdminServer"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ADMIN_INSTANCE, MD_ADMIN_INSTANCE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("1")},

      { TEXT("EnableDirBrowsing"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_ENABLED, MD_DIRBROW_ENABLED, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("DirBrowseShowDate"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_SHOW_DATE, MD_DIRBROW_SHOW_DATE, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DirBrowseShowTime"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_SHOW_TIME, MD_DIRBROW_SHOW_TIME, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DirBrowseShowSize"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_SHOW_SIZE, MD_DIRBROW_SHOW_SIZE, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DirBrowseShowExtension"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_SHOW_EXTENSION, MD_DIRBROW_SHOW_EXTENSION, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DirBrowseShowLongDate"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_LONG_DATE, MD_DIRBROW_LONG_DATE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("EnableDefaultDoc"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_LOADDEFAULT, MD_DIRBROW_LOADDEFAULT, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DefaultDoc"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DEFAULT_LOAD_FILE, MD_DEFAULT_LOAD_FILE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("default.htm")},

      { TEXT("HttpExpires"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HTTP_EXPIRES, MD_HTTP_EXPIRES, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("D, 0x15180")},

      { TEXT("HttpPics"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_HTTP_PICS, MD_HTTP_PICS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("HttpCustomHeaders"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_HTTP_CUSTOM, MD_HTTP_CUSTOM, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("\0")},

      { TEXT("CustomErrorDescriptions"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_CUSTOM_ERROR_DESC, MD_CUSTOM_ERROR_DESC, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("HttpErrors"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_CUSTOM_ERROR, MD_CUSTOM_ERROR, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("\0")},

      { TEXT("EnableDocFooter"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_FOOTER_ENABLED, MD_FOOTER_ENABLED, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("DefaultDocFooter"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FOOTER_DOCUMENT, MD_FOOTER_DOCUMENT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("HttpRedirect"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HTTP_REDIRECT, MD_HTTP_REDIRECT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("LogonMethod"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGON_METHOD, MD_LOGON_METHOD, 0, METADATA_INHERIT, IIS_MD_UT_FILE, MD_LOGON_INTERACTIVE, TEXT("")},

      { TEXT("NTAuthenticationProviders"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_NTAUTHENTICATION_PROVIDERS, MD_NTAUTHENTICATION_PROVIDERS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")}, 

      { TEXT("AuthBasic"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION, MD_VPROP_AUTH_BASIC, MD_AUTH_BASIC, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AuthAnonymous"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION, MD_VPROP_AUTH_ANONYMOUS, MD_AUTH_ANONYMOUS, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("AuthNTLM"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION, MD_VPROP_AUTH_NT, MD_AUTH_NT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AuthMD5"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION, MD_VPROP_AUTH_MD5, MD_AUTH_MD5, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessExecute"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_EXECUTE, MD_ACCESS_EXECUTE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSource"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_READ_SOURCE, MD_ACCESS_SOURCE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSL"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_SSL, MD_ACCESS_SSL, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSL128"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_SSL128, MD_ACCESS_SSL128, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSLNegotiateCert"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_NEGO_CERT, MD_ACCESS_NEGO_CERT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSLRequireCert"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_REQUIRE_CERT, MD_ACCESS_REQUIRE_CERT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSLMapCert"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_MAP_CERT, MD_ACCESS_MAP_CERT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CertCheckMode"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CERT_CHECK_MODE, MD_CERT_CHECK_MODE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CertNoRevocCheck"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CERT_CHECK_MODE, MD_VPROP_CERT_NO_REVOC_CHECK, MD_CERT_NO_REVOC_CHECK, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CertCacheRetrievalOnly"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CERT_CHECK_MODE, MD_VPROP_CERT_CACHE_RETRIEVAL_ONLY, MD_CERT_CACHE_RETRIEVAL_ONLY, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("CertCheckRevocationFreshnessTime"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CERT_CHECK_MODE, MD_VPROP_CERT_CHECK_REVOCATION_FRESHNESS_TIME, MD_CERT_CHECK_REVOCATION_FRESHNESS_TIME, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("CertNoUsageCheck"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CERT_CHECK_MODE, MD_VPROP_CERT_NO_USAGE_CHECK, MD_CERT_NO_USAGE_CHECK , METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("AccessRead"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_READ, MD_ACCESS_READ, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("AccessWrite"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_WRITE, MD_ACCESS_WRITE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessScript"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_SCRIPT, MD_ACCESS_SCRIPT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessNoRemoteExecute"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_NO_REMOTE_EXECUTE, MD_ACCESS_NO_REMOTE_WRITE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessNoRemoteRead"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_NO_REMOTE_READ, MD_ACCESS_NO_REMOTE_READ, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessNoRemoteWrite"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_NO_REMOTE_WRITE, MD_ACCESS_NO_REMOTE_WRITE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessNoRemoteScript"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_NO_REMOTE_SCRIPT, MD_ACCESS_NO_REMOTE_SCRIPT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("FilterLoadOrder"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FILTER_LOAD_ORDER, MD_FILTER_LOAD_ORDER, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_CONFIGURATION_INFO, MD_SERVER_CONFIGURATION_INFO, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigSSL40"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SERVER_CONFIGURATION_INFO, MD_VPROP_SERVER_CONFIG_SSL_40, MD_SERVER_CONFIG_SSL_40, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigSSL128"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SERVER_CONFIGURATION_INFO, MD_VPROP_SERVER_CONFIG_SSL_128, MD_SERVER_CONFIG_SSL_128, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigSSLAllowEncrypt"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SERVER_CONFIGURATION_INFO, MD_VPROP_SERVER_CONFIG_ALLOW_ENCRYPT, MD_SERVER_CONFIG_ALLOW_ENCRYPT, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigAutoPWSync"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SERVER_CONFIGURATION_INFO, MD_VPROP_SERVER_CONFIG_AUTO_PW_SYNC, MD_SERVER_CONFIG_AUTO_PW_SYNC, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

#if defined(CAL_ENABLED)
      { TEXT("CalVcPerConnect"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CAL_VC_PER_CONNECT, MD_CAL_VC_PER_CONNECT, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DEFAULT_W3_CAL_VC_PER_CONNECT, TEXT("")},

      { TEXT("CalReserveTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CAL_AUTH_RESERVE_TIMEOUT, MD_CAL_AUTH_RESERVE_TIMEOUT, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DEFAULT_W3_CAL_AUTH_RESERVE_TIMEOUT, TEXT("")},

      { TEXT("CalSSLReserveTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CAL_SSL_RESERVE_TIMEOUT, MD_CAL_SSL_RESERVE_TIMEOUT, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DEFAULT_W3_CAL_SSL_RESERVE_TIMEOUT, TEXT("")},

      { TEXT("CalLimitHttpError"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CAL_W3_ERROR, MD_CAL_W3_ERROR, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DEFAULT_W3_CAL_W3_ERROR , TEXT("")},
#endif

//
// IIsFtpService
//

      { TEXT("LogAnonymous"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_LOG_ANONYMOUS, MD_LOG_ANONYMOUS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogNonAnonymous"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_LOG_NONANONYMOUS, MD_LOG_NONANONYMOUS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},


//
// IIsVirtualServer
//

      { TEXT("ServerState"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_STATE, MD_SERVER_STATE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MD_SERVER_STATE_STOPPED, TEXT("")},

      { TEXT("ServerComment"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SERVER_COMMENT, MD_SERVER_COMMENT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerAutoStart"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SERVER_AUTOSTART, MD_SERVER_AUTOSTART, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("ServerSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_SIZE, MD_SERVER_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, MD_SERVER_SIZE_MEDIUM, TEXT("")},

      { TEXT("ServerListenBacklog"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_LISTEN_BACKLOG, MD_SERVER_LISTEN_BACKLOG, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 40, TEXT("")},

      { TEXT("ServerBindings"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_SERVER_BINDINGS, MD_SERVER_BINDINGS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("SecureBindings"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_SECURE_BINDINGS, MD_SECURE_BINDINGS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("MaxConnections"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_CONNECTIONS, MD_MAX_CONNECTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ConnectionTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CONNECTION_TIMEOUT, MD_CONNECTION_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 900, TEXT("")},

//
// IIsWebServer
//

      { TEXT("AllowKeepAlive"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_KEEPALIVES, MD_ALLOW_KEEPALIVES, 0, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("CGITimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SCRIPT_TIMEOUT, MD_SCRIPT_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 300, TEXT("")},

      { TEXT("CacheISAPI"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CACHE_EXTENSIONS, MD_CACHE_EXTENSIONS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("FrontPageWeb"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_FRONTPAGE_WEB, MD_FRONTPAGE_WEB, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RevocationFreshnessTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REVOCATION_FRESHNESS_TIME, MD_REVOCATION_FRESHNESS_TIME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 86400, TEXT("")},
      
      { TEXT("RevocationURLRetrievalTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REVOCATION_URL_RETRIEVAL_TIMEOUT, MD_REVOCATION_URL_RETRIEVAL_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},


//
// IIsFtpServer
//


      { TEXT("ExitMessage"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_EXIT_MESSAGE, MD_EXIT_MESSAGE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("GreetingMessage"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_GREETING_MESSAGE, MD_GREETING_MESSAGE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("BannerMessage"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_BANNER_MESSAGE, MD_BANNER_MESSAGE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("MaxClientsMessage"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MAX_CLIENTS_MESSAGE, MD_MAX_CLIENTS_MESSAGE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AnonymousOnly"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ANONYMOUS_ONLY, MD_ANONYMOUS_ONLY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MSDOSDirOutput"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_MSDOS_DIR_OUTPUT, MD_MSDOS_DIR_OUTPUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

//
// IIsW3File
//




// IIsW3Directory


      { TEXT("AppRoot"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_STRING, MD_APP_ROOT, MD_APP_ROOT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AppFriendlyName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_APP_FRIENDLY_NAME, MD_APP_FRIENDLY_NAME, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AppOopRecoverLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APP_OOP_RECOVER_LIMIT, MD_APP_OOP_RECOVER_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_WAM, APP_OOP_RECOVER_LIMIT_DEFAULT, TEXT("")},

      { TEXT("AppIsolated"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_APP_ISOLATED, MD_APP_ISOLATED, 0, METADATA_INHERIT, IIS_MD_UT_WAM, eAppRunOutProcInDefaultPool, TEXT("")},

      { TEXT("AppPackageName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_STRING, MD_APP_PACKAGE_NAME, MD_APP_PACKAGE_NAME, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AppPackageID"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_STRING, MD_APP_PACKAGE_ID, MD_APP_PACKAGE_ID, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("ContentIndexed"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_IS_CONTENT_INDEXED, MD_IS_CONTENT_INDEXED, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("IgnoreTranslate"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_VR_IGNORE_TRANSLATE, MD_VR_IGNORE_TRANSLATE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("UseDigestSSP"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_USE_DIGEST_SSP, MD_USE_DIGEST_SSP, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

//
// IIsW3VirtualDir
//

      { TEXT("Path"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_VR_PATH, MD_VR_PATH, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("UNCUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_VR_USERNAME, MD_VR_USERNAME, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("UNCPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_VR_PASSWORD, MD_VR_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_FILE, 0, TEXT("")},


//
// IIsFtpVirtualDir
//

      { TEXT("FtpDirBrowseShowLongDate"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SHOW_4_DIGIT_YEAR, MD_SHOW_4_DIGIT_YEAR, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

//
// IIsFilter
//

      { TEXT("FilterPath"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FILTER_IMAGE_PATH, MD_FILTER_IMAGE_PATH, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FilterState"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FILTER_STATE, MD_FILTER_STATE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FilterDescription"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FILTER_DESCRIPTION, MD_FILTER_DESCRIPTION, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FilterEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_FILTER_ENABLED, MD_FILTER_ENABLED, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("FilterFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FILTER_FLAGS, MD_FILTER_FLAGS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifySecurePort"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_SECURE_PORT, MD_NOTIFY_SECURE_PORT, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyNonSecurePort"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_NONSECURE_PORT, MD_NOTIFY_NONSECURE_PORT, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyReadRawData"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_READ_RAW_DATA, MD_NOTIFY_READ_RAW_DATA, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyPreProcHeaders"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_PREPROC_HEADERS, MD_NOTIFY_PREPROC_HEADERS, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyAuthentication"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_AUTHENTICATION, MD_NOTIFY_AUTHENTICATION, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyAuthComplete"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_AUTH_COMPLETE, MD_NOTIFY_AUTH_COMPLETE, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyUrlMap"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_URL_MAP, MD_NOTIFY_URL_MAP, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyAccessDenied"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_ACCESS_DENIED, MD_NOTIFY_ACCESS_DENIED, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifySendResponse"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_SEND_RESPONSE, MD_NOTIFY_SEND_RESPONSE, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifySendRawData"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_SEND_RAW_DATA, MD_NOTIFY_SEND_RAW_DATA, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyLog"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_LOG, MD_NOTIFY_LOG, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyEndOfRequest"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_END_OF_REQUEST, MD_NOTIFY_END_OF_REQUEST, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyEndOfNetSession"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_END_OF_NET_SESSION, MD_NOTIFY_END_OF_NET_SESSION, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyOrderHigh"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_ORDER_HIGH, MD_NOTIFY_ORDER_HIGH, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyOrderMedium"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_ORDER_MEDIUM, MD_NOTIFY_ORDER_MEDIUM, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyOrderLow"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_ORDER_LOW, MD_NOTIFY_ORDER_MEDIUM, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},


//
//
//
//

      { TEXT("AspBufferingOn"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_BUFFERINGON, MD_ASP_BUFFERINGON, 0, METADATA_INHERIT, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspLogErrorRequests"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_LOGERRORREQUESTS, MD_ASP_LOGERRORREQUESTS, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspScriptErrorSentToBrowser"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_SCRIPTERRORSSENTTOBROWSER, MD_ASP_SCRIPTERRORSSENTTOBROWSER, 0, METADATA_INHERIT, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspScriptErrorMessage"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ASP_SCRIPTERRORMESSAGE, MD_ASP_SCRIPTERRORMESSAGE, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("An error occurred on the server when processing the URL. Please contact the system administrator.")},

      { TEXT("AspMaxDiskTemplateCacheFiles"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_MAXDISKTEMPLATECACHEFILES, MD_ASP_MAXDISKTEMPLATECACHEFILES, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0xffffffff, TEXT("")},

      { TEXT("AspScriptFileCacheSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SCRIPTFILECACHESIZE, MD_ASP_SCRIPTFILECACHESIZE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0xffffffff, TEXT("")},

      { TEXT("AspDiskTemplateCacheDirectory"),
        TEXT(""), TEXT("ExpandSz"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_EXPANDSZ, MD_ASP_DISKTEMPLATECACHEDIRECTORY, MD_ASP_DISKTEMPLATECACHEDIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("%Windir%\\System32\\inetsrv\\ASP Compiled Templates")},

      { TEXT("AspScriptEngineCacheMax"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SCRIPTENGINECACHEMAX, MD_ASP_SCRIPTENGINECACHEMAX, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 120, TEXT("")},

      { TEXT("AspScriptTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SCRIPTTIMEOUT, MD_ASP_SCRIPTTIMEOUT, 0, METADATA_INHERIT, ASP_MD_UT_APP, 90, TEXT("")},

      { TEXT("AspSessionTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SESSIONTIMEOUT, MD_ASP_SESSIONTIMEOUT, 0, METADATA_INHERIT, ASP_MD_UT_APP, 10, TEXT("")},

      { TEXT("AspEnableParentPaths"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLEPARENTPATHS, MD_ASP_ENABLEPARENTPATHS, 0, METADATA_INHERIT, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspAllowSessionState"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ALLOWSESSIONSTATE, MD_ASP_ALLOWSESSIONSTATE, 0, METADATA_INHERIT, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspScriptLanguage"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ASP_SCRIPTLANGUAGE, MD_ASP_SCRIPTLANGUAGE, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("Vbscript")},

      { TEXT("AspQueueTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_QUEUETIMEOUT, MD_ASP_QUEUETIMEOUT, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0xffffffff, TEXT("")},

      { TEXT("AspAllowOutOfProcComponents"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ALLOWOUTOFPROCCOMPONENTS, MD_ASP_ALLOWOUTOFPROCCOMPONENTS, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspExceptionCatchEnable"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_EXCEPTIONCATCHENABLE, MD_ASP_EXCEPTIONCATCHENABLE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspCodepage"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_CODEPAGE, MD_ASP_CODEPAGE, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},

      { TEXT("AspLCID"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_LCID, MD_ASP_LCID, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},

      { TEXT("AppAllowDebugging"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLESERVERDEBUG, MD_ASP_ENABLESERVERDEBUG, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},

      { TEXT("AppAllowClientDebug"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLECLIENTDEBUG, MD_ASP_ENABLECLIENTDEBUG, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},

      { TEXT("AspKeepSessionIDSecure"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_KEEPSESSIONIDSECURE, MD_ASP_KEEPSESSIONIDSECURE, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},
//
//
      { TEXT("NetLogonWorkstation"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_NET_LOGON_WKS, MD_NET_LOGON_WKS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("UseHostName"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_USE_HOST_NAME, MD_USE_HOST_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PasswordExpirePrenotifyDays"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ADV_NOTIFY_PWD_EXP_IN_DAYS, MD_ADV_NOTIFY_PWD_EXP_IN_DAYS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PasswordCacheTTL"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ADV_CACHE_TTL, MD_ADV_CACHE_TTL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 600, TEXT("")},

      { TEXT("PasswordChangeFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_AUTH_CHANGE_FLAGS, MD_AUTH_CHANGE_FLAGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ProcessNTCRIfLoggedOn"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_PROCESS_NTCR_IF_LOGGED_ON, MD_PROCESS_NTCR_IF_LOGGED_ON, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("AllowPathInfoForScriptMappings"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS, MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("UNCAuthenticationPassThrough"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_VR_PASSTHROUGH, MD_VR_PASSTHROUGH, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AppWamClsid"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_APP_WAM_CLSID, MD_APP_WAM_CLSID, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("DirBrowseFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_DIRECTORY_BROWSING, MD_DIRECTORY_BROWSING, 0, METADATA_INHERIT, IIS_MD_UT_FILE,
        MD_DIRBROW_SHOW_DATE
        |MD_DIRBROW_SHOW_TIME
        |MD_DIRBROW_SHOW_SIZE
        |MD_DIRBROW_SHOW_EXTENSION
        |MD_DIRBROW_LOADDEFAULT
        , TEXT("")},

      { TEXT("AuthFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_AUTHORIZATION, MD_AUTHORIZATION, 0, METADATA_INHERIT, IIS_MD_UT_FILE, MD_AUTH_ANONYMOUS, TEXT("")},

      { TEXT("AuthPersistence"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_AUTHORIZATION_PERSISTENCE, MD_AUTHORIZATION_PERSISTENCE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, MD_AUTH_SINGLEREQUESTIFPROXY, TEXT("")},

      { TEXT("AuthPersistSingleRequest"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION_PERSISTENCE, MD_VPROP_AUTH_SINGLEREQUEST, MD_AUTH_SINGLEREQUEST, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AuthPersistSingleRequestIfProxy"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION_PERSISTENCE, MD_VPROP_AUTH_SINGLEREQUESTIFPROXY, MD_AUTH_SINGLEREQUESTIFPROXY, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AuthPersistSingleRequestAlwaysIfProxy"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION_PERSISTENCE, MD_VPROP_AUTH_SINGLEREQUESTALWAYSIFPROXY, MD_AUTH_SINGLEREQUESTALWAYSIFPROXY, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ACCESS_PERM, MD_ACCESS_PERM, 0, METADATA_INHERIT, IIS_MD_UT_FILE, MD_ACCESS_READ, TEXT("")},

      { TEXT("AccessSSLFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SSL_ACCESS_PERM, MD_SSL_ACCESS_PERM, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("ScriptMaps"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_SCRIPT_MAPS, MD_SCRIPT_MAPS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("\0")},

      { TEXT("InProcessIsapiApps"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_IN_PROCESS_ISAPI_APPS, MD_IN_PROCESS_ISAPI_APPS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("SSIExecDisable"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SSI_EXEC_DISABLED, MD_SSI_EXEC_DISABLED, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("EnableReverseDns"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DO_REVERSE_DNS, MD_DO_REVERSE_DNS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CreateCGIWithNewConsole"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CREATE_PROC_NEW_CONSOLE, MD_CREATE_PROC_NEW_CONSOLE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("LogModuleId"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOG_PLUGIN_MOD_ID, MD_LOG_PLUGIN_MOD_ID, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogModuleUiId"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOG_PLUGIN_UI_ID, MD_LOG_PLUGIN_UI_ID, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOG_TYPE, MD_LOG_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 1, TEXT("")},

      { TEXT("LogFilePeriod"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGFILE_PERIOD, MD_LOGFILE_PERIOD, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 1, TEXT("")},

      { TEXT("LogPluginClsid"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOG_PLUGIN_ORDER, MD_LOG_PLUGIN_ORDER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogModuleList"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOG_PLUGINS_AVAILABLE, MD_LOG_PLUGINS_AVAILABLE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("NCSA Common Log File Format, Microsoft IIS Log File Format, W3C Extended Log File Format")},

      { TEXT("LogFileDirectory"),
        TEXT(""), TEXT("ExpandSz"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_EXPANDSZ, MD_LOGFILE_DIRECTORY, MD_LOGFILE_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("%Windir%\\System32\\LogExtFiles")},

      { TEXT("LogFileTruncateSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGFILE_TRUNCATE_SIZE, MD_LOGFILE_TRUNCATE_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 2000000, TEXT("")},

      { TEXT("LogFileLocaltimeRollover"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_LOGFILE_LOCALTIME_ROLLOVER, MD_LOGFILE_LOCALTIME_ROLLOVER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileDate"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_DATE, MD_EXTLOG_DATE, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileTime"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_TIME, MD_EXTLOG_TIME, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileClientIp"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_CLIENT_IP, MD_EXTLOG_CLIENT_IP, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileUserName"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_USERNAME, MD_EXTLOG_USERNAME, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileSiteName"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_SITE_NAME, MD_EXTLOG_SITE_NAME, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileComputerName"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_COMPUTER_NAME, MD_EXTLOG_COMPUTER_NAME, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileServerIp"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_SERVER_IP, MD_EXTLOG_SERVER_IP, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileMethod"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_METHOD, MD_EXTLOG_METHOD, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileUriStem"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_URI_STEM, MD_EXTLOG_URI_STEM, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileUriQuery"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_URI_QUERY, MD_EXTLOG_URI_QUERY, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileHttpStatus"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_HTTP_STATUS, MD_EXTLOG_HTTP_STATUS, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileWin32Status"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_WIN32_STATUS, MD_EXTLOG_WIN32_STATUS, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileBytesSent"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_BYTES_SENT, MD_EXTLOG_BYTES_SENT, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileBytesRecv"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_BYTES_RECV, MD_EXTLOG_BYTES_RECV, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileTimeTaken"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_TIME_TAKEN, MD_EXTLOG_TIME_TAKEN, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileServerPort"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_SERVER_PORT, MD_EXTLOG_SERVER_PORT, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileUserAgent"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_USER_AGENT, MD_EXTLOG_USER_AGENT, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileCookie"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_COOKIE, MD_EXTLOG_COOKIE, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileReferer"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_REFERER, MD_EXTLOG_REFERER, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileProtocolVersion"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_PROTOCOL_VERSION , MD_EXTLOG_PROTOCOL_VERSION, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGEXT_FIELD_MASK, MD_LOGEXT_FIELD_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, MD_DEFAULT_EXTLOG_FIELDS, TEXT("")},

      { TEXT("LogExtFileHost"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_HOST, MD_EXTLOG_HOST, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogOdbcDataSource"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGSQL_DATA_SOURCES, MD_LOGSQL_DATA_SOURCES, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("HTTPLOG")},

      { TEXT("LogOdbcTableName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGSQL_TABLE_NAME, MD_LOGSQL_TABLE_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("InternetLog")},

      { TEXT("LogOdbcUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGSQL_USER_NAME, MD_LOGSQL_USER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("InternetAdmin")},

      { TEXT("LogOdbcPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGSQL_PASSWORD, MD_LOGSQL_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CacheControlMaxAge"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CC_MAX_AGE, MD_CC_MAX_AGE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CacheControlNoCache"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CC_NO_CACHE, MD_CC_NO_CACHE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CacheControlCustom"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_CC_OTHER, MD_CC_OTHER, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CreateProcessAsUser"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CREATE_PROCESS_AS_USER, MD_CREATE_PROCESS_AS_USER, 0, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD(-1), TEXT("")},

      { TEXT("DirectoryLevelsToScan"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LEVELS_TO_SCAN, MD_LEVELS_TO_SCAN, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 2, TEXT("")},

      { TEXT("MaxBandwidthBlocked"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_BANDWIDTH_BLOCKED, MD_MAX_BANDWIDTH_BLOCKED, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0xffffffff, TEXT("")},

      { TEXT("PoolIdcTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POOL_IDC_TIMEOUT, MD_POOL_IDC_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("PutReadSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_PUT_READ_SIZE, MD_PUT_READ_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 8192, TEXT("")},

      { TEXT("RedirectHeaders"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_REDIRECT_HEADERS, MD_REDIRECT_HEADERS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("UploadReadAheadSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_UPLOAD_READAHEAD_SIZE, MD_UPLOAD_READAHEAD_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 49152, TEXT("")},

      { TEXT("CPULimitsEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CPU_LIMITS_ENABLED, MD_CPU_LIMITS_ENABLED, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPUResetInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_RESET_INTERVAL, MD_CPU_RESET_INTERVAL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 24, TEXT("")},

      { TEXT("CPULoggingInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_LOGGING_INTERVAL, MD_CPU_LOGGING_INTERVAL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},

      { TEXT("CPULoggingOptions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_LOGGING_OPTIONS, MD_CPU_LOGGING_OPTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 1, TEXT("")},

      { TEXT("CPUEnableAllProcLogging"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_OPTIONS, MD_VPROP_CPU_ENABLE_ALL_PROC_LOGGING, MD_CPU_ENABLE_ALL_PROC_LOGGING, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnableCGILogging"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_OPTIONS, MD_VPROP_CPU_ENABLE_CGI_LOGGING, MD_CPU_ENABLE_CGI_LOGGING, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPUEnableAppLogging"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_OPTIONS, MD_VPROP_CPU_ENABLE_APP_LOGGING, MD_CPU_ENABLE_APP_LOGGING, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPULoggingMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_LOGGING_MASK, MD_CPU_LOGGING_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0x11111111, TEXT("")},

      { TEXT("CPULoggingEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_LOGGING, MD_CPU_ENABLE_LOGGING, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPUEnableEvent"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_EVENT, MD_CPU_ENABLE_EVENT, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnableProcType"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_PROC_TYPE, MD_CPU_ENABLE_PROC_TYPE, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnableUserTime"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_USER_TIME, MD_CPU_ENABLE_USER_TIME, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnableKernelTime"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_KERNEL_TIME, MD_CPU_ENABLE_KERNEL_TIME, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnablePageFaults"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_PAGE_FAULTS, MD_CPU_ENABLE_PAGE_FAULTS, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnableTotalProcs"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_TOTAL_PROCS, MD_CPU_ENABLE_TOTAL_PROCS, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnableActiveProcs"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_ACTIVE_PROCS, MD_CPU_ENABLE_ACTIVE_PROCS, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUEnableTerminatedProcs"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CPU_LOGGING_MASK, MD_VPROP_CPU_ENABLE_TERMINATED_PROCS, MD_CPU_ENABLE_TERMINATED_PROCS, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CPUCGILimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_CGI_LIMIT, MD_CPU_CGI_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPULimitLogEvent"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_LIMIT_LOGEVENT, MD_CPU_LIMIT_LOGEVENT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPULimitPriority"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_LIMIT_PRIORITY, MD_CPU_LIMIT_PRIORITY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPULimitProcStop"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_LIMIT_PROCSTOP, MD_CPU_LIMIT_PROCSTOP, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPULimitPause"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_LIMIT_PAUSE, MD_CPU_LIMIT_PAUSE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CPUAppEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CPU_APP_ENABLED, MD_CPU_APP_ENABLED, 0, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("CPUCGIEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CPU_CGI_ENABLED, MD_CPU_CGI_ENABLED, 0, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("LogCustomPropertyName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGCUSTOM_PROPERTY_NAME, MD_LOGCUSTOM_PROPERTY_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyHeader"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGCUSTOM_PROPERTY_HEADER, MD_LOGCUSTOM_PROPERTY_HEADER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyID"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGCUSTOM_PROPERTY_ID, MD_LOGCUSTOM_PROPERTY_ID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGCUSTOM_PROPERTY_MASK, MD_LOGCUSTOM_PROPERTY_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyDataType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGCUSTOM_PROPERTY_DATATYPE, MD_LOGCUSTOM_PROPERTY_DATATYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyServicesString"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_LOGCUSTOM_SERVICES_STRING, MD_LOGCUSTOM_SERVICES_STRING, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("W3Svc\0MSFTPSvc\0SmtpSvc\0NNTPSvc\0\0")},

      { TEXT("HcCompressionDirectory"),
        TEXT(""), TEXT("ExpandSz"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_EXPANDSZ, MD_HC_COMPRESSION_DIRECTORY, MD_HC_COMPRESSION_DIRECTORY, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("%Windir%\\IIS Temporary Compressed Files")},

      { TEXT("HcCacheControlHeader"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HC_CACHE_CONTROL_HEADER, MD_HC_CACHE_CONTROL_HEADER, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("max-age=86400")},

      { TEXT("HcExpiresHeader"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HC_EXPIRES_HEADER, MD_HC_EXPIRES_HEADER, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcDoDynamicCompression"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_DYNAMIC_COMPRESSION, MD_HC_DO_DYNAMIC_COMPRESSION, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcDoStaticCompression"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_STATIC_COMPRESSION, MD_HC_DO_STATIC_COMPRESSION, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("HcDoOnDemandCompression"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_ON_DEMAND_COMPRESSION, MD_HC_DO_ON_DEMAND_COMPRESSION, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("HcDoDiskSpaceLimiting"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_DISK_SPACE_LIMITING, MD_HC_DO_DISK_SPACE_LIMITING, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcNoCompressionForHttp10"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_NO_COMPRESSION_FOR_HTTP_10, MD_HC_NO_COMPRESSION_FOR_HTTP_10, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("HcNoCompressionForProxies"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_NO_COMPRESSION_FOR_PROXIES, MD_HC_NO_COMPRESSION_FOR_PROXIES, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcNoCompressionForRange"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_NO_COMPRESSION_FOR_RANGE, MD_HC_NO_COMPRESSION_FOR_RANGE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("HcSendCacheHeaders"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_SEND_CACHE_HEADERS, MD_HC_SEND_CACHE_HEADERS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("HcMaxDiskSpaceUsage"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_MAX_DISK_SPACE_USAGE, MD_HC_MAX_DISK_SPACE_USAGE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 1000000, TEXT("")},

      { TEXT("HcIoBufferSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_IO_BUFFER_SIZE, MD_HC_IO_BUFFER_SIZE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 8192, TEXT("")},

      { TEXT("HcCompressionBufferSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_COMPRESSION_BUFFER_SIZE, MD_HC_COMPRESSION_BUFFER_SIZE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 8192, TEXT("")},

      { TEXT("HcMaxQueueLength"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_MAX_QUEUE_LENGTH, MD_HC_MAX_QUEUE_LENGTH, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 1000, TEXT("")},

      { TEXT("HcFilesDeletedPerDiskFree"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_FILES_DELETED_PER_DISK_FREE, MD_HC_FILES_DELETED_PER_DISK_FREE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 256, TEXT("")},

      { TEXT("HcMinFileSizeForComp"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_MIN_FILE_SIZE_FOR_COMP, MD_HC_MIN_FILE_SIZE_FOR_COMP, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 256, TEXT("")},

      { TEXT("HcCompressionDll"),
        TEXT(""), TEXT("ExpandSz"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_EXPANDSZ, MD_HC_COMPRESSION_DLL, MD_HC_COMPRESSION_DLL, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcFileExtensions"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_HC_FILE_EXTENSIONS, MD_HC_FILE_EXTENSIONS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("HcScriptFileExtensions"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_HC_SCRIPT_FILE_EXTENSIONS, MD_HC_SCRIPT_FILE_EXTENSIONS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("HcMimeType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HC_MIME_TYPE, MD_HC_MIME_TYPE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcPriority"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_PRIORITY, MD_HC_PRIORITY, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 1, TEXT("")},

      { TEXT("HcDynamicCompressionLevel"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_DYNAMIC_COMPRESSION_LEVEL, MD_HC_DYNAMIC_COMPRESSION_LEVEL, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcOnDemandCompLevel"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_ON_DEMAND_COMP_LEVEL, MD_HC_ON_DEMAND_COMP_LEVEL, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 10, TEXT("")},

      { TEXT("HcCreateFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_CREATE_FLAGS, MD_HC_CREATE_FLAGS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AspEnableAspHtmlFallback"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLEASPHTMLFALLBACK, MD_ASP_ENABLEASPHTMLFALLBACK, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AspEnableChunkedEncoding"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLECHUNKEDENCODING, MD_ASP_ENABLECHUNKEDENCODING, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspEnableTypelibCache"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLETYPELIBCACHE, MD_ASP_ENABLETYPELIBCACHE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspErrorsToNTLog"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ERRORSTONTLOG, MD_ASP_ERRORSTONTLOG, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AspProcessorThreadMax"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_PROCESSORTHREADMAX, MD_ASP_PROCESSORTHREADMAX, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 10, TEXT("")},

      { TEXT("AspTrackThreadingModel"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_TRACKTHREADINGMODEL, MD_ASP_TRACKTHREADINGMODEL, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AspRequestQueueMax"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_REQEUSTQUEUEMAX, MD_ASP_REQEUSTQUEUEMAX, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 500, TEXT("")},

      { TEXT("AspEnableApplicationRestart"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLEAPPLICATIONRESTART, MD_ASP_ENABLEAPPLICATIONRESTART, 0, METADATA_NO_ATTRIBUTES, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspQueueConnectionTestTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_QUEUECONNECTIONTESTTIME, MD_ASP_QUEUECONNECTIONTESTTIME, 0, METADATA_INHERIT, ASP_MD_UT_APP, 3, TEXT("")},

      { TEXT("AspSessionMax"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SESSIONMAX, MD_ASP_SESSIONMAX, 0, METADATA_INHERIT, ASP_MD_UT_APP, -1, TEXT("")},

      { TEXT("AspThreadGateEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_THREADGATEENABLED, MD_ASP_THREADGATEENABLED, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspThreadGateTimeSlice"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_THREADGATETIMESLICE, MD_ASP_THREADGATETIMESLICE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 1000, TEXT("")},

      { TEXT("AspThreadGateSleepDelay"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_THREADGATESLEEPDELAY, MD_ASP_THREADGATESLEEPDELAY, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 100, TEXT("")},

      { TEXT("AspThreadGateSleepMax"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_THREADGATESLEEPMAX, MD_ASP_THREADGATESLEEPMAX, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 50, TEXT("")},

      { TEXT("AspThreadGateLoadLow"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_THREADGATELOADLOW, MD_ASP_THREADGATELOADLOW, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 75, TEXT("")},

      { TEXT("AspThreadGateLoadHigh"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_THREADGATELOADHIGH, MD_ASP_THREADGATELOADHIGH, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 90, TEXT("")},

      { TEXT("SslUseDsMapper"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SSL_USE_DS_MAPPER, MD_SSL_USE_DS_MAPPER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotDeletable"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_NOT_DELETABLE, MD_NOT_DELETABLE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ClusterEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CLUSTER_ENABLED, MD_CLUSTER_ENABLED, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SSLCertHash"),
        TEXT(""), TEXT("Binary"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_BINARY, MD_SSL_CERT_HASH, MD_SSL_CERT_HASH, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SSLStoreName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_STRING, MD_SSL_CERT_STORE_NAME, MD_SSL_CERT_STORE_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

//--------------------------------------------------------------------
//
//      -- BEGIN EXTENSION PROPERTIES -- magnush
//
//--------------------------------------------------------------------

                // I think this one should be added to the standard IIS properties:

      { TEXT("Win32Error"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_WIN32_ERROR, MD_WIN32_ERROR, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},



        //
        //      NNTP service:
        //

      { TEXT("HonorClientMsgIds"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HONOR_CLIENT_MSGIDS, MD_HONOR_CLIENT_MSGIDS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, TRUE, TEXT("")},

      { TEXT("SmtpServer"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_SERVER, MD_SMTP_SERVER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AdminEmail"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ADMIN_EMAIL, MD_ADMIN_EMAIL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AdminName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ADMIN_NAME, MD_ADMIN_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AllowClientPosts"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_CLIENT_POSTS, MD_ALLOW_CLIENT_POSTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, TRUE, TEXT("")},

      { TEXT("AllowFeedPosts"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_FEED_POSTS, MD_ALLOW_FEED_POSTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, TRUE, TEXT("")},

      { TEXT("AllowControlMsgs"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_CONTROL_MSGS, MD_ALLOW_CONTROL_MSGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, TRUE, TEXT("")},

      { TEXT("DefaultModeratorDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DEFAULT_MODERATOR, MD_DEFAULT_MODERATOR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NntpCommandLogMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_NNTP_COMMAND_LOG_MASK, MD_NNTP_COMMAND_LOG_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("DisableNewNews"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DISABLE_NEWNEWS, MD_DISABLE_NEWNEWS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ClientPostHardLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CLIENT_POST_HARD_LIMIT, MD_CLIENT_POST_HARD_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("ClientPostSoftLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CLIENT_POST_SOFT_LIMIT, MD_CLIENT_POST_SOFT_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("FeedPostHardLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_POST_HARD_LIMIT, MD_FEED_POST_HARD_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("FeedPostSoftLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_POST_SOFT_LIMIT, MD_FEED_POST_SOFT_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("NntpServiceVersion"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_NNTP_SERVICE_VERSION, MD_NNTP_SERVICE_VERSION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

        //
        //      NNTP Virtual Server:
        //

      { TEXT("FeedReportPeriod"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_REPORT_PERIOD, MD_FEED_REPORT_PERIOD, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxSearchResults"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_SEARCH_RESULTS, MD_MAX_SEARCH_RESULTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("GroupHelpFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_GROUP_HELP_FILE, MD_GROUP_HELP_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("GroupListFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_GROUP_LIST_FILE, MD_GROUP_LIST_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ArticleTableFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ARTICLE_TABLE_FILE, MD_ARTICLE_TABLE_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HistoryTableFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HISTORY_TABLE_FILE, MD_HISTORY_TABLE_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ListFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LIST_FILE, MD_LIST_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ModeratorFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MODERATOR_FILE, MD_MODERATOR_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("XoverTableFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_XOVER_TABLE_FILE, MD_XOVER_TABLE_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PrettyNamesFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_PRETTYNAMES_FILE, MD_PRETTYNAMES_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NewsPickupDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_PICKUP_DIRECTORY, MD_PICKUP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NewsFailedPickupDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FAILED_PICKUP_DIRECTORY, MD_FAILED_PICKUP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NewsDropDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DROP_DIRECTORY, MD_DROP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NntpUucpName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_NNTP_UUCP_NAME, MD_NNTP_UUCP_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ArticleTimeLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ARTICLE_TIME_LIMIT, MD_ARTICLE_TIME_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("HistoryExpiration"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HISTORY_EXPIRATION, MD_HISTORY_EXPIRATION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("NewsCrawlerTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_NEWS_CRAWLER_TIME, MD_NEWS_CRAWLER_TIME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("ShutdownLatency"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SHUTDOWN_LATENCY, MD_SHUTDOWN_LATENCY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("GroupvarListFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_GROUPVAR_LIST_FILE, MD_GROUPVAR_LIST_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NntpOrganization"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_NNTP_ORGANIZATION, MD_NNTP_ORGANIZATION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
    //
    //  Nntp Virtual roots:
    //

#if 0
      { TEXT("AccessAllowPosting"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_WRITE, MD_ACCESS_WRITE, METADATA_INHERIT, IIS_MD_UT_FILE, TRUE, TEXT("")},

      { TEXT("AccessRestrictGroupVisibility"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_EXECUTE, MD_ACCESS_EXECUTE, METADATA_INHERIT, IIS_MD_UT_FILE, FALSE, TEXT("")},
#endif

     //
     // IIsNntpVirtualDir
     //
      { TEXT("VrUseAccount"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_VR_USE_ACCOUNT, MD_VR_USE_ACCOUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("VrDoExpire"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_VR_DO_EXPIRE, MD_VR_DO_EXPIRE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("VrOwnModerator"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_VR_OWN_MODERATOR, MD_VR_OWN_MODERATOR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("VrDriverProgid"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_VR_DRIVER_PROGID, MD_VR_DRIVER_PROGID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FsPropertyPath"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FS_PROPERTY_PATH, MD_FS_PROPERTY_PATH, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ExMdbGuid"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_EX_MDB_GUID, MD_EX_MDB_GUID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

    //
    // IIsNntpExpire
    //
      { TEXT("ExpireSpace"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_EXPIRE_SPACE, MD_EXPIRE_SPACE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("ExpireTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_EXPIRE_TIME, MD_EXPIRE_TIME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("ExpireNewsgroups"),
        TEXT(""), TEXT("List"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_EXPIRE_NEWSGROUPS, MD_EXPIRE_NEWSGROUPS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ExpirePolicyName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_EXPIRE_POLICY_NAME, MD_EXPIRE_POLICY_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

    //
    // IIsNntpFeed
    //
      { TEXT("FeedServerName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_SERVER_NAME, MD_FEED_SERVER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_TYPE, MD_FEED_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedNewsgroups"),
        TEXT(""), TEXT("List"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_FEED_NEWSGROUPS, MD_FEED_NEWSGROUPS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedSecurityType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_SECURITY_TYPE, MD_FEED_SECURITY_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedAuthenticationType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_AUTHENTICATION_TYPE, MD_FEED_AUTHENTICATION_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedAcountName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_ACCOUNT_NAME, MD_FEED_ACCOUNT_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_PASSWORD, MD_FEED_PASSWORD, 0, METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedStartTimeHigh"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_START_TIME_HIGH, MD_FEED_START_TIME_HIGH, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedStartTimeLow"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_START_TIME_LOW, MD_FEED_START_TIME_LOW, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_INTERVAL, MD_FEED_INTERVAL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedAllowControlMsgs"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_ALLOW_CONTROL_MSGS, MD_FEED_ALLOW_CONTROL_MSGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedCreateAutomatically"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_CREATE_AUTOMATICALLY, MD_FEED_CREATE_AUTOMATICALLY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedDisabled"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_DISABLED, MD_FEED_DISABLED, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedDistribution"),
        TEXT(""), TEXT("List"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_FEED_DISTRIBUTION, MD_FEED_DISTRIBUTION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedConcurrentSessions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_CONCURRENT_SESSIONS, MD_FEED_CONCURRENT_SESSIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedMaxConnectionAttempts"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_MAX_CONNECTION_ATTEMPTS, MD_FEED_MAX_CONNECTION_ATTEMPTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedUucpName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_UUCP_NAME, MD_FEED_UUCP_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedTempDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_TEMP_DIRECTORY, MD_FEED_TEMP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedNextPullHigh"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_NEXT_PULL_HIGH, MD_FEED_NEXT_PULL_HIGH, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedNextPullLow"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_NEXT_PULL_LOW, MD_FEED_NEXT_PULL_LOW, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedPeerTempDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_PEER_TEMP_DIRECTORY, MD_FEED_PEER_TEMP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedPeerGapSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_PEER_GAP_SIZE, MD_FEED_PEER_GAP_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedOutgoingPort"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_OUTGOING_PORT, MD_FEED_OUTGOING_PORT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedFeedpaisId"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_FEEDPAIR_ID, MD_FEED_FEEDPAIR_ID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},
	
      { TEXT("FeedHandshake"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_HANDSHAKE, MD_FEED_HANDSHAKE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedAdminError"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_ADMIN_ERROR, MD_FEED_ADMIN_ERROR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedErrParmMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_ERR_PARM_MASK, MD_FEED_ERR_PARM_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

    //
    // IIsSmtpService
    //
      { TEXT("SmtpServiceVersion"),
        TEXT(""), TEXT("Integer"), 0, 1, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_SERVICE_VERSION, MD_SMTP_SERVICE_VERSION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},


      { TEXT("EnableReverseDnsLookup"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_REVERSE_NAME_LOOKUP, MD_REVERSE_NAME_LOOKUP, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ShouldDeliver"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SHOULD_DELIVER, MD_SHOULD_DELIVER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 1, TEXT("")},

      { TEXT("AlwaysUseSsl"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALWAYS_USE_SSL, MD_ALWAYS_USE_SSL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("AlwaysUseSasl"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALWAYS_USE_SASL, MD_ALWAYS_USE_SASL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

      { TEXT("LimitRemoteConnections"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_LIMIT_REMOTE_CONNECTIONS, MD_LIMIT_REMOTE_CONNECTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("DoMasquerade"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DO_MASQUERADE, MD_DO_MASQUERADE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmartHostType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMARTHOST_TYPE, MD_SMARTHOST_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RemoteSmtpPort"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_SMTP_PORT, MD_REMOTE_SMTP_PORT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 25, TEXT("")},

      { TEXT("RemoteSmtpSecurePort"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_SECURE_PORT, MD_REMOTE_SECURE_PORT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 465, TEXT("")},

      { TEXT("HopCount"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HOP_COUNT, MD_HOP_COUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 10, TEXT("")},

      { TEXT("MaxOutConnections"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_OUTBOUND_CONNECTION, MD_MAX_OUTBOUND_CONNECTION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxOutConnectionsPerDomain"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_OUT_CONN_PER_DOMAIN, MD_MAX_OUT_CONN_PER_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RemoteTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_TIMEOUT, MD_REMOTE_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxMessageSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_MSG_SIZE, MD_MAX_MSG_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0x2000000, TEXT("")},

      { TEXT("MaxSessionSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_MSG_SIZE_B4_CLOSE, MD_MAX_MSG_SIZE_B4_CLOSE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0x10000000, TEXT("")},

      { TEXT("MaxRecipients"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_RECIPIENTS, MD_MAX_RECIPIENTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 100, TEXT("")},

      { TEXT("LocalRetryInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOCAL_RETRY_MINUTES, MD_LOCAL_RETRY_MINUTES, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},

      { TEXT("RemoteRetryInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_RETRY_MINUTES, MD_REMOTE_RETRY_MINUTES, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},

      { TEXT("LocalRetryAttempts"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOCAL_RETRY_ATTEMPTS, MD_LOCAL_RETRY_ATTEMPTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 48, TEXT("")},

      { TEXT("RemoteRetryAttempts"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_RETRY_ATTEMPTS, MD_REMOTE_RETRY_ATTEMPTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 48, TEXT("")},

      { TEXT("EtrnDays"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ETRN_DAYS, MD_ETRN_DAYS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxBatchedMessages"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_BATCH_MSG_LIMIT, MD_BATCH_MSG_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxSmtpLogonErrors"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_SMTP_AUTHLOGON_ERRORS, MD_MAX_SMTP_AUTHLOGON_ERRORS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 4, TEXT("")},

      { TEXT("SmartHost"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMARTHOST_NAME, MD_SMARTHOST_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FullyQualifiedDomainName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FQDN_VALUE, MD_FQDN_VALUE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("DefaultDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DEFAULT_DOMAIN_VALUE, MD_DEFAULT_DOMAIN_VALUE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("DropDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MAIL_DROP_DIR, MD_MAIL_DROP_DIR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("BadMailDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_BAD_MAIL_DIR, MD_BAD_MAIL_DIR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PickupDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MAIL_PICKUP_DIR, MD_MAIL_PICKUP_DIR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("QueueDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MAIL_QUEUE_DIR, MD_MAIL_QUEUE_DIR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RoutingDll"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ROUTING_DLL, MD_ROUTING_DLL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MasqueradeDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MASQUERADE_NAME, MD_MASQUERADE_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SendNdrTo"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SEND_NDR_TO, MD_SEND_NDR_TO, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SaslLogonDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SASL_LOGON_DOMAIN, MD_SASL_LOGON_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("ServerSsAuthMapping"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SERVER_SS_AUTH_MAPPING, MD_SERVER_SS_AUTH_MAPPING, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

      { TEXT("SmtpClearTextProvider"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_CLEARTEXT_AUTH_PROVIDER, MD_SMTP_CLEARTEXT_AUTH_PROVIDER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SendBadTo"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SEND_BAD_TO, MD_SEND_BAD_TO, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RoutingSources"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RO, 0, IIS_SYNTAX_ID_MULTISZ, MD_ROUTING_SOURCES, MD_ROUTING_SOURCES, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("DomainRouting"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RO, 0, IIS_SYNTAX_ID_MULTISZ, MD_DOMAIN_ROUTING, MD_DOMAIN_ROUTING, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      //SMTP Retry related data
      { TEXT("SmtpRemoteProgressiveRetry"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_REMOTE_PROGRESSIVE_RETRY_MINUTES, MD_SMTP_REMOTE_PROGRESSIVE_RETRY_MINUTES, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpLocalDelayExpireMinutes"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EXPIRE_LOCAL_DELAY_MIN, MD_SMTP_EXPIRE_LOCAL_DELAY_MIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},

      { TEXT("SmtpLocalNDRExpireMinutes"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EXPIRE_LOCAL_NDR_MIN, MD_SMTP_EXPIRE_LOCAL_NDR_MIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 2880, TEXT("")},

      { TEXT("SmtpRemoteDelayExpireMinutes"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EXPIRE_REMOTE_DELAY_MIN, MD_SMTP_EXPIRE_REMOTE_DELAY_MIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},

      { TEXT("SmtpRemoteNDRExpireMinutes"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EXPIRE_REMOTE_NDR_MIN, MD_SMTP_EXPIRE_REMOTE_NDR_MIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 2880, TEXT("")},

      { TEXT("SmtpRemoteRetryThreshold"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_REMOTE_RETRY_THRESHOLD, MD_SMTP_REMOTE_RETRY_THRESHOLD, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 3, TEXT("")},

      { TEXT("SmtpDSNOptions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DSN_OPTIONS, MD_SMTP_DSN_OPTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDSNLanguageID"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DSN_LANGUAGE_ID, MD_SMTP_DSN_LANGUAGE_ID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpInboundCommandSupportOptions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_INBOUND_COMMAND_SUPPORT_OPTIONS, MD_INBOUND_COMMAND_SUPPORT_OPTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, SMTP_DEFAULT_CMD_SUPPORT, TEXT("")},

      { TEXT("SmtpOutboundCommandSupportOptions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_OUTBOUND_COMMAND_SUPPORT_OPTIONS, MD_OUTBOUND_COMMAND_SUPPORT_OPTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, SMTP_DEFAULT_CMD_SUPPORT, TEXT("")},

      { TEXT("SmtpAdvQueueDll"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_AQUEUE_DLL, MD_AQUEUE_DLL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

    // IIsSmtpDomain
    //
      { TEXT("RouteAction"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ROUTE_ACTION, MD_ROUTE_ACTION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RouteActionString"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ROUTE_ACTION_TYPE, MD_ROUTE_ACTION_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RouteUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ROUTE_USER_NAME, MD_ROUTE_USER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RoutePassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ROUTE_PASSWORD, MD_ROUTE_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpCommandLogMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_COMMAND_LOG_MASK, MD_COMMAND_LOG_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpFlushMailFile"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FLUSH_MAIL_FILE, MD_FLUSH_MAIL_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RelayIpList"),
        TEXT(""), TEXT("IPSec"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_IPSECLIST, MD_SMTP_IP_RELAY_ADDRESSES, MD_SMTP_IP_RELAY_ADDRESSES, 0, METADATA_INHERIT | METADATA_REFERENCE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RelayForAuth"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_RELAY_FOR_AUTH_USERS, MD_SMTP_RELAY_FOR_AUTH_USERS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AuthTurnList"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_SMTP_AUTHORIZED_TURN_LIST, MD_SMTP_AUTHORIZED_TURN_LIST, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CSideEtrnDomains"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_CSIDE_ETRN_DOMAIN, MD_SMTP_CSIDE_ETRN_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      // ---

      { TEXT("SmtpConnectTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_CONNECT_TIMEOUT, MD_SMTP_CONNECT_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpMailFromTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_MAILFROM_TIMEOUT, MD_SMTP_MAILFROM_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpRcptToTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_RCPTTO_TIMEOUT, MD_SMTP_RCPTTO_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDataTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DATA_TIMEOUT, MD_SMTP_DATA_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpBdatTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_BDAT_TIMEOUT, MD_SMTP_BDAT_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpAuthTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_AUTH_TIMEOUT, MD_SMTP_AUTH_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpSaslTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_SASL_TIMEOUT, MD_SMTP_SASL_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("SmtpEtrnTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_ETRN_TIMEOUT, MD_SMTP_ETRN_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

      { TEXT("SmtpTurnTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_TURN_TIMEOUT, MD_SMTP_TURN_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpRsetTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_RSET_TIMEOUT, MD_SMTP_RSET_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("SmtpQuitTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_QUIT_TIMEOUT, MD_SMTP_QUIT_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

      { TEXT("SmtpHeloTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_HELO_TIMEOUT, MD_SMTP_HELO_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("SmtpEhloTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EHLO_TIMEOUT, MD_SMTP_EHLO_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDataTermTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DATATERMINATION_TIMEOUT, MD_SMTP_DATATERMINATION_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpBdatTermTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_BDATTERMINATION_TIMEOUT, MD_SMTP_BDATTERMINATION_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpTlsTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_TLS_TIMEOUT, MD_SMTP_TLS_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

    // IIsPop3Service
    //
      { TEXT("Pop3ServiceVersion"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_SERVICE_VERSION, MD_POP3_SERVICE_VERSION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3ExpireMail"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_EXPIRE_INSTANCE_MAIL, MD_POP3_EXPIRE_INSTANCE_MAIL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3ExpireDelay"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_EXPIRE_DELAY, MD_POP3_EXPIRE_DELAY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (24*60), TEXT("")},

      { TEXT("Pop3ExpireStart"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_EXPIRE_START, MD_POP3_EXPIRE_START, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3ClearTextProvider"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_CLEARTEXT_AUTH_PROVIDER, MD_POP3_CLEARTEXT_AUTH_PROVIDER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DefaultDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DEFAULT_DOMAIN_VALUE, MD_POP3_DEFAULT_DOMAIN_VALUE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3RoutingDll"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_ROUTING_DLL, MD_POP3_ROUTING_DLL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3RoutingSources"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RO, 0, IIS_SYNTAX_ID_MULTISZ, MD_POP3_ROUTING_SOURCE, MD_POP3_ROUTING_SOURCE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},


    // IIsImapService
    //
      { TEXT("ImapServiceVersion"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_SERVICE_VERSION, MD_IMAP_SERVICE_VERSION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapExpireMail"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_EXPIRE_INSTANCE_MAIL, MD_IMAP_EXPIRE_INSTANCE_MAIL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapExpireDelay"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_EXPIRE_DELAY, MD_IMAP_EXPIRE_DELAY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (24*60), TEXT("")},

      { TEXT("ImapExpireStart"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_EXPIRE_START, MD_IMAP_EXPIRE_START, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapClearTextProvider"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_CLEARTEXT_AUTH_PROVIDER, MD_IMAP_CLEARTEXT_AUTH_PROVIDER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDefaultDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DEFAULT_DOMAIN_VALUE, MD_IMAP_DEFAULT_DOMAIN_VALUE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapRoutingDll"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_ROUTING_DLL, MD_IMAP_ROUTING_DLL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapRoutingSources"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RO, 0, IIS_SYNTAX_ID_MULTISZ, MD_IMAP_ROUTING_SOURCE, MD_IMAP_ROUTING_SOURCE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

    // IIsPop3VirtualDir
    //
      { TEXT("Pop3MailExpirationTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_EXPIRE_MSG_HOURS, MD_POP3_EXPIRE_MSG_HOURS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

    // IIsImapVirtualDir
    //
      { TEXT("ImapMailExpirationTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_EXPIRE_MSG_HOURS, MD_IMAP_EXPIRE_MSG_HOURS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

    // IIsSmtpRoutingSource
    //
      { TEXT("SmtpRoutingTableType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_TYPE, MD_SMTP_DS_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("LDAP")},

      { TEXT("SmtpDsDataDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_DATA_DIRECTORY, MD_SMTP_DS_DATA_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsDefaultMailRoot"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_DEFAULT_MAIL_ROOT, MD_SMTP_DS_DEFAULT_MAIL_ROOT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsBindType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_BIND_TYPE, MD_SMTP_DS_BIND_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsSchemaType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_SCHEMA_TYPE, MD_SMTP_DS_SCHEMA_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsHost"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_HOST, MD_SMTP_DS_HOST, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsNamingContext"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_NAMING_CONTEXT, MD_SMTP_DS_NAMING_CONTEXT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_DOMAIN, MD_SMTP_DS_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsAccount"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_ACCOUNT, MD_SMTP_DS_ACCOUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_PASSWORD, MD_SMTP_DS_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsUseCat"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DS_USE_CAT, MD_SMTP_DS_USE_CAT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DS_FLAGS, MD_SMTP_DS_FLAGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsPort"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DS_PORT, MD_SMTP_DS_PORT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

    // IIsPop3RoutingSource
    //
      { TEXT("Pop3RoutingTableType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_TYPE, MD_POP3_DS_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("LDAP")},

      { TEXT("Pop3DsDataDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_DATA_DIRECTORY, MD_POP3_DS_DATA_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsDefaultMailRoot"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_DEFAULT_MAIL_ROOT, MD_POP3_DS_DEFAULT_MAIL_ROOT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsBindType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_BIND_TYPE, MD_POP3_DS_BIND_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsSchemaType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_SCHEMA_TYPE, MD_POP3_DS_SCHEMA_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsHost"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_HOST, MD_POP3_DS_HOST, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsNamingContext"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_NAMING_CONTEXT, MD_POP3_DS_NAMING_CONTEXT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsAccount"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_ACCOUNT, MD_POP3_DS_ACCOUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_PASSWORD, MD_POP3_DS_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},


    // IIsImapRoutingSource
    //
      { TEXT("ImapRoutingTableType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_TYPE, MD_IMAP_DS_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("LDAP")},

      { TEXT("ImapDsDataDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_DATA_DIRECTORY, MD_IMAP_DS_DATA_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsDefaultMailRoot"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_DEFAULT_MAIL_ROOT, MD_IMAP_DS_DEFAULT_MAIL_ROOT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsBindType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_BIND_TYPE, MD_IMAP_DS_BIND_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsSchemaType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_SCHEMA_TYPE, MD_IMAP_DS_SCHEMA_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsHost"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_HOST, MD_IMAP_DS_HOST, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsNamingContext"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_NAMING_CONTEXT, MD_IMAP_DS_NAMING_CONTEXT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsAccount"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_ACCOUNT, MD_IMAP_DS_ACCOUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_PASSWORD, MD_IMAP_DS_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},


//--------------------------------------------------------------------
//
//      -- END EXTENSION PROPERTIES -- magnush
//
//--------------------------------------------------------------------

#if 0
        // THis is the blank property template
      { TEXT(""),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FILTER_LOAD_ORDER, MD_FILTER_LOAD_ORDER, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif
};


DWORD g_cIISProperties = sizeof(g_aIISProperties)/sizeof(PROPERTYINFO);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\include\caiheap.h ===
//+---------------------------------------------------------------------------
//  File:       caiheap.h
//
//  Contents:   Heap debugging structures and routines for the heap code
//              in commnot
//
//  History:    28-Oct-92   IsaacHe     Created
//
//----------------------------------------------------------------------------

#ifndef _CAIHEAP_H_
#define _CAIHEAP_H_

//
// We keep a stack backtrace for each allocated block of memory.  DEPTHTRACE
// is the number of frames that we record
//
#define DEPTHTRACE   26                 // depth of stack backtraces

//
// The AllocArena structure has this signature at its front.  We put a
// signature on the structure to allow external processes to snapshot the
// debug information and do some minimal check to see they are looking at the
// right stuff
//
const char HEAPSIG[] = { 'H', 'E', 'P', DEPTHTRACE };

// We keep track of the stack backtraces of allocation calls
// in these structues.

struct HeapAllocRec {
        DWORD   sum;            // checksum of stack backtrace
        void *fTrace[ DEPTHTRACE ];     // stack backtrace
        DWORD   count;          // # of un-freed allocs from this place
        size_t  bytes;          // # of un-freed bytes from this place
        struct AllocArena *paa; // points back to the beginning...
        struct {
                DWORD   count;  // # of allocs from this place
                size_t  bytes;  // # of bytes from this place
        } total;
        union {
                struct HeapAllocRec *next; // next bucket in the hash list
                void *ImageBase;        // base addr of containing module
        } u;
};

struct AllocArena {

        char Signature [ sizeof(HEAPSIG) ];
        char comment[ 32 ];
        CRITICAL_SECTION csExclusive;   // ensures single writer

        struct {
                int KeepStackTrace:1;   // are stack records being kept?
        } flags;

        ULONG cAllocs;                  // # of non zero Alloc calls
        ULONG czAllocs;                 // # of Alloc calls w/zero count
        ULONG cFrees;                   // # of Free calls
        ULONG cReAllocs;                // # of realloc calls
        ULONG cMissed;                  // # of missed stack backtraces
        ULONG cRecords;                 // index of next free AllocRec entry
        ULONG cBytesNow;                // # of bytes currently allocated
        ULONG cBytesTotal;              // # of bytes ever allocated
        ULONG cTotalRecords;            // Total # of AllocRecs
        ULONG cPaths;                   // # of distinct allocation paths

        struct {
                ULONG total[ 32 ];      // total number of allocations
                ULONG now[ 32 ];        // current # of simul allocs
                ULONG simul[ 32 ];      // highest # of simul allocs
        } Histogram;

        struct HeapAllocRec AllocRec[1]; // vector of records starts here..
};

/*
 * Allocators may want to associate one of these structures with every
 * allocation...
 */
struct AHeader {
        struct HeapAllocRec FAR *p;
        size_t size;
};

STDAPI_(struct AllocArena ** )
AllocArenaAddr( void );

STDAPI_( struct AllocArena * )
AllocArenaCreate( DWORD memctx, char FAR *comment );

STDAPI_( struct HeapAllocRec FAR * )
AllocArenaRecordAlloc( struct AllocArena *paa, size_t bytes );

STDAPI_(void)
AllocArenaRecordReAlloc( struct HeapAllocRec FAR *vp,
                        size_t oldbytes, size_t newbytes );

STDAPI_(void)
AllocArenaRecordFree( struct HeapAllocRec FAR *vp, size_t bytes );

STDAPI_(void)
AllocArenaDump( struct AllocArena *paa );

STDAPI_( void )
AllocArenaDumpRecord( struct HeapAllocRec FAR *bp );

#endif  // ifndef _CAIHEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\include\dswarn.h ===
#include <warning.h>

#pragma warning (disable: 4101 4201 4100 4244 4245 4706 4786 4267 4701 4115 4509 4214 4057 4127 4189 4702)

#pragma warning (disable:  4514 4512 4663)

/**************************************************************************

DESCRIPTION OF WARNINGS THAT ARE DISABLED

4101  unreferenced local variable

*4201  nonstandard extension: nameless struct or union

*4214  non standard extension: bit field types other than int

*4115  named type definition in paranthesis -- does not like THSTATE

*4127  conditional expression is a constant

4100  ureferenced formal parameter

*4189  local variable is initialized but not referenced 

*4057 slightly different base types -- char * and unsigned char *

4244 conversion from into to char --loss of data -- I saw a few of these and disabled in an effort to get the code to compile -- need further investigation.

4245 conversion from long to unsigned long -- signed/unsigned mismatch

*4509 non standard extension used -- uses SEH and has destructor

4706 assignment within a conditional expression

4702  *unreacheable code

*4701  var used before initializing

4786  identifier truncated to 255 chars in debug information

4267  Signal to noise ratio of this warning is pretty poor -- too many 
      '=' conversion from size_t to unsigned long, possible loss of data
      The problem is that size_t in 64 bit is defined as a 64 bit int,
      while ulong is still a 32 bit int. In practice most places this is
      used -- e.g sizeof operator, or string len etc the value will fit 
      in a 32 bit ULONG

4514 unreferenced inline function has been removed

4512 assignment operator could not be generated

4663 C++ language change: to explicitly specialize class template 'identifier' use the following syntax

VALID WARNINGS ENCOUNTERED 

( 4267, 4701, 4702 and 4706 can also be included in
this list if desired )

4306 TypeCast -- conversion from unsigned short to unsigned short *

4305 Typecase -- truncation from unsigned short * to unsigned short

4312 TypeCase -- Conversion from unsigned long to void * __ptr64 of greater size



****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\include\adstype.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:
//
//  Contents:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#ifndef _ADSTYPE_H_INCLUDED_
#define _ADSTYPE_H_INCLUDED_

typedef enum {
   ADSTYPE_INVALID = 0,
   ADSTYPE_DN_STRING,
   ADSTYPE_CASE_EXACT_STRING,
   ADSTYPE_CASE_IGNORE_STRING,
   ADSTYPE_PRINTABLE_STRING,
   ADSTYPE_NUMERIC_STRING,
   ADSTYPE_BOOLEAN,
   ADSTYPE_INTEGER,
   ADSTYPE_OCTET_STRING,
   ADSTYPE_UTC_TIME,
   ADSTYPE_LARGE_INTEGER,
   ADSTYPE_PROV_SPECIFIC,
   ADSTYPE_OBJECT_CLASS,
   ADSTYPE_CASEIGNORE_LIST,
   ADSTYPE_OCTET_LIST,
   ADSTYPE_PATH,
   ADSTYPE_POSTALADDRESS,
   ADSTYPE_TIMESTAMP,
   ADSTYPE_BACKLINK,
   ADSTYPE_TYPEDNAME,
   ADSTYPE_HOLD,
   ADSTYPE_NETADDRESS,
   ADSTYPE_REPLICAPOINTER,
   ADSTYPE_FAXNUMBER,
   ADSTYPE_EMAIL,
   ADSTYPE_NT_SECURITY_DESCRIPTOR,
   ADSTYPE_UNKNOWN,
   ADSTYPE_DN_WITH_BINARY,
   ADSTYPE_DN_WITH_STRING
} ADSTYPEENUM;
typedef ADSTYPEENUM ADSTYPE;

//
// ADSTYPE_UNKNOWN was added to the end to be save and not break anyone.
// If further types are added, this will be in the middle which is not
// the best position but nonethesless functional.
//


typedef unsigned char BYTE, *LPBYTE, *PBYTE;


//
// ADS Case DN String syntax
//

typedef LPWSTR ADS_DN_STRING, * PADS_DN_STRING;

//
// ADS Case Exact String syntax
//

typedef LPWSTR ADS_CASE_EXACT_STRING, * PADS_CASE_EXACT_STRING;

//
// ADS Case Ignore String syntax
//

typedef LPWSTR ADS_CASE_IGNORE_STRING, *PADS_CASE_IGNORE_STRING;

//
// ADS Printable String syntax
//

typedef LPWSTR ADS_PRINTABLE_STRING, *PADS_PRINTABLE_STRING;

//
// ADS Numeric String syntax
//
//

typedef LPWSTR ADS_NUMERIC_STRING, *PADS_NUMERIC_STRING;


//
// ADS Boolean syntax
//

typedef DWORD ADS_BOOLEAN, * LPNDS_BOOLEAN;

//
// Example: ADS Integer syntax
//

typedef DWORD ADS_INTEGER, *PADS_INTEGER;

//
// ADS Octet String syntax
//

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_OCTET_STRING, *PADS_OCTET_STRING;


//
// ADS NT Security Descriptor syntax
//

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_NT_SECURITY_DESCRIPTOR, *PADS_NT_SECURITY_DESCRIPTOR;


//
// ADS UTC Time Syntax
//

typedef SYSTEMTIME ADS_UTC_TIME, *PADS_UTC_TIME;


typedef LARGE_INTEGER ADS_LARGE_INTEGER, *PADS_LARGE_INTEGER;



//
// ADS ClassName syntax
//

typedef LPWSTR  ADS_OBJECT_CLASS, *PADS_OBJECT_CLASS;

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_PROV_SPECIFIC, *PADS_PROV_SPECIFIC;

//
// Extended Syntaxes for NDS
//
typedef struct _ADS_CASEIGNORE_LIST
{
    struct _ADS_CASEIGNORE_LIST *Next;
    LPWSTR            String;

}
ADS_CASEIGNORE_LIST, *PADS_CASEIGNORE_LIST;


typedef struct _ADS_OCTET_LIST
{
    struct _ADS_OCTET_LIST *Next;
    DWORD  Length;
    BYTE * Data;

} ADS_OCTET_LIST, *PADS_OCTET_LIST;

typedef struct
{
    DWORD  Type;
    LPWSTR VolumeName;
    LPWSTR Path;

} ADS_PATH, *PADS_PATH;

typedef struct
{
    LPWSTR PostalAddress[6]; // Value is limited to 6 lines,
                             // 30 characters each.

} ADS_POSTALADDRESS, *PADS_POSTALADDRESS;

typedef struct
{
    DWORD WholeSeconds; // Zero equals 12:00 midnight, January 1, 1970, UTC
    DWORD EventID;

} ADS_TIMESTAMP, *PADS_TIMESTAMP;

typedef struct
{
    DWORD  RemoteID;
    LPWSTR ObjectName;

} ADS_BACKLINK, *PADS_BACKLINK;

typedef struct
{
    LPWSTR ObjectName;
    DWORD  Level;
    DWORD  Interval;

} ADS_TYPEDNAME, *PADS_TYPEDNAME;

typedef struct
{
    LPWSTR ObjectName;
    DWORD  Amount;

} ADS_HOLD, *PADS_HOLD;

typedef struct
{
    DWORD  AddressType; // 0 = IPX,
    DWORD  AddressLength;
    BYTE * Address;

} ADS_NETADDRESS, *PADS_NETADDRESS;

typedef struct
{
    LPWSTR ServerName;
    DWORD  ReplicaType;
    DWORD  ReplicaNumber;
    DWORD  Count;
    PADS_NETADDRESS ReplicaAddressHints;
} ADS_REPLICAPOINTER, *PADS_REPLICAPOINTER;

typedef struct
{
    LPWSTR TelephoneNumber;
    DWORD  NumberOfBits;
    LPBYTE Parameters;
} ADS_FAXNUMBER, *PADS_FAXNUMBER;

typedef struct
{
    LPWSTR Address;
    DWORD  Type;
} ADS_EMAIL, *PADS_EMAIL;

typedef struct
{
    DWORD dwLength;
    LPBYTE lpBinaryValue;
    LPWSTR pszDNString;
} ADS_DN_WITH_BINARY, *PADS_DN_WITH_BINARY;

typedef struct
{
    LPWSTR pszStringValue;
    LPWSTR pszDNString;
} ADS_DN_WITH_STRING, *PADS_DN_WITH_STRING;


typedef struct _adsvalue{
   ADSTYPE dwType;
   union {
      ADS_DN_STRING                     DNString;
      ADS_CASE_EXACT_STRING             CaseExactString;
      ADS_CASE_IGNORE_STRING            CaseIgnoreString;
      ADS_PRINTABLE_STRING              PrintableString;
      ADS_NUMERIC_STRING                NumericString;
      ADS_BOOLEAN                       Boolean;
      ADS_INTEGER                       Integer;
      ADS_OCTET_STRING                  OctetString;
      ADS_UTC_TIME                      UTCTime;
      ADS_LARGE_INTEGER                 LargeInteger;
      ADS_OBJECT_CLASS                  ClassName;
      ADS_PROV_SPECIFIC                 ProviderSpecific;
      PADS_CASEIGNORE_LIST              pCaseIgnoreList;
      PADS_OCTET_LIST                   pOctetList;
      PADS_PATH                         pPath;
      PADS_POSTALADDRESS                pPostalAddress;
      ADS_TIMESTAMP                     Timestamp;
      ADS_BACKLINK                      BackLink;
      PADS_TYPEDNAME                    pTypedName;
      ADS_HOLD                          Hold;
      PADS_NETADDRESS                   pNetAddress;
      PADS_REPLICAPOINTER               pReplicaPointer;
      PADS_FAXNUMBER                    pFaxNumber;
      ADS_EMAIL                         Email;
      ADS_NT_SECURITY_DESCRIPTOR        SecurityDescriptor;
      PADS_DN_WITH_BINARY               pDNWithBinary;
      PADS_DN_WITH_STRING               pDNWithString;
   };
}ADSVALUE, *PADSVALUE, *LPADSVALUE;

typedef struct _ads_attr_info{
    LPWSTR  pszAttrName;
    DWORD   dwControlCode;
    ADSTYPE dwADsType;
    PADSVALUE pADsValues;
    DWORD   dwNumValues;
} ADS_ATTR_INFO, *PADS_ATTR_INFO;

typedef enum {
    ADS_SECURE_AUTHENTICATION = 0x00000001,
    ADS_USE_ENCRYPTION        = 0x00000002,
    ADS_USE_SSL               = 0x00000002,
    ADS_READONLY_SERVER       = 0x00000004,
    ADS_PROMPT_CREDENTIALS    = 0x00000008,
    ADS_NO_AUTHENTICATION     = 0x00000010,
    ADS_FAST_BIND             = 0x00000020,
    ADS_USE_SIGNING           = 0x00000040,
    ADS_USE_SEALING           = 0x00000080,
    ADS_USE_DELEGATION        = 0x00000100,
    ADS_SERVER_BIND           = 0x00000200,
    ADS_AUTH_RESERVED         = 0x80000000
} ADS_AUTHENTICATION_ENUM;

/* ADS attribute modification operations */

const int ADS_ATTR_CLEAR          =  1; /* Clear all values from an attribute */
const int ADS_ATTR_UPDATE         =  2; /* Update values on an attribute */
const int ADS_ATTR_APPEND         =  3; /* Append  values to an attribute  */
const int ADS_ATTR_DELETE         =  4; /* Delete values from an attribute  */


typedef struct _ads_object_info{
    LPWSTR pszRDN;
    LPWSTR pszObjectDN;
    LPWSTR pszParentDN;
    LPWSTR pszSchemaDN;
    LPWSTR pszClassName;
} ADS_OBJECT_INFO, *PADS_OBJECT_INFO;

typedef enum {
    ADS_STATUS_S_OK = 0,
    ADS_STATUS_INVALID_SEARCHPREF,
    ADS_STATUS_INVALID_SEARCHPREFVALUE
} ADS_STATUSENUM;

typedef ADS_STATUSENUM ADS_STATUS, *PADS_STATUS;



typedef enum {
    ADS_DEREF_NEVER           = 0,
    ADS_DEREF_SEARCHING       = 1,
    ADS_DEREF_FINDING         = 2,
    ADS_DEREF_ALWAYS          = 3
} ADS_DEREFENUM;

typedef enum {
    ADS_SCOPE_BASE            = 0,
    ADS_SCOPE_ONELEVEL        = 1,
    ADS_SCOPE_SUBTREE         = 2
} ADS_SCOPEENUM;

// Some more useful enums moved from other places
typedef enum {

    ADSIPROP_ASYNCHRONOUS       =   0x00000000,
    ADSIPROP_DEREF_ALIASES      =   0x00000001,
    ADSIPROP_SIZE_LIMIT         =   0x00000002,
    ADSIPROP_TIME_LIMIT         =   0x00000003,
    ADSIPROP_ATTRIBTYPES_ONLY   =   0x00000004,
    ADSIPROP_SEARCH_SCOPE       =   0x00000005,
    ADSIPROP_TIMEOUT            =   0x00000006,
    ADSIPROP_PAGESIZE           =   0x00000007,
    ADSIPROP_PAGED_TIME_LIMIT   =   0x00000008,
    ADSIPROP_CHASE_REFERRALS    =   0x00000009,
    ADSIPROP_SORT_ON            =   0x0000000a,
    ADSIPROP_CACHE_RESULTS      =   0x0000000b,
    ADSIPROP_ADSIFLAG           =   0x0000000c

} ADS_PREFERENCES_ENUM;


typedef enum {

    ADSI_DIALECT_LDAP     =  0x00000000,
    ADSI_DIALECT_SQL      =  0x00000001

} ADSI_DIALECT_ENUM;

//
// Values for ChaseReferral Option.
typedef enum {

    ADS_CHASE_REFERRALS_NEVER         =  0x00000000,
    ADS_CHASE_REFERRALS_SUBORDINATE   =  0x00000020,
    ADS_CHASE_REFERRALS_EXTERNAL      =  0x00000040,
    ADS_CHASE_REFERRALS_ALWAYS        =
            (ADS_CHASE_REFERRALS_SUBORDINATE | ADS_CHASE_REFERRALS_EXTERNAL)
} ADS_CHASE_REFERRALS_ENUM;

typedef enum {
   ADS_SEARCHPREF_ASYNCHRONOUS,
   ADS_SEARCHPREF_DEREF_ALIASES,
   ADS_SEARCHPREF_SIZE_LIMIT,
   ADS_SEARCHPREF_TIME_LIMIT,
   ADS_SEARCHPREF_ATTRIBTYPES_ONLY,
   ADS_SEARCHPREF_SEARCH_SCOPE,
   ADS_SEARCHPREF_TIMEOUT,
   ADS_SEARCHPREF_PAGESIZE,
   ADS_SEARCHPREF_PAGED_TIME_LIMIT,
   ADS_SEARCHPREF_CHASE_REFERRALS,
   ADS_SEARCHPREF_SORT_ON,
   ADS_SEARCHPREF_CACHE_RESULTS,
   ADS_SEARCHPREF_DIRSYNC,
   ADS_SEARCHPREF_TOMBSTONE,
   ADS_SEARCHPREF_VLV,
   ADS_SEARCHPREF_ATTRIBUTE_QUERY,
   ADS_SEARCHPREF_SECURITY_MASK

} ADS_SEARCHPREF_ENUM;

typedef ADS_SEARCHPREF_ENUM ADS_SEARCHPREF;

typedef struct ads_searchpref_info{
    ADS_SEARCHPREF dwSearchPref;
    ADSVALUE vValue;
    ADS_STATUS dwStatus;
} ADS_SEARCHPREF_INFO, *PADS_SEARCHPREF_INFO, *LPADS_SEARCHPREF_INFO;


const LPWSTR ADS_DIRSYNC_COOKIE=L"fc8cb04d-311d-406c-8cb9-1ae8b843b418";
const LPWSTR ADS_VLV_RESPONSE  =L"fc8cb04d-311d-406c-8cb9-1ae8b843b419";

typedef HANDLE ADS_SEARCH_HANDLE, *PADS_SEARCH_HANDLE;


typedef struct ads_search_column {
   LPWSTR  pszAttrName;
   ADSTYPE dwADsType;
   PADSVALUE pADsValues;
   DWORD   dwNumValues;
   HANDLE hReserved;
} ADS_SEARCH_COLUMN, *PADS_SEARCH_COLUMN;


typedef struct _ads_attr_def {
   LPWSTR pszAttrName;
    ADSTYPE dwADsType;
    DWORD dwMinRange;
    DWORD dwMaxRange;
    BOOL fMultiValued;
}ADS_ATTR_DEF, *PADS_ATTR_DEF;


typedef struct _ads_class_def {
    LPWSTR pszClassName;
    DWORD  dwMandatoryAttrs;
    LPWSTR *ppszMandatoryAttrs;
    DWORD optionalAttrs;
    LPWSTR **ppszOptionalAttrs;
    DWORD dwNamingAttrs;
    LPWSTR **ppszNamingAttrs;
    DWORD dwSuperClasses;
    LPWSTR **ppszSuperClasses;
    BOOL fIsContainer;
}ADS_CLASS_DEF, *PADS_CLASS_DEF;


typedef struct _ads_sortkey {

    LPWSTR  pszAttrType;
    LPWSTR  pszReserved;
    BOOLEAN fReverseorder;

} ADS_SORTKEY, *PADS_SORTKEY;


typedef struct _ads_vlv {

    DWORD dwBeforeCount;
    DWORD dwAfterCount;
    DWORD dwOffset;
    DWORD dwContentCount;
    LPWSTR pszTarget;
    DWORD  dwContextIDLength;
    LPBYTE lpContextID;
} ADS_VLV, *PADS_VLV;

//
// Valid dispids for extension.
//
// - Max 24 bits.
// - 0 reserved for DISPID_VALUE dealt with by aggregator.
// - DISPID_UNKNOWN (-1) also allowed.
// - Others -ve dispids dealt with by aggregator only.
//

const int ADS_EXT_MINEXTDISPID = 1 ;
const int ADS_EXT_MAXEXTDISPID = 16777215 ;


//
// dwCodes for IADsExtension::Operate
//

const int ADS_EXT_INITCREDENTIALS       = 1 ;
const int ADS_EXT_INITIALIZE_COMPLETE   = 2 ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\include\heapstat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       Heapstats.hxx
//
//  Contents:   Structure that holds heap statistics.
//
//  Classes:    HEAPSTATS
//
//  History:    26-Oct-93 DavidBak      Created
//
//--------------------------------------------------------------------------

#if !defined(__HEAPSTAT_HXX__)
#define __HEAPSTAT_HXX__

#if (PERFSNAP == 1) || (DBG == 1)

//+-------------------------------------------------------------------------
//
//  Class:      HEAPSTATS
//
//  Purpose:    Data structure containing performance counters from the heap.
//              Used in our version of operator new.
//              See common\src\except\memory.cxx.
//
//--------------------------------------------------------------------------

typedef struct _HeapStats
{
    ULONG	cNew;
    ULONG	cZeroNew;
    ULONG	cDelete;
    ULONG	cZeroDelete;
    ULONG	cRealloc;
    ULONG       cbNewed;
    ULONG       cbDeleted;
} HEAPSTATS;

//
// GetHeapStats is in memory.cxx
//

#ifdef __cplusplus
extern "C" {
#endif

void GetHeapStats(HEAPSTATS * hsStats);

#ifdef __cplusplus
}
#endif


#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\include\macro.h ===
#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}                                                                     \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\include\formdeb.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       formdeb.h
//
//  Contents:   Private project-wide Win 4 definitions
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//              08-Aug-94   DonCl       copied from cinc and renamed formdeb.h
//
//----------------------------------------------------------------------------

#ifndef __FORMDEB_H__
#define __FORMDEB_H__
#define __DEBNOT_H__    // keep debnot.h from being included accidentally

#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)

//----------------------------------------------------------------------------
//
//  New STRICT defines should be added in two places below:
//
//  1)  Add the following within the ifdef ALLSTRICT/endif:
//
//      #ifndef xxSTRICT
//      #  define xxSTRICT
//      #endif
//
//      These entries are in alphabetical order.
//
//  2)  Add the following to the #if clause that defines ANYSTRICT:
//
//      #if ... || defined(xxSTRICT) || ...
//
//      so that ANYSTRICT is defined if any of the STRICT defines are.
//

#if (DBG == 1) || (OFSDBG == 1)

#  ifndef CATSTRICT
#    define CATSTRICT
#  endif

#  ifndef CISTRICT
#    define CISTRICT
#  endif

#  ifndef CMSSTRICT
#    define CMSSTRICT
#  endif

#  ifndef DLOSSTRICT
#    define DLOSSTRICT
#  endif

#  ifndef EVSTRICT
#    define EVSTRICT
#  endif

#  ifndef ICLSTRICT
#    define ICLSTRICT
#  endif

#  ifndef INSSTRICT
#    define INSSTRICT
#  endif

#  ifndef JWSTRICT
#    define JWSTRICT
#  endif

#  ifndef NSSTRICT
#    define NSSTRICT
#  endif

#  ifndef OLSTRICT
#    define OLSTRICT
#  endif

#  ifndef OMSTRICT
#    define OMSTRICT
#  endif

#  ifndef REPLSTRICT
#    define REPLSTRICT
#  endif

#  ifndef SHLSTRICT
#    define SHLSTRICT
#  endif

#  ifndef SLSTRICT
#    define SLSTRICT
#  endif

#  ifndef SMUISTRICT
#    define SMUISTRICT
#  endif

#  ifndef SOMSTRICT
#    define SOMSTRICT
#  endif

#  ifndef VCSTRICT
#    define VCSTRICT
#  endif

#  ifndef VQSTRICT
#    define VQSTRICT
#  endif

#  ifndef WMASTRICT
#    define WMASTRICT
#  endif


#endif // (DBG == 1) || (OFSDBG == 1)

//
//  ANYSTRICT
//

#if defined(CATSTRICT) || \
    defined(CISTRICT)  || \
    defined(CMSSTRICT) || \
    defined(DLOSSTRICT)|| \
    defined(ICLSTRICT) || \
    defined(INSSTRICT) || \
    defined(JWSTRICT)  || \
    defined(NSSTRICT)  || \
    defined(OLSTRICT)  || \
    defined(OMSTRICT)  || \
    defined(REPLSTRICT)|| \
    defined(SHLSTRICT) || \
    defined(SLSTRICT)  || \
    defined(SMUISTRICT)|| \
    defined(SOMSTRICT) || \
    defined(VCSTRICT)  || \
    defined(VQSTRICT)  || \
    defined(WMASTRICT)

#  define ANYSTRICT

#endif

#if (DBG != 1 && OFSDBG != 1) && defined(ANYSTRICT)
#pragma message Asserts are defined in a RETAIL build...
#endif


#if defined(WIN32)
 #include <windef.h>
#endif

#ifndef EXPORTDEF
 #define EXPORTDEF
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

#if (DBG == 1) || (OFSDBG == 1)

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
# define EXTRNC "C"
#else
# define EXTRNC
#endif



// vdprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   vdprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   #define _Win4Assert Win4AssertEx

   EXPORTDEF void          APINOT
   Win4AssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   #define _SetWin4InfoLevel SetWin4InfoLevel

   EXPORTDEF unsigned long APINOT
   SetWin4InfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4InfoMask(
       unsigned long ulNewMask);

   #define _SetWin4AssertLevel SetWin4AssertLevel

   EXPORTDEF unsigned long APINOT
   SetWin4AssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4ExceptionLevel(
       unsigned long ulNewLevel);

#ifdef __cplusplus
}
#endif // __cplusplus

# define EXSTRICT      // (EXception STRICT) - Enabled if ANYSTRICT is enabled

# define Win4Assert(x)  \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Assert(x)      \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Verify(x) Assert(x)


//
// Debug print macros
//

# define DEB_ERROR               0x00000001      // exported error paths
# define DEB_WARN                0x00000002      // exported warnings
# define DEB_TRACE               0x00000004      // exported trace messages

# define DEB_DBGOUT              0x00000010      // Output to debugger
# define DEB_STDOUT              0x00000020      // Output to stdout

# define DEB_IERROR              0x00000100      // internal error paths
# define DEB_IWARN               0x00000200      // internal warnings
# define DEB_ITRACE              0x00000400      // internal trace messages

# define DEB_USER1               0x00010000      // User defined
# define DEB_USER2               0x00020000      // User defined
# define DEB_USER3               0x00040000      // User defined
# define DEB_USER4               0x00080000      // User defined
# define DEB_USER5               0x00100000      // User defined
# define DEB_USER6               0x00200000      // User defined
# define DEB_USER7               0x00400000      // User defined
# define DEB_USER8               0x00800000      // User defined
# define DEB_USER9               0x01000000      // User defined
# define DEB_USER10              0x02000000      // User defined
# define DEB_USER11              0x04000000      // User defined
# define DEB_USER12              0x08000000      // User defined
# define DEB_USER13              0x10000000      // User defined
# define DEB_USER14              0x20000000      // User defined
# define DEB_USER15              0x40000000      // User defined

# define DEB_NOCOMPNAME          0x80000000      // suppress component name

# define DEB_FORCE               0x7fffffff      // force message

# define ASSRT_MESSAGE           0x00000001      // Output a message
# define ASSRT_BREAK             0x00000002      // Int 3 on assertion
# define ASSRT_POPUP             0x00000004      // And popup message

# define EXCEPT_MESSAGE          0x00000001      // Output a message
# define EXCEPT_BREAK            0x00000002      // Int 3 on exception
# define EXCEPT_POPUP            0x00000004      // Popup message
# define EXCEPT_FAULT            0x00000008      // generate int 3 on access violation


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
// Define values that are specific to your xxInfoLevel variable in your
// own file, like ciquery.hxx.
//
//-----------------------------------------------------------------------

# ifndef DEF_INFOLEVEL
#  define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
# endif



//
// Back to the info level stuff.
//

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

# define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char *comp##InfoLevelString = #comp;

# ifdef __cplusplus
}
# endif

# ifdef __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

# else  // ! __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

# endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

# define Win4Assert(x)  NULL
# define Assert(x)      NULL
# define Verify(x)     (x)

# define DECLARE_DEBUG(comp)
# define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0

#endif // __DEBNOT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\include\memory.h ===
#ifndef _MEMORY_H_INCLUDED_
#define _MEMORY_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

LPVOID
AllocADsMem(
    DWORD cb
);

BOOL
FreeADsMem(
   LPVOID pMem
);

LPVOID
ReallocADsMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

LPWSTR
AllocADsStr(
    LPCWSTR pStr
);

BOOL
FreeADsStr(
   LPWSTR pStr
);


BOOL
ReallocADsStr(
   LPWSTR *ppStr,
   LPWSTR pStr
);

#if DBG

extern LIST_ENTRY ADsMemList ;

extern CRITICAL_SECTION ADsMemCritSect ;

VOID InitADsMem(
    VOID
    ) ;

VOID AssertADsMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();


#else

#define InitADsMem()
#define AssertADsMemLeaks()

#define DumpMemoryTracker()



#endif

#ifdef __cplusplus
}
#endif


#endif // _MEMORY_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\include\oledserr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oledserr.h

Abstract:

    Contains the entry point for
        ADsGetLastError
        ADsSetLastError
        ADsFreeAllErrorRecords

Author:


    Ram Viswanathan (ramv) 20-Sep-1996

Environment:

    User Mode - Win32


---*/

#ifndef _OLEDSERR_H_INCLUDED_
#define _OLEDSERR_H_INCLUDED_

#ifdef _cplusplus
extern "C" {
#endif

HRESULT
ADsGetLastError(
    OUT     LPDWORD lpError,
    OUT     LPWSTR  lpErrorBuf,
    IN      DWORD   dwErrorBufLen,
    OUT     LPWSTR  lpNameBuf,
    IN      DWORD   dwNameBufLen
    );

VOID
ADsSetLastError(
    IN  DWORD   dwErr,
    IN  LPCWSTR  pszError,
    IN  LPCWSTR  pszProvider
    );

VOID
ADsFreeAllErrorRecords(
    VOID
    );

//=======================
// Data Structures
//=======================

typedef struct _ERROR_RECORD {
    struct  _ERROR_RECORD   *Prev;
    struct  _ERROR_RECORD   *Next;
    DWORD                   dwThreadId;
    DWORD                   dwErrorCode;
    LPWSTR                  pszErrorText;      // This is an allocated buffer
    LPWSTR                  pszProviderName;   // This is an allocated buffer
} ERROR_RECORD, *LPERROR_RECORD;



//
// Global Data Structures
//

extern
ERROR_RECORD        ADsErrorRecList;    // Initialized to zeros by loader

extern
CRITICAL_SECTION    ADsErrorRecCritSec; // Initialized in libmain.cxx



//=======================
// MACROS
//=======================

#define FIND_END_OF_LIST(record)    while(record->Next != NULL) {   \
                                        record=record->Next;        \
                                    }

#define REMOVE_FROM_LIST(record)    record->Prev->Next = record->Next;      \
                                    if (record->Next != NULL) {             \
                                        record->Next->Prev = record->Prev;  \
                                    }

#define ADD_TO_LIST(record, newRec) FIND_END_OF_LIST(record)    \
                                    record->Next = newRec;      \
                                    newRec->Prev = record;      \
                                    newRec->Next = NULL;


//
// Local Functions
//

LPERROR_RECORD
ADsAllocErrorRecord(
    VOID);

LPERROR_RECORD
ADsFindErrorRecord(
    VOID);

VOID
ADsFreeThreadErrorRecords(
    VOID);

#ifdef _cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\include\oledsdbg.h ===
//+-------------------------------------------------------------------------
//
// File:      oledsdbg.h
//
// Contains:  Debugging stuff for use by the ADs code
//
// History:
//
//
//--------------------------------------------------------------------------

#ifndef _ADSDBG_H_
#define _ADSDBG_H_
//--------------------------------------------------------------------------
//
// Debugging Stuff
//
//--------------------------------------------------------------------------


#include <formdeb.h>

#if DBG == 1
#define ADsDebugOut(x)  ADsInlineDebugOut x
#define ADsAssert(x)    Win4Assert(x)
#define ADsVerify(x)    ADsAssert(x)

//
// HeapValidate() is only available from NTs kernel32.dll
//

#if defined(DAYTONA)
#define VDATEHEAP()       Win4Assert(HeapValidate(GetProcessHeap(), 0, NULL))
#else
#define VDATEHEAP()
#endif

#else
#define ADsDebugOut(x)
#define ADsAssert(x)
#define ADsVerify(x)    x
#define VDATEHEAP()
#endif


DECLARE_DEBUG(ADs);

#ifdef Assert
#undef Assert
#endif

//
// You should use ADsAssert, not Assert
//
#define Assert(x) ADsAssert(x)

#endif //_ADSDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\include\rowprov.h ===
//-----------------------------------------------------------------------------------
// Microsoft OLE DB Provider for ODBC data
// (C) Copyright 1994 - 1996 By Microsoft Corporation.
//
// @doc
//
// @module ROWPROV.H | Definition of the Row Provider interface used by the generic
//					   flavor of the TempTable.
//
//
// @rev 1 | 04-03-96 | WlodekN | Created
// @rev 2 | 07-24-96 | EricJ   | Added PropID
//
//-----------------------------------------------------------------------------------


#ifndef __ROWPROV_INCL__
#define __ROWPROV_INCL__


//---------------------------------- C L A S S E S ----------------------------------


// Abstract class for objects providing row data to the generic TempTable.
class IRowProvider : public IUnknown
{
	public:
		virtual STDMETHODIMP GetColumn
				(
				ULONG		icol,
				DBSTATUS	*pwStatus,
				ULONG		*pdwLength,
				BYTE		*pbData
				) = 0;
		virtual STDMETHODIMP NextRow
				(
				void
				) = 0;
};

EXTERN_C const IID IID_IRowProvider;
EXTERN_C const GUID DBPROPSET_TEMPTABLE;

// TempTable Property IDs.
enum tagetmptablepropid
{
	DBPROP_INSTANTPOPULATION=2,	// TRUE = Prepopulate.  FALSE = Lazy population.
	DBPROP_DBCOLBYREF,			// TRUE = Clear BYREF flags from IColumnsInfo, source owns memory.
	DBPROP_DONTALLOCBYREFCOLS,	// TRUE = TempTable only allocates ptr for BYREF columns.
};


#endif	// __ROWPROV_INCL__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\nocairo\alocdbg.cxx ===
/*
 * This file implements an arena that tracks memory allocations and frees.
 *      Isaache
 */

#include <ADs.hxx>

#if     DBG && !defined(MSVC) // we don't have access to nt hdrs with MSVC

// #include <except.hxx>
#include <caiheap.h>
#include <symtrans.h>

#pragma optimize( "y", off )

DECLARE_INFOLEVEL( heap );
DECLARE_DEBUG( heap );
#define heapDebugOut(x) heapInlineDebugOut x

/*
 * The maximum number of AllocArenaCreate's we expect
 */
static const    MAXARENAS       = 5;

/*
 * When printing leak dumps, the max number we will print out.  Note, we keep
 * track of all of them, we just don't want to take forever to terminate a
 * process
 */
static const    MAXDUMP         = 50;

/*
 * The maximum size we'll let any single debug arena get
 */
static const ULONG ARENASIZE    = 1024*1024;

/*
 * The unit of growth for the arena holding the AllocArena data.
 * Must be a power of 2
 */
static const ALLOCRECINCR       = 128;


static AllocArena *AllocArenas[ MAXARENAS + 1 ];

//+---------------------------------------------------------------------------
//
//  Function:   RecordStack functions(s) below...per processor type
//
//  Synopsis:   Record a stack backtrace into fTrace
//
//  Arguments:  [cFrameSkipped] --  How many stack frames to skip over and
//                      not record
//              [fTrace] -- The recorded frames are put in here
//
//  Returns:    A checksum of the stack frames for fast initial lookups
//
//  Notes:      If we can do stack backtracing for whatever processor we're
//              compiling for, the #define CANDOSTACK
//
//----------------------------------------------------------------------------
#if defined (i386) && !defined(WIN95)


static inline DWORD
RecordStack( int cFrameSkipped, void *fTrace[ DEPTHTRACE ] )
{

#define CANDOSTACK

        ULONG sum;
        USHORT cStack;

        // This routine is found in src/ntos/rtl/i386
        // extern "C" USHORT NTAPI
        // RtlCaptureStackBackTrace(ULONG, ULONG, PVOID *, PULONG);

        cStack = RtlCaptureStackBackTrace(cFrameSkipped + 1,
                DEPTHTRACE, fTrace, &sum );

        return sum;
}

#else // ! i386

static inline DWORD
RecordStack( int cFrameSkipped, void *fTrace[ DEPTHTRACE ] )
{
#if defined(CANDOSTACK)
#undef CANDOSTACK
#endif
    return 0;
}
#endif // ! i386

//
// This allows external monitoring of heap activity by caiheap.exe
//
STDAPI_( AllocArena ** )
AllocArenaAddr( void )
{
        return AllocArenas;
}

//
// Create an arena for recording allocation statistics.  Return the arena
// pointer to the caller
//
STDAPI_( AllocArena * )
AllocArenaCreate( DWORD memctx, char FAR *comment )
{
        struct AllocArena *paa = NULL;

        if( memctx == MEMCTX_TASK ) {
#if     defined( CANDOSTACK )
                if( heapInfoLevel & DEB_WARN ) {

                        paa = (struct AllocArena *)VirtualAlloc(
                                NULL, ARENASIZE, MEM_RESERVE, PAGE_NOACCESS );
                        if( paa == NULL )
                                return NULL;

                        paa = (AllocArena *)VirtualAlloc( paa,
                           sizeof(*paa)+(ALLOCRECINCR-1)*sizeof(HeapAllocRec),
                           MEM_COMMIT, PAGE_READWRITE );

                }
                else
#endif
                {
                        paa = (struct AllocArena *)calloc( 1, sizeof(*paa) );
                }
        }

        if( paa == NULL )
                return NULL;

        memcpy( paa->Signature,HEAPSIG,sizeof(HEAPSIG));
        if( comment )
                strncpy(paa->comment, comment, sizeof(paa->comment) );

        InitializeCriticalSection( &paa->csExclusive );

        for( int i=0; i < MAXARENAS; i++ )
                if( AllocArenas[i] == 0 ) {
                        AllocArenas[i] = paa;
                        break;
                }

#if     defined( CANDOSTACK )
        if( (heapInfoLevel & DEB_WARN) == 0 )
#endif
        {
                paa->flags.KeepStackTrace = 0;
                paa->AllocRec[0].paa = paa;
                return paa;
        }

#if     defined( CANDOSTACK )
        paa->cRecords = ALLOCRECINCR;
        paa->cTotalRecords = ALLOCRECINCR;
        paa->flags.KeepStackTrace = 1;

        return paa;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordAlloc
//
//  Synopsis:   Keep a hash table of the stack backtraces of the allocations
//              we've done.
//
//  Arguments:  [paa] -- Return value from AllocArenaCreate() above
//              [bytes] -- the number of bytes being allocated by the caller.
//                      This value is recorded in the stack backtrace entry.
//
//  Algorithm:  The arena for the AllocArena is created with VirtualAlloc.
//                      pAllocArena->cRecords is the index of the next
//                      free record.  The first ALLOCRECINCR records are heads
//                      of separate lists of the records.
//
//  Returns:    A pointer to the AllocRec structure recording the entry.
//              Can return NULL if we can't record the allocation.
//
//----------------------------------------------------------------------------
STDAPI_( HeapAllocRec FAR * )
AllocArenaRecordAlloc( AllocArena *paa, size_t bytes )
{
        if( paa == NULL )
                return NULL;

        EnterCriticalSection( &paa->csExclusive );

        if( bytes ) {
                paa->cAllocs++;
                paa->cBytesNow += bytes;
                paa->cBytesTotal += bytes;
        } else {
                paa->czAllocs++;
        }

        //
        // Record 'size' in the histogram of requests
        //
        for( int i=31; i>=0; i-- )
                if( bytes & (1<<i) ) {
                        ++(paa->Histogram.total[i]);
                        if( paa->Histogram.simul[i] < ++(paa->Histogram.now[i]))
                                paa->Histogram.simul[i] = paa->Histogram.now[i];
                        break;
                }

        LeaveCriticalSection( &paa->csExclusive );

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace == 0 )
#endif
                return &paa->AllocRec[0];

#if     defined( CANDOSTACK )

        DWORD sum;
        struct HeapAllocRec *phar,*hp;
        void *fTrace[ DEPTHTRACE ];

        //
        // See if we find an existing record of this stack backtrace
        //
        memset( fTrace, '\0', sizeof( fTrace ) );
        sum = RecordStack( 2, fTrace );

        hp = &paa->AllocRec[ sum & (ALLOCRECINCR-1) ];

        EnterCriticalSection( &paa->csExclusive );

        for( phar = hp; phar != NULL; phar = phar->u.next )
                if( phar->sum == sum &&
                    !memcmp(phar->fTrace,fTrace,sizeof(fTrace)))
                {
                        phar->count++;
                        phar->bytes += bytes;
                        phar->total.bytes += bytes;
                        phar->total.count++;
                        phar->paa = paa;
                        LeaveCriticalSection( &paa->csExclusive );
                        return phar;
                }
        //
        // We have no record of this allocation.  Make one!
        //
        if( hp->total.count && paa->cRecords == paa->cTotalRecords ) {
                //
                // The arena is currently full.  Grow it by ALLOCRECINCR
                //
                AllocArena *npHeap;

                npHeap = (AllocArena *)VirtualAlloc(
                        paa,
                        sizeof(AllocArena)+
                        ((paa->cTotalRecords + ALLOCRECINCR) *
                                sizeof(HeapAllocRec) ),
                        MEM_COMMIT, PAGE_READWRITE );

                if( npHeap != paa ) {
                        paa->cMissed++;
                        LeaveCriticalSection( &paa->csExclusive );
                        return NULL;
                }

                paa->cTotalRecords += ALLOCRECINCR;
        }

        if( hp->total.count == 0 ) {
                phar = hp;
        } else {
                phar = &paa->AllocRec[ paa->cRecords++ ];
                phar->u.next = hp->u.next;
                hp->u.next = phar;
        }

        paa->cPaths++;

        memcpy( phar->fTrace, fTrace, sizeof( fTrace ) );
        phar->count = phar->total.count = 1;
        phar->bytes = phar->total.bytes = bytes;
        phar->sum = sum;
        phar->paa = paa;
        LeaveCriticalSection( &paa->csExclusive );
        return phar;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordReAlloc
//
//  Synopsis:   Update the record to reflect the fact that we've ReAlloc'd
//              the memory chunk.
//
//  Arguments:  [vp] -- Return value from AllocArenaRecordAlloc() above
//              [oldbytes] -- size of the memory before ReAllocation
//              [newbytes] -- new size of the memory
//
//----------------------------------------------------------------------------
STDAPI_( void )
AllocArenaRecordReAlloc( HeapAllocRec FAR *vp, size_t oldbytes, size_t newbytes)
{
        if( vp == NULL )
                return;

        struct AllocArena *paa = vp->paa;

        EnterCriticalSection( &paa->csExclusive );

        paa->cReAllocs++;
        paa->cBytesNow -= oldbytes;
        paa->cBytesNow += newbytes;

        if( newbytes > oldbytes )
                paa->cBytesTotal += newbytes - oldbytes;

        //
        // Take 'oldbytes' out of the histogram of requests
        //
        for( int i=31; i>=0; i-- )
                if( oldbytes & (1<<i) ) {
                        --(paa->Histogram.now[i]);
                        break;
                }

        //
        // Record 'newbytes' in the histogram of requests
        //
        for( i=31; i>=0; i-- )
                if( newbytes & (1<<i) ) {
                        ++(paa->Histogram.total[i]);
                        if( paa->Histogram.simul[i] < ++(paa->Histogram.now[i]))
                                paa->Histogram.simul[i] = paa->Histogram.now[i];
                        break;
                }

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace ) {
                vp->bytes -= oldbytes;
                vp->bytes += newbytes;
                vp->total.count++;
                if( newbytes > oldbytes )
                        vp->total.bytes += newbytes;
        }
#endif

        LeaveCriticalSection( &paa->csExclusive );
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordFree
//
//  Synopsis:   Caller has freed memory -- keep accounting up to date
//
//  Arguments:  [vp] -- Value returned by AllocArenaRecordAlloc() above
//              [bytes] -- The number of bytes being freed
//
//  Algorithm:  AllocRec structures, once allocated, are never actually
//                      freed back to the Hash memory arena.  This helps us
//                      understand historical use of the heap.
//
//----------------------------------------------------------------------------
STDAPI_( void )
AllocArenaRecordFree( HeapAllocRec FAR *vp, size_t bytes )
{
        if( vp == NULL )
                return;

        struct AllocArena *paa = vp->paa;

        EnterCriticalSection( &paa->csExclusive );

        //
        // Record this free in the histogram
        //
        for( int i=31; i>=0; i-- )
                if( bytes & (1<<i) ) {
                        --(paa->Histogram.now[i]);
                        break;
                }

        paa->cFrees++;
        paa->cBytesNow -= bytes;

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace ) {
                vp->count--;
                vp->bytes -= bytes;
        }
#endif

        LeaveCriticalSection( &paa->csExclusive );
}

STDAPI_( void )
AllocArenaDumpRecord( HeapAllocRec FAR *bp )
{
#if     defined( CANDOSTACK )
        char achBuffer[ MAX_TRANSLATED_LEN ], *p;

        heapDebugOut((DEB_WARN, "*** %d allocs, %u bytes:\n",
                         bp->count, bp->bytes ));

        for( int j=0; j<DEPTHTRACE && bp->fTrace[j]; j++ )
        {
                TranslateAddress(bp->fTrace[j], achBuffer );
                if( p = strchr( achBuffer, '\n' ) )
                        *p = '\0';
                heapDebugOut((DEB_WARN, "       %s\n", achBuffer));
        }
#endif
}

extern "C" ULONG DbgPrint( PCH Format, ... );

STDAPI_( void )
AllocArenaDump( AllocArena *paa )
{
        if( paa == NULL ) {
                for( int i = 0; i < MAXARENAS && AllocArenas[i]; i++ )
                        AllocArenaDump( AllocArenas[i] );
                return;
        }

        char *cmdline = GetCommandLineA();

        if( cmdline == NULL )
                cmdline = "???";

        HeapAllocRec *bp = paa->AllocRec;
        HeapAllocRec *ep = bp + paa->cRecords;

        if( paa->cBytesNow )
                heapDebugOut((DEB_WARN,
                              "***** %u bytes leaked mem for %s in '%s'\n",
                              paa->cBytesNow,
                              paa->comment,
                              cmdline ));

#if     defined( CANDOSTACK )
        if( paa->cBytesNow && paa->flags.KeepStackTrace )
        {
                int cleaks = 0;

                for( ; bp < ep; bp++) {
                        if( bp->count )
                                ++cleaks;
                }

                if( cleaks ) {
                        heapDebugOut((DEB_WARN, "***** %s %u MEM LEAKS\n",
                                paa->comment, cleaks ));

                        if( heapInfoLevel & DEB_TRACE ) {
                                HeapAllocRec *bp;
                                UINT maxdump = MAXDUMP;
                                for( bp = paa->AllocRec; maxdump && bp<ep; bp++)
                                        if( bp->count ) {
                                                heapDebugOut((DEB_TRACE, "\n"));
                                                AllocArenaDumpRecord( bp );
                                                maxdump--;
                                        }
                        } else if( cleaks )
                                heapDebugOut((DEB_WARN, "** Set formidbl!heapInfoLevel to x707 for leak backtrace\n"));

                }
        }
#endif

        if( (heapInfoLevel & DEB_TRACE) && paa->cBytesTotal )
        {
                heapDebugOut((DEB_TRACE,"\n"));
                heapDebugOut((DEB_TRACE,
                        "'%s' Memory Stats: %u allocations, %u frees\n",
                        cmdline, paa->cAllocs, paa->cFrees ));

                if( paa->czAllocs )
                        heapDebugOut((DEB_TRACE,
                                "\t%u zero allocs\n", paa->czAllocs ));

                heapDebugOut((DEB_TRACE,
                                "\t%u bytes allocated\n", paa->cBytesTotal ));

                heapDebugOut((DEB_TRACE,
                                "*** Histogram of Allocated Mem Sizes ***\n"));

                heapDebugOut((DEB_TRACE, "  Min    Max\t  Tot\t Simul\n" ));
                for( int i=0; i < 32; i++ )
                        if( paa->Histogram.total[i] )
                        {
                                heapDebugOut((DEB_TRACE,
                                        "%6u -> %6u\t%6u\t%6u\n",
                                        1<<i, (1<<(i+1))-1,
                                        paa->Histogram.total[i],
                                        paa->Histogram.simul[i]
                                ));
                        }
        }
}

#endif  // DBG && !defined(MSVC)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\include\svcprov.h ===
#include "rpc.h"
#include "rpcndr.h"

#ifndef __svcprov_h__
#define __svcprov_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IProvideDBService_FWD_DEFINED__
#define __IProvideDBService_FWD_DEFINED__
typedef interface IProvideDBService IProvideDBService;
#endif 	/* __IProvideDBService_FWD_DEFINED__ */

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IProvideDBService_INTERFACE_DEFINED__
#define __IProvideDBService_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideDBService
 * at Mon Apr 22 16:40:51 1996
 * using MIDL 2.00.72
 ****************************************/
/* [unique][uuid][object][local] */ 

// @msg IID_IProvideDBService | {EFF65380-9C98-11CF-B963-00AA0044773D}
DEFINE_GUID(IID_IProvideDBService, 0xEFF65380L,0x9C98,0x11CF,0xB9,0x63,0x00,0xAA,0x00,0x44,0x77,0x3D);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideDBService : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ProvideService( 
            /* [in] */ ULONG cProvidedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
            /* [in] */ ULONG cRequestedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ IUnknown __RPC_FAR *pDataProvider,
            /* [in] */ REFIID riidRequested,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider) = 0;
        
    };
    
#else 	/* C style interface */
    
    typedef struct IProvideDBServiceVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IProvideDBService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IProvideDBService __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IProvideDBService __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *ProvideService )( 
            IProvideDBService __RPC_FAR * This,
            /* [in] */ ULONG cProvidedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
            /* [in] */ ULONG cRequestedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ IUnknown __RPC_FAR *pDataProvider,
            /* [in] */ REFIID riidRequested,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider);
        
    } IProvideDBServiceVtbl;
    
    interface IProvideDBService
    {
        CONST_VTBL struct IProvideDBServiceVtbl __RPC_FAR *lpVtbl;
    };
    
    

#ifdef COBJMACROS


#define IProvideDBService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideDBService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideDBService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideDBService_ProvideService(This,cProvidedProperties,rgProvidedProperties,cRequestedProperties,rgRequestedProperties,pUnkOuter,pDataProvider,riidRequested,ppServiceProvider)	\
    (This)->lpVtbl -> ProvideService(This,cProvidedProperties,rgProvidedProperties,cRequestedProperties,rgRequestedProperties,pUnkOuter,pDataProvider,riidRequested,ppServiceProvider)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IProvideDBService_ProvideService_Proxy( 
    IProvideDBService __RPC_FAR * This,
    /* [in] */ ULONG cProvidedPropertySets,
    /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
    /* [in] */ ULONG cRequestedPropertySets,
    /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ IUnknown __RPC_FAR *pDataProvider,
    /* [in] */ REFIID riidRequested,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider);



void __RPC_STUB IProvideDBService_ProvideService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideDBService_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\include\umi.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for umi.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __umi_h__
#define __umi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUmiPropList_FWD_DEFINED__
#define __IUmiPropList_FWD_DEFINED__
typedef interface IUmiPropList IUmiPropList;
#endif 	/* __IUmiPropList_FWD_DEFINED__ */


#ifndef __IUmiBaseObject_FWD_DEFINED__
#define __IUmiBaseObject_FWD_DEFINED__
typedef interface IUmiBaseObject IUmiBaseObject;
#endif 	/* __IUmiBaseObject_FWD_DEFINED__ */


#ifndef __IUmiObject_FWD_DEFINED__
#define __IUmiObject_FWD_DEFINED__
typedef interface IUmiObject IUmiObject;
#endif 	/* __IUmiObject_FWD_DEFINED__ */


#ifndef __IUmiConnection_FWD_DEFINED__
#define __IUmiConnection_FWD_DEFINED__
typedef interface IUmiConnection IUmiConnection;
#endif 	/* __IUmiConnection_FWD_DEFINED__ */


#ifndef __IUmiContainer_FWD_DEFINED__
#define __IUmiContainer_FWD_DEFINED__
typedef interface IUmiContainer IUmiContainer;
#endif 	/* __IUmiContainer_FWD_DEFINED__ */


#ifndef __IUmiCursor_FWD_DEFINED__
#define __IUmiCursor_FWD_DEFINED__
typedef interface IUmiCursor IUmiCursor;
#endif 	/* __IUmiCursor_FWD_DEFINED__ */


#ifndef __IUmiObjectSink_FWD_DEFINED__
#define __IUmiObjectSink_FWD_DEFINED__
typedef interface IUmiObjectSink IUmiObjectSink;
#endif 	/* __IUmiObjectSink_FWD_DEFINED__ */


#ifndef __IUmiURLKeyList_FWD_DEFINED__
#define __IUmiURLKeyList_FWD_DEFINED__
typedef interface IUmiURLKeyList IUmiURLKeyList;
#endif 	/* __IUmiURLKeyList_FWD_DEFINED__ */


#ifndef __IUmiURL_FWD_DEFINED__
#define __IUmiURL_FWD_DEFINED__
typedef interface IUmiURL IUmiURL;
#endif 	/* __IUmiURL_FWD_DEFINED__ */


#ifndef __IUmiQuery_FWD_DEFINED__
#define __IUmiQuery_FWD_DEFINED__
typedef interface IUmiQuery IUmiQuery;
#endif 	/* __IUmiQuery_FWD_DEFINED__ */


#ifndef __IUmiCustomInterfaceFactory_FWD_DEFINED__
#define __IUmiCustomInterfaceFactory_FWD_DEFINED__
typedef interface IUmiCustomInterfaceFactory IUmiCustomInterfaceFactory;
#endif 	/* __IUmiCustomInterfaceFactory_FWD_DEFINED__ */


#ifndef __UmiDefURL_FWD_DEFINED__
#define __UmiDefURL_FWD_DEFINED__

#ifdef __cplusplus
typedef class UmiDefURL UmiDefURL;
#else
typedef struct UmiDefURL UmiDefURL;
#endif /* __cplusplus */

#endif 	/* __UmiDefURL_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __UMI_V6_LIBRARY_DEFINED__
#define __UMI_V6_LIBRARY_DEFINED__

/* library UMI_V6 */
/* [uuid] */ 












typedef 
enum tag_UMI_TYPE_ENUMERATION
    {	UMI_TYPE_NULL	= 0,
	UMI_TYPE_I1	= 1,
	UMI_TYPE_I2	= 2,
	UMI_TYPE_I4	= 3,
	UMI_TYPE_I8	= 4,
	UMI_TYPE_UI1	= 5,
	UMI_TYPE_UI2	= 6,
	UMI_TYPE_UI4	= 7,
	UMI_TYPE_UI8	= 8,
	UMI_TYPE_R4	= 9,
	UMI_TYPE_R8	= 10,
	UMI_TYPE_FILETIME	= 12,
	UMI_TYPE_SYSTEMTIME	= 13,
	UMI_TYPE_BOOL	= 14,
	UMI_TYPE_IDISPATCH	= 15,
	UMI_TYPE_IUNKNOWN	= 16,
	UMI_TYPE_VARIANT	= 17,
	UMI_TYPE_LPWSTR	= 20,
	UMI_TYPE_OCTETSTRING	= 21,
	UMI_TYPE_UMIARRAY	= 22,
	UMI_TYPE_DISCOVERY	= 23,
	UMI_TYPE_UNDEFINED	= 24,
	UMI_TYPE_DEFAULT	= 25,
	UMI_TYPE_ARRAY_FLAG	= 0x2000
    } 	UMI_TYPE_ENUMERATION;

typedef ULONG UMI_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0001
    {	UMI_GENUS_CLASS	= 1,
	UMI_GENUS_INSTANCE	= 2
    } 	UMI_GENUS_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0002
    {	UMI_DONT_COMMIT_SECURITY_DESCRIPTOR	= 0x10
    } 	UMI_COMMIT_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0003
    {	UMI_FLAG_GETPROPS_ALL	= 1,
	UMI_FLAG_GETPROPS_SCHEMA	= 0x2,
	UMI_MASK_GETPROPS_PROP	= 0xff,
	UMI_FLAG_GETPROPS_NAMES	= 0x100,
	UMI_MASK_GETPROPS_EXT	= 0x100
    } 	UMI_GETPROPS_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0004
    {	UMI_FLAG_OWNER_SECURITY_INFORMATION	= 0x1,
	UMI_FLAG_GROUP_SECURITY_INFORMATION	= 0x2,
	UMI_FLAG_DACL_SECURITY_INFORMATION	= 0x4,
	UMI_FLAG_SACL_SECURITY_INFORMATION	= 0x8,
	UMI_SECURITY_MASK	= 0xf,
	UMI_FLAG_PROVIDER_CACHE	= 0x10,
	UMI_FLAG_PROPERTY_ORIGIN	= 0x20
    } 	UMI_GET_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0005
    {	UMI_FLAG_REFRESH_ALL	= 0,
	UMI_FLAG_REFRESH_PARTIAL	= 1
    } 	UMI_REFRESH_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0006
    {	UMI_OPERATION_NONE	= 0,
	UMI_OPERATION_APPEND	= 1,
	UMI_OPERATION_UPDATE	= 2,
	UMI_OPERATION_EMPTY	= 3,
	UMI_OPERATION_INSERT_AT	= 4,
	UMI_OPERATION_REMOVE_AT	= 5,
	UMI_OPERATION_DELETE_AT	= 6,
	UMI_OPERATION_DELETE_FIRST_MATCH	= 7,
	UMI_OPERATION_DELETE_ALL_MATCHES	= 8,
	UMI_OPERATION_RESTORE_DEFAULT	= 9
    } 	UMI_PROP_INSTRUCTION;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0007
    {	UMI_OPERATION_INSTANCE	= 0x1000,
	UMI_OPERATION_CLASS	= 0x2000
    } 	UMI_OPERATION_PATH;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0008
    {	UMIPATH_CREATE_AS_NATIVE	= 0x8000,
	UMIPATH_CREATE_AS_EITHER	= 0x4000,
	UMIPATH_CREATE_ACCEPT_RELATIVE	= 0x4
    } 	tag_UMI_PATH_CREATE_FLAG;

typedef 
enum tag_WMI_PATH_STATUS_FLAG
    {	UMIPATH_INFO_NATIVE_STRING	= 0x1,
	UMIPATH_INFO_RELATIVE_PATH	= 0x2,
	UMIPATH_INFO_INSTANCE_PATH	= 0x4,
	UMIPATH_INFO_CLASS_PATH	= 0x8,
	UMIPATH_INFO_SINGLETON_PATH	= 0x10
    } 	tag_UMI_PATH_STATUS_FLAG;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0009
    {	UMI_S_NO_ERROR	= 0,
	UMI_E_CONNECTION_FAILURE	= 0x80041001,
	UMI_E_TIMED_OUT	= 0x80041002,
	UMI_E_TYPE_MISMATCH	= 0x80041003,
	UMI_E_NOT_FOUND	= 0x80041004,
	UMI_E_INVALID_FLAGS	= 0x80041005,
	UMI_E_UNSUPPORTED_FLAGS	= 0x80041006,
	UMI_E_SYNCHRONIZATION_REQUIRED	= 0x80041007,
	UMI_E_UNSUPPORTED_OPERATION	= 0x80041008,
	UMI_E_TRANSACTION_FAILURE	= 0x80041009,
	UMI_E_UNBOUND_OBJECT	= 0x8004100a
    } 	UMI_STATUS;

typedef struct tag_UMI_OCTET_STRING
    {
    ULONG uLength;
    byte __RPC_FAR *lpValue;
    } 	UMI_OCTET_STRING;

typedef struct tag_UMI_OCTET_STRING __RPC_FAR *PUMI_OCTET_STRING;

typedef struct tag_UMI_COM_OBJECT
    {
    IID __RPC_FAR *priid;
    LPVOID pInterface;
    } 	UMI_COM_OBJECT;

typedef struct tag_UMI_COM_OBJECT __RPC_FAR *PUMI_COM_OBJECT;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ union __MIDL___MIDL_itf_umi_0000_0010
    {
    CHAR cValue[ 1 ];
    UCHAR ucValue[ 1 ];
    WCHAR wcValue[ 1 ];
    WORD wValue[ 1 ];
    DWORD dwValue[ 1 ];
    LONG lValue[ 1 ];
    ULONG uValue[ 1 ];
    BYTE byteValue[ 1 ];
    BOOL bValue[ 1 ];
    LPWSTR pszStrValue[ 1 ];
    FILETIME fileTimeValue[ 1 ];
    SYSTEMTIME sysTimeValue[ 1 ];
    double dblValue[ 1 ];
    unsigned __int64 uValue64[ 1 ];
    __int64 nValue64[ 1 ];
    UMI_OCTET_STRING octetStr[ 1 ];
    UMI_COM_OBJECT comObject[ 1 ];
    } 	UMI_VALUE;

typedef union __MIDL___MIDL_itf_umi_0000_0010 __RPC_FAR *PUMI_VALUE;

typedef /* [public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_umi_0000_0011
    {
    UMI_TYPE uType;
    ULONG uCount;
    ULONG uOperationType;
    LPWSTR pszPropertyName;
    UMI_VALUE __RPC_FAR *pUmiValue;
    } 	UMI_PROPERTY;

typedef struct __MIDL___MIDL_itf_umi_0000_0011 __RPC_FAR *PUMI_PROPERTY;

typedef /* [public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_umi_0000_0012
    {
    ULONG uCount;
    UMI_PROPERTY __RPC_FAR *pPropArray;
    } 	UMI_PROPERTY_VALUES;

typedef struct __MIDL___MIDL_itf_umi_0000_0012 __RPC_FAR *PUMI_PROPERTY_VALUES;


EXTERN_C const IID LIBID_UMI_V6;

#ifndef __IUmiPropList_INTERFACE_DEFINED__
#define __IUmiPropList_INTERFACE_DEFINED__

/* interface IUmiPropList */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiPropList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7b-d9db-11d3-a11f-00105a1f515a")
    IUmiPropList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAs( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeMemory( 
            ULONG uReserved,
            LPVOID pMem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProps( 
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutProps( 
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutFrom( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiPropListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiPropList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiPropList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiPropList __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        END_INTERFACE
    } IUmiPropListVtbl;

    interface IUmiPropList
    {
        CONST_VTBL struct IUmiPropListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiPropList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiPropList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiPropList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiPropList_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiPropList_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiPropList_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiPropList_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiPropList_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiPropList_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiPropList_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiPropList_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiPropList_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiPropList_Put_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);


void __RPC_STUB IUmiPropList_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_Get_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);


void __RPC_STUB IUmiPropList_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_GetAt_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uBufferLength,
    /* [out] */ LPVOID pExistingMem);


void __RPC_STUB IUmiPropList_GetAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_GetAs_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uCoercionType,
    /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);


void __RPC_STUB IUmiPropList_GetAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_FreeMemory_Proxy( 
    IUmiPropList __RPC_FAR * This,
    ULONG uReserved,
    LPVOID pMem);


void __RPC_STUB IUmiPropList_FreeMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_Delete_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiPropList_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_GetProps_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR __RPC_FAR *pszNames,
    /* [in] */ ULONG uNameCount,
    /* [in] */ ULONG uFlags,
    /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);


void __RPC_STUB IUmiPropList_GetProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_PutProps_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR __RPC_FAR *pszNames,
    /* [in] */ ULONG uNameCount,
    /* [in] */ ULONG uFlags,
    /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);


void __RPC_STUB IUmiPropList_PutProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_PutFrom_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uBufferLength,
    /* [in] */ LPVOID pExistingMem);


void __RPC_STUB IUmiPropList_PutFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiPropList_INTERFACE_DEFINED__ */


#ifndef __IUmiBaseObject_INTERFACE_DEFINED__
#define __IUmiBaseObject_INTERFACE_DEFINED__

/* interface IUmiBaseObject */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiBaseObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7c-d9db-11d3-a11f-00105a1f515a")
    IUmiBaseObject : public IUmiPropList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLastStatus( 
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfacePropList( 
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiBaseObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiBaseObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiBaseObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiBaseObject __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        END_INTERFACE
    } IUmiBaseObjectVtbl;

    interface IUmiBaseObject
    {
        CONST_VTBL struct IUmiBaseObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiBaseObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiBaseObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiBaseObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiBaseObject_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiBaseObject_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiBaseObject_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiBaseObject_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiBaseObject_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiBaseObject_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiBaseObject_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiBaseObject_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiBaseObject_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiBaseObject_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiBaseObject_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiBaseObject_GetLastStatus_Proxy( 
    IUmiBaseObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);


void __RPC_STUB IUmiBaseObject_GetLastStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiBaseObject_GetInterfacePropList_Proxy( 
    IUmiBaseObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);


void __RPC_STUB IUmiBaseObject_GetInterfacePropList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiBaseObject_INTERFACE_DEFINED__ */


#ifndef __IUmiObject_INTERFACE_DEFINED__
#define __IUmiObject_INTERFACE_DEFINED__

/* interface IUmiObject */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee23-64a4-11d3-a0da-00105a1f515a")
    IUmiObject : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyTo( 
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uNameCount,
            /* [in] */ LPWSTR __RPC_FAR *pszNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ ULONG uFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiObject __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uNameCount,
            /* [in] */ LPWSTR __RPC_FAR *pszNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        END_INTERFACE
    } IUmiObjectVtbl;

    interface IUmiObject
    {
        CONST_VTBL struct IUmiObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiObject_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiObject_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiObject_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiObject_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiObject_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiObject_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiObject_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiObject_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiObject_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiObject_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiObject_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiObject_Clone(This,uFlags,riid,pCopy)	\
    (This)->lpVtbl -> Clone(This,uFlags,riid,pCopy)

#define IUmiObject_CopyTo(This,uFlags,pURL,riid,pCopy)	\
    (This)->lpVtbl -> CopyTo(This,uFlags,pURL,riid,pCopy)

#define IUmiObject_Refresh(This,uFlags,uNameCount,pszNames)	\
    (This)->lpVtbl -> Refresh(This,uFlags,uNameCount,pszNames)

#define IUmiObject_Commit(This,uFlags)	\
    (This)->lpVtbl -> Commit(This,uFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiObject_Clone_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);


void __RPC_STUB IUmiObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObject_CopyTo_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);


void __RPC_STUB IUmiObject_CopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObject_Refresh_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uNameCount,
    /* [in] */ LPWSTR __RPC_FAR *pszNames);


void __RPC_STUB IUmiObject_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObject_Commit_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiObject_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiObject_INTERFACE_DEFINED__ */


#ifndef __IUmiConnection_INTERFACE_DEFINED__
#define __IUmiConnection_INTERFACE_DEFINED__

/* interface IUmiConnection */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee20-64a4-11d3-a0da-00105a1f515a")
    IUmiConnection : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiConnection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiConnection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiConnection __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);
        
        END_INTERFACE
    } IUmiConnectionVtbl;

    interface IUmiConnection
    {
        CONST_VTBL struct IUmiConnectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiConnection_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiConnection_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiConnection_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiConnection_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiConnection_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiConnection_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiConnection_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiConnection_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiConnection_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiConnection_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiConnection_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiConnection_Open(This,pURL,uFlags,TargetIID,ppvRes)	\
    (This)->lpVtbl -> Open(This,pURL,uFlags,TargetIID,ppvRes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiConnection_Open_Proxy( 
    IUmiConnection __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);


void __RPC_STUB IUmiConnection_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiConnection_INTERFACE_DEFINED__ */


#ifndef __IUmiContainer_INTERFACE_DEFINED__
#define __IUmiContainer_INTERFACE_DEFINED__

/* interface IUmiContainer */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee21-64a4-11d3-a0da-00105a1f515a")
    IUmiContainer : public IUmiObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutObject( 
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out][in] */ void __RPC_FAR *pObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteObject( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [optional][in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiObject __RPC_FAR *__RPC_FAR *pNewObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pOldURL,
            /* [in] */ IUmiURL __RPC_FAR *pNewURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnum( 
            /* [in] */ IUmiURL __RPC_FAR *pszEnumContext,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ IUmiQuery __RPC_FAR *pQuery,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiContainer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiContainer __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uNameCount,
            /* [in] */ LPWSTR __RPC_FAR *pszNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutObject )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out][in] */ void __RPC_FAR *pObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteObject )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [optional][in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiObject __RPC_FAR *__RPC_FAR *pNewObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pOldURL,
            /* [in] */ IUmiURL __RPC_FAR *pNewURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEnum )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pszEnumContext,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecQuery )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiQuery __RPC_FAR *pQuery,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppResult);
        
        END_INTERFACE
    } IUmiContainerVtbl;

    interface IUmiContainer
    {
        CONST_VTBL struct IUmiContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiContainer_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiContainer_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiContainer_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiContainer_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiContainer_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiContainer_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiContainer_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiContainer_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiContainer_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiContainer_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiContainer_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiContainer_Clone(This,uFlags,riid,pCopy)	\
    (This)->lpVtbl -> Clone(This,uFlags,riid,pCopy)

#define IUmiContainer_CopyTo(This,uFlags,pURL,riid,pCopy)	\
    (This)->lpVtbl -> CopyTo(This,uFlags,pURL,riid,pCopy)

#define IUmiContainer_Refresh(This,uFlags,uNameCount,pszNames)	\
    (This)->lpVtbl -> Refresh(This,uFlags,uNameCount,pszNames)

#define IUmiContainer_Commit(This,uFlags)	\
    (This)->lpVtbl -> Commit(This,uFlags)


#define IUmiContainer_Open(This,pURL,uFlags,TargetIID,ppvRes)	\
    (This)->lpVtbl -> Open(This,pURL,uFlags,TargetIID,ppvRes)

#define IUmiContainer_PutObject(This,uFlags,TargetIID,pObj)	\
    (This)->lpVtbl -> PutObject(This,uFlags,TargetIID,pObj)

#define IUmiContainer_DeleteObject(This,pURL,uFlags)	\
    (This)->lpVtbl -> DeleteObject(This,pURL,uFlags)

#define IUmiContainer_Create(This,pURL,uFlags,pNewObj)	\
    (This)->lpVtbl -> Create(This,pURL,uFlags,pNewObj)

#define IUmiContainer_Move(This,uFlags,pOldURL,pNewURL)	\
    (This)->lpVtbl -> Move(This,uFlags,pOldURL,pNewURL)

#define IUmiContainer_CreateEnum(This,pszEnumContext,uFlags,TargetIID,ppvEnum)	\
    (This)->lpVtbl -> CreateEnum(This,pszEnumContext,uFlags,TargetIID,ppvEnum)

#define IUmiContainer_ExecQuery(This,pQuery,uFlags,TargetIID,ppResult)	\
    (This)->lpVtbl -> ExecQuery(This,pQuery,uFlags,TargetIID,ppResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiContainer_Open_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);


void __RPC_STUB IUmiContainer_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_PutObject_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out][in] */ void __RPC_FAR *pObj);


void __RPC_STUB IUmiContainer_PutObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_DeleteObject_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [optional][in] */ ULONG uFlags);


void __RPC_STUB IUmiContainer_DeleteObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_Create_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ ULONG uFlags,
    /* [out] */ IUmiObject __RPC_FAR *__RPC_FAR *pNewObj);


void __RPC_STUB IUmiContainer_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_Move_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ IUmiURL __RPC_FAR *pOldURL,
    /* [in] */ IUmiURL __RPC_FAR *pNewURL);


void __RPC_STUB IUmiContainer_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_CreateEnum_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pszEnumContext,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvEnum);


void __RPC_STUB IUmiContainer_CreateEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_ExecQuery_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiQuery __RPC_FAR *pQuery,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppResult);


void __RPC_STUB IUmiContainer_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiContainer_INTERFACE_DEFINED__ */


#ifndef __IUmiCursor_INTERFACE_DEFINED__
#define __IUmiCursor_INTERFACE_DEFINED__

/* interface IUmiCursor */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiCursor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee26-64a4-11d3-a0da-00105a1f515a")
    IUmiCursor : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIID( 
            /* [in] */ REFIID riid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG uNumRequested,
            /* [out] */ ULONG __RPC_FAR *puNumReturned,
            /* [length_is][size_is][out] */ LPVOID __RPC_FAR *pObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [out] */ ULONG __RPC_FAR *puNumObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Previous( 
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiCursorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiCursor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiCursor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiCursor __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIID )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ REFIID riid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IUmiCursor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uNumRequested,
            /* [out] */ ULONG __RPC_FAR *puNumReturned,
            /* [length_is][size_is][out] */ LPVOID __RPC_FAR *pObjects);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )( 
            IUmiCursor __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puNumObjects);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Previous )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pObj);
        
        END_INTERFACE
    } IUmiCursorVtbl;

    interface IUmiCursor
    {
        CONST_VTBL struct IUmiCursorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiCursor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiCursor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiCursor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiCursor_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiCursor_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiCursor_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiCursor_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiCursor_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiCursor_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiCursor_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiCursor_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiCursor_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiCursor_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiCursor_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiCursor_SetIID(This,riid)	\
    (This)->lpVtbl -> SetIID(This,riid)

#define IUmiCursor_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IUmiCursor_Next(This,uNumRequested,puNumReturned,pObjects)	\
    (This)->lpVtbl -> Next(This,uNumRequested,puNumReturned,pObjects)

#define IUmiCursor_Count(This,puNumObjects)	\
    (This)->lpVtbl -> Count(This,puNumObjects)

#define IUmiCursor_Previous(This,uFlags,pObj)	\
    (This)->lpVtbl -> Previous(This,uFlags,pObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiCursor_SetIID_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [in] */ REFIID riid);


void __RPC_STUB IUmiCursor_SetIID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Reset_Proxy( 
    IUmiCursor __RPC_FAR * This);


void __RPC_STUB IUmiCursor_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Next_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [in] */ ULONG uNumRequested,
    /* [out] */ ULONG __RPC_FAR *puNumReturned,
    /* [length_is][size_is][out] */ LPVOID __RPC_FAR *pObjects);


void __RPC_STUB IUmiCursor_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Count_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puNumObjects);


void __RPC_STUB IUmiCursor_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Previous_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [out] */ LPVOID __RPC_FAR *pObj);


void __RPC_STUB IUmiCursor_Previous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiCursor_INTERFACE_DEFINED__ */


#ifndef __IUmiObjectSink_INTERFACE_DEFINED__
#define __IUmiObjectSink_INTERFACE_DEFINED__

/* interface IUmiObjectSink */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee24-64a4-11d3-a0da-00105a1f515a")
    IUmiObjectSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ LONG lNumObjects,
            /* [size_is][in] */ IUmiObject __RPC_FAR *__RPC_FAR *ppObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResult( 
            /* [in] */ HRESULT hResStatus,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUnknown __RPC_FAR *pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiObjectSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiObjectSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiObjectSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiObjectSink __RPC_FAR * This,
            /* [in] */ LONG lNumObjects,
            /* [size_is][in] */ IUmiObject __RPC_FAR *__RPC_FAR *ppObjects);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetResult )( 
            IUmiObjectSink __RPC_FAR * This,
            /* [in] */ HRESULT hResStatus,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUnknown __RPC_FAR *pObject);
        
        END_INTERFACE
    } IUmiObjectSinkVtbl;

    interface IUmiObjectSink
    {
        CONST_VTBL struct IUmiObjectSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiObjectSink_Put(This,lNumObjects,ppObjects)	\
    (This)->lpVtbl -> Put(This,lNumObjects,ppObjects)

#define IUmiObjectSink_SetResult(This,hResStatus,uFlags,pObject)	\
    (This)->lpVtbl -> SetResult(This,hResStatus,uFlags,pObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiObjectSink_Put_Proxy( 
    IUmiObjectSink __RPC_FAR * This,
    /* [in] */ LONG lNumObjects,
    /* [size_is][in] */ IUmiObject __RPC_FAR *__RPC_FAR *ppObjects);


void __RPC_STUB IUmiObjectSink_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObjectSink_SetResult_Proxy( 
    IUmiObjectSink __RPC_FAR * This,
    /* [in] */ HRESULT hResStatus,
    /* [in] */ ULONG uFlags,
    /* [in] */ IUnknown __RPC_FAR *pObject);


void __RPC_STUB IUmiObjectSink_SetResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiObjectSink_INTERFACE_DEFINED__ */


#ifndef __IUmiURLKeyList_INTERFACE_DEFINED__
#define __IUmiURLKeyList_INTERFACE_DEFINED__

/* interface IUmiURLKeyList */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IUmiURLKeyList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cf779c98-4739-4fd4-a415-da937a599f2f")
    IUmiURLKeyList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *puKeyCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKey( 
            /* [string][in] */ LPCWSTR pszName,
            /* [string][in] */ LPCWSTR pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKey( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puKeyNameBufSize,
            /* [in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puValueBufSize,
            /* [in] */ LPWSTR pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveKey( 
            /* [string][in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllKeys( 
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeysInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiURLKeyListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiURLKeyList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiURLKeyList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puKeyCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKey )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszName,
            /* [string][in] */ LPCWSTR pszValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKey )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puKeyNameBufSize,
            /* [in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puValueBufSize,
            /* [in] */ LPWSTR pszValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveKey )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllKeys )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeysInfo )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
        
        END_INTERFACE
    } IUmiURLKeyListVtbl;

    interface IUmiURLKeyList
    {
        CONST_VTBL struct IUmiURLKeyListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiURLKeyList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiURLKeyList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiURLKeyList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiURLKeyList_GetCount(This,puKeyCount)	\
    (This)->lpVtbl -> GetCount(This,puKeyCount)

#define IUmiURLKeyList_SetKey(This,pszName,pszValue)	\
    (This)->lpVtbl -> SetKey(This,pszName,pszValue)

#define IUmiURLKeyList_GetKey(This,uKeyIx,uFlags,puKeyNameBufSize,pszKeyName,puValueBufSize,pszValue)	\
    (This)->lpVtbl -> GetKey(This,uKeyIx,uFlags,puKeyNameBufSize,pszKeyName,puValueBufSize,pszValue)

#define IUmiURLKeyList_RemoveKey(This,pszName,uFlags)	\
    (This)->lpVtbl -> RemoveKey(This,pszName,uFlags)

#define IUmiURLKeyList_RemoveAllKeys(This,uFlags)	\
    (This)->lpVtbl -> RemoveAllKeys(This,uFlags)

#define IUmiURLKeyList_GetKeysInfo(This,uRequestedInfo,puResponse)	\
    (This)->lpVtbl -> GetKeysInfo(This,uRequestedInfo,puResponse)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiURLKeyList_GetCount_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puKeyCount);


void __RPC_STUB IUmiURLKeyList_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_SetKey_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszName,
    /* [string][in] */ LPCWSTR pszValue);


void __RPC_STUB IUmiURLKeyList_SetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_GetKey_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [in] */ ULONG uKeyIx,
    /* [in] */ ULONG uFlags,
    /* [out][in] */ ULONG __RPC_FAR *puKeyNameBufSize,
    /* [in] */ LPWSTR pszKeyName,
    /* [out][in] */ ULONG __RPC_FAR *puValueBufSize,
    /* [in] */ LPWSTR pszValue);


void __RPC_STUB IUmiURLKeyList_GetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_RemoveKey_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiURLKeyList_RemoveKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_RemoveAllKeys_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiURLKeyList_RemoveAllKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_GetKeysInfo_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [in] */ ULONG uRequestedInfo,
    /* [out] */ ULONGLONG __RPC_FAR *puResponse);


void __RPC_STUB IUmiURLKeyList_GetKeysInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiURLKeyList_INTERFACE_DEFINED__ */


#ifndef __IUmiURL_INTERFACE_DEFINED__
#define __IUmiURL_INTERFACE_DEFINED__

/* interface IUmiURL */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiURL;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7d-d9db-11d3-a11f-00105a1f515a")
    IUmiURL : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ long lFlags,
            /* [in] */ LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBufSize,
            /* [string][in] */ LPWSTR pszDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPathInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocator( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocator( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][in] */ LPWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRootNamespace( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootNamespace( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentCount( 
            /* [out] */ ULONG __RPC_FAR *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComponent( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComponentFromText( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponent( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [out][in] */ LPWSTR pszClass,
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pKeyList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentAsText( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveComponent( 
            /* [in] */ ULONG uIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllComponents( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLeafName( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLeafName( 
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyList( 
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateLeafPart( 
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteLeafPart( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiURLVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiURL __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiURL __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Set )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBufSize,
            /* [string][in] */ LPWSTR pszDest);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPathInfo )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLocator )( 
            IUmiURL __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLocator )( 
            IUmiURL __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][in] */ LPWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRootNamespace )( 
            IUmiURL __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRootNamespace )( 
            IUmiURL __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponentCount )( 
            IUmiURL __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComponent )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComponentFromText )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponent )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [out][in] */ LPWSTR pszClass,
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pKeyList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponentAsText )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveComponent )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllComponents )( 
            IUmiURL __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLeafName )( 
            IUmiURL __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLeafName )( 
            IUmiURL __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeyList )( 
            IUmiURL __RPC_FAR * This,
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateLeafPart )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteLeafPart )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IUmiURLVtbl;

    interface IUmiURL
    {
        CONST_VTBL struct IUmiURLVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiURL_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiURL_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiURL_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiURL_Set(This,lFlags,pszText)	\
    (This)->lpVtbl -> Set(This,lFlags,pszText)

#define IUmiURL_Get(This,lFlags,puBufSize,pszDest)	\
    (This)->lpVtbl -> Get(This,lFlags,puBufSize,pszDest)

#define IUmiURL_GetPathInfo(This,uRequestedInfo,puResponse)	\
    (This)->lpVtbl -> GetPathInfo(This,uRequestedInfo,puResponse)

#define IUmiURL_SetLocator(This,Name)	\
    (This)->lpVtbl -> SetLocator(This,Name)

#define IUmiURL_GetLocator(This,puNameBufLength,pName)	\
    (This)->lpVtbl -> GetLocator(This,puNameBufLength,pName)

#define IUmiURL_SetRootNamespace(This,Name)	\
    (This)->lpVtbl -> SetRootNamespace(This,Name)

#define IUmiURL_GetRootNamespace(This,puNameBufLength,pName)	\
    (This)->lpVtbl -> GetRootNamespace(This,puNameBufLength,pName)

#define IUmiURL_GetComponentCount(This,puCount)	\
    (This)->lpVtbl -> GetComponentCount(This,puCount)

#define IUmiURL_SetComponent(This,uIndex,pszClass)	\
    (This)->lpVtbl -> SetComponent(This,uIndex,pszClass)

#define IUmiURL_SetComponentFromText(This,uIndex,pszText)	\
    (This)->lpVtbl -> SetComponentFromText(This,uIndex,pszText)

#define IUmiURL_GetComponent(This,uIndex,puClassNameBufSize,pszClass,pKeyList)	\
    (This)->lpVtbl -> GetComponent(This,uIndex,puClassNameBufSize,pszClass,pKeyList)

#define IUmiURL_GetComponentAsText(This,uIndex,puTextBufSize,pszText)	\
    (This)->lpVtbl -> GetComponentAsText(This,uIndex,puTextBufSize,pszText)

#define IUmiURL_RemoveComponent(This,uIndex)	\
    (This)->lpVtbl -> RemoveComponent(This,uIndex)

#define IUmiURL_RemoveAllComponents(This)	\
    (This)->lpVtbl -> RemoveAllComponents(This)

#define IUmiURL_SetLeafName(This,Name)	\
    (This)->lpVtbl -> SetLeafName(This,Name)

#define IUmiURL_GetLeafName(This,puBuffLength,pszName)	\
    (This)->lpVtbl -> GetLeafName(This,puBuffLength,pszName)

#define IUmiURL_GetKeyList(This,pOut)	\
    (This)->lpVtbl -> GetKeyList(This,pOut)

#define IUmiURL_CreateLeafPart(This,lFlags,Name)	\
    (This)->lpVtbl -> CreateLeafPart(This,lFlags,Name)

#define IUmiURL_DeleteLeafPart(This,lFlags)	\
    (This)->lpVtbl -> DeleteLeafPart(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiURL_Set_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ LPCWSTR pszText);


void __RPC_STUB IUmiURL_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_Get_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out][in] */ ULONG __RPC_FAR *puBufSize,
    /* [string][in] */ LPWSTR pszDest);


void __RPC_STUB IUmiURL_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetPathInfo_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uRequestedInfo,
    /* [out] */ ULONGLONG __RPC_FAR *puResponse);


void __RPC_STUB IUmiURL_GetPathInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetLocator_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_SetLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetLocator_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
    /* [string][in] */ LPWSTR pName);


void __RPC_STUB IUmiURL_GetLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetRootNamespace_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_SetRootNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetRootNamespace_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
    /* [string][out][in] */ LPWSTR pName);


void __RPC_STUB IUmiURL_GetRootNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetComponentCount_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puCount);


void __RPC_STUB IUmiURL_GetComponentCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetComponent_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [in] */ LPWSTR pszClass);


void __RPC_STUB IUmiURL_SetComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetComponentFromText_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [in] */ LPWSTR pszText);


void __RPC_STUB IUmiURL_SetComponentFromText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetComponent_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
    /* [out][in] */ LPWSTR pszClass,
    /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pKeyList);


void __RPC_STUB IUmiURL_GetComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetComponentAsText_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
    /* [out][in] */ LPWSTR pszText);


void __RPC_STUB IUmiURL_GetComponentAsText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_RemoveComponent_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex);


void __RPC_STUB IUmiURL_RemoveComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_RemoveAllComponents_Proxy( 
    IUmiURL __RPC_FAR * This);


void __RPC_STUB IUmiURL_RemoveAllComponents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetLeafName_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_SetLeafName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetLeafName_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
    /* [string][out][in] */ LPWSTR pszName);


void __RPC_STUB IUmiURL_GetLeafName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetKeyList_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pOut);


void __RPC_STUB IUmiURL_GetKeyList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_CreateLeafPart_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_CreateLeafPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_DeleteLeafPart_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IUmiURL_DeleteLeafPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiURL_INTERFACE_DEFINED__ */


#ifndef __IUmiQuery_INTERFACE_DEFINED__
#define __IUmiQuery_INTERFACE_DEFINED__

/* interface IUmiQuery */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiQuery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7e-d9db-11d3-a11f-00105a1f515a")
    IUmiQuery : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ LPCWSTR pszLanguage,
            /* [in] */ ULONG uFlags,
            /* [in] */ LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuery( 
            /* [out][in] */ ULONG __RPC_FAR *puLangBufSize,
            /* [out][in] */ LPWSTR pszLangBuf,
            /* [out][in] */ ULONG __RPC_FAR *puQueryTextBufSize,
            /* [out][in] */ LPWSTR pszQueryTextBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiQueryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiQuery __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiQuery __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiQuery __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Set )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszLanguage,
            /* [in] */ ULONG uFlags,
            /* [in] */ LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQuery )( 
            IUmiQuery __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puLangBufSize,
            /* [out][in] */ LPWSTR pszLangBuf,
            /* [out][in] */ ULONG __RPC_FAR *puQueryTextBufSize,
            /* [out][in] */ LPWSTR pszQueryTextBuf);
        
        END_INTERFACE
    } IUmiQueryVtbl;

    interface IUmiQuery
    {
        CONST_VTBL struct IUmiQueryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiQuery_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiQuery_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiQuery_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiQuery_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiQuery_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiQuery_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiQuery_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiQuery_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiQuery_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiQuery_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiQuery_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiQuery_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiQuery_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiQuery_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiQuery_Set(This,pszLanguage,uFlags,pszText)	\
    (This)->lpVtbl -> Set(This,pszLanguage,uFlags,pszText)

#define IUmiQuery_GetQuery(This,puLangBufSize,pszLangBuf,puQueryTextBufSize,pszQueryTextBuf)	\
    (This)->lpVtbl -> GetQuery(This,puLangBufSize,pszLangBuf,puQueryTextBufSize,pszQueryTextBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiQuery_Set_Proxy( 
    IUmiQuery __RPC_FAR * This,
    /* [in] */ LPCWSTR pszLanguage,
    /* [in] */ ULONG uFlags,
    /* [in] */ LPCWSTR pszText);


void __RPC_STUB IUmiQuery_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiQuery_GetQuery_Proxy( 
    IUmiQuery __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puLangBufSize,
    /* [out][in] */ LPWSTR pszLangBuf,
    /* [out][in] */ ULONG __RPC_FAR *puQueryTextBufSize,
    /* [out][in] */ LPWSTR pszQueryTextBuf);


void __RPC_STUB IUmiQuery_GetQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiQuery_INTERFACE_DEFINED__ */


#ifndef __IUmiCustomInterfaceFactory_INTERFACE_DEFINED__
#define __IUmiCustomInterfaceFactory_INTERFACE_DEFINED__

/* interface IUmiCustomInterfaceFactory */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiCustomInterfaceFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14CD599E-2BE7-4c6f-B95B-B150DCD93585")
    IUmiCustomInterfaceFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCLSIDForIID( 
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectByCLSID( 
            /* [in] */ CLSID clsid,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppInterface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCLSIDForNames( 
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiCustomInterfaceFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCLSIDForIID )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectByCLSID )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [in] */ CLSID clsid,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppInterface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCLSIDForNames )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID);
        
        END_INTERFACE
    } IUmiCustomInterfaceFactoryVtbl;

    interface IUmiCustomInterfaceFactory
    {
        CONST_VTBL struct IUmiCustomInterfaceFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiCustomInterfaceFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiCustomInterfaceFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiCustomInterfaceFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiCustomInterfaceFactory_GetCLSIDForIID(This,riid,lFlags,pCLSID)	\
    (This)->lpVtbl -> GetCLSIDForIID(This,riid,lFlags,pCLSID)

#define IUmiCustomInterfaceFactory_GetObjectByCLSID(This,clsid,pUnkOuter,dwClsContext,riid,lFlags,ppInterface)	\
    (This)->lpVtbl -> GetObjectByCLSID(This,clsid,pUnkOuter,dwClsContext,riid,lFlags,ppInterface)

#define IUmiCustomInterfaceFactory_GetCLSIDForNames(This,rgszNames,cNames,lcid,rgDispId,lFlags,pCLSID)	\
    (This)->lpVtbl -> GetCLSIDForNames(This,rgszNames,cNames,lcid,rgDispId,lFlags,pCLSID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiCustomInterfaceFactory_GetCLSIDForIID_Proxy( 
    IUmiCustomInterfaceFactory __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [in] */ long lFlags,
    /* [out][in] */ CLSID __RPC_FAR *pCLSID);


void __RPC_STUB IUmiCustomInterfaceFactory_GetCLSIDForIID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCustomInterfaceFactory_GetObjectByCLSID_Proxy( 
    IUmiCustomInterfaceFactory __RPC_FAR * This,
    /* [in] */ CLSID clsid,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ DWORD dwClsContext,
    /* [in] */ REFIID riid,
    /* [in] */ long lFlags,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppInterface);


void __RPC_STUB IUmiCustomInterfaceFactory_GetObjectByCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCustomInterfaceFactory_GetCLSIDForNames_Proxy( 
    IUmiCustomInterfaceFactory __RPC_FAR * This,
    /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
    /* [in] */ UINT cNames,
    /* [in] */ LCID lcid,
    /* [size_is][out] */ DISPID __RPC_FAR *rgDispId,
    /* [in] */ long lFlags,
    /* [out][in] */ CLSID __RPC_FAR *pCLSID);


void __RPC_STUB IUmiCustomInterfaceFactory_GetCLSIDForNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiCustomInterfaceFactory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_UmiDefURL;

#ifdef __cplusplus

class DECLSPEC_UUID("d4b21cc2-f2a5-453e-8459-b27f362cb0e0")
UmiDefURL;
#endif
#endif /* __UMI_V6_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\nocairo\newop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:  MEMORY.CXX
//
//----------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>


//+---------------------------------------------------------------------------
//
//  Function:   ADsAlloc, public
//
//  Synopsis:   Global allocator for ADs.
//
//  Effects:    Keeps track of the most recent heap allocation in each
//        thread. This information is used to determine when to
//        unlink CUnwindable objects.
//
//  Arguments:  [size] -- Size of the memory to allocate.
//
//  Returns:    A pointer to the allocated memory.
//
//  Modifies:   _pLastNew in _exceptioncontext.
//
//----------------------------------------------------------------------------

void*
ADsAlloc( size_t size )
{
    void *p;

    p  = (void *)LocalAlloc( LMEM_FIXED, size );

    return ( p );
}


//+---------------------------------------------------------------------------
//
//  Function:   ADsFree
//
//  Synopsis:   Matches the ADsAlloc above
//
//  Arguments:  [p] -- The pointer to delete.
//
//  Requires:   [p] was called with ADsFree
//
//  Derivation: Never override.
//
//----------------------------------------------------------------------------

void
ADsFree ( void * p )
{
    if( p == NULL ){
        return;
    }

    if( LocalFree( (HLOCAL)p ) != NULL )
        Win4Assert(!"Bad ptr for operator delete");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\nocairo\oledsdbg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       oledsdbg.cxx
//
//  Contents:
//
//
//  History:
//
//----------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>

#if DBG==1

#include <stdio.h>
#include <printf.h>


unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

CRITICAL_SECTION g_csDP; // used by debug print routines

//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguments:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

void APINOT
vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs
    )
{

    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
        EnterCriticalSection(&g_csDP);
        DWORD tid = GetCurrentThreadId();
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf( "%03d> ", tid );
                w4dprintf("%s: ", pszComp);
            }
            w4vdprintf(ppszfmt, pargs);
        }

        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4printf( "%03d> ", tid );
                w4printf("%s: ", pszComp);
            }
            w4vprintf(ppszfmt, pargs);
        }

        LeaveCriticalSection(&g_csDP);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int APINOT
PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile
    )
{

    int id;
    static char szAssertCaption[100];

    DWORD tid = GetCurrentThreadId();

    sprintf(szAssertCaption,"File: %s line %u, thread id %d",
        szFile, iLine, tid);

    id = MessageBoxA(
                NULL,
                (char *) szMsg,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                );

    return id;
}


//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:
//
//----------------------------------------------------------------------------


void APINOT
Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage
    )
{

    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
                   szMessage, szFile, iLine, tid);
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\nocairo\otrack.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       otrack.cxx
//
//  Contents:   Object tracking system
//
//  Classes:    ObjectTracker
//
//  History:    06-Apr-92 MikeSe         Created
//              30-Sep-93 KyleP          DEVL obsolete
//              15-Jul-94 DonCl          grabbed from common put in forms.
//                                       absolutely minimal changes to
//                                       get it working.
//
//--------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>

#include "symtrans.h"
#include "otrackp.hxx"

// This is all unused in the retail build
#if DBG == 1
CRITICAL_SECTION g_csOT;

// this is a dummy item used as the head of the doubly-linked list
// of TrackLinks, and a mutex to protect it
static TrackLink tlHead = { &tlHead, &tlHead };

// this is a dummy item used as the head of the doubly-linked list
// of NameEntrys
static NameEntry neHead = { &neHead, &neHead };

static char * apszTypes[] = {"Create", "AddRef", "Release"};

//  initialize class static data
int ObjectTracker::_TrackAll = GetProfileInt(L"Object Track",L"DEFAULT",1);

// standard debugging stuff
DECLARE_INFOLEVEL(Ot)

extern void RecordAction ( TrackLink *tl, FrameType ft, ULONG cRefCount );
extern void _cdecl EstablishHistory ( FrameRecord * fr, int nSkip );
extern void DumpHistory ( unsigned long fDebugMask, TrackLink *tl );


//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::ObjectTracker, protected
//
//  Synopsis:   Contructor
//
//  Effects:    Allocates TrackLink structure and initialises it.
//
//  Arguments:  None
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
ObjectTracker::ObjectTracker ()
    :_ulRefs(1)
{
    // Allocate the structure which maintains the tracking history.
    // We also make space for the first FrameRecord.
    HRESULT hr = MemAlloc ( sizeof(TrackLink) + sizeof(FrameRecord),
                          (void**)&_tl);
    if ( FAILED(hr) )
    {
        OtDebugOut ((DEB_OT_ERRORS,
                     "Unable to establish tracking for %lx\n",
                     this ));
    }
    else
    {
        _tl->potr = this;
        _tl->ulSig = TRACK_LINK_SIGNATURE;
        _tl->pszName = NULL;

        FrameRecord * fr = (FrameRecord*) ( _tl + 1 );
        if ( OtInfoLevel & DEB_OT_CALLERS )
        {
            EstablishHistory ( fr, 1 );
        }
        fr->ft = FT_CREATE;
        fr->cRefCount = 1;
        fr->frNext = NULL;
        _tl->frFirst = _tl->frLast = fr;

        // insert at end of list, with concurrency control
        EnterCriticalSection(&g_csOT);
        TrackLink * tll = tlHead.tlPrev;
        tll->tlNext = tlHead.tlPrev = _tl;
        _tl->tlNext = &tlHead;
        _tl->tlPrev = tll;
        LeaveCriticalSection(&g_csOT);

        OtDebugOut ((DEB_OT_ACTIONS, "New object at %lx\n", this ));
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::TrackClassName, protected
//
//  Synopsis:   Records class name for tracked object
//
//  Arguments:  [pszName]       -- class name
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP void
ObjectTracker::TrackClassName (
    char * pszName )
{
    if ( _tl != NULL )
    {
        OtAssert (( _tl->ulSig == TRACK_LINK_SIGNATURE ));

    // Copy the class name so we don't lose it if the class DLL is
    //  unloaded.
    ULONG cBytes = strlen ( pszName ) + 1;
    HRESULT hr = MemAlloc ( cBytes, (void**)&(_tl->pszName) );
    if ( SUCCEEDED(hr) )
    {
        memcpy ( _tl->pszName, pszName, cBytes );
    }
        else
    {
        OtDebugOut((DEB_OT_ERRORS,"Memory allocation failure %lx\n",hr));
        _tl->pszName = "Name lost";
    }

        _tl->fTrack = IsClassTracking(pszName);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::StdAddRef, public
//
//  Synopsis:   Standard implementation of AddRef for tracked objects
//
//  Effects:    Increments ref count, records history
//
//  Returns:    S_OK
//
//  Modifies:   _ulRefs
//
//  Derivation: Never
//
//  History:    31-Jul-92 MikeSe        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP ULONG
ObjectTracker::StdAddRef()
{
    InterlockedIncrement ( (LONG*)&_ulRefs );

    if (_tl->fTrack)
    {
        OtDebugOut ((DEB_OT_ACTIONS, "AddRef [%d] of object at %lx (%s)\n",
                        _ulRefs, this, _tl->pszName ));

        RecordAction ( _tl, FT_ADDREF, _ulRefs );
    }

    return _ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::StdRelease, public
//
//  Synopsis:   Helper function for standard implementation of Release()
//
//  Effects:    Decrements ref count, records history
//
//  Returns:    SUCCESS_NO_MORE iff ref count reached zero.
//              Otherwise S_OK or an error.
//
//  History:    31-Jul-92 MikeSe        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP ULONG
ObjectTracker::StdRelease ()
{
    LONG lResult = InterlockedDecrement((LONG*)&_ulRefs);

    if (_tl->fTrack)
    {
        OtDebugOut ((DEB_OT_ACTIONS, "Release [%d] of object at %lx (%s)\n",
                        _ulRefs, this, _tl->pszName ));

        RecordAction ( _tl, FT_RELEASE, _ulRefs );
    }

    return (lResult==0)?0:_ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::~ObjectTracker, protected
//
//  Synopsis:   Destructor
//
//  Effects:    Remove this item, along with all history, from the
//              tracking list
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
ObjectTracker::~ObjectTracker()
{
    if ( _tl != NULL )
    {
        OtDebugOut ((DEB_OT_ACTIONS, "Delete of object at %lx [%s]\n",
                        this, _tl->pszName ));
        OtAssert (( _tl->ulSig == TRACK_LINK_SIGNATURE ));
        // OtAssert ( _ulRefs == 0 );

        // unlink, with concurrency control
        EnterCriticalSection(&g_csOT);
        TrackLink * tlp = _tl->tlPrev;
        TrackLink * tln = _tl->tlNext;
        tln->tlPrev = tlp;
        tlp->tlNext = tln;
        LeaveCriticalSection(&g_csOT);

        if ((_tl->fTrack) && (OtInfoLevel & DEB_OT_DELETE))
        {
            DumpHistory ( DEB_OT_DELETE, _tl );
        }
		if (_tl->pszName) {
			MemFree(_tl->pszName);
		}
        MemFree ( _tl );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::DumpTrackingInfo, public
//
//  Synopsis:   Dumps out the tracking list
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP void
ObjectTracker::DumpTrackingInfo (
    int fDeleteNode)
{
    TrackLink * tl = tlHead.tlNext;
    BOOL fHeader = FALSE;

    while ( tl != &tlHead )
    {
        // This is an unreleased item. Print out the history info

        if ( !fHeader )
        {
            OtDebugOut((DEB_OT_OBJECTS, "****************************\n"));
            OtDebugOut((DEB_OT_OBJECTS, "* Unreleased objects found *\n"));
            OtDebugOut((DEB_OT_OBJECTS, "****************************\n"));
            fHeader = TRUE;
        }

        OtDebugOut ((DEB_OT_OBJECTS,
                     "Object at %lx (%s)\n",
                     tl->potr,
                     tl->pszName ));
        OtDebugOut ((DEB_OT_OBJECTS,
                     "  Reference count = %d\n",
                     tl->potr->GetRefCount() ));
        DumpHistory ( DEB_OT_CALLERS, tl );

        if (fDeleteNode)
        {
            // unlink, with concurrency control
            EnterCriticalSection(&g_csOT);
            tl->potr->_tl = NULL;
            TrackLink * tlp = tl->tlPrev;
            TrackLink * tln = tl->tlNext;
            tln->tlPrev = tlp;
            tlp->tlNext = tln;
            LeaveCriticalSection(&g_csOT);
            MemFree ( tl );
            tl = tln;
        }
        else
        {
            tl = tl->tlNext;
        }
    }

    //  delete all the name entries
    if (fDeleteNode)
    {
        EnterCriticalSection(&g_csOT);

        //  find the entry if there is one
        NameEntry *ne =  neHead.neNext;
        while (ne != &neHead)
        {
            // unlink, with concurrency control
            NameEntry * nep = ne->nePrev;
            NameEntry * nen = ne->neNext;
            nen->nePrev = nep;
            nep->neNext = nen;
            MemFree ( ne );
            ne = nen;
        }
        LeaveCriticalSection(&g_csOT);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     TrackClass
//
//  Synopsis:   Tells the object tracker to start/stop tracking the specified
//              class of objects.
//
//  Arguments:  [fTrack   -- debug mask controlling the output
//              [pszName] -- TrackLink record
//
//  History:    14-Apr-93 Rickhi          Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
void ObjectTracker::TrackClass(int fTrack, char * pszClassName)
{
    if (pszClassName == NULL)
    {
        //  set default for ALL classes
        _TrackAll = fTrack;
        return;
    }


    //  find the entry if there is one
    NameEntry *ne =  neHead.neNext;

    while (ne != &neHead)
    {
        if (!strcmp(ne->pszName, pszClassName))
        {
            //  found our entry, update the flag
            ne->fTrack = fTrack;
            return;
        }

        ne = ne->neNext;
    }

    //  its not in the list
    HRESULT hr = MemAlloc( sizeof(NameEntry), (void **)&ne);
    if ( FAILED(hr) )
    {
        OtDebugOut((DEB_OT_ERRORS,
                    "Unable to record class for tracking %s\n",
                    pszClassName));
    }
    else
    {
        ne->pszName = pszClassName;
        ne->fTrack = fTrack;

        // insert at end of list, with concurrency control
        EnterCriticalSection(&g_csOT);
        NameEntry *neH = neHead.nePrev;
        neH->neNext = neHead.nePrev = ne;
        ne->neNext = &neHead;
        ne->nePrev = ne;
        LeaveCriticalSection(&g_csOT);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     IhrlassTracking, private
//
//  Synopsis:   returns TRUE if the object is currently tracked
//
//  Arguments:  [pszClassName] -- class name
//
//  History:    14-Apr-93 Rickhi          Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
int ObjectTracker::IsClassTracking(char * pszClassName)
{
    //  find the entry if there is one
    NameEntry *ne =  neHead.neNext;
    while (ne != &neHead)
    {
        if (!strcmp(ne->pszName, pszClassName))
        {
            return ne->fTrack;
        }
        ne = ne->neNext;
    }

    return GetProfileIntA("Object Track",pszClassName,_TrackAll);
}

//+-------------------------------------------------------------------------
//
//  Function:   DumpHistory
//
//  Synopsis:   Dumps the call history represented by a particular TrackLink
//
//  Arguments:  [fDebugMask]    -- debug mask controlling the output
//              [tl]            -- TrackLink record
//
//  History:    28-Jul-92 MikeSe        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void DumpHistory ( unsigned long fDebugMask, TrackLink * tl )
{
// we can't call TranslateAddress without access to NT header files
#ifndef MSVC
#ifndef WIN95
    //
    // Only do all of this work if it will output anything!
    //
    if (OtInfoLevel & fDebugMask)
    {
        OtDebugOut ((fDebugMask, "  Call history follows:\n" ));
        FrameRecord * fr = tl->frFirst;
        while ( fr != NULL )
        {
            char achBuffer[MAX_TRANSLATED_LEN];

            OtDebugOut ((fDebugMask,
                         "\t%s [%d]\n",
                         apszTypes[fr->ft],
                         fr->cRefCount ));

            for ( int I=0; (I < MAX_CALLERS) && (fr->callers[I]); I++ )
            {
                TranslateAddress ( fr->callers[I], achBuffer );
                OtDebugOut ((fDebugMask, "\t    %s\n", achBuffer));
            }

            fr = fr->frNext;
        }
    }
#endif
#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   RecordAction
//
//  Synopsis:   Record an AddRef/Release
//
//  Effects:    Allocates and fills in a new frame record
//
//  Arguments:  [tl]            -- TrackLink for object being tracked
//              [ft]            -- Frame type (FT_ADDREF, FT_RELEASE)
//              [cRefCount]     -- current ref count
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void RecordAction ( TrackLink * tl, FrameType ft, ULONG cRefCount )
{
    // Record the activity only if DEB_OT_CALLERS is set

    if ( tl != NULL && (OtInfoLevel & DEB_OT_CALLERS))
    {
        OtAssert(tl->ulSig == TRACK_LINK_SIGNATURE );
        FrameRecord * fr;
        HRESULT hr;

        hr = MemAlloc(sizeof(FrameRecord), (void **)&fr);

        if ( FAILED(hr) )
        {
            OtDebugOut((DEB_OT_ERRORS,
                        "Unable to record history for %lx\n",
                        tl->potr));
        }
        else
        {
            // Save call history
            EstablishHistory ( fr, 2 );
            fr->ft = ft;
            fr->cRefCount = cRefCount;
            fr->frNext = NULL;

            // Add to list, with concurrency control
            EnterCriticalSection(&g_csOT);
            FrameRecord * frl = tl->frLast;
            frl->frNext = tl->frLast = fr;
            LeaveCriticalSection(&g_csOT);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   EstablishHistory
//
//  Synopsis:   Records calling history for an operation
//
//  Effects:    Walks back through call frames recording caller addresses.
//
//  Arguments:  [fr]            -- FrameRecord in which to save history
//              [nFramesSkip]   -- number of frames to skip before
//                                 recording.
//
//  History:    6-Apr-92 MikeSe         Created [from PaulC's imalloc code]
//      19-Apr-94 MikeSe    Converted to use RtlCaptureStackBacktrace
//
//  Notes:
//
//--------------------------------------------------------------------------

void _cdecl
EstablishHistory (
    FrameRecord * fr,
    int nFramesSkip
    )
{

#if (defined(i386) && !defined(WIN95))

    memset ( fr->callers, 0, MAX_CALLERS * sizeof(void*) );

    ULONG ulHash;
    RtlCaptureStackBackTrace ( nFramesSkip, MAX_CALLERS,
                    fr->callers, &ulHash );
#endif // i386
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\nocairo\symtrans.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       symtrans.c
//
//  Contents:   Address->symbolic name translation code
//
//  Functions:  TranslateAddress
//
//  History:     8-Mar-93 PeterWi   Re-ssynced to module list so that
//                                  symbol translation worked.
//              16-Jul-92 MikeSe    Created
//
//  Notes:      This is debug only code, extracted from a piece of NT.
//              (private\windows\base\client\debugint.c).
//
//              Warning: most of this stuff is black magic. You are strongly
//              advised to refer to the original code (as above) before
//              making any changes.
//
//--------------------------------------------------------------------------

#include "dswarn.h"

void
TranslateAddress(
    void * pvAddress,
    char * pchBuffer )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\nocairo\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*   14-Mar-94 DonCl stolen from Cairo common project to use with Forms so
*                   Forms can build and run on Daytona without commnot.dll
*
*******************************************************************************/

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include "wchar.h"
#include "w4io.h"


/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x            // 100390--WHB

#define NOFLOATS                        // Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#ifdef FLAT
#  define LONG_IS_INT        1       /* 1 means long is same size as int */
#  define SHORT_IS_INT       0       /* 1 means short is same size as int */
#  define PTR_IS_INT         1       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        0       /* 1 means ptr is same size as long */
#else // LARGE model
#  define LONG_IS_INT        0       /* 1 means long is same size as int */
#  define SHORT_IS_INT       1       /* 1 means short is same size as int */
#  define PTR_IS_INT         0       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        1       /* 1 means ptr is same size as long */
#endif
#define LONGDOUBLE_IS_DOUBLE 0       /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#ifndef _WIN64
    #if PTR_IS_INT
        #define get_ptr_arg(x) (void *)get_int_arg(x)
    #elif PTR_IS_LONG
        #define get_ptr_arg(x) (void *)get_long_arg(x)
    #else
        #error Size of pointer must be same as size of int or long
    #endif
#else
    #define get_ptr_arg(x) (void *)get_ptr64_arg(x)
#endif

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE     /* buffer size for maximum double conv */
#define BUFFERSIZE 20

/* flag definitions */
#define FL_SIGN       0x0001      /* put plus or minus in front */
#define FL_SIGNSP     0x0002      /* put space or minus in front */
#define FL_LEFT       0x0004      /* left justify */
#define FL_LEADZERO   0x0008      /* pad with leading zeros */
#define FL_LONG       0x0010      /* long value given */
#define FL_SHORT      0x0020      /* short value given */
#define FL_SIGNED     0x0040      /* signed data given */
#define FL_ALTERNATE  0x0080      /* alternate form requested */
#define FL_NEGATIVE   0x0100      /* value is negative */
#define FL_FORCEOCTAL 0x0200      /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400      /* long double value given */
#define FL_WIDE       0x0800      /* wide character/string given */

/* state definitions */
enum STATE {
    ST_NORMAL,              /* normal state; outputting literal chars */
    ST_PERCENT,             /* just read '%' */
    ST_FLAG,                /* just read flag character */
    ST_WIDTH,               /* just read width specifier */
    ST_DOT,                 /* just read '.' */
    ST_PRECIS,              /* just read precision specifier */
    ST_SIZE,                /* just read size specifier */
    ST_TYPE                 /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,               /* character with no special meaning */
    CH_PERCENT,             /* '%' */
    CH_DOT,                 /* '.' */
    CH_STAR,                /* '*' */
    CH_ZERO,                /* '0' */
    CH_DIGIT,               /* '1'..'9' */
    CH_FLAG,                /* ' ', '+', '-', '#' */
    CH_SIZE,                /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE                 /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";    /* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.                                                               */

static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x30, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07,
    0x08
};

#define find_char_class(c)              \
        ((c) < ' ' || (c) > 'x' ?       \
            CH_OTHER                    \
        :                               \
            lookuptable[(c)-' '] & 0xF)

#define find_next_state(class, state)   \
        (lookuptable[(class) * NUMSTATES + (state)] >> 4)

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr);
#endif
LOCAL(int) get_int_arg(va_list *pargptr);
#ifdef _WIN64
LOCAL(void*) get_ptr64_arg(va_list *pargptr);
#endif
LOCAL(void) writestring(char *string,
                        int len,
                        struct w4io *f,
                        int *pcchwritten,
                        int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (* PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)       (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)       (*_cfltcvt_tab[3])(a)
#define _positive(a)        (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif


/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io *f, const char *format, va_list argptr)
{
    int hexadd=0;       /* offset to add to number to get 'a'..'f' */
    char ch;            /* character just read */
    wchar_t wc;         /* wide character temp */
    wchar_t *pwc;       /* wide character temp pointer */
    int flags = 0;      /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;          /* current conversion radix */
    int charsout;       /* characters currently written so far, -1 = IO error */
    int fldwidth=0;     /* selected field with -- 0 means default */
    int fwide;
    int precision=0;    /* selected precision -- -1 means default */
    char prefix[2];     /* numeric prefix -- up to two characters */
    int prefixlen=0;    /* length of prefix -- 0 means no prefix */
    int capexp;         /* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output=0;    /* non-zero = prodcue no output for this specifier */
    char *text=NULL;    /* pointer text to be printed, not zero terminated */
    int textlen=0;      /* length of the text to be printed */
    char buffer[BUFFERSIZE];    /* buffer for conversions */

    charsout = 0;               /* no characters written yet */
    state = ST_NORMAL;          /* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
        chclass = find_char_class(ch);  /* find character class */
        state = find_next_state(chclass, state); /* find next state */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:
            /* normal state -- just write character */
            f->writechar(ch, 1, f, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            fwide = 0;
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case '-':
                flags |= FL_LEFT;       /* '-' => left justify */
                break;
            case '+':
                flags |= FL_SIGN;       /* '+' => force sign indicator */
                break;
            case ' ':
                flags |= FL_SIGNSP;     /* ' ' => force sign or space */
                break;
            case '#':
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case '0':
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == '*') {
                /* get width from arg list */
                fldwidth = get_int_arg(&argptr);
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - '0');
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == '*') {
                /* get precision from arg list */
                precision = get_int_arg(&argptr);
                if (precision < 0)
                    precision = -1;     /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - '0');
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
#if !LONG_IS_INT
            case 'l':
                flags |= FL_LONG;   /* 'l' => long int */
                break;
#endif

#if !LONGDOUBLE_IS_DOUBLE
            case 'L':
                flags |= FL_LONGDOUBLE; /* 'L' => long double */
                break;
#endif

#if !SHORT_IS_INT
            case 'h':
                flags |= FL_SHORT;  /* 'h' => short int */
                break;
#endif
            case 'w':
                flags |= FL_WIDE;   /* 'w' => wide character */
                break;
            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is doen in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case 'c': {
                /* print a single character specified by int argument */
                wc = (wchar_t) get_int_arg(&argptr);    /* get char to print */
                * (wchar_t *) buffer = wc;
                text = buffer;
                textlen = 1;        /* print just a single character */
            }
            break;

            case 'S': {
                /* print a Counted String   */

                struct string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

                pstr = get_ptr_arg(&argptr);
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    /* 64-bit: we assume length of string is <= 4 GB */
                    textlen = (int)strlen(text);
                    flags &= ~FL_WIDE;
                } else {
                    text = pstr->Buffer;
                    /* The length field is a count of bytes, not characters. */
                    if (flags & FL_WIDE)
                        textlen = pstr->Length / sizeof( wchar_t );
                    else
                        textlen = pstr->Length;
                    if (precision != -1)
                        textlen = min( textlen, precision );
                }

            }
            break;

            case 's': {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */

                text = get_ptr_arg(&argptr);
                if (text == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    flags &= ~FL_WIDE;
                }

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;

                /* scan for null upto i characters */
                if (flags & FL_WIDE) {
                    pwc = (wchar_t *) text;
                    while (i-- && (wc = *pwc) != 0 && (wc & 0x00ff)) {
                        ++pwc;
                        if (wc & 0xff00) {      // if high byte set,
                            break;              // error will be indicated
                        }
                    }
                    textlen = (int)(pwc - (wchar_t *) text);  /* length of string */
                } else {
                    p = text;
                    while (i-- && *p) {
                        ++p;
                    }
                    textlen = (int)(p - text);    /* length of the string */
                }
            }
            break;

            case 'n': {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;            /* temp */

                p = get_ptr_arg(&argptr);

                /* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;


#ifndef NOFLOATS
            case 'E':
            case 'G':
                capexp = 1;                 /* capitalize exponent */
                ch += 'a' - 'A';            /* convert format char to lower */
                /* DROP THROUGH */
            case 'e':
            case 'f':
            case 'g':   {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
                text = buffer;              /* put result in buffer */
                flags &= ~FL_WIDE;          /* 8 bit string */

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;      /* default precision: 6 */
                else if (precision == 0 && ch == 'g')
                    precision = 1;      /* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    _cldcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, LONGDOUBLE);
                }
                else
#endif
                {
                    _cfltcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, DOUBLE);
                }

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                    _forcdecpt(text);

                /* 'g' format means crop zero unless '#' given */
                if (ch == 'g' && !(flags & FL_ALTERNATE))
                    _cropzeros(text);

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text == '-') {
                    flags |= FL_NEGATIVE;
                    ++text;
                }

                textlen = strlen(text);     /* compute length of text */
            }
            break;
#endif // NOFLOATS

            case 'd':
            case 'i':
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case 'u':
                radix = 10;
                goto COMMON_INT;

            case 'p':
                /* write a pointer -- this is like an integer or long */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if !PTR_IS_INT
                flags |= FL_LONG;       /* assume we're converting a long */
#endif
                /* DROP THROUGH to hex formatting */

            case 'C':
            case 'X':
                /* unsigned upper hex output */
                hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case 'x':
                /* unsigned lower hex output */
                hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = '0';
                    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);   /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case 'o':
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

                unsigned long number;   /* number to convert */
                int digit;              /* ascii value of digit */
                long l;                 /* temp long value */

                /* 1. read argument into l, sign extend as needed */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    l = get_long_arg(&argptr);
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
                        l = (short) get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
                }
                else
#endif
                {
                    if (flags & FL_SIGNED)
                        l = get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                }
                else {
                    number = l;
                }

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;              /* default precision */
                else
                    flags &= ~FL_LEADZERO;

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text = &buffer[BUFFERSIZE-1];   // last digit at end of buffer
                flags &= ~FL_WIDE;              // 8 bit characters

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;            /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text-- = (char)digit;      /* store the digit */
                }

                textlen = (int)((char *)&buffer[BUFFERSIZE-1] - text); /* compute length of number */
                ++text;         /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
                    *--text = '0';
                    ++textlen;          /* add a zero */
                }
            }
            break;
            }

            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = '-';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = '+';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = ' ';
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* write prefix */
                writestring(prefix, prefixlen, f, &charsout, 0);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    f->writechar('0', padding, f, &charsout);
                }

                /* write text */
                writestring(text, textlen, f, &charsout, flags & FL_WIDE);

                if (flags & FL_LEFT) {
                    /* pad on right with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* we're done! */
            }
            break;
        }
    }

    return charsout;        /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list *pargptr)
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif


/***
void * get_ptr64_arg(va_list pargptr)
*
*Purpose:
*   Gets an 64-bit pointer argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the ptr64 argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#ifdef _WIN64
LOCAL(void *) get_ptr64_arg(va_list *pargptr)
{
    return va_arg(*pargptr, void *__ptr64);
}
#endif  // _WIN64


/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len          - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide        - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
        char *string,
        int len,
        struct w4io *f,
        int *pcchwritten,
        int fwide)
{
    wchar_t *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
        pwc = (wchar_t *) string;
        while (len-- > 0) {
            if (*pwc & 0xff00) {
                f->writechar('^', 1, f, pcchwritten);
            }
            f->writechar((char) *pwc++, 1, f, pcchwritten);
        }
    } else {
        while (len-- > 0) {
            f->writechar(*string++, 1, f, pcchwritten);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\nocairo\printf.h ===
/**
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*       14-Mar-94 DonCl stolen from common project for use with Forms so
*                       we can build on Daytona without linking to commnot.
*
*******************************************************************************/

#include <wchar.h>
#include <stdarg.h>
#include <limits.h>
#include <sys\types.h>

#define _W4DPRINTF_
#include <w4io.h>

#define pwcbuf        buf.wc._pwcbuf
#define pwcstart    buf.wc._pwcstart
#define pchbuf        buf.ch._pchbuf
#define pchstart    buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
#ifdef __cplusplus
extern "C" {
#endif
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
#ifdef __cplusplus
}
#endif



#if defined(_W4PRINTF_)
    static long fh;
//    extern long GetStdHandle(long);
//    extern void WriteFile(long fh, char *s, long cch, long * pcchret, long);
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#   ifdef WIN32
#     undef  OutputDebugString
#     define OutputDebugString OutputDebugStringA
#   else
      extern void _pascal OutputDebugString(char *);
#   endif
    int _cdecl _pflushbuf(struct w4io *f);
#   define SPR(a)
#   define MAXSTR       128
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist);


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ *string) const char *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == -1)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = (long)GetStdHandle(ldummy)) == 0 || fh == -1)
        {
            OutputDebugString("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#  ifndef FLAT
        if (ch == '\n')
        {
            *f->_PBUF_++ = '\r';
            f->cchleft--;
            (*pcchwritten)++;
        }
#  endif
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io *f)
{
    int cch;

    if ((cch = (int)(f->pchbuf - f->pchstart)))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        OutputDebugString(f->pchstart);
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile((HANDLE)fh, f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\nocairo\w4io.h ===
/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*  History: ??-???-??  ?????     Created
*           14-Mar-94  DonCl     stolen from Cairo common project for use
*                                with Forms - allows us to have our own
*                                debug print facility exclusive of commnot.dll
*                                enabling us to build and run on Daytona.
*
*/

struct w4io
{
    union
    {
    struct
    {
        wchar_t *_pwcbuf;    // wchar_t output buffer
        wchar_t *_pwcstart;
    } wc;
    struct
    {
        char *_pchbuf;    // char output buffer
        char *_pchstart;
    } ch;
    } buf ;
    unsigned int cchleft;    // output buffer character count
    void (_cdecl *writechar)(int ch,
                 int num,
                 struct w4io *f,
                 int *pcchwritten);
};

#define pwcbuf        buf.wc._pwcbuf
#define pwcstart    buf.wc._pwcstart
#define pchbuf        buf.ch._pchbuf
#define pchstart    buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
#ifdef __cplusplus
extern "C" {
#endif
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\nocairo\symtrans.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       symtrans.h
//
//  Contents:   Definitions associated with address->symbol translation
//
//  History:    17-Jul-92       MikeSe  Created
//              22-Jun-93  BryanT  Increased MAX_TRANS value to account for
//                                  Line/File information.
//
//----------------------------------------------------------------------------

#ifndef __SYMTRANS_H__
#define __SYMTRANS_H__

//
// The following function provides translation of function addresses into
// symbolic (NTSD-style) names. It is only available if ANYSTRICT is defined.
// (see common\src\commnot\symtrans.c)

# ifdef __cplusplus
extern "C" {
# endif

EXPORTDEF void APINOT
TranslateAddress (
    void * pvAddress,               // address to translate
    char * pchBuffer );             // output buffer

// The output buffer should allocated by the caller, and be at least
// the following size:

#define NT_SYM_ENV              "_NT_SYMBOL_PATH"
#define NT_ALT_SYM_ENV          "_NT_ALT_SYMBOL_PATH"
#define SYS_ENV                 "SystemRoot"

#define IMAGEHLP_DLL            "imagehlp.dll"
#define MAP_DBG_INFO_CALL       "MapDebugInformation"

#define MAX_TRANSLATED_LEN      600

# ifdef __cplusplus
}
# endif

#endif  // of ifndef __SYMTRANS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\nocairo\sysmem.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:          SysMem.CXX
//
//  Contents:   System Memory Management routines
//
//  Functions:  MemAlloc, MemFree, MemAllocLinked
//
//  History:    10-Feb-92   AlexT   Created
//        07-May-92   MikeSe  Converted to using Win32 Heap functions.
//        14-Jul-92   randyd  Added MemSwitchRoot, see memmgmt.doc.
//        5-Oct-93    isaache Slight reorganization, conversion to 'new'
//        13-Jul-94   doncl   stole from ole32, put in ADs proj, deleted
//                            MemSwitchRoot, switched to naked
//                            Win32 CRITICAL_SECTION usage
//
//  Notes:        For additional information, see win4adm\standrds\memmgmt.doc.
//
//                This memory management package is multithread capable - the
//                only place it makes a difference is in MemAllocLinked and
//                MemSwitchRoot, where we use a critical section t
//                protect adding link blocks to the list. We rely on the fact
//                that LocalAlloc is multi-thread safe.
//
//--------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>

#if 0
#include <excpt.h>
#include <except.hxx>
#include <dllsem.hxx>
#endif

CRITICAL_SECTION g_csMem;

//  Memory block prefix (for signature and link)

typedef struct _smheader
{
    unsigned long      ulSignature;
    struct _smheader   *psmNext;
} SMHEADER, *PSMHEADER;


//  Memory block signatures (for strict checks)

const ULONG ROOT_BLOCK          = 0x726f6f74;     // 'root'
const ULONG LINKED_BLOCK        = 0x6c696e6b;     // 'link'

static BOOL
VerifySignature(PSMHEADER psm, ULONG ulSig )
{
    BOOL fReturn;

    __try
    {
        fReturn = (ulSig == psm->ulSignature );
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        fReturn = FALSE;
    }

    return fReturn;
}

// This module acts as the declarer of debug support symbols for COMMNOT
DECLARE_INFOLEVEL(Cn);



//+-------------------------------------------------------------------------
//
//  Function:   MemAlloc
//
//  Synopsis:   allocates memory block
//
//  Arguments:  [ulSize]                -- size of block in bytes
//                        [ppv]            -- output pointer
//
//  Returns:    status code
//
//  Algorithm:  call new, adding space for header
//
//  History:    10-Feb-92 AlexT  Created
//
//--------------------------------------------------------------------------

HRESULT
MemAlloc ( unsigned long ulSize, void ** ppv )
{
    PSMHEADER psm;

    *ppv = NULL;

    psm = (PSMHEADER) LocalAlloc(LMEM_FIXED, ulSize + sizeof(SMHEADER));
    if ( psm != NULL )
    {
        psm->ulSignature = ROOT_BLOCK;
        psm->psmNext = NULL;

        *ppv = psm + 1;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------------
//
//  Function:   MemFree
//
//  Synopsis:   release system memory block
//
//  Arguments:  [pvBlockToFree] -- memory block to release
//
//  Algorithm:  Walk list of linked blocks, deleting each one
//
//  History:    10-Feb-92 AlexT  Created
//
//--------------------------------------------------------------------------

HRESULT
MemFree( void *pvBlockToFree )
{
    PSMHEADER psm = ((PSMHEADER) pvBlockToFree) - 1;

    if( pvBlockToFree == NULL || psm == NULL )
        return S_OK;

    if( !VerifySignature( psm, ROOT_BLOCK ) )
    {
        Win4Assert( !"MemFree -- not a root block!\n" );
        return MEM_E_INVALID_ROOT;
    }

    do {
        PSMHEADER psmNext = psm->psmNext;

        psm->ulSignature = 0;
        LocalFree(psm);
        psm = psmNext;
        if( psm && !VerifySignature( psm, LINKED_BLOCK ) )
        {
            Win4Assert( !"MemFree -- invalid linked block!\n" );
            return MEM_E_INVALID_LINK;
        }
    } while( psm != NULL );

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   MemAllocLinked
//
//  Synopsis:   allocates linked memory block
//
//
//  Arguments:  [pvRootBlock]   -- root memory block
//                        [ulSize]              -- size of new memory block
//                        [ppv]            -- output pointer
//
//  Returns:   status code
//
//
//  History:    10-Feb-92 AlexT  Created
//
//  Notes:        pvRootBlock can specify either a root block, or another
//                        linked block.
//
//--------------------------------------------------------------------------

HRESULT
MemAllocLinked ( void *pvRootBlock, unsigned long ulSize, void ** ppv )
{
    PSMHEADER psm = NULL;
    PSMHEADER psmRoot = ((PSMHEADER) pvRootBlock) - 1;

    *ppv = NULL;

    if ( pvRootBlock == NULL || psmRoot == NULL )
    {
        Win4Assert( !"MemAllocLinked - null root block\n" );
        return MEM_E_INVALID_ROOT;
    }


    if ( !VerifySignature(psmRoot, ROOT_BLOCK)
       && !VerifySignature(psmRoot,LINKED_BLOCK) )
    {
        Win4Assert( !"MemAllocLinked - invalid root block\n" );
        return MEM_E_INVALID_ROOT;
    }

    psm = (PSMHEADER) LocalAlloc(LMEM_FIXED, ulSize + sizeof(SMHEADER));
    if ( psm == NULL )
        return E_OUTOFMEMORY;

    psm->ulSignature = LINKED_BLOCK;

    EnterCriticalSection(&g_csMem);
    psm->psmNext = psmRoot->psmNext;
    psmRoot->psmNext = psm;
    LeaveCriticalSection(&g_csMem);

    //  move psm past header
    *ppv = psm+1;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\noole\creden.cxx ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    creden.cxx

Abstract:

    This module abstracts user credentials for the multiple credential support.

Author:

    Krishna Ganugapati (KrishnaG) 03-Aug-1996

Revision History:

--*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include "memory.h"
}


#include <basetyps.h>

typedef  long HRESULT;


#include "misc.hxx"
#include "creden.hxx"

#define NW_ENCODE_SEED3  0x83

CCredentials::CCredentials():
    _lpszUserName(NULL),
    _lpszPassword(NULL),
    _dwAuthFlags(0)
{
}

CCredentials::CCredentials(
    LPWSTR lpszUserName,
    LPWSTR lpszPassword,
    DWORD dwAuthFlags
    ):
    _lpszUserName(NULL),
    _lpszPassword(NULL),
    _dwAuthFlags(0)
{

    //
    // AjayR 10-04-99 we need a way to bail if the
    // alloc's fail. Since it is in the constructor this is
    // not very easy to do.
    //
    UNICODE_STRING Password;

    if (lpszUserName) {
        _lpszUserName = AllocADsStr(
                        lpszUserName
                        );
    }else {
        _lpszUserName = NULL;
    }



    Password.Length = 0;

    if (lpszPassword) {

        UCHAR Seed = NW_ENCODE_SEED3;

        _lpszPassword = AllocADsStr(
                            lpszPassword
                            );

        if (_lpszPassword) {
            RtlInitUnicodeString(&Password, _lpszPassword);
            RtlRunEncodeUnicodeString(&Seed, &Password);
        }

    }else {

        _lpszPassword = NULL;

    }


    _dwAuthFlags = dwAuthFlags;

}

CCredentials::~CCredentials()
{
    if (_lpszUserName) {
        FreeADsStr(_lpszUserName);
    }

    if (_lpszPassword) {
        FreeADsStr(_lpszPassword);
    }

}



HRESULT
CCredentials::GetUserName(
    LPWSTR *lppszUserName
    )
{
    if (!lppszUserName) {
        RRETURN(E_FAIL);
    }


    if (!_lpszUserName) {
        *lppszUserName = NULL;
    }else {

        *lppszUserName = AllocADsStr(_lpszUserName);

        if (!*lppszUserName) {

            RRETURN(E_OUTOFMEMORY);
        }

    }

    RRETURN(S_OK);
}


HRESULT
CCredentials::GetPassword(
    LPWSTR * lppszPassword
    )
{
    UNICODE_STRING Password;
    LPWSTR lpTempPassword = NULL;
    UCHAR Seed = NW_ENCODE_SEED3;


    Password.Length = 0;

    if (!lppszPassword) {
        RRETURN(E_FAIL);
    }

    if (!_lpszPassword) {
        *lppszPassword = NULL;
    }else {


        lpTempPassword = AllocADsStr(_lpszPassword);
        if (!lpTempPassword) {
            RRETURN(E_OUTOFMEMORY);
        }

        RtlInitUnicodeString(&Password, lpTempPassword);
        RtlRunDecodeUnicodeString(Seed, &Password);

        *lppszPassword = lpTempPassword;
    }

    RRETURN(S_OK);
}


HRESULT
CCredentials::SetUserName(
    LPWSTR lpszUserName
    )
{
    if (_lpszUserName) {
        FreeADsStr(_lpszUserName);
    }

    if (!lpszUserName) {

        _lpszUserName = NULL;
        RRETURN(S_OK);
    }

    _lpszUserName = AllocADsStr(
                        lpszUserName
                        );
    if(!_lpszUserName) {
        RRETURN(E_FAIL);
    }

    RRETURN(S_OK);
}


HRESULT
CCredentials::SetPassword(
    LPWSTR lpszPassword
    )
{
    UNICODE_STRING Password;

    if (_lpszPassword) {
        FreeADsStr(_lpszPassword);
    }

    if (!lpszPassword) {

        _lpszPassword = NULL;
        RRETURN(S_OK);
    }


    UCHAR Seed = NW_ENCODE_SEED3;
    Password.Length = 0;

    _lpszPassword = AllocADsStr(
                        lpszPassword
                        );
    if(!_lpszPassword) {
        RRETURN(E_FAIL);
    }

    RtlInitUnicodeString(&Password, _lpszPassword);
    RtlRunEncodeUnicodeString(&Seed, &Password);

    RRETURN(S_OK);
}

CCredentials::CCredentials(
    const CCredentials& Credentials
    )
{

    _lpszUserName = NULL;
    _lpszPassword = NULL;

    _lpszUserName = AllocADsStr(
                        Credentials._lpszUserName
                        );

    _lpszPassword = AllocADsStr(
                        Credentials._lpszPassword
                        );

    _dwAuthFlags = Credentials._dwAuthFlags;

}


void
CCredentials::operator=(
    const CCredentials& other
    )
{
    if ( &other == this) {
        return;
    }

    if (_lpszUserName) {
        FreeADsStr(_lpszUserName);
    }

    if (_lpszPassword) {
        FreeADsStr(_lpszPassword);
    }

    _lpszUserName = AllocADsStr(
                        other._lpszUserName
                        );

    _lpszPassword = AllocADsStr(
                        other._lpszPassword
                        );


    _dwAuthFlags = other._dwAuthFlags;

    return;
}


BOOL
operator==(
    CCredentials& x,
    CCredentials& y
    )
{
    BOOL bEqualUser = FALSE;
    BOOL bEqualPassword = FALSE;
    BOOL bEqualFlags = FALSE;

    LPWSTR lpszXPassword = NULL;
    LPWSTR lpszYPassword = NULL;
    BOOL bReturnCode = FALSE;
    HRESULT hr = S_OK;


    if (x._lpszUserName &&  y._lpszUserName) {
        bEqualUser = !(wcscmp(x._lpszUserName, y._lpszUserName));
    }else  if (!x._lpszUserName && !y._lpszUserName){
        bEqualUser = TRUE;
    }

    hr = x.GetPassword(&lpszXPassword);
    if (FAILED(hr)) {
        goto error;
    }

    hr = y.GetPassword(&lpszYPassword);
    if (FAILED(hr)) {
        goto error;
    }


    if ((lpszXPassword && lpszYPassword)) {
        bEqualPassword = !(wcscmp(lpszXPassword, lpszYPassword));
    }else if (!lpszXPassword && !lpszYPassword) {
        bEqualPassword = TRUE;
    }


    if (x._dwAuthFlags == y._dwAuthFlags) {
        bEqualFlags = TRUE;
    }


    if (bEqualUser && bEqualPassword && bEqualFlags) {

       bReturnCode = TRUE;
    }


error:

    if (lpszXPassword) {
        FreeADsStr(lpszXPassword);
    }

    if (lpszYPassword) {
        FreeADsStr(lpszYPassword);
    }

    return(bReturnCode);

}


BOOL
CCredentials::IsNullCredentials(
    )
{
    // The function will return true even if the flags are set
    // this is because we want to try and get the default credentials
    // even if the flags were set
     if (!_lpszUserName && !_lpszPassword) {
         return(TRUE);
     }else {
         return(FALSE);
     }

}


DWORD
CCredentials::GetAuthFlags()
{
    return(_dwAuthFlags);
}


void
CCredentials::SetAuthFlags(
    DWORD dwAuthFlags
    )
{
    _dwAuthFlags = dwAuthFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\noole\misc.cxx ===
//+---------------------------------------------------------------------
//
//  File:       misc.cxx
//
//  Contents:   Useful OLE helper and debugging functions
//
//----------------------------------------------------------------------

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <basetyps.h>

#include "dswarn.h"
#include "oledsdbg.h"
}

#if (defined(BUILD_FOR_NT40))
typedef unsigned long HRESULT;
#endif



static HRESULT ADsDebugOutHRESULT(DWORD dwFlags, HRESULT r);

#if DBG == 1

//+---------------------------------------------------------------
//
//  Function:   PrintHRESULT
//
//  Synopsis:   Outputs the name of the SCODE and a carriage return
//              to the debugging device.
//
//  Arguments:  [dwFlags] -- Flags to ADsDebugOut.
//              [scode]   -- The status code to report.
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

STDAPI
PrintHRESULT(DWORD dwFlags, HRESULT hr)
{
    ADsDebugOut((dwFlags | DEB_NOCOMPNAME, " "));
    ADsDebugOutHRESULT(dwFlags | DEB_NOCOMPNAME, hr);
    ADsDebugOut((dwFlags | DEB_NOCOMPNAME, "\n"));

    return hr;
}



//+---------------------------------------------------------------
//
//  Function:   ADsDebugOutHRESULT
//
//  Synopsis:   Outputs the name of the SCODE to the debugging device.
//
//  Arguments:  [dwFlags] -- Flags to ADsDebugOut.
//              [scode]   -- The status code to report.
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

static HRESULT
ADsDebugOutHRESULT(DWORD dwFlags, HRESULT r)
{
    LPWSTR lpstr;

#define CASE_SCODE(sc)  \
        case sc: lpstr = (LPWSTR)L#sc; break;

    switch (r) {
        /* SCODE's defined in SCODE.H */
        CASE_SCODE(S_OK)
        CASE_SCODE(S_FALSE)
        CASE_SCODE(OLE_S_USEREG)
        CASE_SCODE(OLE_S_STATIC)
        CASE_SCODE(OLE_S_MAC_CLIPFORMAT)
        CASE_SCODE(DRAGDROP_S_DROP)
        CASE_SCODE(DRAGDROP_S_USEDEFAULTCURSORS)
        CASE_SCODE(DRAGDROP_S_CANCEL)
        CASE_SCODE(DATA_S_SAMEFORMATETC)
        CASE_SCODE(VIEW_S_ALREADY_FROZEN)
        CASE_SCODE(CACHE_S_FORMATETC_NOTSUPPORTED)
        CASE_SCODE(CACHE_S_SAMECACHE)
        CASE_SCODE(CACHE_S_SOMECACHES_NOTUPDATED)
        CASE_SCODE(OLEOBJ_S_INVALIDVERB)
        CASE_SCODE(OLEOBJ_S_CANNOT_DOVERB_NOW)
        CASE_SCODE(OLEOBJ_S_INVALIDHWND)
        CASE_SCODE(INPLACE_S_TRUNCATED)
        CASE_SCODE(CONVERT10_S_NO_PRESENTATION)
        CASE_SCODE(MK_S_REDUCED_TO_SELF)
        CASE_SCODE(MK_S_ME)
        CASE_SCODE(MK_S_HIM)
        CASE_SCODE(MK_S_US)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
        CASE_SCODE(STG_S_CONVERTED)

        CASE_SCODE(E_UNEXPECTED)
        CASE_SCODE(E_NOTIMPL)
        CASE_SCODE(E_OUTOFMEMORY)
        CASE_SCODE(E_INVALIDARG)
        CASE_SCODE(E_NOINTERFACE)
        CASE_SCODE(E_POINTER)
        CASE_SCODE(E_HANDLE)
        CASE_SCODE(E_ABORT)
        CASE_SCODE(E_FAIL)
        CASE_SCODE(E_ACCESSDENIED)

        /* SCODE's defined in DVOBJ.H */
        // CASE_SCODE(DATA_E_FORMATETC)
// same as DATA_E_FORMATETC     CASE_SCODE(DV_E_FORMATETC)
        CASE_SCODE(VIEW_E_DRAW)
//  same as VIEW_E_DRAW         CASE_SCODE(E_DRAW)
        CASE_SCODE(CACHE_E_NOCACHE_UPDATED)

        /* SCODE's defined in OLE2.H */
        CASE_SCODE(OLE_E_OLEVERB)
        CASE_SCODE(OLE_E_ADVF)
        CASE_SCODE(OLE_E_ENUM_NOMORE)
        CASE_SCODE(OLE_E_ADVISENOTSUPPORTED)
        CASE_SCODE(OLE_E_NOCONNECTION)
        CASE_SCODE(OLE_E_NOTRUNNING)
        CASE_SCODE(OLE_E_NOCACHE)
        CASE_SCODE(OLE_E_BLANK)
        CASE_SCODE(OLE_E_CLASSDIFF)
        CASE_SCODE(OLE_E_CANT_GETMONIKER)
        CASE_SCODE(OLE_E_CANT_BINDTOSOURCE)
        CASE_SCODE(OLE_E_STATIC)
        CASE_SCODE(OLE_E_PROMPTSAVECANCELLED)
        CASE_SCODE(OLE_E_INVALIDRECT)
        CASE_SCODE(OLE_E_WRONGCOMPOBJ)
        CASE_SCODE(OLE_E_INVALIDHWND)
        CASE_SCODE(DV_E_DVTARGETDEVICE)
        CASE_SCODE(DV_E_STGMEDIUM)
        CASE_SCODE(DV_E_STATDATA)
        CASE_SCODE(DV_E_LINDEX)
        CASE_SCODE(DV_E_TYMED)
        CASE_SCODE(DV_E_CLIPFORMAT)
        CASE_SCODE(DV_E_DVASPECT)
        CASE_SCODE(DV_E_DVTARGETDEVICE_SIZE)
        CASE_SCODE(DV_E_NOIVIEWOBJECT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_GET)
        CASE_SCODE(CONVERT10_E_OLESTREAM_PUT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_FMT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB)
        CASE_SCODE(CONVERT10_E_STG_FMT)
        CASE_SCODE(CONVERT10_E_STG_NO_STD_STREAM)
        CASE_SCODE(CONVERT10_E_STG_DIB_TO_BITMAP)
        CASE_SCODE(CLIPBRD_E_CANT_OPEN)
        CASE_SCODE(CLIPBRD_E_CANT_EMPTY)
        CASE_SCODE(CLIPBRD_E_CANT_SET)
        CASE_SCODE(CLIPBRD_E_BAD_DATA)
        CASE_SCODE(CLIPBRD_E_CANT_CLOSE)
        CASE_SCODE(DRAGDROP_E_NOTREGISTERED)
        CASE_SCODE(DRAGDROP_E_ALREADYREGISTERED)
        CASE_SCODE(DRAGDROP_E_INVALIDHWND)
        CASE_SCODE(OLEOBJ_E_NOVERBS)
        CASE_SCODE(INPLACE_E_NOTUNDOABLE)
        CASE_SCODE(INPLACE_E_NOTOOLSPACE)

        /* SCODE's defined in STORAGE.H */
        CASE_SCODE(STG_E_INVALIDFUNCTION)
        CASE_SCODE(STG_E_FILENOTFOUND)
        CASE_SCODE(STG_E_PATHNOTFOUND)
        CASE_SCODE(STG_E_TOOMANYOPENFILES)
        CASE_SCODE(STG_E_ACCESSDENIED)
        CASE_SCODE(STG_E_INVALIDHANDLE)
        CASE_SCODE(STG_E_INSUFFICIENTMEMORY)
        CASE_SCODE(STG_E_INVALIDPOINTER)
        CASE_SCODE(STG_E_NOMOREFILES)
        CASE_SCODE(STG_E_DISKISWRITEPROTECTED)
        CASE_SCODE(STG_E_SEEKERROR)
        CASE_SCODE(STG_E_WRITEFAULT)
        CASE_SCODE(STG_E_READFAULT)
        CASE_SCODE(STG_E_LOCKVIOLATION)
        CASE_SCODE(STG_E_FILEALREADYEXISTS)
        CASE_SCODE(STG_E_INVALIDPARAMETER)
        CASE_SCODE(STG_E_MEDIUMFULL)
        CASE_SCODE(STG_E_ABNORMALAPIEXIT)
        CASE_SCODE(STG_E_INVALIDHEADER)
        CASE_SCODE(STG_E_INVALIDNAME)
        CASE_SCODE(STG_E_UNKNOWN)
        CASE_SCODE(STG_E_UNIMPLEMENTEDFUNCTION)
        CASE_SCODE(STG_E_INVALIDFLAG)
        CASE_SCODE(STG_E_INUSE)
        CASE_SCODE(STG_E_NOTCURRENT)
        CASE_SCODE(STG_E_REVERTED)
        CASE_SCODE(STG_E_CANTSAVE)
        CASE_SCODE(STG_E_OLDFORMAT)
        CASE_SCODE(STG_E_OLDDLL)
        CASE_SCODE(STG_E_SHAREREQUIRED)

        /* SCODE's defined in COMPOBJ.H */
        CASE_SCODE(CO_E_NOTINITIALIZED)
        CASE_SCODE(CO_E_ALREADYINITIALIZED)
        CASE_SCODE(CO_E_CANTDETERMINECLASS)
        CASE_SCODE(CO_E_CLASSSTRING)
        CASE_SCODE(CO_E_IIDSTRING)
        CASE_SCODE(CO_E_APPNOTFOUND)
        CASE_SCODE(CO_E_APPSINGLEUSE)
        CASE_SCODE(CO_E_ERRORINAPP)
        CASE_SCODE(CO_E_DLLNOTFOUND)
        CASE_SCODE(CO_E_ERRORINDLL)
        CASE_SCODE(CO_E_WRONGOSFORAPP)
        CASE_SCODE(CO_E_OBJNOTREG)
        CASE_SCODE(CO_E_OBJISREG)
        CASE_SCODE(CO_E_OBJNOTCONNECTED)
        CASE_SCODE(CO_E_APPDIDNTREG)
        CASE_SCODE(CLASS_E_NOAGGREGATION)
        CASE_SCODE(REGDB_E_READREGDB)
        CASE_SCODE(REGDB_E_WRITEREGDB)
        CASE_SCODE(REGDB_E_KEYMISSING)
        CASE_SCODE(REGDB_E_INVALIDVALUE)
        CASE_SCODE(REGDB_E_CLASSNOTREG)
        CASE_SCODE(REGDB_E_IIDNOTREG)
        CASE_SCODE(RPC_E_CALL_REJECTED)
        CASE_SCODE(RPC_E_CALL_CANCELED)
        CASE_SCODE(RPC_E_CANTPOST_INSENDCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INASYNCCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INEXTERNALCALL)
        CASE_SCODE(RPC_E_CONNECTION_TERMINATED)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(RPC_E_SERVER_DIED)
#endif // NO_NTOLEBUGS
        CASE_SCODE(RPC_E_CLIENT_DIED)
        CASE_SCODE(RPC_E_INVALID_DATAPACKET)
        CASE_SCODE(RPC_E_CANTTRANSMIT_CALL)
        CASE_SCODE(RPC_E_CLIENT_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_CLIENT_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_INVALID_DATA)
        CASE_SCODE(RPC_E_INVALID_PARAMETER)
        CASE_SCODE(RPC_E_UNEXPECTED)

        /* SCODE's defined in MONIKER.H */
        CASE_SCODE(MK_E_CONNECTMANUALLY)
        CASE_SCODE(MK_E_EXCEEDEDDEADLINE)
        CASE_SCODE(MK_E_NEEDGENERIC)
        CASE_SCODE(MK_E_UNAVAILABLE)
        CASE_SCODE(MK_E_SYNTAX)
        CASE_SCODE(MK_E_NOOBJECT)
        CASE_SCODE(MK_E_INVALIDEXTENSION)
        CASE_SCODE(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED)
        CASE_SCODE(MK_E_NOTBINDABLE)
        CASE_SCODE(MK_E_NOTBOUND)
        CASE_SCODE(MK_E_CANTOPENFILE)
        CASE_SCODE(MK_E_MUSTBOTHERUSER)
        CASE_SCODE(MK_E_NOINVERSE)
        CASE_SCODE(MK_E_NOSTORAGE)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
#endif //NO_NTOLEBUGS


        // Dispatch error codes
        CASE_SCODE(DISP_E_MEMBERNOTFOUND)

        default:
            ADsDebugOut((dwFlags, "<UNKNOWN SCODE  0x%lx>", r));
            return r;
    }

#undef CASE_SCODE

    ADsDebugOut((dwFlags, "<%ws (0x%lx)>", lpstr, r));
    return r;
}



//+---------------------------------------------------------------------------
//
//  Function:   BreakOnFailed
//
//  Synopsis:   Function called when CheckAndReturnResult or CheckResult
//              examines a failure code.  Set a breakpoint on this function
//              to break on failures.
//
//  History:    5-18-94   adams   Created
//
//----------------------------------------------------------------------------

static void
BreakOnFailed(void)
{
    int x;
    x = 1;
}


//+---------------------------------------------------------------
//
//  Function:   CheckAndReturnResult
//
//  Synopsis:   Issues a warning if the HRESULT indicates failure,
//              and asserts if the HRESULT is not a permitted success code.
//
//  Arguments:  [hr]        -- the HRESULT to be checked.
//              [lpstrFile] -- the file where the HRESULT is being checked.
//              [line]      -- the line in the file where the HRESULT is
//                              being checked.
//              [cSuccess]  -- the number of permitted non-zero success codes.
//              [...]       -- list of success codes.
//
//  Returns:    The return value is exactly the HRESULT passed in.
//
//  History:    1-06-94   adams   Created.
//              5-24-94   adams   Added call to BreakOnFailed.
//
//  Notes:      This function should not be used directly.  Use
//              the SRETURN and RRETURN macros instead.
//
//----------------------------------------------------------------

STDAPI
CheckAndReturnResult(
        HRESULT hr,
        LPSTR   lpstrFile,
        UINT    line,
        int     cSuccess,
        ...)
{
    BOOL    fOKReturnCode;
    va_list va;
    int     i;
    HRESULT hrSuccess;

    //
    // Check if code is an error or permitted success.
    //

    fOKReturnCode = (FAILED(hr) || hr == S_OK || hr == S_FALSE ||
                     cSuccess == -1);
    if (!fOKReturnCode && cSuccess > 0)
    {
        va_start(va, cSuccess);
        for (i = 0; i < cSuccess; i++)
        {
            hrSuccess = va_arg(va, HRESULT);
            ADsAssert(SUCCEEDED(hrSuccess));
            if (hr == hrSuccess)
            {
                fOKReturnCode = TRUE;
                break;
            }
        }

        va_end(va);
    }

    //
    // Assert on non-permitted success code.
    //

    if (!fOKReturnCode)
    {
/* ADsDebugOut((
                DEB_ERROR,
                "ERROR: %s:%d returned bad success code",
                lpstrFile,
                line)); */

        // (void) PrintHRESULT(DEB_ERROR | DEB_NOCOMPNAME, hr);

        //
        // I've removed the Assert but we should enable this
        // to monitor all functions that are returning S_FALSE
        // As far as possible, functions should not return
        // S_FALSE except for the Next function of an Enumerator
        // object.

        // ADsAssert(0 && "An unpermitted success code was returned.");
    }

    //
    // Warn on error result.
    //

    if (FAILED(hr))
    {
        ADsDebugOut((
                DEB_IWARN,
                "WARNING: %s:%d returning",
                lpstrFile,
                line));

        PrintHRESULT(DEB_IWARN | DEB_NOCOMPNAME, hr);

        BreakOnFailed();
    }

    return hr;
}



//+---------------------------------------------------------------
//
//  Function:   CheckResult
//
//  Synopsis:   Issues a warning if the HRESULT indicates failure
//
//  Arguments:  [hr] -- the HRESULT to be checked
//              [lpstrFile] -- the file where the HRESULT is being checked
//              [line] -- the line in the file where the HRESULT is being checked
//
//
//  History:    1-06-94   adams   Error printed only on FAILURE, not also
//                                  on non-zero success.
//              5-24-94   adams   Added call to BreakOnFailed.
//
//  Notes:      This function should not be used directly.  The RRETURN
//              macro is provided for convenience.
//
//----------------------------------------------------------------

STDAPI_(void)
CheckResult(HRESULT hr, LPSTR lpstrFile, UINT line)
{
    if (FAILED(hr))
    {
        ADsDebugOut((DEB_IWARN, "WARNING: "));
        ADsDebugOutHRESULT(DEB_IWARN | DEB_NOCOMPNAME, hr);
        ADsDebugOut((
                DEB_IWARN | DEB_NOCOMPNAME,
                " occurred at %s:%d.\n",
                lpstrFile,
                line));

        BreakOnFailed();
    }
}


#endif  // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\utils\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//              multiple IDispatch-callable interfaces.
//
//  Classes:    CDispatchMgr
//
//  Functions:  None external.
//
//  History:    ??-???-??   KrishnaG   created
//              07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

#include "procs.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include "cdispmgr.hxx"
#include "iprops.hxx"

#endif  // ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    End Non-ADSI compile stuff

//
// Error recovery.
//
#define BAIL_ON_FAILURE(hr) if (FAILED(hr)) { goto cleanup; }

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:    Simplified from Win4AssertEx, to make this dispatch manager
//              not depend on other files.
//
//----------------------------------------------------------------------------
static void
AssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[100];

    sprintf(szAssertCaption, "File: %s line %u, thread id %d",
        szFile, iLine, GetCurrentThreadId());

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
        DebugBreak();
    }
}
# define DispMgrAssert(x)  (void)((x) || (AssertEx(__FILE__, __LINE__, #x),0))
#else
# define AssertEx(f,l,m)   do {} while(0)
# define DispMgrAssert(x)  do {} while(0)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(LONG TypeInfoId, LONG DispId, DISPID *pResult)
{
    if (DispId == DISPID_UNKNOWN)
        *pResult = DispId;
    else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
        DispId < 0 || DispId >= 0x10000)
    {
        //
        // Might happen if some object has very large dispid's.
        // But we can't handle it if it does.
        //
        *pResult = DISPID_UNKNOWN;
    }
    else
        *pResult = ((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

}

static inline void
IncDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
        if (rgdispid[i] == DISPID_UNKNOWN)
            continue;

        //
        // This is either a stack of DispMgrs >127 high, or
        // a programming error.  More likely the latter.
        //
        DispMgrAssert(getDispMgrId(rgdispid[i]) < 0x7f);

        rgdispid[i] =
            (rgdispid[i] & 0x00ffffff) |
            (((getDispMgrId(rgdispid[i]) + 1) & 0x7f) << 24);
    }
}

static inline void
DecDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
        //
        // It should never be less than zero, and the only place
        // this is called from guarantees it is not zero.
        //
        DispMgrAssert(getDispMgrId(rgdispid[i]) > 0);

        rgdispid[i] =
            (rgdispid[i] & 0x00ffffff) |
            (((getDispMgrId(rgdispid[i]) - 1) & 0x7f) << 24);
    }
}

static inline void
MakeDISPIDs(LONG TypeInfoId, DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//
// Struct defs
//
typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;


PTYPEINFO_TABLE gpTypeInfoTable = NULL;

CRITICAL_SECTION g_DispTypeInfoCritSect;

#define ENTER_DISP_TYPEINFO_CRITSECT()  EnterCriticalSection(&g_DispTypeInfoCritSect)
#define LEAVE_DISP_TYPEINFO_CRITSECT()  LeaveCriticalSection(&g_DispTypeInfoCritSect)

LONG glnObjCount = 0;
LONG glnTypesOfInfo = 0;
LONG glnOledbObjCnt = 0;


//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CDispatchMgr::CDispatchMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
    _pDispatch = NULL;
}

CDispatchMgr::~CDispatchMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        InterlockedDecrement(&glnObjCount);

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

    ENTER_DISP_TYPEINFO_CRITSECT();
    if (glnObjCount == glnTypesOfInfo) {
        //
        // We need to clean up the list
        //
        FreeTypeInfoTable();

        glnObjCount = glnTypesOfInfo = 0;

    }
    LEAVE_DISP_TYPEINFO_CRITSECT();

    if (_pDispatch)
        _pDispatch->Release();
}

void
CDispatchMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}

void
CDispatchMgr::RegisterBaseDispatchPtr(IDispatch *pDispatch)
{
    _pDispatch = pDispatch;
}

STDMETHODIMP
CDispatchMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDispatchMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDispatchMgr::GetIDsOfNames(REFIID iid, LPWSTR *rgszNames,
        unsigned int cNames, LCID lcid, DISPID *rgdispid)
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
        hr = S_OK;
        for (DWORD dw = 0; dw < cNames; dw++) {
            if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
                    (PDWORD)(rgdispid + dw)))) {
                hr = DISP_E_UNKNOWNNAME;
                rgdispid[dw] = DISPID_UNKNOWN;
            }
        }
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(_dwPropCacheID, rgdispid, cNames);
        }
    }

    //
    // Try our "base class" dispatch pointer.
    //
    if (FAILED(hr) && _pDispatch) {
        hr = _pDispatch->GetIDsOfNames(iid, rgszNames, cNames, lcid, rgdispid);

        if (SUCCEEDED(hr)) {
            IncDispMgrIds(rgdispid, cNames);
        }
    }

    return hr;
}

STDMETHODIMP
CDispatchMgr::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,
        unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CDispatchMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CDispatchMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CDispatchMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CDispatchMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CDispatchMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

    return S_OK;

cleanup:
    return hr;
}

STDMETHODIMP
CDispatchMgr::TypeInfoInvoke(DISPID dispidMember, REFIID iid, LCID lcid,
        unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

        //
            // One of the special DISPIDs.
            //
            // If we have an interface pointer for it, use that.
            // If we don't, and we have a base IDispatch pointer,
            //   pass it to the base pointer's Invoke() method.
            // If we don't, and we don't have a base IDispatch pointer,
            //   return failure.
            //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
            break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

            if (!pInterfacePtr) {
            if (_pDispatch) {
                    return _pDispatch->Invoke(dispidMember, iid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);
                } else {
                    BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
                }
            }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else if (getDispMgrId(dispidMember)) {

            //
            // A regular DISPID of a "base class" dispatch manager.
            //

            if (!_pDispatch){

                char szMessage[80];
                sprintf(szMessage, "_pDispatch is NULL, dispid = 0x%08x",
                        dispidMember);
                 AssertEx(__FILE__, __LINE__, szMessage);
                return DISP_E_MEMBERNOTFOUND;
            }

            DecDispMgrIds(&dispidMember, 1);

            hr = _pDispatch->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                        pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        return(hr);

    } else {

        //
            // A regular DISPID of ours.
            //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

            if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
                pInterfacePtr = getInterfacePtr(typeinfoid);
                pTypeInfo = getTypeInfo(typeinfoid);
                if (!pTypeInfo)
                        //
                    // Shouldn't happen.
                    //
                    BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
            }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = DynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

cleanup:
    return hr;
}


HRESULT
DynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

cleanup:
    return(hr);

}


HRESULT
CDispatchMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CDispatchMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CDispatchMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    DispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

ITypeInfo *
FindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
LoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    DispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (hr)
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CDispatchMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    ENTER_DISP_TYPEINFO_CRITSECT();

    pTypeInfo = ::FindTypeInfo(gpTypeInfoTable, iid);

    if (!pTypeInfo) {

        LEAVE_DISP_TYPEINFO_CRITSECT();

        hr = LoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        ENTER_DISP_TYPEINFO_CRITSECT();

        gpTypeInfoTable = ::AddTypeInfo(
                                gpTypeInfoTable,
                                iid,
                                pTypeInfo
                                );
        if (!gpTypeInfoTable) {

                LEAVE_DISP_TYPEINFO_CRITSECT();
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        //
        // Increment the global list of the types of type info's.
        //
        InterlockedIncrement(&glnTypesOfInfo);

        InterlockedIncrement(&glnObjCount);
    }
    pTypeInfo->AddRef();


    hr = AddTypeInfo(pTypeInfo, pIntf);

    if (FAILED(hr)) {
        LEAVE_DISP_TYPEINFO_CRITSECT();
        BAIL_ON_FAILURE(hr);
    }

    //
    // We have a ref on the object as add was succesful
    //
    InterlockedIncrement(&glnObjCount);
    LEAVE_DISP_TYPEINFO_CRITSECT();

    if (SpecialId == -4) {
        hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
        hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

cleanup:
    if (pTypeInfo)
        pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CDispatchMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
FreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }

    gpTypeInfoTable = NULL;
}

BOOL
DllReadyToUnload()
{
    BOOL retVal = FALSE;

    ENTER_DISP_TYPEINFO_CRITSECT();
        retVal = ((glnTypesOfInfo == 0) && (glnOledbObjCnt == 0));
    LEAVE_DISP_TYPEINFO_CRITSECT();

    return retVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\utils\disputil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       disputil.cxx
//
//  Contents:   Dispatch Utilities.
//
//  Classes:
//
//  Functions:
//
//  History:  25-Oct-94   KrishnaG appropriated from the ADs project
//
//----------------------------------------------------------------------------

#include "procs.hxx"

#define VT_TYPEMASK   0x3ff

#define BAIL_ON_FAILURE(hr) \
    if (FAILED(hr)) {       \
        goto error;         \
    }

#define CONTINUE_ON_FAILURE(hr) \
    if (FAILED(hr)) {           \
        continue;               \
    }

HMODULE g_hActiveDs = NULL; // Module handle of activeds.dll. This should be
                            // initialized when the provider module is loaded
                            // into a process' address space. The handle
                            // is used by FillExcepInfo to retrieve error
                            // description strings from activeds.dll.

static HRESULT VARIANTARGToCVar(VARIANTARG * pvarg, VARTYPE vt, void* pv);
static void CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg);




//+---------------------------------------------------------------------------
//
//  Function:   FreeEXCEPINFO
//
//  Synopsis:   Frees resources in an excepinfo.  Does not reinitialize
//              these fields.
//
//----------------------------------------------------------------------------

void
FreeEXCEPINFO(EXCEPINFO * pEI)
{
    if (pEI)
    {
        ADsFreeString(pEI->bstrSource);
        ADsFreeString(pEI->bstrDescription);
        ADsFreeString(pEI->bstrHelpFile);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   ValidateInvoke
//
//  Synopsis:   Validates arguments to a call of IDispatch::Invoke.  A call
//              to this function takes less space than the function itself.
//
//----------------------------------------------------------------------------

HRESULT
ValidateInvoke(
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr)
{
    if (pvarResult)
        VariantInit(pvarResult);

    if (pexcepinfo)
        InitEXCEPINFO(pexcepinfo);

    if (puArgErr)
        *puArgErr = 0;

    if (!pdispparams)
        RRETURN(E_INVALIDARG);

    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGToCVar
//
//  Synopsis:   Converts a VARIANT to a C-language variable.
//
//  Arguments:  [pvarg] -- Variant to convert.
//              [vt]    -- Type to convert to.
//              [pv]    -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_I2, VT_I4, VT_R4,
//              VT_R8.
//----------------------------------------------------------------------------

static HRESULT
VARIANTARGToCVar(VARIANT * pvarg, VARTYPE vt, void * pv)
{
    HRESULT     hr      = S_OK;
    VARIANTARG  vargNew;                    // variant of new type

    ADsAssert(pvarg);
    ADsAssert(pv);
    ADsAssert((vt & ~VT_TYPEMASK) == 0 || (vt & ~VT_TYPEMASK) == VT_BYREF);

    if (vt & VT_BYREF)
    {
        if (V_VT(pvarg) != vt)
        {
            hr = DISP_E_TYPEMISMATCH;
            goto Cleanup;
        }

        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
        vargNew = *pvarg;
    }
    else
    {
        VariantInit(&vargNew);
        hr = VariantChangeType(&vargNew, pvarg, 0, vt);
        if (hr)
            goto Cleanup;
    }

    switch (vt)
    {
    case VT_BOOL:
        if (V_BOOL(&vargNew) != VB_FALSE && V_BOOL(&vargNew) != VB_TRUE)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // convert VT_TRUE to TRUE
        *(BOOL *)pv = - V_BOOL(&vargNew);
        break;

    case VT_I2:
        *(short *)pv = V_I2(&vargNew);
        break;

    case VT_I4:
        *(long *)pv = V_I4(&vargNew);
        break;

    case VT_R4:
        *(float *)pv = V_R4(&vargNew);
        break;

    case VT_R8:
        *(double *)pv = V_R8(&vargNew);
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        *(void **)pv = V_BYREF(&vargNew);
        break;

    default:
        ADsAssert(FALSE && "Unknown type in VARIANTARGToCVar().\n");
        break;
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CVarToVARIANTARG
//
//  Synopsis:   Converts a C-language variable to a VARIANT.
//
//  Arguments:  [pv]    -- Pointer to C-language variable.
//              [vt]    -- Type of C-language variable.
//              [pvarg] -- Resulting VARIANT.  Must be initialized by caller.
//                         Any contents will be freed.
//
//  Modifies:   [pvarg]
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_UI2, VT_I2, VT_UI4,
//              VT_I4, VT_R4, VT_R8.
//
//----------------------------------------------------------------------------

static void
CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg)
{
    ADsAssert(pv);
    ADsAssert(pvarg);

    VariantClear(pvarg);

    V_VT(pvarg) = vt;
    if (V_ISBYREF(pvarg))
    {
        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
    }

    switch (vt)
    {
    case VT_BOOL:
        // convert TRUE to VT_TRUE
        ADsAssert(*(BOOL *) pv == 1 || *(BOOL *) pv == 0);
        V_BOOL(pvarg) = VARIANT_BOOL(-*(BOOL *) pv);
        break;

    case VT_I2:
        V_I2(pvarg) = *(short *) pv;
        break;

    case VT_I4:
        V_I4(pvarg) = *(long *) pv;
        break;

    case VT_R4:
         V_R4(pvarg) = *(float *) pv;
        break;

    case VT_R8:
        V_R8(pvarg) = *(double *) pv;
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        V_BYREF(pvarg) = *(long **)pv;
        break;

    default:
        Assert(FALSE && "Unknown type.");
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   CParamsToDispParams
//
//  Synopsis:   Converts a C parameter list to a dispatch parameter list.
//
//  Arguments:  [pDispParams] -- Resulting dispatch parameter list.
//                               Note that the rgvarg member of pDispParams
//                               must be initialized with an array of
//                               EVENTPARAMS_MAX VARIANTs.
//
//              [pvt]         -- List of C parameter types.  May be NULL.
//                               If not NULL, Last elem in list MUST be
//                               VT_EMPTY.
//
//              [va]          -- List of C arguments.
//
//  Modifies:   [pDispParams]
//
//  History:    05-Jan-94   adams   Created
//              23-Feb-94   adams   Reversed order of disp arguments, added
//                                  support for VT_R4, VT_R8, and pointer
//                                  types.
//
//  Notes:      Only types VT_I2,VT_I4, and VT_UNKNOWN are supported.
//
//----------------------------------------------------------------------------

void
CParamsToDispParams(
        DISPPARAMS *    pDispParams,
        VARTYPE *       pvt,
        va_list         va)
{
    ADsAssert(pDispParams);
    ADsAssert(pDispParams->rgvarg);

    VARIANTARG *    pvargCur;           // current variant
    VARTYPE *       pvtCur;            // current vartype

    // Assign vals to dispatch param list.
    pDispParams->cNamedArgs         = 0;
    pDispParams->rgdispidNamedArgs  = NULL;

    // Get count of arguments.
    if (!pvt)
    {
        pDispParams->cArgs = 0;
        return;
    }

    for (pvtCur = pvt; *pvtCur != VT_EMPTY; pvtCur++)
        ;

    pDispParams->cArgs = (DWORD)(pvtCur - pvt);
    ADsAssert(pDispParams->cArgs < EVENTPARAMS_MAX);


    //
    // Convert each C-param to a dispparam.  Note that the order of dispatch
    // parameters is the reverse of the order of c-params.
    //

    ADsAssert(pDispParams->rgvarg);
    pvargCur = pDispParams->rgvarg + pDispParams->cArgs;
    for (pvtCur = pvt; *pvtCur != VT_EMPTY; pvtCur++)
    {
        pvargCur--;
        ADsAssert(pvargCur >= pDispParams->rgvarg);

        V_VT(pvargCur) = *pvtCur;
        if ((*pvtCur & VT_BYREF) == VT_BYREF)
        {
            V_BYREF(pvargCur) = va_arg(va, long *);
        }
        else
        {
            switch (*pvtCur)
            {
            case VT_BOOL:
                // convert TRUE to VT_TRUE
                V_BOOL(pvargCur) = VARIANT_BOOL(-va_arg(va, BOOL));
                ADsAssert(V_BOOL(pvargCur) == VB_FALSE ||
                        V_BOOL(pvargCur) == VB_TRUE);
                break;

            case VT_I2:
                V_I2(pvargCur) = va_arg(va, short);
                break;

            case VT_I4:
                V_I4(pvargCur) = va_arg(va, long);
                break;

            case VT_R4:
                V_R4(pvargCur) = va_arg(va, float);
                break;

            case VT_R8:
                V_R8(pvargCur) = va_arg(va, double);
                break;

            //
            // All Pointer types.
            //
            case VT_BSTR:
            case VT_LPSTR:
            case VT_LPWSTR:
            case VT_DISPATCH:
            case VT_UNKNOWN:
                V_BYREF(pvargCur) = va_arg(va, long *);
                break;

            default:
                Assert(FALSE && "Unknown type.\n");
            }
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   DispParamsToCParams
//
//  Synopsis:   Converts Dispatch::Invoke method params to C-language params.
//
//  Arguments:  [pDP] -- Dispatch params to be converted.
//              [pvt] -- Array of types of C-params.  May be NULL.  If
//                       non-NULL, last element must be VT_EMPTY.
//              [...] -- List of pointers to c-params to be converted to.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types listed in VARIANTToCParam.
//
//----------------------------------------------------------------------------

STDAPI
DispParamsToCParams(
        DISPPARAMS *    pDP,
        UINT *          puArgErr,
        VARTYPE *       pvt,
        ...)
{
    HRESULT         hr;
    va_list         va;                // list of pointers to c-params.
    VARTYPE *       pvtCur;            // current VARTYPE of c-param.
    VARIANTARG *    pvargCur;          // current VARIANT being converted.
    void *          pv;                // current c-param being converted.
    int             cArgs;             // count of arguments.

    ADsAssert(pDP);

    hr = S_OK;
    va_start(va, pvt);
    if (!pvt)
    {
        if (pDP->cArgs > 0)
            goto BadParamCountError;

        goto Cleanup;
    }

    pvargCur = pDP->rgvarg + pDP->cArgs - 1;
    pvtCur = pvt;
    for (cArgs = 0; cArgs < (int)pDP->cArgs; cArgs++)
    {
        if (*pvtCur == VT_EMPTY)
            goto BadParamCountError;

        pv = va_arg(va, void *);
        hr = VARIANTARGToCVar(pvargCur, *pvtCur, pv);
        if (hr)
        {
            if (puArgErr)
                *puArgErr = cArgs;

            goto Cleanup;
        }

        pvargCur--;
        pvtCur++;
    }

    if (*pvtCur != VT_EMPTY)
        goto BadParamCountError;

Cleanup:
    va_end(va);
    RRETURN(hr);

BadParamCountError:
    hr = DISP_E_BADPARAMCOUNT;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDispProp
//
//  Synopsis:   Gets a property of an object.
//
//  Arguments:  [pDisp]  -- The object containing the property.
//              [dispid] -- The ID of the property.
//              [riid]   -- interface of object desired
//              [lcid]   -- The locale of the object.
//              [pvar]   -- The resulting property.  Must be initialized.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pvarg].
//
//  History:    23-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified to take REFIID
//
//----------------------------------------------------------------------------

HRESULT
GetDispProp(
        IDispatch * pDisp,
        DISPID      dispid,
        REFIID      riid,
        LCID        lcid,
        VARIANT *   pvar,
        EXCEPINFO * pexcepinfo)
{
    HRESULT     hr;
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.
    UINT        uiErr;                 // Argument error.

    ADsAssert(pDisp);
    ADsAssert(pvar);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    hr = pDisp->Invoke(
            dispid,
            riid,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            pvar,
            pexcepinfo,
            &uiErr);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispProp
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- The object to set the property on.
//              [dispid] -- The ID of the property.
//              [riid]   -- interface of object
//              [lcid]   -- The locale of the property.
//              [pvarg]  -- The value to set.
//
//  Returns:    HRESULT.
//
//  History:    23-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified to take REFIID
//
//----------------------------------------------------------------------------

HRESULT
SetDispProp(
        IDispatch *     pDisp,
        DISPID          dispid,
        REFIID          riid,
        LCID            lcid,
        VARIANTARG *    pvarg,
        EXCEPINFO *     pexcepinfo)
{
    HRESULT     hr;
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke
    UINT        uiErr;                 // Invoke error param.

    ADsAssert(pDisp);
    ADsAssert(pvarg);

    dp.rgvarg = pvarg;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    hr = pDisp->Invoke(
            dispid,
            riid,
            lcid,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            pexcepinfo,
            &uiErr);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDispPropOfType
//
//  Synopsis:   Gets a property from an object, and converts it to a c
//              variable.
//
//  Arguments:  [pDisp]  -- The object to retrieve the property from.
//              [dispid] -- Property ID.
//              [lcid]   -- Locale of property.
//              [vt]     -- Type of c-variable to receive property.
//              [pv]     -- Pointer to resulting c-variable.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pv].
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports variable types found in VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
GetDispPropOfType(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vt,
        void *      pv)
{
    HRESULT     hr;
    VARIANT     varProp;               // Property retrieved.
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.

    ADsAssert(pDisp);
    ADsAssert(pv);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    VariantInit(&varProp);
    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            &varProp,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

    hr = VARIANTARGToCVar(&varProp, vt, pv);

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispPropOfType
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- Object to set property on.
//              [dispid] -- Property ID to set.
//              [lcid]   -- Locale of property.
//              [vt]     -- Type of property to set.
//              [pv]     -- Pointer to property value.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types found in VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
SetDispPropOfType(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vt,
        void *      pv)
{
    HRESULT     hr;
    VARIANTARG  varg;                   // Variant property to put.
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke

    ADsAssert(pDisp);
    ADsAssert(pv);

    VariantInit(&varg);
    CVarToVARIANTARG(pv, vt, &varg);
    dp.rgvarg = &varg;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            NULL,
            NULL);
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CallDispMethod
//
//  Synopsis:   Calls a late-bound method on a object via IDispatch::Invoke.
//
//  Arguments:  [pDisp]     -- Object to call method on.
//              [dispid]    -- Method ID.
//              [lcid]      -- Locale of method.
//              [vtReturn]  -- Type of return value.  If no return value,
//                             must be VT_VOID.
//              [pvReturn]  -- Location of return value.  If no return value,
//                             must be NULL.
//              [pvtParams] -- List of param types.  May be NULL.  If
//                             non-NULL, last entry must be VT_EMPTY.
//              [...]       -- List of params.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CallDispMethod(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vtReturn,
        void *      pvReturn,
        VARTYPE *   pvtParams,
        ...)
{
    HRESULT     hr;
    VARIANTARG  av[EVENTPARAMS_MAX];   // List of args for Invoke.
    DISPPARAMS  dp;                    // Params for Invoke.
    VARIANT     varReturn;             // Return value.
    va_list     va;                    // List of C-params.

    ADsAssert(pDisp);
    ADsAssert((vtReturn != VT_VOID) == (pvReturn != NULL));

    va_start(va, pvtParams);
    dp.rgvarg = av;
    CParamsToDispParams(&dp, pvtParams, va);
    va_end(va);

    if (pvReturn)
        VariantInit(&varReturn);

    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_METHOD,
            &dp,
            pvReturn ? &varReturn : NULL,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

    if (pvReturn)
        hr = VARIANTARGToCVar(&varReturn, vtReturn, pvReturn);

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   IsVariantEqual, public API
//
//  Synopsis:   Compares the values of two VARIANTARGs.
//
//  Arguments:  [pvar1], [pvar2] -- VARIANTARGs to compare.
//
//  Returns:    TRUE if equal, FALSE if not.
//
//  History:    18-Mar-93   SumitC      Created.
//              11-May-94   SumitC      don't assert for VT_UNKNOWN
//
//  Notes:      Variant type unequal returns FALSE, even if actual values
//              are the same.
//              Currently does I2, I4, R4, R8, CY, BSTR, BOOL
//              Returns FALSE for all other VariantTypes.
//
//-------------------------------------------------------------------------

BOOL
IsVariantEqual( VARIANTARG FAR* pvar1, VARIANTARG FAR* pvar2 )
{
    if( V_VT(pvar1) != V_VT(pvar2) )
        return FALSE;

    switch (V_VT(pvar1))
    {
    case VT_EMPTY :
    case VT_NULL:
        return TRUE;    // just the types being equal is good enough

    case VT_I2 :
        return (V_I2(pvar1) == V_I2(pvar2));

    case VT_I4 :
        return (V_I4(pvar1) == V_I4(pvar2));

    case VT_R4 :
        return (V_R4(pvar1) == V_R4(pvar2));

    case VT_R8 :
        return (V_R8(pvar1) == V_R8(pvar2));

    case VT_CY :
        return !memcmp(&V_CY(pvar1), &V_CY(pvar2), sizeof(CY));

    case VT_BSTR :
        return !ADsStringCmp(V_BSTR(pvar1), V_BSTR(pvar2));

    case VT_BOOL :
        return (V_BOOL(pvar1) == V_BOOL(pvar2));

    case VT_UNKNOWN:
        // returns FALSE unless the objects are the same
        return (V_UNKNOWN(pvar1) == V_UNKNOWN(pvar2));

    default:
        ADsAssert(0 && "Type not handled");
        break;
    };

    return(FALSE);
}

HRESULT
ConvertSafeArrayToVariantArray(
    VARIANT varSafeArray,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    VARIANT * pVarArray = NULL;
    SAFEARRAY * pArray = NULL;
    VARIANT *pvProp = NULL;

    *pdwNumVariants = 0;
    *ppVarArray  = 0;

    //
    // It has to be a variant and a safearray. It might
    // also be a variant that is byref and safe array
    //
    //

    pvProp = &varSafeArray;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&varSafeArray);
    }

    if(!(((V_VT(pvProp) & VT_VARIANT)== VT_VARIANT)
         && V_ISARRAY(pvProp))) {
        //
        // We need to make this additional check. This is not really 
        // legal but it could be that just the tag at this level is wrong.
        // This was allowed in older versions of ADSI and therefore needs
        // on future versions (backward compatibility). 
        //
        if(!((V_VT(&varSafeArray) & VT_VARIANT) && V_ISARRAY(&varSafeArray)))
          RRETURN(E_FAIL);
    }

    if (V_VT(pvProp) == (VT_BYREF | VT_VARIANT | VT_ARRAY)) {
        //
        // in this case we need to use the ARRAY_REF.
        //
        pArray = *(V_ARRAYREF(pvProp));
    }
    else {
        //
        // pvProp will always have the correc info, byref or not.
        //
        pArray = V_ARRAY(pvProp);
    }

    //
    // Check that there is only one dimension in this array
    //
    if (pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (pArray->rgsabound[0].cElements == 0){
        RRETURN(S_OK);  // Return success and null array
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwNumVariants = dwSUBound - dwSLBound + 1;
    pVarArray = (PVARIANT)AllocADsMem(
                                sizeof(VARIANT)*dwNumVariants
                                );
    if (!pVarArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {

        VariantInit(pVarArray + i);
        hr = SafeArrayGetElement(pArray,
                                (long FAR *)&i,
                                (pVarArray + i)
                                );
        CONTINUE_ON_FAILURE(hr);
    }

    *ppVarArray = pVarArray;
    *pdwNumVariants = dwNumVariants;

error:

    RRETURN(hr);
}

//
// This method should go away.  ConvertSafeArrayToVariantArray does the job.
//
HRESULT
ConvertByRefSafeArrayToVariantArray(
    VARIANT varSafeArray,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    )
{
    RRETURN(ConvertSafeArrayToVariantArray(
        varSafeArray,
        ppVarArray,
        pdwNumVariants
        ));
}

//
// An LDAP query needs a NULL-terminated array of strings.
//
HRESULT
ConvertVariantArrayToLDAPStringArray(
    PVARIANT pVarArray,
    PWSTR **pppszStringArray,
    DWORD dwNumStrings
    )
{
    HRESULT hr = S_OK;
    PWSTR *ppszStringArray = NULL;
    DWORD i = 0;

    //
    // Start off with a zero-length array.
    //
    *pppszStringArray = NULL;

    //
    // The LDAP library expects an array terminated with a NULL string.
    // So make space for an extra one.
    //
    dwNumStrings++;

    ppszStringArray = (PWSTR *)AllocADsMem(dwNumStrings * sizeof(PWSTR));
    if (!ppszStringArray)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    for (i = 0; i < dwNumStrings - 1; i++)
    {
        if (!(V_VT(pVarArray + i) == VT_BSTR))
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);

        ppszStringArray[i] = AllocADsStr(V_BSTR(pVarArray + i));
        if (!ppszStringArray[i])
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // NULL-terminated for LDAP.
    //
    ppszStringArray[i] = NULL;

    *pppszStringArray = ppszStringArray;
    RRETURN(hr);

error:
    if (ppszStringArray)
    {
        for (DWORD j = 0; j < i; j++)
            if (ppszStringArray[i])
                FreeADsStr(ppszStringArray[i]);

        FreeADsMem(ppszStringArray);
    }
    RRETURN(hr);
}

HRESULT
VariantToBinary(
    PVARIANT pVarSrcObject,
    DWORD *pdwLength,
    BYTE  **ppByte
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    BYTE  *pByte = NULL;

    if( pVarSrcObject->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    pByte = (BYTE*)AllocADsMem( dwSUBound - dwSLBound + 1);
    if ( pByte == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    hr = SafeArrayAccessData( V_ARRAY(pVarSrcObject),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pByte,
            pArray,
            dwSUBound-dwSLBound+1);

    SafeArrayUnaccessData( V_ARRAY(pVarSrcObject) );

    *pdwLength = dwSUBound - dwSLBound + 1;
    *ppByte = pByte;

    RRETURN(hr);
error:
    if (pByte) {
        FreeADsMem(pByte);
    }
    RRETURN(hr);
}

HRESULT
BinaryToVariant(
    DWORD Length,
    BYTE* pByte,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = Length;
    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, pByte, aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(lpVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(lpVarDestObject) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    RRETURN(hr);
}

HRESULT
CopyOctetString(
    DWORD dwNumBytes,
    BYTE *pData,
    DWORD *pdwNumBytes,
    BYTE **ppByte
    )
{
    LPBYTE lpByteStream = NULL;
    HRESULT hr = S_OK;

    if (dwNumBytes) {
        lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);
        if (lpByteStream == NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        memcpy(
            lpByteStream,
            pData,
            dwNumBytes
            );

        *pdwNumBytes = dwNumBytes;
        *ppByte =  lpByteStream;
    }
    else {
        *pdwNumBytes = 0;
        *ppByte = NULL;
    }
error:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   RaiseException, public API
//
//  Synopsis:   Generic function for translating ADS HRESULT codes to an
//              OLE error object.
//
//  Arguments:  [hr] - The HRESULT code to be translated into
//                     an OLE error object.
//
//
//  Returns:    Nothing. This function is called when an error occurred.
//              There isn't much the caller can do if this function fails.
//
//  History:    10-Sep-97   t-rmak      Created.
//
//
//  Notes:      1) Only ADS error codes are properly translated to
//                 corresponding OLE error objects.
//              2) This function will ignore the lcid passed into
//                 ITypeInfo::Invoke and it always passes 0 as the langid
//                 to FormatMessage.
//              3) Only the source field and the description field of the
//                 error object will be filled by this function.
//              4) This function does not support inserts in the description
//                 string.
//
//-------------------------------------------------------------------------
void
RaiseException(HRESULT hr)
{

    DWORD            dwStrLen;
    LPTSTR           lpszMessage = NULL;
    ICreateErrorInfo *pICreateErrorInfo = NULL;
    IErrorInfo       *pIErrorInfo = NULL;
    HRESULT          localhr = S_OK;

    if (g_hActiveDs != NULL) {

        //
        // Clear any previously set error object
        //
        SetErrorInfo(0, NULL);

        //
        // Let FormatMessage allocate the message buffer.
        // In a multi-threaded environment, this is the simplest
        // solution.
        //
        dwStrLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM |
                                 // Ignore inserts for now.
                                 FORMAT_MESSAGE_IGNORE_INSERTS |
                                 FORMAT_MESSAGE_FROM_HMODULE,
                                 (LPCVOID) g_hActiveDs,
                                 hr,
                                 0,
                                 (LPTSTR) &lpszMessage,
                                 0,
                                 NULL);

        //
        // We may want to fail with a special error code if the specified
        // lcid is not supported.
        //
        if (dwStrLen == 0) {
            goto error;
        }

        //
        // We may want to add support for help file in the future.
        //
        localhr = CreateErrorInfo(&pICreateErrorInfo);

        BAIL_ON_FAILURE(localhr);

        //
        // Note that we don't care whether the following calls succeed since
        // there is nothing we can if they fail.
        //
        pICreateErrorInfo->SetDescription(lpszMessage);
        pICreateErrorInfo->SetSource(TEXT("Active Directory"));

        //
        // Set the threads error object.
        //
        pICreateErrorInfo->QueryInterface(IID_IErrorInfo, (void **)&pIErrorInfo);
        SetErrorInfo(0, pIErrorInfo);

    }

error:

    if (lpszMessage != NULL) {
        LocalFree(lpszMessage);
    }

    //
    // Release the error object's interface pointers
    //
    if (pIErrorInfo != NULL) {
        pIErrorInfo->Release();
    }

    if (pICreateErrorInfo != NULL) {
        pICreateErrorInfo->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\utils\fbstr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       fbstr.cxx
//
//  Contents:   Wrappers around BSTR api to account for wierdness with NULL
//
//  Functions:  ADsAllocString
//              ADsAllocStringLen
//              ADsReAllocString
//              ADsReAllocStringLen
//              ADsFreeString
//              ADsStringLen
//              ADsStringByteLen
//              ADsAllocStringByteLen
//              ADsStringCmp
//              ADsStringNCmp
//              ADsStringICmp
//              ADsStringNICmp
//
//  History:   25-Oct-94 krishnag
//
//
//----------------------------------------------------------------------------

#include "procs.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   ADsAllocString
//
//  Synopsis:   Allocs a BSTR and initializes it from a string.  If the
//              initializer is NULL or the empty string, the resulting bstr is
//              NULL.
//
//  Arguments:  [pch]   -- String to initialize BSTR.
//              [pBSTR] -- The result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR]
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsAllocString(const OLECHAR * pch, BSTR * pBSTR)
{
    HRESULT hr = S_OK;

    ADsAssert(pBSTR);
    if (!pch)
    {
        *pBSTR = NULL;
        return S_OK;
    }

    *pBSTR = SysAllocString(pch);
    hr = (*pBSTR) ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsAllocStringLen
//
//  Synopsis:   Allocs a BSTR of [uc] + 1 OLECHARS, and
//              initializes it from an optional string.  If [uc] == 0, the
//              resulting bstr is NULL.
//
//  Arguments:  [pch]   -- String to initialize.
//              [uc]    -- Count of characters of string.
//              [pBSTR] -- The result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsAllocStringLen(const OLECHAR * pch, UINT uc, BSTR * pBSTR)
{
    HRESULT hr = S_OK;

    ADsAssert(pBSTR);

    if (!pch){

        *pBSTR = NULL;
        return S_OK;

     }


    *pBSTR = SysAllocStringLen(pch, uc);
    hr =  *pBSTR ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsReAllocString
//
//  Synopsis:   Allocates a BSTR initialized from a string; if successful,
//              frees the original string and replaces it.
//
//  Arguments:  [pBSTR] -- String to reallocate.
//              [pch]   -- Initializer.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsReAllocString(BSTR * pBSTR, const OLECHAR * pch)
{
    ADsAssert(pBSTR);

#if DBG == 1
    HRESULT hr;
    BSTR    bstrTmp;

    hr = ADsAllocString(pch, &bstrTmp);
    if (hr)
        RRETURN(hr);

    ADsFreeString(*pBSTR);
    *pBSTR = bstrTmp;
    return S_OK;
#else

    if (!pch){

        SysFreeString(*pBSTR);
        *pBSTR = NULL;
        return S_OK;
     }


    return SysReAllocString(pBSTR, pch) ? S_OK : E_OUTOFMEMORY;
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsReAllocStringLen
//
//  Synopsis:   Allocates a BSTR of [uc] + 1 OLECHARs and optionally
//              initializes it from a string; if successful, frees the original
//              string and replaces it.
//
//  Arguments:  [pBSTR] -- String to reallocate.
//              [pch]   -- Initializer.
//              [uc]    -- Count of characters.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsReAllocStringLen(BSTR * pBSTR, const OLECHAR * pch, UINT uc)
{
    ADsAssert(pBSTR);

#if DBG == 1
    HRESULT hr;
    BSTR    bstrTmp;

    hr = ADsAllocStringLen(pch, uc, &bstrTmp);
    if (hr)
        RRETURN(hr);

    ADsFreeString(*pBSTR);
    *pBSTR = bstrTmp;
    return S_OK;
#else

    if (!pch){

        SysFreeString(*pBSTR);
        *pBSTR = NULL;
        return S_OK;
     }

    return SysReAllocStringLen(pBSTR, pch, uc) ? S_OK : E_OUTOFMEMORY;
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringLen
//
//  Synopsis:   Returns the length of the BSTR.
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI_(UINT)
ADsStringLen(BSTR bstr)
{
    return bstr ? SysStringLen(bstr) : 0;
}



#ifdef WIN32

//+---------------------------------------------------------------------------
//
//  Function:   ADsStringByteLen
//
//  Synopsis:   Returns the length of a BSTR in bytes.
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI_(UINT)
ADsStringByteLen(BSTR bstr)
{
    return bstr ? SysStringByteLen(bstr) : 0;
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsAllocStringByteLen
//
//  Synopsis:   Allocates a BSTR of [uc] + 1 chars and optionally initializes
//              from a string.  If [uc] = 0, the resulting bstr is NULL.
//
//  Arguments:  [pch]   -- Initializer.
//              [uc]    -- Count of chars.
//              [pBSTR] -- Result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsAllocStringByteLen(const char * pch, UINT uc, BSTR * pBSTR)
{
    HRESULT hr = S_OK;

    ADsAssert(pBSTR);

    if (!pch){

        *pBSTR = NULL;
        return S_OK;
     }


    *pBSTR = SysAllocStringByteLen(pch, uc);

    RRETURN(hr);
}
#endif



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringCmp
//
//  Synopsis:   As per wcscmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringCmp(CBSTR bstr1, CBSTR bstr2)
{
    return wcscmp(STRVAL(bstr1), STRVAL(bstr2));
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringNCmp
//
//  Synopsis:   As per wcsncmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringNCmp(CBSTR bstr1, CBSTR bstr2, size_t c)
{
    return wcsncmp(STRVAL(bstr1), STRVAL(bstr2), c);
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringICmp
//
//  Synopsis:   As per wcsicmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//              15-Aug-94 doncl   changed from wcsicmp to _wcsicmp
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringICmp(CBSTR bstr1, CBSTR bstr2)
{
    return _wcsicmp(STRVAL(bstr1), STRVAL(bstr2));
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringNICmp
//
//  Synopsis:   As per wcsnicmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//              15-Aug-94 doncl   changed from wcsnicmp to _wcsnicmp
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringNICmp(CBSTR bstr1, CBSTR bstr2, size_t c)
{
    return _wcsnicmp(STRVAL(bstr1), STRVAL(bstr2), c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\utils\date.cxx ===
#include "Procs.hxx"

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\


HRESULT
NTTimeFormattoDateFormat(
    LARGE_INTEGER *NTTimeFormat,
    DATE *DateFormat
    )
{
    *DateFormat = (DATE)0;
    RRETURN(S_OK);
}


HRESULT
ConvertDWORDtoDATE(
    DWORD dwDate,
    DATE * pdaDate,
    BOOL fIsGMT
    )
{

    FILETIME fileTime;
    SYSTEMTIME SystemTime, LocalTime;
    LARGE_INTEGER tmpTime;
    HRESULT hr = S_OK;    

    if (pdaDate) {
        memset(pdaDate, 0, sizeof(DATE));
    }

    memset(&fileTime, 0, sizeof(FILETIME));

    ::RtlSecondsSince1970ToTime(dwDate, &tmpTime );

    fileTime.dwLowDateTime = tmpTime.LowPart;
    fileTime.dwHighDateTime = tmpTime.HighPart;

    if(!fIsGMT)
    // OLE DB on NDS does not convert to local file time. We don't
    // convert here to be consistent.
        FileTimeToLocalFileTime(&fileTime, &fileTime);

    if (!FileTimeToSystemTime(&fileTime, &SystemTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (!SystemTimeToVariantTime(&SystemTime, pdaDate)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}


HRESULT
ConvertDATEtoDWORD(
    DATE daDate,
    DWORD *pdwDate,
    BOOL fIsGMT
    )
{

    FILETIME fileTime;
    LARGE_INTEGER tmpTime;
    HRESULT hr = S_OK;
    SYSTEMTIME systemTime;

    if (!VariantTimeToSystemTime(daDate, &systemTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (!SystemTimeToFileTime(&systemTime, &fileTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if(!fIsGMT)
    // OLE DB on NDS does not convert to local file time. We don't
    // convert here to be consistent.
        LocalFileTimeToFileTime(&fileTime, &fileTime);

    tmpTime.LowPart = fileTime.dwLowDateTime;
    tmpTime.HighPart = fileTime.dwHighDateTime;


    ::RtlTimeToSecondsSince1970(&tmpTime, (ULONG *)pdwDate);

error:
    RRETURN(hr);

}


HRESULT
ConvertDATEToDWORD(
    DATE  daDate,
    DWORD *pdwDate
    )
{
    RRETURN(S_OK);
}

HRESULT
ConvertSystemTimeToDATE(
    SYSTEMTIME Time,
    DATE *     pdaTime
    )
{
    FILETIME ft;
    BOOL fRetval = FALSE;
    USHORT wDosDate;
    USHORT wDosTime;
    SYSTEMTIME LocalTime;

    //
    // Get Time-zone specific local time.
    //

    fRetval = SystemTimeToTzSpecificLocalTime(
                  NULL,
                  &Time,
                  &LocalTime
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // System Time To File Time.
    //

    fRetval = SystemTimeToFileTime(&LocalTime,
                                   &ft);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // File Time to DosDateTime.
    //

    fRetval = FileTimeToDosDateTime(&ft,
                                    &wDosDate,
                                    &wDosTime);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // DosDateTime to VariantTime.
    //

    fRetval = DosDateTimeToVariantTime(wDosDate,
                                       wDosTime,
                                       pdaTime );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    RRETURN(S_OK);
}


HRESULT
ConvertDWORDToDATE(
    DWORD    dwTime,
    DATE *     pdaTime
    )

{
    RRETURN(S_OK);
}

HRESULT
ConvertDATEToSYSTEMTIME(
    DATE  daDate,
    SYSTEMTIME *pSysTime
    )
{
    HRESULT hr;
    FILETIME ft;
    FILETIME lft; //local file time
    BOOL fRetval = FALSE;
    SYSTEMTIME LocalTime;
    USHORT wDosDate;
    USHORT wDosTime;

    fRetval = VariantTimeToDosDateTime(daDate,
                                       &wDosDate,
                                       &wDosTime );

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    fRetval = DosDateTimeToFileTime(wDosDate,
                                    wDosTime,
                                    &lft);



    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    //
    // convert local file time to filetime
    //

    fRetval = LocalFileTimeToFileTime(&lft,
                                      &ft );

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    fRetval = FileTimeToSystemTime(&ft,
                                   pSysTime );


    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\utils\misc.cxx ===
//+---------------------------------------------------------------------
//
//  File:       misc.cxx
//
//  Contents:   Useful OLE helper and debugging functions
//
//----------------------------------------------------------------------

#include "procs.hxx"

//+------------------------------------------------------------------------
//
//  Function:   GetLastWin32Error
//
//  Synopsis:   Returns the last Win32 error, converted to an HRESULT.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
GetLastWin32Error( )
{
    return HRESULT_FROM_WIN32(GetLastError());
}



#if DBG == 1

//+---------------------------------------------------------------
//
//  Function:   TraceIID
//
//  Synopsis:   Outputs the name of the interface to the debugging device
//
//  Arguments:  [riid] -- the interface
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

STDAPI_(void)
PrintIID(DWORD dwFlags, REFIID riid)
{
    LPWSTR lpstr = NULL;

#define CASE_IID(iid)  \
        if (IsEqualIID(IID_##iid, riid)) lpstr = (LPWSTR)L#iid;

    CASE_IID(IUnknown)
    CASE_IID(IOleLink)
    CASE_IID(IOleCache)
    CASE_IID(IOleManager)
    CASE_IID(IOlePresObj)
    CASE_IID(IDebug)
    CASE_IID(IDebugStream)
    CASE_IID(IAdviseSink2)
    CASE_IID(IDataObject)
    CASE_IID(IViewObject)
    CASE_IID(IOleObject)
    CASE_IID(IOleInPlaceObject)
    CASE_IID(IParseDisplayName)
    CASE_IID(IOleContainer)
    CASE_IID(IOleItemContainer)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleInPlaceSite)
    CASE_IID(IPersist)
    CASE_IID(IPersistStorage)
    CASE_IID(IPersistFile)
    CASE_IID(IPersistStream)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleInPlaceSite)
    CASE_IID(IAdviseSink)
    CASE_IID(IDataAdviseHolder)
    CASE_IID(IOleAdviseHolder)
    CASE_IID(IClassFactory)
    CASE_IID(IOleWindow)
    CASE_IID(IOleInPlaceActiveObject)
    CASE_IID(IOleInPlaceUIWindow)
    CASE_IID(IOleInPlaceFrame)
    CASE_IID(IDropSource)
    CASE_IID(IDropTarget)
    CASE_IID(IBindCtx)
    CASE_IID(IEnumUnknown)
    CASE_IID(IEnumString)
    CASE_IID(IEnumFORMATETC)
    CASE_IID(IEnumSTATDATA)
    CASE_IID(IEnumOLEVERB)
    CASE_IID(IEnumMoniker)
    CASE_IID(IEnumGeneric)
    CASE_IID(IEnumHolder)
    CASE_IID(IEnumCallback)
    CASE_IID(ILockBytes)
    CASE_IID(IStorage)
    CASE_IID(IStream)
    CASE_IID(IDispatch)
    CASE_IID(IMarshal)
    //CASE_IID(IEnumVARIANT)
    //CASE_IID(ITypeInfo)
    //CASE_IID(ITypeLib)
    //CASE_IID(ITypeComp)
    //CASE_IID(ICreateTypeInfo)
    //CASE_IID(ICreateTypeLib)

#undef CASE_IID

    if (lpstr == NULL)
    {
        WCHAR chBuf[256];
        StringFromGUID2(riid, chBuf, 256);

        ADsDebugOut((dwFlags | DEB_NOCOMPNAME,
                       "UNKNOWN ITF %ws", chBuf));
    }
    else
        ADsDebugOut((dwFlags | DEB_NOCOMPNAME, "%ws", lpstr));
}

#endif  // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\utils\cenum.cxx ===
//+------------------------------------------------------------------------
//
//  File:       cenum.cxx
//
//  Contents:   Generic enumerator class.
//
//  Classes:    CBaseEnum
//              CEnumGeneric
//              CEnumVARIANT
//
//  History:    05-05-93    ChrisZ      Added class object caching
//              05-11-93    ChrisZ      Cleanup on CF caching
//              02-24-93    LyleC       Moved from ADs directory
//              01-Sep-93   DonCl       new (NullOnFail)
//              08-Sep-93   LyleC       Changed Next() to accept NULL 3rd param
//              15-May-94   adams       Added CBaseEnum, CEnumVARIANT
//
//-------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop

// Determines whether a variant is a base type.
#define ISBASEVARTYPE(vt) ((vt & ~VT_TYPEMASK) == 0)

//+------------------------------------------------------------------------
//
//  CBaseEnum Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Init
//
//  Synopsis:   2nd stage initialization perADs copy of array if necessary.
//
//  Arguments:  [pary]    -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//  Modifies:   [this].
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CBaseEnum::Init(CADsAry * pary, BOOL fCopy)
{
    HRESULT     hr          = S_OK;
    CADsAry * paryCopy    = NULL;     // copied array

    ADsAssert(pary);

    // Copy array if necessary.
    if (fCopy)
    {
        paryCopy = new CADsAry;
        if (!paryCopy)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = paryCopy->Copy(_cb, *pary, _fAddRef);
        if (hr)
            goto Error;

        pary = paryCopy;
    }

    _pary = pary;

Cleanup:
    RRETURN(hr);

Error:
    delete paryCopy;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- addref enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::CBaseEnum(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete)
{
    _ulRefs     = 1;

    _cb         = cb;
    _pary       = NULL;
    _piid       = &iid;
    _i          = 0;
    _fAddRef    = fAddRef;
    _fDelete    = fDelete;

    INC_OBJECT_COUNT();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::CBaseEnum(const CBaseEnum& benum)
{
    _ulRefs     = 1;

    _cb         = benum._cb;
    _piid       = benum._piid;
    _pary       = benum._pary;
    _i          = benum._i;
    _fAddRef    = benum._fAddRef;
    _fDelete    = benum._fDelete;

    INC_OBJECT_COUNT();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::~CBaseEnum
//
//  Synopsis:   Destructor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::~CBaseEnum(void)
{
    IUnknown ** ppUnk;
    int         i;

    if (_pary && _fDelete)
    {
        if (_fAddRef)
        {
            for (i = 0, ppUnk = (IUnknown **) Deref(0);
                 i < _pary->Size();
                 i++, ppUnk++)
            {
                (*ppUnk)->Release();
            }
        }

        delete _pary;
    }

    DEC_OBJECT_COUNT();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::QueryInterface
//
//  Synopsis:   Per IUnknown::QueryInterface.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, *_piid))
    {
        AddRef();
        *ppv = this;
        return NOERROR;
    }

    return E_NOTIMPL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Skip
//
//  Synopsis:   Per IEnum*
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::Skip(ULONG celt)
{
    int c = min((int) celt, _pary->Size() - _i);
    _i += c;

    return ((c == (int) celt) ? NOERROR : S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Reset
//
//  Synopsis:   Per IEnum*
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::Reset(void)
{
    _i = 0;

    return NOERROR;
}



//+------------------------------------------------------------------------
//
//  CEnumGeneric Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumGeneric::Create(
        size_t          cb,
        CADsAry *     pary,
        REFIID          iid,
        BOOL            fAddRef,
        BOOL            fCopy,
        BOOL            fDelete,
        CEnumGeneric ** ppenum)
{
    HRESULT         hr      = S_OK;
    CEnumGeneric *  penum;

    ADsAssert(pary);
    ADsAssert(ppenum);
    ADsAssert(!fCopy || fDelete);
    *ppenum = NULL;
    penum = new CEnumGeneric(cb, iid, fAddRef, fDelete);
    if (!penum)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = penum->Init(pary, fCopy);
    if (hr)
        goto Error;

    *ppenum = penum;

Cleanup:
    RRETURN(hr);

Error:
    penum->Release();
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this].
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumGeneric::CEnumGeneric(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete) :
        CBaseEnum(cb, iid, fAddRef, fDelete)
{
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumGeneric::CEnumGeneric(const CEnumGeneric& enumg) : CBaseEnum(enumg)
{
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumGeneric::Next(ULONG celt, void * reelt, ULONG * pceltFetched)
{
    int         c;
    int         i;
    IUnknown ** ppUnk;

    c = min((int) celt, _pary->Size() - _i);
    if (c > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    if (_fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) Deref(_i); i < c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }
    memcpy(reelt, (BYTE *) Deref(_i), c * _cb);
    if (pceltFetched)
    {
        *pceltFetched = c;
    }
    _i += c;

    return ((c == (int) celt) ? NOERROR : S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumGeneric::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = _pary->EnumElements(_cb, *_piid, (void **) ppenum, _fAddRef);
    if (hr)
        RRETURN(hr);

    (**(CEnumGeneric **)ppenum)._i = _i;
    return S_OK;
}



//+------------------------------------------------------------------------
//
//  CEnumVARIANT Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [vt]      -- Type of elements enumerated.
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumVARIANT::Create(
        size_t          cb,
        CADsAry *     pary,
        VARTYPE         vt,
        BOOL            fCopy,
        BOOL            fDelete,
        IEnumVARIANT ** ppenum)
{
    HRESULT         hr          = S_OK;
    CEnumVARIANT *  penum;              // enumerator to return.

    ADsAssert(pary);
    ADsAssert(ppenum);
    ADsAssert(ISBASEVARTYPE(vt));
    *ppenum = NULL;
    penum = new CEnumVARIANT(cb, vt, fDelete);
    if (!*ppenum)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = penum->Init(pary, fCopy);
    if (hr)
        goto Error;

    *ppenum = (IEnumVARIANT *) (void *) penum;

Cleanup:
    RRETURN(hr);

Error:
    penum->Release();
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  Arguments:  [vt]      -- Type of elements enumerated.
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumVARIANT::CEnumVARIANT(size_t cb, VARTYPE vt, BOOL fDelete) :
        CBaseEnum(cb, IID_IEnumVARIANT, vt == VT_UNKNOWN || vt == VT_DISPATCH, fDelete)
{
    ADsAssert(ISBASEVARTYPE(vt));
    _vt         = vt;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumVARIANT::CEnumVARIANT(const CEnumVARIANT& enumv) : CBaseEnum(enumv)
{
    _vt     = enumv._vt;
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumVARIANT::Next(ULONG celt, void * reelt, ULONG * pceltFetched)
{
    int         c;
    int         i;
    BYTE *      pb;
    VARIANT *   pvar;

    c = min((int) celt, _pary->Size() - _i);
    if (c > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    for (i = 0, pb = (BYTE *) Deref(_i), pvar = (VARIANT *) reelt;
         i < c;
         i++, pb += _cb, pvar++)
    {
        V_VT(pvar) = _vt;
        switch (_vt)
        {
        case VT_I2:
            ADsAssert(sizeof(V_I2(pvar)) == _cb);
            V_I2(pvar) = *(short *) pb;
            break;

        case VT_I4:
            ADsAssert(sizeof(V_I4(pvar)) == _cb);
            V_I4(pvar) = *(long *) pb;
            break;

        case VT_BOOL:
            ADsAssert(sizeof(V_BOOL(pvar)) == _cb);
            V_BOOL(pvar) = (short) -*(int *) pb;
            break;

        case VT_BSTR:
            ADsAssert(sizeof(V_BSTR(pvar)) == _cb);
            V_BSTR(pvar) = *(BSTR *) pb;
            break;

        case VT_UNKNOWN:
        case VT_DISPATCH:
            ADsAssert(sizeof(V_UNKNOWN(pvar)) == _cb);
            V_UNKNOWN(pvar) = *(IUnknown **) pb;
            V_UNKNOWN(pvar)->AddRef();
            break;

        default:
            ADsAssert(0 && "Unknown VARTYPE in IEnumVARIANT::Next");
            break;
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = c;
    }

    _i += c;
    return ((c == (int) celt) ? NOERROR : S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CEnumVARIANT::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = _pary->EnumVARIANT(_cb, _vt, (IEnumVARIANT **)ppenum);
    if (hr)
        RRETURN(hr);

    (**(CEnumVARIANT **)ppenum)._i = _i;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\utils\netolary.cxx ===
//+------------------------------------------------------------------------
//
//  File:   netolary.cxx
//
//  Contents:   Generic dynamic array class
//
//  Classes:    CADsAry
//
//  History:
//
//-------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop

//  CADsAry class





//+------------------------------------------------------------------------
//
//  Member: CADsAry::~CADsAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//-------------------------------------------------------------------------
CADsAry::~CADsAry( )
{
    if (_pv)
        LocalFree(_pv);
}


//+------------------------------------------------------------------------
//
//  Member: CADsAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  [cb]    Element size
//              [c]     New allocated size for the array.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::EnsureSize(size_t cb, int c)
{
    void *  pv;

    if (c <= GetAlloced(cb))
        return NOERROR;

    //  CONSIDER should we use a more sophisticated array-growing
    //    algorithm?
    c = ((c - 1) & -8) + 8;
    ADsAssert(c > 0);
    if (!_pv)
    {
        pv = LocalAlloc(LMEM_FIXED, c * cb);
    }
    else
    {
        pv = LocalReAlloc(_pv, c * cb, LMEM_MOVEABLE);
    }

    if (!pv)
        RRETURN(E_OUTOFMEMORY);

    _pv = pv;
    return NOERROR;
}



#if 0
//+------------------------------------------------------------------------
//
//  Member: CADsAry::Append
//
//  Synopsis:   Appends the given pointer to the end of the array, incrementing
//      the array's logical size, and growing its allocated size if
//      necessary. This method should only be called for arrays of
//      pointers; AppendIndirect should be used for arrays of
//      non-pointers.
//
//  Arguments:  [pv]        Pointer to append.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::Append(void * pv)
{
    HRESULT hr;

    ADsAssert(_cb == 4);

    hr = EnsureSize(_c + 1);
    if (hr)
        RRETURN(hr);

    * (void **) Deref(_c) = pv;
    _c++;

    return NOERROR;
}
#endif


//+------------------------------------------------------------------------
//
//  Member: CADsAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array, incrementing
//      the array's logical size, and growing the array's allocated
//      size if necessary.  Note that the element is passed with a
//      pointer, rather than directly.
//
//  Arguments:  [cb]        --  Element size
//              [pv]        --  Pointer to the element to be appended
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::AppendIndirect(size_t cb, void * pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    memcpy(Deref(cb, _c), pv, cb);
    _c++;

    return NOERROR;
}



//+------------------------------------------------------------------------
//
//  Member: CADsAry::Delete
//
//  Synopsis:   Removes the i'th element of the array, shuffling all elements
//      that follow one slot towards the beginning of the array.
//
//  Arguments:  [cb]    Element size
//              [i]     Element to delete
//
//-------------------------------------------------------------------------
void
CADsAry::Delete(size_t cb, int i)
{
    ADsAssert(i >= 0);
    ADsAssert(i < _c);

    memmove(((BYTE *) _pv) + (i * cb),
            ((BYTE *) _pv) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    _c--;
}


//+------------------------------------------------------------------------
//
//  Member: CADsAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//-------------------------------------------------------------------------
void
CADsAry::DeleteAll(void)
{
    if (_pv)
        LocalFree(_pv);

    _pv = NULL;
    _c = 0;
}


#if 0
//+------------------------------------------------------------------------
//
//  Member: CADsAry::Insert
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.
//      This method should only be called for arrays of
//      pointers; InsertIndirect should be used for arrays of
//      non-pointers.
//
//
//  Arguments:  [i]     Index to insert...
//              [pv]        ...this pointer at
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::Insert(int i, void * pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    memmove(((BYTE *) _pv) + ((i + 1) * _cb),
            ((BYTE *) _pv) + (i * _cb),
            (_c - i ) * _cb);

    ((void **) _pv)[i] = pv;
    _c++;
    return NOERROR;
}
#endif


//+------------------------------------------------------------------------
//
//  Member: CADsAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  [cb]    Element size
//              [i]     Index to insert...
//              [pv]        ...this pointer at
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    memmove(((BYTE *) _pv) + ((i + 1) * cb),
            ((BYTE *) _pv) + (i * cb),
            (_c - i ) * cb);

    memcpy(Deref(cb, i), pv, cb);
    _c++;
    return NOERROR;

}

//+------------------------------------------------------------------------
//
//  Member: CADsAry::BringToFront
//
//  Synopsis:   Moves the i'th element to the front of the array, shuffling
//              intervening elements to make room.
//
//  Arguments:  [i]
//
//-------------------------------------------------------------------------
void
CADsAry::BringToFront(size_t cb, int i)
{
    BYTE    rgb[CADsAry_MAXELEMSIZE];

    ADsAssert(cb <= CADsAry_MAXELEMSIZE);

    memcpy(rgb, ((BYTE *) _pv) + (i * cb), cb);
    memmove(((BYTE *) _pv) + cb, _pv, i * cb);
    memcpy(_pv, rgb, cb);
}



//+------------------------------------------------------------------------
//
//  Member: CADsAry::SendToBack
//
//  Synopsis:   Moves the i'th element to the back of the array (that is,
//      the largest index less than the logical size.) Any intervening
//      elements are shuffled out of the way.
//
//  Arguments:  [i]
//
//-------------------------------------------------------------------------
void
CADsAry::SendToBack(size_t cb, int i)
{
    BYTE    rgb[CADsAry_MAXELEMSIZE];

    ADsAssert(cb <= CADsAry_MAXELEMSIZE);

    memcpy(rgb, ((BYTE *) _pv) + (i * cb), cb);
    memmove(((BYTE *) _pv) + (i * cb),
            ((BYTE *) _pv) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    memcpy(((BYTE *) _pv) + ((_c - 1) * cb), rgb, cb);
}



#if 0
//+------------------------------------------------------------------------
//
//  Member: CADsAry::Find
//
//  Synopsis:   Returns the index at which the given pointer is found, or -1
//      if it is not found. The pointer values are compared directly;
//      there is no compare function.
//
//  Arguments:  [pv]        Pointer to find
//
//  Returns:    int; index of pointer, or -1 if not found
//
//-------------------------------------------------------------------------
int
CADsAry::Find(void * pv)
{
    int     i;
    void ** ppv;

    Assert(_cb == 4);

    for (i = 0, ppv = (void **) _pv; i < _c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CADsAry::Copy
//
//  Synopsis:   Creates a copy from another CADsAry object.
//
//  Arguments:  [ary]     -- Object to copy.
//              [fAddRef] -- Addref the elements on copy?
//
//  Returns:    HRESULT.
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CADsAry::Copy(size_t cb, const CADsAry& ary, BOOL fAddRef)
{
    int         cbArray;                // size of array
    IUnknown ** ppUnk;                  // elem to addref
    int         i;                      // counter

    // avoid copy of self
    if (this == &ary)
        return S_OK;

    DeleteAll();
    if (ary._pv)
    {
        cbArray = ary._c * cb;
        _pv = LocalAlloc(LMEM_FIXED, cbArray);
        if (!_pv)
            RRETURN(E_OUTOFMEMORY);

        memcpy(_pv, ary._pv, cbArray);
    }

    _c          = ary._c;

    if (fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) _pv; i < _c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CADsAry::EnumElements
//
//  Synopsis:   Creates and returns an enumerator for the elements of the
//              array.
//
//  Arguments:  [iid]     --    Type of the enumerator.
//              [ppv]     --    Location to put enumerator.
//              [fAddRef] --    AddRef enumerated elements?
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CADsAry::EnumElements(
        size_t  cb,
        REFIID  iid,
        void ** ppv,
        BOOL    fAddRef,
        BOOL    fCopy,
        BOOL    fDelete)
{
    HRESULT hr;

    ADsAssert(ppv);
    hr = CEnumGeneric::Create(
            cb,
            this,
            iid,
            fAddRef,
            fCopy,
            fDelete,
            (CEnumGeneric **)ppv);
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CADsAry::EnumElements
//
//  Synopsis:   Creates and returns an IEnumVARIANT enumerator for the elements
//              of the array.
//
//  Arguments:  [vt]      --    Type of elements enumerated.
//              [ppv]     --    Location to put enumerator.
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CADsAry::EnumVARIANT(
        size_t          cb,
        VARTYPE         vt,
        IEnumVARIANT ** ppenum,
        BOOL            fCopy,
        BOOL            fDelete)
{
    HRESULT hr;

    ADsAssert(ppenum);
    hr = CEnumVARIANT::Create(cb, this, vt, fCopy, fDelete, ppenum);
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member: CADsAry::Deref
//
//  Synopsis:   Returns a pointer to the i'th element of the array. This
//              method is normally called by type-safe methods in derived
//              classes.
//
//  Arguments:  [i]
//
//  Returns:    void *
//
//  BUGBUG:     This function should be inline; however, since nothing is
//              inlined in debug builds, it requires an export, which
//              then doesn't apply in retail builds and breaks the retail
//              build.  Near ship time, the def file will be fixed handle
//              inlining.
//
//-------------------------------------------------------------------------

void *
CADsAry::Deref(size_t cb, int i)
{
    ADsAssert(i >= 0);
    ADsAssert(i < GetAlloced(cb));

    return ((BYTE *) _pv) + i * cb;
};





HRESULT
CADsPtrAry::EnsureSize(int c)
{
    return CADsAry::EnsureSize(sizeof(LPVOID), c);
}



HRESULT
CADsPtrAry::Append(void * pv)
{
    return CADsAry::AppendIndirect(sizeof(void *), &pv);
}


HRESULT
CADsPtrAry::Insert(int i, void * pv)
{
    return CADsAry::InsertIndirect(sizeof(void *), i, &pv);
}


int
CADsPtrAry::Find(void * pv)
{
    int     i;
    void ** ppv;

    for (i = 0, ppv = (void **) _pv; i < _c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
}


void
CADsPtrAry::Delete(int i)
{
    CADsAry::Delete(sizeof(void *), i);
}


void
CADsPtrAry::BringToFront(int i)
{
    CADsAry::BringToFront(sizeof(void *), i);
}


void
CADsPtrAry::SendToBack(int i)
{
    CADsAry::SendToBack(sizeof(void *), i);
}


HRESULT
CADsPtrAry::Copy(const CADsAry& ary, BOOL fAddRef)
{
    return CADsAry::Copy(sizeof(void *), ary, fAddRef);
}


HRESULT
CADsPtrAry::EnumElements(
        REFIID iid,
        void ** ppv,
        BOOL fAddRef,
        BOOL fCopy,
        BOOL fDelete)
{
    return CADsAry::EnumElements(
            sizeof(void *),
            iid,
            ppv,
            fAddRef,
            fCopy,
            fDelete);
}


HRESULT
CADsPtrAry::EnumVARIANT(
        VARTYPE vt,
        IEnumVARIANT ** ppenum,
        BOOL fCopy,
        BOOL fDelete)
{
    return CADsAry::EnumVARIANT(
            sizeof(void *),
            vt,
            ppenum,
            fCopy,
            fDelete);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\utils\pack.cxx ===
#include "procs.hxx"
#pragma hdrstop
#include "macro.h"

HRESULT
PackStringinVariant(
    BSTR bstrString,
    VARIANT * pvarInputData
    )
{
    HRESULT hr = S_OK;

    if ( bstrString == NULL )
        RRETURN(E_FAIL);

    VariantInit(pvarInputData);

    pvarInputData->vt = VT_BSTR;

    if (!bstrString) {
        V_BSTR(pvarInputData) = NULL;
        RRETURN(S_OK);
    }

    hr = ADsAllocString(bstrString, &(V_BSTR(pvarInputData)));

    RRETURN(hr);
}


HRESULT
UnpackStringfromVariant(
    VARIANT varSrcData,
    BSTR * pbstrDestString
    )
{
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_BSTR){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!V_BSTR(&varSrcData)) {
        *pbstrDestString = NULL;
        RRETURN(S_OK);
    }

    hr = ADsAllocString(V_BSTR(&varSrcData), pbstrDestString);

    RRETURN(hr);
}


HRESULT
PackLONGinVariant(
    LONG  lValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_I4;
    V_I4(pvarInputData) = lValue;

    RRETURN(S_OK);
}

HRESULT
UnpackLONGfromVariant(
    VARIANT varSrcData,
    LONG * plValue
    )
{
    if( varSrcData.vt != VT_I4){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *plValue = V_I4(&varSrcData);

    RRETURN(S_OK);
}


HRESULT
PackDATEinVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_DATE;
    V_DATE(pvarInputData) = daValue;

    RRETURN(S_OK);
}

HRESULT
UnpackDATEfromVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    )
{
    if( varSrcData.vt != VT_DATE){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdaValue = V_DATE(&varSrcData);

    RRETURN(S_OK);
}



HRESULT
PackFILETIMEinVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    )
{
    IADsLargeInteger *pTime = NULL;
    VARIANT var;
    SYSTEMTIME systemtime;
    FILETIME filetime;
    HRESULT hr = S_OK;

    if (VariantTimeToSystemTime(daValue,
                                &systemtime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    if (SystemTimeToFileTime(&systemtime,
                             &filetime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (LocalFileTimeToFileTime(&filetime, &filetime ) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = CoCreateInstance(
                CLSID_LargeInteger,
                NULL,
                CLSCTX_ALL,
                IID_IADsLargeInteger,
                (void**)&pTime
                );
    BAIL_ON_FAILURE(hr);

    hr = pTime->put_HighPart(filetime.dwHighDateTime);
    BAIL_ON_FAILURE(hr);
    hr = pTime->put_LowPart(filetime.dwLowDateTime);
    BAIL_ON_FAILURE(hr);

    VariantInit(pvarInputData);
    pvarInputData->pdispVal = pTime;
    pvarInputData->vt = VT_DISPATCH;

error:
    return hr;
}

HRESULT
UnpackFILETIMEfromVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    )
{
    IADsLargeInteger *pLarge = NULL;
    IDispatch *pDispatch = NULL;
    FILETIME filetime;
    FILETIME locFiletime;
    SYSTEMTIME systemtime;
    DATE date;
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_DISPATCH){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    pDispatch = varSrcData.pdispVal;
    hr = pDispatch->QueryInterface(IID_IADsLargeInteger, (VOID **) &pLarge);
    BAIL_ON_FAILURE(hr);

    hr = pLarge->get_HighPart((long*)&filetime.dwHighDateTime);
    BAIL_ON_FAILURE(hr);

    hr = pLarge->get_LowPart((long*)&filetime.dwLowDateTime);
    BAIL_ON_FAILURE(hr);

    if (FileTimeToLocalFileTime(&filetime, &locFiletime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (FileTimeToSystemTime(&locFiletime,
                             &systemtime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (SystemTimeToVariantTime(&systemtime,
                                &date) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    *pdaValue = date;
error:
    return hr;
}

HRESULT
PackVARIANT_BOOLinVariant(
    VARIANT_BOOL  fValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_BOOL;
    V_BOOL(pvarInputData) = fValue;

    RRETURN(S_OK);
}

HRESULT
UnpackVARIANT_BOOLfromVariant(
    VARIANT varSrcData,
    VARIANT_BOOL * pfValue
    )
{
    if( varSrcData.vt != VT_BOOL){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pfValue = V_BOOL(&varSrcData);

    RRETURN(S_OK);
}


HRESULT
PackVARIANTinVariant(
    VARIANT vaValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_VARIANT;
    RRETURN( VariantCopy( pvarInputData, &vaValue ));
}

HRESULT
UnpackVARIANTfromVariant(
    VARIANT varSrcData,
    VARIANT * pvaValue
    )
{
    VariantInit( pvaValue );

    RRETURN( VariantCopy( pvaValue, &varSrcData ));
}


HRESULT
PackDATEinLONGVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    )
{
    LONG lValue;
    HRESULT hr = S_OK;
    SYSTEMTIME stSystemTime;
    SYSTEMTIME LocalTime;
    FILETIME LocalFileTime;
    FILETIME FileTimeCurrent;
    DATE       date ;
    BOOL       fRetval;

    VariantInit(pvarInputData);

    if( hr = ConvertDATEToSYSTEMTIME(daValue,
                                &LocalTime)
      ) {
        RRETURN( hr );
    }

    fRetval = SystemTimeToFileTime(&LocalTime,
                         &LocalFileTime);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    fRetval = LocalFileTimeToFileTime(
                  &LocalFileTime,
                  &FileTimeCurrent
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    fRetval = FileTimeToSystemTime(&FileTimeCurrent,
                         &stSystemTime);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }
    lValue = stSystemTime.wHour * 60 + stSystemTime.wMinute;

    pvarInputData->vt = VT_I4;
    V_I4(pvarInputData) = lValue;

    RRETURN(S_OK);
}

HRESULT
UnpackDATEfromLONGVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    )
{
    LONG lValue;
    SYSTEMTIME stSystemTime;
    SYSTEMTIME LocalTime;
    DATE       date ;
    BOOL       fRetval;
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_I4){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    lValue = V_I4(&varSrcData);

    GetSystemTime( &stSystemTime);


    stSystemTime.wHour = (WORD)(lValue)/60;
    stSystemTime.wMinute = (WORD)(lValue)%60;
    stSystemTime.wSecond =0;
    stSystemTime.wMilliseconds = 0;

    fRetval = SystemTimeToTzSpecificLocalTime(
                  NULL,
                  &stSystemTime,
                  &LocalTime
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    hr = ConvertSystemTimeToDATE (LocalTime,
                                  pdaValue);

    //lpVarDestObject->date = date - (DWORD)date;
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\utils\stdfact.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stdfact.cxx
//
//  Contents:   Standard IClassFactory implementation
//
//  Classes:    StdClassFactory
//              CDynamicCF
//
//  History:    6-21-94   adams   added CDynamicCF
//              19-Jul-94 doncl   init StdClassFactory::_ulRefs to 1
//
//----------------------------------------------------------------------

#include "procs.hxx"

//+------------------------------------------------------------------------
//
//  StdClassFactory Implementation
//
//-------------------------------------------------------------------------


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::AddRef, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
StdClassFactory::AddRef(void)
{
    ADsAssert(_ulRefs);

    if (_ulRefs == 1)
        INC_OBJECT_COUNT();

    return ++_ulRefs;
}


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::Release, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
StdClassFactory::Release(void)
{
    ADsAssert(_ulRefs > 1);

    if (--_ulRefs == 1)
        DEC_OBJECT_COUNT();

    return _ulRefs;
}

//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::LockServer, public
//
//  Synopsis:   Method of IClassFactory interface
//
//  Notes:      Since class factories based on this class are global static
//              objects, this method doesn't serve much purpose.
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::LockServer (BOOL fLock)
{
    if (fLock)
        INC_OBJECT_COUNT();
    else
        DEC_OBJECT_COUNT();
    return NOERROR;
}

#ifdef DOCGEN
//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::CreateInstance, public
//
//  Synopsis:   Manufactures an instance of the class
//
//  Notes:      This pure virtual function must be overridden by the
//              inheriting class because the base class does not know what
//              class to instantiate.
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
        REFIID iid,
        LPVOID FAR* ppv) {};

//REVIEW: how to enforce ref counting of Class factory in object
// constructor/destructor?  Can we do this in a conjunction of StdUnknown
// with StdClassFactory.
#endif  // DOCGEN


//+------------------------------------------------------------------------
//
//  CDynamicCF Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CDynamicCF::CDynamicCF
//
//  Synopsis:   Constructor.
//
//  History:    7-20-94   adams   Created
//
//----------------------------------------------------------------------------

CDynamicCF::CDynamicCF(void)
{
    _ulRefs = 1;

    INC_OBJECT_COUNT();
}



//+---------------------------------------------------------------------------
//
//  Member:     CDynamicCF::~CDynamicCF
//
//  Synopsis:   Destructor.
//
//  History:    7-20-94   adams   Created
//
//----------------------------------------------------------------------------

CDynamicCF::~CDynamicCF(void)
{
    DEC_OBJECT_COUNT();
}



//+---------------------------------------------------------------
//
//  Member:     CDynamicCF::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
CDynamicCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CDynamicCF::LockServer, public
//
//  Synopsis:   Since these class factories are on the heap, we have
//              to implement this properly.  In our case, LockServer is
//              equivalent to AddRef/Release because we don't have a single
//              'application' object that we can put an external lock on.
//              Each time CreateInstance is called, we return a newly created
//              object.  If, instead, we returned a pointer to an existing
//              object, we would need to call CoLockObjectExternal on that
//              global object in the implementation of LockServer to keep it
//              alive.
//
//----------------------------------------------------------------

STDMETHODIMP
CDynamicCF::LockServer (BOOL fLock)
{
    if (fLock)
    {
        _ulRefs++;
    }
    else
    {
        _ulRefs--;
        Assert(_ulRefs != 0 && "Improper use of IClassFactory::LockServer!");
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\utils\registry.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       registry.cxx
//
//  Contents:   Registry utilities
//
//  Classes:
//
//  Functions:
//
//  History:    23-May-1996  RamV (Ram Viswanathan) Created
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   SetKeyAndValue
//
//  Synopsis:   Used for setting a key value
//
//
//  Arguments:  pszRegLocation: where to look for/create key
//              pszKey :   name of the Key
//              pszSubKey: name of the subkey
//              pszValue : Value to set
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    5/21/1996  RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
SetKeyAndValue(
    LPTSTR pszRegLocation,
    LPTSTR pszKey,
    LPTSTR pszSubKey,
    LPTSTR pszValue
    )

{

    HKEY        hKey;
    TCHAR       szKey[MAX_PATH];
    LONG        lErrorCode;
    HRESULT     hr = S_OK;

    _tcscpy(szKey, pszRegLocation);

    if (pszSubKey != NULL){
        _tcscpy(szKey, TEXT("\\"));
        _tcscat(szKey, pszSubKey);
    }

    lErrorCode = RegCreateKeyEx(HKEY_CURRENT_USER,
                                szKey,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                NULL);

    if (lErrorCode != ERROR_SUCCESS){
        return HRESULT_FROM_WIN32(lErrorCode);
    }

    if (pszValue != NULL){
        lErrorCode = RegSetValueEx(hKey,
                                   pszKey,
                                   0,
                                   REG_SZ,
                                   (BYTE *)pszValue,
                                   (_tcslen(pszValue)+1)*sizeof(TCHAR));

        if(lErrorCode != ERROR_SUCCESS){
            hr = HRESULT_FROM_WIN32(lErrorCode);
            goto cleanup;
        }

    }

cleanup:
    RegCloseKey(hKey);
    return S_OK;
}


HRESULT
QueryKeyValue(
    LPTSTR pszRegLocation,
    LPTSTR pszKey,
    LPTSTR * ppszValue
    )

{
    LONG lErrorCode;
    TCHAR szKey[MAX_PATH];
    DWORD dwDataLen;
    DWORD dwType;
    HKEY  hKey = NULL;
    HRESULT hr = S_OK;

    dwDataLen = sizeof(TCHAR)* MAX_PATH;
    
    *ppszValue = (LPTSTR)AllocADsMem( dwDataLen );

    if(!*ppszValue){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    _tcscpy(szKey, pszRegLocation);

    lErrorCode = RegOpenKeyEx(HKEY_CURRENT_USER,
                              szKey,
                              NULL,
                              KEY_ALL_ACCESS,
                              &hKey);

    if( lErrorCode != ERROR_SUCCESS){
        hr = HRESULT_FROM_WIN32(lErrorCode);
        goto cleanup;
    }

    lErrorCode = RegQueryValueEx(hKey,
                                 pszKey,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)*ppszValue,
                                 &dwDataLen);

    if (lErrorCode == ERROR_MORE_DATA){
        FreeADsMem(*ppszValue);
        *ppszValue = NULL;
        *ppszValue = (LPTSTR)AllocADsMem (dwDataLen);

        if(!*ppszValue){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        lErrorCode = RegQueryValueEx(hKey,
                                     pszKey,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)*ppszValue,
                                     &dwDataLen);


        hr = HRESULT_FROM_WIN32(lErrorCode);
        BAIL_IF_ERROR(hr);

    } else if (lErrorCode != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lErrorCode);
        FreeADsMem(*ppszValue);
        *ppszValue = NULL;
    }
cleanup:
    if(hKey){
        RegCloseKey(hKey);
    }
    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\capool.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001
//
//  File:  capool.cxx
//
//  Contents:  Contains methods for CIISApplicationPool object
//
//  History:   11-09-2000     BrentMid    Created.
//
//----------------------------------------------------------------------------

#include "iisext.hxx"
#pragma hdrstop


//  Class CIISApplicationPool

DEFINE_IPrivateDispatch_Implementation(CIISApplicationPool)
DEFINE_DELEGATING_IDispatch_Implementation(CIISApplicationPool)
DEFINE_CONTAINED_IADs_Implementation(CIISApplicationPool)
DEFINE_IADsExtension_Implementation(CIISApplicationPool)

CIISApplicationPool::CIISApplicationPool():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _pszServerName(NULL),
        _pszPoolName(NULL),
        _pszMetaBasePath(NULL),
        _pAdminBase(NULL),
        _pDispMgr(NULL),
        _fDispInitialized(FALSE)
{
    ENLIST_TRACKING(CIISApplicationPool);
}

HRESULT
CIISApplicationPool::CreateApplicationPool(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    CCredentials Credentials;
    CIISApplicationPool FAR * pApplicationPool = NULL;
    HRESULT hr = S_OK;
    BSTR bstrAdsPath = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer * pLexer = NULL;
    LPWSTR pszIISPathName  = NULL;
	LPWSTR *pszPoolName;

    hr = AllocateApplicationPoolObject(pUnkOuter, Credentials, &pApplicationPool);
    BAIL_ON_FAILURE(hr);

    //
    // get ServerName and pszPath
    //

    hr = pApplicationPool->_pADs->get_ADsPath(&bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    pLexer = new CLexer();
    hr = pLexer->Initialize(bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(pLexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(bstrAdsPath);
    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

	pszPoolName = &(ObjectInfo.ComponentArray[ObjectInfo.NumComponents-1].szComponent);

    hr = pApplicationPool->InitializeApplicationPoolObject(
                pObjectInfo->TreeName,
                pszIISPathName,
                *pszPoolName );
    BAIL_ON_FAILURE(hr);

    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pApplicationPool;

    if (bstrAdsPath)
    {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    *ppvObj = NULL;

    delete pApplicationPool;

    RRETURN(hr);

}


CIISApplicationPool::~CIISApplicationPool( )
{
    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath) {
        FreeADsStr(_pszMetaBasePath);
    }

	if (_pszPoolName) {
		FreeADsStr(_pszPoolName);
	}

    delete _pDispMgr;
}


STDMETHODIMP
CIISApplicationPool::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;
   
    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);
}

HRESULT
CIISApplicationPool::AllocateApplicationPoolObject(
    IUnknown *pUnkOuter,
    CCredentials& Credentials,
    CIISApplicationPool ** ppApplicationPool
    )
{
    CIISApplicationPool FAR * pApplicationPool = NULL;
    IADs FAR *  pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pApplicationPool = new CIISApplicationPool();
    if (pApplicationPool == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISExt,
                IID_IISApplicationPool,
                (IISApplicationPool *)pApplicationPool,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the IADs Pointer, but again do NOT ref-count
    // this pointer - we keep the pointer around, but do
    // a release immediately.
    //
 
    hr = pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
    pADs->Release();
    pApplicationPool->_pADs = pADs;

    //
    // Store the pointer to the pUnkOuter object
    // AND DO NOT add ref this pointer
    //
    pApplicationPool->_pUnkOuter = pUnkOuter;
  
    pApplicationPool->_Credentials = Credentials;
    pApplicationPool->_pDispMgr = pDispMgr;
    *ppApplicationPool = pApplicationPool;

    RRETURN(hr);

error:

    delete  pDispMgr;
    delete  pApplicationPool;

    RRETURN(hr);
}

HRESULT
CIISApplicationPool::InitializeApplicationPoolObject(
    LPWSTR pszServerName,
    LPWSTR pszPath,
	LPWSTR pszPoolName
    )
{
    HRESULT hr = S_OK;

    if (pszServerName) {
        _pszServerName = AllocADsStr(pszServerName);

        if (!_pszServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pszPath) {
        _pszMetaBasePath = AllocADsStr(pszPath);

        if (!_pszMetaBasePath) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pszPoolName) {
        _pszPoolName = AllocADsStr(pszPoolName);

        if (!_pszPoolName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = InitServerInfo(pszServerName, &_pAdminBase);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

STDMETHODIMP
CIISApplicationPool::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }

    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);

    if (SUCCEEDED(hr)) {
        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISApplicationPool::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP
CIISApplicationPool::ADSIReleaseObject()
{
    delete this;
    RRETURN(S_OK);
}


STDMETHODIMP
CIISApplicationPool::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);
    
    if (IsEqualIID(iid, IID_IISApplicationPool)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;
                                
    } else if (IsEqualIID(iid, IID_IUnknown)) {
        
        //
        // probably not needed since our 3rd party extension does not stand 
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {
        
        *ppv = NULL;
        return E_NOINTERFACE;
    } 


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IISApplicationPool.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();       

    return S_OK;
}


//
// IADsExtension::Operate()
//

STDMETHODIMP
CIISApplicationPool::Operate(
    THIS_ DWORD dwCode,
    VARIANT varUserName,
    VARIANT varPassword,
    VARIANT varFlags
    )
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CIISApplicationPool::SetState(
    METADATA_HANDLE hObjHandle,
    DWORD dwState
    )
{
    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)&dwState;    

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_APPPOOL_COMMAND,
                       METADATA_VOLATILE,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = _pAdminBase->SetData(
                hObjHandle,
                L"",
                &mdrMDData
                );

    RRETURN(hr);
}

STDMETHODIMP
CIISApplicationPool::Start(THIS)
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;

    hr = OpenAdminBaseKey(
        _pszServerName,
        _pszMetaBasePath,
        METADATA_PERMISSION_WRITE,
        &_pAdminBase,
        &hObjHandle
        );

    BAIL_ON_FAILURE(hr);

    hr = SetState(hObjHandle, MD_APPPOOL_COMMAND_START);

    BAIL_ON_FAILURE(hr);

error:

    if (hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISApplicationPool::Stop(THIS)
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;

    hr = OpenAdminBaseKey(
        _pszServerName,
        _pszMetaBasePath,
        METADATA_PERMISSION_WRITE,
        &_pAdminBase,
        &hObjHandle
        );

    BAIL_ON_FAILURE(hr);

    hr = SetState(hObjHandle, MD_APPPOOL_COMMAND_STOP);

    BAIL_ON_FAILURE(hr);

error:

    if (hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISApplicationPool::Recycle(THIS)
{
    HRESULT hr = S_OK;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IIISApplicationAdmin * pAppAdmin = NULL;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (_pszServerName == NULL || _wcsicmp(_pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName = _pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    hr = CoGetClassObject(
                CLSID_WamAdmin,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IIISApplicationAdmin,
                (void **) &pAppAdmin
                );
    BAIL_ON_FAILURE(hr);

    hr = pAppAdmin->RecycleApplicationPool( _pszPoolName );

    BAIL_ON_FAILURE(hr);

error:
    if (pcsfFactory) {
        pcsfFactory->Release();
    }
    if (pAppAdmin) {
        pAppAdmin->Release();
    } 

    RRETURN(hr);
}

STDMETHODIMP
CIISApplicationPool::EnumApps(
        VARIANT FAR* pvBuffer
        )
{
    HRESULT hr = S_OK;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IIISApplicationAdmin * pAppAdmin = NULL;
	BSTR bstr = NULL;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (_pszServerName == NULL || _wcsicmp(_pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName = _pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    hr = CoGetClassObject(
                CLSID_WamAdmin,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IIISApplicationAdmin,
                (void **) &pAppAdmin
                );
    BAIL_ON_FAILURE(hr);

	hr = pAppAdmin->EnumerateApplicationsInPool( _pszPoolName, &bstr );

    BAIL_ON_FAILURE(hr);

	hr = MakeVariantFromStringArray( (LPWSTR)bstr, pvBuffer);
	BAIL_ON_FAILURE(hr);

error:
    if (pcsfFactory) {
        pcsfFactory->Release();
    }
    if (pAppAdmin) {
        pAppAdmin->Release();
    } 

    RRETURN(hr);
}

HRESULT
CIISApplicationPool::MakeVariantFromStringArray(
    LPWSTR pszList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    LPWSTR pszStrList;
    WCHAR wchPath[MAX_PATH];


    if  (pszList != NULL)
    {
        long nCount = 0;
        long i = 0;
        pszStrList = pszList;

        if (*pszStrList == L'\0') {
            nCount = 1;
            pszStrList++;
        }

        while (*pszStrList != L'\0') {
            while (*pszStrList != L'\0') {
                pszStrList++;
            }
            nCount++;
            pszStrList++;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszStrList = pszList;
        for (i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            hr = ADsAllocString( pszStrList, &(V_BSTR(&v)));

            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList, &i, &v );

            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszStrList += wcslen(pszStrList) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    return S_OK;

error:

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\capoolscf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:  capoolcf.cxx
//
//  Contents:  IIS ApplicationPools Object Class Factory Code
//
//             CIISApplicationPoolsCF::CreateInstance
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISApplicationPoolsCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11-10-2000    BrentMid     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApplicationPoolsCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (!pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISApplicationPools::CreateApplicationPools(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\helper\utils\variant.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       disputil.cxx
//
//  Contents:   Dispatch Utilities.
//
//  Classes:
//
//  Functions:
//
//  History:    21-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified Set/GetDispProp to take REFIID
//                                  to meet sysmgmt needs
//              25-Oct-94   KrishnaG appropriated from the ADs project
//
//----------------------------------------------------------------------------

#include "procs.hxx"

#define VT_TYPEMASK   0x3ff


static HRESULT VARIANTARGToCVar(VARIANTARG * pvarg, VARTYPE vt, void* pv);
static void CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg);


//+---------------------------------------------------------------------------
//
//  Function:   FreeEXCEPINFO
//
//  Synopsis:   Frees resources in an excepinfo.  Does not reinitialize
//              these fields.
//
//----------------------------------------------------------------------------

void
FreeEXCEPINFO(EXCEPINFO * pEI)
{
    if (pEI)
    {
        ADsFreeString(pEI->bstrSource);
        ADsFreeString(pEI->bstrDescription);
        ADsFreeString(pEI->bstrHelpFile);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   ValidateInvoke
//
//  Synopsis:   Validates arguments to a call of IDispatch::Invoke.  A call
//              to this function takes less space than the function itself.
//
//----------------------------------------------------------------------------

HRESULT
ValidateInvoke(
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr)
{
    if (pvarResult)
        VariantInit(pvarResult);

    if (pexcepinfo)
        InitEXCEPINFO(pexcepinfo);

    if (puArgErr)
        *puArgErr = 0;

    if (!pdispparams)
        RRETURN(E_INVALIDARG);

    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
LoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    ADsAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (hr)
        RRETURN(hr);

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGToCVar
//
//  Synopsis:   Converts a VARIANT to a C-language variable.
//
//  Arguments:  [pvarg] -- Variant to convert.
//              [vt]    -- Type to convert to.
//              [pv]    -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_I2, VT_I4, VT_R4,
//              VT_R8.
//----------------------------------------------------------------------------

static HRESULT
VARIANTARGToCVar(VARIANT * pvarg, VARTYPE vt, void * pv)
{
    HRESULT     hr      = S_OK;
    VARIANTARG  vargNew;                    // variant of new type

    ADsAssert(pvarg);
    ADsAssert(pv);
    ADsAssert((vt & ~VT_TYPEMASK) == 0 || (vt & ~VT_TYPEMASK) == VT_BYREF);

    if (vt & VT_BYREF)
    {
        if (V_VT(pvarg) != vt)
        {
            hr = DISP_E_TYPEMISMATCH;
            goto Cleanup;
        }

        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
        vargNew = *pvarg;
    }
    else
    {
        VariantInit(&vargNew);
        hr = VariantChangeType(&vargNew, pvarg, 0, vt);
        if (hr)
            goto Cleanup;
    }

    switch (vt)
    {
    case VT_BOOL:
        if (V_BOOL(&vargNew) != VB_FALSE && V_BOOL(&vargNew) != VB_TRUE)
        {
            hr = E_FAIL;           // BUGBUG: scode?
            goto Cleanup;
        }

        // convert VT_TRUE to TRUE
        *(BOOL *)pv = - V_BOOL(&vargNew);
        break;

    case VT_I2:
        *(short *)pv = V_I2(&vargNew);
        break;

    case VT_I4:
        *(long *)pv = V_I4(&vargNew);
        break;

    case VT_R4:
        *(float *)pv = V_R4(&vargNew);
        break;

    case VT_R8:
        *(double *)pv = V_R8(&vargNew);
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        *(void **)pv = V_BYREF(&vargNew);
        break;

    default:
        ADsAssert(FALSE && "Unknown type in VARIANTARGToCVar().\n");
        break;
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CVarToVARIANTARG
//
//  Synopsis:   Converts a C-language variable to a VARIANT.
//
//  Arguments:  [pv]    -- Pointer to C-language variable.
//              [vt]    -- Type of C-language variable.
//              [pvarg] -- Resulting VARIANT.  Must be initialized by caller.
//                         Any contents will be freed.
//
//  Modifies:   [pvarg]
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_UI2, VT_I2, VT_UI4,
//              VT_I4, VT_R4, VT_R8.
//
//----------------------------------------------------------------------------

static void
CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg)
{
    ADsAssert(pv);
    ADsAssert(pvarg);

    VariantClear(pvarg);

    V_VT(pvarg) = vt;
    if (V_ISBYREF(pvarg))
    {
        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
    }

    switch (vt)
    {
    case VT_BOOL:
        // convert TRUE to VT_TRUE
        ADsAssert(*(BOOL *) pv == 1 || *(BOOL *) pv == 0);
        V_BOOL(pvarg) = VARIANT_BOOL(-*(BOOL *) pv);
        break;

    case VT_I2:
        V_I2(pvarg) = *(short *) pv;
        break;

    case VT_I4:
        V_I4(pvarg) = *(long *) pv;
        break;

    case VT_R4:
         V_R4(pvarg) = *(float *) pv;
        break;

    case VT_R8:
        V_R8(pvarg) = *(double *) pv;
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        V_BYREF(pvarg) = *(long **)pv;
        break;

    default:
        Assert(FALSE && "Unknown type.");
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   CParamsToDispParams
//
//  Synopsis:   Converts a C parameter list to a dispatch parameter list.
//
//  Arguments:  [pDispParams] -- Resulting dispatch parameter list.
//                               Note that the rgvarg member of pDispParams
//                               must be initialized with an array of
//                               EVENTPARAMS_MAX VARIANTs.
//
//              [pvt]         -- List of C parameter types.  May be NULL.
//                               If not NULL, Last elem in list MUST be
//                               VT_EMPTY.
//
//              [va]          -- List of C arguments.
//
//  Modifies:   [pDispParams]
//
//  History:    05-Jan-94   adams   Created
//              23-Feb-94   adams   Reversed order of disp arguments, added
//                                  support for VT_R4, VT_R8, and pointer
//                                  types.
//
//  Notes:      Only types VT_I2,VT_I4, and VT_UNKNOWN are supported.
//
//----------------------------------------------------------------------------

void
CParamsToDispParams(
        DISPPARAMS *    pDispParams,
        VARTYPE *       pvt,
        va_list         va)
{
    ADsAssert(pDispParams);
    ADsAssert(pDispParams->rgvarg);

    VARIANTARG *    pvargCur;           // current variant
    VARTYPE *       pvtCur;            // current vartype

    // Assign vals to dispatch param list.
    pDispParams->cNamedArgs         = 0;
    pDispParams->rgdispidNamedArgs  = NULL;

    // Get count of arguments.
    if (!pvt)
    {
        pDispParams->cArgs = 0;
        return;
    }

    for (pvtCur = pvt; *pvtCur != VT_EMPTY; pvtCur++)
        ;

    pDispParams->cArgs = pvtCur - pvt;
    ADsAssert(pDispParams->cArgs < EVENTPARAMS_MAX);


    //
    // Convert each C-param to a dispparam.  Note that the order of dispatch
    // parameters is the reverse of the order of c-params.
    //

    ADsAssert(pDispParams->rgvarg);
    pvargCur = pDispParams->rgvarg + pDispParams->cArgs;
    for (pvtCur = pvt; *pvtCur != VT_EMPTY; pvtCur++)
    {
        pvargCur--;
        ADsAssert(pvargCur >= pDispParams->rgvarg);

        V_VT(pvargCur) = *pvtCur;
        if ((*pvtCur & VT_BYREF) == VT_BYREF)
        {
            V_BYREF(pvargCur) = va_arg(va, long *);
        }
        else
        {
            switch (*pvtCur)
            {
            case VT_BOOL:
                // convert TRUE to VT_TRUE
                V_BOOL(pvargCur) = VARIANT_BOOL(-va_arg(va, BOOL));
                ADsAssert(V_BOOL(pvargCur) == VB_FALSE ||
                        V_BOOL(pvargCur) == VB_TRUE);
                break;

            case VT_I2:
                V_I2(pvargCur) = va_arg(va, short);
                break;

            case VT_I4:
                V_I4(pvargCur) = va_arg(va, long);
                break;

            case VT_R4:
                V_R4(pvargCur) = va_arg(va, float);
                break;

            case VT_R8:
                V_R8(pvargCur) = va_arg(va, double);
                break;

            //
            // All Pointer types.
            //
            case VT_BSTR:
            case VT_LPSTR:
            case VT_LPWSTR:
            case VT_DISPATCH:
            case VT_UNKNOWN:
                V_BYREF(pvargCur) = va_arg(va, long *);
                break;

            default:
                Assert(FALSE && "Unknown type.\n");
            }
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   DispParamsToCParams
//
//  Synopsis:   Converts Dispatch::Invoke method params to C-language params.
//
//  Arguments:  [pDP] -- Dispatch params to be converted.
//              [pvt] -- Array of types of C-params.  May be NULL.  If
//                       non-NULL, last element must be VT_EMPTY.
//              [...] -- List of pointers to c-params to be converted to.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types listed in VARIANTToCParam.
//
//----------------------------------------------------------------------------

STDAPI
DispParamsToCParams(
        DISPPARAMS *    pDP,
        UINT *          puArgErr,
        VARTYPE *       pvt,
        ...)
{
    HRESULT         hr;
    va_list         va;                // list of pointers to c-params.
    VARTYPE *       pvtCur;            // current VARTYPE of c-param.
    VARIANTARG *    pvargCur;          // current VARIANT being converted.
    void *          pv;                // current c-param being converted.
    int             cArgs;             // count of arguments.

    ADsAssert(pDP);

    hr = S_OK;
    va_start(va, pvt);
    if (!pvt)
    {
        if (pDP->cArgs > 0)
            goto BadParamCountError;

        goto Cleanup;
    }

    pvargCur = pDP->rgvarg + pDP->cArgs - 1;
    pvtCur = pvt;
    for (cArgs = 0; cArgs < (int)pDP->cArgs; cArgs++)
    {
        if (*pvtCur == VT_EMPTY)
            goto BadParamCountError;

        pv = va_arg(va, void *);
        hr = VARIANTARGToCVar(pvargCur, *pvtCur, pv);
        if (hr)
        {
            if (puArgErr)
                *puArgErr = cArgs;

            goto Cleanup;
        }

        pvargCur--;
        pvtCur++;
    }

    if (*pvtCur != VT_EMPTY)
        goto BadParamCountError;

Cleanup:
    va_end(va);
    RRETURN(hr);

BadParamCountError:
    hr = DISP_E_BADPARAMCOUNT;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDispProp
//
//  Synopsis:   Gets a property of an object.
//
//  Arguments:  [pDisp]  -- The object containing the property.
//              [dispid] -- The ID of the property.
//              [riid]   -- interface of object desired
//              [lcid]   -- The locale of the object.
//              [pvar]   -- The resulting property.  Must be initialized.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pvarg].
//
//  History:    23-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified to take REFIID
//
//----------------------------------------------------------------------------

HRESULT
GetDispProp(
        IDispatch * pDisp,
        DISPID      dispid,
        REFIID      riid,
        LCID        lcid,
        VARIANT *   pvar,
        EXCEPINFO * pexcepinfo)
{
    HRESULT     hr;
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.
    UINT        uiErr;                 // Argument error.

    ADsAssert(pDisp);
    ADsAssert(pvar);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    hr = pDisp->Invoke(
            dispid,
            riid,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            pvar,
            pexcepinfo,
            &uiErr);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispProp
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- The object to set the property on.
//              [dispid] -- The ID of the property.
//              [riid]   -- interface of object
//              [lcid]   -- The locale of the property.
//              [pvarg]  -- The value to set.
//
//  Returns:    HRESULT.
//
//  History:    23-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified to take REFIID
//
//----------------------------------------------------------------------------

HRESULT
SetDispProp(
        IDispatch *     pDisp,
        DISPID          dispid,
        REFIID          riid,
        LCID            lcid,
        VARIANTARG *    pvarg,
        EXCEPINFO *     pexcepinfo)
{
    HRESULT     hr;
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke
    UINT        uiErr;                 // Invoke error param.

    ADsAssert(pDisp);
    ADsAssert(pvarg);

    dp.rgvarg = pvarg;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    hr = pDisp->Invoke(
            dispid,
            riid,
            lcid,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            pexcepinfo,
            &uiErr);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDispPropOfType
//
//  Synopsis:   Gets a property from an object, and converts it to a c
//              variable.
//
//  Arguments:  [pDisp]  -- The object to retrieve the property from.
//              [dispid] -- Property ID.
//              [lcid]   -- Locale of property.
//              [vt]     -- Type of c-variable to receive property.
//              [pv]     -- Pointer to resulting c-variable.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pv].
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports variable types found in VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
GetDispPropOfType(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vt,
        void *      pv)
{
    HRESULT     hr;
    VARIANT     varProp;               // Property retrieved.
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.

    ADsAssert(pDisp);
    ADsAssert(pv);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    VariantInit(&varProp);
    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            &varProp,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

    hr = VARIANTARGToCVar(&varProp, vt, pv);

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispPropOfType
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- Object to set property on.
//              [dispid] -- Property ID to set.
//              [lcid]   -- Locale of property.
//              [vt]     -- Type of property to set.
//              [pv]     -- Pointer to property value.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types found in VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
SetDispPropOfType(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vt,
        void *      pv)
{
    HRESULT     hr;
    VARIANTARG  varg;                   // Variant property to put.
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke

    ADsAssert(pDisp);
    ADsAssert(pv);

    VariantInit(&varg);
    CVarToVARIANTARG(pv, vt, &varg);
    dp.rgvarg = &varg;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            NULL,
            NULL);
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CallDispMethod
//
//  Synopsis:   Calls a late-bound method on a object via IDispatch::Invoke.
//
//  Arguments:  [pDisp]     -- Object to call method on.
//              [dispid]    -- Method ID.
//              [lcid]      -- Locale of method.
//              [vtReturn]  -- Type of return value.  If no return value,
//                             must be VT_VOID.
//              [pvReturn]  -- Location of return value.  If no return value,
//                             must be NULL.
//              [pvtParams] -- List of param types.  May be NULL.  If
//                             non-NULL, last entry must be VT_EMPTY.
//              [...]       -- List of params.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CallDispMethod(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vtReturn,
        void *      pvReturn,
        VARTYPE *   pvtParams,
        ...)
{
    HRESULT     hr;
    VARIANTARG  av[EVENTPARAMS_MAX];   // List of args for Invoke.
    DISPPARAMS  dp;                    // Params for Invoke.
    VARIANT     varReturn;             // Return value.
    va_list     va;                    // List of C-params.

    ADsAssert(pDisp);
    ADsAssert((vtReturn != VT_VOID) == (pvReturn != NULL));

    va_start(va, pvtParams);
    dp.rgvarg = av;
    CParamsToDispParams(&dp, pvtParams, va);
    va_end(va);

    if (pvReturn)
        VariantInit(&varReturn);

    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_METHOD,
            &dp,
            pvReturn ? &varReturn : NULL,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

    if (pvReturn)
        hr = VARIANTARGToCVar(&varReturn, vtReturn, pvReturn);

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   IsVariantEqual, public API
//
//  Synopsis:   Compares the values of two VARIANTARGs.
//
//  Arguments:  [pvar1], [pvar2] -- VARIANTARGs to compare.
//
//  Returns:    TRUE if equal, FALSE if not.
//
//  History:    18-Mar-93   SumitC      Created.
//              11-May-94   SumitC      don't assert for VT_UNKNOWN
//
//  Notes:      Variant type unequal returns FALSE, even if actual values
//              are the same.
//              Currently does I2, I4, R4, R8, CY, BSTR, BOOL
//              Returns FALSE for all other VariantTypes.
//
//-------------------------------------------------------------------------

BOOL
IsVariantEqual( VARIANTARG FAR* pvar1, VARIANTARG FAR* pvar2 )
{
    if( V_VT(pvar1) != V_VT(pvar2) )
        return FALSE;

    switch (V_VT(pvar1))
    {
    case VT_EMPTY :
    case VT_NULL:
        return TRUE;    // just the types being equal is good enough

    case VT_I2 :
        return (V_I2(pvar1) == V_I2(pvar2));

    case VT_I4 :
        return (V_I4(pvar1) == V_I4(pvar2));

    case VT_R4 :
        return (V_R4(pvar1) == V_R4(pvar2));

    case VT_R8 :
        return (V_R8(pvar1) == V_R8(pvar2));

    case VT_CY :
        return !memcmp(&V_CY(pvar1), &V_CY(pvar2), sizeof(CY));

    case VT_BSTR :
        return !ADsStringCmp(V_BSTR(pvar1), V_BSTR(pvar2));

    case VT_BOOL :
        return (V_BOOL(pvar1) == V_BOOL(pvar2));

    case VT_UNKNOWN:
        // returns FALSE unless the objects are the same
        return (V_UNKNOWN(pvar1) == V_UNKNOWN(pvar2));

    default:
        ADsAssert(0 && "Type not handled");
        break;
    };

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\capoolcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:  capoolcf.cxx
//
//  Contents:  IIS ApplicationPool Object Class Factory Code
//
//             CIISApplicationPoolCF::CreateInstance
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISApplicationPoolCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11-10-2000    BrentMid     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApplicationPoolCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (!pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISApplicationPool::CreateApplicationPool(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\capools.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001
//
//  File:  capools.cxx
//
//  Contents:  Contains methods for CIISApplicationPools object
//
//  History:   11-09-2000     BrentMid    Created.
//
//----------------------------------------------------------------------------

#include "iisext.hxx"
#pragma hdrstop


//  Class CIISApplicationPools

DEFINE_IPrivateDispatch_Implementation(CIISApplicationPools)
DEFINE_DELEGATING_IDispatch_Implementation(CIISApplicationPools)
DEFINE_CONTAINED_IADs_Implementation(CIISApplicationPools)
DEFINE_IADsExtension_Implementation(CIISApplicationPools)

CIISApplicationPools::CIISApplicationPools():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _pszServerName(NULL),
        _pszMetaBasePath(NULL),
        _pAdminBase(NULL),
        _pDispMgr(NULL),
        _fDispInitialized(FALSE)
{
    ENLIST_TRACKING(CIISApplicationPools);
}

HRESULT
CIISApplicationPools::CreateApplicationPools(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    CCredentials Credentials;
    CIISApplicationPools FAR * pApplicationPools = NULL;
    HRESULT hr = S_OK;
    BSTR bstrAdsPath = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer * pLexer = NULL;
    LPWSTR pszIISPathName  = NULL;

    hr = AllocateApplicationPoolsObject(pUnkOuter, Credentials, &pApplicationPools);
    BAIL_ON_FAILURE(hr);

    //
    // get ServerName and pszPath
    //

    hr = pApplicationPools->_pADs->get_ADsPath(&bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    pLexer = new CLexer();
    hr = pLexer->Initialize(bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(pLexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(bstrAdsPath);
    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pApplicationPools->InitializeApplicationPoolsObject(
                pObjectInfo->TreeName,
                pszIISPathName );
    BAIL_ON_FAILURE(hr);

    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pApplicationPools;

    if (bstrAdsPath)
    {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    *ppvObj = NULL;

    delete pApplicationPools;

    RRETURN(hr);

}


CIISApplicationPools::~CIISApplicationPools( )
{
    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath) {
        FreeADsStr(_pszMetaBasePath);
    }

    delete _pDispMgr;
}


STDMETHODIMP
CIISApplicationPools::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;
   
    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);
}

HRESULT
CIISApplicationPools::AllocateApplicationPoolsObject(
    IUnknown *pUnkOuter,
    CCredentials& Credentials,
    CIISApplicationPools ** ppApplicationPools
    )
{
    CIISApplicationPools FAR * pApplicationPools = NULL;
    IADs FAR *  pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pApplicationPools = new CIISApplicationPools();
    if (pApplicationPools == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISExt,
                IID_IISApplicationPools,
                (IISApplicationPools *)pApplicationPools,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the IADs Pointer, but again do NOT ref-count
    // this pointer - we keep the pointer around, but do
    // a release immediately.
    //
 
    hr = pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
    pADs->Release();
    pApplicationPools->_pADs = pADs;

    //
    // Store the pointer to the pUnkOuter object
    // AND DO NOT add ref this pointer
    //
    pApplicationPools->_pUnkOuter = pUnkOuter;
  
    pApplicationPools->_Credentials = Credentials;
    pApplicationPools->_pDispMgr = pDispMgr;
    *ppApplicationPools = pApplicationPools;

    RRETURN(hr);

error:

    delete  pDispMgr;
    delete  pApplicationPools;

    RRETURN(hr);
}

HRESULT
CIISApplicationPools::InitializeApplicationPoolsObject(
    LPWSTR pszServerName,
    LPWSTR pszPath
    )
{
    HRESULT hr = S_OK;

    if (pszServerName) {
        _pszServerName = AllocADsStr(pszServerName);

        if (!_pszServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pszPath) {
        _pszMetaBasePath = AllocADsStr(pszPath);

        if (!_pszMetaBasePath) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = InitServerInfo(pszServerName, &_pAdminBase);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

STDMETHODIMP
CIISApplicationPools::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }

    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);

    if (SUCCEEDED(hr)) {
        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISApplicationPools::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP
CIISApplicationPools::ADSIReleaseObject()
{
    delete this;
    RRETURN(S_OK);
}


STDMETHODIMP
CIISApplicationPools::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);
    
    if (IsEqualIID(iid, IID_IISApplicationPools)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;
                                
    } else if (IsEqualIID(iid, IID_IUnknown)) {
        
        //
        // probably not needed since our 3rd party extension does not stand 
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {
        
        *ppv = NULL;
        return E_NOINTERFACE;
    } 


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IISApplicationPools.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();       

    return S_OK;
}


//
// IADsExtension::Operate()
//

STDMETHODIMP
CIISApplicationPools::Operate(
    THIS_ DWORD dwCode,
    VARIANT varUserName,
    VARIANT varPassword,
    VARIANT varFlags
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\ccompcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  ccompcf.cxx
//
//  Contents:  IIS Computer Object Class Factory Code
//
//             CIISComputerCF::CreateInstance
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISComputerCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISComputerCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (!pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISComputer::CreateComputer(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\cmacro.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cmacro.h
//
//  Contents:  Macros for adsi methods
//
//  History:   21-04-97     sophiac    Created.
//
//----------------------------------------------------------------------------

#define DEFINE_CONTAINED_IADs_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_Name(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                              \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_ADsPath(retval));                            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_Class(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Parent(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Schema(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_GUID(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(_pADs->Get(bstrName, pvProp));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(_pADs->Put(bstrName, vProp));                             \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(_pADs->GetEx(bstrName, pvProp));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(_pADs->PutEx(lnControlCode, bstrName, vProp));            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetInfo(THIS_)                                                   \
{                                                                     \
    RRETURN(_pADs->GetInfo());                                        \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetInfo(THIS_ )                                                  \
{                                                                     \
    RRETURN(_pADs->SetInfo());                                        \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(_pADs->GetInfoEx(vProperties, lnReserved));               \
}


#define DEFINE_CONTAINED_IDSObject_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetObjectAttributes(                                             \
    PADS_ATTR_DEF pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    DWORD *pdwNumAttributesModified                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->SetObjectAttributes(                             \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        pdwNumAttributesModified                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectAttributes(                                             \
    PADS_ATTR_NAME pAttributeNames,                                   \
    DWORD dwNumberAttributes,                                         \
    PADS_ATTR_DEF *ppAttributeEntries,                                \
    DWORD * pdwNumAttributesReturned                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectAttributes(                             \
                        pAttributeNames,                              \
                        dwNumberAttributes,                           \
                        ppAttributeEntries,                           \
                        pdwNumAttributesReturned                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateDSObject(                                                  \
    LPWSTR pszRDNName,                                                \
    PADS_ATTR_DEF pAttributeEntries,                                  \
    DWORD dwNumAttributes                                             \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->CreateDSObject(                                  \
                        pszRDNName,                                   \
                        pAttributeEntries,                            \
                        dwNumAttributes                               \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteDSObject(                                                  \
    LPWSTR pszRDNName                                                 \
    )                                                                 \
                                                                      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->DeleteDSObject(                                  \
                        pszRDNName                                    \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectInformation(                                            \
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo                              \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectInformation(                            \
                            ppObjInfo                                 \
                            );                                        \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IADsContainer_Implementation(cls)          \
STDMETHODIMP                                                          \
cls::get_Filter(THIS_ VARIANT FAR* pVar )                             \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Filter( pVar );                    \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Filter(THIS_ VARIANT Var )                                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Filter( Var );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Hints(THIS_ VARIANT FAR* pVar )                              \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Hints( pVar );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Hints(THIS_ VARIANT Var )                                    \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Hints( Var );                      \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Count(THIS_ long FAR* retval)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Count( retval );                   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get__NewEnum(THIS_ IUnknown * FAR * retval )                     \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get__NewEnum( retval );                \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObject(THIS_ BSTR ClassName, BSTR RelativeName,               \
               IDispatch * FAR * ppObject )                           \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->GetObject( ClassName, RelativeName, ppObject ); \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Create(THIS_ BSTR ClassName, BSTR RelativeName,                  \
            IDispatch * FAR * ppObject )                               \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr =_pADsContainer->Create( ClassName, RelativeName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Delete(THIS_ BSTR ClassName, BSTR SourceName )                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->Delete( ClassName, SourceName );       \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::CopyHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                           \
        hr = _pADsContainer->CopyHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::MoveHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                           \
        hr = _pADsContainer->MoveHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     

#define DEFINE_CONTAINED_IIsBaseObject_Implementation(cls)            \
STDMETHODIMP                                                          \
cls::GetDataPaths(THIS_ BSTR bstrName, LONG lnAttribute,              \
                  VARIANT FAR* pvProp)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pIIsBaseObject) {                                           \
        hr = _pIIsBaseObject->GetDataPaths( bstrName, lnAttribute, pvProp);   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetPropertyAttribObj(THIS_ BSTR bstrName,                        \
                          IDispatch * FAR *ppObject)                  \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pIIsBaseObject) {                                           \
        hr = _pIIsBaseObject->GetPropertyAttribObj(bstrName, ppObject); \
    }                                                                 \
    RRETURN(hr);                                                      \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//		multiple IDispatch-callable interfaces.
//
//  Classes:	CAggregateeDispMgr
//
//  Functions:	None external.
//
//  History:    ??-???-??   KrishnaG   created
//		07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

#include "iisext.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-	Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include "cdispmgr.hxx"
#include "iprops.hxx"

#endif	// ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-	End Non-ADSI compile stuff

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:	Simplified from Win4AssertEx, to make this dispatch manager
//  		not depend on other files.
//
//----------------------------------------------------------------------------
static void
AssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[100];

    sprintf(szAssertCaption, "File: %s line %u, thread id %d",
	szFile, iLine, GetCurrentThreadId());

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
	DebugBreak();
    }
}
# define DispMgrAssert(x)  (void)((x) || (AssertEx(__FILE__, __LINE__, #x),0))
#else
# define AssertEx(f,l,m)   
# define DispMgrAssert(x)  
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(
    LONG ExtensionId,
    LONG TypeInfoId,
    LONG DispId,
    DISPID *pResult
    )
{
    if (DispId == DISPID_UNKNOWN){

    	*pResult = DispId;

    }else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
	                DispId < 0 || DispId >= 0x10000){

	    //
	    // Might happen if some object has very large dispid's.
	    // But we can't handle it if it does.
	    //
	    *pResult = DISPID_UNKNOWN;
    }
    else{

	    *pResult = ((ExtensionId & 0xff) << 24) |((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

    }

}


static inline void
MakeDISPIDs(
    LONG ExtensionId,
    LONG TypeInfoId,
    DISPID *rgdispid,
    unsigned int cNames
    )
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(ExtensionId, TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregateeDispMgr::CAggregateeDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
    _dwExtensionID = 0;
}

CAggregateeDispMgr::~CAggregateeDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

}

void
CAggregateeDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregateeDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregateeDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

//
// This works only for single names; if multiple names are
// passed we die big time. This is help us get going using VB's _NewEnum
//

STDMETHODIMP
CAggregateeDispMgr::GetIDsOfNames(REFIID iid, LPWSTR *rgszNames,
        unsigned int cNames, LCID lcid, DISPID *rgdispid)
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {

            // 
            // aggregatee no longer needs to include extension id
            // in dispid.  
            // TODO: change function to get rid of ext id = 0 during clean up
            //

            MakeDISPIDs(0, pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
	hr = S_OK;
	for (DWORD dw = 0; dw < cNames; dw++) {
	    if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
		    (PDWORD)(rgdispid + dw)))) {
		hr = DISP_E_UNKNOWNNAME;
		rgdispid[dw] = DISPID_UNKNOWN;
	    }
	}
	if (SUCCEEDED(hr)) {

            // 
            // aggregatee no longer needs to include extension id
            // in dispid.  
            // TODO: change function to get rid of ext id = 0 during clean up
            //

	    MakeDISPIDs(0, _dwPropCacheID, rgdispid, cNames);
	}
    }

    return hr;
}

STDMETHODIMP
CAggregateeDispMgr::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,
	unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
	EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregateeDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregateeDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregateeDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregateeDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregateeDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

    return S_OK;

error:
    return hr;
}

STDMETHODIMP
CAggregateeDispMgr::TypeInfoInvoke(DISPID dispidMember, REFIID iid, LCID lcid,
	unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
	EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

    	//
	    // One of the special DISPIDs.
	    //
	    // If we have an interface pointer for it, use that.
	    // If we don't, and we have a base IDispatch pointer,
	    //   pass it to the base pointer's Invoke() method.
	    // If we don't, and we don't have a base IDispatch pointer,
	    //   return failure.
	    //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
	    break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

	    if (!pInterfacePtr) {

	        BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

	    }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                           	
	    // A regular DISPID of ours.
	    //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

	    if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
	        pInterfacePtr = getInterfacePtr(typeinfoid);
	        pTypeInfo = getTypeInfo(typeinfoid);
	        if (!pTypeInfo)
		        //
		    // Shouldn't happen.
		    //
		    BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
	    }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = AggregateeDynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

error:
    return hr;
}


HRESULT
AggregateeDynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        //
        // only handles one argument.
        //

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

error:
    return(hr);

}


HRESULT
CAggregateeDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregateeDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregateeDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    DispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;


ITypeInfo *
AggregateeFindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
AggregateeLoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    DispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (hr)
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregateeDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    hr = AggregateeLoadTypeInfo(libid, iid, &pTypeInfo);
    BAIL_ON_FAILURE(hr);

    hr = AddTypeInfo(pTypeInfo, pIntf);
    BAIL_ON_FAILURE(hr);

    if (SpecialId == -4) {
	hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
	hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

error:
    if (pTypeInfo)
	pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregateeDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

HRESULT
CAggregateeDispMgr::InitializeDispMgr(
    DWORD dwExtensionID
    )
{
    if (dwExtensionID > 255) {
        return(E_FAIL);
    }
    _dwExtensionID = dwExtensionID;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\cappcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cappcf.cxx
//
//  Contents:  IIS App Object Class Factory Code
//
//             CIISAppCF::CreateInstance
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISAppCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISAppCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (!pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISApp::CreateApp(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\ccomp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  ccomp.cxx
//
//  Contents:  Contains methods for CIISComputer object
//
//  History:   20-1-98     SophiaC    Created.
//
//----------------------------------------------------------------------------

#include "iisext.hxx"
#pragma hdrstop


//  Class CIISComputer

DEFINE_IPrivateDispatch_Implementation(CIISComputer)
DEFINE_DELEGATING_IDispatch_Implementation(CIISComputer)
DEFINE_CONTAINED_IADs_Implementation(CIISComputer)
DEFINE_IADsExtension_Implementation(CIISComputer)

CIISComputer::CIISComputer():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _pszServerName(NULL),
        _pszMetaBasePath(NULL),
        _pAdminBase(NULL),
        _pDispMgr(NULL),
        _fDispInitialized(FALSE)
{
    ENLIST_TRACKING(CIISComputer);
}

HRESULT
CIISComputer::CreateComputer(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    CCredentials Credentials;
    CIISComputer FAR * pComputer = NULL;
    HRESULT hr = S_OK;
    BSTR bstrAdsPath = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer * pLexer = NULL;
    LPWSTR pszIISPathName  = NULL;

    hr = AllocateComputerObject(pUnkOuter, Credentials, &pComputer);
    BAIL_ON_FAILURE(hr);

    //
    // get ServerName and pszPath
    //

    hr = pComputer->_pADs->get_ADsPath(&bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    pLexer = new CLexer();
    hr = pLexer->Initialize(bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(pLexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(bstrAdsPath);
    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pComputer->InitializeComputerObject(
                pObjectInfo->TreeName,
                pszIISPathName );
    BAIL_ON_FAILURE(hr);

    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pComputer;

    if (bstrAdsPath)
    {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    *ppvObj = NULL;

    delete pComputer;

    RRETURN(hr);

}


CIISComputer::~CIISComputer( )
{
    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath) {
        FreeADsStr(_pszMetaBasePath);
    }

    delete _pDispMgr;
}


STDMETHODIMP
CIISComputer::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;
   
    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);
}

HRESULT
CIISComputer::AllocateComputerObject(
    IUnknown *pUnkOuter,
    CCredentials& Credentials,
    CIISComputer ** ppComputer
    )
{
    CIISComputer FAR * pComputer = NULL;
    IADs FAR *  pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pComputer = new CIISComputer();
    if (pComputer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISExt,
                IID_IISComputer2,
                (IISComputer2 *)pComputer,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the IADs Pointer, but again do NOT ref-count
    // this pointer - we keep the pointer around, but do
    // a release immediately.
    //
 
    hr = pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
    pADs->Release();
    pComputer->_pADs = pADs;

    //
    // Store the pointer to the pUnkOuter object
    // AND DO NOT add ref this pointer
    //
    pComputer->_pUnkOuter = pUnkOuter;
  
    pComputer->_Credentials = Credentials;
    pComputer->_pDispMgr = pDispMgr;
    *ppComputer = pComputer;

    RRETURN(hr);

error:

    delete  pDispMgr;
    delete  pComputer;

    RRETURN(hr);
}

HRESULT
CIISComputer::InitializeComputerObject(
    LPWSTR pszServerName,
    LPWSTR pszPath
    )
{
    HRESULT hr = S_OK;

    if (pszServerName) {
        _pszServerName = AllocADsStr(pszServerName);

        if (!_pszServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pszPath) {
        _pszMetaBasePath = AllocADsStr(pszPath);

        if (!_pszMetaBasePath) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = InitServerInfo(pszServerName, &_pAdminBase);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISComputer::Backup
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07/14/97  SophiaC    Created
//
// Notes:
//----------------------------------------------------------------------------

STDMETHODIMP
CIISComputer::Backup(
    BSTR bstrLocation,
    LONG lVersion,
    LONG lFlags
    )
{
    HRESULT hr = S_OK;
    hr =  _pAdminBase->Backup((LPWSTR)bstrLocation,
                               lVersion,
                               lFlags);
    RRETURN(hr);
}

STDMETHODIMP
CIISComputer::BackupWithPassword(
    BSTR bstrLocation,
    LONG lVersion,
    LONG lFlags,
    BSTR bstrPassword
    )
{
	HRESULT hr = S_OK;
	IMSAdminBase2 * pInterface2 = NULL;
	if (SUCCEEDED(hr = _pAdminBase->QueryInterface(IID_IMSAdminBase2, (void **)&pInterface2)))
	{
		hr = pInterface2->BackupWithPasswd(bstrLocation, lVersion, lFlags, bstrPassword);
		pInterface2->Release();
	}
    
    RRETURN(hr);
}

STDMETHODIMP
CIISComputer::SaveData()
{
    HRESULT hr = S_OK;

    hr = _pAdminBase->SaveData();

    RRETURN(hr);
}

STDMETHODIMP
CIISComputer::Export(
	BSTR bstrPassword,
	BSTR bstrFilename,
	BSTR bstrSourcePath,
	LONG lFlags
	)
{
	HRESULT hr = S_OK;
	IMSAdminBase2 * pInterface2 = NULL;
	if (SUCCEEDED(hr = _pAdminBase->QueryInterface(IID_IMSAdminBase2, (void **)&pInterface2)))
	{
		hr = pInterface2->Export(bstrPassword, bstrFilename, bstrSourcePath, lFlags);
		pInterface2->Release();
	}

	RRETURN(hr);
}

STDMETHODIMP
CIISComputer::Import(
	BSTR bstrPassword,
	BSTR bstrFilename,
	BSTR bstrSourcePath,
	BSTR bstrDestPath,
	LONG lFlags
	)
{
	HRESULT hr = S_OK;
	IMSAdminBase2 * pInterface2 = NULL;
	if (SUCCEEDED(hr = _pAdminBase->QueryInterface(IID_IMSAdminBase2, (void **)&pInterface2)))
	{
		hr = pInterface2->Import(bstrPassword, bstrFilename, bstrSourcePath, bstrDestPath, lFlags);
		pInterface2->Release();
	}

	RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISComputer::Restore
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07/14/96 SophiaC  Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CIISComputer::Restore(
    BSTR bstrLocation,
    LONG lVersion,
    LONG lFlags
    )
{
    HRESULT hr = S_OK;

    hr =  _pAdminBase->Restore((LPWSTR)bstrLocation,
                               lVersion,
                               lFlags);

    RRETURN(hr);
}

STDMETHODIMP
CIISComputer::RestoreWithPassword(
    BSTR bstrLocation,
    LONG lVersion,
    LONG lFlags,
    BSTR bstrPassword
    )
{
	HRESULT hr = S_OK;

	IMSAdminBase2 * pInterface2 = NULL;

	if (SUCCEEDED(hr = _pAdminBase->QueryInterface(IID_IMSAdminBase2, (void **)&pInterface2)))
	{
		hr = pInterface2->RestoreWithPasswd(bstrLocation, lVersion, lFlags, bstrPassword);
		pInterface2->Release();
	}

   RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISComputer::EnumBackups
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CIISComputer::EnumBackups(
    BSTR bstrLocation,
    LONG lIndex,
    VARIANT *pvVersion,
    VARIANT *pvLocation,
    VARIANT *pvDate
    )
{
    HRESULT hr = S_OK;
    FILETIME ftBackupTime;
    WORD wFatDate;
    WORD wFatTime;
    WCHAR Location[MD_BACKUP_MAX_LEN];
    DWORD dwVersion;

    VariantInit( pvVersion );
    VariantInit( pvLocation );
    VariantInit( pvDate );

    Location[0] = L'\0';

    if (bstrLocation) {
        wcscpy((LPWSTR)Location, (LPWSTR)bstrLocation);
    }

    hr = _pAdminBase->EnumBackups((LPWSTR)Location,
                                  (PDWORD)&dwVersion,
                                  &ftBackupTime,
                                  lIndex);

    if (SUCCEEDED(hr)) {

        pvVersion->vt = VT_I4;
        pvLocation->vt = VT_BSTR;
        pvDate->vt = VT_DATE;

        if (!FileTimeToDosDateTime( &ftBackupTime, &wFatDate, &wFatTime)){
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        if (!DosDateTimeToVariantTime(wFatDate, wFatTime, &pvDate->date)){
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        pvVersion->lVal = (long)dwVersion;

        hr = ADsAllocString(
                (LPWSTR)Location,
                &pvLocation->bstrVal
                );
    }

error :

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISComputer::DeleteBackup
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07/14/96  SophiaC Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CIISComputer::DeleteBackup(
    BSTR bstrLocation,
    LONG lVersion
    )
{
    HRESULT hr = S_OK;
    hr =  _pAdminBase->DeleteBackup((LPWSTR)bstrLocation,
                                    lVersion
                                    );
    RRETURN(hr);
}


STDMETHODIMP
CIISComputer::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }

    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);

    if (SUCCEEDED(hr)) {
        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISComputer::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP
CIISComputer::ADSIReleaseObject()
{
    delete this;
    RRETURN(S_OK);
}


STDMETHODIMP
CIISComputer::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);
    
    if (IsEqualIID(iid, IID_IISComputer)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IISComputer2)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;
                                
    } else if (IsEqualIID(iid, IID_IUnknown)) {
        
        //
        // probably not needed since our 3rd party extension does not stand 
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {
        
        *ppv = NULL;
        return E_NOINTERFACE;
    } 


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IISComputer.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();       

    return S_OK;
}


//
// IADsExtension::Operate()
//

STDMETHODIMP
CIISComputer::Operate(
    THIS_ DWORD dwCode,
    VARIANT varUserName,
    VARIANT varPassword,
    VARIANT varFlags
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\capp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  capp.cxx
//
//  Contents:  Contains methods for CIISApp object
//
//  History:   20-1-98     SophiaC    Created.
//
//----------------------------------------------------------------------------

#include "iisext.hxx"
#pragma hdrstop
#define INITGUID

//  Class CIISApp

DEFINE_IPrivateDispatch_Implementation(CIISApp)
DEFINE_DELEGATING_IDispatch_Implementation(CIISApp)
DEFINE_CONTAINED_IADs_Implementation(CIISApp)
DEFINE_IADsExtension_Implementation(CIISApp)

CIISApp::CIISApp():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _pszServerName(NULL),
        _pszMetaBasePath(NULL),
        _pAdminBase(NULL),
        _pWamAdmin(NULL),
        _pWamAdmin2(NULL),
        _pAppAdmin(NULL),
        _pDispMgr(NULL),
        _fDispInitialized(FALSE)
{
    ENLIST_TRACKING(CIISApp);
}

HRESULT
CIISApp::CreateApp(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    CCredentials Credentials;
    CIISApp FAR * pApp = NULL;
    HRESULT hr = S_OK;
    BSTR bstrAdsPath = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer * pLexer = NULL;
    LPWSTR pszIISPathName = NULL;

    hr = AllocateAppObject(pUnkOuter, Credentials, &pApp);
    BAIL_ON_FAILURE(hr);

    //
    // get ServerName and pszPath
    //

    hr = pApp->_pADs->get_ADsPath(&bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    pLexer = new CLexer();
    hr = pLexer->Initialize(bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(pLexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(bstrAdsPath);
    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pApp->InitializeAppObject(
                pObjectInfo->TreeName,
                pszIISPathName );
    BAIL_ON_FAILURE(hr);

    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pApp;

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    *ppvObj = NULL;

    delete pApp;

    RRETURN(hr);

}


CIISApp::~CIISApp( )
{

    if (_pWamAdmin) {
        _pWamAdmin->Release();
    }

    if (_pWamAdmin2) {
        _pWamAdmin2->Release();
    }

    if (_pAppAdmin) {
        _pAppAdmin->Release();
    }

    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath) {
        FreeADsStr(_pszMetaBasePath);
    }

    delete _pDispMgr;
}


STDMETHODIMP
CIISApp::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);
}

HRESULT
CIISApp::AllocateAppObject(
    IUnknown *pUnkOuter,
    CCredentials& Credentials,
    CIISApp ** ppApp
    )
{
    CIISApp FAR * pApp = NULL;
    IADs FAR *  pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pApp = new CIISApp();
    if (pApp == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISExt,
                IID_IISApp3,
                (IISApp3 *)pApp,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the IADs Pointer, but again do NOT ref-count
    // this pointer - we keep the pointer around, but do
    // a release immediately.
    //

    hr = pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
    pADs->Release();
    pApp->_pADs = pADs;

    //
    // Store the pointer to the pUnkOuter object
    // AND DO NOT add ref this pointer
    //

    pApp->_pUnkOuter = pUnkOuter;

    pApp->_Credentials = Credentials;
    pApp->_pDispMgr = pDispMgr;
    *ppApp = pApp;

    RRETURN(hr);

error:

    delete  pDispMgr;
    delete  pApp;

    RRETURN(hr);
}

HRESULT
CIISApp::InitializeAppObject(
    LPWSTR pszServerName,
    LPWSTR pszPath
    )
{
    HRESULT hr = S_OK;
    DWORD dwState;

    if (pszServerName) {
        _pszServerName = AllocADsStr(pszServerName);

        if (!_pszServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pszPath) {
        _pszMetaBasePath = AllocADsStr(pszPath);

        if (!_pszMetaBasePath) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = InitServerInfo(pszServerName, &_pAdminBase);
    BAIL_ON_FAILURE(hr);

	hr = InitWamAdm(pszServerName);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

HRESULT
CIISApp::InitWamAdm(
    LPWSTR pszServerName
    )
{
    HRESULT hr = S_OK;

    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (pszServerName == NULL || _wcsicmp(pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName =  pszServerName;
    }

    csiName.pAuthInfo = NULL;

    
    MULTI_QI  rgInterfaces[3];

    rgInterfaces[0].hr = NOERROR;
    rgInterfaces[0].pIID = &IID_IWamAdmin;
    rgInterfaces[0].pItf = NULL;

    rgInterfaces[1].hr = NOERROR;
    rgInterfaces[1].pIID = &IID_IIISApplicationAdmin;
    rgInterfaces[1].pItf = NULL;

    rgInterfaces[2].hr = NOERROR;
    rgInterfaces[2].pIID = &IID_IWamAdmin2;
    rgInterfaces[2].pItf = NULL;

    hr = CoCreateInstanceEx( CLSID_WamAdmin,
                             NULL,
                             CLSCTX_SERVER,
                             pcsiParam,
                             3,
                             rgInterfaces
                             );

    if( SUCCEEDED(hr) )
    {
        if( SUCCEEDED(rgInterfaces[0].hr) )
        {
            _pWamAdmin = (IWamAdmin *)rgInterfaces[0].pItf;
        }

        if( SUCCEEDED(rgInterfaces[1].hr) )
        {
            _pAppAdmin = (IIISApplicationAdmin *)rgInterfaces[1].pItf;
        }

        if( SUCCEEDED(rgInterfaces[2].hr) )
        {
            _pWamAdmin2 = (IWamAdmin2 *)rgInterfaces[2].pItf;
        }
    }

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppCreate
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07/14/97  SophiaC    Created
//
// Notes:
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppCreate(
    THIS_ VARIANT_BOOL bSetInProcFlag
    )
{
    HRESULT hr = S_OK;
    BOOL boolCreatePool = FALSE;
    LPWSTR pszPoolName;

    if (_pAppAdmin) {
        
        pszPoolName = NULL;
        boolCreatePool = FALSE;

        hr = _pAppAdmin->CreateApplication((LPWSTR)_pszMetaBasePath,
                               bSetInProcFlag ? TRUE : FALSE,
                               pszPoolName,
                               boolCreatePool
                               );
    }

    else if (_pWamAdmin) {
        hr = _pWamAdmin->AppCreate((LPWSTR)_pszMetaBasePath, 
                           bSetInProcFlag ? TRUE : FALSE);
    }

    else {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISApp::AppCreate2(                  
    IN LONG lAppMode
    )
{
    HRESULT hr = S_OK;
    BOOL boolCreatePool = FALSE;
    LPWSTR pszPoolName;

    if (_pAppAdmin) {
        pszPoolName = NULL;
        boolCreatePool = FALSE;
             
        hr = _pAppAdmin->CreateApplication((LPWSTR)_pszMetaBasePath,
                               lAppMode,
                               pszPoolName,
                               boolCreatePool
                               );
    }

    else if (_pWamAdmin2) {
        hr = _pWamAdmin2->AppCreate2( (LPWSTR)_pszMetaBasePath, lAppMode );
    }

    else {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISApp::AppCreate3(                  
    IN LONG lAppMode,
    VARIANT bstrAppPoolId,
    VARIANT bCreatePool
    )
{
    HRESULT hr = S_OK;
    BOOL boolCreatePool = FALSE;
    LPWSTR pszPoolName;

    if (_pAppAdmin) {
        if (bstrAppPoolId.vt == VT_BSTR) {
            pszPoolName = bstrAppPoolId.bstrVal;
        }
        else {
            pszPoolName = NULL;
        }

        if (bCreatePool.vt == VT_BOOL) {
            if (bCreatePool.boolVal == VARIANT_TRUE) {
                boolCreatePool = TRUE;
            }
            else {
                boolCreatePool = FALSE;
            }
        }

             
        hr = _pAppAdmin->CreateApplication((LPWSTR)_pszMetaBasePath,
                               lAppMode,
                               pszPoolName,
                               boolCreatePool
                               );
    }

    else if (_pWamAdmin2) {
        hr = _pWamAdmin2->AppCreate2( (LPWSTR)_pszMetaBasePath, lAppMode );
    }

    else {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppDelete
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07/14/96 SophiaC  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppDelete(THIS)
{
    HRESULT hr = S_OK;

    if (_pAppAdmin) {
        hr = _pAppAdmin->DeleteApplication((LPWSTR)_pszMetaBasePath, FALSE);
    }
    
    else if (_pWamAdmin) {
        hr = _pWamAdmin->AppDelete((LPWSTR)_pszMetaBasePath, FALSE);
    }

    else {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppDeleteRecursive
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07/14/96 SophiaC  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppDeleteRecursive(THIS)
{
    HRESULT hr = S_OK;

    if (_pAppAdmin) {
        hr = _pAppAdmin->DeleteApplication((LPWSTR)_pszMetaBasePath, TRUE);
    }

    else if (_pWamAdmin) {
        hr = _pWamAdmin->AppDelete((LPWSTR)_pszMetaBasePath, TRUE);
    }

    else {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppUnLoad
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppUnLoad(THIS)
{
    HRESULT hr = S_OK;
    hr = _pWamAdmin->AppUnLoad((LPWSTR)_pszMetaBasePath, FALSE);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppUnLoadRecursive
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppUnLoadRecursive(THIS)
{
    HRESULT hr = S_OK;
    hr = _pWamAdmin->AppUnLoad((LPWSTR)_pszMetaBasePath, TRUE);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppDisable
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppDisable(THIS)
{
    HRESULT hr = S_OK;
    hr = _pWamAdmin->AppDeleteRecoverable((LPWSTR)_pszMetaBasePath, FALSE);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppDisableRecursive
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppDisableRecursive(THIS)
{
    HRESULT hr = S_OK;
    hr = _pWamAdmin->AppDeleteRecoverable((LPWSTR)_pszMetaBasePath, TRUE);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppGetStatus
//
//  Synopsis:  
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07/14/96  SophiaC Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppGetStatus(THIS_ DWORD * pdwStatus)
{
    HRESULT hr = S_OK;
    hr = _pWamAdmin->AppGetStatus((LPWSTR)_pszMetaBasePath, pdwStatus);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppGetStatus2
//
//  Synopsis:   AppGetStatus is not automation compliant. This version
//              is.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppGetStatus2( LONG * lpStatus )
{
    HRESULT     hr;
    hr = _pWamAdmin->AppGetStatus((LPWSTR)_pszMetaBasePath, (LPDWORD)lpStatus);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppEnable
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppEnable(THIS)
{
    HRESULT hr = S_OK;
    hr = _pWamAdmin->AppRecover((LPWSTR)_pszMetaBasePath, FALSE);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AspAppRestart
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AspAppRestart(THIS)
{
    HRESULT hr = S_OK;
    DWORD dwState = 0;
    METADATA_HANDLE hObjHandle = NULL;

    hr = IISCheckApp(METADATA_MASTER_ROOT_HANDLE);
    BAIL_ON_FAILURE(hr);

    hr = IISGetState(METADATA_MASTER_ROOT_HANDLE, &dwState);
    BAIL_ON_FAILURE(hr);

    //
    // Write the value to the metabase
    //

    hr = OpenAdminBaseKey(
               _pszServerName,
               _pszMetaBasePath,
               METADATA_PERMISSION_WRITE,
               &_pAdminBase,
               &hObjHandle
               );
    BAIL_ON_FAILURE(hr);

    dwState = dwState ? 0 : 1;
    hr = IISSetState(hObjHandle, dwState);
    BAIL_ON_FAILURE(hr);

    dwState = dwState ? 0 : 1;
    hr = IISSetState(hObjHandle, dwState);
    BAIL_ON_FAILURE(hr);

    CloseAdminBaseKey(_pAdminBase, hObjHandle);

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppEnableRecursive
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppEnableRecursive(THIS)
{
    HRESULT hr = S_OK;
    hr = _pWamAdmin->AppRecover((LPWSTR)_pszMetaBasePath, TRUE);
    RRETURN(hr);
}

HRESULT
CIISApp::IISSetState(
    METADATA_HANDLE hObjHandle,
    DWORD dwState
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)&dwState;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_ASP_ENABLEAPPLICATIONRESTART,
                       METADATA_INHERIT,
                       ASP_MD_UT_APP,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = _pAdminBase->SetData(
             hObjHandle,
             L"",
             &mdrMDData
             );

    RRETURN(hr);
}

HRESULT
CIISApp::IISCheckApp(
    METADATA_HANDLE hObjHandle
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize;
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer;
    WCHAR DataBuf[MAX_PATH];
    DWORD dwState;

    pBuffer = (LPBYTE) DataBuf;
    dwBufferSize = MAX_PATH;
    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_APP_ROOT,
                       METADATA_INHERIT|METADATA_ISINHERITED,
                       IIS_MD_UT_FILE,
                       STRING_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = _pAdminBase->GetData(
             hObjHandle,
             _pszMetaBasePath,
             &mdrMDData,
             &dwBufferSize
             );
    BAIL_ON_FAILURE(hr);

    if (mdrMDData.dwMDAttributes & METADATA_ISINHERITED) {
        hr = MD_ERROR_DATA_NOT_FOUND;
        BAIL_ON_FAILURE(hr);
    }

    pBuffer = (LPBYTE) &dwState;
    dwBufferSize = sizeof(DWORD);
    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_APP_ISOLATED,
                       METADATA_INHERIT|METADATA_ISINHERITED,
                       IIS_MD_UT_WAM,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = _pAdminBase->GetData(
             hObjHandle,
             _pszMetaBasePath,
             &mdrMDData,
             &dwBufferSize
             );
    BAIL_ON_FAILURE(hr);

    if (mdrMDData.dwMDAttributes & METADATA_ISINHERITED) {
        hr = MD_ERROR_DATA_NOT_FOUND;
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);

}

HRESULT
CIISApp::IISGetState(
    METADATA_HANDLE hObjHandle,
    PDWORD pdwState
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)pdwState;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_ASP_ENABLEAPPLICATIONRESTART,
                       METADATA_INHERIT,
                       ASP_MD_UT_APP,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = _pAdminBase->GetData(
             hObjHandle,
             _pszMetaBasePath,
             &mdrMDData,
             &dwBufferSize
             );

    RRETURN(hr);

}


STDMETHODIMP
CIISApp::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }

    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);

    if (SUCCEEDED(hr)) {
        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISApp::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{

    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}

STDMETHODIMP
CIISApp::ADSIReleaseObject()
{
    delete this;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISApp::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);

    if (IsEqualIID(iid, IID_IISApp)) {

        *ppv = (IISApp3 FAR *) this;

    } 
    else if (IsEqualIID(iid, IID_IISApp2)) {
        *ppv = (IISApp3 FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IISApp3)) {
        *ppv = (IISApp3 FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IISApp.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();

    return S_OK;
}



//
// IADsExtension::Operate()
//

STDMETHODIMP
CIISApp::Operate(
    THIS_ DWORD dwCode,
    VARIANT varUserName,
    VARIANT varPassword,
    VARIANT varFlags
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\crmap.cxx ===
/*++


Copyright (c) 1997  Microsoft Corporation

Module Name:

    crmap.cxx

Abstract:

    ADSIIS cert mapper object

Author:

    Philippe Choquier (phillich)    10-Apr-1997

--*/

#include "iisext.hxx"
#pragma hdrstop

#include <nsepname.hxx>
#include <dbgutil.h>

DEFINE_IPrivateDispatch_Implementation(CIISDsCrMap)
DEFINE_DELEGATING_IDispatch_Implementation(CIISDsCrMap)
DEFINE_CONTAINED_IADs_Implementation(CIISDsCrMap)
DEFINE_IADsExtension_Implementation(CIISDsCrMap)

#define LOCAL_MAX_SIZE 32

//
// Local functions
//

HRESULT
GetStringFromBSTR( 
    BSTR    bstr,
    LPSTR*  psz,
    LPDWORD pdwLen,
    BOOL    fAddDelimInCount = TRUE
    );

HRESULT
GetStringFromVariant( 
    VARIANT*    pVar,
    LPSTR*      psz,
    LPDWORD     pdwLen,
    BOOL        fAddDelimInCount = TRUE
    );

VOID
FreeString( 
    LPSTR   psz 
    );

HRESULT
SetBSTR( 
    BSTR*   pbstrRet,
    DWORD   cch, 
    LPBYTE  sz 
    );

HRESULT
SetVariantAsByteArray(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    );

HRESULT
SetVariantAsBSTR(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    );

HRESULT
SetVariantAsLong(
    VARIANT*    pvarReturn, 
    DWORD       dwV
    );

HRESULT 
VariantResolveDispatch(
    VARIANT *   pVarOut, 
    VARIANT *   pVarIn
    );

//
//
//

HRESULT
CIISDsCrMap::CreateMapping(
    VARIANT     vCert,
    BSTR        bstrNtAcct,
    BSTR        bstrNtPwd,
    BSTR        bstrName,
    LONG        lEnabled
    )
/*++

Routine Description:

    Create a mapping entry

Arguments:

    vCert - X.509 certificate
    bstrNtAcct - NT acct to map to
    bstrNtPwd - NT pwd
    bstrName - friendly name for mapping entry
    lEnabled - 1 to enable mapping entry, 0 to disable it

Returns:

    COM status

--*/
{
    HRESULT     hres;
    LPBYTE      pbCert = NULL;
    DWORD       cCert;
    LPSTR       pszNtAcct = NULL;
    LPSTR       pszNtPwd = NULL;
    LPSTR       pszName = NULL;
    LPBYTE      pRes;
    DWORD       cRes;
    DWORD       cName;
    DWORD       cNtAcct;
    DWORD       cNtPwd;
    WCHAR       achIndex[LOCAL_MAX_SIZE];
    VARIANT     vOldAcct;
    VARIANT     vOldCert;
    VARIANT     vOldPwd;
    VARIANT     vOldName;
    VARIANT     vOldEnabledFlag;
    PCCERT_CONTEXT pcCert = NULL;

    //
    // Do some sanity checks on the cert 
    //
    if ( SUCCEEDED( hres = GetStringFromVariant( &vCert, 
                                                 (LPSTR*)&pbCert,
                                                 &cCert,
                                                 FALSE ) ) )
    {
        //
        // try to construct a cert context
        //
        if ( !( pcCert = CertCreateCertificateContext( X509_ASN_ENCODING,
                                                       pbCert,
                                                       cCert ) ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Invalid cert passed to CreateMapping()\n"));
            //
            // If the decoding fails, GetLastError() returns an ASN1 decoding
            // error that is obtained by subtracting CRYPT_E_OSS_ERROR from the returned
            // error and looking in file asn1code.h for the actual error. To avoid the
            // cryptic ASN1 errors, we'll just return a general "invalid arg" error 
            //
            hres = RETURNCODETOHRESULT( E_INVALIDARG );
            FreeString( (LPSTR) pbCert );
            goto Exit;
        }

        CertFreeCertificateContext( pcCert );
    }
    else
    {
        goto Exit;
    }

    //
    // check if we already have a mapping for this cert; if we do, we'll replace that mapping
    // with the new one
    //
    if ( SUCCEEDED( hres = GetMapping( IISMAPPER_LOCATE_BY_CERT,
                                       vCert,
                                       &vOldCert,
                                       &vOldAcct,
                                       &vOldPwd,
                                       &vOldName,
                                       &vOldEnabledFlag ) ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Replacing old 1-1 cert mapping with new mapping\n"));

        if ( FAILED( hres = SetName( IISMAPPER_LOCATE_BY_CERT,
                                     vCert,
                                     bstrName ) ) ||
             FAILED( hres = SetAcct( IISMAPPER_LOCATE_BY_CERT,
                                     vCert,
                                     bstrNtAcct ) ) ||
             FAILED( hres = SetPwd( IISMAPPER_LOCATE_BY_CERT,
                                    vCert,
                                    bstrNtPwd ) ) ||
             FAILED( hres = SetEnabled( IISMAPPER_LOCATE_BY_CERT,
                                        vCert,
                                        lEnabled ) ) )
        {
            hres; //NOP - Something failed 
        }
    }
    //
    // New mapping
    //
    else if ( hres == RETURNCODETOHRESULT( ERROR_PATH_NOT_FOUND ) )
    {
        //
        // check mapping exists, create if not
        //
        hres = OpenMd( L"Cert11", METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ );

        if ( hres == RETURNCODETOHRESULT( ERROR_PATH_NOT_FOUND ) )
        {
            if ( SUCCEEDED( hres = OpenMd( L"", 
                                           METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
            {
                hres = CreateMdObject( L"Cert11" );
                CloseMd( FALSE );

                // Reopen to the correct node.
                hres = OpenMd( L"Cert11", METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ );
            }
        }

        if ( FAILED( hres ) )
        {
            goto Exit;
        }

        //
        // adding mapping cert "0" means add @ end of list
        //

        if ( SUCCEEDED( hres = CreateMdObject( L"mappings/0" ) ) )
        {
            if ( SUCCEEDED( hres = GetMdData( L"", MD_NSEPM_ACCESS_CERT, DWORD_METADATA, &
                                              cRes, &pRes ) ) )
            {
                if ( cRes == sizeof(DWORD ) )
                {
                    wsprintfW( achIndex, L"mappings/%u", *(LPDWORD)pRes );

                    if ( FAILED( hres = GetStringFromBSTR( bstrNtAcct, &pszNtAcct, &cNtAcct ) ) ||
                         FAILED( hres = GetStringFromBSTR( bstrNtPwd, &pszNtPwd, &cNtPwd ) ) ||
                         FAILED( hres = GetStringFromBSTR( bstrName, &pszName, &cName ) ) ||
                         FAILED( hres = SetMdData( achIndex, MD_MAPENABLED, DWORD_METADATA, 
                                                   sizeof(DWORD), (LPBYTE)&lEnabled ) ) ||
                         FAILED( hres = SetMdData( achIndex, MD_MAPNAME, STRING_METADATA, 
                                                   cName, (LPBYTE)pszName ) ) ||
                         FAILED( hres = SetMdData( achIndex, MD_MAPNTPWD, STRING_METADATA, 
                                                   cNtPwd, (LPBYTE)pszNtPwd ) ) ||
                         FAILED( hres = SetMdData( achIndex, MD_MAPNTACCT, STRING_METADATA, 
                                                   cNtAcct, (LPBYTE)pszNtAcct ) ) ||
                         FAILED( hres = SetMdData( achIndex, MD_MAPCERT, BINARY_METADATA, 
                                                   cCert, (LPBYTE)pbCert ) ) )
                    {
                    }
                }   
                else
                {
                    hres = E_FAIL;
                }
            }
        }
    }

    CloseMd( SUCCEEDED( hres ) );

    FreeString( (LPSTR)pbCert );
    FreeString( pszNtAcct );
    FreeString( pszNtPwd );
    FreeString( pszName );

Exit:

    return hres;
}


HRESULT
CIISDsCrMap::GetMapping(
    LONG        lMethod,
    VARIANT     vKey,
    VARIANT*    pvCert,
    VARIANT*    pbstrNtAcct,
    VARIANT*    pbstrNtPwd,
    VARIANT*    pbstrName,
    VARIANT*    plEnabled
    )
/*++

Routine Description:

    Get a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    pvCert - X.509 certificate
    pbstrNtAcct - NT acct to map to
    pbstrNtPwd - NT pwd
    pbstrName - friendly name for mapping entry
    plEnabled - 1 to enable mapping entry, 0 to disable it

Returns:

    COM status

--*/
{
    WCHAR       achIndex[LOCAL_MAX_SIZE];
    HRESULT     hres;
    DWORD       dwLen;
    LPBYTE      pbData;

    VariantInit( pvCert );
    VariantInit( pbstrNtAcct );
    VariantInit( pbstrNtPwd );
    VariantInit( pbstrName );
    VariantInit( plEnabled );

    if ( SUCCEEDED( hres = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hres = Locate( lMethod, vKey, achIndex )) )
        {
            if ( SUCCEEDED( hres = GetMdData( achIndex, MD_MAPCERT, BINARY_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hres = SetVariantAsByteArray( pvCert, dwLen, pbData );
                LocalFree( pbData );
            }
            else
            {
                goto Done;
            }

            if ( SUCCEEDED( hres = GetMdData( achIndex, MD_MAPNTACCT, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hres = SetVariantAsBSTR( pbstrNtAcct, dwLen, pbData );
                LocalFree( pbData );
            }
            else
            {
                goto Done;
            }

            if ( SUCCEEDED( hres = GetMdData( achIndex, MD_MAPNTPWD, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hres = SetVariantAsBSTR( pbstrNtPwd, dwLen, pbData );
                LocalFree( pbData );
            }
            else
            {
                goto Done;
            }

            if ( SUCCEEDED( hres = GetMdData( achIndex, MD_MAPNAME, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hres = SetVariantAsBSTR( pbstrName, dwLen, pbData );
                LocalFree( pbData );
            }
            else
            {
                goto Done;
            }

            if ( FAILED( hres = GetMdData( achIndex, MD_MAPENABLED, STRING_METADATA, &dwLen, 
                                           &pbData ) ) )
            {
                SetVariantAsLong( plEnabled, FALSE );
            }
            else
            {
                SetVariantAsLong( plEnabled, *(LPDWORD)pbData );
                LocalFree( pbData );
            }
        }

Done:
        CloseMd( FALSE );
    }

    return hres;
}


HRESULT
CIISDsCrMap::DeleteMapping(
    LONG        lMethod,
    VARIANT     vKey
    )
/*++

Routine Description:

    Delete a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping

Returns:

    COM status

--*/
{
    WCHAR       achIndex[LOCAL_MAX_SIZE];
    HRESULT     hres;

    if ( SUCCEEDED( hres = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hres = Locate( lMethod, vKey, achIndex )) )
        {
            hres = DeleteMdObject( achIndex );
        }
        CloseMd( TRUE );
    }

    return hres;
}


HRESULT
CIISDsCrMap::SetEnabled(
    LONG        lMethod,
    VARIANT     vKey,
    LONG        lEnabled
    )
/*++

Routine Description:

    Set the enable flag on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    lEnabled - 1 to enable, 0 to disable

Returns:

    COM status

--*/
{
    WCHAR       achIndex[LOCAL_MAX_SIZE];
    HRESULT     hres;

    if ( SUCCEEDED( hres = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hres = Locate( lMethod, vKey, achIndex )) )
        {
            hres = SetMdData( achIndex, MD_MAPENABLED, DWORD_METADATA, sizeof(DWORD), (LPBYTE)&lEnabled );
        }
        CloseMd( TRUE );
    }

    return hres;
}


HRESULT
CIISDsCrMap::SetName(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrName
    )
/*++

Routine Description:

    Set the Name on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    bstrName - name to assign to mapping entry

Returns:

    COM status

--*/
{
    return SetString( lMethod, vKey, bstrName, MD_MAPNAME );
}


HRESULT
CIISDsCrMap::SetString(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrName,
    DWORD       dwProp
    )
/*++

Routine Description:

    Set a string property on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    bstrName - string content to assign to mapping entry
    dwProp - property ID to assign to

Returns:

    COM status

--*/
{
    WCHAR       achIndex[LOCAL_MAX_SIZE];
    LPSTR       pszName = NULL;
    HRESULT     hres;
    DWORD       dwLen;


    if ( FAILED( hres = GetStringFromBSTR( bstrName, &pszName, &dwLen, TRUE ) ) )
    {
        return hres;
    }

    if ( SUCCEEDED( hres = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hres = Locate( lMethod, vKey, achIndex )) )
        {
            hres = SetMdData( achIndex, dwProp, STRING_METADATA, dwLen, (LPBYTE)pszName );
        }
        CloseMd( TRUE );
    }

    FreeString( pszName );

    return hres;
}


HRESULT
CIISDsCrMap::SetPwd(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrPwd
    )
/*++

Routine Description:

    Set the Password on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    bstrPwd - password to assign to mapping entry

Returns:

    COM status

--*/
{
    return SetString( lMethod, vKey, bstrPwd, MD_MAPNTPWD );
}


HRESULT
CIISDsCrMap::SetAcct(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrAcct
    )
/*++

Routine Description:

    Set the NT account name on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    bstrAcct - NT account name to assign to mapping entry

Returns:

    COM status

--*/
{
    return SetString( lMethod, vKey, bstrAcct, MD_MAPNTACCT );
}



////


HRESULT
CIISDsCrMap::OpenMd(
    LPWSTR  pszOpenPath,
    DWORD   dwPermission
    )
/*++

Routine Description:

    Open metabase using path & permission
    path is relative to the top of the name space extension ( i.e. /.../<nsepm> )

Arguments:

    pszOpenPath - path to open inside name space extension
    dwPermission - metabase permission ( read/write )

Returns:

    COM status

--*/
{
    HRESULT hres;
    LPWSTR  pszPath;
    UINT    cL = wcslen( m_pszMetabasePath );

    pszPath = (LPWSTR)LocalAlloc( LMEM_FIXED, (wcslen(pszOpenPath) + 1 + cL + 1)*sizeof(WCHAR) );

    if ( pszPath == NULL )
    {
        return E_OUTOFMEMORY;
    }

    memcpy( pszPath, m_pszMetabasePath, cL * sizeof(WCHAR) );
    if ( cL && m_pszMetabasePath[cL-1] != L'/' && *pszOpenPath && *pszOpenPath != L'/' )
    {
        pszPath[cL++] = L'/';
    }
    wcscpy( pszPath + cL, pszOpenPath );

    hres = OpenAdminBaseKey(
                m_pszServerName,
                pszPath,
                dwPermission,
                &m_pcAdmCom,
                &m_hmd
                );

    LocalFree( pszPath );

	if ( FAILED(hres) )
	{
        m_hmd = NULL;
    }

    return hres;
}


HRESULT
CIISDsCrMap::CloseMd(
    BOOL fSave
    )
/*++

Routine Description:

    close metabase

Arguments:

    fSave - TRUE to save data immediatly

Returns:

    COM status

--*/
{
    CloseAdminBaseKey( m_pcAdmCom, m_hmd );
    m_hmd = NULL;
    
    if ( m_pcAdmCom && fSave )
    {
        m_pcAdmCom->SaveData();
    }

    return S_OK;
}


HRESULT
CIISDsCrMap::DeleteMdObject(
    LPWSTR  pszKey
    )
/*++

Routine Description:

    Delete metabase object in an opened tree
    OpenMd() must be called 1st

Arguments:

    pszKey - key to delete in opened metabase

Returns:

    COM status

--*/
{
    return m_pcAdmCom->DeleteKey( m_hmd, pszKey );
}


HRESULT
CIISDsCrMap::CreateMdObject(
    LPWSTR  pszKey
    )
/*++

Routine Description:

    Create metabase object in an opened tree
    OpenMd() must be called 1st

Arguments:

    pszKey - key to create in opened metabase

Returns:

    COM status

--*/
{
    return m_pcAdmCom->AddKey( m_hmd, pszKey );
}


HRESULT
CIISDsCrMap::SetMdData( 
    LPWSTR  achIndex, 
    DWORD   dwProp,
    DWORD   dwDataType,
    DWORD   dwDataLen,
    LPBYTE  pbData 
    )
/*++

Routine Description:

    Set a metabase property
    OpenMd() must be called 1st
    Property will be stored with NULL attribute, except for MD_MAPPWD
     which will be stored with METADATA_SECURE

Arguments:

    achIndex - key name where to store property
    dwProp - property ID
    dwDataType - property data type
    dwDataLen - property length
    pbData - property value

Returns:

    COM status

--*/
{
    METADATA_RECORD     md;

    md.dwMDDataLen = dwDataLen;
    md.dwMDDataType = dwDataType;
    md.dwMDIdentifier = dwProp;
    md.dwMDAttributes = (dwProp == MD_MAPPWD) ? METADATA_SECURE : 0;
    md.pbMDData = pbData;

    return m_pcAdmCom->SetData( m_hmd, achIndex, &md );
}


HRESULT
CIISDsCrMap::GetMdData( 
    LPWSTR  achIndex, 
    DWORD   dwProp,
    DWORD   dwDataType,
    LPDWORD pdwDataLen,
    LPBYTE* ppbData 
    )
/*++

Routine Description:

    Get a metabase property
    OpenMd() must be called 1st

Arguments:

    achIndex - key name where to get property
    dwProp - property ID
    dwDataType - property data type
    pdwDataLen - property length
    ppData - property value, to be freed using LocalFree() on successfull return

Returns:

    COM status

--*/
{
    HRESULT             hres;
    METADATA_RECORD     md;
    DWORD               dwRequired;

    md.dwMDDataLen = 0;
    md.dwMDDataType = dwDataType;
    md.dwMDIdentifier = dwProp;
    md.dwMDAttributes = 0;
    md.pbMDData = NULL;

    if ( FAILED(hres = m_pcAdmCom->GetData( m_hmd, achIndex, &md, &dwRequired )) )
    {
        if ( hres == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER) )
        {
            if ( (*ppbData = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired )) == NULL )
            {
                return E_OUTOFMEMORY;
            }
            md.pbMDData = *ppbData;
            md.dwMDDataLen = dwRequired;
            hres = m_pcAdmCom->GetData( m_hmd, achIndex, &md, &dwRequired );
            *pdwDataLen = md.dwMDDataLen;
        }
    }
    else
    {
       *pdwDataLen = 0;
       *ppbData = NULL;
    }

    return hres;
}


//////

HRESULT
CIISDsCrMap::Locate(
    LONG    lMethod,
    VARIANT vKey,
    LPWSTR  pszResKey
    )
/*++

Routine Description:

    Locate a mapping entry based on key
    OpenMd() must be called 1st

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    pszResKey - 

Returns:

    COM status

--*/
{
    HRESULT     hres;
    LPSTR       pV = NULL;
    DWORD       cV;
    DWORD       dwProp;
    LPSTR       pRes;
    DWORD       cRes;
    BOOL        fAddDelim = TRUE;

    //
    // determine method
    //

    switch ( lMethod )
    {
        case IISMAPPER_LOCATE_BY_CERT:
            dwProp = MD_NSEPM_ACCESS_CERT;
            fAddDelim = FALSE;
            break;

        case IISMAPPER_LOCATE_BY_NAME:
            dwProp = MD_NSEPM_ACCESS_NAME;
            break;

        case IISMAPPER_LOCATE_BY_ACCT:
            dwProp = MD_NSEPM_ACCESS_ACCOUNT;
            break;

        case IISMAPPER_LOCATE_BY_INDEX:
            if ( SUCCEEDED( hres = GetStringFromVariant( &vKey, &pV, &cV, TRUE ) ) )
            {
                WCHAR       pwV[LOCAL_MAX_SIZE]; 
                int i = MultiByteToWideChar(CP_ACP, 0, pV, cV, pwV, LOCAL_MAX_SIZE);
                
                if (i ==0) 
                    return E_FAIL;  // MultiByteToWideChar failure
                if (i >= (int)(LOCAL_MAX_SIZE - wcslen(L"mappings/"))) 
                    return E_FAIL;  //pwV is too big for pszResKey
                
                wsprintfW( pszResKey, L"mappings/%s", pwV );
            }
            goto Exit;

        default:
            return E_FAIL;
    }

    //
    // get ptr to data
    //

    if ( SUCCEEDED( hres = GetStringFromVariant( &vKey, &pV, &cV, fAddDelim ) ) )
    {
        //
        // set search prop, get result
        //

        if ( SUCCEEDED( hres = SetMdData( L"", dwProp, BINARY_METADATA, cV, (LPBYTE)pV ) ) )
        {
            if ( SUCCEEDED( hres = GetMdData( L"", dwProp, DWORD_METADATA, &cRes, (LPBYTE*)&pRes ) ) )
            {
                if ( cRes == sizeof(DWORD ) )
                {
                    wsprintfW( pszResKey, L"mappings/%u", *(LPDWORD)pRes );
                }
                else
                {
                    hres = E_FAIL;
                }
                LocalFree( pRes );
            }
        }
    }

Exit:

    FreeString( pV );

    return hres;
}


HRESULT
GetStringFromBSTR( 
    BSTR    bstr,
    LPSTR*  psz,
    LPDWORD pdwLen,
    BOOL    fAddDelimInCount
    )
/*++

Routine Description:

    Allocate string buffer from BSTR

Arguments:

    bstr - bstr to convert from
    psz - updated with ptr to buffer, to be freed with FreeString()
    pdwLen - updated with strlen(string), incremented by 1 if fAddDelimInCount is TRUE
    fAddDelimInCount - TRUE to increment *pdwLen 

Returns:

    COM status

--*/
{
    UINT    cch = SysStringLen(bstr);
    UINT    cchT;

    // include NULL terminator

    *pdwLen = cch + (fAddDelimInCount ? 1 : 0);

	CHAR *szNew = (CHAR*)LocalAlloc( LMEM_FIXED, (2 * cch) + 1);			// * 2 for worst case DBCS string
	if (szNew == NULL)
    {
		return E_OUTOFMEMORY;
    }

	cchT = WideCharToMultiByte(CP_ACP, 0, bstr, cch + 1, szNew, (2 * cch) + 1, NULL, NULL);

	*psz = szNew;

	return NOERROR;
}


HRESULT
GetStringFromVariant( 
    VARIANT*    pVar,
    LPSTR*      psz,
    LPDWORD     pdwLen,
    BOOL        fAddDelim
    )
/*++

Routine Description:

    Allocate string buffer from BSTR

Arguments:

    pVar - variant to convert from. Recognizes BSTR, VT_ARRAY|VT_UI1, ByRef or ByVal
    psz - updated with ptr to buffer, to be freed with FreeString()
    pdwLen - updated with size of input, incremented by 1 if fAddDelimInCount is TRUE
    fAddDelimInCount - TRUE to increment *pdwLen 

Returns:

    COM status

--*/
{
    LPBYTE  pbV;
    UINT    cV;
    HRESULT hres;
    WORD    vt = V_VT(pVar);
    BOOL    fByRef = FALSE;
    VARIANT vOut;

    VariantInit( &vOut );

    if ( vt & VT_BYREF )
    {
        vt &= ~VT_BYREF;
        fByRef = TRUE;
    }

    if ( vt == VT_DISPATCH )
    {
        if ( FAILED(hres = VariantResolveDispatch( &vOut, pVar )) )
        {
            return hres;
        }
        pVar = &vOut;
        vt = V_VT(pVar);
        if ( fByRef = vt & VT_BYREF )
        {
            vt &= ~VT_BYREF;
        }
    }

    // if pVar is BSTR, convert to multibytes

    if ( vt == VT_VARIANT )
    {
        pVar = (VARIANT*)V_BSTR(pVar);
        vt = V_VT(pVar);
        if ( fByRef = vt & VT_BYREF )
        {
            vt &= ~VT_BYREF;
        }
    }

    if ( vt == VT_BSTR )
    {
        hres = GetStringFromBSTR( fByRef ? 
                                    *(BSTR*)V_BSTR(pVar) :
                                    V_BSTR(pVar), 
                                  psz, 
                                  pdwLen,
                                  fAddDelim );
    }
    else if( vt == (VT_ARRAY | VT_UI1) )
    {
        long        lBound, uBound, lItem;
        BYTE        bValue;
        SAFEARRAY*  pSafeArray;

   
        // array of VT_UI1 (probably OctetString)
   
        pSafeArray  = fByRef ? *(SAFEARRAY**)V_BSTR(pVar) : V_ARRAY( pVar );

        hres = SafeArrayGetLBound(pSafeArray, 1, &lBound);
        hres = SafeArrayGetUBound(pSafeArray, 1, &uBound);

        cV = uBound - lBound + 1;

        if ( !(pbV = (LPBYTE)LocalAlloc( LMEM_FIXED, cV )) )
        {
            hres = E_OUTOFMEMORY;
            goto Exit;
        }

        hres = S_OK;

        for( lItem = lBound; lItem <= uBound ; lItem++ )
        {
            hres  = SafeArrayGetElement( pSafeArray, &lItem, &bValue );
            if( FAILED( hres ) )
            {
                break;
            }
            pbV[lItem-lBound] = bValue;
        }

        *psz = (LPSTR)pbV;
        *pdwLen = cV;
    }
    else if( vt == (VT_ARRAY | VT_VARIANT) )
    {
        long        lBound, uBound, lItem;
        VARIANT     vValue;
        BYTE        bValue;
        SAFEARRAY*  pSafeArray;

   
        // array of VT_VARIANT (probably VT_I4 )
   
        pSafeArray  = fByRef ? *(SAFEARRAY**)V_BSTR(pVar) : V_ARRAY( pVar );

        hres = SafeArrayGetLBound(pSafeArray, 1, &lBound);
        hres = SafeArrayGetUBound(pSafeArray, 1, &uBound);

        cV = uBound - lBound + 1;

        if ( !(pbV = (LPBYTE)LocalAlloc( LMEM_FIXED, cV )) )
        {
            hres = E_OUTOFMEMORY;
            goto Exit;
        }

        hres = S_OK;

        for( lItem = lBound; lItem <= uBound ; lItem++ )
        {
            hres  = SafeArrayGetElement( pSafeArray, &lItem, &vValue );
            if( FAILED( hres ) )
            {
                break;
            }
            if ( V_VT(&vValue) == VT_UI1 )
            {
                bValue = V_UI1(&vValue);
            }
            else if ( V_VT(&vValue) == VT_I2 )
            {
                bValue = (BYTE)V_I2(&vValue);
            }
            else if ( V_VT(&vValue) == VT_I4 )
            {
                bValue = (BYTE)V_I4(&vValue);
            }
            else
            {
                bValue = 0;
            }
            pbV[lItem-lBound] = bValue;
        }

        *psz = (LPSTR)pbV;
        *pdwLen = cV;
    }
    else
    {
        hres = E_FAIL;
    }

Exit:
    VariantClear( &vOut );

    return hres;
}


VOID
FreeString( 
    LPSTR   psz 
    )
/*++

Routine Description:

    Free a string returned by GetStringFromVariant() or GetStringFromBTR()
    can be NULL

Arguments:

    psz - string to free, can be NULL

Returns:

    Nothing

--*/
{
    if ( psz )
    {
        LocalFree( psz );
    }
}


HRESULT
SetBSTR( 
    BSTR*   pbstrRet,
    DWORD   cch, 
    LPBYTE  sz 
    )
/*++

Routine Description:

    Build a BSTR from byte array

Arguments:

    pbstrRet - updated with BSTR
    cch - byte count in sz
    sz - byte array

Returns:

    COM status

--*/
{
	BSTR bstrRet;
	
	if (sz == NULL)
	{
		*pbstrRet = NULL;
		return(NOERROR);
	}
		
	// Allocate a string of the desired length
	// SysAllocStringLen allocates enough room for unicode characters plus a null
	// Given a NULL string it will just allocate the space

	bstrRet = SysAllocStringLen(NULL, cch);
	if (bstrRet == NULL)
    {
		return(E_OUTOFMEMORY);
    }

	// If we were given "", we will have cch=0.  return the empty bstr
	// otherwise, really copy/convert the string
	// NOTE we pass -1 as 4th parameter of MultiByteToWideChar for DBCS support

	if (cch != 0)
	{
		UINT cchTemp = 0;
		if (MultiByteToWideChar(CP_ACP, 0, (LPSTR)sz, -1, bstrRet, cch+1) == 0)
        {
			return(HRESULT_FROM_WIN32(GetLastError()));
        }

		// If there are some DBCS characters in the sz(Input), then, the character count of BSTR(DWORD) is 
		// already set to cch(strlen(sz)) in SysAllocStringLen(NULL, cch), we cannot change the count, 
		// and later call of SysStringLen(bstr) always returns the number of characters specified in the
		// cch parameter at allocation time.  Bad, because one DBCS character(2 bytes) will convert
		// to one UNICODE character(2 bytes), not 2 UNICODE characters(4 bytes).
		// Example: For input sz contains only one DBCS character, we want to see SysStringLen(bstr) 
		// = 1, not 2.

		bstrRet[cch] = 0;
		cchTemp = wcslen(bstrRet);
		if (cchTemp < cch)
		{
			BSTR bstrTemp = SysAllocString(bstrRet);
			SysFreeString(bstrRet);
			bstrRet = bstrTemp;	
			cch = cchTemp;
		}
	}

   if (bstrRet != NULL)
	   bstrRet[cch] = 0;
	*pbstrRet = bstrRet;

	return(NOERROR);
}


HRESULT
CIISDsCrMap::Create(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
/*++

Routine Description:

    Create a CIISDsCrMap

Arguments:

    pUnkOuter - ptr to iunknown
    riid - requested IID
    ppvObj - updated with ptr to requested IID

Returns:

    COM status

--*/
{
    CCredentials Credentials;
    CIISDsCrMap FAR * pMap = NULL;
    HRESULT hr = S_OK;
    BSTR bstrAdsPath = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer * pLexer = NULL;
    LPWSTR pszIISPathName = NULL;

    hr = AllocateObject(pUnkOuter, Credentials, &pMap);
    BAIL_ON_FAILURE(hr);

    //
    // get ServerName and pszPath
    //

    hr = pMap->_pADs->get_ADsPath(&bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    pLexer = new CLexer();
    hr = pLexer->Initialize(bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(pLexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(bstrAdsPath);
    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pMap->Init( pObjectInfo->TreeName,
                     pszIISPathName );
    BAIL_ON_FAILURE(hr);

    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pMap;

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    *ppvObj = NULL;

    delete pMap;

    RRETURN(hr);
}


STDMETHODIMP
CIISDsCrMap::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
/*++

Routine Description:

    Query interface to CIISDsCrMap

Arguments:

    iid - requested IID
    ppv - updated with ptr to requested IID

Returns:

    COM status

--*/
{
    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);
}


CIISDsCrMap::CIISDsCrMap(
    )
/*++

Routine Description:

    CIISDsCrMap constructor

Arguments:

    pADs - ptr to contained ADs
    Credentials - credential
    pDispMgr - ptr to dispatch manager

Returns:

    Nothing

--*/
{ 
    m_pcAdmCom = NULL; 
    m_hmd = NULL; 
    m_pszServerName = NULL; 
    m_pszMetabasePath = NULL; 
    m_ADsPath = NULL; 
    _pADs = NULL; 
    _pDispMgr = NULL; 
    ENLIST_TRACKING(CIISDsCrMap);
}


CIISDsCrMap::~CIISDsCrMap(
    )
/*++

Routine Description:

    CIISDsCrMap destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    if ( m_ADsPath ) 
    {
        ADsFreeString( m_ADsPath );
    }

    if ( m_pszServerName ) 
    {
        LocalFree( m_pszServerName );
    }

    if ( m_pszMetabasePath )
    {
        LocalFree( m_pszMetabasePath );
    }

    if ( _pDispMgr )
    {
        delete _pDispMgr;
    }
}


HRESULT
CIISDsCrMap::AllocateObject(
    IUnknown *pUnkOuter,
    CCredentials& Credentials,
    CIISDsCrMap ** ppMap
    )
/*++

Routine Description:

    Allocate CIISDsCrMap

Arguments:

    pUnkOuter - ptr to iunknown
    Credentials - credential
    ppMap - updated with ptr to IUnknown to Allocated object

Returns:

    COM status

--*/
{
    CIISDsCrMap FAR * pMap = NULL;
    IADs FAR * pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pMap = new CIISDsCrMap();
    if (pMap == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISExt,   //LIBID_ADs,
                IID_IISDsCrMap,
                (IISDsCrMap *)pMap,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the IADs Pointer, but again do NOT ref-count
    // this pointer - we keep the pointer around, but do
    // a release immediately.
    //

    hr = pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
    pADs->Release();
    pMap->_pADs = pADs;

    //
    // Store the pointer to the pUnkOuter object
    // AND DO NOT add ref this pointer
    //

    pMap->_pUnkOuter = pUnkOuter;

    pMap->m_Credentials = Credentials;
    pMap->_pDispMgr = pDispMgr;
    *ppMap = pMap;

    RRETURN(hr);

error:
    delete  pDispMgr;
    delete  pMap;

    RRETURN(hr);
}


HRESULT
CIISDsCrMap::Init( 
    LPWSTR  pszServerName, 
    LPWSTR  pszMetabasePath 
    )
/*++

Routine Description:

    Initialize CIISDsCrMap

Arguments:

    pszServerName - target computer name for metabase access
    pszParent - metabase path to IisMapper object

Returns:

    COM status

--*/
{
    UINT cL;

    cL = wcslen( pszServerName );
    if ( m_pszServerName = (LPWSTR)LocalAlloc( LMEM_FIXED, ( cL + 1 )*sizeof(WCHAR) ) )
    {
        memcpy( m_pszServerName, pszServerName, ( cL + 1 )*sizeof(WCHAR) );
    }
    else
    {
        return E_OUTOFMEMORY;
    }

    cL = wcslen( pszMetabasePath );
    while ( cL && pszMetabasePath[cL-1] != L'/' && pszMetabasePath[cL-1] != L'\\' )
    {
        --cL;
    }
    if ( m_pszMetabasePath = (LPWSTR)LocalAlloc( LMEM_FIXED, ( cL*sizeof(WCHAR) + sizeof(L"<nsepm>") )) )
    {
        memcpy( m_pszMetabasePath, pszMetabasePath, cL * sizeof(WCHAR) );
        memcpy( m_pszMetabasePath + cL, L"<nsepm>", sizeof(L"<nsepm>") );
    }
    else
    {
        return E_OUTOFMEMORY;
    }

	return InitServerInfo(pszServerName, &m_pcAdmCom);
}


HRESULT
SetVariantAsByteArray(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    )
/*++

Routine Description:

    Create variant as byte array

Arguments:

    pVarReturn - ptr to created variant
    cbLen - byte count
    pbIn - byte array

Returns:

    COM status

--*/
{
	HRESULT         hr;
	SAFEARRAYBOUND  rgsabound[1];
	BYTE *          pbData = NULL;

	// Set the variant type of the output parameter

	V_VT(pvarReturn) = VT_ARRAY|VT_UI1;
	V_ARRAY(pvarReturn) = NULL;

	// Allocate a SafeArray for the data

	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = cbLen;

	V_ARRAY(pvarReturn) = SafeArrayCreate(VT_UI1, 1, rgsabound);
	if (V_ARRAY(pvarReturn) == NULL)
	{
		return E_OUTOFMEMORY;
	}

	if (FAILED(SafeArrayAccessData(V_ARRAY(pvarReturn), (void **) &pbData)))
	{
		return E_UNEXPECTED;
	}

	memcpy(pbData, pbIn, cbLen );

	SafeArrayUnaccessData(V_ARRAY(pvarReturn));

	return NOERROR;
}


HRESULT
SetVariantAsBSTR(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    )
/*++

Routine Description:

    Create variant BSTR

Arguments:

    pVarReturn - ptr to created variant
    cbLen - byte count
    pbIn - byte array

Returns:

    COM status

--*/
{
	HRESULT         hr;

    V_VT(pvarReturn) = VT_BSTR;
    return SetBSTR( &V_BSTR(pvarReturn), cbLen, pbIn );
}


HRESULT
SetVariantAsLong(
    VARIANT*    pvarReturn, 
    DWORD       dwV
    )
/*++

Routine Description:

    Create variant as long

Arguments:

    pVarReturn - ptr to created variant
    dwV - value

Returns:

    COM status

--*/
{
	HRESULT         hr;

    V_VT(pvarReturn) = VT_I4;
    V_I4(pvarReturn) = dwV;

    return S_OK;
}


HRESULT 
VariantResolveDispatch(
    VARIANT *   pVarOut, 
    VARIANT *   pVarIn
    )
/*++

Routine Description:

    Extract value from IDispatch default property

Arguments:

    pVarOut - ptr to created variant
    pVarIn - ptr to IDispatch variant to resolve

Returns:

    COM status

--*/
{
	VARIANT		varResolved;		// value of IDispatch::Invoke
	DISPPARAMS	dispParamsNoArgs = {NULL, NULL, 0, 0}; 
	EXCEPINFO	ExcepInfo;
	HRESULT		hrCopy;


	VariantInit(pVarOut);

	hrCopy = VariantCopy(pVarOut, pVarIn);

	if (FAILED(hrCopy))
	{
		return hrCopy;
	}

	// follow the IDispatch chain.
	//
	while (V_VT(pVarOut) == VT_DISPATCH)
	{
		HRESULT hrInvoke = S_OK;

		// If the variant is equal to Nothing, then it can be argued
		// with certainty that it does not have a default property!
		// hence we return DISP_E_MEMBERNOTFOUND for this case.
		//
		if (V_DISPATCH(pVarOut) == NULL)
        {
			hrInvoke = DISP_E_MEMBERNOTFOUND;
        }
		else
		{
			VariantInit(&varResolved);
			hrInvoke = V_DISPATCH(pVarOut)->Invoke(
                            DISPID_VALUE,
                            IID_NULL,
                            LOCALE_SYSTEM_DEFAULT,
                            DISPATCH_PROPERTYGET | DISPATCH_METHOD,
                            &dispParamsNoArgs,
                            &varResolved,
                            &ExcepInfo,
                            NULL);
		}

		if (FAILED(hrInvoke))
		{
			if (hrInvoke == DISP_E_EXCEPTION)
			{			
				//
				// forward the ExcepInfo from Invoke to caller's ExcepInfo
				//
				SysFreeString(ExcepInfo.bstrHelpFile);
			}

			VariantClear(pVarOut);
			return hrInvoke;
		}

		// The correct code to restart the loop is:
		//
		//		VariantClear(pVar)
		//		VariantCopy(pVar, &varResolved);
		//		VariantClear(&varResolved);
		//
		// however, the same affect can be achieved by:
		//
		//		VariantClear(pVar)
		//		*pVar = varResolved;
		//		VariantInit(&varResolved)
		//
		// this avoids a copy.  The equivalence rests in the fact that
		// *pVar will contain the pointers of varResolved, after we
		// trash varResolved (WITHOUT releasing strings or dispatch
		// pointers), so the net ref count is unchanged. For strings,
		// there is still only one pointer to the string.
		//
		// NOTE: the next interation of the loop will do the VariantInit.
		//
		VariantClear(pVarOut);
		*pVarOut = varResolved;
	}

	return S_OK;
}

STDMETHODIMP
CIISDsCrMap::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);

    if (IsEqualIID(iid, IID_IISDsCrMap)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IISDsCrMap.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();

    return S_OK;
}



//
// IADsExtension::Operate()
//

STDMETHODIMP
CIISDsCrMap::Operate(
    THIS_ DWORD dwCode,
    VARIANT varUserName,
    VARIANT varPassword,
    VARIANT varFlags
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISDsCrMap::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }

    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);

    if (SUCCEEDED(hr)) {
        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISDsCrMap::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    m_Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP
CIISDsCrMap::ADSIReleaseObject()
{
    delete this;
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\common.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  common.cxx
//
//  Contents:  Microsoft ADs IIS Common routines 
//
//  History:   28-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include "iisext.hxx"

extern SERVER_CACHE * g_pServerCache;
extern WIN32_CRITSEC * g_pGlobalLock;

#pragma hdrstop


#define DEFAULT_TIMEOUT_VALUE                    30000



//+------------------------------------------------------------------------
//
//  Class:      Common
//
//  Purpose:    Contains Winnt routines and properties that are common to
//              all Winnt objects. Winnt objects get the routines and
//              properties through C++ inheritance.
//
//-------------------------------------------------------------------------

HRESULT
ReCacheAdminBase(
    IN LPWSTR pszServerName,
    IN OUT IMSAdminBase **ppAdminBase
    )
{
    HRESULT hr = S_OK;
    SERVER_CACHE_ITEM * item = NULL;
    DWORD dwThreadId;

    IMSAdminBase * pAdminBase = *ppAdminBase;
    IMSAdminBase * pOldAdminBase = *ppAdminBase;

    // RPC error caused this function to be called, so try to
    // recover the connection

    hr = InitAdminBase(pszServerName, &pAdminBase);
    BAIL_ON_FAILURE(hr);

    // we will return this one, so save it in the OUT param
    *ppAdminBase = pAdminBase;

    // update the cache
    dwThreadId = GetCurrentThreadId();
    item = g_pServerCache->Find(pszServerName, dwThreadId);

    if (item != NULL)
    {
        UninitAdminBase(pOldAdminBase);
        item->UpdateAdminBase(pAdminBase, dwThreadId);
    }

error :
    RRETURN(hr);
}

HRESULT
OpenAdminBaseKey(
    IN LPWSTR pszServerName,
    IN LPWSTR pszPathName,
    IN DWORD dwAccessType,
    IN OUT IMSAdminBase **ppAdminBase,
    OUT METADATA_HANDLE *phHandle
    )
{
    HRESULT hr;
    IMSAdminBase *pAdminBase = *ppAdminBase;
    METADATA_HANDLE RootHandle = NULL;
    DWORD dwThreadId;

    hr = pAdminBase->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                pszPathName,
                dwAccessType,
                DEFAULT_TIMEOUT_VALUE,
                &RootHandle
                );

    if (FAILED(hr)) {
        if ((HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE) ||
            ((HRESULT_CODE(hr) >= RPC_S_NO_CALL_ACTIVE) &&
             (HRESULT_CODE(hr) <= RPC_S_CALL_FAILED_DNE)) || 
            hr == RPC_E_DISCONNECTED) {

            hr = ReCacheAdminBase(pszServerName, &pAdminBase);
            BAIL_ON_FAILURE(hr);

            hr = pAdminBase->OpenKey(
                        METADATA_MASTER_ROOT_HANDLE,
                        pszPathName,
                        dwAccessType,
                        DEFAULT_TIMEOUT_VALUE,
                        &RootHandle
                        );
            BAIL_ON_FAILURE(hr);
        }
    }

error :

    if (FAILED(hr)) {

        if (pAdminBase && RootHandle) {
            pAdminBase->CloseKey(RootHandle);
        }
    }
    else {
        *phHandle = RootHandle;
    }

    RRETURN(hr);
}


VOID
CloseAdminBaseKey(
    IN IMSAdminBase *pAdminBase,
    IN METADATA_HANDLE hHandle
    )
{
    HRESULT hr;

    if (pAdminBase) {
        hr = pAdminBase->CloseKey(hHandle);
    }

    return;
}




HRESULT
InitAdminBase(
    IN LPWSTR pszServerName,
    OUT IMSAdminBase **ppAdminBase
    )
{
    HRESULT hr = S_OK;

    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IMSAdminBase * pAdminBase = NULL;
    IMSAdminBase * pAdminBaseT = NULL;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (pszServerName == NULL || _wcsicmp(pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName =  pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    hr = CoGetClassObject(
                CLSID_MSAdminBase,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IMSAdminBase,
                (void **) &pAdminBaseT
                );
    BAIL_ON_FAILURE(hr);

	hr = pAdminBaseT->UnmarshalInterface((IMSAdminBaseW **)&pAdminBase);
    pAdminBaseT->Release();
    pAdminBaseT = NULL;
	BAIL_ON_FAILURE(hr);
    *ppAdminBase = pAdminBase;

error:

    if (pcsfFactory) {
        pcsfFactory->Release();
    }

    RRETURN(hr);
}

VOID
UninitAdminBase(
    IN IMSAdminBase * pAdminBase
    )
{
    if (pAdminBase != NULL) {
        pAdminBase->Release();
    }
}

HRESULT
InitServerInfo(
    IN LPWSTR pszServerName,
    OUT IMSAdminBase ** ppObject
    )
{
    HRESULT hr = S_OK;
    IMSAdminBase * pAdminBase = NULL;
    SERVER_CACHE_ITEM * item;
    BOOL Success;
    DWORD dwThreadId;

    ASSERT(g_pServerCache != NULL);

    //
    // We'll return the localhost machine config to the users if 
    // pszServerName == NULL, e.g. IIS:
    //

    if (pszServerName == NULL) {
        pszServerName = L"Localhost";
    }

    dwThreadId = GetCurrentThreadId();

    if ((item = g_pServerCache->Find(pszServerName, dwThreadId)) == NULL) {

        //
        // get pAdminBase
        //

        hr = InitAdminBase(pszServerName, &pAdminBase);
        BAIL_ON_FAILURE(hr);

        item = new SERVER_CACHE_ITEM(pszServerName,
                                     pAdminBase,
                                     dwThreadId,
                                     Success);

        if (item == NULL || !Success) {
            if (item != NULL) {
                UninitAdminBase(pAdminBase);
                delete item;
            }
            RRETURN(E_OUTOFMEMORY); // OUT_OF_MEMORY;
        }

        if (g_pServerCache->Insert(item) == FALSE) {
            UninitAdminBase(pAdminBase);
            delete item;
            RRETURN(E_OUTOFMEMORY); // OUT_OF_MEMORY;
        }
    }

    *ppObject = item->pAdminBase;

error :

    RRETURN(hr);

}


HRESULT
InitWamAdmin(
    IN LPWSTR pszServerName,
    OUT IWamAdmin2 **ppWamAdmin
    )
{
    HRESULT hr = S_OK;

    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IWamAdmin2 * pWamAdmin = NULL;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (pszServerName == NULL || _wcsicmp(pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName =  pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    hr = CoGetClassObject(
                CLSID_WamAdmin,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IWamAdmin2,
                (void **) &pWamAdmin
                );
    BAIL_ON_FAILURE(hr);

    *ppWamAdmin = pWamAdmin;

error:

    if (pcsfFactory) {
        pcsfFactory->Release();
    }

    RRETURN(hr);
}


VOID
UninitWamAdmin(
    IN IWamAdmin2 *pWamAdmin
    )
{
    if (pWamAdmin != NULL) {
        pWamAdmin->Release();
    }
}



HRESULT
BuildIISPathFromADsPath(
    POBJECTINFO pObjectInfo,
    LPWSTR pszIISPathName
    )
{

    DWORD dwNumComponents = 0;
    DWORD i = 0;

    dwNumComponents = pObjectInfo->NumComponents;

    //
    // wcscat "LM" to IIS Metabase path
    //

    wcscat(pszIISPathName, L"/LM/");

    if (dwNumComponents) {


        for (i = 0; i < dwNumComponents; i++) {


            if (wcscmp(pObjectInfo->ComponentArray[i].szComponent, L"[Root]")){
                   wcscat(pszIISPathName, pObjectInfo->ComponentArray[i].szComponent);
            }
            else {
                   if( i == dwNumComponents -1 ) {
                       wcscat(pszIISPathName, L"/");
                   }
            }

            if( i < dwNumComponents -1 ) {
                wcscat(pszIISPathName,L"/");
            }
        }

    }

    RRETURN(S_OK);

}


VOID
FreeObjectInfo(
    POBJECTINFO pObjectInfo
    )
{
    if ( !pObjectInfo )
        return;

    FreeADsStr( pObjectInfo->ProviderName );
    FreeADsStr( pObjectInfo->TreeName );

    for ( DWORD i = 0; i < pObjectInfo->NumComponents; i++ ) {
        if (pObjectInfo->ComponentArray[i].szComponent) {
            FreeADsStr( pObjectInfo->ComponentArray[i].szComponent );
        }
        if (pObjectInfo->ComponentArray[i].szValue) {
            FreeADsStr( pObjectInfo->ComponentArray[i].szValue );
        }
    }

    if (pObjectInfo->ComponentArray) {
        FreeADsMem(pObjectInfo->ComponentArray);
    }

    // We don't need to free pObjectInfo since the object is always a static
    // variable on the stack.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\csrv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  csrv.cxx
//
//  Contents:  Contains methods for CIISServer object
//
//  History:   21-1-98     SophiaC    Created.
//
//----------------------------------------------------------------------------

#include "iisext.hxx"
#pragma hdrstop

//
// Period to sleep while waiting for service to attain desired state
//
#define SLEEP_INTERVAL (500L)
#define MAX_SLEEP_INST (60000)       // For an instance

//  Class CIISServer

DEFINE_IPrivateDispatch_Implementation(CIISServer)
DEFINE_DELEGATING_IDispatch_Implementation(CIISServer)
DEFINE_CONTAINED_IADs_Implementation(CIISServer)
DEFINE_IADsExtension_Implementation(CIISServer)

CIISServer::CIISServer():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _pszServerName(NULL),
        _pszMetaBasePath(NULL),
		_pAdminBase(NULL),
        _pDispMgr(NULL),
        _fDispInitialized(FALSE)
{
    ENLIST_TRACKING(CIISServer);
}

HRESULT
CIISServer::CreateServer(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    CCredentials Credentials;
    CIISServer FAR * pServer = NULL;
    HRESULT hr = S_OK;
    BSTR bstrAdsPath = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer * pLexer = NULL;
    LPWSTR pszIISPathName = NULL;   

    hr = AllocateServerObject(pUnkOuter, Credentials, &pServer);
    BAIL_ON_FAILURE(hr);

    //
    // get ServerName and pszPath
    //

    hr = pServer->_pADs->get_ADsPath(&bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    pLexer = new CLexer();
    hr = pLexer->Initialize(bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(pLexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);
    pszIISPathName = AllocADsStr(bstrAdsPath);
    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pServer->InitializeServerObject(
                pObjectInfo->TreeName,
                pszIISPathName );
    BAIL_ON_FAILURE(hr);

    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pServer;

    if (bstrAdsPath)
    {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (bstrAdsPath)
    {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    *ppvObj = NULL;

    delete pServer;

    RRETURN(hr);

}


CIISServer::~CIISServer( )
{

    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath) {
        FreeADsStr(_pszMetaBasePath);
    }

    delete _pDispMgr;
}


STDMETHODIMP
CIISServer::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr); 

}

HRESULT
CIISServer::AllocateServerObject(
    IUnknown *pUnkOuter,
    CCredentials& Credentials,
    CIISServer ** ppServer
    )
{
    CIISServer FAR * pServer = NULL;
    IADs FAR * pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pServer = new CIISServer();
    if (pServer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsServiceOperations,
                (IADsServiceOperations *)pServer,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the IADs Pointer, but again do NOT ref-count
    // this pointer - we keep the pointer around, but do
    // a release immediately.
    //

    hr = pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
    pADs->Release();
    pServer->_pADs = pADs;

    //
    // Store the pointer to the pUnkOuter object
    // AND DO NOT add ref this pointer
    //

    pServer->_pUnkOuter = pUnkOuter;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pServer->_Credentials = Credentials;
    pServer->_pDispMgr = pDispMgr;
    *ppServer = pServer;

    RRETURN(hr);

error:

    delete  pDispMgr;
    delete  pServer;

    RRETURN(hr);
}

HRESULT
CIISServer::InitializeServerObject(
    LPWSTR pszServerName,
    LPWSTR pszPath
    )
{
    HRESULT hr = S_OK;

    if (pszServerName) {
        _pszServerName = AllocADsStr(pszServerName);

        if (!_pszServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pszPath) {
        _pszMetaBasePath = AllocADsStr(pszPath);

        if (!_pszMetaBasePath) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

	hr = InitServerInfo(pszServerName, &_pAdminBase);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


STDMETHODIMP
CIISServer::SetPassword(THIS_ BSTR bstrNewPassword)
{
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISServer::Start
//
//  Synopsis:   Attempts to start the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/97  SophiaC    Created
//
// Notes:
//----------------------------------------------------------------------------

STDMETHODIMP
CIISServer::Start(THIS)
{
    RRETURN(IISControlServer(MD_SERVER_COMMAND_START));
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISServer::Stop
//
//  Synopsis:   Attempts to stop the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96 SophiaC  Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CIISServer::Stop(THIS)
{
    RRETURN(IISControlServer(MD_SERVER_COMMAND_STOP));
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISServer::Pause
//
//  Synopsis:   Attempts to pause the service named _bstrServiceName on the
//              server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01-04-96    SophiaC     Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CIISServer::Pause(THIS)
{
    RRETURN(IISControlServer(MD_SERVER_COMMAND_PAUSE));
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISServer::Continue
//
//  Synopsis:   Attempts to "unpause" the service specified in _bstrServiceName
//              on the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96  SophiaC Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CIISServer::Continue(THIS)
{
    RRETURN(IISControlServer(MD_SERVER_COMMAND_CONTINUE));
}

STDMETHODIMP
CIISServer::get_Status(THIS_ long FAR* plStatusCode)
{
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    DWORD dwCurrentState = 0;

    if(plStatusCode == NULL){
        RRETURN(E_POINTER);
    }

    hr = IISGetServerState(METADATA_MASTER_ROOT_HANDLE, &dwCurrentState);
    BAIL_ON_FAILURE(hr);

    *plStatusCode = (long) dwCurrentState; 

error:

    RRETURN(hr);
}


//
// Helper Functions
//

HRESULT
CIISServer::IISGetServerState(
    METADATA_HANDLE hObjHandle,
    PDWORD pdwState
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)pdwState;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_SERVER_STATE,    // server state
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = _pAdminBase->GetData(
             hObjHandle,
             _pszMetaBasePath,
             &mdrMDData,
             &dwBufferSize
             );
    if (FAILED(hr)) {
	    if( hr == MD_ERROR_DATA_NOT_FOUND )
	    {
	        //
	        // If the data is not there, but the path exists, then the
	        // most likely cause is that the service is not running and
	        // this object was just created.
	        //
	        // Since MD_SERVER_STATE would be set as stopped if the
	        // service were running when the key is added, we'll just 
	        // say that it's stopped. 
	        // 
	        // Note: starting the server or service will automatically set 
	        // the MB value.
	        //
	        *pdwState = MD_SERVER_STATE_STOPPED;
	        hr = S_FALSE;
	    }

        else if ((HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE) ||
            ((HRESULT_CODE(hr) >= RPC_S_NO_CALL_ACTIVE) &&
             (HRESULT_CODE(hr) <= RPC_S_CALL_FAILED_DNE)) || 
            hr == RPC_E_DISCONNECTED) {
			
            hr = ReCacheAdminBase(_pszServerName, &_pAdminBase);
            BAIL_ON_FAILURE(hr);

		    hr = _pAdminBase->GetData(
		             hObjHandle,
		             _pszMetaBasePath,
		             &mdrMDData,
		             &dwBufferSize
		             );
			BAIL_ON_FAILURE(hr);
		}

	    else
	    {
	        BAIL_ON_FAILURE(hr);
	    }
	}
error:

    RRETURN(hr);
}

//
// Helper routine for ExecMethod.
// Gets Win32 error from the metabase
//
HRESULT
CIISServer::IISGetServerWin32Error(
    METADATA_HANDLE hObjHandle,
    HRESULT*        phrError)
{
    DBG_ASSERT(phrError != NULL);

    long    lWin32Error = 0;
    DWORD   dwLen;

    METADATA_RECORD mr = {
        MD_WIN32_ERROR, 
        METADATA_NO_ATTRIBUTES,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        sizeof(DWORD),
        (unsigned char*)&lWin32Error,
        0
        };  
    
    HRESULT hr = _pAdminBase->GetData(
        hObjHandle,
        _pszMetaBasePath,
        &mr,
        &dwLen);
    if(hr == MD_ERROR_DATA_NOT_FOUND)
    {
        hr = S_FALSE;
    }

    //
    // Set out param
    //
    *phrError = HRESULT_FROM_WIN32(lWin32Error);

    RRETURN(hr);
}

HRESULT
CIISServer::IISControlServer(
    DWORD dwControl
    )
{
    METADATA_HANDLE hObjHandle = NULL;
    DWORD dwTargetState;
    DWORD dwPendingState;
    DWORD dwState = 0;
    DWORD dwSleepTotal = 0L;

    HRESULT hr = S_OK;
    HRESULT hrMbNode = S_OK;

    switch(dwControl)
    {
    case MD_SERVER_COMMAND_STOP:
        dwTargetState = MD_SERVER_STATE_STOPPED;
        dwPendingState = MD_SERVER_STATE_STOPPING;
        break;

    case MD_SERVER_COMMAND_START:
        dwTargetState = MD_SERVER_STATE_STARTED;
        dwPendingState = MD_SERVER_STATE_STARTING;
        break;

    case MD_SERVER_COMMAND_CONTINUE:
        dwTargetState = MD_SERVER_STATE_STARTED;
        dwPendingState = MD_SERVER_STATE_CONTINUING;
        break;

    case MD_SERVER_COMMAND_PAUSE:
        dwTargetState = MD_SERVER_STATE_PAUSED;
        dwPendingState = MD_SERVER_STATE_PAUSING;
        break;

    default:
        hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        BAIL_ON_FAILURE(hr);
    }

    hr = IISGetServerState(METADATA_MASTER_ROOT_HANDLE, &dwState);
    BAIL_ON_FAILURE(hr);
 
    if (dwState == dwTargetState) {
        RRETURN (hr);
    }

    //
    // Write the command to the metabase
    //

    hr = OpenAdminBaseKey(
               _pszServerName,
               _pszMetaBasePath,
               METADATA_PERMISSION_WRITE,
               &_pAdminBase,
               &hObjHandle
               );
    BAIL_ON_FAILURE(hr);

    hr = IISSetCommand(hObjHandle, dwControl);
    BAIL_ON_FAILURE(hr);

    CloseAdminBaseKey(_pAdminBase, hObjHandle);

    while (dwSleepTotal < MAX_SLEEP_INST) {
        hr = IISGetServerState(METADATA_MASTER_ROOT_HANDLE, &dwState);
        BAIL_ON_FAILURE(hr);

        hrMbNode = 0;

        hr = IISGetServerWin32Error(METADATA_MASTER_ROOT_HANDLE, &hrMbNode);
        BAIL_ON_FAILURE(hr);

        // check to see if we hit the target state
        if (dwState != dwPendingState)
        {
            //
            // Done one way or another
            //
            if (dwState == dwTargetState)
            {
                break;
            }
        }

        // check to see if there was a Win32 error from the server
        if (FAILED(hrMbNode))
        {
            hr = hrMbNode;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Still pending...
        //
        ::Sleep(SLEEP_INTERVAL);

        dwSleepTotal += SLEEP_INTERVAL;
    }

    if (dwSleepTotal >= MAX_SLEEP_INST)
    {
        //
        // Timed out.  If there is a real error in the metabase
        // use it, otherwise use a generic timeout error
        //

        hr = HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT);
    }

error :

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN (hr);
}


HRESULT
CIISServer::IISSetCommand(
    METADATA_HANDLE hObjHandle,
    DWORD dwControl
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)&dwControl;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_SERVER_COMMAND,  // server command
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = _pAdminBase->SetData(
             hObjHandle,
             L"",
             &mdrMDData
             );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);

}

STDMETHODIMP
CIISServer::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }

    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);

    if (SUCCEEDED(hr)) {
        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISServer::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{

    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}

STDMETHODIMP
CIISServer::ADSIReleaseObject()
{
    delete this;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISServer::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IADsServiceOperations)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IISServer.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();

    return S_OK;
}



//
// IADsExtension::Operate()
//

STDMETHODIMP
CIISServer::Operate(
    THIS_ DWORD dwCode,
    VARIANT varUserName,
    VARIANT varPassword,
    VARIANT varFlags
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\guid.c ===
/*++

   Copyright (c) 1997-1999 Microsoft Corporation

   Module  Name :

       iisext_guid.c

   Abstract:

        Contains ADSI IISExtensions CLSIDs, LIBIDs, and IIDs

   Environment:

      Win32 User Mode

--*/

#define INITGUID


#include <ole2.h>
#include "iwamreg.h"
#include "iadmw.h" 


//--------------------------------------------------------------------------
//
//  ADSI IISExtensions CLSIDs
//
//--------------------------------------------------------------------------

const IID LIBID_IISExt = {0x2a56ea30,0xafeb,0x11d1,{0x98,0x68,0x00,0xa0,0xc9,0x22,0xe7,0x03}};

const CLSID CLSID_IISExtDsCrMap = {0xbc36cde8,0xafeb,0x11d1,{0x98,0x68,0x00,0xa0,0xc9,0x22,0xe7,0x03}};

const CLSID CLSID_IISExtComputer = {0x91ef9258,0xafec,0x11d1,{0x98,0x68,0x00,0xa0,0xc9,0x22,0xe7,0x03}};

const CLSID CLSID_IISExtApp = {0xb4f34438,0xafec,0x11d1,{0x98,0x68,0x00,0xa0,0xc9,0x22,0xe7,0x03}};

const CLSID CLSID_IISExtServer = {0xc3b32488,0xafec,0x11d1,{0x98,0x68,0x00,0xa0,0xc9,0x22,0xe7,0x03}};

const CLSID CLSID_IISExtApplicationPool = { 0xe99f9d0c, 0xfb39, 0x402b, { 0x9e, 0xeb, 0xaa, 0x18, 0x52, 0x37, 0xbd, 0x34 } };

const CLSID CLSID_IISExtApplicationPools = { 0x95863074, 0xa389, 0x406a, { 0xa2, 0xd7, 0xd9, 0x8b, 0xfc, 0x95, 0xb9, 0x5 } };

const CLSID CLSID_IISExtWebService = { 0x40b8f873, 0xb30e, 0x475d, { 0xbe, 0xc5, 0x4d, 0xe, 0xbb, 0xd, 0xba, 0xf3 } };

DEFINE_GUID(IID_IISDsCrMap, 0xedcd6a60, 0xb053, 0x11d0, 0xa6, 0x2f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x52);

DEFINE_GUID(IID_IISApp, 0x46fbbb80, 0x192, 0x11d1, 0x9c, 0x39, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x3);

DEFINE_GUID(IID_IISApp2, 0x603DCBEA, 0x7350, 0x11d2, 0xA7, 0xBE, 0x0, 0x0, 0xF8, 0x8, 0x5B, 0x95);

DEFINE_GUID(IID_IISApp3, 0x2812b639, 0x8fac, 0x4510, 0x96, 0xc5, 0x71, 0xdd, 0xbd, 0x1f, 0x54, 0xfc);

DEFINE_GUID(IID_IISComputer, 0xcf87a2e0, 0x78b, 0x11d1, 0x9c, 0x3d, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x3);

DEFINE_GUID(IID_IISComputer2, 0x63d89839, 0x5762, 0x4a68, 0xb1, 0xb9, 0x35, 0xa07, 0xea, 0x76, 0xcb, 0xbf);

DEFINE_GUID(IID_IISApplicationPool, 0xb3cb1e1, 0x829a, 0x4c06, 0x8b, 0x9, 0xf5, 0x6d, 0xa1, 0x89, 0x4c, 0x88);

DEFINE_GUID(IID_IISApplicationPools, 0x587f123f, 0x49b4, 0x49dd, 0x93, 0x9e, 0xf4, 0x54, 0x7a, 0xa3, 0xfa, 0x75);

DEFINE_GUID(IID_IISWebService, 0xee46d40c, 0x1b38, 0x4a02, 0x89, 0x8d, 0x35, 0x8e, 0x74, 0xdf, 0xc9, 0xd2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\extres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       extres.h
//
//  Contents:   IIS Extension  DLL ID
//
//  Functions:
//
//----------------------------------------------------------------------------
#define IISEXT_PROVIDER_ID    1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\csrvcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  csrvcf.cxx
//
//  Contents:  IIS Server Object Class Factory Code
//
//             CIISServerCF::CreateInstance
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISServerCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISServerCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (!pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISServer::CreateServer(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\cwebservice.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001
//
//  File:  cwebservice.cxx
//
//  Contents:  Contains methods for CIISWebService object
//
//  History:   01-15-2001     BrentMid    Created.
//
//----------------------------------------------------------------------------

#include "iisext.hxx"
#include <initguid.h>
#include "iwamreg.h"
#include "sitecreator.h"

#pragma hdrstop

//  Class CIISWebService

DEFINE_IPrivateDispatch_Implementation(CIISWebService)
DEFINE_DELEGATING_IDispatch_Implementation(CIISWebService)
DEFINE_CONTAINED_IADs_Implementation(CIISWebService)
DEFINE_IADsExtension_Implementation(CIISWebService)

CIISWebService::CIISWebService():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _pszServerName(NULL),
        _pszMetaBasePath(NULL),
        _pAdminBase(NULL),
        _pDispMgr(NULL),
        _fDispInitialized(FALSE)
{
    ENLIST_TRACKING(CIISWebService);
}

HRESULT
CIISWebService::CreateWebService(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    CCredentials Credentials;
    CIISWebService FAR * pWebService = NULL;
    HRESULT hr = S_OK;
    BSTR bstrAdsPath = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer * pLexer = NULL;
    LPWSTR pszIISPathName  = NULL;

    hr = AllocateWebServiceObject(pUnkOuter, Credentials, &pWebService);
    BAIL_ON_FAILURE(hr);

    //
    // get ServerName and pszPath
    //

    hr = pWebService->_pADs->get_ADsPath(&bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    pLexer = new CLexer();
    hr = pLexer->Initialize(bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(pLexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(bstrAdsPath);
    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pWebService->InitializeWebServiceObject(
                pObjectInfo->TreeName,
                pszIISPathName );
    BAIL_ON_FAILURE(hr);

    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pWebService;

    if (bstrAdsPath)
    {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    *ppvObj = NULL;

    delete pWebService;

    RRETURN(hr);

}


CIISWebService::~CIISWebService( )
{
    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath) {
        FreeADsStr(_pszMetaBasePath);
    }

    delete _pDispMgr;
}


STDMETHODIMP
CIISWebService::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;
   
    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);
}

HRESULT
CIISWebService::AllocateWebServiceObject(
    IUnknown *pUnkOuter,
    CCredentials& Credentials,
    CIISWebService ** ppWebService
    )
{
    CIISWebService FAR * pWebService = NULL;
    IADs FAR *  pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pWebService = new CIISWebService();
    if (pWebService == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISExt,
                IID_IISWebService,
                (IISWebService *)pWebService,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the IADs Pointer, but again do NOT ref-count
    // this pointer - we keep the pointer around, but do
    // a release immediately.
    //
 
    hr = pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
    pADs->Release();
    pWebService->_pADs = pADs;

    //
    // Store the pointer to the pUnkOuter object
    // AND DO NOT add ref this pointer
    //
    pWebService->_pUnkOuter = pUnkOuter;
    pWebService->_Credentials = Credentials;
    pWebService->_pDispMgr = pDispMgr;
    *ppWebService = pWebService;

    RRETURN(hr);

error:

    delete  pDispMgr;
    delete  pWebService;

    RRETURN(hr);
}

HRESULT
CIISWebService::InitializeWebServiceObject(
    LPWSTR pszServerName,
    LPWSTR pszPath
    )
{
    HRESULT hr = S_OK;

    if (pszServerName) {
        _pszServerName = AllocADsStr(pszServerName);

        if (!_pszServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pszPath) {
        _pszMetaBasePath = AllocADsStr(pszPath);

        if (!_pszMetaBasePath) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = InitServerInfo(pszServerName, &_pAdminBase);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

STDMETHODIMP
CIISWebService::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }

    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);

    if (SUCCEEDED(hr)) {
        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISWebService::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP
CIISWebService::ADSIReleaseObject()
{
    delete this;
    RRETURN(S_OK);
}


STDMETHODIMP
CIISWebService::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);
    
    if (IsEqualIID(iid, IID_IISWebService)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;
                                
    } else if (IsEqualIID(iid, IID_IUnknown)) {
        
        //
        // probably not needed since our 3rd party extension does not stand 
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {
        
        *ppv = NULL;
        return E_NOINTERFACE;
    } 


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IISWebService.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();       

    return S_OK;
}


//
// IADsExtension::Operate()
//

STDMETHODIMP
CIISWebService::Operate(
    THIS_ DWORD dwCode,
    VARIANT varUserName,
    VARIANT varPassword,
    VARIANT varFlags
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISWebService::CreateNewSite(
    BSTR bstrServerComment,
    VARIANT *pvServerBindings,
    BSTR bstrRootVDirPath,
    VARIANT vServerID,
    VARIANT *pvActualID
    )
{
    HRESULT hr = S_OK;
    DWORD dwSiteID = 0;
    DWORD * pdwSiteID = &dwSiteID;
    DWORD dwNewSiteID = 0;
    IIISApplicationAdmin * pAppAdmin = NULL;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    CSiteCreator SiteCreator(_pAdminBase);
    VARIANT vVar;
    WCHAR* wszServerBindings = NULL;
    WCHAR* pIndex = NULL;
    VARIANT * pVarArray = NULL;
    DWORD dwNumValues = 0;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (_pszServerName == NULL || _wcsicmp(_pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName =  _pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    if (vServerID.vt == VT_I4) {
        *pdwSiteID = vServerID.lVal;
    }
    else {
        pdwSiteID = NULL;
    }

    hr = CoGetClassObject(
                CLSID_WamAdmin,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IIISApplicationAdmin,
                (void **) &pAppAdmin
                );
    BAIL_ON_FAILURE(hr);
    
    VariantInit(&vVar);

    hr = VariantCopyInd(&vVar, pvServerBindings);
    BAIL_ON_FAILURE(hr);

    if ( VT_DISPATCH == V_VT(&vVar) )   // JScript Array
    {
        // Output here is VT_BSTR, of format: "str_1,str_2,str_3, ... str_n\0"
        hr = VariantChangeType( &vVar, &vVar, 0, VT_BSTR );    
        BAIL_ON_FAILURE(hr);

        wszServerBindings = new WCHAR [wcslen(vVar.bstrVal) + 2];  // 1 for NULL, 1 for extra NULL

        if (!wszServerBindings) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(wszServerBindings, vVar.bstrVal);

        // change VT_BSTR to MULTISZ format: "str_1\0str_2\0str_3\0 ... str_n\0"
        pIndex = wszServerBindings;
        while ( *pIndex != 0 )
        {
            if ( *pIndex == L',' )
            {
                *pIndex = 0;
            }

            pIndex++;
        }
        *(++pIndex) = 0;
    }
    else if ( (VT_ARRAY | VT_VARIANT) == V_VT(&vVar) )   // VBS Array = SafeArray
    {
        // Allocates wszServerBindings and puts in MULTISZ format
        hr = ConvertArrayToMultiSZ( vVar, &wszServerBindings );
        BAIL_ON_FAILURE(hr);
    }
    else
    {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    hr = SiteCreator.CreateNewSite2(SC_W3SVC, bstrServerComment, wszServerBindings, 
                                    bstrRootVDirPath, pAppAdmin, &dwNewSiteID, pdwSiteID);
                                    
    BAIL_ON_FAILURE(hr);
     
    VariantInit( pvActualID );

    pvActualID->vt = VT_I4;
    pvActualID->lVal = dwNewSiteID;

error:
    
    if (pcsfFactory) {
        pcsfFactory->Release();
    }
 
    if (pAppAdmin) {
        pAppAdmin->Release();
    } 

    if (wszServerBindings) {
        delete [] wszServerBindings;
    }

    RRETURN(hr);
}

HRESULT
CIISWebService::ConvertArrayToMultiSZ(
    VARIANT varSafeArray,
    WCHAR **pszServerBindings
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    SAFEARRAY * pArray = NULL;
    DWORD dwLen = 0;
    DWORD dwNumVariants = 0;
    VARIANT * pVarArray = NULL;
    VARIANT pElem;
    WCHAR* wszServerBindings = NULL;

    if(!(V_ISARRAY(&varSafeArray)))
       RRETURN(E_FAIL);

    //
    // This handles by-ref and regular SafeArrays.
    //

    if (V_VT(&varSafeArray) & VT_BYREF)
        pArray = *(V_ARRAYREF(&varSafeArray));
    else
        pArray = V_ARRAY(&varSafeArray);


    //
    // Check that there is only one dimension in this array
    //
    if (pArray && pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (!pArray ||  
        ( pArray->rgsabound[0].cElements == 0) ) {

        wszServerBindings = new WCHAR [2];
        wszServerBindings[0] = 0;
        wszServerBindings[1] = 1;
    } 
    else {  

        //
        // We know that this is a valid single dimension array
        //

        hr = SafeArrayGetLBound(pArray,
                                1,
                                (long FAR *)&dwSLBound
                                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayGetUBound(pArray,
                                1,
                                (long FAR *)&dwSUBound
                                );
        BAIL_ON_FAILURE(hr);

        dwNumVariants = dwSUBound - dwSLBound + 1;
        dwLen = 0;

        pVarArray = (PVARIANT)AllocADsMem(
                                    sizeof(VARIANT)*dwNumVariants
                                    );
        if (!pVarArray) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        
        for (i = dwSLBound; i <= dwSUBound; i++) {

            VariantInit(&pElem);
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &pElem
                                    );
            BAIL_ON_FAILURE(hr);
        
            hr = VariantChangeType(&pElem, &pElem, 0, VT_BSTR);
            BAIL_ON_FAILURE(hr);

            dwLen = dwLen + wcslen(pElem.bstrVal) + 1;
            pVarArray[i] = pElem;
        }

        wszServerBindings = new WCHAR [dwLen + 1];

        WCHAR * pServerBindings = wszServerBindings;

        for (i = dwSLBound; i <= dwSUBound; i++) {
            
            wcscpy(pServerBindings, pVarArray[i].bstrVal);
            
            while (*pServerBindings != 0) {
                pServerBindings++;
            }         

            pServerBindings++;
        }

        *pServerBindings = 0;

    }

    *pszServerBindings = wszServerBindings;

error:
    if (pVarArray) {
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISWebService::GetCurrentMode(
    VARIANT FAR* pvServerMode
    )
{
    HRESULT hr = S_OK;
    DWORD dwServerMode = 0;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IWamAdmin * pWamAdmin = NULL;
    IIISApplicationAdmin * pAppAdmin = NULL;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (_pszServerName == NULL || _wcsicmp(_pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName =  _pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    hr = CoGetClassObject(
                CLSID_WamAdmin,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IWamAdmin,
                (void **) &pWamAdmin
                );
    BAIL_ON_FAILURE(hr);

	// test here for 5.1 compat 

    hr = pWamAdmin->QueryInterface(
                    IID_IIISApplicationAdmin,
                    (void **)&pAppAdmin
                    );

    BAIL_ON_FAILURE(hr);

    // Call GetProcessMode - it's returning GetCurrentMode
    // after it checks to make sure the W3SVC is running.

    hr = pAppAdmin->GetProcessMode( &dwServerMode );

    BAIL_ON_FAILURE(hr);

    VariantInit( pvServerMode );

    pvServerMode->vt = VT_I4;
    pvServerMode->lVal = dwServerMode;

error:
    if (pcsfFactory) {
        pcsfFactory->Release();
    }
    if (pWamAdmin) {
        pWamAdmin->Release();
    }
    if (pAppAdmin) {
        pAppAdmin->Release();
    } 

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\cwebservicecf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:  cwebservicecf.cxx
//
//  Contents:  IIS WebService Object Class Factory Code
//
//             CIISWebServiceCF::CreateInstance
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISWebServiceCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11-10-2000    BrentMid     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISWebServiceCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (!pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISWebService::CreateWebService(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                RRETURN(put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ))

#define GET_PROPERTY_LONG(this, Property) \
                RRETURN(get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_BSTR(this, Property) \
                RRETURN(put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ))

#define GET_PROPERTY_BSTR(this, Property) \
                RRETURN(get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ))

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_DATE(this, Property) \
                RRETURN(put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ))

#define GET_PROPERTY_DATE(this, Property) \
                RRETURN(get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_VARIANT(this, Property) \
                RRETURN(put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ))

#define GET_PROPERTY_VARIANT(this, Property) \
                RRETURN(get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\crmapcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  crmapcf.cxx
//
//  Contents:  IIS cert mapper Object Class Factory Code
//
//             CIIScert mapperCF::CreateInstance
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISDsCrMapCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISDsCrMapCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (!pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISDsCrMap::Create(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for IIS ext guids
//
//  History:    16-Jan-98   SophiaC
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// IISExt CLSIDs
//
//-------------------------------------------


//
// IISExt objects
//

extern const CLSID LIBID_IISExt;


extern const CLSID CLSID_IISExtDsCrMap;

extern const CLSID CLSID_IISExtApp;

extern const CLSID CLSID_IISExtComputer;

extern const CLSID CLSID_IISExtServer;

extern const CLSID CLSID_IISExtApplicationPool;

extern const CLSID CLSID_IISExtApplicationPools;

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\iisext.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  iisext.h
//
//  Contents:  Macros for ADSI IIS Extension methods
//
//  History:   25-Feb-97   SophiaC    Created.
//
//----------------------------------------------------------------------------

#define IIS_LIBIID_IISExt                  2a56ea30-afeb-11d1-9868-00a0c922e703 
#define IIS_IID_IISApp                     46FBBB80-0192-11d1-9C39-00A0C922E703
#define IIS_IID_IISApp2                    603DCBEA-7350-11d2-A7BE-0000F8085B95
#define IIS_IID_IISApp3                    2812B639-8FAC-4510-96C5-71DDBD1F54FC
#define IIS_IID_IISComputer                CF87A2E0-078B-11d1-9C3D-00A0C922E703
#define IIS_IID_IISComputer2               63d89839-5762-4a68-b1b9-3507ea76cbbf
#define IIS_IID_IISDsCrMap                 edcd6a60-b053-11d0-a62f-00a0c922e752
#define IIS_IID_IISApplicationPool         0B3CB1E1-829A-4c06-8B09-F56DA1894C88
#define IIS_IID_IISApplicationPools        587F123F-49B4-49dd-939E-F4547AA3FA75
#define IIS_IID_IISWebService              EE46D40C-1B38-4a02-898D-358E74DFC9D2

#define IIS_CLSID_IISExtApp                b4f34438-afec-11d1-9868-00a0c922e703
#define IIS_CLSID_IISExtComputer           91ef9258-afec-11d1-9868-00a0c922e703
#define IIS_CLSID_IISExtServer             c3b32488-afec-11d1-9868-00a0c922e703
#define IIS_CLSID_IISExtDsCrMap            bc36cde8-afeb-11d1-9868-00a0c922e703
#define IIS_CLSID_IISExtApplicationPool    E99F9D0C-FB39-402b-9EEB-AA185237BD34
#define IIS_CLSID_IISExtApplicationPools   95863074-A389-406a-A2D7-D98BFC95B905
#define IIS_CLSID_IISExtWebService         40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3


#define PROPERTY_RO(name,type, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] type * retval);

#define PROPERTY_LONG_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] long ln##name);

#define PROPERTY_LONG_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);

#define PROPERTY_BSTR_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] BSTR bstr##name);

#define PROPERTY_BSTR_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);

#define PROPERTY_VARIANT_BOOL_RW(name, prid)          \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT_BOOL * retval); \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] VARIANT_BOOL f##name);

#define PROPERTY_VARIANT_BOOL_RO(name, prid)          \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT_BOOL * retval);

#define PROPERTY_VARIANT_RW(name, prid)               \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT * retval); \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] VARIANT v##name);

#define PROPERTY_VARIANT_RO(name, prid)               \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT * retval); \

#define PROPERTY_DATE_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] DATE * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] DATE da##name);

#define PROPERTY_DATE_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] DATE * retval);

#define PROPERTY_DISPATCH_RW(name, prid)              \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] IDispatch ** retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] IDispatch * p##name);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\parse.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:  parse.cxx
//
//  Contents:  IIS Pathname Parser
//
//  The Pathname Parser is a key component in ADs providers. It checks for
//  syntactic validity of an ADs pathname that has been passed to this
//  provider. If the syntax is valid, then an OBJECTINFO structure is
//  constructed. This OBJECTINFO structure contains a componentized version
//  of the ADs pathname for this object.
//
//  Note all that is being done is a syntax check. Rather than special-case
//  every single new nuance to pathnames, all path checking must conform to
//  the grammar rules laid out by the parser.
//
//
//
//  History:
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

// Object -> PathName, Type, eos
// Object -> PathName, eos

//+---------------------------------------------------------------------------
//  Function:   ADsObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <ADsObject> -> <ProviderName> <IISObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
ADsObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = ProviderName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    pObjectInfo->ComponentArray = NULL;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    switch (dwToken) {

    case TOKEN_END:
        RRETURN(S_OK);

    case TOKEN_COMMA:
        hr = Type(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
        if (dwToken == TOKEN_END) {
            RRETURN(S_OK);
        }else {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    default:
        hr = pTokenizer->PushBackToken();


        hr = IISObject(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        switch (dwToken) {
        case TOKEN_END:
            RRETURN(S_OK);

        case TOKEN_COMMA:
            hr = Type(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);
            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);
            if (dwToken == TOKEN_END) {
                RRETURN(S_OK);
            }else {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

        default:
            RRETURN(E_FAIL);

        }
    }

cleanup:
    RRETURN(hr);

}



//+---------------------------------------------------------------------------
//  Function:   IISObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <IISObject> -> "\\""identifier""\" <IISObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
IISObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) &&  (dwToken != TOKEN_BSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) && (dwToken != TOKEN_BSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = AddTreeName(pObjectInfo, szToken);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    //
    // If we get an TOKEN_END, then we have a tree name only \\<tree_name>
    //

    if (dwToken == TOKEN_END || dwToken == TOKEN_COMMA) {
        hr = pTokenizer->PushBackToken();
        RRETURN(S_OK);
    }

    if ((dwToken != TOKEN_BSLASH) && (dwToken != TOKEN_FSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

cleanup:
    RRETURN(hr);
}

HRESULT
ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_ATSIGN) {

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_EXCLAMATION) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else if (dwToken == TOKEN_IDENTIFIER) {

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_COLON) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // You can now disable the processing for "@" and "!" treat them
    // as ordinary characters.
    //

    pTokenizer->SetAtDisabler(TRUE);


    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}


// PathName -> Component \\ PathName
// PathName -> Component
HRESULT
DsPathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) || (dwToken != TOKEN_BSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) || (dwToken != TOKEN_BSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    HRESULT hr;
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;

    do
    {
        hr = Component(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
    }
    while( (dwToken == TOKEN_BSLASH) || (dwToken == TOKEN_FSLASH) );

    hr = pTokenizer->PushBackToken();
    BAIL_IF_ERROR(hr);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:  Component -> <identifier>
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szValue[MAX_TOKEN_LENGTH];
    WCHAR szEqual[MAX_TOKEN_LENGTH];
    WCHAR szComponent[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szComponent, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = pTokenizer->GetNextToken(szEqual, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_EQUAL) {

        hr = pTokenizer->GetNextToken(szValue, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddComponent(pObjectInfo, szComponent, szValue);
        BAIL_IF_ERROR(hr);

    }else {

        hr = AddComponent(pObjectInfo, szComponent, NULL);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->PushBackToken();
        BAIL_IF_ERROR(hr);
    }

    RRETURN(S_OK);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLexer::CLexer():
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE)
{
        return;
}

HRESULT
CLexer::Initialize(LPWSTR szBuffer)
{
    if (!szBuffer || !*szBuffer) {
        RRETURN(S_OK);
    }

    _Buffer = AllocADsStr(szBuffer);

    if (!_Buffer) {
        RRETURN(E_OUTOFMEMORY);
    }
    _ptr = _Buffer;
    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    FreeADsStr(_Buffer);
}

/*++
    This routine assumes that szToken is a buffer of at least MAX_TOKEN_LENGTH
--*/
HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPDWORD pdwToken)
{
    WCHAR c;
    DWORD state = 0;
    LPWSTR pch = szToken;

    memset(szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH);
    _dwLastTokenLength = 0;
    while (1) {
        c = NextChar();
        switch (state) {
        case  0:
            if (_dwLastTokenLength++ >= MAX_TOKEN_LENGTH) {
                RRETURN(RETURNCODETOHRESULT(ERROR_INVALID_NAME));
            }
            *pch++ = c;

            if (c == L'\\') {
                *pdwToken = TOKEN_BSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'/') {
                *pdwToken = TOKEN_FSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L',') {
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'='){
                *pdwToken = TOKEN_EQUAL;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }
            else if (c == L':'){
                *pdwToken = TOKEN_COLON;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'\0'){
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'@') {

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_ATSIGN;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else if (c == L'!'){

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_EXCLAMATION;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else {

                state = 1;
            }
            break;


        case 1:
            if (c == L'\\' || c == L'\0' || c == L',' ||
                    c == L'=' || 
                    c == L':' || c == L'/') {
                PushbackChar();

                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                RRETURN (S_OK);

            }else if (c == L'@' || c == L'!') {

                if (!_bAtDisabled) {

                    PushbackChar();

                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {

                    if (_dwLastTokenLength++ >= MAX_TOKEN_LENGTH) {
                        RRETURN(RETURNCODETOHRESULT(ERROR_INVALID_NAME));
                    }
                    *pch++ = c;
                    state = 1;
                    break;

                }

            }else {
                if (_dwLastTokenLength++ >= MAX_TOKEN_LENGTH) {
                    RRETURN(RETURNCODETOHRESULT(ERROR_INVALID_NAME));
                }
                *pch++ = c;
                state = 1;
                break;
            }

        default:
            RRETURN(E_FAIL);
        }
    }
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }
    _ptr -= _dwLastTokenLength;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

#if 0
//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
BOOL
CLexer::IsKeyword(LPWSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < MAX_KEYWORDS; i++) {
        if (!_wcsicmp(szToken, KeywordList[i].Keyword)) {
            *pdwToken = KeywordList[i].dwTokenId;
            return(TRUE);
        }
    }
    *pdwToken = 0;
    return(FALSE);
}

#endif

//+---------------------------------------------------------------------------
//Function:
//
//Synopsis:
//
//Arguments:
//
//Returns:
//
//Modifies:
//
//History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
AddComponent(POBJECTINFO pObjectInfo, LPWSTR szComponent, LPWSTR szValue)
{
    if (!szComponent || !*szComponent) {
        RRETURN(E_FAIL);
    }


    if (pObjectInfo->ComponentArray == NULL) {
        pObjectInfo->ComponentArray =
               (PCOMPONENT) AllocADsMem(sizeof(COMPONENT)*MAXCOMPONENTS);
        pObjectInfo->MaxComponents = MAXCOMPONENTS;
    }
    else if (pObjectInfo->NumComponents == pObjectInfo->MaxComponents) {
        pObjectInfo->ComponentArray =
               (PCOMPONENT) ReallocADsMem(
                                  pObjectInfo->ComponentArray,
                                  sizeof(COMPONENT)*pObjectInfo->MaxComponents,
                                  sizeof(COMPONENT)*(
                                    pObjectInfo->MaxComponents+MAXCOMPONENTS)
                                  );
        pObjectInfo->MaxComponents += MAXCOMPONENTS;
    }

    pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szComponent =
                        AllocADsStr(szComponent);

    if (szValue && *szValue) {
        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szValue =
                        AllocADsStr(szValue);
    }
    else {
        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szValue = NULL;
    }

    pObjectInfo->NumComponents++;

    RRETURN(S_OK);
}

HRESULT
AddProviderName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->ProviderName = AllocADsStr(szToken);

    RRETURN(S_OK);
}


HRESULT
AddTreeName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->TreeName = AllocADsStr(szToken);

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
SetType(POBJECTINFO pObjectInfo, DWORD dwToken)
{
    pObjectInfo->ObjectType = dwToken;
    RRETURN(S_OK);
}


// Type -> "user", "group","printer","service", "fileservice"

//+---------------------------------------------------------------------------
// Function:    Type
//
// Synopsis:    Parses Type-> "user" | "group" etc
//
// Arguments:   [CLexer * pTokenizer]
//              [POBJECTINFo pObjectInfo]
//
// Returns:     HRESULT
//
// Modifies:    -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------


HRESULT
Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_PATH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_IDENTIFIER ) {
        RRETURN(hr);
    }

    RRETURN(E_FAIL);

cleanup:
    RRETURN(hr);
}


void
CLexer::SetAtDisabler(
    BOOL bFlag
    )
{
    _bAtDisabled = bFlag;
}

BOOL
CLexer::GetAtDisabler()
{
    return(_bAtDisabled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\macro.h ===
//
//             This NonDelegating interface is completely for 3rd-party 
//              extension objects based on our implementation only. NO need 
//              to export to ADISclients or 3rd part writer or typelib.  
//              Will put it here for now. Move -> ?? 
//

#ifndef _INonDelegatingUnknown
#define _INonDelegatingUnknown
interface INonDelegatingUnknown
{
    //
    //            Do I have to use __RPC_FAR * instead ?? (for marshalling?)
    //            May be not now since in proc server now. But should make
    //            it generalized. Look up and copy from IUnknown.

    virtual HRESULT STDMETHODCALLTYPE
    NonDelegatingQueryInterface(const IID&, void **) = 0; 

    virtual ULONG STDMETHODCALLTYPE 
    NonDelegatingAddRef() = 0;

    virtual ULONG STDMETHODCALLTYPE 
    NonDelegatingRelease() = 0;
};
#endif


#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}

#define DEFINE_IADsPutGet_UnImplementation(cls)                          \
STDMETHODIMP                                                             \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                             \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                     \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}


#define DEFINE_IPrivateDispatch_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::ADSIGetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ADSIGetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::ADSIGetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ADSIInvoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}


//
//            add the shell of DEFINE_IADsExtension_Imp to VC++ template 
//            for 3rd party extension - including Operate, can even include 
//            dwCode switches - would be nice. Later
//
// Will not include Operate() in macro since funct'n sligthly more complicated ?
// 

//
//            LPWSTR ?? OLECHAR * won't compile ?? but declaration use
//            OLECHAR * ?? win95/98 ??
//

#define DEFINE_IADsExtension_Implementation(cls)                        \
STDMETHODIMP                                                            \
cls::PrivateGetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,            \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)           \
{                                                                       \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                           \
                                         rgszNames,                     \
                                         cNames,                        \
                                         lcid,                          \
                                         rgdispid                       \
                                         ));                            \
}                                                                       \
                                                                        \
STDMETHODIMP                                                            \
cls::PrivateInvoke(DISPID dispidMember, REFIID iid, LCID lcid,          \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,             \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,             \
        unsigned int FAR* puArgErr)                                     \
{                                                                       \
        RRETURN (_pDispMgr->Invoke(dispidMember,                        \
                                   iid,                                 \
                                   lcid,                                \
                                   wFlags,                              \
                                   pdispparams,                         \
                                   pvarResult,                          \
                                   pexcepinfo,                          \
                                   puArgErr                             \
                                   ));                                  \
}



#define DEFINE_DELEGATING_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pADs->GetTypeInfoCount(pctinfo));                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pADs->GetTypeInfo(itinfo,                            \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pADs->GetIDsOfNames(iid,                             \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pADs->Invoke(dispidMember,                          \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for iisext.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-1-98   sophiac   Created.
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop


HINSTANCE g_hInst = NULL;


//
//  Global Data
//

WIN32_CRITSEC * g_pGlobalLock = NULL;
SERVER_CACHE * g_pServerCache = NULL;



DECLARE_DEBUG_PRINTS_OBJECT()
#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#endif

//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    WCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(L"IISEXT",L"heapInfoLevel", L"00000003", awcs,MAXINFOLEN))
        heapInfoLevel = wcstoul(awcs, NULL, 16);

    if (GetProfileString(L"IISEXT",L"Ot", L"00000003", awcs, MAXINFOLEN))
        OtInfoLevel = wcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(L"IISEXT",L"ADsInfoLevel", L"00000003", awcs,MAXINFOLEN))
        ADsInfoLevel = wcstoul(awcs, NULL, 16);
#endif
}

//  Globals


ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll


//+------------------------------------------------------------------------
//
//  Macro that calculates the number of elements in a statically-defined
//  array.
//
//  Note - I swiped this from ADsary.cxx - A type-safe array class. Remember
//  to swipe the whole thing as required.
//-------------------------------------------------------------------------
#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))

CIISComputerCF            g_cfComputer;
CIISServerCF              g_cfServer;   
CIISAppCF                 g_cfApp;    
CIISDsCrMapCF             g_cfDsCrMap;
CIISApplicationPoolCF     g_cfApplicationPool;
CIISApplicationPoolsCF    g_cfApplicationPools;
CIISWebServiceCF          g_cfWebService;

//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};



CLSCACHE g_aclscache[] =
{
    &CLSID_IISExtComputer,                     &g_cfComputer,
    &CLSID_IISExtServer,                       &g_cfServer,
    &CLSID_IISExtApp,                          &g_cfApp,
    &CLSID_IISExtDsCrMap,                      &g_cfDsCrMap,  
	&CLSID_IISExtApplicationPool,              &g_cfApplicationPool,
	&CLSID_IISExtApplicationPools,             &g_cfApplicationPools,
	&CLSID_IISExtWebService,                   &g_cfWebService
};


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been called with an unknown CLSID.
    //

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInst);
        g_pGlobalLock = new WIN32_CRITSEC();
        g_pServerCache = new SERVER_CACHE();

        g_hInst = hInst;


#if DBG==1
#ifndef MSVC
        InitializeCriticalSection(&g_csOT);
        InitializeCriticalSection(&g_csMem);
#endif
        InitializeCriticalSection(&g_csDP);
#endif

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT("iisext");
        SET_DEBUG_FLAGS(DEBUG_ERROR);
#endif

        break;


    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsidIndex
//
//  Synopsis:   Returns the index of the given CLSID in the cache, or
//              -1 if the CLSID is not present in the cache
//
//  Arguments:  [clsid]
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetCachedClsidIndex(REFCLSID clsid)
{
    int             i;
    CLSCACHE *      pclscache;

    for (i = 0, pclscache = g_aclscache;
         i < ARRAY_SIZE(g_aclscache);
         i ++, pclscache++)
    {
        if (IsEqualCLSID(*pclscache->pclsid, clsid))
            return i;
    }

    return -1;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClassFactory
//
//  Synopsis:   Returns the cached class factory with the given index.
//              The pointer returned has been AddRef'd.
//
//  Arguments:  [iclsid]
//
//  Returns:    IClassFactory *
//
//-------------------------------------------------------------------------

IClassFactory *
GetCachedClassFactory(int iclsid)
{
    IClassFactory * pCF;

    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    pCF = g_aclscache[iclsid].pCF;
    pCF->AddRef();

    return pCF;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsid
//
//  Synopsis:   Returns the CLSID corresponding to the given index.
//              Normally, code should call GetCachedClassFactory to get
//              the class factory directly.
//
//  Arguments:  [iclsid]    --  Clsid index
//              [pclsid]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

void
GetCachedClsid(int iclsid, CLSID * pclsid)
{
    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    *pclsid = *g_aclscache[iclsid].pclsid;
}


//+------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Register registry keys for adsiis
//
//  Arguments:  None
//
//-------------------------------------------------------------------------

STDAPI DllRegisterServer(
    )
{
    HKEY hKeyCLSID, hKeyTemp;
    DWORD dwDisposition;
    HMODULE hModule;
    HRESULT hr;
    ITypeLib   *pITypeLib;
    WCHAR pszName[MAX_PATH +1];
    int i;

    hModule=GetModuleHandle(TEXT("IISEXT.DLL"));

    if (!hModule) {
            return E_UNEXPECTED;
            }

    if (GetModuleFileName(hModule, pszName, MAX_PATH+1)==0) {
            return E_UNEXPECTED;
            }

    hr=LoadTypeLibEx(pszName, REGKIND_REGISTER, &pITypeLib);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }

    pITypeLib->Release();

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsCertMapper\\{bc36cde8-afeb-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
                      (BYTE*) TEXT("{edcd6a60-b053-11d0-a62f-00a0c922e752}"),
                      sizeof(TEXT("{edcd6a60-b053-11d0-a62f-00a0c922e752}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsComputer\\{91ef9258-afec-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
                      (BYTE*) TEXT("{CF87A2E0-078B-11d1-9C3D-00A0C922E703}"),
                      sizeof(TEXT("{CF87A2E0-078B-11d1-9C3D-00A0C922E703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApplicationPool\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
                      (BYTE*) TEXT("{0B3CB1E1-829A-4c06-8B09-F56DA1894C88}"),
                      sizeof(TEXT("{0B3CB1E1-829A-4c06-8B09-F56DA1894C88}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApplicationPools\\{95863074-A389-406a-A2D7-D98BFC95B905}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
                      (BYTE*) TEXT("{587F123F-49B4-49dd-939E-F4547AA3FA75}"),
                      sizeof(TEXT("{587F123F-49B4-49dd-939E-F4547AA3FA75}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsWebService\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
                      (BYTE*) TEXT("{EE46D40C-1B38-4a02-898D-358E74DFC9D2}"),
                      sizeof(TEXT("{EE46D40C-1B38-4a02-898D-358E74DFC9D2}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApp\\{b4f34438-afec-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
                      (BYTE*) TEXT("{46FBBB80-0192-11d1-9C39-00A0C922E703}"),
                      sizeof(TEXT("{46FBBB80-0192-11d1-9C39-00A0C922E703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsServer\\{c3b32488-afec-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
                      (BYTE*) TEXT("{5d7b33f0-31ca-11cf-a98a-00aa006bc149}"),
                      sizeof(TEXT("{5d7b33f0-31ca-11cf-a98a-00aa006bc149}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISExtDsCrMap\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{bc36cde8-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{bc36cde8-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{bc36cde8-afeb-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS Cert Map Extension"),
                      sizeof(TEXT("IIS Cert Map Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("iisext.dll"),
                      sizeof(TEXT("iisext.dll")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISExtDsCrMap"),
                      sizeof(TEXT("IISExtDsCrMap")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISExtComputer\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{91ef9258-afec-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{91ef9258-afec-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS Computer Extension"),
                      sizeof(TEXT("IIS Computer Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("iisext.dll"),
                      sizeof(TEXT("iisext.dll")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISExtComputer"),
                      sizeof(TEXT("IISExtComputer")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISExtApplicationPool\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{E99F9D0C-FB39-402b-9EEB-AA185237BD34}"),
                      sizeof(TEXT("{E99F9D0C-FB39-402b-9EEB-AA185237BD34}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS ApplicationPool Extension"),
                      sizeof(TEXT("IIS ApplicationPool Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("iisext.dll"),
                      sizeof(TEXT("iisext.dll")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISExtApplicationPool"),
                      sizeof(TEXT("IISExtApplicationPool")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISExtApplicationPools\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{95863074-A389-406a-A2D7-D98BFC95B905}"),
                      sizeof(TEXT("{95863074-A389-406a-A2D7-D98BFC95B905}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{95863074-A389-406a-A2D7-D98BFC95B905}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS ApplicationPools Extension"),
                      sizeof(TEXT("IIS ApplicationPools Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("iisext.dll"),
                      sizeof(TEXT("iisext.dll")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISExtApplicationPools"),
                      sizeof(TEXT("IISExtApplicationPools")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISWebService\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}"),
                      sizeof(TEXT("{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS Web Service Extension"),
                      sizeof(TEXT("IIS Web Service Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("iisext.dll"),
                      sizeof(TEXT("iisext.dll")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISExtWebService"),
                      sizeof(TEXT("IISExtWebService")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISExtApp\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{b4f34438-afec-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{b4f34438-afec-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{b4f34438-afec-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS App Extension"),
                      sizeof(TEXT("IIS App Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("iisext.dll"),
                      sizeof(TEXT("iisext.dll")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISExtApp"),
                      sizeof(TEXT("IISExtApp")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISExtServer\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{c3b32488-afec-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{c3b32488-afec-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{c3b32488-afec-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS Server Extension"),
                      sizeof(TEXT("IIS Server Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("iisext.dll"),
                      sizeof(TEXT("iisext.dll")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISExtServer"),
                      sizeof(TEXT("IISExtServer")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    return NOERROR;

}

//+------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Register registry keys for adsiis
//
//  Arguments:  None
//
//+------------------------------------------------------------------------
/* #pragma INTRINSA suppress=all */
STDAPI DllUnregisterServer(void) {

    UnRegisterTypeLib(LIBID_IISExt,
                      1,
                      0,
                      0,
                      SYS_WIN32);

    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsCertMapper\\{bc36cde8-afeb-11d1-9868-00a0c922e703}"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsCertMapper"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsComputer\\{91ef9258-afec-11d1-9868-00a0c922e703}"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsComputer"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApplicationPool\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApplicationPool"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsWebService\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsWebService"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApplicationPools\\{95863074-A389-406a-A2D7-D98BFC95B905}"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApplicationPools"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApp\\{b4f34438-afec-11d1-9868-00a0c922e703}"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApp"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsServer\\{c3b32488-afec-11d1-9868-00a0c922e703}"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsServer"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtDsCrMap\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtDsCrMap"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{bc36cde8-afeb-11d1-9868-00a0c922e703}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{bc36cde8-afeb-11d1-9868-00a0c922e703}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{bc36cde8-afeb-11d1-9868-00a0c922e703}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{bc36cde8-afeb-11d1-9868-00a0c922e703}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{bc36cde8-afeb-11d1-9868-00a0c922e703}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtComputer\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtComputer"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtApplicationPool\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtApplicationPool"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtApplicationPools\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtApplicationPools"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{95863074-A389-406a-A2D7-D98BFC95B905}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{95863074-A389-406a-A2D7-D98BFC95B905}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{95863074-A389-406a-A2D7-D98BFC95B905}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{95863074-A389-406a-A2D7-D98BFC95B905}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{95863074-A389-406a-A2D7-D98BFC95B905}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtWebService\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtWebService"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtApp\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtApp"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtServer\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtServer"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{c3b32488-afec-11d1-9868-00a0c922e703}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{c3b32488-afec-11d1-9868-00a0c922e703}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{c3b32488-afec-11d1-9868-00a0c922e703}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{c3b32488-afec-11d1-9868-00a0c922e703}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{c3b32488-afec-11d1-9868-00a0c922e703}"));

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\property.cxx ===
#include "iisext.hxx"
#pragma hdrstop


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( ppDestStringProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( plDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pdaDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pfDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pvDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\sdict.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  sdict.cxx
//
//  Contents:  simple dictionary 
//
//  History:   28-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include <iisext.hxx>

SIMPLE_DICT::SIMPLE_DICT()
{
    cDictSize = 0;
    iNextItem = 0;
    cDictSlots = INITIALDICTSLOTS;

    DictSlots = InitialDictSlots;
    memset(DictSlots, 0, sizeof(void *) * cDictSlots);
}

SIMPLE_DICT::~SIMPLE_DICT()
{
    if (DictSlots != InitialDictSlots)
        delete DictSlots;
}

int
SIMPLE_DICT::Insert (
    void *Item
    )
{
    int iDictSlots;
    void * * NewDictSlots;

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)

        if (DictSlots[iDictSlots] == NULL)
            {
            DictSlots[iDictSlots] = Item;
            cDictSize += 1;
            return(iDictSlots);
            }

    // If we fell through to here, it must mean that the dictionary is
    // full; hence we need to allocate more space and copy the old
    // dictionary into it.

    NewDictSlots = (void * *) new char[sizeof(void *)*cDictSlots*2];
    if (!NewDictSlots)
        return(-1);

    memcpy(NewDictSlots, DictSlots, sizeof(void *) * cDictSlots);
    memset(NewDictSlots+iDictSlots, 0,  sizeof(void *) * cDictSlots);

    if (DictSlots != InitialDictSlots)
        delete DictSlots;
    DictSlots = NewDictSlots;

    cDictSlots *= 2;

    DictSlots[iDictSlots] = Item;
    cDictSize += 1;
    return(iDictSlots);
}

void *
SIMPLE_DICT::Find (
    int Key
    )
{
    if (Key >= cDictSlots)
        return(NULL);

    return(DictSlots[Key]);
}

void *
SIMPLE_DICT::DeleteItemByBruteForce(
    void * Item
    )
{

    if (Item == 0)
       {
       return (0);
       }

    for (int i = 0; i < cDictSlots; i++)
        {
        if (DictSlots[i] == Item)
           {
           DictSlots[i] = NULL;
           cDictSize -= 1;
           return (Item);
           }
        }

    return (0);
}

void *
SIMPLE_DICT::Delete (
    int Key
    )
{
    void *Item;

    if (Key >= cDictSlots)
        {
        return(NULL);
        }

    Item = DictSlots[Key];
    ASSERT((DictSlots[Key]));

    cDictSize -= 1;
    DictSlots[Key] = NULL;

    return(Item);
}

void *
SIMPLE_DICT::Next (
    )
{
    for ( ; iNextItem < cDictSlots; iNextItem++)
        {
        if (DictSlots[iNextItem])
            return(DictSlots[iNextItem++]);
        }

    iNextItem = NULL;
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\svrcache.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  svrcache.cxx
//
//  Contents:  Caching code for com interface pointer and schema pointer
//
//  History:   28-Apr-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include <iisext.hxx>

BOOL SERVER_CACHE::Insert(SERVER_CACHE_ITEM * item)
// returns TRUE if succeed
{
    ASSERT(NULL != item);
    CLock lock;
#ifdef DBG
    SERVER_CACHE_ITEM * item2;
    Cache.Reset();
    while (NULL != (item2 = Cache.Next()))
        {
        if ((0 == _wcsicmp(item->ServerName, item2->ServerName)) &&
            (item->dwThreadId == item2->dwThreadId))
            {
            ASSERT(!"item already exists");
            }
        }
#endif
    item->key = Cache.Insert(item);
    return item->key != -1;
}

SERVER_CACHE_ITEM * SERVER_CACHE::Delete(LPWSTR ServerName, DWORD dwThreadId)
// returns item found
{
    SERVER_CACHE_ITEM * item;
    CLock lock;
    Cache.Reset();
    while (NULL != (item = Cache.Next()))
        {
        if ((0 == _wcsicmp(ServerName, item->ServerName)) &&
            (dwThreadId == item->dwThreadId))
            {
            Cache.Delete(item->key);
            if (item->ServerName) {
                delete item->ServerName;
            }
            return item; 
            }
        }
    return NULL;
}

SERVER_CACHE_ITEM * SERVER_CACHE::Find(LPWSTR ServerName, DWORD dwThreadId)
// returns pointer to the item found
{
    SERVER_CACHE_ITEM * item;
    CLock lock;
    Cache.Reset();
    while (NULL != (item = Cache.Next()))
        {
        if ((0 == _wcsicmp(ServerName, item->ServerName)) &&
            (dwThreadId == item->dwThreadId))
            {
            return item;
            }
        }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{obj\$(TARGET_DIRECTORY)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\iis60\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\iis51\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\include\heapstat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       Heapstats.hxx
//
//  Contents:   Structure that holds heap statistics.
//
//  Classes:    HEAPSTATS
//
//  History:    26-Oct-93 DavidBak      Created
//
//--------------------------------------------------------------------------

#if !defined(__HEAPSTAT_HXX__)
#define __HEAPSTAT_HXX__

#if (PERFSNAP == 1) || (DBG == 1)

//+-------------------------------------------------------------------------
//
//  Class:      HEAPSTATS
//
//  Purpose:    Data structure containing performance counters from the heap.
//              Used in our version of operator new.
//              See common\src\except\memory.cxx.
//
//--------------------------------------------------------------------------

typedef struct _HeapStats
{
    ULONG	cNew;
    ULONG	cZeroNew;
    ULONG	cDelete;
    ULONG	cZeroDelete;
    ULONG	cRealloc;
    ULONG       cbNewed;
    ULONG       cbDeleted;
} HEAPSTATS;

//
// GetHeapStats is in memory.cxx
//

#ifdef __cplusplus
extern "C" {
#endif

void GetHeapStats(HEAPSTATS * hsStats);

#ifdef __cplusplus
}
#endif


#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\iisext\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\include\adstype.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:
//
//  Contents:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#ifndef _ADSTYPE_H_INCLUDED_
#define _ADSTYPE_H_INCLUDED_

typedef enum {
   ADSTYPE_INVALID = 0,
   ADSTYPE_DN_STRING,
   ADSTYPE_CASE_EXACT_STRING,
   ADSTYPE_CASE_IGNORE_STRING,
   ADSTYPE_PRINTABLE_STRING,
   ADSTYPE_NUMERIC_STRING,
   ADSTYPE_BOOLEAN,
   ADSTYPE_INTEGER,
   ADSTYPE_OCTET_STRING,
   ADSTYPE_UTC_TIME,
   ADSTYPE_LARGE_INTEGER,
   ADSTYPE_PROV_SPECIFIC,
   ADSTYPE_OBJECT_CLASS,
   ADSTYPE_CASEIGNORE_LIST,
   ADSTYPE_OCTET_LIST,
   ADSTYPE_PATH,
   ADSTYPE_POSTALADDRESS,
   ADSTYPE_TIMESTAMP,
   ADSTYPE_BACKLINK,
   ADSTYPE_TYPEDNAME,
   ADSTYPE_HOLD,
   ADSTYPE_NETADDRESS,
   ADSTYPE_REPLICAPOINTER,
   ADSTYPE_FAXNUMBER,
   ADSTYPE_EMAIL,
   ADSTYPE_NT_SECURITY_DESCRIPTOR
} ADSTYPEENUM;
typedef ADSTYPEENUM ADSTYPE;

typedef unsigned char BYTE, *LPBYTE, *PBYTE;


//
// ADS Case DN String syntax
//

typedef LPWSTR ADS_DN_STRING, * PADS_DN_STRING;

//
// ADS Case Exact String syntax
//

typedef LPWSTR ADS_CASE_EXACT_STRING, * PADS_CASE_EXACT_STRING;

//
// ADS Case Ignore String syntax
//

typedef LPWSTR ADS_CASE_IGNORE_STRING, *PADS_CASE_IGNORE_STRING;

//
// ADS Printable String syntax
//

typedef LPWSTR ADS_PRINTABLE_STRING, *PADS_PRINTABLE_STRING;

//
// ADS Numeric String syntax
//
//

typedef LPWSTR ADS_NUMERIC_STRING, *PADS_NUMERIC_STRING;


//
// ADS Boolean syntax
//

typedef DWORD ADS_BOOLEAN, * LPNDS_BOOLEAN;

//
// Example: ADS Integer syntax
//

typedef DWORD ADS_INTEGER, *PADS_INTEGER;

//
// ADS Octet String syntax
//

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_OCTET_STRING, *PADS_OCTET_STRING;


//
// ADS NT Security Descriptor syntax
//

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_NT_SECURITY_DESCRIPTOR, *PADS_NT_SECURITY_DESCRIPTOR;


//
// ADS UTC Time Syntax
//

typedef SYSTEMTIME ADS_UTC_TIME, *PADS_UTC_TIME;


typedef LARGE_INTEGER ADS_LARGE_INTEGER, *PADS_LARGE_INTEGER;



//
// ADS ClassName syntax
//

typedef LPWSTR  ADS_OBJECT_CLASS, *PADS_OBJECT_CLASS;

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_PROV_SPECIFIC, *PADS_PROV_SPECIFIC;

//
// Extended Syntaxes for NDS
//
typedef struct _ADS_CASEIGNORE_LIST
{
    struct _ADS_CASEIGNORE_LIST *Next;
    LPWSTR            String;

}
ADS_CASEIGNORE_LIST, *PADS_CASEIGNORE_LIST;


typedef struct _ADS_OCTET_LIST
{
    struct _ADS_OCTET_LIST *Next;
    DWORD  Length;
    BYTE * Data;

} ADS_OCTET_LIST, *PADS_OCTET_LIST;

typedef struct
{
    DWORD  Type;
    LPWSTR VolumeName;
    LPWSTR Path;

} ADS_PATH, *PADS_PATH;

typedef struct
{
    LPWSTR PostalAddress[6]; // Value is limited to 6 lines,
                             // 30 characters each.

} ADS_POSTALADDRESS, *PADS_POSTALADDRESS;

typedef struct
{
    DWORD WholeSeconds; // Zero equals 12:00 midnight, January 1, 1970, UTC
    DWORD EventID;

} ADS_TIMESTAMP, *PADS_TIMESTAMP;

typedef struct
{
    DWORD  RemoteID;
    LPWSTR ObjectName;

} ADS_BACKLINK, *PADS_BACKLINK;

typedef struct
{
    LPWSTR ObjectName;
    DWORD  Level;
    DWORD  Interval;

} ADS_TYPEDNAME, *PADS_TYPEDNAME;

typedef struct
{
    LPWSTR ObjectName;
    DWORD  Amount;

} ADS_HOLD, *PADS_HOLD;

typedef struct
{
    DWORD  AddressType; // 0 = IPX,
    DWORD  AddressLength;
    BYTE * Address;

} ADS_NETADDRESS, *PADS_NETADDRESS;

typedef struct
{
    LPWSTR ServerName;
    DWORD  ReplicaType;
    DWORD  ReplicaNumber;
    DWORD  Count;
    PADS_NETADDRESS ReplicaAddressHints;
} ADS_REPLICAPOINTER, *PADS_REPLICAPOINTER;

typedef struct
{
    LPWSTR TelephoneNumber;
    DWORD  NumberOfBits;
    LPBYTE Parameters;
} ADS_FAXNUMBER, *PADS_FAXNUMBER;

typedef struct
{
    LPWSTR Address;
    DWORD  Type;
} ADS_EMAIL, *PADS_EMAIL;


typedef struct _adsvalue{
   ADSTYPE dwType;
   union {
      ADS_DN_STRING                     DNString;
      ADS_CASE_EXACT_STRING             CaseExactString;
      ADS_CASE_IGNORE_STRING            CaseIgnoreString;
      ADS_PRINTABLE_STRING              PrintableString;
      ADS_NUMERIC_STRING                NumericString;
      ADS_BOOLEAN                       Boolean;
      ADS_INTEGER                       Integer;
      ADS_OCTET_STRING                  OctetString;
      ADS_UTC_TIME                      UTCTime;
      ADS_LARGE_INTEGER                 LargeInteger;
      ADS_OBJECT_CLASS                  ClassName;
      ADS_PROV_SPECIFIC                 ProviderSpecific;
      PADS_CASEIGNORE_LIST              pCaseIgnoreList;
      PADS_OCTET_LIST                   pOctetList;
      PADS_PATH                         pPath;
      PADS_POSTALADDRESS                pPostalAddress;
      ADS_TIMESTAMP                     Timestamp;
      ADS_BACKLINK                      BackLink;
      PADS_TYPEDNAME                    pTypedName;
      ADS_HOLD                          Hold;
      PADS_NETADDRESS                   pNetAddress;
      PADS_REPLICAPOINTER               pReplicaPointer;
      PADS_FAXNUMBER                    pFaxNumber;
      ADS_EMAIL                         Email;
      ADS_NT_SECURITY_DESCRIPTOR        SecurityDescriptor;
   };
}ADSVALUE, *PADSVALUE, *LPADSVALUE;

typedef struct _ads_attr_info{
    LPWSTR  pszAttrName;
    DWORD   dwControlCode;
    ADSTYPE dwADsType;
    PADSVALUE pADsValues;
    DWORD   dwNumValues;
} ADS_ATTR_INFO, *PADS_ATTR_INFO;


const int  ADS_SECURE_AUTHENTICATION = 0x00000001;
const int  ADS_USE_ENCRYPTION        = 0x00000002;
const int  ADS_READONLY_SERVER       = 0x00000004;
const int  ADS_PROMPT_CREDENTIALS    = 0x00000008;
const int  ADS_NO_AUTHENTICATION     = 0x00000010;

/* ADS attribute modification operations */

const int ADS_ATTR_CLEAR          =  1; /* Clear all values from an attribute */
const int ADS_ATTR_UPDATE         =  2; /* Update values on an attribute */
const int ADS_ATTR_APPEND         =  3; /* Append  values to an attribute  */
const int ADS_ATTR_DELETE         =  4; /* Delete values from an attribute  */


typedef struct _ads_object_info{
    LPWSTR pszRDN;
    LPWSTR pszObjectDN;
    LPWSTR pszParentDN;
    LPWSTR pszSchemaDN;
    LPWSTR pszClassName;
} ADS_OBJECT_INFO, *PADS_OBJECT_INFO;

typedef enum {
    ADS_STATUS_S_OK = 0,
    ADS_STATUS_INVALID_SEARCHPREF,
    ADS_STATUS_INVALID_SEARCHPREFVALUE
} ADS_STATUSENUM;

typedef ADS_STATUSENUM ADS_STATUS, *PADS_STATUS;



typedef enum {
    ADS_DEREF_NEVER           = 0,
    ADS_DEREF_SEARCHING       = 1,
    ADS_DEREF_FINDING         = 2,
    ADS_DEREF_ALWAYS          = 3
} ADS_DEREFENUM;

typedef enum {
    ADS_SCOPE_BASE            = 0,
    ADS_SCOPE_ONELEVEL        = 1,
    ADS_SCOPE_SUBTREE         = 2
} ADS_SCOPEENUM;


//
// Values for ChaseReferral Option.

const int ADS_CHASE_REFERRALS_NEVER         =  0x00000000;
const int ADS_CHASE_REFERRALS_SUBORDINATE   =  0x00000020;
const int ADS_CHASE_REFERRALS_EXTERNAL      =  0x00000040;
const int ADS_CHASE_REFERRALS_ALWAYS        =
            (ADS_CHASE_REFERRALS_SUBORDINATE | ADS_CHASE_REFERRALS_EXTERNAL);

typedef enum {
   ADS_SEARCHPREF_ASYNCHRONOUS,
   ADS_SEARCHPREF_DEREF_ALIASES,
   ADS_SEARCHPREF_SIZE_LIMIT,
   ADS_SEARCHPREF_TIME_LIMIT,
   ADS_SEARCHPREF_ATTRIBTYPES_ONLY,
   ADS_SEARCHPREF_SEARCH_SCOPE,
   ADS_SEARCHPREF_TIMEOUT,
   ADS_SEARCHPREF_PAGESIZE,
   ADS_SEARCHPREF_PAGED_TIME_LIMIT,
   ADS_SEARCHPREF_CHASE_REFERRALS,
   ADS_SEARCHPREF_SORT_ON,
   ADS_SEARCHPREF_CACHE_RESULTS
} ADS_SEARCHPREF_ENUM;

typedef ADS_SEARCHPREF_ENUM ADS_SEARCHPREF;

typedef struct ads_searchpref_info{
    ADS_SEARCHPREF dwSearchPref;
    ADSVALUE vValue;
    ADS_STATUS dwStatus;
} ADS_SEARCHPREF_INFO, *PADS_SEARCHPREF_INFO, *LPADS_SEARCHPREF_INFO;


typedef HANDLE ADS_SEARCH_HANDLE, *PADS_SEARCH_HANDLE;


typedef struct ads_search_column {
   LPWSTR  pszAttrName;
   ADSTYPE dwADsType;
   PADSVALUE pADsValues;
   DWORD   dwNumValues;
   HANDLE hReserved;
} ADS_SEARCH_COLUMN, *PADS_SEARCH_COLUMN;

typedef struct _ads_attr_def {
   LPWSTR pszAttrName;
    ADSTYPE dwADsType;
    DWORD dwMinRange;
    DWORD dwMaxRange;
    BOOL fMultiValued;
}ADS_ATTR_DEF, *PADS_ATTR_DEF;


typedef struct _ads_sortkey {

    LPWSTR  pszAttrType;
    LPWSTR  pszReserved;
    BOOLEAN fReverseorder;

} ADS_SORTKEY, *PADS_SORTKEY;


//
// 3rd Party Extension 
//

//
// Valid dispids for extension.  
//
// - Max 24 bits. 
// - 0 reserved for DISPID_VALUE dealt with by aggregator.
// - DISPID_UNKNOWN (-1) also allowed. 
// - Others -ve dispids dealt with by aggregator only.
//

const int ADS_EXT_MINEXTDISPID = 1 ;
const int ADS_EXT_MAXEXTDISPID = 16777215 ;


//
// dwCodes for IADsExtension::Operate 
// 

const int ADS_EXT_INITCREDENTIALS = 1 ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\include\adsi.h ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  adsi.h
//
//  Contents:  Microsoft ADs LDAP Provider DSObject
//
//
//  History:   02-20-97    yihsins    Created.
//
//----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#include "adserr.h"
#include "adssts.h"
#include "adsnms.h"
#include "adsdb.h"

#include "adstype.h"

HRESULT
ADSIOpenDSObject(
    LPWSTR pszDNName,
    LPWSTR pszUserName,
    LPWSTR pszPassword,
    LONG   lnReserved,
    PHANDLE phDSObject
    );

HRESULT
ADSICloseDSObject(
    HANDLE hDSObject
    );

HRESULT
ADSISetObjectAttributes(
    HANDLE hDSObject,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    DWORD *pdwNumAttributesModified
    );

HRESULT
ADSIGetObjectAttributes(
    HANDLE hDSObject,
    LPWSTR *pAttributeNames,
    DWORD dwNumberAttributes,
    PADS_ATTR_INFO *ppAttributeEntries,
    DWORD * pdwNumAttributesReturned
    );

HRESULT
ADSICreateDSObject(
    HANDLE hParentDSObject,
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes
    );

HRESULT
ADSIDeleteDSObject(
    HANDLE hParentDSObject,
    LPWSTR pszRDNName
    );

BOOL
FreeADsMem(
   LPVOID pMem
);


HRESULT
ADSISetSearchPreference(
    HANDLE hDSObject,
    IN PADS_SEARCHPREF_INFO pSearchPrefs,
    IN DWORD   dwNumPrefs
    );


HRESULT
ADSIExecuteSearch(
    HANDLE hDSObject,
    IN LPWSTR pszSearchFilter,
    IN LPWSTR * pAttributeNames,
    IN DWORD dwNumberAttributes,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    );

HRESULT
ADSIAbandonSearch(
    HANDLE hDSObject,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    );


HRESULT
ADSICloseSearchHandle (
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );


HRESULT
ADSIGetFirstRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );

HRESULT
ADSIGetNextRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );


HRESULT
ADSIGetPreviousRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );


HRESULT
ADSIGetColumn(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN LPWSTR pszColumnName,
    OUT PADS_SEARCH_COLUMN pColumn
    );


HRESULT
ADSIGetNextColumnName(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT LPWSTR * ppszColumnName
    );


HRESULT
ADSIFreeColumn(
    HANDLE hDSObject,
    IN PADS_SEARCH_COLUMN pColumn
    );

HRESULT
ADSIEnumAttributes(
    HANDLE hDSObject,
    LPWSTR * ppszAttrNames,
    DWORD dwNumAttributes,
    PADS_ATTR_DEF * ppAttrDefinition,
    DWORD * pdwNumAttributes
    );

HRESULT
ADSICreateAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition
    );

HRESULT
ADSIReadAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF * pAttributeDefinition
    );

HRESULT
ADSIWriteAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF  pAttributeDefinition
    );

HRESULT
ADSIDeleteAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\include\formdeb.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       formdeb.h
//
//  Contents:   Private project-wide Win 4 definitions
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//              08-Aug-94   DonCl       copied from cinc and renamed formdeb.h
//
//----------------------------------------------------------------------------

#ifndef __FORMDEB_H__
#define __FORMDEB_H__
#define __DEBNOT_H__    // keep debnot.h from being included accidentally

#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)

//----------------------------------------------------------------------------
//
//  New STRICT defines should be added in two places below:
//
//  1)  Add the following within the ifdef ALLSTRICT/endif:
//
//      #ifndef xxSTRICT
//      #  define xxSTRICT
//      #endif
//
//      These entries are in alphabetical order.
//
//  2)  Add the following to the #if clause that defines ANYSTRICT:
//
//      #if ... || defined(xxSTRICT) || ...
//
//      so that ANYSTRICT is defined if any of the STRICT defines are.
//

#if (DBG == 1) || (OFSDBG == 1)

#  ifndef CATSTRICT
#    define CATSTRICT
#  endif

#  ifndef CISTRICT
#    define CISTRICT
#  endif

#  ifndef CMSSTRICT
#    define CMSSTRICT
#  endif

#  ifndef DLOSSTRICT
#    define DLOSSTRICT
#  endif

#  ifndef EVSTRICT
#    define EVSTRICT
#  endif

#  ifndef ICLSTRICT
#    define ICLSTRICT
#  endif

#  ifndef INSSTRICT
#    define INSSTRICT
#  endif

#  ifndef JWSTRICT
#    define JWSTRICT
#  endif

#  ifndef NSSTRICT
#    define NSSTRICT
#  endif

#  ifndef OLSTRICT
#    define OLSTRICT
#  endif

#  ifndef OMSTRICT
#    define OMSTRICT
#  endif

#  ifndef REPLSTRICT
#    define REPLSTRICT
#  endif

#  ifndef SHLSTRICT
#    define SHLSTRICT
#  endif

#  ifndef SLSTRICT
#    define SLSTRICT
#  endif

#  ifndef SMUISTRICT
#    define SMUISTRICT
#  endif

#  ifndef SOMSTRICT
#    define SOMSTRICT
#  endif

#  ifndef VCSTRICT
#    define VCSTRICT
#  endif

#  ifndef VQSTRICT
#    define VQSTRICT
#  endif

#  ifndef WMASTRICT
#    define WMASTRICT
#  endif


#endif // (DBG == 1) || (OFSDBG == 1)

//
//  ANYSTRICT
//

#if defined(CATSTRICT) || \
    defined(CISTRICT)  || \
    defined(CMSSTRICT) || \
    defined(DLOSSTRICT)|| \
    defined(ICLSTRICT) || \
    defined(INSSTRICT) || \
    defined(JWSTRICT)  || \
    defined(NSSTRICT)  || \
    defined(OLSTRICT)  || \
    defined(OMSTRICT)  || \
    defined(REPLSTRICT)|| \
    defined(SHLSTRICT) || \
    defined(SLSTRICT)  || \
    defined(SMUISTRICT)|| \
    defined(SOMSTRICT) || \
    defined(VCSTRICT)  || \
    defined(VQSTRICT)  || \
    defined(WMASTRICT)

#  define ANYSTRICT

#endif

#if (DBG != 1 && OFSDBG != 1) && defined(ANYSTRICT)
#pragma message Asserts are defined in a RETAIL build...
#endif


#if defined(WIN32)
 #include <windef.h>
#endif

#ifndef EXPORTDEF
 #define EXPORTDEF
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

#if (DBG == 1) || (OFSDBG == 1)

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
# define EXTRNC "C"
#else
# define EXTRNC
#endif



// vdprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   vdprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   #define _Win4Assert Win4AssertEx

   EXPORTDEF void          APINOT
   Win4AssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   #define _SetWin4InfoLevel SetWin4InfoLevel

   EXPORTDEF unsigned long APINOT
   SetWin4InfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4InfoMask(
       unsigned long ulNewMask);

   #define _SetWin4AssertLevel SetWin4AssertLevel

   EXPORTDEF unsigned long APINOT
   SetWin4AssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4ExceptionLevel(
       unsigned long ulNewLevel);

#ifdef __cplusplus
}
#endif // __cplusplus

# define EXSTRICT      // (EXception STRICT) - Enabled if ANYSTRICT is enabled

# define Win4Assert(x)  \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Assert(x)      \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Verify(x) Assert(x)


//
// Debug print macros
//

# define DEB_ERROR               0x00000001      // exported error paths
# define DEB_WARN                0x00000002      // exported warnings
# define DEB_TRACE               0x00000004      // exported trace messages

# define DEB_DBGOUT              0x00000010      // Output to debugger
# define DEB_STDOUT              0x00000020      // Output to stdout

# define DEB_IERROR              0x00000100      // internal error paths
# define DEB_IWARN               0x00000200      // internal warnings
# define DEB_ITRACE              0x00000400      // internal trace messages

# define DEB_USER1               0x00010000      // User defined
# define DEB_USER2               0x00020000      // User defined
# define DEB_USER3               0x00040000      // User defined
# define DEB_USER4               0x00080000      // User defined
# define DEB_USER5               0x00100000      // User defined
# define DEB_USER6               0x00200000      // User defined
# define DEB_USER7               0x00400000      // User defined
# define DEB_USER8               0x00800000      // User defined
# define DEB_USER9               0x01000000      // User defined
# define DEB_USER10              0x02000000      // User defined
# define DEB_USER11              0x04000000      // User defined
# define DEB_USER12              0x08000000      // User defined
# define DEB_USER13              0x10000000      // User defined
# define DEB_USER14              0x20000000      // User defined
# define DEB_USER15              0x40000000      // User defined

# define DEB_NOCOMPNAME          0x80000000      // suppress component name

# define DEB_FORCE               0x7fffffff      // force message

# define ASSRT_MESSAGE           0x00000001      // Output a message
# define ASSRT_BREAK             0x00000002      // Int 3 on assertion
# define ASSRT_POPUP             0x00000004      // And popup message

# define EXCEPT_MESSAGE          0x00000001      // Output a message
# define EXCEPT_BREAK            0x00000002      // Int 3 on exception
# define EXCEPT_POPUP            0x00000004      // Popup message
# define EXCEPT_FAULT            0x00000008      // generate int 3 on access violation


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
// Define values that are specific to your xxInfoLevel variable in your
// own file, like ciquery.hxx.
//
//-----------------------------------------------------------------------

# ifndef DEF_INFOLEVEL
#  define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
# endif



//
// Back to the info level stuff.
//

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

# define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char *comp##InfoLevelString = #comp;

# ifdef __cplusplus
}
# endif

# ifdef __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

# else  // ! __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

# endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

# define Win4Assert(x)  NULL
# define Assert(x)      NULL
# define Verify(x)     (x)

# define DECLARE_DEBUG(comp)
# define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0

#endif // __DEBNOT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\include\msdatt.h ===
//--------------------------------------------------------------------
// Microsoft OLE DB Rowset Service Provider
// (C) Copyright 1994 - 1996 By Microsoft Corporation.
//
// @doc
//
// @module MSDATT.H | Service Provider Specific definitions
//
//--------------------------------------------------------------------

#ifndef  _MSDATT_H_
#define  _MSDATT_H_


// Provider Class Id
#ifdef DBINITCONSTANTS
extern const GUID CLSID_MSDATT               = {0xc8b522ceL,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
#else // !DBINITCONSTANTS
extern const GUID CLSID_MSDATT;
#endif // DBINITCONSTANTS

#endif //_MSDATT_H_
//----
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\include\macro.h ===
#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}                                                                     \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\include\caiheap.h ===
//+---------------------------------------------------------------------------
//  File:       caiheap.h
//
//  Contents:   Heap debugging structures and routines for the heap code
//		in commnot
//
//  History:    28-Oct-92   IsaacHe	Created
//
//----------------------------------------------------------------------------


//
// We keep a stack backtrace for each allocated block of memory.  DEPTHTRACE
// is the number of frames that we record
//
#define DEPTHTRACE   26			// depth of stack backtraces

//
// The AllocArena structure has this signature at its front.  We put a
// signature on the structure to allow external processes to snapshot the
// debug information and do some minimal check to see they are looking at the
// right stuff
//
const char HEAPSIG[] = { 'H', 'E', 'P', DEPTHTRACE };

// We keep track of the stack backtraces of allocation calls
// in these structues.

struct HeapAllocRec {
	DWORD	sum;		// checksum of stack backtrace
	void *fTrace[ DEPTHTRACE ];	// stack backtrace
	DWORD	count;		// # of un-freed allocs from this place
	size_t	bytes;		// # of un-freed bytes from this place
	struct AllocArena *paa;	// points back to the beginning...
	struct {
		DWORD	count;	// # of allocs from this place
		size_t	bytes;	// # of bytes from this place
	} total;
	union {
		struct HeapAllocRec *next; // next bucket in the hash list
		void *ImageBase; 	// base addr of containing module
	} u;
};

struct AllocArena {

	char Signature [ sizeof(HEAPSIG) ];
	char comment[ 32 ];
	CRITICAL_SECTION csExclusive;	// ensures single writer

	struct {
		int KeepStackTrace:1;	// are stack records being kept?
	} flags;

	ULONG cAllocs;			// # of non zero Alloc calls
	ULONG czAllocs;			// # of Alloc calls w/zero count
	ULONG cFrees;			// # of Free calls
	ULONG cReAllocs;		// # of realloc calls
	ULONG cMissed;			// # of missed stack backtraces
	ULONG cRecords;			// index of next free AllocRec entry
	ULONG cBytesNow;		// # of bytes currently allocated
	ULONG cBytesTotal;		// # of bytes ever allocated
	ULONG cTotalRecords;		// Total # of AllocRecs
	ULONG cPaths;			// # of distinct allocation paths

	struct {
		ULONG total[ 32 ];	// total number of allocations
		ULONG now[ 32 ];	// current # of simul allocs
		ULONG simul[ 32 ];	// highest # of simul allocs
	} Histogram;

	struct HeapAllocRec AllocRec[1]; // vector of records starts here..
};

/*
 * Allocators may want to associate one of these structures with every
 * allocation...
 */
struct AHeader {
	struct HeapAllocRec FAR *p;
	size_t size;
};

STDAPI_(struct AllocArena ** )
AllocArenaAddr( void );

STDAPI_( struct AllocArena * )
AllocArenaCreate( DWORD memctx, char FAR *comment );

STDAPI_( struct HeapAllocRec FAR * )
AllocArenaRecordAlloc( struct AllocArena *paa, size_t bytes );

STDAPI_(void)
AllocArenaRecordReAlloc( struct HeapAllocRec FAR *vp,
			size_t oldbytes, size_t newbytes );

STDAPI_(void)
AllocArenaRecordFree( struct HeapAllocRec FAR *vp, size_t bytes );

STDAPI_(void)
AllocArenaDump( struct AllocArena *paa );

STDAPI_( void )
AllocArenaDumpRecord( struct HeapAllocRec FAR *bp );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\include\iadsp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Wed Sep 03 00:29:14 1997
 */
/* Compiler settings for adsp.odl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __iadsp_h__
#define __iadsp_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IADsObjectOptions_FWD_DEFINED__
#define __IADsObjectOptions_FWD_DEFINED__
typedef interface IADsObjectOptions IADsObjectOptions;
#endif 	/* __IADsObjectOptions_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ActiveDsP_LIBRARY_DEFINED__
#define __ActiveDsP_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ActiveDsP
 * at Wed Sep 03 00:29:14 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_ActiveDsP;

#ifndef __IADsObjectOptions_INTERFACE_DEFINED__
#define __IADsObjectOptions_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IADsObjectOptions
 * at Wed Sep 03 00:29:14 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][uuid] */ 



EXTERN_C const IID IID_IADsObjectOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("46f14fda-232b-11d1-a808-00c04fd8d5a8")
    IADsObjectOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOption( 
            DWORD dwOption,
            void __RPC_FAR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOption( 
            DWORD dwOption,
            void __RPC_FAR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsObjectOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IADsObjectOptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IADsObjectOptions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IADsObjectOptions __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOption )( 
            IADsObjectOptions __RPC_FAR * This,
            DWORD dwOption,
            void __RPC_FAR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )( 
            IADsObjectOptions __RPC_FAR * This,
            DWORD dwOption,
            void __RPC_FAR *pValue);
        
        END_INTERFACE
    } IADsObjectOptionsVtbl;

    interface IADsObjectOptions
    {
        CONST_VTBL struct IADsObjectOptionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsObjectOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsObjectOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsObjectOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsObjectOptions_GetOption(This,dwOption,pValue)	\
    (This)->lpVtbl -> GetOption(This,dwOption,pValue)

#define IADsObjectOptions_SetOption(This,dwOption,pValue)	\
    (This)->lpVtbl -> SetOption(This,dwOption,pValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsObjectOptions_GetOption_Proxy( 
    IADsObjectOptions __RPC_FAR * This,
    DWORD dwOption,
    void __RPC_FAR *pValue);


void __RPC_STUB IADsObjectOptions_GetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsObjectOptions_SetOption_Proxy( 
    IADsObjectOptions __RPC_FAR * This,
    DWORD dwOption,
    void __RPC_FAR *pValue);


void __RPC_STUB IADsObjectOptions_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsObjectOptions_INTERFACE_DEFINED__ */

#endif /* __ActiveDsP_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\include\oledsdbg.h ===
//+-------------------------------------------------------------------------
//
// File:      oledsdbg.h
//
// Contains:  Debugging stuff for use by the ADs code
//
// History:
//
//
//--------------------------------------------------------------------------

#ifndef _ADSDBG_H_
#define _ADSDBG_H_
//--------------------------------------------------------------------------
//
// Debugging Stuff
//
//--------------------------------------------------------------------------


#include <formdeb.h>

#if DBG == 1
#define ADsDebugOut(x)  ADsInlineDebugOut x
#define ADsAssert(x)    Win4Assert(x)
#define ADsVerify(x)    ADsAssert(x)

//
// HeapValidate() is only available from NTs kernel32.dll
//

#if defined(DAYTONA)
#define VDATEHEAP()       Win4Assert(HeapValidate(GetProcessHeap(), 0, NULL))
#else
#define VDATEHEAP()
#endif

#else
#define ADsDebugOut(x)
#define ADsAssert(x)
#define ADsVerify(x)    x
#define VDATEHEAP()
#endif


DECLARE_DEBUG(ADs);

#ifdef Assert
#undef Assert
#endif

//
// You should use ADsAssert, not Assert
//
#define Assert(x) ADsAssert(x)

#endif //_ADSDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\include\memory.h ===
#ifndef _MEMORY_H_INCLUDED_
#define _MEMORY_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

LPVOID
AllocADsMem(
    DWORD cb
);

BOOL
FreeADsMem(
   LPVOID pMem
);

LPVOID
ReallocADsMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

LPWSTR
AllocADsStr(
    LPWSTR pStr
);

BOOL
FreeADsStr(
   LPWSTR pStr
);


BOOL
ReallocADsStr(
   LPWSTR *ppStr,
   LPWSTR pStr
);

#if DBG

extern LIST_ENTRY ADsMemList ;

extern CRITICAL_SECTION ADsMemCritSect ;

VOID InitADsMem(
    VOID
    ) ;

VOID AssertADsMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();


#else

#define InitADsMem()
#define AssertADsMemLeaks()

#define DumpMemoryTracker()



#endif

#ifdef __cplusplus
}
#endif


#endif // _MEMORY_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\include\rowprov.h ===
//-----------------------------------------------------------------------------------
// Microsoft OLE DB Provider for ODBC data
// (C) Copyright 1994 - 1996 By Microsoft Corporation.
//
// @doc
//
// @module ROWPROV.H | Definition of the Row Provider interface used by the generic
//					   flavor of the TempTable.
//
//
// @rev 1 | 04-03-96 | WlodekN | Created
// @rev 2 | 07-24-96 | EricJ   | Added PropID
//
//-----------------------------------------------------------------------------------


#ifndef __ROWPROV_INCL__
#define __ROWPROV_INCL__


//---------------------------------- C L A S S E S ----------------------------------


// Abstract class for objects providing row data to the generic TempTable.
class IRowProvider : public IUnknown
{
	public:
		virtual STDMETHODIMP GetColumn
				(
				ULONG		icol,
				DBSTATUS	*pwStatus,
				ULONG		*pdwLength,
				BYTE		*pbData
				) = 0;
		virtual STDMETHODIMP NextRow
				(
				void
				) = 0;
};

EXTERN_C const IID IID_IRowProvider;
EXTERN_C const GUID DBPROPSET_TEMPTABLE;

// TempTable Property IDs.
enum tagetmptablepropid
{
	DBPROP_INSTANTPOPULATION=2,	// TRUE = Prepopulate.  FALSE = Lazy population.
	DBPROP_DBCOLBYREF,			// TRUE = Clear BYREF flags from IColumnsInfo, source owns memory.
	DBPROP_DONTALLOCBYREFCOLS,	// TRUE = TempTable only allocates ptr for BYREF columns.
};


#endif	// __ROWPROV_INCL__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\win95.inc ===
#
# These flags do not get used because we do our
# own thing (for now).
#

CHICAGO_PRODUCT=1
ALT_PROJECT_TARGET=win95

#
# Instead of the CHICAGO_PRODUCT flag, we just
# use USE_MAPSYM so BINPLACE works.  (I think.)
#

#USE_MAPSYM=1

#
# Default target path. Can be overridden after include.
#

TARGET_PATH=$(DSLIBRARY)\chicago
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\include\svcprov.h ===
#include "rpc.h"
#include "rpcndr.h"

#ifndef __svcprov_h__
#define __svcprov_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IProvideDBService_FWD_DEFINED__
#define __IProvideDBService_FWD_DEFINED__
typedef interface IProvideDBService IProvideDBService;
#endif 	/* __IProvideDBService_FWD_DEFINED__ */

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IProvideDBService_INTERFACE_DEFINED__
#define __IProvideDBService_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideDBService
 * at Mon Apr 22 16:40:51 1996
 * using MIDL 2.00.72
 ****************************************/
/* [unique][uuid][object][local] */ 

// @msg IID_IProvideDBService | {EFF65380-9C98-11CF-B963-00AA0044773D}
DEFINE_GUID(IID_IProvideDBService, 0xEFF65380L,0x9C98,0x11CF,0xB9,0x63,0x00,0xAA,0x00,0x44,0x77,0x3D);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideDBService : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ProvideService( 
            /* [in] */ ULONG cProvidedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
            /* [in] */ ULONG cRequestedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ IUnknown __RPC_FAR *pDataProvider,
            /* [in] */ REFIID riidRequested,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider) = 0;
        
    };
    
#else 	/* C style interface */
    
    typedef struct IProvideDBServiceVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IProvideDBService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IProvideDBService __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IProvideDBService __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *ProvideService )( 
            IProvideDBService __RPC_FAR * This,
            /* [in] */ ULONG cProvidedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
            /* [in] */ ULONG cRequestedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ IUnknown __RPC_FAR *pDataProvider,
            /* [in] */ REFIID riidRequested,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider);
        
    } IProvideDBServiceVtbl;
    
    interface IProvideDBService
    {
        CONST_VTBL struct IProvideDBServiceVtbl __RPC_FAR *lpVtbl;
    };
    
    

#ifdef COBJMACROS


#define IProvideDBService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideDBService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideDBService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideDBService_ProvideService(This,cProvidedProperties,rgProvidedProperties,cRequestedProperties,rgRequestedProperties,pUnkOuter,pDataProvider,riidRequested,ppServiceProvider)	\
    (This)->lpVtbl -> ProvideService(This,cProvidedProperties,rgProvidedProperties,cRequestedProperties,rgRequestedProperties,pUnkOuter,pDataProvider,riidRequested,ppServiceProvider)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IProvideDBService_ProvideService_Proxy( 
    IProvideDBService __RPC_FAR * This,
    /* [in] */ ULONG cProvidedPropertySets,
    /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
    /* [in] */ ULONG cRequestedPropertySets,
    /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ IUnknown __RPC_FAR *pDataProvider,
    /* [in] */ REFIID riidRequested,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider);



void __RPC_STUB IProvideDBService_ProvideService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideDBService_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\charset.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    charset.h

Abstract:

    Contains prototypes Unicode <-> Ansi/MBCS conversions (see charset.c)

Author:

    Danilo Almeida  (t-danal)  06-17-96

Revision History:

--*/

#include <windows.h>
#include <malloc.h>

//
// Memory allocation macros
//

#define                                                      \
AllocMem(                                                    \
    Size,                                                    \
    pBuffer                                                  \
    )                                                        \
(                                                            \
    (*pBuffer = (LPBYTE)malloc((size_t)Size)) == NULL        \
    ?                                                        \
    ERROR_NOT_ENOUGH_MEMORY                                  \
    :                                                        \
    NO_ERROR                                                 \
);

#define                                                      \
FreeMem(                                                     \
    Buffer                                                   \
    )                                                        \
(                                                            \
    free((void *)Buffer)                                     \
);


// Function prototypes

UINT
AllocAnsi(
    LPCWSTR pwszUnicode,
    LPSTR *ppszAnsi
    );

VOID
FreeAnsi(
    LPSTR pszAnsi
    );

UINT
AllocUnicode(
    LPCSTR pszAnsi,
    LPWSTR *ppwszUnicode
    );

int
AllocUnicode2(
    LPCSTR pszAnsi,
    int cch,
    LPWSTR *ppwszUnicode
    );

VOID
FreeUnicode(
    LPWSTR pwszUnicodeAllocated
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\nexus.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nexus.h

Abstract:

    Contains some thunking for Net APIs

Author:

    Danilo Almeida  (t-danal)  06-27-96

Revision History:

--*/

#include "nexus.h"

NET_API_STATUS NET_API_FUNCTION
NetGetDCName (
    LPCWSTR servername,
    LPCWSTR domainname,
    LPBYTE *bufptr
)
{
    return NetGetDCNameW(servername,
                         domainname,
                         bufptr);
}

NET_API_STATUS NET_API_FUNCTION
NetServerEnum(
    LPCWSTR   ServerName,
    DWORD    Level,
    LPBYTE * BufPtr,
    DWORD    PrefMaxLen,
    LPDWORD  EntriesRead,
    LPDWORD  TotalEntries,
    DWORD    ServerType,
    LPCWSTR   Domain,
    LPDWORD  ResumeHandle
)
{
    return NetServerEnumW(ServerName, 
                          Level, 
                          BufPtr, 
                          PrefMaxLen, 
                          EntriesRead, 
                          TotalEntries, 
                          ServerType, 
                          Domain, 
                          ResumeHandle);
}

NET_API_STATUS NET_API_FUNCTION
NetUserChangePassword(
    LPCWSTR domainname,  // pointer to server or domain name string
    LPCWSTR username,    // pointer to user name string
    LPCWSTR oldpassword, // pointer to old password string
    LPCWSTR newpassword  // pointer to new password string
)
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}
/*
HANDLE WINAPI
AddPrinterW(
    LPWSTR pName,      // pointer to server name 
    DWORD Level,       // printer info. structure level  
    LPBYTE pPrinter    // pointer to structure 
)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return NULL;
}
BOOL WINAPI
SetJobW(
    HANDLE hPrinter,    // handle of printer object 
    DWORD JobId,        // job-identification value 
    DWORD Level,        // structure level 
    LPBYTE  Job,        // address of job info structures  
    DWORD Command       // job-command value 
)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

BOOL WINAPI
EnumPrintersW(
    DWORD Flags,        // types of printer objects to enumerate 
    LPTSTR Name,        // name of printer object 
    DWORD Level,        // specifies type of printer info structure 
    LPBYTE pPrinterEnum,// points to buffer to receive printer info structures 
    DWORD cbBuf,        // size, in bytes, of array 
    LPDWORD pcbNeeded,  // points to num of bytes copied or required
    LPDWORD pcReturned  // points to num of printer info. structures copied 
)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\include\oledserr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oledserr.h

Abstract:

    Contains the entry point for
        ADsGetLastError
        ADsSetLastError
        ADsFreeAllErrorRecords

Author:


    Ram Viswanathan (ramv) 20-Sep-1996

Environment:

    User Mode - Win32


---*/

#ifndef _OLEDSERR_H_INCLUDED_
#define _OLEDSERR_H_INCLUDED_

#ifdef _cplusplus
extern "C" {
#endif

HRESULT
ADsGetLastError(
    OUT     LPDWORD lpError,
    OUT     LPWSTR  lpErrorBuf,
    IN      DWORD   dwErrorBufLen,
    OUT     LPWSTR  lpNameBuf,
    IN      DWORD   dwNameBufLen
    );

VOID
ADsSetLastError(
    IN  DWORD   dwErr,
    IN  LPWSTR  pszError,
    IN  LPWSTR  pszProvider
    );

VOID
ADsFreeAllErrorRecords(
    VOID
    );

//=======================
// Data Structures
//=======================

typedef struct _ERROR_RECORD {
    struct  _ERROR_RECORD   *Prev;
    struct  _ERROR_RECORD   *Next;
    DWORD                   dwThreadId;
    DWORD                   dwErrorCode;
    LPWSTR                  pszErrorText;      // This is an allocated buffer
    LPWSTR                  pszProviderName;   // This is an allocated buffer
} ERROR_RECORD, *LPERROR_RECORD;



//
// Global Data Structures
//

extern 
ERROR_RECORD        ADsErrorRecList;    // Initialized to zeros by loader

extern
CRITICAL_SECTION    ADsErrorRecCritSec; // Initialized in libmain.cxx



//=======================
// MACROS
//=======================

#define FIND_END_OF_LIST(record)    while(record->Next != NULL) {   \
                                        record=record->Next;        \
                                    }

#define REMOVE_FROM_LIST(record)    record->Prev->Next = record->Next;      \
                                    if (record->Next != NULL) {             \
                                        record->Next->Prev = record->Prev;  \
                                    }

#define ADD_TO_LIST(record, newRec) FIND_END_OF_LIST(record)    \
                                    record->Next = newRec;      \
                                    newRec->Prev = record;      \
                                    newRec->Next = NULL;


//
// Local Functions
//

LPERROR_RECORD
ADsAllocErrorRecord(
    VOID);

LPERROR_RECORD
ADsFindErrorRecord(
    VOID);

#ifdef _cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\nexus.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nexus.h

Abstract:

    Contains some thunking for Net APIs

Author:

    Danilo Almeida  (t-danal)  06-27-96

Revision History:

--*/

#ifndef __OLEDS_NEXUS__
#define __OLEDS_NEXUS__

#include <windows.h>
#include <lm.h>

#ifdef __cplusplus
extern "C" {
#endif

NET_API_STATUS NET_API_FUNCTION
NetGetDCNameW (
    LPCWSTR servername,
    LPCWSTR domainname,
    LPBYTE *bufptr
);

NET_API_STATUS NET_API_FUNCTION
NetServerEnumW(
    LPCWSTR  ServerName,
    DWORD    Level,
    LPBYTE * BufPtr,
    DWORD    PrefMaxLen,
    LPDWORD  EntriesRead,
    LPDWORD  TotalEntries,
    DWORD    ServerType,
    LPCWSTR  Domain,
    LPDWORD  ResumeHandle
);

#ifdef __cplusplus
}
#endif

#endif // __OLEDS_NEXUS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\charset.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    charset.c

Abstract:

    Contains some functions to do Unicode <-> Ansi/MBCS convertsions.

Author:

    Danilo Almeida  (t-danal)  06-17-96

Revision History:

--*/


//
// INCLUDES
//

#include <string.h>
#include "charset.h"

/*
 *  AnsiBytesFromUnicode
 *
 *  Description:
 *      Given a Unicode string, returns number of bytes needed for Ansi version
 *
 *  In:
 *      pwszUnicode - pointer to Unicode string
 */

int
AnsiBytesFromUnicode(
    LPCWSTR pwszUnicode
    )
{
    return WideCharToMultiByte(CP_ACP,
                               0,
                               pwszUnicode,
                               -1,
                               NULL,
                               0,
                               NULL,
                               NULL);
}


/*
 *  AllocAnsi
 *
 *  Description:
 *      Given a Unicode string, allocate a new Ansi translation of that string
 *
 *  In:
 *      pwszUnicode - pointer to original Unicode string
 *      ppszAnsi    - pointer to cell to hold new MCBS string addr
 *
 *  Out:
 *      ppszAnsi    - contains new MBCS string
 *
 *  Returns:
 *      Error code or 0 if successful.
 *
 *  Notes:
 *      The client must free the allocated string with FreeAnsi.
 */

UINT
AllocAnsi(
    LPCWSTR pwszUnicode,
    LPSTR* ppszAnsi
    )
{
    UINT     err;
    BYTE *   pbAlloc;
    INT      cbUnicode;
    INT      cbAnsi;

    if (pwszUnicode == NULL)
    {
        *ppszAnsi = NULL;
        return 0;
    }

    cbAnsi = AnsiBytesFromUnicode(pwszUnicode);
    err = AllocMem(cbAnsi, &pbAlloc);
    if (err)
        return err;

    cbUnicode = wcslen(pwszUnicode)+1;

    *ppszAnsi = (LPSTR)pbAlloc;

    err = (UINT) !WideCharToMultiByte(CP_ACP,
                                      0,
                                      pwszUnicode,
                                      cbUnicode,
                                      *ppszAnsi,
                                      cbAnsi,
                                      NULL,
                                      NULL);
    if (err)
    {
        *ppszAnsi = NULL;
        FreeMem(pbAlloc);
        return ( (UINT)GetLastError() );
    }

    return 0;
}


/*
 *  FreeAnsi
 *
 *  Description:
 *      Deallocates an Ansi string allocated by AllocAnsi
 *
 *  In:
 *      pszAnsi - pointer to the Ansi string
 *
 *  Out:
 *      pszAnsi - invalid pointer - string has been freed
 */

VOID
FreeAnsi(LPSTR pszAnsi)
{
    if (pszAnsi != NULL)
        FreeMem((LPBYTE)pszAnsi);
}

/*
 *  AllocUnicode
 *
 *  Description:
 *      Given an Ansi string, allocates an Unicode version of that string
 *
 *  In:
 *      pszAnsi         - pointer to original MBCS string
 *      ppwszUnicode    - pointer to new Unicode string address
 *
 *  Out:
 *      ppwszUnicode    - points to new Unicode string
 *
 *  Returns:
 *      Error code or 0 if successful.
 *
 *  Notes:
 *      The client must free the allocated string with FreeUnicode.
 */

UINT
AllocUnicode(
    LPCSTR   pszAnsi,
    LPWSTR * ppwszUnicode )
{
    UINT     err;
    BYTE *   pbAlloc;
    INT      cbAnsi;

    if (pszAnsi == NULL)
    {
        *ppwszUnicode = NULL;
        return 0;
    }

    // Allocate space for Unicode string (may be a little extra if MBCS)

    cbAnsi = strlen(pszAnsi)+1;
    err = AllocMem(sizeof(WCHAR) * cbAnsi, &pbAlloc);
    if (err)
        return err;

    *ppwszUnicode = (LPWSTR)pbAlloc;

    err = (UINT) !MultiByteToWideChar(CP_ACP,
                                      MB_PRECOMPOSED,
                                      pszAnsi,
                                      cbAnsi,
                                      *ppwszUnicode,
                                      cbAnsi);
    if (err)
    {
        *ppwszUnicode = NULL;
        FreeMem(pbAlloc);
        return ( (UINT)GetLastError() );
    }

    return 0;
}

/*
 *  AllocUnicode2
 *
 *  Description:
 *      Given a MBCS string, allocates a new Unicode version of that string
 *
 *  In:
 *      pszAnsi         - pointer to original MBCS string
 *      cbAnsi          - number of bytes to convert
 *      ppwszUnicode    - pointer to where to return new Unicode string address
 *
 *  Out:
 *      ppwszUnicode    - contains new Unicode string
 *
 *  Returns:
 *      Returns number of characters written.
 *
 *  Notes:
 *      The client must free the allocated string with FreeUnicode.
 */

int
AllocUnicode2(
    LPCSTR   pszAnsi,
    int      cbAnsi,
    LPWSTR * ppwszUnicode)
{
    UINT     err;
    BYTE *   pbAlloc;
    INT      cwch;

    *ppwszUnicode = NULL;
    SetLastError(ERROR_SUCCESS);

    if (cbAnsi == 0)
        return 0;

    err = AllocMem(sizeof(WCHAR) * cbAnsi, &pbAlloc);
    if (err)
    {
        SetLastError(err);
        return 0;
    }

    *ppwszUnicode = (LPWSTR)pbAlloc;

    cwch = MultiByteToWideChar(CP_ACP,
                               MB_PRECOMPOSED,
                               pszAnsi,
                               cbAnsi,
                               *ppwszUnicode,
                               cbAnsi);

    if (cwch == 0)
    {
        *ppwszUnicode = NULL;
        FreeMem(pbAlloc);
    }

    return cwch;
}

/*
 *  FreeUnicode
 *
 *  Description:
 *      Deallocates a Unicode string allocatedd by AllocUnicode/AllocUnicode2
 *
 *  In:
 *      pwszUnicode - pointer to the Unicode string
 *
 *  Out:
 *      pwszUnicode - invalid pointer - string has been freed
 */

VOID
FreeUnicode( LPWSTR pwszUnicode )
{
    if (pwszUnicode != NULL)
        FreeMem((LPBYTE)pwszUnicode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\win95reg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    win95reg.h

Abstract:

    Contains some thunking for Unicode Registry APIs (Local Calls only)

Author:

    Danilo Almeida  (t-danal)  07-01-96

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WINREG_
#ifndef __WIN95REG__
#define __WIN95REG__

#define RegOpenKeyExW     Win95RegOpenKeyExW
#define RegQueryValueExW  Win95RegQueryValueExW
#define RegSetValueExW    Win95RegSetValueExW
#define RegEnumKeyExW     Win95RegEnumKeyExW
#define RegCreateKeyExW   Win95RegCreateKeyExW

LONG
APIENTRY
RegOpenKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

LONG
APIENTRY
RegQueryValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG
APIENTRY
RegSetValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

LONG
APIENTRY
RegEnumKeyExW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );

LONG
APIENTRY
RegCreateKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

#endif // __WIN95REG__
#endif // _WINREG_

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\win95reg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    win95reg.c

Abstract:

    Contains some thunking for Unicode Registry APIs (Local Calls only)

Author:

    Danilo Almeida  (t-danal)  07-01-96

Revision History:

--*/

#include <windows.h>
#include "charset.h"
#include "win95reg.h"
#include <stdlib.h>

#define IsRegString(x) \
              ((x == REG_SZ) || (x == REG_EXPAND_SZ) || (x == REG_MULTI_SZ))

DWORD
RegStringConvert(
    DWORD Type, 
    LPCSTR pszAnsi, 
    LPWSTR *ppszWide,
    LPDWORD lpcbWide)
{
    int cbAnsi;
    int ccAnsi;
    int cb;
    int cc;
    LPWSTR pszWide;
    UINT err;

    if (!ppszWide)
        return ERROR_INVALID_PARAMETER;

    if (!lpcbWide)
        return ERROR_INVALID_PARAMETER;

    if (!pszAnsi)
    {
        *lpcbWide = 0;
        return ERROR_SUCCESS;
    }

    if (Type != REG_MULTI_SZ)
        cbAnsi = strlen(pszAnsi) + 1;
    else
    {
        cbAnsi = 0;
        do {
            cb = strlen(pszAnsi+cbAnsi) + 1;
            cbAnsi += cb;
        } while (*pszAnsi);
    }

    err = AllocMem(cbAnsi * sizeof(WCHAR), (LPBYTE *) ppszWide);
    if (err)
        return err;
    pszWide = *ppszWide;

    *lpcbWide = sizeof(WCHAR) *
                MultiByteToWideChar(CP_ACP,
                               MB_PRECOMPOSED,
                               pszAnsi,
                               cbAnsi,
                               pszWide,
                               cbAnsi * sizeof(WCHAR));
    if (*lpcbWide == 0)
    {
        if (pszWide)
            FreeMem(pszWide);
        return GetLastError();
    }
    return ERROR_SUCCESS;
}

DWORD
RegEnumKeyExUnicodeString(
    HKEY hKey,
    DWORD dwIndex,
    LPDWORD lpReserved,
    LPBYTE *pNameBuf,
    LPDWORD lpcbName,
    LPBYTE *pClassBuf,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )
{
    LONG result;
    UINT err;

    LPBYTE NameBuf;
    LPBYTE ClassBuf = NULL;

    DWORD cbName;
    DWORD cbClass;

    if (!lpcbName)
        return ERROR_INVALID_PARAMETER;

    cbName = (*lpcbName)++;
    err = AllocMem(cbName + 1, &NameBuf);
    if (err)
        return err;

    if (lpcbClass)
    {
        cbClass = (*lpcbClass)++;
        err = AllocMem(cbClass + 1, &ClassBuf);
        if (err)
        {
            FreeMem(NameBuf);
            return err;
        }
    }

    result = RegEnumKeyExA(
                  hKey,
                  dwIndex,
                  NameBuf,
                  lpcbName,
                  lpReserved,
                  ClassBuf,
                  lpcbClass,
                  lpftLastWriteTime
                  );

    if (result == ERROR_MORE_DATA ||
        cbName != *lpcbName ||
        (lpcbClass && cbClass != *lpcbClass))
        result = ERROR_INVALID_DATA;
    else if (result == ERROR_SUCCESS)
    {
        result = RegStringConvert(
            REG_SZ, 
            (LPCSTR)NameBuf, 
            (LPWSTR *)pNameBuf, 
            lpcbName
            );
        if (result != ERROR_SUCCESS)
            goto cleanup;
        if (lpcbClass)
            result = RegStringConvert(
                REG_SZ, 
                (LPCSTR)ClassBuf, 
                (LPWSTR *)pClassBuf, 
                lpcbClass
                );
        if (result != ERROR_SUCCESS)
            goto cleanup;

        // Want number of chars, not bytes, subtracting out the NULL
        *lpcbName /= sizeof(WCHAR);
        *lpcbName--;
        if (lpcbClass) {
            *lpcbClass /= sizeof(WCHAR);
            *lpcbClass--;
        }
    }

cleanup:
    if (ClassBuf)
        FreeMem(ClassBuf);
    FreeMem(NameBuf);
    return result;
}

DWORD
RegQueryValueExUnicodeString(
    HKEY hKey,
    LPCSTR lpValueNameA,
    LPDWORD lpReserved,
    DWORD TypeReq,
    LPDWORD lpcbData,
    LPBYTE *pBuffer
    )
{
    LONG result;
    UINT err;

    LPBYTE Buffer;

    DWORD Type;
    DWORD cbData;

    err = AllocMem(*lpcbData, &Buffer);
    if (err)
        return err;

    cbData = *lpcbData;
    result = RegQueryValueExA(
                  hKey,
                  lpValueNameA,
                  lpReserved,
                  &Type,
                  Buffer,
                  &cbData
                  );

    if (result == ERROR_MORE_DATA ||
        (result == ERROR_SUCCESS && (Type != TypeReq ||
                                     cbData != *lpcbData)))
        result = ERROR_INVALID_DATA;
    else if (result == ERROR_SUCCESS)
        result = RegStringConvert(
            Type, 
            (LPCSTR)Buffer, 
            (LPWSTR *)pBuffer, 
            lpcbData
            );

    FreeMem(Buffer);
    return result;
}

LONG
APIENTRY
RegOpenKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    LPSTR lpSubKeyA;
    LONG result;
    UINT err;

    err = AllocAnsi(lpSubKey, &lpSubKeyA);
    if (err)
        return (LONG) err;
    result = RegOpenKeyExA(
                 hKey, 
                 lpSubKeyA, 
                 ulOptions, 
                 samDesired, 
                 phkResult
                 );
    FreeAnsi(lpSubKeyA);
    return result;
}


LONG
APIENTRY
RegQueryValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    LPSTR lpValueNameA = NULL;
    LONG result;
    UINT err;

    DWORD Type;
    DWORD ccWide;
    DWORD cbData = *lpcbData;
    LPBYTE Buffer = NULL;

    if (lpData && !lpcbData)
        return ERROR_INVALID_PARAMETER;

    err = AllocAnsi(lpValueName, &lpValueNameA);
    if (err)
        return err;

    result = RegQueryValueExA(
                 hKey,
                 lpValueNameA,
                 lpReserved,
                 &Type,
                 lpData,
                 lpcbData
                 );

    if (lpType)
        *lpType = Type;

    if (result != ERROR_SUCCESS && 
        result != ERROR_MORE_DATA)    // Did the call err?
        goto cleanup;

    if (!IsRegString(Type))    // Do we have a string?
        goto cleanup;
    if (!lpData && !lpcbData)  // If both are NULL, no extra work
        goto cleanup;

    result = RegQueryValueExUnicodeString(
                              hKey, 
                              lpValueNameA, 
                              lpReserved, 
                              Type, 
                              lpcbData, 
                              &Buffer
                              );

    if (result == ERROR_SUCCESS)
    {
        if (cbData < *lpcbData)
            result = ERROR_MORE_DATA;
        else
            CopyMemory(lpData, Buffer, *lpcbData);
    }

cleanup:
    if (lpValueNameA != NULL)
         FreeAnsi(lpValueNameA);
    if (Buffer != NULL)
         FreeMem(Buffer);
    return result;
}
                                         
LONG
APIENTRY
RegSetValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    )
{
    LPSTR lpValueNameA;
    LONG result;
    UINT err;
    LPSTR lpDataA = NULL;

    err = AllocAnsi(lpValueName, &lpValueNameA);
    if (err)
        return (LONG) err;
    if (IsRegString(dwType)) {
        AllocAnsi((LPWSTR)lpData, &lpDataA);
        lpData = (CONST BYTE *)lpDataA;
    }
    result = RegSetValueExA(
                 hKey,
                 lpValueNameA,
                 Reserved,
                 dwType,
                 lpData,
                 cbData
                 );
    FreeAnsi(lpValueNameA);
    if (lpDataA)
        FreeAnsi(lpDataA);
    return result;
}

LONG
APIENTRY
RegEnumKeyExW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )
{
    LONG result;
    UINT err;

    DWORD cbName;
    DWORD cbClass;

    LPBYTE NameBuf = NULL;
    LPBYTE ClassBuf = NULL;

    if (lpcbName)
        cbName = *lpcbName;
    else
        return ERROR_INVALID_PARAMETER;

    if (lpcbClass)
        cbClass = *lpcbClass;

    result = RegEnumKeyExA(
                 hKey,
                 dwIndex,
                 (LPSTR)lpName,
                 lpcbName,
                 lpReserved,
                 (LPSTR)lpClass,
                 lpcbClass,
                 lpftLastWriteTime
                 );

    if (result != ERROR_SUCCESS && result != ERROR_MORE_DATA)
        return result;

    result = RegEnumKeyExUnicodeString(
                 hKey,
                 dwIndex,
                 lpReserved,
                 &NameBuf,
                 lpcbName,
                 &ClassBuf,
                 lpcbClass,
                 lpftLastWriteTime
                 );
    
    if (result == ERROR_SUCCESS)
    {
        if ((cbName < *lpcbName) ||
            (lpcbClass && (cbClass < *lpcbClass)))
            result = ERROR_MORE_DATA;
        else
        {
            CopyMemory(lpName, NameBuf, sizeof(WCHAR)*(*lpcbName+1));
            if (lpcbClass)
                CopyMemory(lpClass, ClassBuf, sizeof(WCHAR)*(*lpcbClass+1));
        }
    }

    if (NameBuf != NULL)
         FreeMem(NameBuf);
    if (ClassBuf != NULL)
         FreeMem(ClassBuf);
    return result;
}

LONG
APIENTRY
RegCreateKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    LPSTR lpSubKeyA;
    LPSTR lpClassA;
    LONG result;
    UINT err;

    err = AllocAnsi(lpSubKey, &lpSubKeyA);
    if (err)
        return (LONG) err;
    err = AllocAnsi(lpClass, &lpClassA);
    if (err) {
        FreeAnsi(lpSubKeyA);
        return (LONG) err;
    }
    result = RegCreateKeyExA(
                 hKey,
                 lpSubKeyA,
                 Reserved,
                 lpClassA,
                 dwOptions,
                 samDesired,
                 lpSecurityAttributes,
                 phkResult,
                 lpdwDisposition
                 );
    FreeAnsi(lpSubKeyA);
    FreeAnsi(lpClassA);
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\setup\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for adsiis.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "schema.h"

#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include "dbgutil.h"
#pragma hdrstop


#ifdef _NO_TRACING_
DECLARE_DEBUG_PRINTS_OBJECT()
DECLARE_DEBUG_VARIABLE();
#endif


//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT("iisschema");
        SET_DEBUG_FLAGS(DEBUG_ERROR);
#endif
        break;


    case DLL_PROCESS_DETACH:
#ifdef _NO_TRACING_
        DELETE_DEBUG_PRINT_OBJECT();
#endif
        break;

    default:
        break;
    }
    return TRUE;
}


//+------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Register registry keys for adsiis
//
//  Arguments:  None
//
//-------------------------------------------------------------------------

STDAPI DllRegisterServer(
    )
{
        HRESULT hr = E_FAIL;
	HRESULT hrCoInit = CoInitialize(NULL);
        if( SUCCEEDED(hrCoInit) ) 
        {
            hr = StoreSchema();
	    CoUninitialize();
        }
	return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Register registry keys for adsiis
//
//  Arguments:  None
//
//+------------------------------------------------------------------------
STDAPI DllUnregisterServer(void) {

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\setup\schema.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:
//
//  History:
//
//  Note:
//
//----------------------------------------------------------------------------
#define _OLEAUT32_
#define _LARGE_INTEGER_SUPPORT_

#define UNICODE
#define _UNICODE

#define INC_OLE2

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <winspool.h>


//
// ********* CRunTime Includes
//

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#include <io.h>
#include <wchar.h>
#include <tchar.h>


//
// ********* IIS Includes
//


#ifdef __cplusplus
extern "C" {
#endif

#include "iis64.h"
#include "iissynid.h"
#include "macro.h"
#include "iiscnfgp.h"

#ifdef __cplusplus
}
#endif

#include "mddef.h"
#include "cschema.hxx"
#include <tchar.h>

#include "iiscnfg.h"
extern HRESULT StoreSchema();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\win95api.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    win95api.h

Abstract:

    Contains some thunking for Unicode KERNEL32 and USER32 APIs

Author:

    Danilo Almeida  (t-danal)  07-01-96

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WINBASE_
#ifndef __WIN95BASE__
#define __WIN95BASE__

// KERNEL32.DLL

#define GetProfileIntW                  Win95GetProfileIntW
#define CreateSemaphoreW                Win95CreateSemaphoreW
#define LoadLibraryW                    Win95LoadLibraryW
#define SystemTimeToTzSpecificLocalTime Win95SystemTimeToTzSpecificLocalTime

UINT
WINAPI
GetProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault
    );

HANDLE
WINAPI
CreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    );

HMODULE
WINAPI
LoadLibraryW(
    LPCWSTR lpLibFileName
    );

BOOL
WINAPI
SystemTimeToTzSpecificLocalTime(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
    LPSYSTEMTIME lpUniversalTime,
    LPSYSTEMTIME lpLocalTime
    );

#endif // __WIN95BASE__
#endif // _WINBASE_ (KERNEL32.DLL)


// USER32.DLL

#ifdef _WINUSER_
#ifndef __WIN95USER__
#define __WIN95USER__

#define wvsprintfW                      Win95wvsprintfW
#define wsprintfW                       Win95wsprintfW

int
WINAPI
wvsprintfW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    va_list arglist);

int
WINAPIV
wsprintfW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    ...);

#endif // __WIN95USER__
#endif // _WINUSER_ (USER32.DLL)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\setup\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{obj\$(TARGET_DIRECTORY)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\setup\metacfg.cxx ===
#include "schema.h"
#pragma hdrstop

#include "initguid.h"
#include "iadmw.h"
#include "schemini.hxx"

#if _IIS_6_0
#include "..\adsiis\globdata.cxx"
#elif _IIS_5_1
#include "..\adsiis\iis51\globdata.cxx"
#else
#error "Neither _IIS_6_0 nor _IIS_5_1 is defined"
#endif

#define DEFAULT_TIMEOUT_VALUE                    30000

HRESULT SetAdminACL(IMSAdminBase * pAdminBase);
DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    );

MetaHandle::MetaHandle(IMSAdminBasePtr _pmb) : pmb(_pmb) {
    if (pmb)
        pmb->AddRef();
    h = 0;
}
MetaHandle::~MetaHandle() {
    if (pmb) {
        if (h)
            pmb->CloseKey(h);
        pmb->Release();
    }
}

struct WideStrMapEntry {
    LPWSTR m_str;
    void *m_data;
};

class WideStrMap {
    WideStrMapEntry *map;
    int count;
    int mapSize;
public:
    WideStrMap();
    ~WideStrMap();
    BOOL CheckSpace();
    BOOL Add(LPWSTR str, void *data);
    void *Find(LPWSTR str);
    void *operator[] (LPWSTR str);
};

WideStrMap::WideStrMap() {
    count = 0;
    mapSize = 64;
    map = (WideStrMapEntry *)malloc(sizeof(WideStrMapEntry) * mapSize);
}

WideStrMap::~WideStrMap() {
    free(map);
}

BOOL WideStrMap::CheckSpace() {
    if (count < mapSize)
        return TRUE;
    mapSize += 32;
    if ((map = (WideStrMapEntry *)realloc(map, sizeof(WideStrMapEntry)*mapSize)) == NULL)
        return FALSE;
    return TRUE;
}

BOOL WideStrMap::Add(LPWSTR str, void *data) {
    if (!CheckSpace())
        return FALSE;
    map[count].m_str = str;
    map[count].m_data = data;
    count++;
    return TRUE;
}

void *WideStrMap::Find(LPWSTR str) {
    for (int i=0; i < count; i++) {
        if (!_wcsicmp(str, map[i].m_str))
            return map[i].m_data;
    }
    return NULL;
}

void *WideStrMap::operator[] (LPWSTR str) {
    return Find(str);
}

#if 0
struct PropValue {
    DWORD dwMetaID;
    DWORD dwSynID;
    DWORD dwMetaType;
    DWORD dwFlags;
    BOOL fMultiValued;
    DWORD dwMask;
    DWORD dwMetaFlags;
    DWORD dwUserGroup;
};
#endif

void InitPropValue(PropValue *pv, PROPERTYINFO *pi) {
    pv->dwSynID = pi->dwSyntaxId;
    pv->dwMetaID = pi->dwMetaID;
    pv->dwPropID = pi->dwPropID;
    pv->dwMaxRange = (DWORD)pi->lMaxRange;
    pv->dwMinRange = (DWORD)pi->lMinRange;

    switch(pi->dwSyntaxId) {
    case IIS_SYNTAX_ID_DWORD:
    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
        pv->dwMetaType = DWORD_METADATA;
        break;
    case IIS_SYNTAX_ID_STRING:
        pv->dwMetaType = STRING_METADATA;
        break;
    case IIS_SYNTAX_ID_EXPANDSZ:
        pv->dwMetaType = EXPANDSZ_METADATA;
        break;
    case IIS_SYNTAX_ID_MIMEMAP:
    case IIS_SYNTAX_ID_MULTISZ:
        pv->dwMetaType = MULTISZ_METADATA;
        break;
    case IIS_SYNTAX_ID_NTACL:
    case IIS_SYNTAX_ID_IPSECLIST:
        pv->dwMetaType = BINARY_METADATA;
        break;

    }
    pv->dwFlags = pi->dwFlags;
    pv->fMultiValued = pi->fMultiValued;
    pv->dwMask = pi->dwMask;
    pv->dwMetaFlags = pi->dwMetaFlags;
    pv->dwUserGroup = pi->dwUserGroup;
}

// struct __declspec(__uuid()
static char asciiBuf[2048];

BOOL DataForSyntaxID(PROPERTYINFO *pp, METADATA_RECORD *mdr) {
    static DWORD value=0;
    WCHAR *ptr;
    int i;

    switch(pp->dwSyntaxId) {
    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
    case IIS_SYNTAX_ID_DWORD:
        mdr->dwMDDataType = DWORD_METADATA;
        mdr->dwMDDataLen = sizeof(DWORD);
        mdr->pbMDData = (unsigned char *)&(pp->dwDefault);
        break;
    case IIS_SYNTAX_ID_STRING:
        mdr->dwMDDataType = STRING_METADATA;
        mdr->dwMDDataLen = (wcslen(pp->szDefault)+1)*2;
        mdr->pbMDData = (unsigned char *)pp->szDefault;
        break;
    case IIS_SYNTAX_ID_EXPANDSZ:
        mdr->dwMDDataType = EXPANDSZ_METADATA;
        mdr->dwMDDataLen = (wcslen(pp->szDefault)+1)*2;
        mdr->pbMDData = (unsigned char *)pp->szDefault;
        break;
    case IIS_SYNTAX_ID_MIMEMAP:
    case IIS_SYNTAX_ID_MULTISZ:
        //
        // Note, ALL multisz types must have an extra \0 in the table.
        //
        mdr->dwMDDataType = MULTISZ_METADATA;
        ptr = pp->szDefault;
        do {
            ptr += wcslen(ptr)+1;
        } while (*ptr != 0);
        mdr->dwMDDataLen = DIFF((char *)ptr - (char *)pp->szDefault)+2;
        mdr->pbMDData = (unsigned char *)pp->szDefault;
        break;
    case IIS_SYNTAX_ID_IPSECLIST:
    case IIS_SYNTAX_ID_NTACL:
    case IIS_SYNTAX_ID_BINARY:
        mdr->dwMDDataType = BINARY_METADATA;
        mdr->dwMDDataLen = 0;
        mdr->pbMDData = NULL;
        break;
    default:
        mdr->dwMDDataType = DWORD_METADATA;
        mdr->dwMDDataLen = sizeof(DWORD);
        mdr->pbMDData = (unsigned char *)&value;
        return FALSE;
    }
    return TRUE;
}

const DWORD getAllBufSize = 4096;

wchar_t *grabProp(wchar_t *out, wchar_t *in) {
    if (!in || *in == L'\0') {
        *out = L'\0';
        return NULL;
    }
    while (*in != L',' && *in != L'\0') {
        *out++ = *in++;
    }
    *out = L'\0';
    if (*in == L',')
        return ++in;
    return in;
}


HRESULT StoreSchema() {
    DWORD bufSize = getAllBufSize;
    BYTE *buf = new BYTE[bufSize];
    HRESULT hr;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IMSAdminBase * pAdminBase = NULL;
    METADATA_RECORD mdr;
    wchar_t mandProps[MAX_PATH];
    wchar_t optProps[MAX_PATH];
    wchar_t prop[MAX_PATH], *propList;
    MetaHandle root(NULL);
    DWORD value = 0;
    DWORD i;
    //
    // nameToProp is used for mapping properties by name to the property structures
    // that define the properties.  Since we first run through the list of props,
    // and write out the names, we add the prop to the map.  Then, when we encounter
    // the properties by name, which is how the classes maintain them, we can access
    // the corresponding property structure.
    //
    WideStrMap nameToProp;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));
    pcsiParam->pwszName =  NULL;
    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    hr = CoGetClassObject(
                          CLSID_MSAdminBase,
                          CLSCTX_SERVER,
                          pcsiParam,
                          IID_IClassFactory,
                          (void**) &pcsfFactory
                         );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                                     NULL,
                                     IID_IMSAdminBase,
                                     (void **) &pAdminBase
                                    );
    pcsfFactory->Release();
    BAIL_ON_FAILURE(hr);
    root.setpointer(pAdminBase);
    hr = pAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                             L"",
                             METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                             DEFAULT_TIMEOUT_VALUE,
                             root);
    BAIL_ON_FAILURE(hr);

    hr = pAdminBase->AddKey(root, L"Schema");
    if (FAILED(hr) && HRESULT_CODE(hr) != ERROR_ALREADY_EXISTS) {
        BAIL_ON_FAILURE(hr);
    }
    hr = pAdminBase->AddKey(root, L"Schema/Properties");
    if (FAILED(hr) && HRESULT_CODE(hr) != ERROR_ALREADY_EXISTS) {
        BAIL_ON_FAILURE(hr);
    }

    hr = pAdminBase->AddKey(root, L"Schema/Classes");
    if (FAILED(hr) && HRESULT_CODE(hr) != ERROR_ALREADY_EXISTS) {
        BAIL_ON_FAILURE(hr);
    }

    hr = pAdminBase->AddKey(root, L"Schema/Properties/Names");
    if (FAILED(hr) && HRESULT_CODE(hr) != ERROR_ALREADY_EXISTS) {
        BAIL_ON_FAILURE(hr);
    }

    hr = pAdminBase->AddKey(root, L"Schema/Properties/Types");
    if (FAILED(hr) && HRESULT_CODE(hr) != ERROR_ALREADY_EXISTS) {
        BAIL_ON_FAILURE(hr);
    }

    hr = pAdminBase->AddKey(root, L"Schema/Properties/Defaults");
    if (FAILED(hr) && HRESULT_CODE(hr) != ERROR_ALREADY_EXISTS) {
        BAIL_ON_FAILURE(hr);
    }

    root.close();

    //
    // Now, let's initialize the property dictionary.
    //
    hr = pAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                             L"/Schema/Properties",
                             METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                             DEFAULT_TIMEOUT_VALUE,
                             root);
    BAIL_ON_FAILURE(hr);

    mdr.dwMDDataTag = 0;
    DWORD propData[2];
    PropValue pv;
    for (i=0; i < g_cIISProperties; i++) {
        //
        // First, we set the name prop to the string value of the properties name.
        //
        mdr.dwMDIdentifier = g_aIISProperties[i].dwPropID;
        mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        mdr.dwMDUserType = IIS_MD_UT_SERVER;
        mdr.dwMDDataType = STRING_METADATA;
        mdr.dwMDDataLen = (wcslen(g_aIISProperties[i].szPropertyName)+1)*2;
        mdr.pbMDData = (unsigned char *)g_aIISProperties[i].szPropertyName;
        hr = pAdminBase->SetData(root, L"Names", &mdr);
        BAIL_ON_FAILURE(hr);

        //
        // Next, we need to update the type field.
        //
        InitPropValue(&pv, &g_aIISProperties[i]);
        mdr.dwMDDataType = BINARY_METADATA;
        mdr.dwMDDataLen = sizeof(PropValue);
        mdr.pbMDData = (unsigned char *)&pv;
        hr = pAdminBase->SetData(root, L"Types", &mdr);
        BAIL_ON_FAILURE(hr);

        // 
        //  update default values
        // 

        mdr.dwMDIdentifier = g_aIISProperties[i].dwPropID;
        mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        mdr.dwMDUserType = IIS_MD_UT_SERVER;
        DataForSyntaxID(&(g_aIISProperties[i]), &mdr);
        hr = pAdminBase->SetData(root, L"Defaults", &mdr);
        BAIL_ON_FAILURE(hr);

    }

    root.close();
    hr = pAdminBase->SaveData();
    BAIL_ON_FAILURE(hr);

    hr = pAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                             L"/Schema/Classes",
                             METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                             DEFAULT_TIMEOUT_VALUE,
                             root);
    BAIL_ON_FAILURE(hr);


    for (i=0; i < g_cIISClasses; i++) {
        hr = pAdminBase->AddKey(root, g_aIISClasses[i].bstrName);
        if (FAILED(hr) && HRESULT_CODE(hr) != ERROR_ALREADY_EXISTS) {
            BAIL_ON_FAILURE(hr);
        }

        //
        // setting Containment and Container property for classes
        //

        mdr.dwMDIdentifier = MD_SCHEMA_CLASS_CONTAINMENT;
        mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        mdr.dwMDUserType = IIS_MD_UT_SERVER;
        mdr.dwMDDataType = STRING_METADATA;
        if (g_aIISClasses[i].bstrContainment) {
            mdr.dwMDDataLen = (wcslen((LPWSTR)g_aIISClasses[i].bstrContainment)+1)*2;
        }
        else {
            mdr.dwMDDataLen = 0;
        }

        mdr.pbMDData = (unsigned char *)g_aIISClasses[i].bstrContainment;
        hr = pAdminBase->SetData(root, g_aIISClasses[i].bstrName, &mdr);
        BAIL_ON_FAILURE(hr);

        mdr.dwMDIdentifier = MD_SCHEMA_CLASS_CONTAINER;
        mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        mdr.dwMDUserType = IIS_MD_UT_SERVER;
        mdr.dwMDDataType = DWORD_METADATA;
        mdr.dwMDDataLen = sizeof(DWORD);
        mdr.pbMDData = (unsigned char *)&(g_aIISClasses[i].fContainer);
        hr = pAdminBase->SetData(root, g_aIISClasses[i].bstrName, &mdr);
        BAIL_ON_FAILURE(hr);


        //
        // setting Optional and Mandatory Properties 
        //

        mdr.dwMDIdentifier = MD_SCHEMA_CLASS_MAND_PROPERTIES;
        mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        mdr.dwMDUserType = IIS_MD_UT_SERVER;
        mdr.dwMDDataType = STRING_METADATA;
        if (g_aIISClasses[i].bstrMandatoryProperties) {
            mdr.dwMDDataLen = (wcslen((LPWSTR)g_aIISClasses[i].bstrMandatoryProperties)+1)*2;
        }
        else {
            mdr.dwMDDataLen = 0;
        }

        mdr.pbMDData = (unsigned char *)g_aIISClasses[i].bstrMandatoryProperties;
        hr = pAdminBase->SetData(root, g_aIISClasses[i].bstrName, &mdr);
        BAIL_ON_FAILURE(hr);

        mdr.dwMDIdentifier = MD_SCHEMA_CLASS_OPT_PROPERTIES;
        mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        mdr.dwMDUserType = IIS_MD_UT_SERVER;
        mdr.dwMDDataType = STRING_METADATA;
        if (g_aIISClasses[i].bstrOptionalProperties) {
            mdr.dwMDDataLen = (wcslen((LPWSTR)g_aIISClasses[i].bstrOptionalProperties)+1)*2;
        }
        else {
            mdr.dwMDDataLen = 0;
        }

        mdr.pbMDData = (unsigned char *)g_aIISClasses[i].bstrOptionalProperties;
        hr = pAdminBase->SetData(root, g_aIISClasses[i].bstrName, &mdr);
        BAIL_ON_FAILURE(hr);

    }
    root.close();
    hr = pAdminBase->SaveData();
    BAIL_ON_FAILURE(hr);

    hr = SetAdminACL(pAdminBase);

error:
    root.close();
    if (pAdminBase)
        pAdminBase->Release();
    return hr;
}

HRESULT SetAdminACL(
    IMSAdminBase * pAdminBase
    )
{
    BOOL b = FALSE;
    DWORD dwLength = 0;

    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR outpSD = NULL;
    DWORD cboutpSD = 0;
    PACL pACLNew = NULL;
    DWORD cbACL = 0;
    PSID pAdminsSID = NULL, pEveryoneSID = NULL;
    BOOL bWellKnownSID = FALSE;
    MetaHandle root(NULL);
    METADATA_RECORD mdr;
    HRESULT hr = NO_ERROR;
    DWORD dwStartMetaId = IIS_MD_ADSI_METAID_BEGIN;

    // Initialize a new security descriptor
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (!pSD) {hr = E_OUTOFMEMORY;}
    BAIL_ON_FAILURE(hr);

    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);

    // Get Local Admins Sid
    GetPrincipalSID (_T("Administrators"), &pAdminsSID, &bWellKnownSID);

    // Get everyone Sid
    GetPrincipalSID (_T("Everyone"), &pEveryoneSID, &bWellKnownSID);

    // Initialize a new ACL, which only contains 2 aaace
    cbACL = sizeof(ACL) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminsSID) - sizeof(DWORD)) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pEveryoneSID) - sizeof(DWORD)) ;
    pACLNew = (PACL) LocalAlloc(LPTR, cbACL);
    if (!pACLNew) {hr = E_OUTOFMEMORY;}
    BAIL_ON_FAILURE(hr);

    InitializeAcl(pACLNew, cbACL, ACL_REVISION);

    AddAccessAllowedAce(
        pACLNew,
        ACL_REVISION,
        FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE,
        pAdminsSID);

    AddAccessAllowedAce(
        pACLNew,
        ACL_REVISION,
        FILE_GENERIC_READ,
        pEveryoneSID);

    // Add the ACL to the security descriptor
    b = SetSecurityDescriptorDacl(pSD, TRUE, pACLNew, FALSE);
    b = SetSecurityDescriptorOwner(pSD, pAdminsSID, TRUE);
    b = SetSecurityDescriptorGroup(pSD, pAdminsSID, TRUE);

    // Security descriptor blob must be self relative
     b = MakeSelfRelativeSD(pSD, outpSD, &cboutpSD);
     outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);
     if (!outpSD) {hr = E_OUTOFMEMORY;}
     BAIL_ON_FAILURE(hr);
     b = MakeSelfRelativeSD( pSD, outpSD, &cboutpSD );

    // below this modify pSD to outpSD

    // Apply the new security descriptor to the file
    dwLength = GetSecurityDescriptorLength(outpSD);

    // Apply the new security descriptor to the file
    hr = pAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                             L"/Schema",
                             METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                             DEFAULT_TIMEOUT_VALUE,
                             root);
    BAIL_ON_FAILURE(hr);

    mdr.dwMDIdentifier = MD_ADMIN_ACL;
    mdr.dwMDAttributes = METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE;
    mdr.dwMDUserType = IIS_MD_UT_SERVER;
    mdr.dwMDDataType = BINARY_METADATA;
    mdr.dwMDDataLen = dwLength;
    mdr.pbMDData = (LPBYTE)outpSD;

    hr = pAdminBase->SetData(root, L"", &mdr);
    BAIL_ON_FAILURE(hr);

    //
    // set the start count for meta id
    //

    mdr.dwMDIdentifier = MD_SCHEMA_METAID;
    mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = IIS_MD_UT_SERVER;
    mdr.dwMDDataType = DWORD_METADATA;
    mdr.dwMDDataLen = sizeof(DWORD);
    mdr.pbMDData = (LPBYTE)&dwStartMetaId;

    hr = pAdminBase->SetData(root, L"", &mdr);
    BAIL_ON_FAILURE(hr);

    root.close();

error :

    //Cleanup:
    // both of Administrators and Everyone are well-known SIDs, use FreeSid() to free them.
    if (outpSD)
        GlobalFree(outpSD);

    if (pAdminsSID)
        FreeSid(pAdminsSID);
    if (pEveryoneSID)
        FreeSid(pEveryoneSID);
    if (pSD)
        LocalFree((HLOCAL) pSD);
    if (pACLNew)
        LocalFree((HLOCAL) pACLNew);

    return (hr);
}


DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));
    if ( wcscmp(Principal,_T("Administrators")) == 0 ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if ( wcscmp(Principal,_T("System")) == 0) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    } else if ( wcscmp(Principal,_T("Interactive")) == 0) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if ( wcscmp(Principal,_T("Everyone")) == 0) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority,
                                    (BYTE)Count,
                                    dwRID[0],
                                    dwRID[1],
                                    dwRID[2],
                                    dwRID[3],
                                    dwRID[4],
                                    dwRID[5],
                                    dwRID[6],
                                    dwRID[7],
                                    Sid) )
        return GetLastError();
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        DWORD        returnValue;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();
        if (returnValue != ERROR_INSUFFICIENT_BUFFER)
            return returnValue;

        *Sid = (PSID) malloc (sidSize);
        refDomainSize = 255;

        if (!LookupAccountName (NULL,
                                Principal,
                                *Sid,
                                &sidSize,
                                refDomain,
                                &refDomainSize,
                                &snu))
        {
            return GetLastError();
        }
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\win95api.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    win95api.c

Abstract:

    Contains some thunking for Unicode KERNEL32 and USER32 APIs

Author:

    Danilo Almeida  (t-danal)  01-Jul-1996

Revision History:

--*/

#include <windows.h>
#include "charset.h"
#include "win95api.h"

UINT
WINAPI
GetProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault
)
{
    LPSTR alpAppName;
    LPSTR alpKeyName;
    UINT err;

    err = AllocAnsi(lpAppName, &alpAppName);
    if (err)
        return nDefault;
    err = AllocAnsi(lpKeyName, &alpKeyName);
    if (err) {
        FreeAnsi(alpAppName);
        return nDefault;
    }
    err = GetProfileIntA((LPCSTR)alpAppName, (LPCSTR)alpKeyName, nDefault);
    FreeAnsi(alpAppName);
    FreeAnsi(alpKeyName);
    return err;
}

HANDLE
WINAPI
CreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
)
{
    LPSTR alpName;
    UINT err;
    HANDLE hSemaphore;

    err = AllocAnsi(lpName, &alpName);
    if (err) {
        SetLastError(err);
        return NULL;
    }
    hSemaphore = CreateSemaphoreA(lpSemaphoreAttributes,
                                  lInitialCount,
                                  lMaximumCount,
                                  alpName);
    FreeAnsi(alpName);
    return hSemaphore;
}

HMODULE
WINAPI
LoadLibraryW(
    LPCWSTR lpLibFileName
)
{
    LPSTR alpLibFileName;
    UINT err;
    HMODULE hLibrary;

    err = AllocAnsi(lpLibFileName, &alpLibFileName);
    if (err) {
        SetLastError(err);
        return NULL;
    }
    hLibrary = LoadLibraryA(alpLibFileName);
    FreeAnsi(alpLibFileName);
    return hLibrary;
}

BOOL
WINAPI
SystemTimeToTzSpecificLocalTime(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
    LPSYSTEMTIME lpUniversalTime,
    LPSYSTEMTIME lpLocalTime
)
{
    FILETIME UniversalFileTime;
    FILETIME LocalFileTime;
    if (!SystemTimeToFileTime(lpUniversalTime, &UniversalFileTime))
        return FALSE;
    if(!FileTimeToLocalFileTime(&UniversalFileTime, &LocalFileTime))
        return FALSE;
    if(!FileTimeToSystemTime(&LocalFileTime, lpLocalTime))
        return FALSE;
    return TRUE;
}

/****************************** Module Header ******************************\
* Module Name: wsprintf.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*  sprintf.c
*
*  Implements Windows friendly versions of sprintf and vsprintf
*
*  History:
*   2-15-89  craigc     Initial
*  11-12-90  MikeHar    Ported from windows 3
\***************************************************************************/

/* Max number of characters. Doesn't include termination character */
#define WSPRINTF_LIMIT 1024

#define out(c) if (cchLimit) {*lpOut++=(c); cchLimit--;} else goto errorout


/***************************************************************************\
* SP_GetFmtValueW
*
*  reads a width or precision value from the format string
*
* History:
*  11-12-90  MikeHar    Ported from windows 3
*  07-27-92  GregoryW   Created Unicode version (copied from SP_GetFmtValue)
\***************************************************************************/

LPCWSTR SP_GetFmtValueW(
    LPCWSTR lpch,
    int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= L'0' && *lpch <= L'9') {
        ii *= 10;
        ii += (int)(*lpch - L'0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/***************************************************************************\
* SP_PutNumberW
*
* Takes an unsigned long integer and places it into a buffer, respecting
* a buffer limit, a radix, and a case select (upper or lower, for hex).
*
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   need to increment lpstr after assignment of mod
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

int SP_PutNumberW(
    LPWSTR lpstr,
    DWORD n,
    int   limit,
    DWORD radix,
    int   uppercase)
{
    DWORD mod;
    int count = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (count < limit) {
        do  {
            mod =  n % radix;
            n /= radix;

            mod += '0';
            if (mod > '9')
            mod += uppercase;
            *lpstr++ = (WCHAR)mod;
            count++;
        } while((count < limit) && n);
    }

    return count;
}

/***************************************************************************\
* SP_ReverseW
*
*  reverses a string in place
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   fixed boundary conditions; removed count
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

void SP_ReverseW(
    LPWSTR lpFirst,
    LPWSTR lpLast)
{
    WCHAR ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}


/***************************************************************************\
* wvsprintfW (API)
*
* wsprintfW() calls this function.
*
* History:
*    11-Feb-1992 GregoryW copied xwvsprintf
*         Temporary hack until we have C runtime support
\***************************************************************************/

int WINAPI wvsprintfW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    va_list arglist)
{
    BOOL fAllocateMem;
    WCHAR prefix, fillch;
    int left, width, prec, size, sign, radix, upper, hprefix;
    int cchLimit = WSPRINTF_LIMIT, cch;
    LPWSTR lpT, lpTWC;
    LPBYTE psz;
    va_list varglist = arglist;
    union {
        long l;
        unsigned long ul;
        char sz[2];
        WCHAR wsz[2];
    } val;

    while (*lpFmt != 0) {
        if (*lpFmt == L'%') {

            /*
             * read the flags.  These can be in any order
             */
            left = 0;
            prefix = 0;
            while (*++lpFmt) {
                if (*lpFmt == L'-')
                    left++;
                else if (*lpFmt == L'#')
                    prefix++;
                else
                    break;
            }

            /*
             * find fill character
             */
            if (*lpFmt == L'0') {
                fillch = L'0';
                lpFmt++;
            } else
                fillch = L' ';

            /*
             * read the width specification
             */
            lpFmt = SP_GetFmtValueW(lpFmt, &cch);
            width = cch;

            /*
             * read the precision
             */
            if (*lpFmt == L'.') {
                lpFmt = SP_GetFmtValueW(++lpFmt, &cch);
                prec = cch;
            } else
                prec = -1;

            /*
             * get the operand size
             * default size: size == 0
             * long number:  size == 1
             * wide chars:   size == 2
             * It may be a good idea to check the value of size when it
             * is tested for non-zero below (IanJa)
             */
            hprefix = 0;
            if ((*lpFmt == L'w') || (*lpFmt == L't')) {
                size = 2;
                lpFmt++;
            } else if (*lpFmt == L'l') {
                size = 1;
                lpFmt++;
            } else {
                size = 0;
                if (*lpFmt == L'h') {
                    lpFmt++;
                    hprefix = 1;
                }
            }

            upper = 0;
            sign = 0;
            radix = 10;

            switch (*lpFmt) {
            case 0:
                goto errorout;

            case L'i':
            case L'd':
                size=1;
                sign++;

                /*** FALL THROUGH to case 'u' ***/

            case L'u':
                /* turn off prefix if decimal */
                prefix = 0;
donumeric:
                /* special cases to act like MSC v5.10 */
                if (left || prec >= 0)
                    fillch = L' ';

                /*
                 * if size == 1, "%lu" was specified (good);
                 * if size == 2, "%wu" was specified (bad)
                 */
                if (size) {
                    val.l = va_arg(varglist, LONG);
                } else if (sign) {
                    val.l = va_arg(varglist, SHORT);
                } else {
                    val.ul = va_arg(varglist, unsigned);
                }

                if (sign && val.l < 0L)
                    val.l = -val.l;
                else
                    sign = 0;

                lpT = lpOut;

                /*
                 * blast the number backwards into the user buffer
                 */
                cch = SP_PutNumberW(lpOut, val.l, cchLimit, radix, upper);
                if (!(cchLimit -= cch))
                    goto errorout;

                lpOut += cch;
                width -= cch;
                prec -= cch;
                if (prec > 0)
                    width -= prec;

                /*
                 * fill to the field precision
                 */
                while (prec-- > 0)
                    out(L'0');

                if (width > 0 && !left) {
                    /*
                     * if we're filling with spaces, put sign first
                     */
                    if (fillch != L'0') {
                        if (sign) {
                            sign = 0;
                            out(L'-');
                            width--;
                        }

                        if (prefix) {
                            out(prefix);
                            out(L'0');
                            prefix = 0;
                        }
                    }

                    if (sign)
                        width--;

                    /*
                     * fill to the field width
                     */
                    while (width-- > 0)
                        out(fillch);

                    /*
                     * still have a sign?
                     */
                    if (sign)
                        out(L'-');

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * now reverse the string in place
                     */
                    SP_ReverseW(lpT, lpOut - 1);
                } else {
                    /*
                     * add the sign character
                     */
                    if (sign) {
                        out(L'-');
                        width--;
                    }

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * reverse the string in place
                     */
                    SP_ReverseW(lpT, lpOut - 1);

                    /*
                     * pad to the right of the string in case left aligned
                     */
                    while (width-- > 0)
                        out(fillch);
                }
                break;

            case L'X':
                upper++;

                /*** FALL THROUGH to case 'x' ***/

            case L'x':
                radix = 16;
                if (prefix)
                    if (upper)
                        prefix = L'X';
                    else
                        prefix = L'x';
                goto donumeric;

            case L'c':
                if (!size && !hprefix) {
                    size = 1;           // force WCHAR
                }

                /*** FALL THROUGH to case 'C' ***/

            case L'C':
                /*
                 * if size == 0, "%C" or "%hc" was specified (CHAR);
                 * if size == 1, "%c" or "%lc" was specified (WCHAR);
                 * if size == 2, "%wc" or "%tc" was specified (WCHAR)
                 */
                cch = 1; /* One character must be copied to the output buffer */
                if (size) {
                    val.wsz[0] = va_arg(varglist, WCHAR);
                    val.wsz[1] = 0;
                    lpT = val.wsz;
                    goto putwstring;
                } else {
                    val.sz[0] = va_arg(varglist, CHAR);
                    val.sz[1] = 0;
                    psz = val.sz;
                    goto putstring;
                }

            case L's':
                if (!size && !hprefix) {
                    size = 1;           // force LPWSTR
                }

                /*** FALL THROUGH to case 'S' ***/

            case L'S':
                /*
                 * if size == 0, "%S" or "%hs" was specified (LPSTR)
                 * if size == 1, "%s" or "%ls" was specified (LPWSTR);
                 * if size == 2, "%ws" or "%ts" was specified (LPWSTR)
                 */
                if (size) {
                    lpT = va_arg(varglist, LPWSTR);
                    cch = wcslen(lpT);
putwstring:
                    fAllocateMem = FALSE;
                } else {
                    psz = va_arg(varglist, LPBYTE);
                    cch = strlen(psz);
putstring:
                    cch = AllocUnicode2(psz, cch, &lpTWC);
                    fAllocateMem = (BOOL) cch;
                    lpT = lpTWC;
                }

                if (prec >= 0 && cch > prec)
                    cch = prec;
                width -= cch;

                if (fAllocateMem) {
                    if (cch + (width < 0 ? 0 : width) >= cchLimit) {
                        FreeUnicode(lpTWC);
                        goto errorout;
                    }
                }

                if (left) {
                    while (cch--)
                        out(*lpT++);
                    while (width-- > 0)
                        out(fillch);
                } else {
                    while (width-- > 0)
                        out(fillch);
                    while (cch--)
                        out(*lpT++);
                }

                if (fAllocateMem) {
                     FreeUnicode(lpTWC);
                }

                break;

            default:
normalch:
                out((WCHAR)*lpFmt);
                break;
            }  /* END OF SWITCH(*lpFmt) */
        }  /* END OF IF(%) */ else
            goto normalch;  /* character not a '%', just do it */

        /*
         * advance to next format string character
         */
        lpFmt++;
    }  /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut = 0;

    return WSPRINTF_LIMIT - cchLimit;
}

int WINAPIV wsprintfW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvsprintfW(lpOut, lpFmt, arglist);
    va_end(arglist);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\tests\qstest\makefile.inc ===
#
# Supplemental rules for generating Type library.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\aspdebug.cpp ===
//
//
//
#include "stdafx.h"
#include "AspDebug.h"

LRESULT
CAspDebugPage::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   DoDataExchange();

   m_ErrorIdx = m_pData->m_SendAspError ? 0 : 1;

   m_DefaultErrCtrl.EnableWindow(!m_pData->m_SendAspError);
   DoDataExchange(FALSE);

   return FALSE;
}

void
CAspDebugPage::OnChangeError(UINT nCode, UINT nID, HWND hWnd)
{
   DoDataExchange(TRUE);
   m_pData->m_SendAspError = (m_ErrorIdx == 0);
   m_DefaultErrCtrl.EnableWindow(!m_pData->m_SendAspError);
   SET_MODIFIED(TRUE);
}

BOOL
CAspDebugPage::OnKillActive()
{
   DoDataExchange(TRUE);
   return SUCCEEDED(m_pData->Save());
}

void
CAspDebugPage::OnHelp()
{
    WinHelp(m_pData->m_HelpPath, HELP_CONTEXT, CAspDebugPage::IDD + WINHELP_NUMBER_BASE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\setup\iis51\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\tests\qstest\main.cpp ===
/*===================================================================
Microsoft

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: qstest

File: main.cpp

Owner: brentmid

Note:
===================================================================*/

#include <stdio.h>
#include <objbase.h>
#include <atlbase.h>
#include <iads.h>
#include <adshlp.h>

DWORD QuerySMTPState() {

    HRESULT			hr = NOERROR;

    CComPtr<IADsServiceOperations>	pADsIisService;
    DWORD				dwState;

    // Get virtual server instance on metabase
    hr = ADsGetObject (L"IIS://localhost/smtpsvc/1", IID_IADsServiceOperations, (void**)&pADsIisService );
    if (FAILED(hr)) goto Exit;

    printf("Successful ADsGetObject...\n");

    // Get state
    hr = pADsIisService->get_Status ( (long*)&dwState );
 
    if (FAILED(hr)) goto Exit;

    printf("Successful get_Status...\n");

    Exit:
    
    return dwState;
}

int _cdecl main (int argc, char **argv)
{
	char s;
    DWORD status;

    CoInitialize(NULL);

	printf("Beginning qstest...\n");

    printf("Querying SMTP service state - 1st time...\n");

    status = QuerySMTPState();
    printf("Status = %x\n", status);

    printf("Stop/restart iisadmin, then hit enter...");
    scanf("%c",&s);
    
    printf("Querying SMTP service state - 2nd time...\n");

    status = QuerySMTPState();
    printf("Status = %x\n", status);

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\adsi\setup\iis60\makefile.inc ===
#
#   makefile.inc
#       Makefile for generating files from the .idl file
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\aspdebug.h ===
//
//
//
#ifndef _ASP_DEBUG_H
#define _ASP_DEBUG_H

#include "resource.h"
#include "ExchControls.h"
#include "PropSheet.h"

class CAspDebugPage : 
   public WTL::CPropertyPageImpl<CAspDebugPage>,
   public WTL::CWinDataExchange<CAspDebugPage>
{
   typedef WTL::CPropertyPageImpl<CAspDebugPage> baseClass;

public:
   CAspDebugPage(CAppData * pData)
   {
      m_pData = pData;
   }
   ~CAspDebugPage()
   {
   }

   enum {IDD = IDD_ASPDEBUG};

BEGIN_MSG_MAP_EX(CAspDebugPage)
   MSG_WM_INITDIALOG(OnInitDialog)
   COMMAND_HANDLER_EX(IDC_SEND_DEF_ERROR, BN_CLICKED, OnChangeError)
   COMMAND_HANDLER_EX(IDC_SEND_DETAILED_ERROR, BN_CLICKED, OnChangeError)
   COMMAND_HANDLER_EX(IDC_SERVER_DEBUG, BN_CLICKED, OnChangeControl)
   COMMAND_HANDLER_EX(IDC_CLIENT_DEBUG, BN_CLICKED, OnChangeControl)
   COMMAND_HANDLER_EX(IDC_DEFAULT_ERROR, EN_CHANGE, OnChangeControl)
   CHAIN_MSG_MAP(baseClass)
END_MSG_MAP()

BEGIN_DDX_MAP(CAspDebugPage)
   DDX_CHECK(IDC_SERVER_DEBUG, m_pData->m_ServerDebug)
   DDX_CHECK(IDC_CLIENT_DEBUG, m_pData->m_ClientDebug)
   DDX_RADIO(IDC_SEND_DETAILED_ERROR, m_ErrorIdx)
   DDX_TEXT(IDC_DEFAULT_ERROR, m_pData->m_DefaultError)
   DDX_CONTROL(IDC_DEFAULT_ERROR, m_DefaultErrCtrl)
END_DDX_MAP()

   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnChangeError(UINT nCode, UINT nID, HWND hWnd);
   void OnHelp();
   void OnChangeControl(UINT nCode, UINT nID, HWND hWnd)
   {
      SET_MODIFIED(TRUE);
   }
   BOOL OnKillActive();

protected:
   CAppData * m_pData;
   int m_ErrorIdx;
   CEditExch m_DefaultErrCtrl;
};

#endif //_ASP_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\appconfig.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Jul 27 17:55:53 2000
 */
/* Compiler settings for D:\ntw\inetsrv\iis\ui\admin\AppConfig\AppConfig.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __AppConfig_h__
#define __AppConfig_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IIISAppConfig_FWD_DEFINED__
#define __IIISAppConfig_FWD_DEFINED__
typedef interface IIISAppConfig IIISAppConfig;
#endif 	/* __IIISAppConfig_FWD_DEFINED__ */


#ifndef __IISAppConfig_FWD_DEFINED__
#define __IISAppConfig_FWD_DEFINED__

#ifdef __cplusplus
typedef class IISAppConfig IISAppConfig;
#else
typedef struct IISAppConfig IISAppConfig;
#endif /* __cplusplus */

#endif 	/* __IISAppConfig_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IIISAppConfig_INTERFACE_DEFINED__
#define __IIISAppConfig_INTERFACE_DEFINED__

/* interface IIISAppConfig */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IIISAppConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D4E9B327-D9B4-4942-871E-1AF2FFCF6C0C")
    IIISAppConfig : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Run( void) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ComputerName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UserName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UserPassword( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MetaPath( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_HelpPath( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ServiceVersion( 
            /* [in] */ DWORD newVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ServiceCompatMode( 
            /* [in] */ BOOL newVal) = 0;
    };
    
#else 	/* C style interface */

    typedef struct IIISAppConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IIISAppConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IIISAppConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IIISAppConfig __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Run )( 
            IIISAppConfig __RPC_FAR * This);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ComputerName )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UserName )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UserPassword )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MetaPath )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HelpPath )( 
            IIISAppConfig __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IIISAppConfigVtbl;

    interface IIISAppConfig
    {
        CONST_VTBL struct IIISAppConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIISAppConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIISAppConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIISAppConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIISAppConfig_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IIISAppConfig_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IIISAppConfig_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IIISAppConfig_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IIISAppConfig_Run(This)	\
    (This)->lpVtbl -> Run(This)

#define IIISAppConfig_put_ComputerName(This,newVal)	\
    (This)->lpVtbl -> put_ComputerName(This,newVal)

#define IIISAppConfig_put_UserName(This,newVal)	\
    (This)->lpVtbl -> put_UserName(This,newVal)

#define IIISAppConfig_put_UserPassword(This,newVal)	\
    (This)->lpVtbl -> put_UserPassword(This,newVal)

#define IIISAppConfig_put_MetaPath(This,newVal)	\
    (This)->lpVtbl -> put_MetaPath(This,newVal)

#define IIISAppConfig_put_HelpPath(This,newVal)	\
    (This)->lpVtbl -> put_HelpPath(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IIISAppConfig_Run_Proxy( 
    IIISAppConfig __RPC_FAR * This);


void __RPC_STUB IIISAppConfig_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIISAppConfig_put_ComputerName_Proxy( 
    IIISAppConfig __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IIISAppConfig_put_ComputerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIISAppConfig_put_UserName_Proxy( 
    IIISAppConfig __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IIISAppConfig_put_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIISAppConfig_put_UserPassword_Proxy( 
    IIISAppConfig __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IIISAppConfig_put_UserPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIISAppConfig_put_MetaPath_Proxy( 
    IIISAppConfig __RPC_FAR * This,
    /* [in] */ BSTR newVal);

void __RPC_STUB IIISAppConfig_put_MetaPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IIISAppConfig_put_HelpPath_Proxy( 
    IIISAppConfig __RPC_FAR * This,
    /* [in] */ BSTR newVal);

void __RPC_STUB IIISAppConfig_put_HelpPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


#endif 	/* __IIISAppConfig_INTERFACE_DEFINED__ */



#ifndef __APPCONFIGLib_LIBRARY_DEFINED__
#define __APPCONFIGLib_LIBRARY_DEFINED__

/* library APPCONFIGLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_APPCONFIGLib;

EXTERN_C const CLSID CLSID_IISAppConfig;

#ifdef __cplusplus

class DECLSPEC_UUID("5443AED3-A8AF-4351-B7E1-929EABCAF250")
IISAppConfig;
#endif
#endif /* __APPCONFIGLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\appconfig.cpp ===
// AppConfig.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for AppConfig.idl by adding the following 
//      files to the Outputs.
//          AppConfig_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f AppConfigps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "AppConfig.h"
#include "dlldatax.h"

#include "AppConf_i.c"
#include "IISAppConfig.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_IISAppConfig, CIISAppConfig)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_APPCONFIGLib);
        DisableThreadLibraryCalls(hInstance);
        INITCOMMONCONTROLSEX iccx;
        iccx.dwSize = sizeof(iccx);
        iccx.dwICC = ICC_DATE_CLASSES | ICC_UPDOWN_CLASS;
        ::InitCommonControlsEx(&iccx);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\exchcontrols.h ===
//
//
//
#ifndef _EXCH_CONTROLS_H
#define _EXCH_CONTROLS_H

class CTrackBarCtrlExch : public CWindowImpl<CTrackBarCtrlExch, CTrackBarCtrl>
{
public:
   BEGIN_MSG_MAP_EX(CTrackBarCtrlExch)
   END_MSG_MAP()
};

class CUpDownCtrlExch : public CWindowImpl<CUpDownCtrlExch, CUpDownCtrl>
{
public:
   BEGIN_MSG_MAP_EX(CUpDownCtrlExch)
   END_MSG_MAP()
};

class CButtonExch : public CWindowImpl<CButtonExch, CButton>
{
public:
   BEGIN_MSG_MAP_EX(CButtonExch)
   END_MSG_MAP()
};

class CListViewExch : public CWindowImpl<CListViewExch, CListViewCtrl>
{
public:
   BEGIN_MSG_MAP_EX(CListViewExch)
   END_MSG_MAP()
};

class CListBoxExch : public CWindowImpl<CListBoxExch, CListBox>
{
public:
   BEGIN_MSG_MAP_EX(CListBoxExch)
   END_MSG_MAP()
};

class CEditExch : public CWindowImpl<CEditExch, CEdit>
{
public:
   BEGIN_MSG_MAP_EX(CEditExch)
   END_MSG_MAP()
};

class CTimePickerExch : public CWindowImpl<CTimePickerExch, CDateTimePickerCtrl>
{
public:
   BEGIN_MSG_MAP_EX(CTimePickerExch)
   END_MSG_MAP()
};

#endif //_EXCH_CONTROLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__C969038E_59A1_48EA_AB6D_7EFFCFCED92E__INCLUDED_)
#define AFX_DLLDATAX_H__C969038E_59A1_48EA_AB6D_7EFFCFCED92E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__C969038E_59A1_48EA_AB6D_7EFFCFCED92E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\aspmain.cpp ===
//
//
//
#include "stdafx.h"
#include "aspmain.h"

LRESULT
CAspMainPage::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   DoDataExchange();

   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};
   m_TimeoutSpin.SetRange32(SESSION_TIMEOUT_MIN, SESSION_TIMEOUT_MAX);
   m_TimeoutSpin.SetPos32(m_pData->m_SessionTimeout);
   m_TimeoutSpin.SetAccel(3, toAcc);

   m_AspTimeoutSpin.SetRange32(SCRIPT_TIMEOUT_MIN, SCRIPT_TIMEOUT_MAX);
   m_AspTimeoutSpin.SetPos32(m_pData->m_ScriptTimeout);
   m_AspTimeoutSpin.SetAccel(3, toAcc);
   
   BOOL bEnable = SendDlgItemMessage(IDC_ENABLE_SESSION, BM_GETCHECK, 0, 0);
   ::EnableWindow(GetDlgItem(IDC_SESSION_TIMEOUT), bEnable);
   ::EnableWindow(GetDlgItem(IDC_TIMEOUT_SPIN), bEnable);

   return FALSE;
}

void
CAspMainPage::OnEnableSession(UINT nCode, UINT nID, HWND hWnd)
{
   BOOL bEnable = SendDlgItemMessage(IDC_ENABLE_SESSION, BM_GETCHECK, 0, 0);
   ::EnableWindow(GetDlgItem(IDC_SESSION_TIMEOUT), bEnable);
   ::EnableWindow(GetDlgItem(IDC_TIMEOUT_SPIN), bEnable);
   SET_MODIFIED(TRUE);
}

BOOL
CAspMainPage::OnKillActive()
{
	BOOL res = FALSE;
	if (DoDataExchange(TRUE))
	{
		res = SUCCEEDED(m_pData->Save());
	}
	return res;
}

void 
CAspMainPage::OnDataValidateError(UINT id, BOOL bSave,_XData& data)
{
	if (bSave)
	{
		CString str, fmt, caption;
		caption.LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE);
 
		switch (data.nDataType)
		{
		case ddxDataNull:
			break;
		case ddxDataText:
 			break;
		case ddxDataInt:
			fmt.LoadString(_Module.GetResourceInstance(), IDS_ERR_INT_RANGE);
			str.Format(fmt, data.intData.nMin, data.intData.nMax);
			break;
		}
		if (!str.IsEmpty())
		{
			MessageBox(str, caption, MB_OK | MB_ICONEXCLAMATION);
			::SetFocus(GetDlgItem(id));
		}
	}
}

void 
CAspMainPage::OnDataExchangeError(UINT nCtrlID, BOOL bSave)
{
	if (bSave)
	{
		CString str, caption;
		caption.LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE);
        // This is hack to make testers happy. Here we creating dependence on
        // dialog layout and range values
        if (nCtrlID == IDC_SESSION_TIMEOUT || nCtrlID == IDC_SCRIPT_TIMEOUT)
        {
            CString fmt;
		    fmt.LoadString(_Module.GetResourceInstance(), IDS_ERR_INT_RANGE);
			str.Format(fmt, SESSION_TIMEOUT_MIN, SESSION_TIMEOUT_MAX);
        }
        else
        {
		    str.LoadString(_Module.GetResourceInstance(), IDS_ERR_INVALID_DATA);
        }
		MessageBox(str, caption, MB_OK | MB_ICONEXCLAMATION);
		::SetFocus(GetDlgItem(nCtrlID));
	}
}


void
CAspMainPage::OnHelp()
{
    WinHelp(m_pData->m_HelpPath, HELP_CONTEXT, CAspMainPage::IDD + WINHELP_NUMBER_BASE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\iisappconfig.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        IISAppConfig.cpp

   Abstract:
        Implementation of CIISAppConfig

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

#include "stdafx.h"
#include "AppConfig.h"
#include "IISAppConfig.h"
#include "PropSheet.h"
#include "MappingPage.h"
#include "CacheOpt.h"
#include "ProcessOpt.h"
#include "AspMain.h"
#include "AspDebug.h"

/////////////////////////////////////////////////////////////////////////////
// CIISAppConfig

STDMETHODIMP CIISAppConfig::Run()
{
   CAppPropSheet ps;
   CAppData data;
   HRESULT hr;

   data.m_ServerName = (LPCTSTR)m_ComputerName;
   data.m_UserName = (LPCTSTR)m_UserName;
   data.m_UserPassword = (LPCTSTR)m_UserPassword;
   data.m_MetaPath = (LPCTSTR)m_MetaPath;
   data.m_HelpPath = (LPCTSTR)m_HelpPath;
   data.m_dwVersion = m_Version;
   data.m_fCompatMode = m_CompatMode;
   data.m_pSheet = &ps;

   if (SUCCEEDED(hr = data.Load()))
   {
      CAppMappingPage map_page(&data);
      CAspMainPage asp_main(&data);
      CAspDebugPage asp_debug(&data);
      CCacheOptPage cache_page(&data);
      CCacheOptPage_iis5 cache_page_iis5(&data);
      CProcessOptPage proc_page(&data);

      ps.m_psh.dwFlags |= PSH_HASHELP;
      ps.m_psh.dwFlags |= PSH_NOCONTEXTHELP;
      map_page.m_psp.dwFlags |= PSP_HASHELP;
      asp_main.m_psp.dwFlags |= PSP_HASHELP;
      asp_debug.m_psp.dwFlags |= PSP_HASHELP;
      cache_page.m_psp.dwFlags |= PSP_HASHELP;
      cache_page_iis5.m_psp.dwFlags |= PSP_HASHELP;
      proc_page.m_psp.dwFlags |= PSP_HASHELP;

      ps.AddPage(map_page);
      ps.AddPage(asp_main);
      ps.AddPage(asp_debug);
      if (  (LOWORD(m_Version) >= 6 && m_CompatMode)
         || LOWORD(m_Version) < 6
         )
      {
          if (  CMetabasePath::IsMasterInstance(data.m_MetaPath) 
             || data.m_AppIsolated == eAppRunOutProcIsolated
             )
          {
			  if (LOWORD(m_Version) == 5 && HIWORD(m_Version) == 0)
			  {
                  ps.AddPage(cache_page_iis5);
			  }
			  else
			  {
		          ps.AddPage(cache_page);
			  }
          }
      }
      if (  (LOWORD(m_Version) >= 6 && m_CompatMode)
         || LOWORD(m_Version) < 6
         )
      {
          if (  CMetabasePath::IsMasterInstance(data.m_MetaPath) 
             || data.m_AppIsolated == eAppRunOutProcIsolated
             )
          {
             ps.AddPage(proc_page);
          }
      }

      if (IDOK == ps.DoModal())
      {
         hr = data.Save();
      }
   }
	return hr;
}

STDMETHODIMP CIISAppConfig::put_ComputerName(BSTR newVal)
{
	m_ComputerName = newVal;
	return S_OK;
}

STDMETHODIMP CIISAppConfig::put_UserName(BSTR newVal)
{
   m_UserName = newVal;
	return S_OK;
}

STDMETHODIMP CIISAppConfig::put_UserPassword(BSTR newVal)
{
   m_UserPassword = newVal;
	return S_OK;
}

STDMETHODIMP CIISAppConfig::put_MetaPath(BSTR newVal)
{
   m_MetaPath = newVal;
	return S_OK;
}

STDMETHODIMP CIISAppConfig::put_HelpPath(BSTR newVal)
{
	m_HelpPath = newVal;
	return S_OK;
}

STDMETHODIMP CIISAppConfig::put_ServiceVersion(DWORD newVal)
{
    m_Version = newVal;
    return S_OK;
}

STDMETHODIMP CIISAppConfig::put_ServiceCompatMode(BOOL newVal)
{
    m_CompatMode = newVal;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\cacheopt.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        cacheopt.h

   Abstract:
        ASP Cache Options page

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef _CACHE_OPT_H
#define _CACHE_OPT_H

#include "resource.h"
#include "ExchControls.h"
#include "PropSheet.h"


#define SCRIPT_ENG_MIN		0
#define SCRIPT_ENG_MAX		2000000000
#define CACHE_SIZE_MIN		0
#define CACHE_SIZE_MAX		CACHE_UNLIM_MAX

class CCacheOptPage : 
   public WTL::CPropertyPageImpl<CCacheOptPage>,
   public WTL::CWinDataExchange<CCacheOptPage>
{
   typedef WTL::CPropertyPageImpl<CCacheOptPage> baseClass;

public:
   CCacheOptPage(CAppData * pData)
   {
      m_pData = pData;
   }
   ~CCacheOptPage()
   {
   }

   enum {IDD = IDD_CACHE_OPT};

BEGIN_MSG_MAP_EX(CCacheOptPage)
   MSG_WM_INITDIALOG(OnInitDialog)
   COMMAND_HANDLER_EX(IDC_NO_CACHE, BN_CLICKED, OnCacheSwitch)
   COMMAND_HANDLER_EX(IDC_UNLIMITED_CACHE, BN_CLICKED, OnCacheSwitch)
   COMMAND_HANDLER_EX(IDC_LIMITED_CACHE, BN_CLICKED, OnCacheSwitch)
   COMMAND_HANDLER_EX(IDC_CACHE_SIZE_EDIT, EN_CHANGE, OnChangeCacheSize)
   COMMAND_HANDLER_EX(IDC_INMEM_LIM_EDIT, EN_CHANGE, OnChangeInmemCacheSize)
   COMMAND_HANDLER_EX(IDC_CACHE_PATH, EN_CHANGE, OnChangePath)
   COMMAND_HANDLER_EX(IDC_ENGINES, EN_CHANGE, OnChangeData)
   COMMAND_HANDLER_EX(IDC_INMEM_UNLIM_EDIT, EN_CHANGE, OnChangeData)
   MSG_WM_HSCROLL(OnTrackBarScroll)
   CHAIN_MSG_MAP(baseClass)
END_MSG_MAP()

BEGIN_DDX_MAP(CCacheOptPage)
   DDX_CHECK(IDC_NO_CACHE, m_pData->m_NoCache)
   DDX_CHECK(IDC_UNLIMITED_CACHE, m_pData->m_UnlimCache)
   DDX_CHECK(IDC_LIMITED_CACHE, m_pData->m_LimCache)
   DDX_CONTROL(IDC_NO_CACHE, m_NoCacheBtn)
   DDX_CONTROL(IDC_UNLIMITED_CACHE, m_UnlimCacheBtn)
   DDX_CONTROL(IDC_LIMITED_CACHE, m_LimCacheBtn)
   DDX_CONTROL(IDC_CACHE_DIST, m_cache_dist)
   DDX_CONTROL(IDC_INMEM_UNLIM_SPIN, m_inmem_unlim)
   DDX_CONTROL(IDC_CACHE_SIZE_SPIN, m_cache_size)
   DDX_CONTROL(IDC_INMEM_LIM_SPIN, m_inmem_lim)
   DDX_CONTROL(IDC_ENG_CACHED_SPIN, m_eng_cache)
   if (m_pData->m_LimCache)
   {
      DDX_INT_RANGE(IDC_CACHE_SIZE_EDIT, m_pData->m_TotalCacheSize, CACHE_SIZE_MIN, CACHE_SIZE_MAX)
      DDX_INT_RANGE(IDC_INMEM_LIM_EDIT, m_pData->m_LimCacheInMemorySize, 0, m_pData->m_TotalCacheSize)
   }
   if (m_pData->m_UnlimCache)
   {
	  DDX_INT_RANGE(IDC_INMEM_UNLIM_EDIT, m_pData->m_UnlimCacheInMemorySize, CACHE_SIZE_MIN, CACHE_SIZE_MAX)
   }
   DDX_INT_RANGE(IDC_ENGINES, m_pData->m_ScriptEngCacheMax, SCRIPT_ENG_MIN, SCRIPT_ENG_MAX)
END_DDX_MAP()

public:
   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnCacheSwitch(UINT nCode, UINT nID, HWND hWnd);
   void OnTrackBarScroll(UINT nSBCode, UINT nPos, HWND hwnd);
   void OnChangeCacheSize(UINT nCode, UINT nID, HWND hWnd);
   void OnChangeInmemCacheSize(UINT nCode, UINT nID, HWND hWnd);
   void OnChangeData(UINT nCode, UINT nID, HWND hWnd)
   {
      SET_MODIFIED(TRUE);
   }
   void OnChangePath(UINT nCode, UINT nID, HWND hWnd);
   BOOL OnKillActive();
   BOOL OnApply()
   {
      APPLY_DATA();
      return TRUE;
   }
   void OnDataValidateError(UINT nCtrlID, BOOL bSave, _XData& data);
   void OnDataExchangeError(UINT nCtrlID, BOOL bSave);
   void OnHelp();

   void AdjustTracker();

protected:
   CAppData * m_pData;
   CButtonExch m_NoCacheBtn, m_UnlimCacheBtn, m_LimCacheBtn;
   CTrackBarCtrlExch m_cache_dist;
   CUpDownCtrlExch m_inmem_unlim;
   CUpDownCtrlExch m_inmem_lim;
   CUpDownCtrlExch m_cache_size;
   CUpDownCtrlExch m_eng_cache;
   CFileChooser m_FileChooser;
   BOOL m_bInitDone;
};


class CCacheOptPage_iis5 : 
   public WTL::CPropertyPageImpl<CCacheOptPage_iis5>,
   public WTL::CWinDataExchange<CCacheOptPage_iis5>
{
   typedef WTL::CPropertyPageImpl<CCacheOptPage_iis5> baseClass;

public:
   CCacheOptPage_iis5(CAppData * pData)
   {
      m_pData = pData;
   }
   ~CCacheOptPage_iis5()
   {
   }

   enum {IDD = IDD_CACHE_OPT_IIS5};

BEGIN_MSG_MAP_EX(CCacheOptPage_iis5)
   MSG_WM_INITDIALOG(OnInitDialog)
   COMMAND_HANDLER_EX(IDC_NO_CACHE, BN_CLICKED, OnCacheSwitch)
   COMMAND_HANDLER_EX(IDC_UNLIMITED_CACHE, BN_CLICKED, OnCacheSwitch)
   COMMAND_HANDLER_EX(IDC_LIMITED_CACHE, BN_CLICKED, OnCacheSwitch)
   COMMAND_HANDLER_EX(IDC_ENGINES, EN_CHANGE, OnChangeData)
   COMMAND_HANDLER_EX(IDC_CACHE_SIZE_EDIT, EN_CHANGE, OnChangeData)
   CHAIN_MSG_MAP(baseClass)
END_MSG_MAP()

BEGIN_DDX_MAP(CCacheOptPage)
   DDX_CHECK(IDC_NO_CACHE, m_pData->m_NoCache)
   DDX_CHECK(IDC_UNLIMITED_CACHE, m_pData->m_UnlimCache)
   DDX_CHECK(IDC_LIMITED_CACHE, m_pData->m_LimCache)
   DDX_INT_RANGE(IDC_CACHE_SIZE_EDIT, m_pData->m_LimCacheInMemorySize, CACHE_SIZE_MIN, CACHE_SIZE_MAX)
   DDX_CONTROL(IDC_NO_CACHE, m_NoCacheBtn)
   DDX_CONTROL(IDC_UNLIMITED_CACHE, m_UnlimCacheBtn)
   DDX_CONTROL(IDC_LIMITED_CACHE, m_LimCacheBtn)
   DDX_CONTROL(IDC_CACHE_SIZE_SPIN, m_inmem_lim)
   DDX_CONTROL(IDC_ENG_CACHED_SPIN, m_eng_cache)
   DDX_INT_RANGE(IDC_ENGINES, m_pData->m_ScriptEngCacheMax, SCRIPT_ENG_MIN, SCRIPT_ENG_MAX)
END_DDX_MAP()

public:
   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnCacheSwitch(UINT nCode, UINT nID, HWND hWnd);
   void OnChangeData(UINT nCode, UINT nID, HWND hWnd)
   {
      SET_MODIFIED(TRUE);
   }
   BOOL OnKillActive();
   BOOL OnApply()
   {
      APPLY_DATA();
      return TRUE;
   }
   void OnDataValidateError(UINT nCtrlID, BOOL bSave, _XData& data);
   void OnDataExchangeError(UINT nCtrlID, BOOL bSave);
   void OnHelp();

protected:
   CAppData * m_pData;
   CButtonExch m_NoCacheBtn, m_UnlimCacheBtn, m_LimCacheBtn;
   CUpDownCtrlExch m_inmem_lim;
   CUpDownCtrlExch m_eng_cache;
   BOOL m_bInitDone;
};

#endif   //_CACHE_OPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\aspmain.h ===
//
//
//
#ifndef _ASP_MAIN_H
#define _ASP_MAIN_H

#include "resource.h"
#include "ExchControls.h"
#include "PropSheet.h"

#define SESSION_TIMEOUT_MIN		1
#define SESSION_TIMEOUT_MAX		2000000000
#define SCRIPT_TIMEOUT_MIN		1
#define SCRIPT_TIMEOUT_MAX		2000000000

class CAspMainPage : 
   public WTL::CPropertyPageImpl<CAspMainPage>,
   public WTL::CWinDataExchange<CAspMainPage>
{
   typedef CPropertyPageImpl<CAspMainPage> baseClass;

public:
   CAspMainPage(CAppData * pData)
   {
      m_pData = pData;
   }
   ~CAspMainPage()
   {
   }

   enum {IDD = IDD_ASPMAIN};

BEGIN_MSG_MAP_EX(CAspMainPage)
   MSG_WM_INITDIALOG(OnInitDialog)
   COMMAND_HANDLER_EX(IDC_ENABLE_SESSION, BN_CLICKED, OnEnableSession)
   COMMAND_HANDLER_EX(IDC_ENABLE_BUFFERING, BN_CLICKED, OnChangeControl)
   COMMAND_HANDLER_EX(IDC_ENABLE_PARENTS, BN_CLICKED, OnChangeControl)
   COMMAND_HANDLER_EX(IDC_SESSION_TIMEOUT, EN_CHANGE, OnChangeControl)
   COMMAND_HANDLER_EX(IDC_SCRIPT_TIMEOUT, EN_CHANGE, OnChangeControl)
   COMMAND_HANDLER_EX(IDC_LANGUAGES, EN_CHANGE, OnChangeControl)
   CHAIN_MSG_MAP(baseClass)
END_MSG_MAP()

BEGIN_DDX_MAP(CAspMainPage)
   DDX_CHECK(IDC_ENABLE_SESSION, m_pData->m_EnableSession)
   DDX_CHECK(IDC_ENABLE_BUFFERING, m_pData->m_EnableBuffering)
   DDX_CHECK(IDC_ENABLE_PARENTS, m_pData->m_EnableParents)
   if (m_pData->m_EnableSession)
   {
	   DDX_INT_RANGE(IDC_SESSION_TIMEOUT, 
		   m_pData->m_SessionTimeout, SESSION_TIMEOUT_MIN, SESSION_TIMEOUT_MAX)
   }
   DDX_TEXT(IDC_LANGUAGES, m_pData->m_Languages)
   DDX_INT_RANGE(IDC_SCRIPT_TIMEOUT, m_pData->m_ScriptTimeout, SCRIPT_TIMEOUT_MIN, SCRIPT_TIMEOUT_MAX)

   DDX_CONTROL(IDC_LANGUAGES, m_LanguagesCtrl)
   DDX_CONTROL(IDC_TIMEOUT_SPIN, m_TimeoutSpin)
   DDX_CONTROL(IDC_ASPTIMEOUT_SPIN, m_AspTimeoutSpin)
END_DDX_MAP()

   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnEnableSession(UINT nCode, UINT nID, HWND hWnd);
   void OnChangeControl(UINT nCode, UINT nID, HWND hWnd)
   {
	  if (nCode == EN_CHANGE)
	  {
		 TCHAR buf[MAX_PATH];
	     UINT len = GetDlgItemText(nID, buf, MAX_PATH);
		 BOOL bEnable = (len != 0);
         // Disable OK and Apply buttons
		 ::EnableWindow(::GetDlgItem(GetParent(), IDOK), bEnable);
		 if (!bEnable)
		 {
			 SET_MODIFIED(FALSE);
			 return;
		 }
	  }
	  SET_MODIFIED(TRUE);
   }
   BOOL OnKillActive();
   void OnDataValidateError(UINT nCtrlID, BOOL bSave, _XData& data);
   void OnDataExchangeError(UINT nCtrlID, BOOL bSave);
   void OnHelp();

protected:
   CAppData * m_pData;
   CEditExch m_LanguagesCtrl;
   CUpDownCtrlExch m_TimeoutSpin;
   CUpDownCtrlExch m_AspTimeoutSpin;
};

#endif //_ASP_MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\cacheopt.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        cacheopt.cpp

   Abstract:
        ASP Cache options page

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include <aclapi.h>
#include "CacheOpt.h"

#define TOTAL_CACHE_DEFAULT      1000
#define IIS5_CACHE_DEFAULT		 250

LRESULT 
CCacheOptPage::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   if (NULL == m_pData)
   {
      ASSERT(FALSE);
      ::EndDialog(hDlg, 0);
      return -1;
   }
   m_bInitDone = FALSE;
   // Set defaults for disabled controls
   if (m_pData->m_NoCache)
   {
	   m_pData->m_TotalCacheSize = TOTAL_CACHE_DEFAULT;
	   m_pData->m_LimCacheInMemorySize = 250;
	   m_pData->m_UnlimCacheInMemorySize = 250;
   }
   else if (m_pData->m_UnlimCache)
   {
	   m_pData->m_TotalCacheSize = TOTAL_CACHE_DEFAULT;
	   m_pData->m_LimCacheInMemorySize = 250;
   }
   else if (m_pData->m_LimCache)
   {
	   m_pData->m_UnlimCacheInMemorySize = 250;
   }
   DoDataExchange();
   m_FileChooser.Init(this, m_pData->IsLocal() ? FC_DIRECTORY_ONLY | FC_FORWRITE : 0, 
       IDC_CACHE_PATH, IDC_BROWSE);
   CString title;
   if (title.LoadString(_Module.GetResourceInstance(), IDS_SELECT_CACHE_PATH))
      m_FileChooser.SetDialogTitle(title);
   m_FileChooser.SetPath(m_pData->m_DiskCacheDir);

   ::EnableWindow(GetDlgItem(IDC_BROWSE), m_pData->IsLocal());

   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

   m_eng_cache.SetRange32(SCRIPT_ENG_MIN, SCRIPT_ENG_MAX);
   m_eng_cache.SetPos32(m_pData->m_ScriptEngCacheMax);
   m_eng_cache.SetAccel(3, toAcc);
   
   m_cache_size.SetRange32(CACHE_SIZE_MIN, CACHE_SIZE_MAX);
   m_cache_size.SetPos32(m_pData->m_TotalCacheSize);
   m_cache_size.SetAccel(3, toAcc);
   
   m_inmem_unlim.SetRange32(0, m_pData->m_TotalCacheSize);
   m_inmem_unlim.SetPos32(m_pData->m_UnlimCacheInMemorySize);
   m_inmem_unlim.SetAccel(3, toAcc);
   
   m_inmem_lim.SetRange32(0, m_pData->m_TotalCacheSize);
   m_inmem_lim.SetPos32(m_pData->m_LimCacheInMemorySize);
   m_inmem_lim.SetAccel(3, toAcc);

   UINT id = IDC_UNLIMITED_CACHE;
   if (m_pData->m_NoCache) 
      id = IDC_NO_CACHE;
   else if (m_pData->m_LimCache) 
      id = IDC_LIMITED_CACHE;
   OnCacheSwitch(0, id, NULL);

   AdjustTracker();

   DoDataExchange();

   m_bInitDone = TRUE;

   return FALSE;
};

BOOL
CCacheOptPage::OnKillActive()
{
   HRESULT hr = S_OK;

   if (m_bInitDone)
   {
      if (!DoDataExchange(TRUE))
		  return FALSE;
	  hr = m_pData->Save();
      if (m_pData->m_LimCache)
      {
         if (m_pData->m_LimCacheInMemorySize > m_pData->m_TotalCacheSize)
         {
            ::SetFocus(GetDlgItem(IDC_INMEM_LIM_EDIT));
            return FALSE;
         }
      }
      CString buf;
	  DWORD rc;
      if (FC_SUCCESS != (rc = m_FileChooser.GetFileName(buf)))
	  {
		  DWORD id;
          if (rc == FC_TEXT_IS_INVALID)
          {
			  id = ERROR_DIRECTORY;
          }
		  else if (m_pData->IsLocal() && FC_FILE_DOES_NOT_EXIST == rc)
		  {
			  id = ERROR_PATH_NOT_FOUND;
		  }
		  CError err(id);
		  err.MessageBox(MB_OK);
          ::SetFocus(GetDlgItem(IDC_CACHE_PATH));
          SendDlgItemMessage(IDC_CACHE_PATH, EM_SETSEL, 0, -1);
          return FALSE;
	  }
	  if (m_pData->IsLocal())
	  {
		 TCHAR expanded[MAX_PATH];
	     ExpandEnvironmentStrings(buf, expanded, MAX_PATH);
	     buf = expanded;
         DWORD attr = ::GetFileAttributes(buf);
         if (-1 == (int)attr)
		 {
            CError err(GetLastError());
            err.MessageBox(MB_OK);
            ::SetFocus(GetDlgItem(IDC_CACHE_PATH));
            SendDlgItemMessage(IDC_CACHE_PATH, EM_SETSEL, 0, -1);
            return FALSE;
		 }
	     if (  (attr & FILE_ATTRIBUTE_READONLY) != 0
		    || (attr & FILE_ATTRIBUTE_DIRECTORY) == 0
			|| PathIsNetworkPath(buf)
			)
		 {
		    CString cap, msg;
			cap.LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE);
			msg.LoadString(_Module.GetResourceInstance(), IDS_READ_ONLY_DIRECTORY);
			SendDlgItemMessage(IDC_CACHE_PATH, EM_SETSEL, 0, -1);
			MessageBox(msg, cap);
			::SetFocus(GetDlgItem(IDC_CACHE_PATH));
			return FALSE;
		 }
	  }
#if 0
	  // Andy will do this during startup. It is impossible to do in remote case.
      // Setup access permissions for the directory
      CWaitCursor clock;
      EXPLICIT_ACCESS ea[3];
      PACL pNewDACL = NULL;
      CString strWamIdentity;
      SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

      // go get the IWAM account name from the metabase
      CMetabasePath w3svc(TRUE, SZ_MBN_WEB);
      CComAuthInfo auth(m_pData->m_ServerName, 
         m_pData->m_UserName, m_pData->m_UserPassword); 
      CMetaKey mk(&auth, w3svc, METADATA_PERMISSION_READ);
      if (!mk.Succeeded() || FAILED(hr = mk.QueryValue(MD_WAM_USER_NAME, strWamIdentity)))
      {
         return FALSE;
      }

      ZeroMemory(ea, sizeof(EXPLICIT_ACCESSA) * 3);
    
      ea[0].grfAccessPermissions = SYNCHRONIZE | GENERIC_ALL;
      ea[0].grfAccessMode = GRANT_ACCESS;
      ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
      ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;

      ea[1].grfAccessPermissions = SYNCHRONIZE | GENERIC_ALL;
      ea[1].grfAccessMode = GRANT_ACCESS;
      ea[1].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
      ea[1].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
      ea[1].Trustee.ptstrName = (LPTSTR)(LPCTSTR)strWamIdentity;

      ea[2].grfAccessPermissions = SYNCHRONIZE | GENERIC_ALL;
      ea[2].grfAccessMode = GRANT_ACCESS;
      ea[2].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
      ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;

      // build the new DACL with just these ACEs
      if (!AllocateAndInitializeSid(&NtAuthority,
                                       1,
                                       SECURITY_LOCAL_SYSTEM_RID,
                                       0,0,0,0,0,0,0,
                                       (PSID *)(&ea[0].Trustee.ptstrName)))
         hr = HRESULT_FROM_WIN32(GetLastError());
      else if (!AllocateAndInitializeSid(&NtAuthority,
                                       2,            // 2 sub-authorities
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_ADMINS,
                                       0,0,0,0,0,0,
                                       (PSID *)(&ea[2].Trustee.ptstrName)))

         hr = HRESULT_FROM_WIN32(GetLastError());

      else if ((hr = SetEntriesInAcl(3, ea, NULL, &pNewDACL)) != ERROR_SUCCESS);

      // set the ACL on the directory

      else hr = SetNamedSecurityInfo((LPTSTR)(LPCTSTR)buf,
                                    SE_FILE_OBJECT,
                                    DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                                    NULL,
                                    NULL,
                                    pNewDACL,
                                    NULL);
      if (pNewDACL)
         LocalFree(pNewDACL);

      if (ea[0].Trustee.ptstrName)
         FreeSid(ea[0].Trustee.ptstrName);

      if (ea[2].Trustee.ptstrName)
         FreeSid(ea[2].Trustee.ptstrName);
#endif
      if (SUCCEEDED(hr))
      {
         StrCpy(m_pData->m_DiskCacheDir, buf);
      }
   }
   return SUCCEEDED(hr);
}

void
CCacheOptPage::OnCacheSwitch(UINT, UINT nID, HWND)
{
   switch (nID)
   {
   case IDC_NO_CACHE:
      m_pData->m_NoCache = TRUE;
      m_pData->m_UnlimCache = FALSE;
      m_pData->m_LimCache = FALSE;
      break;
   case IDC_UNLIMITED_CACHE:
      m_pData->m_NoCache = FALSE;
      m_pData->m_UnlimCache = TRUE;
      m_pData->m_LimCache = FALSE;
      break;
   case IDC_LIMITED_CACHE:
      // When cache is unlimited or disabled, total size is set to -1,
      // reset it to reasonable default here
//      if (m_pData->m_TotalCacheSize >= CACHE_UNLIM_MAX)
//      {
      {
//         m_pData->m_TotalCacheSize = 
//            __max(m_pData->m_LimCacheInMemorySize, TOTAL_CACHE_DEFAULT);
//         DoDataExchange(FALSE, IDC_CACHE_SIZE_EDIT);
//      }
      }
      m_pData->m_NoCache = FALSE;
      m_pData->m_UnlimCache = FALSE;
      m_pData->m_LimCache = TRUE;
      break;
   }
   m_NoCacheBtn.SetCheck(m_pData->m_NoCache);
   m_UnlimCacheBtn.SetCheck(m_pData->m_UnlimCache);
   m_LimCacheBtn.SetCheck(m_pData->m_LimCache);

   m_inmem_unlim.EnableWindow(m_pData->m_UnlimCache);
   ::EnableWindow(GetDlgItem(IDC_INMEM_UNLIM_EDIT), m_pData->m_UnlimCache);

   m_inmem_lim.EnableWindow(m_pData->m_LimCache);
   ::EnableWindow(GetDlgItem(IDC_INMEM_LIM_EDIT), m_pData->m_LimCache);
   m_cache_size.EnableWindow(m_pData->m_LimCache);
   ::EnableWindow(GetDlgItem(IDC_CACHE_SIZE_EDIT), m_pData->m_LimCache);
   m_cache_dist.EnableWindow(m_pData->m_LimCache);

   SET_MODIFIED(TRUE);
}

void
CCacheOptPage::OnChangeCacheSize(UINT nCode, UINT nID, HWND)
{
   if (::IsWindow(m_cache_dist.m_hWnd) && m_bInitDone)
   {
//      DoDataExchange(TRUE, IDC_CACHE_SIZE_EDIT);
//      DoDataExchange(TRUE, IDC_INMEM_LIM_EDIT);
// DoDataExchange is not suitable here -- it will call OnDataExchange error internally
// and will immediately produce annoying popup
      BOOL translated;
      m_pData->m_TotalCacheSize = GetDlgItemInt(IDC_CACHE_SIZE_EDIT, &translated, FALSE);
      m_pData->m_LimCacheInMemorySize = GetDlgItemInt(IDC_INMEM_LIM_EDIT, &translated, FALSE);
      m_inmem_lim.SetRange32(0, m_pData->m_TotalCacheSize);
	  if (m_pData->m_LimCacheInMemorySize > m_pData->m_TotalCacheSize)
	  {
		  // If in-memory limit is currently higher than total, set it to total
		  m_pData->m_LimCacheInMemorySize = m_pData->m_TotalCacheSize;
		  DoDataExchange(FALSE, IDC_INMEM_LIM_EDIT);
		  m_inmem_lim.SetPos32(m_pData->m_LimCacheInMemorySize);
	  }
      AdjustTracker();
      // Here we could adjust in memory size to be less or equal to the total size,
      // but I decided that it could be annoying: what if user deleted last zero
      // in total size control, and in memory size turned to be larger than total size.
      // We immediately will cut it to total, and to fix this mistake user will need 
      // to touch two places. It will be too bad.
      SET_MODIFIED(TRUE);
   }
}

void
CCacheOptPage::OnChangeInmemCacheSize(UINT nCode, UINT nID, HWND)
{
   if (::IsWindow(m_cache_dist.m_hWnd) && m_bInitDone)
   {
//      DoDataExchange(TRUE, nID);
// DoDataExchange is not suitable here -- it will call OnDataExchange error internally
// and will immediately produce annoying popup
      BOOL translated;
      m_pData->m_LimCacheInMemorySize = GetDlgItemInt(IDC_INMEM_LIM_EDIT, &translated, FALSE);
      AdjustTracker();
      SET_MODIFIED(TRUE);
   }
}

void
CCacheOptPage::OnTrackBarScroll(UINT nSBCode, UINT nPos, HWND hwnd)
{
   BOOL bChange = FALSE;
   int endval;
   switch (nSBCode)
   {
   case SB_THUMBPOSITION:
       if (nPos > m_pData->m_LimCacheInMemorySize)
       {
           m_pData->m_LimCacheInMemorySize = min(nPos, m_pData->m_TotalCacheSize);
       }
       else if (nPos < m_pData->m_LimCacheInMemorySize)
       {
           m_pData->m_LimCacheInMemorySize = max(nPos, 0);
       }
       else
       {
           m_pData->m_LimCacheInMemorySize = nPos;
       }
      bChange = TRUE;
      break;
   case SB_LINELEFT:
      endval = m_pData->m_LimCacheInMemorySize - m_c