----------------------------------------*/
int Report_Alias_IO(IN PSERIAL_DEVICE_EXTENSION extension)
{
 PCM_RESOURCE_LIST resourceList;
 ULONG sizeOfResourceList;
 ULONG countOfPartials;
 PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
 NTSTATUS status;
 PHYSICAL_ADDRESS MyPort;
 BOOLEAN ConflictDetected;
 BOOLEAN MappedFlag;
 int j;
 int brd = extension->UniqueId;
 DEVICE_CONFIG *Ctl;
 char name[70];
 int need_alias = 0;
 int NumAiop;

  DTraceStr("ReportResources");
  ConflictDetected=FALSE;

  countOfPartials=0;
  Ctl = extension->config;

  // we got mudback.
  if (Ctl->BusType != Isa)
  {
    DTraceStr("NotISA");
    return 0;
  }

  // if it only has 1 aiopic and has 4 bytes for mudback,
  // then no aliasing required.
  if (Ctl->BaseIoSize != 0x44)
    need_alias = 1;

   // rocketport boards need extra aiop space for reset circuitry.
  if (extension->config->ModemDevice)
  {
    need_alias = 1;
  }

  if (Ctl->NumPorts > 8)
    need_alias = 1;

  if (need_alias == 0)
  {
    // no aliasing needed.
    DTraceStr("EasyISA");
    return 0;
  }
  // we need to update initcontroller to stall until first controller
  // gets a start.

  // else it is an additional board which needs to alias its mudback
  // ontop of the first ISA(44H) address space, or it is a board
  // with more than 1 aiopic chip(which requires aliasing over itself)
  if (Ctl->BaseIoSize != 0x44)  // must be 2nd, 3rd, or 4th board
  {
     DTraceStr("HasMdBk");
     countOfPartials++;         // so mudback is aliased up
  }

  NumAiop = Ctl->NumAiop;

  if (extension->config->ModemDevice)
  {  // reset circuitry
     ++NumAiop;
  }
  if (NumAiop > 4)
    return 15;  // error

  MyKdPrint(D_Pnp,("Report Resources brd:%d bus:%d\n",brd+1, Ctl->BusType))

  // don't report first aiop(we got that from pnp)
  for (j=1; j<NumAiop; j++)
  {
    if (Ctl->AiopIO[j] > 0)
      countOfPartials++;  // For each Aiop, we will get resources
  }

  sizeOfResourceList = sizeof(CM_RESOURCE_LIST) +
                       sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +  // add, kpb
                        (sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)*
                        countOfPartials);

                       // add 64 for slop
  resourceList = ExAllocatePool(PagedPool, sizeOfResourceList+64);

  if (!resourceList)
  {
    if (Driver.VerboseLog)
      Eprintf("No ResourceList");

    EventLog(Driver.GlobalDriverObject,
             STATUS_SUCCESS,
             SERIAL_INSUFFICIENT_RESOURCES,
             0, NULL);
    return(9);
  }

  RtlZeroMemory(resourceList, sizeOfResourceList);

  resourceList->Count = 1;
  resourceList->List[0].InterfaceType = Ctl->BusType;
  resourceList->List[0].BusNumber = Ctl->BusNumber;  //change for multibus
  resourceList->List[0].PartialResourceList.Count = countOfPartials;
  partial = &resourceList->List[0].PartialResourceList.PartialDescriptors[0];

  // Account for the space used by the Rocket.
  // Report the use of the Mudbacs on Isa boards only
  if (Ctl->BaseIoSize != 0x44)  // must be 2nd, 3rd, or 4th board
  {
    MyPort.HighPart=0x0;
    MyPort.LowPart=Ctl->MudbacIO;
    partial->Type = CmResourceTypePort;
    partial->ShareDisposition = CmResourceShareDeviceExclusive;
    partial->Flags = CM_RESOURCE_PORT_IO;
    partial->u.Port.Start = MyPort;
    partial->u.Port.Length = SPANOFMUDBAC;
    partial++;
  }

  for (j=1; j<NumAiop; j++)
  {
    if (Ctl->AiopIO[j] == 0)
      Ctl->AiopIO[j] = Ctl->AiopIO[j-1];

    // Report the use of the AIOPs.
    if (Ctl->AiopIO[j] > 0)
    {
       MyPort.HighPart=0x0;
       MyPort.LowPart=Ctl->AiopIO[j];
       partial->Type = CmResourceTypePort;
       partial->ShareDisposition = CmResourceShareDeviceExclusive;
       partial->Flags = CM_RESOURCE_PORT_IO;
       partial->u.Port.Start = MyPort;
       partial->u.Port.Length = SPANOFAIOP;
       partial++;
    }
    else
    {
       MyKdPrint(D_Pnp,("Aiop Count Wrong, A.\n"))
       if (Driver.VerboseLog)
         Eprintf("Error RR12");
    }
  }  // end for j

  //-------- Report the resources indicated by partial list (resourceList)
  strcpy(name, szResourceClassName);
  our_ultoa(extension->UniqueId, &name[strlen(name)], 10);

  MyKdPrint(D_Pnp,("Reporting Resources To system\n"))
  status=IoReportResourceUsage(
      CToU1(name),                     // DriverClassName OPTIONAL,
      extension->DeviceObject->DriverObject,  // DriverObject,
      // Driver.GlobalDriverObject,
      NULL,                          // DriverList OPTIONAL,
      0,                             // DriverListSize OPTIONAL,
      extension->DeviceObject,       // DeviceObject
      resourceList,                  // DeviceList OPTIONAL,
      sizeOfResourceList,            // DeviceListSize OPTIONAL,
      FALSE,                         // OverrideConflict,
      &ConflictDetected);            // ConflictDetected

  if (!NT_SUCCESS(status))
  {
    if (Driver.VerboseLog)
      Eprintf("Error, Resources");
    TraceErr("Err5G");
  }

  if (ConflictDetected) 
  {
    Eprintf("Error, Resource Conflict.");
    if (resourceList)
      ExFreePool(resourceList);
    resourceList = NULL;
    EventLog(Driver.GlobalDriverObject,
             STATUS_SUCCESS,
             SERIAL_INSUFFICIENT_RESOURCES,
             0, NULL);
    MyKdPrint(D_Pnp,("Resource Conflict Detected.\n"))
    return(10);
  }

  // OK, even more important than reporting resources is getting
  // the pointers to the I/O ports!!

  if (Ctl->BusType == Isa)
  {
    MyPort.HighPart=0x0;
    MyPort.LowPart=Ctl->MudbacIO;

    if (Ctl->BaseIoSize != 0x44)  // must be 2nd, 3rd, or 4th board
    {
      Ctl->pMudbacIO =
          SerialGetMappedAddress(Isa,Ctl->BusNumber,MyPort,SPANOFMUDBAC,1,&MappedFlag,1);
      if (Ctl->pMudbacIO == NULL) 
      {
        if (Driver.VerboseLog)
          Eprintf("Err RR15");
        MyKdPrint(D_Pnp,("Resource Error A.\n"))
        return 11;
      }
    }
  }

  for (j=1; j<NumAiop; j++)
  {
    if (Ctl->AiopIO[j] > 0)
    {
      MyPort.HighPart=0x0;
      MyPort.LowPart=Ctl->AiopIO[j];
      Ctl->pAiopIO[j] =
          SerialGetMappedAddress(Ctl->BusType,
                      Ctl->BusNumber,MyPort,SPANOFAIOP,1,&MappedFlag,1);

      if (Ctl->pAiopIO[j] == NULL) 
      {
        if (Driver.VerboseLog)
          Eprintf("Err RR16");
        MyKdPrint(D_Pnp,("Resource Error B.\n"))
        return 12;
      }

    }
    else
    {
      if (Driver.VerboseLog)
        Eprintf("Err RR17");
      MyKdPrint(D_Pnp,("Aiop Count Wrong, B.\n"))
      return 13;
    }
  }

  extension->io_reported = 1; // tells that we should deallocate on unload.

  // Release the memory used for the resourceList
  if (resourceList)
    ExFreePool(resourceList);
  resourceList = NULL;
  MyKdPrint(D_Pnp,("Done Reporting Resources\n"))
  return 0;
}
#endif

#if 0
/*----------------------------------------------------------------------
SerialFindInitController -
|----------------------------------------------------------------------*/
NTSTATUS
SerialFindInitController(IN PDEVICE_OBJECT Fdo, IN PCONFIG_DATA PConfig)
{
   PSERIAL_DEVICE_EXTENSION fdoExtension    = Fdo->DeviceExtension;
   PDEVICE_OBJECT pDeviceObject;
   PSERIAL_DEVICE_EXTENSION pExtension;
   PHYSICAL_ADDRESS serialPhysicalMax;
   //SERIAL_LIST_DATA listAddition;
   PLIST_ENTRY currentFdo;
   NTSTATUS status;

   serialPhysicalMax.LowPart = (ULONG)~0;
   serialPhysicalMax.HighPart = ~0;

   //if (address is hosed,)
   //   return STATUS_NO_SUCH_DEVICE;

   //
   // Loop through all of the driver's device objects making
   // sure that this new record doesn't overlap with any of them.
   //
#ifdef DO_LATER
   if (!IsListEmpty(&Driver.AllFdos)) {
      currentFdo = Driver.AllFdos.Flink;
      pExtension = CONTAINING_RECORD(currentFdo, SERIAL_DEVICE_EXTENSION,
                                     AllFdos);
   } else {
      currentFdo = NULL;
      pExtension = NULL;
   }

   //
   // Loop through all previously attached devices
   //
   if (!IsListEmpty(&Driver.AllFdos)) {
      currentFdo = Driver.AllFdos.Flink;
      pExtension = CONTAINING_RECORD(currentFdo, SERIAL_DEVICE_EXTENSION,
                                     AllFdos);
   } else {
      currentFdo = NULL;
      pExtension = NULL;
   }

   //status = SerialInitOneController(Fdo, PConfig);
   //PSERIAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
   // init the thing

   if (!NT_SUCCESS(status)) {
      return status;
   }
#endif

   return STATUS_SUCCESS;
}
#endif  // 0


#ifdef DO_BRD_FILTER_RES_REQ
/*----------------------------------------------------------------------
 BoardFilterResReq -  handle IRP_MN_FILTER_RESOURCE_REQUIREMENTS:  // 0x0D
  for our board FDO entity.  Test to see if we can adjust requirements
  to handle io-aliasing(no, doesn't look too promising).
|----------------------------------------------------------------------*/
NTSTATUS BoardFilterResReq(IN PDEVICE_OBJECT devobj, IN PIRP Irp)
{
   PSERIAL_DEVICE_EXTENSION  Ext = devobj->DeviceExtension;
   PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS                    status          = STATUS_NOT_SUPPORTED;

   //******** see serial driver(changes resource requirements)
   HANDLE pnpKey;
   //KEVENT resFiltEvent;
   //ULONG isMulti = 0;
   PIO_RESOURCE_REQUIREMENTS_LIST prrl;
   PIO_RESOURCE_LIST prl;
   PIO_RESOURCE_DESCRIPTOR prd;

   PIO_RESOURCE_REQUIREMENTS_LIST new_prrl;
   PIO_RESOURCE_LIST new_prl;
   PIO_RESOURCE_DESCRIPTOR new_prd;

   ULONG i, j;
   ULONG reqCnt;
   ULONG rrl_size;
   ULONG rl_size;

   TraceStr1("Filt Res Req, PDO:%x", do);

   status = WaitForLowerPdo(devobj, Irp);

   if (Irp->IoStatus.Information == 0)
   {
      if (irpStack->Parameters.FilterResourceRequirements
          .IoResourceRequirementList == 0)
      {
         DTraceStr("No Resources");
         status = Irp->IoStatus.Status;
         SerialCompleteRequest(Ext, Irp, IO_NO_INCREMENT);
         return status;
      }

      Irp->IoStatus.Information = (ULONG)irpStack->Parameters
                                  .FilterResourceRequirements
                                  .IoResourceRequirementList;
   }

   // Add aliases to IO_RES_REQ_LIST.
   prrl = (PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information;

#if 0
   new_prrl = (new_prrl) ExAllocatePool(PagedPool,
         prrl->ListSize + (sizeof(IO_RESOURCE_DESCRIPTOR)*2));
   if (new_prrl == NULL)
   {
     TraceErr("Bad Buf Z");
     //ExFreePool();
   }
   memcpy(new_prrl, prrl);
#endif

   //reqCnt = ((prrl->ListSize - sizeof(IO_RESOURCE_REQUIREMENTS_LIST))
   //          / sizeof(IO_RESOURCE_DESCRIPTOR)) + 1;
   reqCnt = 0;

   TraceStr1("RRL Size:%x", sizeof(IO_RESOURCE_REQUIREMENTS_LIST));
   TraceStr1("RL Size:%x", sizeof(IO_RESOURCE_LIST));
   TraceStr1("RD Size:%x", sizeof(IO_RESOURCE_DESCRIPTOR));
   TraceStr1("List Size:%x", prrl->ListSize);

   rrl_size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) -
                    sizeof(IO_RESOURCE_LIST);
   rl_size = sizeof(IO_RESOURCE_LIST) - sizeof(IO_RESOURCE_DESCRIPTOR);

   TraceStr1("RRL Base Size:%x", rrl_size);
   TraceStr1("RL Base Size:%x", rl_size);

   //for (i = 0; i < reqCnt; i++) {
   reqCnt = rrl_size;  // pass up base of IO_RESOURCE_REQUIREMENTS_LIST
   while (reqCnt < prrl->ListSize)
   {
      prl = (PIO_RESOURCE_LIST) &((BYTE *)prrl)[reqCnt];  // ptr to IO_RESOURCE_LIST
      reqCnt += rl_size;  // pass up base of IO_RESOURCE_LIST

      TraceStr1("Num Res Desc:%d", prl->Count);
      for (j = 0; j < prl->Count; j++)
      {
        reqCnt += sizeof(IO_RESOURCE_DESCRIPTOR);
        prd = &prl->Descriptors[j];
        TraceStr2("Desc Type:%x, Flags:%x", prd->Type, prd->Flags);
        if (prd->Type == CmResourceTypePort)
        {
           DTraceStr("Type:Port");
           TraceStr2("Min:%x Max:%x",
             prd->u.Port.MinimumAddress.LowPart,
             prd->u.Port.MaximumAddress.LowPart);
           TraceStr2("Align:%x Len:%x",
             prd->u.Port.Alignment, prd->u.Port.Length);

           //Addr = (unsigned int) prd->u.Port.Start.LowPart;
           //if (Addr < 0x400)
           //   pConfig->BaseIoAddr = Addr;
           //pConfig->BaseIoSize = prd->u.Port.Length;
        }
      }
      TraceStr1("ByteCnt:%d", reqCnt);
   }

   Irp->IoStatus.Status = STATUS_SUCCESS;
   SerialCompleteRequest(Ext, Irp, IO_NO_INCREMENT);
   return STATUS_SUCCESS;
}
#endif  // DO_BRD_FILTER_RES_REQ


/*----------------------------------------------------------------------------
| is_isa_cards_pending_start - scan linked list of card devices, see if
   any ISA bus cards are not started(delayed or pending a start waiting
   for first ISA card.)
|----------------------------------------------------------------------------*/
int is_isa_cards_pending_start(void)
{
 PSERIAL_DEVICE_EXTENSION Ext;

  Ext = Driver.board_ext;
  while (Ext)
  {
    if (Ext->config->BusType == Isa)
    {
      if (Ext->config->ISABrdIndex == 0)
      {
        if (Ext->config->HardwareStarted)
          return 1;  // true, its pending a start
      }
    }
    Ext = Ext->board_ext;  // next in chain
  }  // while board extension

  return 0;  // false, not started
}

/*----------------------------------------------------------------------------
| is_first_isa_card_started - scan linked list of card devices, see if
   "first" ISA bus card is started.
|----------------------------------------------------------------------------*/
int is_first_isa_card_started(void)
{
 PSERIAL_DEVICE_EXTENSION Ext;

  Ext = Driver.board_ext;
  while (Ext)
  {
    if (Ext->config->BusType == Isa)
    {
      if (Ext->config->ISABrdIndex == 0)
      {
        if (Ext->config->HardwareStarted)
          return 1;  // true, its started
      }
    }
    Ext = Ext->board_ext;  // next in chain
  }  // while board extension

  return 0;  // false, not started
}

#endif  // NT50
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\precomp.h ===
//---- precomp.h 
// common include file so we can use pre-compiled headers

#define NDIS40 1

#include <ntddk.h>
#include <ntddser.h>

#include <stdarg.h>
#include <wchar.h>
#include <ndis.h>
#ifdef NT50
#include <wmilib.h>
// #include "wmi.h"
#include <wmidata.h>
#endif
#include "nic.h"
#include "queue.h"
#include "admin.h"
#include "hdlc.h"
#include "port.h"
#include "asic.h"
#include "debuger.h"
#include "ssci.h"
#include "init.h"
#include "utils.h"
#include "options.h"
#include "initc.h"
#include "initvs.h"
#include "initrk.h"
#include "read.h"
#include "write.h"
#include "waitmask.h"
#include "openclos.h"
#include "pnpadd.h"
#include "pnp.h"
#include "pnprckt.h"
#include "isr.h"
#include "ioctl.h"
#include "rcktioct.h"
#include "opstr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\port.h ===
// port.h - serial port stuff
// 5-13-99 - enable RTS toggling for VS
// 3-20-98 add NEW_Q stuff, turned off for now - kpb

// following defines the port queue sizes for in/out going data between
// box and us.  See Qin, Qout structs in SerPort structs.
#define  IN_BUF_SIZE 2000  // must match box code, and be even #
#define OUT_BUF_SIZE 2000  // must match box code, and be even #

// uncomment this for new-q tracking code
#define NEW_Q

#ifdef NEW_Q
// following is less the rocketport-hardware buffer in the box
#define REMOTE_IN_BUF_SIZE (2000 - 256)
#endif

#define PORTS_MAX_PORTS_PER_DEVICE 64

//-------- sub-packet type byte header defines for type ASYNC_FRAME
#define RK_QIN_STATUS       0x60  // qin status report
#define RK_DATA_BLK         0x61  // data block
#define RK_PORT_SET         0x62  // set the port num to work with
#define RK_CONTROL_SET      0x63  // config the hardware
#define RK_MCR_SET          0x64  // change on modem control reg.
#define RK_MSR_SET          0x65  // change on modem status reg.
#define RK_ACTION_SET       0x66  // new actions, such as flush.
#define RK_ACTION_ACK       0x67  // response to actions, such as flush.
#define RK_BAUD_SET         0x70  // set the baud rate
#define RK_SPECIAL_CHAR_SET 0x71  // xon,xoff, err-replace, event-match
#define RK_ESR_SET          0x72  // set error status register.

#define RK_CONNECT_CHECK    0xfd  // server packet to check link is working
#define RK_CONNECT_REPLY    0xfe  // reply from RK_CONNECT_ASK
#define RK_CONNECT_ASK      0xff  // broadcast from server to get report from boxes

//------ old ssci.h stuff
#define TRUE 1
#define FALSE 0

//#define RX_HIWATER 512                 /* sw input flow ctl high water mark */
//#define RX_LOWATER 256                 /* sw input flow ctl low water mark */

#define OFF      0
#define ON       1
#define NOCHANGE 2

//Status
/* Open type and TX and RX identifier flags (unsigned int) */
#define COM_OPEN     0x0001            /* device open */
#define COM_TX       0x0002            /* transmit */
#define COM_RX       0x0004            /* receive */

typedef struct
{
  BYTE  rx_xon;  // xon  sent by us to resume rx flow, default to 11H
  BYTE  rx_xoff; // xoff sent by us to halt rx flow, default to 13H
  BYTE  tx_xon;  // xon  rec. by us to resume tx flow, default to 11H
  BYTE  tx_xoff; // xoff rec. by us to halt tx flow, default to 13H
  BYTE error; // in NT, option to replace error-chars with this char
  BYTE event; // in NT, can specify a event-char to match and notify
} Special_Chars;

// for NT, we want to keep this DWORD aligned, so NT and DOS see same struct
typedef struct
{
  //WORD  dev;      // handle index to com port, same as COM#(# part)
  //WORD  LanIndex; // index of port number to LAN
  WORD  Status;     // we use as internal status indicator

  WORD control_settings;   // parity, stopbits, databits, flowcontrol
  WORD old_control_settings;   // used to detect change
  DWORD baudrate;
  DWORD old_baudrate; // used to detect change
  WORD mcr_value;  // modem control register state
  WORD old_mcr_value;  // used to detect change

  WORD change_flags; // tells what might have changed and needs transfer to remote

  WORD msr_value;  // modem status register state
  WORD old_msr_value;  // used to detect change

  WORD action_reg;  // action(one-shot) functions:flush, etc.

  WORD esr_reg;  // error status register state(framing err, parity err,,)
                   // one shot style register(resets on read)

  // The following Q structures are in perspective of the LAN.
  // So QOut is the Que for data which is destined for the remote
  // client over the LAN.  QIn is data we received from the LAN.
  Queue QOut;
  Queue QIn;
#ifdef NEW_Q
  // How much data can we send over to the remote?
  // new method which can include hardware tx buffer space and
  // does not rely on set queue sizes.
  WORD nPutRemote; // tx data we sent to remote, Modulo 0x10000.
  WORD nGetRemote; // tx data remote cleared out, Modulo 0x10000.
                   // this value is sent to us as an update.
  WORD nGetLocal;  // tx data we cleared out, Modulo 0x10000.
                   // we send back as an update.
#else
  // How much data can we send over to the remote?  We can calculate
  // this by maintaining a mirror image of its Q data structure.
  // We maintain the Q.Put index, and the remote side sends us its
  // actual Q.Get value when it changes.  Then when we want to
  // calculate the room left in the remote queue(this includes anything
  // in transit.) we just do the normal queue arithmetic.
  // there is no actual data buffer used in this queue structure.
  Queue QInRemote;
#endif

  WORD remote_status;
  Special_Chars sp_chars;  // special chars struct: xon, xoff..
  Special_Chars last_sp_chars;  // used to detect when we need to send
} SerPort;



//----- change_flags bit assignments
// tells what has changed and needs transfer to remote
#define CHG_SP_CHARS       0x0001
#define CHG_BAUDRATE       0x0002

//----- Mirror Register bit flags, these are associated with fields in
// the SerPort struct, and get mirrored back/forth to the box to transfer
// state of the port.
// values for Status(SerPort)
#define S_OPENED           0x0001
#define S_UPDATE_ROOM      0x0002
#define S_NEED_CODE_UPDATE 0x0800

// control_settings, control settings
#define SC_STOPBITS_MASK  0x0001
#define SC_STOPBITS_1     0x0000
#define SC_STOPBITS_2     0x0001

#define SC_DATABITS_MASK  0x0002
#define SC_DATABITS_7     0x0002
#define SC_DATABITS_8     0x0000

#define SC_PARITY_MASK    0x000c
#define SC_PARITY_NONE    0x0000
#define SC_PARITY_EVEN    0x0004
#define SC_PARITY_ODD     0x0008

#define SC_FLOW_RTS_MASK   0x0070
#define SC_FLOW_RTS_NONE   0x0000
#define SC_FLOW_RTS_AUTO   0x0010
#define SC_FLOW_RTS_RS485  0x0020  // rts turn on to transmit
#define SC_FLOW_RTS_ARS485 0x0040  // rts turn off to transmit(auto-rocketport)

#define SC_FLOW_CTS_MASK  0x0080
#define SC_FLOW_CTS_NONE  0x0000
#define SC_FLOW_CTS_AUTO  0x0080

#define SC_FLOW_DTR_MASK  0x0100
#define SC_FLOW_DTR_NONE  0x0000
#define SC_FLOW_DTR_AUTO  0x0100

#define SC_FLOW_DSR_MASK  0x0200
#define SC_FLOW_DSR_NONE  0x0000
#define SC_FLOW_DSR_AUTO  0x0200

#define SC_FLOW_CD_MASK   0x0400
#define SC_FLOW_CD_NONE   0x0000
#define SC_FLOW_CD_AUTO   0x0400

#define SC_FLOW_XON_TX_AUTO  0x0800
#define SC_FLOW_XON_RX_AUTO  0x1000

#define SC_NULL_STRIP      0x2000

// mcr_value, settings(modem control reg.)
#define MCR_RTS_SET_MASK   0x0001
#define MCR_RTS_SET_ON     0x0001
#define MCR_RTS_SET_OFF    0x0000

#define MCR_DTR_SET_MASK   0x0002
#define MCR_DTR_SET_ON     0x0002
#define MCR_DTR_SET_OFF    0x0000

// loop in rocketport asic chip
#define MCR_LOOP_SET_MASK  0x0004
#define MCR_LOOP_SET_ON    0x0004
#define MCR_LOOP_SET_OFF   0x0000

#define MCR_BREAK_SET_MASK  0x0008
#define MCR_BREAK_SET_ON    0x0008
#define MCR_BREAK_SET_OFF   0x0000

// msr_value, settings(modem status reg.)
#define MSR_TX_FLOWED_OFF   0x0001
#define MSR_CD_ON           0x0008
#define MSR_DSR_ON          0x0010
#define MSR_CTS_ON          0x0020
#define MSR_RING_ON         0x0040
#define MSR_BREAK_ON        0x0080

//#define MSR_TX_FLOW_OFF_DTR  0x0040
//#define MSR_TX_FLOW_OFF_XOFF 0x0080

//-- action control register bit flags(server event out to device)
#define ACT_FLUSH_INPUT    0x0001
#define ACT_FLUSH_OUTPUT   0x0002
#define ACT_SET_TX_XOFF    0x0004
#define ACT_CLEAR_TX_XOFF  0x0008
#define ACT_SEND_RX_XON    0x0010
#define ACT_SEND_RX_XOFF   0x0020
#define ACT_MODEM_RESET    0x0040

//-- error status register bit flags
#define ESR_FRAME_ERROR    0x0001
#define ESR_PARITY_ERROR   0x0002
#define ESR_OVERFLOW_ERROR 0x0004
#define ESR_BREAK_ERROR    0x0008

//-- event control register bit flags(device event reported to server)

#define ST_INIT          0
#define ST_GET_OWNERSHIP 1
#define ST_SENDCODE      2
#define ST_CONNECT       3
#define ST_ACTIVE        4

// following for trace or dump messages, make public for other mods as well.
char *port_state_str[];

typedef struct {
  Nic *nic;    // ptr to our NIC card handler
  Hdlc *hd;    // ptr to our HDLC struct handler
  SerPort *sp[PORTS_MAX_PORTS_PER_DEVICE]; // ptr to list of our sp objects(num_ports worth)
  int unique_id;  // unique id assigned to this device
  int backup_server;  // 1=this is a backup server,0=primary server
  int backup_timer;   // 1=backup server timer used to detect how long to 
					  // wait before attempting to acquire the box
  int load_timer;  // our load_timer, incr. every time in port_poll compared
				   // against backup_timer for when to load box 
  int nic_index;  // index of nic card
  int num_ports;  // num ports on this box
  //int sp_index;   // index into total SerPort array
  int state;      // state for state-machine
  int old_state;  // old state, used to detect state changes and reset timer
  WORD state_timer;  // our state_timer, incr. every time in port_poll
  WORD Status;  // misc. bit flags
  int last_round_robin;  // used to cycle service of ports evenly
  ULONG code_cnt;        // used to upload code(marks position in upload data)
  WORD code_state;       // 1=signals port poll code to send next chunk
  WORD reload_errors;    // count of ialive failures
  WORD timer_base;       // used to time port_state_handler
  WORD total_loads;		// statistics
  WORD good_loads;      // statistics
  WORD ownership_timer;  // check timer due to hosed up ownership logic
} PortMan;  // port manager

// values for Status(PortMan)
#define S_SERVER           0x0001
#define S_CHECK_LINK       0x0002
#define S_NEED_CODE_UPDATE 0x0800

void port_state_handler(PortMan *pm);
int port_set_new_mac_addr(PortMan *pm, BYTE *box_addr);

int portman_init(Hdlc *hd,
                 PortMan *pm,
                 int num_ports,
                 int unique_id,
                 int backup_server, 
                 int backup_timer,
                 BYTE *box_addr);
int port_init(SerPort *sp);
int port_close(SerPort *sp);
int port_poll(PortMan *pm);
void port_debug_scr(PortMan *pm, char *outbuf);
int portman_close(PortMan *pm);

void PortFlushTx(SerPort *p);
void PortFlushRx(SerPort *p);

int PortSetBaudRate(SerPort *p,
                    ULONG desired_baud,
                    USHORT SetHardware,
                    DWORD  clock_freq,
                    DWORD  clk_prescaler);

WORD PortGetTxCntRemote(SerPort *p);

#define PortGetTxCnt(p) (q_count(&p->QOut))
// int PortGetTxCnt(SerPort *p)
// { return q_count(&p->QOut); }
#define PortGetTxRoom(p) (q_room(&p->QOut))

#define PortGetRxCnt(p) (q_count(&p->QIn))
//  return q_count(&p->QIn);

#define pIsTxFlowedOff(p) ((p)->msr_value & MSR_TX_FLOWED_OFF)

#define pEnLocalLoopback(p) \
    { (p)->mcr_value |= MCR_LOOP_SET_MASK; }

#define pDisLocalLoopback(p) \
    { (p)->mcr_value &= ~MCR_LOOP_SET_MASK; }

#define pSetBreak(p) \
    { (p)->mcr_value |= MCR_BREAK_SET_ON; }

#define pClrBreak(p) \
    { (p)->mcr_value &= ~MCR_BREAK_SET_ON; }

#define pSetDTR(p) \
  {(p)->mcr_value |= MCR_DTR_SET_ON;}

#define pClrDTR(p) \
  {(p)->mcr_value &= ~MCR_DTR_SET_ON;}
   
#define pSetRTS(p) \
  {(p)->mcr_value |= MCR_RTS_SET_ON;}

#define pClrRTS(p) \
  {(p)->mcr_value &= ~MCR_RTS_SET_ON;}
 
#define pEnRTSToggleLow(p) \
  { (p)->control_settings &= ~SC_FLOW_RTS_MASK; \
    (p)->control_settings |=  SC_FLOW_RTS_ARS485; }

#define pEnRTSToggleHigh(p) \
  { (p)->control_settings &= ~SC_FLOW_RTS_MASK; \
    (p)->control_settings |=  SC_FLOW_RTS_RS485; }

#define pEnDTRFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_DTR_AUTO; \
    (p)->control_settings |=  SC_FLOW_DTR_AUTO; }

#define pDisDTRFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_DTR_AUTO; }

#define pEnCDFlowCtl(p) \
  { (p)->control_settings |= SC_FLOW_CD_AUTO; }

#define pDisCDFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_CD_AUTO; }

#define pEnDSRFlowCtl(p) \
  { (p)->control_settings |= SC_FLOW_DSR_AUTO; }

#define pDisDSRFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_DSR_AUTO; }

#define pEnRTSFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_RTS_MASK; \
    (p)->control_settings |=  SC_FLOW_RTS_AUTO; \
    (p)->mcr_value |= MCR_RTS_SET_ON; }

#define pDisRTSFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_RTS_MASK; }

#define pDisRTSToggle(p) \
  { (p)->control_settings &= ~SC_FLOW_RTS_MASK; }

#define pEnCTSFlowCtl(p) \
  { (p)->control_settings |= SC_FLOW_CTS_AUTO; }

#define pDisCTSFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_CTS_AUTO; }

#define pEnNullStrip(p) \
  { (p)->control_settings |= SC_NULL_STRIP; }

#define pDisNullStrip(p) \
  { (p)->control_settings &= ~SC_NULL_STRIP; }

#define pSetXOFFChar(p,c) \
   { (p)->sp_chars.rx_xoff = (c); \
     (p)->sp_chars.tx_xoff = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pSetXONChar(p,c) \
   { (p)->sp_chars.rx_xon = (c); \
     (p)->sp_chars.tx_xon = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pSetTxXOFFChar(p,c) \
   { (p)->sp_chars.tx_xoff = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pSetTxXONChar(p,c) \
   { (p)->sp_chars.tx_xon = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pSetRxXOFFChar(p,c) \
   { (p)->sp_chars.rx_xoff = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pSetRxXONChar(p,c) \
   { (p)->sp_chars.rx_xon = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pSetErrorChar(p,c) \
   { (p)->sp_chars.error = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pSetEventChar(p,c) \
   { (p)->sp_chars.event = (c); \
     (p)->change_flags |= CHG_SP_CHARS; }

#define pEnRxSoftFlowCtl(p) \
  { (p)->control_settings |= SC_FLOW_XON_RX_AUTO; }
  
#define pDisRxSoftFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_XON_RX_AUTO; }
 
#define pEnTxSoftFlowCtl(p) \
  { (p)->control_settings |= SC_FLOW_XON_TX_AUTO; }
  
#define pDisTxSoftFlowCtl(p) \
  { (p)->control_settings &= ~SC_FLOW_XON_TX_AUTO; }

#define pSetStop2(p) \
  { (p)->control_settings |= SC_STOPBITS_2; }

#define pSetStop1(p) \
  { (p)->control_settings &= ~SC_STOPBITS_2; }

#define pSetOddParity(p) \
  { (p)->control_settings &= ~SC_PARITY_MASK; \
    (p)->control_settings |=  SC_PARITY_ODD; }

#define pSetEvenParity(p) \
  { (p)->control_settings &= ~SC_PARITY_MASK; \
    (p)->control_settings |=  SC_PARITY_EVEN; }

#define pDisParity(p) \
  { (p)->control_settings &= ~SC_PARITY_MASK; }

#define pSetData8(p) \
  { (p)->control_settings &= ~SC_DATABITS_7; }

#define pSetData7(p) \
  { (p)->control_settings |= SC_DATABITS_7; }

//--- action_reg macros
#define pModemReset(p) \
  { (p)->action_reg |= ACT_MODEM_RESET; }

#define pFlushInput(p) \
  { (p)->action_reg |= ACT_FLUSH_INPUT; }

#define pFlushOutput(p) \
  { (p)->action_reg |= ACT_FLUSH_OUTPUT; }

#define pOverrideClearXoff(p) \
  { (p)->action_reg |= ACT_CLEAR_TX_XOFF; }

#define pOverrideSetXoff(p) \
  { (p)->action_reg |= ACT_SET_TX_XOFF; }


//------- questionable stuff, untidy, thrown in to make compile
//Status
/* Open type and TX and RX identifier flags (unsigned int) */
#define COM_OPEN     0x0001            /* device open */
#define COM_TX       0x0002            /* transmit */
#define COM_RX       0x0004            /* receive */

//Status
/* Flow control flags (unsigned int) */
#define COM_FLOW_NONE  0x0000
#define COM_FLOW_IS    0x0008          /* input software flow control */
#define COM_FLOW_IH    0x0010          /* input hardware flow control */
#define COM_FLOW_OS    0x0020          /* output software flow control */
#define COM_FLOW_OH    0x0040          /* output hardware flow control */
#define COM_FLOW_OXANY 0x0080          /* restart output on any Rx char */
#define COM_RXFLOW_ON  0x0100          /* Rx data flow is ON */
#define COM_TXFLOW_ON  0x0200          /* Tx data flow is ON */

//Status ... State flags
#define COM_REQUEST_BREAK 0x0400

/* Modem control flags (unsigned char) */
#define COM_MDM_RTS   0x02             /* request to send */
#define COM_MDM_DTR   0x04             /* data terminal ready */
#define COM_MDM_CD    CD_ACT           /* carrier detect (0x08) */
#define COM_MDM_DSR   DSR_ACT          /* data set ready (0x10) */
#define COM_MDM_CTS   CTS_ACT          /* clear to send (0x20) */

/* Stop bit flags (unsigned char) */
#define COM_STOPBIT_1  0x01            /* 1 stop bit */
#define COM_STOPBIT_2  0x02            /* 2 stop bits */

/* Data bit flags (unsigned char) */
#define COM_DATABIT_7  0x01            /* 7 data bits */
#define COM_DATABIT_8  0x02            /* 8 data bits */

/* Parity flags (unsigned char) */
#define COM_PAR_NONE   0x00            /* no parity */
#define COM_PAR_EVEN   0x02            /* even parity */
#define COM_PAR_ODD    0x01            /* odd parity */

/* Detection enable flags (unsigned int) */
#define COM_DEN_NONE     0         /* no event detection enabled */
#define COM_DEN_MDM      0x0001    /* enable modem control change detection */
#define COM_DEN_RDA      0x0002    /* enable Rx data available detection */

/*---- 20-2FH Direct - Channel Status Reg. */
#define CTS_ACT   0x20        /* CTS input asserted */
#define DSR_ACT   0x10        /* DSR input asserted */
#define CD_ACT    0x08        /* CD input asserted */
#define TXFIFOMT  0x04        /* Tx FIFO is empty */
#define TXSHRMT   0x02        /* Tx shift register is empty */
#define RDA       0x01        /* Rx data available */
#define DRAINED (TXFIFOMT | TXSHRMT)  /* indicates Tx is drained */
#define STATMODE  0x8000      /* status mode enable bit */
#define RXFOVERFL 0x2000      /* receive FIFO overflow */
#define RX2MATCH  0x1000      /* receive compare byte 2 match */
#define RX1MATCH  0x0800      /* receive compare byte 1 match */
#define RXBREAK   0x0400      /* received BREAK */
#define RXFRAME   0x0200      /* received framing error */
#define RXPARITY  0x0100      /* received parity error */
#define STATERROR (RXBREAK | RXFRAME | RXPARITY)

/* channel data register stat mode status byte (high byte of word read) */
#define STMBREAK   0x08        /* BREAK */
#define STMFRAME   0x04        /* framing error */
#define STMRCVROVR 0x02        /* receiver over run error */
#define STMPARITY  0x01        /* parity error */
#define STMERROR   (STMBREAK | STMFRAME | STMPARITY)
#define STMBREAKH   0x800      /* BREAK */
#define STMFRAMEH   0x400      /* framing error */
#define STMRCVROVRH 0x200      /* receiver over run error */
#define STMPARITYH  0x100      /* parity error */
#define STMERRORH   (STMBREAKH | STMFRAMEH | STMPARITYH)

#define CTS_ACT   0x20        /* CTS input asserted */
#define DSR_ACT   0x10        /* DSR input asserted */
#define CD_ACT    0x08        /* CD input asserted */
#define TXFIFOMT  0x04        /* Tx FIFO is empty */
#define TXSHRMT   0x02        /* Tx shift register is empty */
#define RDA       0x01        /* Rx data available */
#define DRAINED (TXFIFOMT | TXSHRMT)  /* indicates Tx is drained */

/* interrupt ID register */
#define RXF_TRIG  0x20        /* Rx FIFO trigger level interrupt */
#define TXFIFO_MT 0x10        /* Tx FIFO empty interrupt */
#define SRC_INT   0x08        /* special receive condition interrupt */
#define DELTA_CD  0x04        /* CD change interrupt */
#define DELTA_CTS 0x02        /* CTS change interrupt */
#define DELTA_DSR 0x01        /* DSR change interrupt */
//------- END questionable stuff, untidy, thrown in to make compile


#define DEF_VS_PRESCALER 0x14 /* div 5 prescale, max 460800 baud(NO 50baud!) */
#define DEF_VS_CLOCKRATE 36864000

#define DEF_RHUB_PRESCALER  0x14
#define DEF_RHUB_CLOCKRATE 18432000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\port.c ===
/*--------------------------------------------------------------------------
| port.c - common port code
Change History:
4-27-98 - adjust for scanrate addition.
3-23-98 - add in broadcast for boxes if not found(had put in V1.12) but
  the changes did not make it into source-safe. kpb.
3-20-98 - Change scheme to track remote tx-buffer level, all changes
  ifdef'ed by NEW_Q in port.h, turned off for now. - kpb.
3-16-98 - VS recovery fix, reset flags in port_resync_all() to force update.
  If RAS lost box, it would continue to see active connections, then on
  recovery, DSR,CD,CTS input signals would not be updated immediately.
11-05-97 - Add Backup Server feature.  DCS
6-17-97 - start using index field assigned to box to id rx-messages.
6-17-97 - change link-integrity check code.
|--------------------------------------------------------------------------*/
#include "precomp.h"

int check_ack_code(PortMan *pm, BYTE *pkt);
int send_code(PortMan *pm);
int send_go(PortMan *pm);

int port_handle_outpkt(PortMan *pm, BYTE **buf, int *tx_used, int *port_set);
BYTE *port_setup_outpkt(PortMan *pm, int *tx_used);
void port_query_reply(PortMan *pm, BYTE *pkt);
void port_load_pkt(PortMan *pm, BYTE *pkt);
ULONG port_event_proc(PVOID context, int message_id, ULONG message_data);
int port_resync_all(PortMan *pm);
int port_connect_reply(Hdlc *hd);
int port_connect_ask(Hdlc *hd);
int port_packet(PortMan *pm, BYTE *buf);

#define DISABLE()
#define ENABLE()

#define TraceErr3(s, p1, p2, p3) GTrace3(D_Error, sz_modid, s, p1, p2, p3)
#define TraceErr2(s, p1, p2) GTrace2(D_Error, sz_modid, s, p1, p2)
#define TraceErr1(s, p1)     GTrace1(D_Error, sz_modid, s, p1)
#define Trace2(s, p1, p2) GTrace2(D_Port, sz_modid, s, p1, p2)
#define Trace1(s, p1)     GTrace1(D_Port, sz_modid, s, p1)
#define TraceStr(s) GTrace(D_Port, sz_modid, s)
#define TraceErr(s) GTrace(D_Error, sz_modid_err, s)
#define TraceAssert(l,s)
static char *sz_modid = {"Port"};
static char *sz_modid_err = {"Error,Port"};

// following for trace or dump messages, make public for other mods as well.
char *port_state_str[] = {"Init", "InitOwn", "SendCode", "Connect", "Active", "."};


#ifdef NEW_Q
/*--------------------------------------------------------------------------
  PortGetTxCntRemote -
|--------------------------------------------------------------------------*/
WORD PortGetTxCntRemote(SerPort *p)
{
  WORD Get, Put;

  Get = p->nGetRemote;
  Put = p->nPutRemote;

  if (Put >= Get)
    return (Put - Get);
  else
    return (Put + (~Get) + 1);
}
#endif

/*--------------------------------------------------------------------------
  PortFlushTx -
|--------------------------------------------------------------------------*/
void PortFlushTx(SerPort *p)
{
  if (!q_empty(&p->QOut))  // flush local side
  {
    q_put_flush(&p->QOut);
  }
  pFlushOutput(p);  // flush remote
}

/*--------------------------------------------------------------------------
  PortFlushRx -
|--------------------------------------------------------------------------*/
void PortFlushRx(SerPort *p)
{
  if (!q_empty(&p->QIn))  // flush local side
  {
#ifdef NEW_Q
    p->nGetLocal += q_count(&p->QIn);
#endif
    q_get_flush(&p->QIn);
    p->Status |= S_UPDATE_ROOM;
  }
  pFlushInput(p);  // flush remote
}

/*--------------------------------------------------------------------------
  port_resync_all - total-resync, this routine is called to reset port
   users, to inform them of a re-sync operation and adjust operation
  accordingly.
  If our case, since remote q is critical to maintain between both sides,
  we clear out all buffer data and start with all empty buffers.
|--------------------------------------------------------------------------*/
int port_resync_all(PortMan *pm)
{
  int i;
  SerPort *Port;

  TraceStr( "ReSync");

  for (i=0; i<pm->num_ports; i++)
  {
    Port = pm->sp[i];
    if (Port != NULL)
    {
      Port->QOut.QSize = OUT_BUF_SIZE;
      Port->QOut.QGet = 0;
      Port->QOut.QPut = 0;

#ifdef NEW_Q
      Port->nPutRemote = 0;
      Port->nGetRemote = 0;
      Port->nGetLocal = 0;
#else
      Port->QInRemote.QSize= OUT_BUF_SIZE;  // for now assume same sizes
      Port->QInRemote.QGet = 0;
      Port->QInRemote.QPut = 0;
#endif

      //Port->LanIndex = i;
      Port->QIn.QSize = IN_BUF_SIZE;
      Port->QIn.QGet = 0;
      Port->QIn.QPut = 0;

      Port->change_flags |= (CHG_BAUDRATE | CHG_SP_CHARS);
      Port->old_baudrate = 0;  // force baud rate update

      Port->old_control_settings = ~Port->control_settings;  // force update
      Port->old_mcr_value = ~Port->mcr_value;  // force update
      // reset this
      memset(&Port->last_sp_chars, 0, sizeof(Port->last_sp_chars));

      Port->msr_value = 0; // back to initial state.
    }
  }

  return 0;
}

/*--------------------------------------------------------------------------
  Callback routine that hdlc(l2) protocol calls on events.
   We are upper layer(3).
|--------------------------------------------------------------------------*/
ULONG port_event_proc(PVOID context, int message_id, ULONG message_data)
{
  TraceStr("L3Event");
  switch(message_id)
  {
    case EV_L2_CHECK_LINK: // hdlc wants us to check link
      TraceStr("Chk Link");
      // request that the portman do a link message check
      ((PortMan *) context)->Status |= S_CHECK_LINK;
    break;

    case EV_L2_ADMIN_REPLY: // got a query-id reply ADMIN packet
      TraceStr("ID PKT");
      port_query_reply((PortMan *) context, (BYTE *) message_data);
    break;

    case EV_L2_BOOT_REPLY:  // got a boot loader ADMIN packet
      TraceStr("LOAD PKT");
      port_load_pkt((PortMan *) context, (BYTE *) message_data);
    break;

    case EV_L2_RESYNC:
      // this happens on RK_CONNECT reply
      port_resync_all((PortMan *) context);
    break;

    case EV_L2_RELOAD:
      // this only happens when alive timer times out,
      // (hdlc-level detects a bad connection),
      // so lets assume box needs to be brought up from ground zero.
      port_resync_all((PortMan *) context);
      ((PortMan *) context)->state = ST_INIT;
      ((PortMan *) context)->load_timer = 0;
      ++((PortMan *) context)->reload_errors;
      TraceErr("Reload device");
    break;

    case EV_L2_RX_PACKET:
      port_packet((PortMan *) context, ((BYTE *) message_data) );
    break;
  }
  return 0;
}

/*--------------------------------------------------------------------------
 port_set_new_mac_addr - 
|--------------------------------------------------------------------------*/
int port_set_new_mac_addr(PortMan *pm, BYTE *box_addr)
{
//  Hdlc *hd;
//  int i;

  // copy over the new mac-address
  memcpy(pm->hd->dest_addr, box_addr, 6);

  // force a complete update of the box
  pm->reload_errors = 0;
  pm->state = 0;
  pm->Status |= S_NEED_CODE_UPDATE;
  pm->Status |= S_SERVER; // yes we are server(not box)

  port_resync_all(pm);
  return 0;
}

/*--------------------------------------------------------------------------
 portman_init - init the Box(PortMAn) struct, and the associated hdlc hd object.
   At this point the Nic object is already open.
|--------------------------------------------------------------------------*/
int portman_init(Hdlc *hd,
                 PortMan *pm,
                 int num_ports,
                 int unique_id,
                 int backup_server, 
                 int backup_timer,
                 BYTE *box_addr)
{
  int i, stat;

  MyKdPrint(D_Init, ("portman_init\n"))

  TraceStr( "PortInit");
  stat = 0;

  // allocate serial-port structures.
  for (i=0; i<num_ports; i++)
  {
    if (pm->sp[i] == NULL)
    {
      pm->sp[i] = (SerPort *)our_locked_alloc(sizeof(SerPort), "Dsp");
      port_init(pm->sp[i]);  // let port create and init some stuff
    }
  }
  pm->num_ports = num_ports;
  pm->backup_server = backup_server;
  pm->backup_timer = backup_timer;
  pm->unique_id = unique_id;
  pm->load_timer = 0;

  // default to the first nic card slot, port state handling and nic
  // packet reception handling dynamically figures this out.
  // we should probably set it to null, but I'm afraid of this right now
#ifdef BREAK_NIC_STUFF
  pm->nic =NULL;
#else
  pm->nic = &Driver.nics[0];
#endif
  pm->nic_index = 0;

  pm->hd = hd;
  pm->reload_errors = 0;
  pm->state = 0;
  pm->state_timer = 0;
  pm->Status |= S_NEED_CODE_UPDATE;
  pm->Status |= S_SERVER; // yes we are server(not box)

  pm->hd = hd;
  stat = hdlc_open(pm->hd, box_addr);
  hd->context = pm;  // put our handle here, so hdlc sends this along
                     // with any upper_layer messages

  if (stat)
  {
    if (Driver.VerboseLog)
      Eprintf("Hdlc open fail:%d",stat);

    TraceStr("Err-Hdlc Open!");
    return 3;
  }

  // set HDLC's callback RX-proc to point to our routine
  hd->upper_layer_proc = port_event_proc;

  port_resync_all(pm);

  return 0;
}

/*--------------------------------------------------------------------------
 portman_close - close down the port manager.
|--------------------------------------------------------------------------*/
int portman_close(PortMan *pm)
{
  int i;

  pm->state = 0;

  // deallocate any Port things
  for (i=0; i<pm->num_ports; i++)
  {
    if (pm->sp[i] != NULL)
    {
      port_close(pm->sp[i]);
      our_free(pm->sp[i], "Dsp");
      pm->sp[i] = NULL;
    }
  }
  return 0;
}

/*--------------------------------------------------------------------------
 port_init - init a SerPort thing.
|--------------------------------------------------------------------------*/
int port_init(SerPort *sp)
{
  TraceStr("SPort_Init");

  if (sp->QOut.QBase == NULL)
  {
    sp->QOut.QBase =  our_locked_alloc(OUT_BUF_SIZE+2,"pmQO");
    if (sp->QOut.QBase == NULL)
    {
      return 1;
    }
  }

  if (sp->QIn.QBase == NULL)
  {
    sp->QIn.QBase = our_locked_alloc(IN_BUF_SIZE+2, "pmQI");
    if (sp->QIn.QBase == NULL)
    {
      return 2;
    }
  }

  sp->Status |= S_OPENED;
  sp->mcr_value = 0;
  //sp->mcr_value = MCR_RTS_SET_ON | MCR_DTR_SET_ON;
  sp->old_mcr_value = sp->mcr_value;

  sp->sp_chars.tx_xon = 0x11;
  sp->sp_chars.tx_xoff = 0x13;
  sp->sp_chars.rx_xon = 0x11;
  sp->sp_chars.rx_xoff = 0x13;
  sp->last_sp_chars = sp->sp_chars;  // copy struct to old
  sp->change_flags = 0;
}

/*--------------------------------------------------------------------------
  port_close -
|--------------------------------------------------------------------------*/
int port_close(SerPort *sp)
{
  int i;

  if (sp == NULL)
    return 0;

  if (sp->QIn.QBase != NULL)
  {
    our_free(sp->QIn.QBase,"pmQI");
    sp->QIn.QBase = NULL;
  }

  if (sp->QOut.QBase != NULL)
  {
    our_free(sp->QOut.QBase,"pmQO");
    sp->QOut.QBase = NULL;
  }

  return 0;
}

/*--------------------------------------------------------------------------
  port_packet - got an incoming packet, do something with it.
|--------------------------------------------------------------------------*/
int port_packet(PortMan *pm, BYTE *buf)
{
  SerPort *Port;
  int port_num;
  int done, len;
  int QInRoom;

  TraceStr( "GotPkt");

  Port = pm->sp[0];  // default to point to first port

  //----- process all the sub-packets in the lan-packet, process
  // until we hit a zero header field, or some header we don't know
  // about(default: case).
  done = 0;
  if (*(buf) == 0)
  {
    // bugbug: this is a problem, we get a bunch of these during
    // normal operation, for now just show in debug version, as
    // they are a nuciance in peer error tracing.
#if DBG
    TraceErr("Empty pkt!");
#endif
  }
  while (!done)
  {
    switch(*buf++)
    {
      case RK_CONNECT_CHECK:  // check link
        TraceStr( "Rk_Conn_Chk_reply");
       
        // do nothing on the server, on box send back a iframe reply
      break;

      case RK_CONNECT_REPLY:  // reply from our request to bring up connection
        TraceStr( "Rk_reply");
        if (pm->Status & S_SERVER)
        {
          if (pm->state == ST_CONNECT) // should happen at this time
          {
            pm->state = ST_ACTIVE;  // fire up a connection
          }
          else  // got it when not expecting it.
          {
            TraceStr("Err-Recover!");
            // client recovering, need resyc.
            port_resync_all(pm);
          }
        }
      break;

      case RK_CONNECT_ASK:  // packet from server
        TraceStr( "Rk_Ask");
        // should not see this on server
      break;

      case RK_PORT_SET:    // set the port num to work with
        TraceStr( "Rk_Port");
        if (*buf >= pm->num_ports)
        {
          TraceErr( "PortI!");
          port_num = *buf++;
          break;
        }
        port_num = *buf++;
        Port = pm->sp[port_num];
      break;

#ifdef COMMENT_OUT   // not on server
      case RK_BAUD_SET:  // set the baud rate
        Port->baudrate = *((DWORD *)(buf));  // Remotes QIn.QGet value
        buf += 4;
        //sSetBaudRate(ChP, Port->baudrate, 1);
      break;

      case RK_CONTROL_SET:  // set the baud rate
        w1 = *((WORD *)(buf));  // control settings
        buf += 2;
        control_set(port_num, w1);
      break;

      case RK_MCR_SET:  // modem control reg pkt
        w1 = *((WORD *)(buf));  // control settings
        buf += 2;
        mcr_set(port_num, w1);
      break;
#endif

      case RK_MSR_SET:  // modem status reg pkt
        Port->msr_value = *((WORD *)(buf));
        Trace1("Rk_MSR:%xH", Port->msr_value);
        buf += 2;
      break;

      case RK_ACTION_ACK:  // modem status reg pkt
        // NT does not use this one, novell driver does to 
        // help dump all data in transit during a flush.
        //Port->action_resp = *((WORD *)(buf));
        Trace1("Rk_Act_Ack:%xH", *((WORD *)(buf)));
        buf += 2;
      break;

      case RK_ESR_SET:  // error status reg pkt
        Port->esr_reg = *((WORD *)(buf));
        Trace1("Rk_ESR:%xH", Port->esr_reg);
        buf += 2;
      break;

      case RK_QIN_STATUS:  // qin status report
        TraceStr( "Rk_QStat");
#ifdef NEW_Q
        Port->nGetRemote = *((WORD *)(buf));  // track remote output buffer space
#else
        Port->QInRemote.QGet = *((short *)(buf));  // Remotes QIn.QGet value
#endif
        buf += 2;
      break;

      case RK_DATA_BLK:    // data block to put in buffer queue
        TraceStr( "Rk_Data");
#ifdef NEW_Q
        //old(does not belong here!):Port->Status |= S_UPDATE_ROOM;
#else
        Port->Status |= S_UPDATE_ROOM;
#endif
        len = *((WORD *)(buf));
        buf += 2;

        QInRoom  = q_room(&Port->QIn);
        TraceAssert((QInRoom < Port->QIn.QSize), "Err1B!!!");
        TraceAssert((QInRoom >= 0), "Err1B!!!");
        if (len > QInRoom)  // Overflow
        {
          TraceErr("Err-Port Overflow!");
          len = 0;
        }
        q_put(&Port->QIn, buf, len);
        buf += len;
      break;

      default:
        done = 1;
        if (*(buf-1) != 0)
        {
          TraceErr("Bad Sub pkt hdr!");
          GTrace1(D_Error,sz_modid," HDR:%xH",*(buf-1));
        }
      break;
    }  // case per sub-packet
  }  // while not done with sub-packets
  return 0;
}

/*--------------------------------------------------------------------------
  port_poll - check to see if we need to send any packets over.  If we have
    new data in or need to send status packets over.
|--------------------------------------------------------------------------*/
int port_poll(PortMan *pm)
{
#define MAX_TX_SPACE 1460
  int i, tx_used;
  SerPort *Port;
  unsigned char *buf;
  int ToMove, ThisMove;
  int QOutCount;
  int QLanRoom;
#ifdef NEW_Q
  WORD tmp_word;
#endif
  int port_set;  // flag it as not setup.


// this logic is in isr.c service routine now
//  if (pm->state != ST_ACTIVE)
//  {
//    port_state_handler(pm);
//    return 0;
//  }

  tx_used = MAX_TX_SPACE+1000;  // indicate no pkt allocated
#if DBG
  if (pm == NULL)
  {
    MyKdPrint(D_Error, ("!!!!!pm null\n"))
    return 0;
  }
#endif

  // handle box things, send out a query to check-connection if
  // hdlc saw inactivity.
  if (pm->Status & S_CHECK_LINK)
  {
    if (tx_used > (MAX_TX_SPACE-50))  // if our tx-pkt is near full or null
    {
       buf = port_setup_outpkt(pm, &tx_used);
       if (buf == NULL)
         return 0;  // no more output packet space available, so all done
       buf[tx_used++] = RK_CONNECT_CHECK;
       // at this point we queued our iframe to query other side(to ensure
       // link-integrity.
       pm->Status &= ~S_CHECK_LINK;  // reset our request to send this
       TraceStr("Check sent");
    }
  }

  for (i=0; i<pm->num_ports; i++)
  {
    Port = pm->sp[pm->last_round_robin];

    //----- see if flag set to tell other side how much room in Port Rx buf
    if (Port->Status & S_UPDATE_ROOM)
    {
      TraceStr("Update needed");
      if (tx_used > (MAX_TX_SPACE-50))  // if our tx-pkt is near full or null
      {
         buf = port_setup_outpkt(pm, &tx_used);
         if (buf == NULL)
           return 0;  // no more output packet space available, so all done
         port_set = 0xff;  // flag it as not setup.
      }
      if (port_set != pm->last_round_robin)   // our port index not setup
      {
        buf[tx_used++] = RK_PORT_SET;
        buf[tx_used++] = (BYTE) pm->last_round_robin;
        port_set = pm->last_round_robin;
      }

      // take away status reminder flag
      Port->Status &= ~S_UPDATE_ROOM;

               // form the sub-packet in our output packet buffer
      buf[tx_used++] = RK_QIN_STATUS;
               // report our actual QGet index to other side.
#ifdef NEW_Q
      *((WORD *)(&buf[tx_used])) = Port->nGetLocal;
#else
      *((short *)(&buf[tx_used])) = Port->QIn.QGet;
#endif
      tx_used += 2;
    }

    //----- do action items
    if (Port->action_reg != 0)
    {
      if (port_handle_outpkt(pm, &buf, &tx_used, &port_set) != 0) // no pkt space avail
         return 0;  // no more output packet space available, so all done

      TraceStr("act pkt");
      buf[tx_used++] = RK_ACTION_SET;
      *((WORD *)(&buf[tx_used])) = Port->action_reg;
      Port->action_reg = 0; // its a one-shot deal, so we reset this now
      tx_used += 2;
    }

    //----- do updates for control settings, mcr, etc
    if (Port->old_control_settings != Port->control_settings)
    {
      if (port_handle_outpkt(pm, &buf, &tx_used, &port_set) != 0) // no pkt space avail
         return 0;  // no more output packet space available, so all done

      Port->old_control_settings = Port->control_settings;
      TraceStr("ctr chg");
      buf[tx_used++] = RK_CONTROL_SET;
      *((WORD *)(&buf[tx_used])) = Port->control_settings;
      tx_used += 2;
    }

    //----- do updates for mcr
    if (Port->old_mcr_value != Port->mcr_value)
    {
      if (port_handle_outpkt(pm, &buf, &tx_used, &port_set) != 0) // no pkt space avail
         return 0;  // no more output packet space available, so all done

      TraceStr("mcr chg");
      Port->old_mcr_value = Port->mcr_value;
      buf[tx_used++] = RK_MCR_SET;
      *((WORD *)(&buf[tx_used])) = Port->mcr_value;
      tx_used += 2;
    }

    //----- do updates for special chars, etc
    if (Port->change_flags)
    {
      if (Port->change_flags & CHG_BAUDRATE)
      {
        //----- do updates for baud rate settings
        if (Port->old_baudrate != Port->baudrate)
        {
          if (port_handle_outpkt(pm, &buf, &tx_used, &port_set) != 0) // no pkt space avail
            return 0;  // no more output packet space available, so all done

          Port->old_baudrate = Port->baudrate;
          Trace1("baud:%lu", Port->baudrate);
          buf[tx_used++] = RK_BAUD_SET;
          *((DWORD *)(&buf[tx_used])) = Port->baudrate;
          tx_used += 4;
        }
      }

      if (Port->change_flags & CHG_SP_CHARS)
      {
        if (memcmp(&Port->last_sp_chars, &Port->sp_chars, 6) != 0)  // compare structs for chg
        {
          Port->last_sp_chars = Port->sp_chars;  // remember last set values
          if (port_handle_outpkt(pm, &buf, &tx_used, &port_set) != 0) // no pkt space avail
             return 0;  // no more output packet space available, so all done

          TraceStr("sp_chars");
          buf[tx_used++] = RK_SPECIAL_CHAR_SET;

          Trace1(" rx_xon:%x", Port->sp_chars.rx_xon);
          Trace1(" rx_xoff:%x", Port->sp_chars.rx_xoff);
          Trace1(" tx_xon:%x", Port->sp_chars.tx_xon);
          Trace1(" tx_xoff:%x", Port->sp_chars.tx_xoff);
          Trace1(" error:%x", Port->sp_chars.error);
          Trace1(" event:%x", Port->sp_chars.event);

          buf[tx_used++] = Port->sp_chars.rx_xon;
          buf[tx_used++] = Port->sp_chars.rx_xoff;
          buf[tx_used++] = Port->sp_chars.tx_xon;
          buf[tx_used++] = Port->sp_chars.tx_xoff;
          buf[tx_used++] = Port->sp_chars.error;
          buf[tx_used++] = Port->sp_chars.event;
        }
      }
      Port->change_flags = 0;  // reset all
    }

    //----- send any outgoing data if other side has room.
    QOutCount = q_count(&Port->QOut);
#ifdef NEW_Q
    // calculate our remote tx-buffer space based on WORD modulo arithmetic
    tmp_word = PortGetTxCntRemote(Port);

    // right now this var is equal to how much tx-data is in remote buffer.
    if (tmp_word < REMOTE_IN_BUF_SIZE)
         QLanRoom = REMOTE_IN_BUF_SIZE - tmp_word;
    else QLanRoom = 0;
    // now it is how much room we have in the remote tx-buffer.
#else
    QLanRoom  = q_room(&Port->QInRemote);  // other sides port queue room
#endif
    if ((QOutCount > 0) && (QLanRoom > 50))  // have data, other side has room
    {
      TraceStr("Data to Send");
      if (QOutCount > QLanRoom)  // more data than room
           ToMove = QLanRoom;       // limit
      else ToMove = QOutCount;

      do
      {
        if (tx_used > (MAX_TX_SPACE-50))  // if our tx-pkt is near full or null
        {
           buf = port_setup_outpkt(pm, &tx_used);  // allocate a new one
           if (buf == NULL)
             return 0;  // no more output packet space available, so all done
           port_set = 0xff;  // flag it as not setup.
        }
        if (port_set != pm->last_round_robin)   // our port index not setup
        {
          buf[tx_used++] = RK_PORT_SET;
          buf[tx_used++] = (BYTE) pm->last_round_robin;
          port_set = pm->last_round_robin;
        }

        // make sure we have emough room for data, limit if we don't
        if (ToMove > ((MAX_TX_SPACE-1) - tx_used) )
        {
          ThisMove = (MAX_TX_SPACE-1) - tx_used;
          ToMove -= ThisMove;
        }
        else
        {
          ThisMove = ToMove;
          ToMove = 0;
        }
        buf[tx_used++] = RK_DATA_BLK;           // set header sub-type
        *((WORD *)(&buf[tx_used])) = ThisMove;   // set header data size
        tx_used += 2;
        q_get(&Port->QOut, &buf[tx_used], ThisMove);
        tx_used += ThisMove;

        // keep our own copy of remote qin indexes
#ifdef NEW_Q
        // bump our tx-buffer count based on WORD modulo arithmetic
        Port->nPutRemote += ((WORD)ThisMove);
#else
        q_putted(&Port->QInRemote, ((short)ThisMove));
#endif
      } while (ToMove > 0);  // keep using packets if more to send
    }  // if data sent

    ++pm->last_round_robin;
    if (pm->last_round_robin >= pm->num_ports)
      pm->last_round_robin = 0;
  }


  if (tx_used < (MAX_TX_SPACE+1000))  // then we allocated a packet prior
  {                              // and need to send it
    if (hdlc_send_outpkt(pm->hd, tx_used, pm->hd->dest_addr)) // send it out!
    {
      TraceErr("Err-hdlc_send1");
    }
  }

  //TraceStr( "EndPoll");

  return 0;
}

/*--------------------------------------------------------------------------
 port_state_handler - handle states other than normal data flowage.
   Called at scanrate(1-20ms) times per second from service routine.
|--------------------------------------------------------------------------*/
void port_state_handler(PortMan *pm)
{
  int inic;

  if (pm->old_state != pm->state)
  {
    pm->old_state = pm->state;
    pm->state_timer = 0;
  }

  pm->timer_base += ((WORD) Driver.Tick100usBase);  // 100us base units(typical:100)
  if (pm->timer_base < 98)  // less than 9.8ms
  {
    // we want to run roughly 100 ticks per second
    return;
  }
  pm->timer_base = 0;

  switch(pm->state)
  {
    case ST_INIT:
      // if we are server, then wait for query back.

//pm->state_timer = 0;
//break;

      if (pm->Status & S_SERVER)
      {
        if (pm->state_timer == 600) // 6 seconds
        {
          pm->ownership_timer = 0;
          TraceStr( "Send Query");
          // find box out on network, use ADMIN pkt
          // do the query on all nic-segments
          for (inic=0; inic<VS1000_MAX_NICS; inic++)
          {
            if (Driver.nics[inic].Open)  // if nic-card open for use
            {
              // send a passive query(don't try to assume ownership
              if (admin_send_query_id(&Driver.nics[inic], pm->hd->dest_addr,
                                      0, 0) != 0)
              {
                TraceErr( "Err1E");
              }
            }
          }
        }
        else if (pm->state_timer == 1800) // 18 seconds
        {
          // try a broadcast to cut through switches.
          TraceStr( "Send Br.Query");
          // find box out on network, use ADMIN pkt
          // do the query on all nic-segments
          for (inic=0; inic<VS1000_MAX_NICS; inic++)
          {
            if (Driver.nics[inic].Open)  // if nic-card open for use
            {
              // send a passive query(don't try to assume ownership
              if (admin_send_query_id(&Driver.nics[inic], broadcast_addr,
                                      0, 0) != 0)
              {
                TraceErr( "Err1E");
              }
            }
          }
        }
        else if (pm->state_timer > 2400)  // 24 sec, give up start over
          pm->state_timer = 0;
      }
    break;

    case ST_GET_OWNERSHIP:
      // if we are server, then wait for query back.
      if (pm->Status & S_SERVER)
      {
        // Increment when in ST_GET_OWNERSHIP state for backup server.
        ++pm->load_timer;
        if (pm->state_timer == 10) // 100ms
        {
          TraceStr( "Send Query Owner");
          // find box out on network, use ADMIN pkt
          // do the query on all nic-segments
          for (inic=0; inic<VS1000_MAX_NICS; inic++)
          {
            if (Driver.nics[inic].Open)  // if nic-card open for use
            {
              // BUGFIX(8-26-98), this was only sending it out on
              // the nic card assigned to pm.
              //)if (admin_send_query_id(pm->nic, pm->hd->dest_addr,
              if (admin_send_query_id(&Driver.nics[inic], pm->hd->dest_addr,
                                      1, (BYTE) pm->unique_id) != 0)
              {
                TraceErr( "Err1G");
              }
            }
          }
        }
        else if (pm->state_timer > 600) // 6 seconds
        {
          // SAFE GUARD ADDED DUE to SCREWED UP OWNERSHIP STATE MACHINE
          // kpb, 8-25-98, make sure we don't spend forever in this state.
          pm->ownership_timer += 6;
          if (pm->ownership_timer > (60 * 15))  // 15 minutes
          {
            pm->state = ST_INIT;
            pm->load_timer = 0;
          }
          pm->state_timer = 0;
        }
        // 8-26-98
        // NOTICE, we are not reseting state to INIT after a while,
        // this is a problem!
      }
    break;

    case ST_SENDCODE:  // download main driver code to box
      if (pm->state_timer == 0)
      {
        ++pm->total_loads;
        pm->code_cnt = 0;  // start upload
        send_code(pm);
      }
      else if (pm->state_timer == 1000)  // 10 seconds since init
      {
        TraceErr("Upload Retry");
        ++pm->total_loads;
        pm->code_cnt = 0;  // start upload
        send_code(pm);
      }
      else if (pm->state_timer == 2000)  // 20 seconds since init
      {
        TraceErr("Upload Retry");
        ++pm->total_loads;
        pm->code_cnt = 0;  // start upload
        send_code(pm);
      }
      else if (pm->state_timer == 3000)   // fail it out, start over with init
      {
        TraceErr("Upload Fail");
        pm->state = ST_INIT;
        pm->load_timer = 0;
      }
      else if (pm->code_state == 1)  // signal port poll code to send next chunk
      {
        TraceStr("Upload, next chk.");
        if (pm->code_cnt < Driver.MicroCodeSize)
        {
          if (send_code(pm) == 0)  // success
            pm->code_state = 0;
        }
        else  // all done
        {
          TraceStr("Code Upload Done.");
          if (send_go(pm) == 0)
          {
            ++pm->good_loads;
            pm->code_cnt = 0;
            pm->state = ST_GET_OWNERSHIP;
          }
        }
      }
    break;

    case ST_CONNECT:
      if (pm->state_timer == 0)
         port_connect_ask(pm->hd);
      else if (pm->state_timer == 1000)  // 10 seconds
         port_connect_ask(pm->hd);
      else if (pm->state_timer == 2000)  // 20 seconds
      {
        pm->state = ST_INIT;  // fall back
        pm->load_timer = 0;
      }
    break;

    default:
      TraceErr("Err-PState!");
      pm->state = ST_INIT;
      pm->load_timer = 0;
    break;
  }
  ++pm->state_timer;
}

/*--------------------------------------------------------------------------
 port_handle_outpkt - check if we have at least 50 bytes in outpkt, if
  not get a new one.  If no new one avail, return non-zero.
|--------------------------------------------------------------------------*/
int port_handle_outpkt(PortMan *pm, BYTE **buf, int *tx_used, int *port_set)
{
  if (*tx_used > (MAX_TX_SPACE-50))  // if our tx-pkt is near full or null
  {
     *buf = port_setup_outpkt(pm, tx_used);
     if (*buf == NULL)
       return 1;  // no more output packet space available, so all done
     *port_set = 0xff;
  }
  if (*port_set != pm->last_round_robin)
  {
    // since we have a new pkt, we need to
    (*buf)[(*tx_used)++] = RK_PORT_SET;
    (*buf)[(*tx_used)++] = (BYTE) pm->last_round_robin;
    *port_set = pm->last_round_robin;
  }
  return 0;  // current pkt has plenty of room(at least 50 bytes)
}

/*--------------------------------------------------------------------------
 port_setup_outpkt - setup an outgoing packet if one is available, if previously
   filled one out then we ship it off out the nic card.
|--------------------------------------------------------------------------*/
BYTE *port_setup_outpkt(PortMan *pm, int *tx_used)
{
  BYTE *buf;

  if (*tx_used != (MAX_TX_SPACE+1000))  // then we allocated a packet prior
  {                              // and need to send it
    if (hdlc_send_outpkt(pm->hd, *tx_used, pm->hd->dest_addr)) // send it out!
    {
      TraceErr("send err");
    }
  }
  if (hdlc_get_outpkt(pm->hd, &buf) == 0)  // no error, got a output packet
  {
    TraceStr("NPkt2");
    *tx_used = 0;  // have a new empty output packet allocated
    return buf;  // all done
  }
  else
  {
    TraceStr("NPktDone2");
    *tx_used = MAX_TX_SPACE+1000;  // indicate no pkt allocated
    return NULL;  // all done
  }
}

/*--------------------------------------------------------------------------
port_load_pkt - got a admin boot load packet: ACK back from code download pkt.
|--------------------------------------------------------------------------*/
void port_load_pkt(PortMan *pm, BYTE *pkt)
{
  if (pm->state != ST_SENDCODE)  // not expected at this time, lets reset it.
  {
    TraceErr("BootLoad not at SENDCODE!");
    Tprintf("state=%d", pm->state);
    // other details????
    pm->state = ST_INIT;
    pm->load_timer = 0;
    //pm->hd->state = ST_HDLC_INIT;
    return;
  }

  if (Driver.MicroCodeSize == 0)
  {
    TraceErr("Bad MC");
    return;
  }

  if (check_ack_code(pm,pkt) != 0)
  {
    TraceErr("Bad Ack");
    return;
  }
  TraceStr("Good Ack!");

  // send more data
  if (pm->code_cnt < Driver.MicroCodeSize)
    pm->code_cnt += 1000;
  pm->code_state = 1;  // signal port poll code to send next chunk
}

#if NEW_QUERY_HANDLER
/*--------------------------------------------------------------------------
port_query_reply - got a ADMIN query reply back, server sends out
  query-id request on init and when setup is entered, box sends back 
  id(which tells us if code is loaded.)   A query reply is ignored in
  states other that ST_INIT and ST_GET_OWNERSHIP
|--------------------------------------------------------------------------*/
void port_query_reply(PortMan *pm, BYTE *pkt)
{
  int unit_available  = 0;
  int unit_needs_code = 0;
  int unit_needs_reset = 0;

  if (!mac_match(pkt, pm->hd->dest_addr))
  {
    TraceErr("Reply MAC bad!");
    return;
  }

  // ignore if not ST_INIT or ST_GET_OWNERSHIP
  if ((pm->state != ST_INIT) && (pm->state != ST_GET_OWNERSHIP)) 
  {
    return;
  }

  if (pkt[7] >= VS1000_MAX_NICS)  // if invalid nic-index
  {
    TraceErr("Nic Index Reply!");
    return;
  }

  // when we get the query packet, we stash the nic-card index
  // into part of the receive buffer that is unused(pkt[7]).
  // see if this matches what our port-manager nic_index is,
  // if not, then we switched nic cards and need to update some
  // things.
  if (pm->nic_index != (int)(pkt[7]))  // changed nic cards
  {
    TraceErr("Nic Changed!");
    pm->nic_index = (int)(pkt[7]);   // set nic_index
    pm->nic = &Driver.nics[pm->nic_index];  // changed nic cards
    pm->hd->nic = pm->nic;  // update the hdlc nic ptr
  }
#define Q_DRIVER_RUNNING 1
#define Q_NOT_OWNER      2
#define Q_ABANDONED      4

  // we are NOT owner(2H), and main app-driver running(1H), be careful
  if ((pkt[6] & Q_DRIVER_RUNNING) && (pkt[6] & Q_NOT_OWNER))
  {
    // if not owner timeout, (4H=ABANDONED) then leave alone!
    // some other server is actively using it.
    if ((pkt[6] & Q_ABANDONED) == 0) 
    {
      Trace1("ReplyID, Not Ours. [%x]", pkt[6]);
        pm->load_timer = 0;
      pm->state = ST_INIT;
      pm->load_timer = 0;
      return;
    }
    // else its abandoned, so we can take ownership.
    unit_available  = 1;
    unit_needs_reset = 1;
  }
  else
  {
    // we are owner or main-driver not running yet
    unit_available  = 1;
  }
  if ((pkt[6] & Q_DRIVER_RUNNING) == 0)
  {
    unit_needs_code = 1;
  }

  if (pm->Status & S_NEED_CODE_UPDATE)
  {
    unit_needs_reset = 1;
    unit_needs_code  = 1;
  }

  // ok to take ownership(no owner)
  TraceStr("ReplyID, Unit Available");
  if (pm->state == ST_INIT)
  {
    if ((pm->backup_server == 0) ||
        (pm->load_timer >= (pm->backup_timer*6000)) )
    {
      if (pm->backup_server == 0)
        { TraceStr("Pri. make owner"); }
      else
        { TraceStr("2nd. make owner"); }
      pm->state = ST_GET_OWNERSHIP;
      // this will cause the state machine to issue a query trying to
      // obtain ownership
      unit_needs_reset = 1;
    }
    else
    {
      if (pm->load_timer >= (pm->backup_timer*6000))
      {
        TraceStr("2nd, make owner");
        pm->state = ST_GET_OWNERSHIP;
        // this will cause the state machine to issue a query trying to
        // obtain ownership
      }
    }
  }
  else if (pm->state == ST_GET_OWNERSHIP)
  {
    TraceStr("ReplyID in GET_OWNERSHIP");

      // Is this the primary server or has the backup timer expired?
    if ((pm->backup_server == 0) && (pm->load_timer >= (pm->backup_timer*6000))
    {  
      // we are NOT owner(2H), and main app-driver running(1H), be careful
      if ((pkt[6] & 3) == 3)
      {
        if (pkt[6] & 4)  // Owner has timed out - force reload
        {
          // force a reset of box on driver-load(this bit is set in 
          // port_init) so we load up some fresh microcode.
          admin_send_reset(pm->nic, pm->hd->dest_addr);
          TraceStr("Abandoned, ReSet");
        }
      }
      else if ((pkt[6] & 1) == 0) // code is not downloaded, so download it.
      {
        // Make sure that we are the owner?
        if (pkt[6] & 2)  // 2h=not owner bit
        {
          TraceStr("GET_OWNERSHIP: No App - Not Owner!");
          pm->state = ST_INIT;
          pm->load_timer = 0;
          return;
        }
        TraceStr("GET_OWNERSHIP: Download");
        pm->Status &= ~S_NEED_CODE_UPDATE;
        pm->state = ST_SENDCODE;
      }
      else  // code is downloaded - we are the owner
      {  
        if (pm->Status & S_NEED_CODE_UPDATE)
        {
          // force a reset of box on driver-load(this bit is set in 
          // port_init) and set S_NEED_CODE_UPDATE so we load up some 
          // fresh microcode.
          admin_send_reset(pm->nic, pm->hd->dest_addr);
          TraceStr("ReplyID, ReLoad");
          pm->Status &= ~S_NEED_CODE_UPDATE;
        }
        else
        {
          TraceStr("ReplyID, GoToConnect");
          port_resync_all(pm);
          //pm->state = ST_ACTIVE;
          pm->state = ST_CONNECT;
        }
      }
    }
  }
}
#else

/*--------------------------------------------------------------------------
port_query_reply - got a ADMIN query reply back, server sends out
  query-id request on init and when setup is entered, box sends back 
  id(which tells us if code is loaded.)   A query reply is ignored in
  states other that ST_INIT and ST_GET_OWNERSHIP
|--------------------------------------------------------------------------*/
void port_query_reply(PortMan *pm, BYTE *pkt)
{
  if (!mac_match(pkt, pm->hd->dest_addr))
  {
    TraceErr("Reply MAC bad!");
    return;
  }

  // ignore if not ST_INIT or ST_GET_OWNERSHIP
  if ((pm->state != ST_INIT) && (pm->state != ST_GET_OWNERSHIP)) 
  {
    return;
  }

  if (pkt[7] >= VS1000_MAX_NICS)  // if invalid nic-index
  {
    TraceErr("Nic Index Reply!");
    return;
  }

  // when we get the query packet, we stash the nic-card index
  // into part of the receive buffer that is unused(pkt[7]).
  // see if this matches what our port-manager nic_index is,
  // if not, then we switched nic cards and need to update some
  // things.
  if (pm->nic_index != (int)(pkt[7]))  // changed nic cards
  {
    TraceErr("Nic Changed!");
    pm->nic_index = (int)(pkt[7]);   // set nic_index
    pm->nic = &Driver.nics[pm->nic_index];  // changed nic cards
    pm->hd->nic = pm->nic;  // update the hdlc nic ptr
  }

  // we are NOT owner(2H), and main app-driver running(1H), be careful
  if ((pkt[6] & 3) == 3)
  {
    // if not owner timeout, (4H=ABANDONED) then leave alone!
    // some other server is actively using it.
    if ((pkt[6] & 4) == 0) 
    {
     Trace1("ReplyID, Not Ours. [%x]", pkt[6]);
        pm->load_timer = 0;
     pm->state = ST_INIT;
      return;
    }
  }

  if (pm->state == ST_INIT)
  {  
   // ok to take ownership(no owner)
   pm->state = ST_GET_OWNERSHIP;
   if(pm->backup_server == 0)
   {
     Trace1("ReplyID, Primary Server - Unit Available [%x]", pkt[6]);
   }
   else
   {
     Trace1("ReplyID, Backup Server - Unit Available [%x]", pkt[6]);
   }
  }
  else if (pm->state == ST_GET_OWNERSHIP)
  {
   Trace1("ReplyID, GET_OWNERSHIP [%x]", pkt[6]);
    // Is this the primary server or has the backup timer expired?
    if((pm->backup_server == 0) || 
     (pm->load_timer >= (pm->backup_timer*6000)))
   {
     // we are NOT owner(2H), and main app-driver running(1H), be careful
     if ((pkt[6] & 3) == 3)
     {
       if (pkt[6] & 4)  // Owner has timed out - force reload
     {
       // force a reset of box on driver-load(this bit is set in
       // port_init) so we load up some fresh microcode.
       admin_send_reset(pm->nic, pm->hd->dest_addr);
       TraceStr("ReplyID, ReLoad");
     }
     else
     {
       TraceStr("GET_OWNERSHIP: App Running - Not Owner!");
       pm->state = ST_INIT;
          pm->load_timer = 0;
       return;
     }
     }
      else if ((pkt[6] & 1) == 0) // code is not downloaded, so download it.
      {
     // Make sure that we are the owner?
        if (pkt[6] & 2)  // 2h=not owner bit
     {
       TraceStr("GET_OWNERSHIP: No App - Not Owner!");
       pm->state = ST_INIT;
          pm->load_timer = 0;
       return;
     }
        TraceStr("GET_OWNERSHIP: Download");
        pm->Status &= ~S_NEED_CODE_UPDATE;
        pm->state = ST_SENDCODE;
      }
      else  // code is downloaded - we are the owner
     {
     if (pm->Status & S_NEED_CODE_UPDATE)
     {
       // force a reset of box on driver-load(this bit is set in
       // port_init) and set S_NEED_CODE_UPDATE so we load up some
       // fresh microcode.
       admin_send_reset(pm->nic, pm->hd->dest_addr);
       TraceStr("ReplyID, ReLoad");
          pm->Status &= ~S_NEED_CODE_UPDATE;
     }
     else
     {
       TraceStr("ReplyID, GoToConnect");
       port_resync_all(pm);
       //pm->state = ST_ACTIVE;
       pm->state = ST_CONNECT;
     }
     }
   }
  }
}
#endif

/*--------------------------------------------------------------------------
| port_connect_reply - Reply to server connection request, we return our
    MAC address, and do a re-sync operation.
|--------------------------------------------------------------------------*/
int port_connect_reply(Hdlc *hd)
{
  BYTE rkt_header[8];

  TraceStr( "Connect Reply");
  rkt_header[0] = RK_CONNECT_REPLY;
  memcpy(&rkt_header[1], hd->nic->address,6);
  hdlc_send_control(hd, rkt_header, 7,
                    NULL, 0,   // ptr to data to send
                    hd->dest_addr); // MAC address to send to
  hdlc_resync(hd);
  return 0;
}

/*--------------------------------------------------------------------------
| port_connect_ask - Ask box to initiate a connection.  We send out our
    MAC address, and do a resync.
|--------------------------------------------------------------------------*/
int port_connect_ask(Hdlc *hd)
{
  BYTE rkt_header[8];

  TraceStr( "Connect Ask");
  rkt_header[0] = RK_CONNECT_ASK;
  memcpy(&rkt_header[1], hd->nic->address,6);

  hdlc_send_control(hd, rkt_header, 7,
                    NULL, 0,   // ptr to data to send
                    hd->dest_addr); // MAC address to send to
  hdlc_resync(hd);
  return 0;
}

/*------------------------------------------------------------------
 PortSetBaudRate - Set the desired baud rate.  Return non-zero on error.
|-------------------------------------------------------------------*/
int PortSetBaudRate(SerPort *p,
                    ULONG desired_baud,
                    USHORT SetHardware,
                    DWORD  clock_freq,
                    DWORD  clk_prescaler)
{
  ULONG diff;
  ULONG act_baud;
  ULONG percent_error;
  ULONG div;
  ULONG base_clock_rate;

  base_clock_rate = ((clock_freq/16) / ((clk_prescaler & 0xf)+1));

  // calculate the divisor for our hardware register.
  // this is really just div = clk/desired_baud -1.  but we do some
  // work to minimize round-off error.
  if (desired_baud <= 0) desired_baud = 1;  // guard against div 0

  div =  ((base_clock_rate+(desired_baud>>1)) / desired_baud) - 1;
  if (div > 8191)  // overflow hardware divide register
    div = 8191;

  // this is really just (clk) / (div+1) but we do some
  // work to minimize round-off error.
  act_baud = (base_clock_rate+((div+1)>>1)) / (div+1);

  if (desired_baud > act_baud)
    diff = desired_baud - act_baud;
  else
    diff = act_baud - desired_baud;

  percent_error = (diff * 100) / desired_baud;
  if (percent_error > 5)
    return (int) percent_error;

  if (SetHardware)
  {
    p->change_flags |= CHG_BAUDRATE;
    //---- OLD p->out_flags |= SC_BAUDRATE_CHANGE;   // tells what needs changing to remote
    p->baudrate = desired_baud;
  }
  return 0;
}

/*---------------------------------------------------------------------------
| check_ack_code - upload code, given ack packet, check for good status.
|---------------------------------------------------------------------------*/
int check_ack_code(PortMan *pm, BYTE *pkt)
{
  int stat;
  int snd;

  TraceStr("CodeChk");
  stat = eth_device_reply(UPLOAD_COMMAND,
                          0x00010000L + pm->code_cnt,
                          &snd,
                          NULL,
                          pkt);
  return stat;
}
                  
/*---------------------------------------------------------------------------
| send_go - send boot loader command to start execution of uploaded driver
   at 1000:0 in memory.
|---------------------------------------------------------------------------*/
int send_go(PortMan *pm)
{
  int stat;
  BYTE *buf;
  WORD io[4];
  BYTE *tx_base;

  TraceStr("GoSend");

  hdlc_get_ctl_outpkt(pm->hd, &buf);
  if (buf == NULL)
    return 1;
  tx_base = buf - 20;  // backup to start of pkt

  io[0] = 0x1000;  // segment to go at
  io[1] = 0;  // offset to go at

  // send more code, loading at 10000H location in mem.
  // first just transfer data to an outgoing packet buffer
  stat = ioctl_device(IOCTL_COMMAND,
                      (BYTE *) io,
                      buf,
                      12,  // 12 = go command
                      4);  // num bytes of data
  // setup header
  tx_base[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
  tx_base[15] = 0;     // conc. index field
  tx_base[16] = 1;     // admin
  *((WORD *)&tx_base[17]) = 40;
  tx_base[19] = 1;     // ADMIN packet type, 1=boot-loader, 3=id-reply

  // send it.
  stat = hdlc_send_raw(pm->hd, 60, NULL);
  return 0;
}

/*---------------------------------------------------------------------------
| send_code - upload code.
|---------------------------------------------------------------------------*/
int send_code(PortMan *pm)
{
  int stat;
  BYTE *buf;
  BYTE *tx_base;
  long snd;

  TraceStr("CodeSend");

  // send more data
  if (pm->code_cnt < Driver.MicroCodeSize)
  {
    if ((Driver.MicroCodeSize - pm->code_cnt) > 1000)
      snd = 1000;
    else
      snd = Driver.MicroCodeSize - pm->code_cnt;

    hdlc_get_ctl_outpkt(pm->hd, &buf);
    if (buf == NULL)
    {
      TraceErr("CodeSend Err1A");
      return 1;
    }
    tx_base = buf - 20;  // backup to start of pkt

    // send more code, loading at 10000H location in mem.
    // first just transfer data to an outgoing packet buffer
    stat = ioctl_device(UPLOAD_COMMAND,
                        &Driver.MicroCodeImage[pm->code_cnt],
                        buf,
                        0x00010000L + pm->code_cnt,  // offset into memory
                        snd);
    // setup header
    tx_base[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
    tx_base[15] = 0;     // conc. index field
    tx_base[16] = 1;     // admin
    *((WORD *)&tx_base[17]) = snd+20;
    tx_base[19] = 1;     // ADMIN packet type, 1=boot-loader, 3=id-reply

    // send it.
    stat = hdlc_send_raw(pm->hd, snd+40, NULL);
  }
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\queue.h ===
//---- queue.h
// Copyright 1996 Comtrol Corporation.  All rights reserved.

#ifndef BYTE
#define BYTE UCHAR
#endif

//----- a queue data type
typedef struct {
  unsigned char *QBase; // points to base of buffer
  int QSize;  // total Q size
  int QGet;   // get index
  int QPut;   // put index
} Queue;

/*----------------------------------
 q_full - return true if queue is full.
|----------------------------------*/
#define q_full(q) ((((q)->QGet + 1) % (q)->QSize) == (q)->QPut)

/*----------------------------------
 q_empty - return true if queue is empty.
|----------------------------------*/
#define q_empty(q) ((q)->QGet == (q)->QPut)

/*----------------------------------
 q_put_flush - flush the queue, empty it out.
|----------------------------------*/
#define q_put_flush(q)  (q)->QPut = (q)->QGet

/*----------------------------------
 q_get_flush - flush the queue, empty it out.
|----------------------------------*/
#define q_get_flush(q)  (q)->QGet = (q)->QPut
#define q_flush q_get_flush

/*----------------------------------
 q_room_put_till_wrap - return number of chars we can put in queue up to the
   wrap point(end of the queue).  Assumes we already checked to see if
   the total number will fit in the queue using q_room().
|----------------------------------*/
#define q_room_put_till_wrap(q)  \
      ( (q)->QSize - (q)->QPut)

/*----------------------------------
 q_room_get_till_wrap - return number of chars we can get in queue up to the
   wrap point(end of the queue).  Assumes we already checked to see if
   the total number is available from the the queue using q_count().
|----------------------------------*/
#define q_room_get_till_wrap(q)  \
      ( (q)->QSize - (q)->QGet)

/*----------------------------------
 q_room - return number of chars room in queue we can put.
  if (QRoom = (queue->QPut - queue->QGet -1) < 0)
      QRoom += queue->QSize;
|----------------------------------*/
int q_room(Queue *queue);
/* #define q_room(q)  \
   ( (((q)->QGet - (q)->QPut) <= 0) ?             \
      ((q)->QGet - (q)->QPut - 1 + (q)->QSize) :  \
      ((q)->QGet - (q)->QPut - 1) )
   to many references to QPut, contentious!
*/

/*----------------------------------
 q_count - return number of chars in queue we can get.

  if (QCount = (queue->QPut - queue->QGet) < 0)
      QCount += queue->QSize;
|----------------------------------*/
int q_count(Queue *queue);
/* #define q_count(q)  \
   ( (((q)->QPut - (q)->QGet) < 0) ?          \
      ((q)->QPut - (q)->QGet + (q)->QSize) :  \
      ((q)->QPut - (q)->QGet) )
   to many references to QPut, contentious!
*/

/*----------------------------------
 q_put_one - put a single character in the queue.  No check for room
   done, so do a if (!q_full(q)) prior to calling
|----------------------------------*/
#define q_put_one(q, c)  \
   (q)->QBase[(q)->QPut] = c; \
   (q)->QPut += 1; \
   (q)->QPut %= (q)->QSize;

/*--------------------------------------------------------------------------
| q_got - do the arithmetic to update the indexes if someone pulled Count
    many bytes from the queue.
|--------------------------------------------------------------------------*/
#define q_got(q, _cnt) \
  ( (q)->QGet = ((q)->QGet + _cnt) % (q)->QSize )

/*--------------------------------------------------------------------------
| q_putted - do the arithmetic to update the indexes if someone stuffed _cnt
    many bytes into the queue.
|--------------------------------------------------------------------------*/
#define q_putted(q, _cnt) \
  ( (q)->QPut = ((q)->QPut + _cnt) % (q)->QSize )

/*--------------------------------------------------------------------------
| q_flush_amount - flush an amount out of the queue on the get side.
   Used for debugger queue, where we want to dispose oldest so we
   always have room to put new.
   Assumed that called checks that there are enough bytes in the queue
   to clear prior to calling.
|--------------------------------------------------------------------------*/
#define q_flush_amount(q,bytes) \
  { q->QGet = (q->QGet + bytes) % q->QSize; }

int q_flush_count_get(Queue *queue);
int q_flush_count_put(Queue *queue);
int q_get(Queue *queue, unsigned char *buf, int Count);
int q_put(Queue *queue, unsigned char *buf, int Count);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\queue.c ===
/*--------------------------------------------------------------------------
| queue.c - queue code.  This queue code serves the following need:
   It provides circular queue code which is fast and it does so without
   requiring a lock or semaphore between the get and put side of the queue.
   Simpler queue code exists which keeps a qcount member, but this requires
   a lock or semaphore in the implementation.  By calculating everything
   based on the indexes we can run without a lock.  This index arithmetic
   is a bit hairy(and may contain some additional overhead), but when
   working with a complex multiprocessor OS's, the ellimination of the lock
   is very handy.

 Copyright 1996-97 Comtrol Corporation.  All rights reserved.
|--------------------------------------------------------------------------*/
#include "precomp.h"

// much of the queue implementation are macros in the header file.

/*--------------------------------------------------------------------------
| q_flush_count_put - flush the queue and return number of bytes flushed
    from it.  Assume Put side of queue will not be in a state of flux.
|--------------------------------------------------------------------------*/
int q_flush_count_put(Queue *queue)
{
 int Count, QGet;

  // use a copy of QGet, since it may be changing at ISR level while we work.
  QGet = queue->QGet;

  // figure the number of bytes in the queue
  if ((Count = queue->QPut - QGet) < 0)
    Count += queue->QSize; // adjust for wrap

  // flush by setting QGet=QPut;
  queue->QPut = QGet;
  return Count;  // return count of flushed chars
}

/*--------------------------------------------------------------------------
| q_flush_count_get - flush the queue and return number of bytes flushed
    from it.  Assume Get side of queue will not be in a state of flux.
|--------------------------------------------------------------------------*/
int q_flush_count_get(Queue *queue)
{
 int Count, QPut;

  // use a copy of QPut, since it may be changing at ISR level while we work.
  QPut = queue->QPut;

  // figure the number of bytes in the queue
  if ((Count = QPut - queue->QGet) < 0)
    Count += queue->QSize; // adjust for wrap

  // flush by setting QGet=QPut;
  queue->QGet = QPut;
  return Count;  // return count of flushed chars
}

/*----------------------------------
 q_room - return number of chars room in queue we can put.
|----------------------------------*/
int q_room(Queue *queue)
{
 int QCount;

  if ((QCount = (queue->QPut - queue->QGet)) < 0)
      QCount += queue->QSize;
  return (queue->QSize - QCount - 1);
}

/*----------------------------------
 q_count - return number of chars in queue we can get.
|----------------------------------*/
int q_count(Queue *queue)
{
 int QCount;

  if ((QCount = (queue->QPut - queue->QGet)) < 0)
      QCount += queue->QSize;
  return QCount;
}

/*--------------------------------------------------------------------------
| q_get - Get bytes from queue.
   queue : our queue
   buf   : buffer to put the data into
   Count : Max number of bytes to get
   Returns int value equal to number of bytes transferred.
|--------------------------------------------------------------------------*/
int q_get(Queue *queue, unsigned char *buf, int Count)
{
 int get1, get2, ToMove;

  if ((ToMove = queue->QPut - queue->QGet) < 0)
    ToMove += queue->QSize; // adjust for wrap

  if (Count > ToMove)  // only move whats asked
  {
    Count = ToMove;
  }

  if (Count == 0)  // if nothing asked or nothing available
    return 0;

  get1 = queue->QSize - queue->QGet;  // space till wrap point
  if (get1 < Count)
  {
    get2 = Count - get1;  // two moves required
  }
  else  // only one move required
  {
    get2 = 0;
    get1 = Count;
  }

  memcpy(buf, &queue->QBase[queue->QGet], get1);

  queue->QGet = (queue->QGet + get1) % queue->QSize;
  if (get2)
  {
    memcpy(&buf[get1], &queue->QBase[0], get2);
    queue->QGet = get2;
  }

  return Count;
}

/*--------------------------------------------------------------------------
| q_put - Put data into the Queue.
   queue : our queue
   buf   : buffer to get the data from
   Count : Max number of bytes to put
   Returns int value equal to number of bytes transferred.
|--------------------------------------------------------------------------*/
int q_put(Queue *queue, unsigned char *buf, int Count)
{
 int put1, put2, room;

  if ((room = queue->QGet - queue->QPut - 1) < 0)
    room += queue->QSize;  // adjust for wrap

  if (Count > room)
    Count = room;

  if (Count <= 0)  // if nothing asked or nothing available
    return 0;

  put1 = queue->QSize - queue->QPut;

  if (put1 < Count)
  {
    put2 = Count - put1;  // two moves required
  }
  else  // only one move required
  {
    put2 = 0;
    put1 = Count;
  }

  memcpy(&queue->QBase[queue->QPut], buf, put1);
  queue->QPut = (queue->QPut + put1) % queue->QSize;
  if (put2)
  {
    memcpy(&queue->QBase[0], &buf[put1], put2);
    queue->QPut = put2;
  }

  return Count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\read.c ===
/*-------------------------------------------------------------------
| read.c -
1-22-99 - add missing IoReleaseCancelSpinLock(oldIrql) to CompleteRead().
  Error introduced after V3.23.  kpb
1-18-99 - adjust VS timeout settings., take out some old #ifdef's. kpb.
3-23-98 - adjust VS so we have minimum per-character timeout value to
  compensate for vs networking.
3-04-98 Beef up synch locks with isr service routine(blue-screens on MP systems). kpb.
3-04-98 Take out data move from inter-character timer processing - kpb.
 9-22-97 V1.16 - add check to avoid crash on modem detection.
Copyright 1993-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

// #define TIMEOUT_TRACING
// #define TESTING_READ 1

//--- local funcs
VOID SerialCancelCurrentRead(PDEVICE_OBJECT DeviceObject, PIRP Irp);

BOOLEAN SerialGrabReadFromIsr(PSERIAL_DEVICE_EXTENSION Extension);

/*************************************************************************
Routine Description:
    This is the dispatch routine for reading.  It validates the parameters
    for the read request and if all is ok then it places the request
    on the work queue.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request
Return Value:
    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return the status returned by
    the actual start read routine.
*************************************************************************/
NTSTATUS
SerialRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    NTSTATUS Status;
    BOOLEAN acceptingIRPs;

    acceptingIRPs = SerialIRPPrologue(extension);

   if (acceptingIRPs == FALSE) {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
      SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
      return STATUS_NO_SUCH_DEVICE;
   };

   if (extension->DeviceType == DEV_BOARD)
   {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
      SerialCompleteRequest (extension, Irp, IO_NO_INCREMENT);
      return STATUS_NOT_SUPPORTED;
   };

    ExtTrace1(extension,D_Ioctl,"Read Start Len:%d",
            IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length);

    if (extension->ErrorWord)
    {
      if (SerialCompleteIfError( DeviceObject, Irp ) != STATUS_SUCCESS)
      {
        ExtTrace(extension,D_Ioctl,"ErrSet!");
        return STATUS_CANCELLED;
      }
    }

    Irp->IoStatus.Information = 0L;

    // If this is a zero length read then we are already done.
    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length)
    {
        // Put the read on the queue so that we can
        // process it when our previous reads are done.
        ++extension->rec_packets;
        Status = SerialStartOrQueue(
                   extension,
                   Irp,
                   &extension->ReadQueue,
                   &extension->CurrentReadIrp,
                   SerialStartRead
                   );
        if  (Status == STATUS_PENDING)
        {
          ExtTrace(extension,D_Ioctl, " ,PENDING");
        }
        else
        {
          ExtTrace1(extension,D_Ioctl,"Read Return Status:%d",Status);
        }

        return Status;
    }
    else
    {
        // Nothing to do, return success
        Irp->IoStatus.Status = STATUS_SUCCESS;
    
        SerialCompleteRequest(extension, Irp, 0);

        return STATUS_SUCCESS;
    }
}

/*************************************************************************
Routine Description:
    This routine is used to start off any read.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the read.  It will attempt to complete
    the read from data already in the interrupt buffer.  If the
    read can be completed quickly it will start off another if
    necessary.
Arguments:
    Extension - Simply a pointer to the serial device extension.
Return Value:
    This routine will return the status of the first read
    irp.  This is useful in that if we have a read that can
    complete right away (AND there had been nothing in the
    queue before it) the read could return SUCCESS and the
    application won't have to do a wait.
*************************************************************************/
NTSTATUS
SerialStartRead(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )
{
    PIRP newIrp;
    KIRQL oldIrql;
    KIRQL controlIrql;

    BOOLEAN returnWithWhatsPresent;
    BOOLEAN os2ssreturn;
    BOOLEAN crunchDownToOne;
    BOOLEAN useTotalTimer;
    BOOLEAN useIntervalTimer;

    ULONG multiplierVal;
    ULONG constantVal;

    LARGE_INTEGER totalTime;

    SERIAL_TIMEOUTS timeoutsForIrp;

    BOOLEAN setFirstStatus = FALSE;
    NTSTATUS firstStatus;

    do
    {
            Extension->NumberNeededForRead =
                IoGetCurrentIrpStackLocation(Extension->CurrentReadIrp)
                    ->Parameters.Read.Length;

            // Calculate the timeout value needed for the
            // request.  Note that the values stored in the
            // timeout record are in milliseconds.

            useTotalTimer = FALSE;
            returnWithWhatsPresent = FALSE;
            os2ssreturn = FALSE;
            crunchDownToOne = FALSE;
            useIntervalTimer = FALSE;

            // Always initialize the timer objects so that the
            // completion code can tell when it attempts to
            // cancel the timers whether the timers had ever
            // been set.

            KeInitializeTimer(&Extension->ReadRequestTotalTimer);
            KeInitializeTimer(&Extension->ReadRequestIntervalTimer);

            // We get the *current* timeout values to use for timing
            // this read.

            KeAcquireSpinLock(&Extension->ControlLock, &controlIrql);

            timeoutsForIrp = Extension->Timeouts;

            KeReleaseSpinLock(&Extension->ControlLock, controlIrql);

            // Calculate the interval timeout for the read.

            if (timeoutsForIrp.ReadIntervalTimeout &&
                (timeoutsForIrp.ReadIntervalTimeout !=
                 MAXULONG))
            {
                useIntervalTimer = TRUE;
                Extension->IntervalTime.QuadPart =
                    UInt32x32To64(
                        timeoutsForIrp.ReadIntervalTimeout,
                        10000
                        );
#ifdef S_VS
                // if they are using a per-character timeout of less
                // than 100ms, then change it to 100ms due to possible
                // network latencies.
                if (Extension->IntervalTime.QuadPart < (10000 * 100))
                {
                  ExtTrace(Extension,D_Ioctl,"Adjust mintime");

                  Extension->IntervalTime.QuadPart = (10000 * 100);
                }
#endif

                if (Extension->IntervalTime.QuadPart >=
                    Extension->CutOverAmount.QuadPart) {

                    Extension->IntervalTimeToUse =
                        &Extension->LongIntervalAmount;

                } else {

                    Extension->IntervalTimeToUse =
                        &Extension->ShortIntervalAmount;

                }
            }

            if (timeoutsForIrp.ReadIntervalTimeout == MAXULONG)
            {
                // We need to do special return quickly stuff here.
                // 1) If both constant and multiplier are
                //    0 then we return immediately with whatever
                //    we've got, even if it was zero.
                // 2) If constant and multiplier are not MAXULONG
                //    then return immediately if any characters
                //    are present, but if nothing is there, then
                //    use the timeouts as specified.
                // 3) If multiplier is MAXULONG then do as in
                //    "2" but return when the first character
                //    arrives.

                if (!timeoutsForIrp.ReadTotalTimeoutConstant &&
                    !timeoutsForIrp.ReadTotalTimeoutMultiplier)
                {
                    returnWithWhatsPresent = TRUE;

                }
                else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                            &&
                           (timeoutsForIrp.ReadTotalTimeoutMultiplier
                            != MAXULONG))
               {

                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                }
                else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                            &&
                           (timeoutsForIrp.ReadTotalTimeoutMultiplier
                            == MAXULONG))
                {
                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    crunchDownToOne = TRUE;
                    multiplierVal = 0;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
                }
            }
            else
            {
                // If both the multiplier and the constant are
                // zero then don't do any total timeout processing.

                if (timeoutsForIrp.ReadTotalTimeoutMultiplier ||
                    timeoutsForIrp.ReadTotalTimeoutConstant) {

                    // We have some timer values to calculate.

                    useTotalTimer = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
                }
            }

            if (useTotalTimer)
            {
                totalTime.QuadPart = ((LONGLONG)(UInt32x32To64(
                                          Extension->NumberNeededForRead,
                                          multiplierVal
                                          )
                                          + constantVal))
                                      ;
#ifdef S_VS
                if (totalTime.QuadPart < 50)
                {
                  totalTime.QuadPart = 50;  // limit to a minimum of 50ms timeout
                }
#endif
                totalTime.QuadPart *= -10000;
            }


            // Move any data in the interrupt buffer to the user buffer.
            // Try to satisfy the current read irp.

            // Use spinlock so a purge will not cause problems.
            KeAcquireSpinLock(&Extension->ControlLock, &controlIrql);

            // Move the data from the host side buffer to the user buffer
            // This is the "first" move so assign CountOnLastRead

            Extension->CountOnLastRead = SerialGetCharsFromIntBuffer(Extension);

            // Init the timeout flag
            Extension->ReadByIsr = 0;

            // See if we have any cause to return immediately.
            if (returnWithWhatsPresent || (!Extension->NumberNeededForRead) ||
                (os2ssreturn && Extension->CurrentReadIrp->IoStatus.Information))
            {
                // We got all we needed for this read.

                KeReleaseSpinLock(&Extension->ControlLock, controlIrql);

#ifdef TRACE_PORT
    if (Extension->TraceOptions)
    {
      if (Extension->TraceOptions & 1)  // event tracing
      {
        ExtTrace1(Extension,D_Read,"Immed. Read Done, size:%d",
                 Extension->CurrentReadIrp->IoStatus.Information);

        // dump data into the trace buffer in a hex or ascii dump format
        TraceDump(Extension,
                  Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer,
                  Extension->CurrentReadIrp->IoStatus.Information, 0);
      }
      else if (Extension->TraceOptions & 2)  // trace input data
      {
        TracePut(
                 Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer,
                 Extension->CurrentReadIrp->IoStatus.Information);
      }
    }
#endif

                Extension->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;
                if (!setFirstStatus)
                {
                    firstStatus = STATUS_SUCCESS;
                    setFirstStatus = TRUE;
                }
            }
            else  // not return with what we have
            {
                MyKdPrint(D_Read,("Read Pending\n"))

                // The irp may go under control of the isr.
                // Initialize the reference count

                SERIAL_INIT_REFERENCE(Extension->CurrentReadIrp);

                IoAcquireCancelSpinLock(&oldIrql);

                // We need to see if this irp should be canceled.
                if (Extension->CurrentReadIrp->Cancel)
                {
                    IoReleaseCancelSpinLock(oldIrql);

                    KeReleaseSpinLock(&Extension->ControlLock, controlIrql);

                    Extension->CurrentReadIrp->IoStatus.Status =
                        STATUS_CANCELLED;

                    Extension->CurrentReadIrp->IoStatus.Information = 0;

                    if (!setFirstStatus)
                    {
                        firstStatus = STATUS_CANCELLED;
                        setFirstStatus = TRUE;
                    }

                }
                else
                {
                    // If we are supposed to crunch the read down to
                    // one character, then update the read length
                    // in the irp and truncate the number needed for
                    // read down to one. Note that if we are doing
                    // this crunching, then the information must be
                    // zero (or we would have completed above) and
                    // the number needed for the read must still be
                    // equal to the read length.
                    //

                    if (crunchDownToOne)
                    {
                        Extension->NumberNeededForRead = 1;

                        IoGetCurrentIrpStackLocation(
                            Extension->CurrentReadIrp
                            )->Parameters.Read.Length = 1;
                    }

                    // Is this irp complete?
                    if (Extension->NumberNeededForRead)
                    {
                        // The irp isn't complete, the ISR or timeout
                        // will start the completion routines and
                        // invoke this code again to finish.

                        // Total supervisory read time.
                        if (useTotalTimer)
                        {
                            SERIAL_SET_REFERENCE(
                                Extension->CurrentReadIrp,
                                SERIAL_REF_TOTAL_TIMER
                                );

                            // Start off the total timer
                            KeSetTimer(
                                &Extension->ReadRequestTotalTimer,
                                totalTime,
                                &Extension->TotalReadTimeoutDpc
                                );
                        }

   // Inter-character timer
                        if(useIntervalTimer)
                        {
                            SERIAL_SET_REFERENCE(
                                Extension->CurrentReadIrp,
                                SERIAL_REF_INT_TIMER
                                );

                            KeQuerySystemTime(
                                &Extension->LastReadTime
                                );

                            KeSetTimer(
                                &Extension->ReadRequestIntervalTimer,
                                *Extension->IntervalTimeToUse,
                                &Extension->IntervalReadTimeoutDpc
                                );
                        }

                        SERIAL_SET_REFERENCE(Extension->CurrentReadIrp,
                                             SERIAL_REF_CANCEL);

                        IoMarkIrpPending(Extension->CurrentReadIrp);
                        IoSetCancelRoutine(
                            Extension->CurrentReadIrp,
                            SerialCancelCurrentRead
                            );

                        SERIAL_SET_REFERENCE(Extension->CurrentReadIrp,
                                             SERIAL_REF_ISR);
                        // tell ISR to complete it.
                        Extension->ReadPending = TRUE;

                        IoReleaseCancelSpinLock(oldIrql);
                        KeReleaseSpinLock(&Extension->ControlLock, controlIrql);

                        if (!setFirstStatus)
                        {
                            firstStatus = STATUS_PENDING;
                        }

                        return firstStatus;

                    }
                    else
                    {

                        IoReleaseCancelSpinLock(oldIrql);
                        KeReleaseSpinLock(&Extension->ControlLock,controlIrql);
                        Extension->CurrentReadIrp->IoStatus.Status =
                            STATUS_SUCCESS;

                        if (!setFirstStatus) {

                            firstStatus = STATUS_SUCCESS;
                            setFirstStatus = TRUE;
                        }
                    }  // irp not complete
                }  // not canceled
            }  // not return with what we have

            // The current irp is complete, try to get another one.
            SerialGetNextIrp(
                &Extension->CurrentReadIrp,
                &Extension->ReadQueue,
                &newIrp,
                TRUE,
                Extension
                );

    } while (newIrp);

    return firstStatus;

}

/*------------------------------------------------------------------------
 trace_read_data - used to trace completion of read irp.
|------------------------------------------------------------------------*/
void trace_read_data(PSERIAL_DEVICE_EXTENSION extension)
{

  if (extension->TraceOptions & 1)  // event tracing
  {
    ExtTrace3(extension,D_Read,"Pend. Read Done, size:%d [%d %d]",
             extension->CurrentReadIrp->IoStatus.Information,
             extension->RxQ.QPut, extension->RxQ.QGet);

    // dump data into the trace buffer in a hex or ascii dump format
    TraceDump(extension,
              extension->CurrentReadIrp->AssociatedIrp.SystemBuffer,
              extension->CurrentReadIrp->IoStatus.Information, 0);
  }
  else if (extension->TraceOptions & 2)  // trace input data
  {
    TracePut(
             extension->CurrentReadIrp->AssociatedIrp.SystemBuffer,
             extension->CurrentReadIrp->IoStatus.Information);
  }
}

/***************************************************************************
Routine Description:
    This routine is merely used to complete any read that
    ended up being used by the Isr.  It assumes that the
    status and the information fields of the irp are already
    correctly filled in.
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
***************************************************************************/
VOID
SerialCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{
    PSERIAL_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

#ifdef TRACE_PORT
    if (extension->TraceOptions)
    {
      ExtTrace(extension,D_Read,"Read Complete");
      trace_read_data(extension);
    }
#endif

    IoAcquireCancelSpinLock(&oldIrql);

    // check that we haven't been canceled by a timeout
    // kludge fix for the semaphores from hell
    if (extension->CurrentReadIrp != NULL)
    {

      // Don't allow the ISR to complete this IRP
      extension->ReadPending = FALSE;

      // Indicate to the interval timer that the read has completed.
      // The interval timer dpc can be lurking in some DPC queue.
      extension->CountOnLastRead = SERIAL_COMPLETE_READ_COMPLETE;

    
      SerialTryToCompleteCurrent(
        extension,
        NULL,
        oldIrql,
        STATUS_SUCCESS,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp,
        SERIAL_REF_ISR
        );
    }
    else
    {
      IoReleaseCancelSpinLock(oldIrql);
    }
#ifdef TESTING_READ
        MyKdPrint(D_Read,("Complete Read!"))
#endif

}

/****************************************************************************
Routine Description:
    This routine is used to cancel the current read.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP to be canceled.
Return Value:
    None.
****************************************************************************/
VOID
SerialCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;

    // Indicate to the interval timer that the read has encountered a cancel.
    // The interval timer dpc can be lurking in some DPC queue.
    extension->CountOnLastRead = SERIAL_COMPLETE_READ_CANCEL;
    extension->ReadPending = FALSE;
    SERIAL_CLEAR_REFERENCE(extension->CurrentReadIrp, SERIAL_REF_ISR);

    if (extension->TraceOptions)
    {
      ExtTrace(extension,D_Read,"Cancel Read");
      trace_read_data(extension);
    }

    SerialTryToCompleteCurrent(
        extension,
        SerialGrabReadFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp,
        SERIAL_REF_CANCEL
        );
}

/*------------------------------------------------------------------
Routine Description:
    This routine is used to complete a read because its total
    timer has expired.
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
|------------------------------------------------------------------*/
VOID
SerialReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{
    PSERIAL_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

#ifdef TESTING_READ
    MyKdPrint(D_Read,("\n[Read Timeout!]\n"))
    MyKdPrint(D_Read,("Read Wanted, len:%ld \n", extension->debug_ul1))
    MyKdPrint(D_Read,("Read, Got:%ld, Immed:%d readpen:%d\n", 
        extension->CurrentReadIrp->IoStatus.Information,
        extension->debug_ul2,
        extension->ReadPending))
    MyKdPrint(D_Read,("Read Left, NNFR:%ld\n", extension->NumberNeededForRead))
    KdBreakPoint();
#endif

    if (extension->TraceOptions)
    {
      ExtTrace(extension,D_Read,"Rd-Total Timeout");
      trace_read_data(extension);
    }

    IoAcquireCancelSpinLock(&oldIrql);

    // Indicate to the interval timer that the read has completed
    // due to total timeout.
    // The interval timer dpc can be lurking in some DPC queue.
    extension->CountOnLastRead = SERIAL_COMPLETE_READ_TOTAL;

    SerialTryToCompleteCurrent(
        extension,
        SerialGrabReadFromIsr,
        oldIrql,
        STATUS_TIMEOUT,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp,
        SERIAL_REF_TOTAL_TIMER
        );
}

/*------------------------------------------------------------------
Routine Description:
    This routine is used timeout the request if the time between
    characters exceed the interval time.  A global is kept in
    the device extension that records the count of characters read
    the last the last time this routine was invoked (This dpc
    will resubmit the timer if the count has changed).  If the
    count has not changed then this routine will attempt to complete
    the irp.  Note the special case of the last count being zero.
    The timer isn't really in effect until the first character is read.
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
|------------------------------------------------------------------*/
VOID
SerialIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{
    PSERIAL_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;
#if 0
    KIRQL controlIrql;
#endif

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

#ifdef TIMEOUT_TRACING
    ExtTrace3(extension,D_Read,"RIT, amnt:%d [%d %d]",
             extension->CurrentReadIrp->IoStatus.Information,
             extension->RxQ.QPut, extension->RxQ.QGet);
#endif
    IoAcquireCancelSpinLock(&oldIrql);

    if (extension->CountOnLastRead == SERIAL_COMPLETE_READ_TOTAL)
    {
#ifdef TIMEOUT_TRACING
      if (extension->TraceOptions)
      {
        ExtTrace(extension,D_Read,"Interv. Complete Total");
        trace_read_data(extension);
      }
#endif

        // The total timer has fired, try to complete.
        SerialTryToCompleteCurrent(
            extension,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_TIMEOUT,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp,
            SERIAL_REF_INT_TIMER
            );

    }
    else if (extension->CountOnLastRead == SERIAL_COMPLETE_READ_COMPLETE)
    {
        ExtTrace(extension,D_Read," Rd Timeout, Complete");
#ifdef TRACE_PORT
        if (extension->TraceOptions)
          { trace_read_data(extension); }
#endif
        // The regular completion routine has been called, try to complete.
        SerialTryToCompleteCurrent(
            extension,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_SUCCESS,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp,
            SERIAL_REF_INT_TIMER
            );

    }
    else if (extension->CountOnLastRead == SERIAL_COMPLETE_READ_CANCEL)
    {
        ExtTrace(extension,D_Read,"Rd Timeout, Cancel");
#ifdef TRACE_PORT
        if (extension->TraceOptions)
          { trace_read_data(extension); }
#endif
        // The cancel read routine has been called, try to complete.
        SerialTryToCompleteCurrent(
            extension,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_CANCELLED,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp,
            SERIAL_REF_INT_TIMER
            );

    }
    else if (extension->CountOnLastRead || extension->ReadByIsr)
    {
        //
 // Check on Interval Timeouts.
        //

        // As we come back to this routine we will compare the current time
        // to the "last" time.  If the difference is larger than the
        // interval requested by the user, time out the request.
        // If the ISR has read in any more characters, resubmit the timer.

        if(extension->ReadByIsr)
        {
           // Something was placed in the system side buffer by the ISR

           // Init for resubmitted timeout
           extension->ReadByIsr = 0;

#if 0

/*----------
  This is bad news, the ISR moves data from the que to the user IRP buffer,
  if we do it here we have a nasty time-consuming contention issue.
  There is no good reason to do the move here, take it out.
----------*/
           KeAcquireSpinLock(&extension->ControlLock,&controlIrql);

           // Move the chars to the user buffer
/*----------
isr code calls this routine also, the extension->ReadPending is the
mechanism to control access(Two SerialGetCharsFromIntBuffer() calls
 at same time.) kpb
----------*/
           extension->CountOnLastRead |=
              SerialGetCharsFromIntBuffer(extension);

           KeReleaseSpinLock(&extension->ControlLock,controlIrql);
 #endif
   
           // Save off the "last" time something was read.
           KeQuerySystemTime(
               &extension->LastReadTime
               );
#ifdef TRACE_TICK_DEBUG
           ExtTrace(extension,D_Read," Resubmit(new chars)");
#endif
   
           // Resubmit the timer
           KeSetTimer(
               &extension->ReadRequestIntervalTimer,
               *extension->IntervalTimeToUse,
               &extension->IntervalReadTimeoutDpc
               );

           IoReleaseCancelSpinLock(oldIrql);

           // Allow the ISR to complete this IRP
       }
       else
       {
           // The timer fired but nothing was in the interrupt buffer.
           // Characters have been read previously, so check time interval

           LARGE_INTEGER currentTime;

           KeQuerySystemTime(
               &currentTime
               );
            if ((currentTime.QuadPart - extension->LastReadTime.QuadPart) >=
                extension->IntervalTime.QuadPart)
           {
              ExtTrace(extension,D_Read,"RIT Timeout");
#ifdef TRACE_PORT
               if (extension->TraceOptions)
                 { trace_read_data(extension); }
#endif
               // No characters read in the interval time, kill this read.
               SerialTryToCompleteCurrent(
                   extension,
                   SerialGrabReadFromIsr,
                   oldIrql,
                   STATUS_TIMEOUT,
                   &extension->CurrentReadIrp,
                   &extension->ReadQueue,
                   &extension->ReadRequestIntervalTimer,
                   &extension->ReadRequestTotalTimer,
                   SerialStartRead,
                   SerialGetNextIrp,
                   SERIAL_REF_INT_TIMER
                   );
   
           }
           else
           {
#ifdef TRACE_TICK_DEBUG
               // The timer fired but the interval time has not
               // been exceeded, resubmit the timer
               ExtTrace(extension,D_Read," Resubmit");
#endif
               KeSetTimer(
                   &extension->ReadRequestIntervalTimer,
                   *extension->IntervalTimeToUse,
                   &extension->IntervalReadTimeoutDpc
                   );

               IoReleaseCancelSpinLock(oldIrql);

#ifdef TIMEOUT_TRACING
               ExtTrace(extension,D_Read," No data, Resubmit.");
#endif

               // Allow the ISR to complete this IRP
           }
       }
   }
   else
   {
      // No characters have been read yet, so just resubmit the timeout.

      KeSetTimer(
          &extension->ReadRequestIntervalTimer,
          *extension->IntervalTimeToUse,
          &extension->IntervalReadTimeoutDpc
          );

      IoReleaseCancelSpinLock(oldIrql);

#ifdef TIMEOUT_TRACING
      ExtTrace(extension,D_Read," No data A, Resubmit.");
#endif
   }
}

/*------------------------------------------------------------------
  SerialGrabReadFromIsr - Take back the read packet from the ISR by
   reseting ReadPending flag in extension.  Need to use a sync with
   isr/timer routine to avoid contention in multiprocessor environments.

   Called from sync routine or with timer spinlock held.

  App - Can set ReadPending to give read-irp handling to the ISR without
    syncing to ISR.
  ISR - Can reset ReadPending to give read-irp handling back to app-time.

  If App wants to grab control of read-irp handling back from ISR, then
  it must sync-up with the isr/timer routine which has control.
|-------------------------------------------------------------------*/
BOOLEAN SerialGrabReadFromIsr(PSERIAL_DEVICE_EXTENSION Extension)
{
  Extension->ReadPending = FALSE;
  SERIAL_CLEAR_REFERENCE(Extension->CurrentReadIrp, SERIAL_REF_ISR);
  return FALSE;
}

/*------------------------------------------------------------------
Routine Description:
    This routine is used to copy any characters out of the interrupt
    buffer into the users buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.
Arguments:
    Extension - A pointer to the device extension.
Return Value:
    The number of characters that were copied into the user
    buffer.
|-------------------------------------------------------------------*/
ULONG SerialGetCharsFromIntBuffer(PSERIAL_DEVICE_EXTENSION Extension)
{
   LONG RxCount;
   LONG WrapCount = 0L;

   // See how much data we have in RxBuf (host-side buffer)
   // RxCount signed here for buffer wrap testing
   RxCount = q_count(&Extension->RxQ);

   // Check for a zero count in RxBuf
   if (RxCount == 0)
      return 0L;

   // Send back only as much as the application asked for...
   // RxCount unsigned here (will always be positive at this point)
   if (Extension->NumberNeededForRead < (ULONG)RxCount)
      RxCount = Extension->NumberNeededForRead;

   // Check for a buffer wrap 
   WrapCount = q_room_get_till_wrap(&Extension->RxQ);
   if (RxCount > WrapCount)  // wrap is required
   {
      // RtlMoveMemory(
      memcpy(
         (PUCHAR)(Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer) + 
         Extension->CurrentReadIrp->IoStatus.Information,
         Extension->RxQ.QBase + Extension->RxQ.QGet,
         WrapCount);

      // RtlMoveMemory(
      memcpy(
         (PUCHAR)(Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer) + 
         Extension->CurrentReadIrp->IoStatus.Information + WrapCount,
         Extension->RxQ.QBase,
         RxCount - WrapCount);
   }
   else //--- single move ok
   {
      // RtlMoveMemory(
      memcpy(
         (PUCHAR)(Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer) + 
         Extension->CurrentReadIrp->IoStatus.Information,
         Extension->RxQ.QBase + Extension->RxQ.QGet,
         RxCount);
   }
   // Update host side buffer ptrs
   Extension->RxQ.QGet = (Extension->RxQ.QGet + RxCount) % Extension->RxQ.QSize;
   Extension->CurrentReadIrp->IoStatus.Information += RxCount;
   Extension->NumberNeededForRead -= RxCount;

   return RxCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\rcktioct.h ===
// Following are private I/O control codes for the rocket port
#define IOCTL_RCKT_GET_STATS \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_CHECK \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x801,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_CLR_STATS \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x802,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_ISR_CNT \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x803,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_MONALL \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x804,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RCKT_SET_LOOPBACK_ON \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x805,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_SET_LOOPBACK_OFF \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x806,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RCKT_SET_TOGGLE_LOW \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x807,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_CLEAR_TOGGLE_LOW \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x808,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RCKT_SET_MODEM_RESET_OLD \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x809,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_CLEAR_MODEM_RESET_OLD \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80a,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_GET_RCKTMDM_INFO_OLD \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80b,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_SEND_MODEM_ROW_OLD \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80c,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_SET_MODEM_RESET \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80d,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_CLEAR_MODEM_RESET \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80e,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_SEND_MODEM_ROW \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80f,METHOD_BUFFERED,FILE_ANY_ACCESS)


//----- following struct is for passing info back to a manager/debugger.
typedef struct {
  USHORT  struct_size;   // our struct size for version control
  USHORT  status;        // return status
  char  port_name[12]; // COM#
  ULONG handle;       // handle, alternate to port_name
  char  reserved[20]; // room for extra growth

  char data[1000];    // general data area
} Tracer;

typedef struct {
    LONG receiveFifo;
    LONG transmitFifo;
    LONG receiveBytes;
    LONG transmitBytes;
    LONG parityErrors;
    LONG framingErrors;
    LONG overrunSoftware;
    LONG overrunHardware;
} PortStats;

typedef struct {
    ULONG trace_info;
    ULONG int_counter;
    ULONG WriteDpc_counter;
    ULONG Timer_counter;
    ULONG Poll_counter;
} Global_Track;

// following is a structure for a port which the driver will return
// information on.  The driver will return this information for every
// port(assume ptr to an array of up to 128 port_mon_structs) in one
// call to the driver.  Will query driver every X seconds for this
// data to generate statistics on port.  The structure list is terminated
// by a structure with port_name[0] = 0.
typedef struct
{
  char  port_name[12];  // port name(0=end of port list),("."=not assigned)
  ULONG sent_bytes;     // total number of sent bytes
  ULONG rec_bytes;      // total number of receive bytes

  USHORT sent_packets;   // number of write() packets
  USHORT rec_packets;    // number of read() packets

  USHORT overrun_errors; // receive over-run errors
  USHORT framing_errors; // receive framing errors

  USHORT parity_errors;  // receive parity errors
  USHORT status_flags;   // opened/close, flow-ctrl, out/in pin signals, etc

  USHORT function_bits;  // bits set on to indicate function call
  USHORT spare1;         // some room for expansion(& stay on 4x boundary)
} PortMon;


typedef struct
{
  ULONG struct_type;
  ULONG struct_size;
  ULONG num_structs;
  ULONG var1;  // reserve
} PortMonBase;

typedef struct
{
  char  port_name[12];  // port name(0=end of port list),("."=not assigned)
} PortMonNames;


typedef struct
{
  ULONG sent_bytes;     // total number of sent bytes
  ULONG rec_bytes;      // total number of receive bytes

  USHORT sent_packets;   // number of write() packets
  USHORT rec_packets;    // number of read() packets

  USHORT overrun_errors; // receive over-run errors
  USHORT framing_errors; // receive framing errors

  USHORT parity_errors;  // receive parity errors
  USHORT status_flags;   // opened/close, flow-ctrl, out/in pin signals, etc
} PortMonStatus;


// following are structures that are used to query the driver for information
// about RocketModem boards installed in the system.  this information is
// primarily used by the user program used to manually reset the hardware on
// the newer generation RocketModem boards.  [jl] 980308
typedef struct
{
  ULONG num_rktmdm_ports;   // 0 if != rocketmodem, >0 = # ports (4 or 8)
  char port_names[8][16];   // array of port names assigned to this board
} RktBoardInfo;

typedef struct
{
  ULONG         struct_size;
  ULONG         rm_country_code; // RocketModem country code
  ULONG         rm_settle_time;  // RocketModem settle time
  RktBoardInfo  rm_board_cfg[4];
} RocketModemConfig;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\read.h ===
//---- read.h

NTSTATUS
SerialRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartRead(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SerialCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID
SerialReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

ULONG
SerialGetCharsFromIntBuffer(
    PSERIAL_DEVICE_EXTENSION Extension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\ssci.h ===
/*-------------------------------------------------------------------
  ssci.h - Whole slew of macros for talking to RocketPort hardware.
Copyright 1993-96 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
//#include "ntddk.h"
//#include <conio.h> i hate includes of includes

#define CHANPTR_T CHANNEL_T *
#define ULONGPTR_T unsigned long *
#define CTL_SIZE 4                  /* max number of controllers in system */

typedef PUCHAR BIOA_T;              /* byte I/O address */
typedef PUSHORT WIOA_T;             /* word I/O address */
typedef PULONG DWIOA_T;             /* double word I/O address */

#define _CDECL

#define TRUE 1
#define FALSE 0

#define MCODE1_SIZE 72              /* number of bytes in microcode array */
#define MCODE1REG_SIZE 52           /* number bytes in microcode reg array */
#define AIOP_CTL_SIZE 4             /* max number AIOPs per controller */
#define CHAN_AIOP_SIZE 8            /* max number channels per AIOP */
// #define NULLDEV -1                  /* identifies non-existant device */
// #define NULLCTL -1                  /* identifies non-existant controller */
// #define NULLCTLPTR (CONTROLLER_T *)0 /* identifies non-existant controller */
// #define NULLAIOP -1                 /* identifies non-existant AIOP */
// #define NULLCHAN -1                 /* identifies non-existant channel */
#define MAXTX_SIZE 250           /* max number of bytes allowed in Tx FIFO */

#define CHANINT_EN 0x0100           /* flags to enable/disable channel ints */

/*
	the revision field is used to extend	the PCI device identifications...
*/
#define	PCI_REVISION_RMODEM_SOC	0x00
#define	PCI_REVISION_RMODEM_II	0x01

/* Controller ID numbers */
// #define CTLID_NULL  -1              /* no controller exists */
#define CTLID_0001  0x0001          /* controller release 1 */

/* PCI Defines(have moved to opstr.h) */

/* AIOP ID numbers, identifies AIOP type implementing channel */
#define AIOPID_NULL -1              /* no AIOP or channel exists */
#define AIOPID_0001 0x0001          /* AIOP release 1 */

#define RX_HIWATER 512                 /* sw input flow ctl high water mark */
#define RX_LOWATER 256                 /* sw input flow ctl low water mark */

#define OFF      0
#define ON       1
#define NOCHANGE 2

/* Error flags for RocketPort */
#define ERR_PARITY 0x01          /* parity error */

//Status
/* Open type and TX and RX identifier flags (unsigned int) */
#define COM_OPEN     0x0001            /* device open */
#define COM_TX       0x0002            /* transmit */
#define COM_RX       0x0004            /* receive */

//Status
/* Flow control flags (unsigned int) */
#define COM_FLOW_NONE  0x0000
#define COM_FLOW_IS    0x0008          /* input software flow control */
#define COM_FLOW_IH    0x0010          /* input hardware flow control */
#define COM_FLOW_OS    0x0020          /* output software flow control */
#define COM_FLOW_OH    0x0040          /* output hardware flow control */
#define COM_FLOW_OXANY 0x0080          /* restart output on any Rx char */
#define COM_RXFLOW_ON  0x0100          /* Rx data flow is ON */
#define COM_TXFLOW_ON  0x0200          /* Tx data flow is ON */

//Status ... State flags
#define COM_REQUEST_BREAK 0x0400

/* Modem control flags (unsigned char) */
#define COM_MDM_RTS   0x02             /* request to send */
#define COM_MDM_DTR   0x04             /* data terminal ready */
#define COM_MDM_CD    CD_ACT           /* carrier detect (0x08) */
#define COM_MDM_DSR   DSR_ACT          /* data set ready (0x10) */
#define COM_MDM_CTS   CTS_ACT          /* clear to send (0x20) */

/* Stop bit flags (unsigned char) */
#define COM_STOPBIT_1  0x01            /* 1 stop bit */
#define COM_STOPBIT_2  0x02            /* 2 stop bits */

/* Data bit flags (unsigned char) */
#define COM_DATABIT_7  0x01            /* 7 data bits */
#define COM_DATABIT_8  0x02            /* 8 data bits */

/* Parity flags (unsigned char) */
#define COM_PAR_NONE   0x00            /* no parity */
#define COM_PAR_EVEN   0x02            /* even parity */
#define COM_PAR_ODD    0x01            /* odd parity */

/* Detection enable flags (unsigned int) */
#define COM_DEN_NONE     0         /* no event detection enabled */
#define COM_DEN_MDM      0x0001    /* enable modem control change detection */
#define COM_DEN_RDA      0x0002    /* enable Rx data available detection */

// Driver controller information
#define DEV_SIZE 128                 /* maximum number devices */
#define SPANOFMUDBAC             0x04        // 4 bytes    
#define SPANOFAIOP               0x40        // 64 bytes

#ifdef COMMENT_OUT
/* Configuration information for all controllers */
typedef struct
{
   int Irq;                            /* IRQ number */
   int NumCtl;                         /* number of controllers in system */
//   int NumDev;                         /* number of devices in the system */
//   int InterruptingCtl;                /* indicates the ctl that interrupts */
   int FirstISA;                       /* first isa so know where to start mudbacks */
   CFCTL_T CfCtl[CTL_SIZE];
} CF_T;
#endif

/* Controller level information structure */
/* The interrupt strobe bit of MUDBAC register 2 is never stored in Reg2
   because it is write only */
typedef struct
{
   int CtlID;                       /* controller ID */
   //int CtlNum;                      /* controller number */
   INTERFACE_TYPE BusType;          /* PCIBus or Isa  */
   unsigned char PCI_Slot;
   unsigned char BusNumber;
   USHORT PCI1;
   WIOA_T PCI1IO;                   /* I/O address for Pci register */
   BIOA_T MBaseIO;                  /* I/O address for MUDBAC */
   BIOA_T MReg1IO;                  /* I/O address for MUDBAC register 1 */
   BIOA_T MReg2IO;                  /* I/O address for MUDBAC register 2 */
   BIOA_T MReg3IO;                  /* I/O address for MUDBAC register 3 */
   unsigned char MReg2;             /* copy of MUDBAC register 2 */
   unsigned char MReg3;             /* copy of MUDBAC register 3 */
   int NumAiop;                     /* number of AIOPs on the controller */
   WIOA_T AiopIO[AIOP_CTL_SIZE];    /* AIOP's base I/O address */
   BIOA_T AiopIntChanIO[AIOP_CTL_SIZE]; /* AIOP's Int Chan Reg I/O add */
   int AiopID[AIOP_CTL_SIZE];       /* AIOP ID, or -1 if no AIOP exists */
   int AiopNumChan[AIOP_CTL_SIZE];  /* number of channels in AIOP */

   BYTE PortsPerAiop;   // normally 8, but rplus this is 4
   BYTE ClkPrescaler;
   ULONG ClkRate;
   int PCI_DevID;
   int PCI_RevID;		// due to odd PCI controller design, must use RevID to extend device IDs...
   int PCI_SVID;
   int PCI_SID;

} CONTROLLER_T;


/* Channel level information structure */
typedef struct
{
   /* Channel, AIOP, and controller identifiers */
   CONTROLLER_T *CtlP;          /* ptr to controller information structure */
   int AiopNum;                 /* AIOP number on the controller */
   int  ChanID;                 /* channel ID - indentifies type of AIOP */
   int ChanNum;                 /* channel within AIOP */

   /* Maximum number bytes allowed in Tx FIFO */
   int TxSize;

   /* AIOP's global direct register addresses */
   BIOA_T  Cmd;                  /* AIOP's Command register */
   BIOA_T  IntChan;              /* AIOP's Interrupt channel register */
   BIOA_T  IntMask;              /* AIOP's Interrupt mask register */
   DWIOA_T  IndexAddr;           /* AIOP's Index Register */
   WIOA_T  IndexData;            /* AIOP's Index Register Data */

   /* Channel's direct register addresses */
   WIOA_T  TxRxData;             /* Transmit and Receive register address */
   WIOA_T  ChanStat;             /* Channel Status register address */
   WIOA_T  TxRxCount;            /* Tx and Rx FIFO count register address */
   BIOA_T  IntID;                /* Interrupt ID register address */

   /* Channel indirect register addresses */
   unsigned int TxFIFO;         /* transmit FIFO */
   unsigned int TxFIFOPtrs;     /* transmit FIFO out and in ptrs */
   unsigned int RxFIFO;         /* receive FIFO */
   unsigned int RxFIFOPtrs;     /* receive FIFO out and in ptrs */
   unsigned int TxPrioCnt;      /* transmit priority count */
   unsigned int TxPrioPtr;      /* transmit priority ptr */
   unsigned int TxPrioBuf;      /* transmit priority buffer */

   /* Copy of channel's microcode */
   unsigned char MCode[MCODE1REG_SIZE]; /* channel's microcode registers */

   /* Control register save values */
   unsigned char BaudDiv[4];       /* baud rate divisor for channel */
   unsigned char TxControl[4];     /* transmit control register vals */
   unsigned char RxControl[4];     /* receive control register vals */
   unsigned char TxEnables[4];     /* transmit processor enable vals */
   unsigned char TxCompare[4];     /* transmit compare values 1 & 2 */
   unsigned char TxReplace1[4];    /* transmit replace value 1 - bytes 1 & 2 */
   unsigned char TxReplace2[4];    /* transmit replace value 2 */
} CHANNEL_T;

//--------------------------- Function prototypes
int sInitController(CONTROLLER_T *CtlP,
                    //int CtlNum,
                    BIOA_T MudbacIO,
                    BIOA_T *AiopIOList,
                    unsigned int *PhyAiopIOList,
                    int AiopIOListSize,
                    int IRQNum,
                    unsigned char Frequency,
                    int PeriodicOnly,
                    int BusType,
                    int prescaler);
int _CDECL sReadAiopID(BIOA_T io);
int _CDECL sReadAiopNumChan(WIOA_T io);
int _CDECL sInitChan(CONTROLLER_T *CtlP,
                     CHANPTR_T ChP,
                     int AiopNum,
                     int ChanNum);
unsigned char _CDECL sGetRxErrStatus(CHANPTR_T ChP);
void _CDECL sSetParity(CHANPTR_T ChP,int Parity);
void _CDECL sStopRxProcessor(CHANPTR_T ChP);
void _CDECL sStopSWInFlowCtl(CHANPTR_T ChP);
void _CDECL sFlushRxFIFO(CHANPTR_T ChP);
void _CDECL sFlushTxFIFO(CHANPTR_T ChP);
int _CDECL sFlushTxPriorityBuf(CHANPTR_T ChP,unsigned char *Data);
unsigned char _CDECL sGetTxPriorityCnt(CHANPTR_T ChP);
int _CDECL sReadRxBlk(CHANPTR_T ChP,unsigned char *Buffer,int Count);
ULONG _CDECL sWriteTxBlk(CHANPTR_T ChP,PUCHAR Buffer,ULONG Count);
int _CDECL sWriteTxPrioBlk(CHANPTR_T ChP,unsigned char *Buffer,int Count);
int _CDECL sWriteTxPrioByte(CHANPTR_T ChP,unsigned char Data);
void _CDECL sEnInterrupts(CHANPTR_T ChP,unsigned int Flags);
void _CDECL sDisInterrupts(CHANPTR_T ChP,unsigned int Flags);
void _CDECL sReadMicrocode(CHANPTR_T ChP,char *Buffer,int Count);
int sSetBaudRate(CHANNEL_T *ChP,
                 ULONG desired_baud,
                 USHORT SetHardware);
void sChanOutWI(CHANNEL_T *ChP, USHORT RegNum, ULONG  val);
void sModemReset(CHANNEL_T *ChP, int on);
void sModemWriteROW(CHANNEL_T *ChP, USHORT CountryCode);
void sModemWriteDelay(CHANNEL_T *ChP,char *string, int length);
void sModemWrite(CHANNEL_T *ChP,char *string,int length);
void sModemSpeakerEnable(CHANNEL_T *ChP);
int  sModemRead(CHANNEL_T *ChP,char *string,int length,int poll_retries);
int  sModemReadChoice(CHANNEL_T *ChP,char *string0,int length0,char *string1,int length1,int poll_retries);
int  sTxFIFOReady(CHANNEL_T *ChP);
int  sTxFIFOStatus(CHANNEL_T *ChP);
int  sRxFIFOReady(CHANNEL_T *ChP);


/*-------------------------------------------------------------------
Function: sClrBreak
Purpose:  Stop sending a transmit BREAK signal
Call:     sClrBreak(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sClrBreak(CHP) \
{ \
   (CHP)->TxControl[3] &= ~SETBREAK; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sClrDTR
Purpose:  Clr the DTR output
Call:     sClrDTR(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sClrDTR(CHP) \
{ \
   (CHP)->TxControl[3] &= ~SET_DTR; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sClrNextInBitMap
Purpose:  Clear the bit within a bit map of the next number needing service.
Call:     sGetNextInBitMap(BitMap,Number)
          unsigned char BitMap; The bit map.  Since this is a macro, the
                   variable holding the bit map can be passed directly, rather
                   than a pointer to the variable.
          int Number; Next number needing service.  This is the same number
                      returned from the preceeding call to sGetNextInBitMap().
Return:   void
Comments: This function should be called immediately after calling
          sGetNextInBitMap().

---------------------------------------------------------------------*/
//#define sClrNextInBitMap(BITMAP,NUMBER) (BITMAP) &= sBitMapClrTbl[NUMBER]

/*-------------------------------------------------------------------
Function: sClrRTS
Purpose:  Clr the RTS output
Call:     sClrRTS(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sClrRTS(CHP) \
{ \
   (CHP)->TxControl[3] &= ~SET_RTS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sClrTxXOFF
Purpose:  Clear any existing transmit software flow control off condition
Call:     sClrTxXOFF(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sClrTxXOFF(CHP) \
{ \
   sOutB((PUCHAR)(CHP)->Cmd,(unsigned char)(TXOVERIDE | (CHP)->ChanNum)); \
   sOutB((PUCHAR)(CHP)->Cmd,(unsigned char)(CHP)->ChanNum); \
}

/*-------------------------------------------------------------------
Function: sPCIControllerEOI
Purpose:  Strobe the PCI End Of Interrupt bit.
Call:     sPCIControllerEOI(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   void
---------------------------------------------------------------------*/
//#define sPCIControllerEOI(CTLP) sOutB(((BIOA_T)(CTLP)->AiopIO[0]+_PCI_INT_FUNC),(unsigned char)(PCI_STROBE));
#define sPCIControllerEOI(CTLP) sOutW((CTLP)->PCI1IO, \
                                      (USHORT)((CTLP)->PCI1 | PCI_STROBE))

/*-------------------------------------------------------------------
Function: sControllerEOI
Purpose:  Strobe the MUDBAC's End Of Interrupt bit.
Call:     sControllerEOI(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   void
---------------------------------------------------------------------*/
#define sControllerEOI(CTLP) sOutB((PUCHAR)(CTLP)->MReg2IO,(unsigned char)((CTLP)->MReg2 | INT_STROB))

/*-------------------------------------------------------------------
Function: sDisAiop
Purpose:  Disable I/O access to an AIOP
Call:     sDisAiop(CltP)
          CONTROLLER_T *CtlP; Ptr to controller structure
          int AiopNum; Number of AIOP on controller
Return:   void
---------------------------------------------------------------------*/
#define sDisAiop(CTLP,AIOPNUM) \
{ \
   (CTLP)->MReg3 &= (~(1 << (AIOPNUM))); \
   sOutB((CTLP)->MReg3IO,(CTLP)->MReg3); \
}

/*-------------------------------------------------------------------
Function: sDisCTSFlowCtl
Purpose:  Disable output flow control using CTS
Call:     sDisCTSFlowCtl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sDisCTSFlowCtl(CHP) \
{ \
   (CHP)->TxControl[2] &= ~CTSFC_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sDisGlobalInt
Purpose:  Disable global interrupts for a controller
Call:     sDisGlobalInt(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   void
---------------------------------------------------------------------*/
#define sDisGlobalInt(CTLP) \
{ \
   (CTLP)->MReg2 &= ~INTR_EN; \
   sOutB((CTLP)->MReg2IO,(CTLP)->MReg2); \
}

/*-------------------------------------------------------------------
Function: sDisIXANY
Purpose:  Disable IXANY Software Flow Control
Call:     sDisIXANY(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sDisIXANY(CHP) \
{ \
   (CHP)->MCode[IXANY_DATA] = IXANY_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IXANY_OUT]); \
}

/*-------------------------------------------------------------------
Function: sDisLocalLoopback
Purpose:  Disable local loopback of transmit to receive
Call:     sDisLocalLoopback(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sDisLocalLoopback(CHP) \
{ \
   (CHP)->TxControl[3] &= ~LOCALLOOP; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: DisParity
Purpose:  Disable parity
Call:     sDisParity(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: Function sSetParity() can be used in place of functions sEnParity(),
          sDisParity(), sSetOddParity(), and sSetEvenParity().
---------------------------------------------------------------------*/
#define sDisParity(CHP) \
{ \
   (CHP)->TxControl[2] &= ~PARITY_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sDisRTSFlowCtl
Purpose:  Disable input flow control using RTS
Call:     sDisRTSFlowCtl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sDisRTSFlowCtl(CHP) \
{ \
   (CHP)->RxControl[2] &= ~RTSFC_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->RxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sDisRTSToggle
Purpose:  Disable RTS toggle
Call:     sDisRTSToggle(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sDisRTSToggle(CHP) \
{ \
   (CHP)->TxControl[2] &= ~RTSTOG_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sDisRxCompare1
Purpose:  Disable Rx compare byte 1
Call:     sDisRxCompare1(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function is used to disable Rx replace 1, Rx ignore 1,
          and Rx compare and interrupt 1.
---------------------------------------------------------------------*/
#define sDisRxCompare1(CHP) \
{ \
   (CHP)->MCode[RXCMP1_DATA] = RXCMP1_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP1_OUT]); \
   (CHP)->MCode[IGREP1_DATA] = IG_REP1_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP1_OUT]); \
   (CHP)->MCode[INTCMP1_DATA] = INTCMP1_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP1_OUT]); \
}

/*-------------------------------------------------------------------
Function: sDisRxCompare0
Purpose:  Disable Rx compare byte 0
Call:     sDisRxCompare0(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function is used to disable Rx ignore 0,
---------------------------------------------------------------------*/
#define sDisRxCompare0(CHP) \
{ \
   (CHP)->MCode[IGNORE0_DATA] = IGNORE0_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGNORE0_OUT]); \
}

/*-------------------------------------------------------------------
Function: sDisRxCompare2
Purpose:  Disable Rx compare byte 2
Call:     sDisRxCompare2(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function is used to disable Rx replace 2, Rx ignore 2,
          and Rx compare and interrupt 2.
---------------------------------------------------------------------*/
#define sDisRxCompare2(CHP) \
{ \
   (CHP)->MCode[RXCMP2_DATA] = RXCMP2_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP2_OUT]); \
   (CHP)->MCode[IGREP2_DATA] = IG_REP2_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP2_OUT]); \
   (CHP)->MCode[INTCMP2_DATA] = INTCMP2_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP2_OUT]); \
}

/*-------------------------------------------------------------------
Function: sDisRxFIFO
Purpose:  Disable Rx FIFO
Call:     sDisRxFIFO(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sDisRxFIFO(CHP) \
{ \
   (CHP)->MCode[RXFIFO_DATA] = RXFIFO_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXFIFO_OUT]); \
}

/*-------------------------------------------------------------------
Function: sDisRxStatusMode
Purpose:  Disable the Rx status mode
Call:     sDisRxStatusMode(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This takes the channel out of the receive status mode.  All
          subsequent reads of receive data using sReadRxWord() will return
          two data bytes.
---------------------------------------------------------------------*/
#define sDisRxStatusMode(CHP) sOutW((CHP)->ChanStat,0)

/*-------------------------------------------------------------------
Function: sDisTransmit
Purpose:  Disable transmit
Call:     sDisTransmit(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
          This disables movement of Tx data from the Tx FIFO into the 1 byte
          Tx buffer.  Therefore there could be up to a 2 byte latency
          between the time sDisTransmit() is called and the transmit buffer
          and transmit shift register going completely empty.
---------------------------------------------------------------------*/
#define sDisTransmit(CHP) \
{ \
   (CHP)->TxControl[3] &= ~TX_ENABLE; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sDisTxCompare1
Purpose:  Disable Tx compare byte 1
Call:     sDisTxCompare1(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function is used to disable Tx replace 1 with 1, Tx replace
          1 with 2, and Tx ignore 1.
---------------------------------------------------------------------*/
#define sDisTxCompare1(CHP) \
{ \
   (CHP)->TxEnables[2] &= ~COMP1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxEnables[0]); \
}

/*-------------------------------------------------------------------
Function: sDisTxCompare2
Purpose:  Disable Tx compare byte 2
Call:     sDisTxCompare2(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function is used to disable Tx replace 2 with 1 and Tx ignore 2.
---------------------------------------------------------------------*/
#define sDisTxCompare2(CHP) \
{ \
   (CHP)->TxEnables[2] &= ~COMP2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxEnables[0]); \
}

/*-------------------------------------------------------------------
Function: sDisTxSoftFlowCtl
Purpose:  Disable Tx Software Flow Control
Call:     sDisTxSoftFlowCtl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sDisTxSoftFlowCtl(CHP) \
{ \
   (CHP)->MCode[TXSWFC_DATA] = TXSWFC_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[TXSWFC_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnAiop
Purpose:  Enable I/O access to an AIOP
Call:     sEnAiop(CltP)
          CONTROLLER_T *CtlP; Ptr to controller structure
          int AiopNum; Number of AIOP on controller
Return:   void
---------------------------------------------------------------------*/
#define sEnAiop(CTLP,AIOPNUM) \
{ \
   (CTLP)->MReg3 |= (1 << (AIOPNUM)); \
   sOutB((CTLP)->MReg3IO,(CTLP)->MReg3); \
}

/*-------------------------------------------------------------------
Function: sEnCTSFlowCtl
Purpose:  Enable output flow control using CTS
Call:     sEnCTSFlowCtl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sEnCTSFlowCtl(CHP) \
{ \
   (CHP)->TxControl[2] |= CTSFC_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
 sIsCTSFlowCtlEnabled(CHP) -
|---------------------------------------------------------------------*/
#define sIsCTSFlowCtlEnabled(CHP) \
  { ((CHP)->TxControl[2] & CTSFC_EN) }

/*-------------------------------------------------------------------
Function: sDisGlobalIntPCI
Purpose:  Disable global interrupts for a controller
Call:     sDisGlobalIntPCI(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   void
---------------------------------------------------------------------*/
#define sDisGlobalIntPCI(CTLP) \
{ \
   (CTLP)->PCI1 &= ~INTR_EN_PCI; \
   sOutW((WIOA_T)CtlP->PCI1IO,(USHORT)CtlP->PCI1); \
}

/*-------------------------------------------------------------------
Function: sEnGlobalIntPCI
Purpose:  Enable global interrupts for a controller
Call:     sEnGlobalInt(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   void
---------------------------------------------------------------------*/
#define sEnGlobalIntPCI(CTLP) \
{ \
   (CTLP)->PCI1 |= INTR_EN_PCI; \
   sOutW(CtlP->PCI1IO,(USHORT)CtlP->PCI1); \
}

/*-------------------------------------------------------------------
Function: sEnGlobalInt
Purpose:  Enable global interrupts for a controller
Call:     sEnGlobalInt(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   void
---------------------------------------------------------------------*/
#define sEnGlobalInt(CTLP) \
{ \
   (CTLP)->MReg2 |= INTR_EN; \
   sOutB((CTLP)->MReg2IO,(CTLP)->MReg2); \
}

/*-------------------------------------------------------------------
Function: sEnIXANY
Purpose:  Enable IXANY Software Flow Control
Call:     sEnIXANY(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sEnIXANY(CHP) \
{ \
   (CHP)->MCode[IXANY_DATA] = IXANY_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IXANY_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnLocalLoopback
Purpose:  Enable local loopback of transmit to receive
Call:     sEnLocalLoopback(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sEnLocalLoopback(CHP) \
{ \
   (CHP)->TxControl[3] |= LOCALLOOP; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: EnParity
Purpose:  Enable parity
Call:     sEnParity(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: Function sSetParity() can be used in place of functions sEnParity(),
          sDisParity(), sSetOddParity(), and sSetEvenParity().

Warnings: Before enabling parity odd or even parity should be chosen using
          functions sSetOddParity() or sSetEvenParity().
---------------------------------------------------------------------*/
#define sEnParity(CHP) \
{ \
   (CHP)->TxControl[2] |= PARITY_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sEnRTSFlowCtl
Purpose:  Enable input flow control using RTS
Call:     sEnRTSFlowCtl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Warnings: RTS toggle and the RTS output will be both be cleared by this
          function.  The original state of RTS toggle and RTS output will
          not be preserved after a subsequent call to sDisRTSFlowCtl().
---------------------------------------------------------------------*/
#define sEnRTSFlowCtl(CHP) \
{ \
   (CHP)->TxControl[2] &= ~RTSTOG_EN; \
   (CHP)->TxControl[3] &= ~SET_RTS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
   (CHP)->RxControl[2] |= RTSFC_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->RxControl[0]); \
}

/*-------------------------------------------------------------------
 sIsRTSFlowCtlEnabled
---------------------------------------------------------------------*/
#define sIsRTSFlowCtlEnabled(CHP) \
   { ((CHP)->TxControl[2] & RTSTOG_EN) }

/*-------------------------------------------------------------------
Function: sEnRTSToggle
Purpose:  Enable RTS toggle
Call:     sEnRTSToggle(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function will disable RTS flow control and clear the RTS
          line to allow operation of RTS toggle.
---------------------------------------------------------------------*/
#define sEnRTSToggle(CHP) \
{ \
   (CHP)->RxControl[2] &= ~RTSFC_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->RxControl[0]); \
   (CHP)->TxControl[2] |= RTSTOG_EN; \
   (CHP)->TxControl[3] &= ~SET_RTS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sEnRxFIFO
Purpose:  Enable Rx FIFO
Call:     sEnRxFIFO(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sEnRxFIFO(CHP) \
{ \
   (CHP)->MCode[RXFIFO_DATA] = RXFIFO_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXFIFO_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnRxIgnore0
Purpose:  Enable compare of Rx data with compare byte #1 and ignore (discard)
          that byte if a match is found.
Call:     sEnRxIgnore0(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function enables comparison of the receive data byte
          with CmpByte.  The comparison is done after the receive data
          byte has been masked (see sSetRxMask()).  If a match is found the
          receive data byte is ignored (discarded).

          Rx ignore 0 can be disabled with sDisRxCompare0().
---------------------------------------------------------------------*/
#define sEnRxIgnore0(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL0_DATA] = (CMPBYTE); \
   (CHP)->MCode[IGNORE0_DATA] = IGNORE0_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGNORE0_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnRxIgnore1
Purpose:  Enable compare of Rx data with compare byte #1 and ignore (discard)
          that byte if a match is found.
Call:     sEnRxIgnore1(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function enables comparison of the receive data byte
          with CmpByte.  The comparison is done after the receive data
          byte has been masked (see sSetRxMask()).  If a match is found the
          receive data byte is ignored (discarded).

          Rx ignore 1 can be disabled with sDisRxCompare1().
---------------------------------------------------------------------*/
#define sEnRxIgnore1(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL1_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL1_OUT]); \
   (CHP)->MCode[RXCMP1_DATA] = RXCMP1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP1_OUT]); \
   (CHP)->MCode[INTCMP1_DATA] = INTCMP1_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP1_OUT]); \
   (CHP)->MCode[IGREP1_DATA] = IGNORE1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP1_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnRxIgnore2
Purpose:  Enable compare of Rx data with compare byte #2 and ignore (discard)
          that byte if a match is found.
Call:     sEnRxIgnore2(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function enables comparison of the receive data byte
          with CmpByte.  The comparison is done after the receive data
          byte has been masked (see sSetRxMask()).  If a match is found the
          receive data byte is ignored (discarded).

          Rx ignore 2 can be disabled with sDisRxCompare2().
---------------------------------------------------------------------*/
#define sEnRxIgnore2(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL2_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL2_OUT]); \
   (CHP)->MCode[RXCMP2_DATA] = RXCMP2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP2_OUT]); \
   (CHP)->MCode[INTCMP2_DATA] = INTCMP2_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP2_OUT]); \
   (CHP)->MCode[IGREP2_DATA] = IGNORE2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP2_OUT]); \
}


/*-------------------------------------------------------------------
Function: sEnRxIntCompare1
Purpose:  Enable compare of Rx data with compare byte #1 and interrupt
          if a match is found.
Call:     sEnRxIntCompare1(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function enables comparison of the receive data byte
          with CmpByte.  The comparison is done after the receive data
          byte has been masked (see sSetRxMask()).  If a match is found an
          interrupt is generated after adding the data byte to the receive
          FIFO.

          Rx compare interrupt 1 can be disabled with sDisRxCompare1().

Warnings: Before an interrupt will be generated SRC interrupts must be
          enabled (see sEnInterrupts()).
---------------------------------------------------------------------*/
#define sEnRxIntCompare1(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL1_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL1_OUT]); \
   (CHP)->MCode[RXCMP1_DATA] = RXCMP1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP1_OUT]); \
   (CHP)->MCode[IGREP1_DATA] = IG_REP1_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP1_OUT]); \
   (CHP)->MCode[INTCMP1_DATA] = INTCMP1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP1_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnRxIntCompare2
Purpose:  Enable compare of Rx data with compare byte #2 and interrupt
          if a match is found.
Call:     sEnRxIntCompare2(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function enables comparison of the receive data byte
          with CmpByte.  The comparison is done after the receive data
          byte has been masked (see sSetRxMask()).  If a match is found an
          interrupt is generated after adding the data byte to the receive
          FIFO.

          Rx compare interrupt 2 can be disabled with sDisRxCompare2().

Warnings: Before an interrupt will be generated SRC interrupts must be
          enabled (see sEnInterrupts()).
---------------------------------------------------------------------*/
#define sEnRxIntCompare2(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL2_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL2_OUT]); \
   (CHP)->MCode[RXCMP2_DATA] = RXCMP2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP2_OUT]); \
   (CHP)->MCode[IGREP2_DATA] = IG_REP2_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP2_OUT]); \
   (CHP)->MCode[INTCMP2_DATA] = INTCMP2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP2_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnRxProcessor
Purpose:  Enable the receive processor
Call:     sEnRxProcessor(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function is used to start the receive processor.  When
          the channel is in the reset state the receive processor is not
          running.  This is done to prevent the receive processor from
          executing invalid microcode instructions prior to the
          downloading of the microcode.

Warnings: This function must be called after valid microcode has been
          downloaded to the AIOP, and it must not be called before the
          microcode has been downloaded.
---------------------------------------------------------------------*/
#define sEnRxProcessor(CHP) \
{ \
   (CHP)->RxControl[2] |= RXPROC_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->RxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sEnRxReplace1
Purpose:  Enable compare of Rx data with compare byte #1 and replacement
          with a single byte if a match is found.
Call:     sEnRxReplace1(ChP,CmpByte,ReplByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
          unsigned char ReplByte; Byte to replace Rx data byte with if
                                  a match is found on the compare.
Return:   void
Comments: This function enables comparison of the receive data byte
          with CmpByte.  The comparison is done after the receive data
          byte has been masked (see sSetRxMask()).  If a match is found
          the receive data byte is replaced by ReplByte.

          Rx replace 1 can be disabled with sDisRxCompare1().
---------------------------------------------------------------------*/
#define sEnRxReplace1(CHP,CMPBYTE,REPLBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL1_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL1_OUT]); \
   (CHP)->MCode[RXREPL1_DATA] = (REPLBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXREPL1_OUT]); \
   (CHP)->MCode[RXCMP1_DATA] = RXCMP1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP1_OUT]); \
   (CHP)->MCode[INTCMP1_DATA] = INTCMP1_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP1_OUT]); \
   (CHP)->MCode[IGREP1_DATA] = REPLACE1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP1_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnRxReplace2
Purpose:  Enable compare of Rx data with compare byte #2 and replacement
          with a single byte if a match is found.
Call:     sEnRxReplace2(ChP,CmpByte,ReplByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
          unsigned char ReplByte; Byte to replace Rx data byte with if
                                  a match is found on the compare.
Return:   void
Comments: This function enables comparison of the receive data byte
          with CmpByte.  The comparison is done after the receive data
          byte has been masked (see sSetRxMask()).  If a match is found
          the receive data byte is replaced by ReplByte.

          Rx replace 2 can be disabled with sDisRxCompare2().
---------------------------------------------------------------------*/
#define sEnRxReplace2(CHP,CMPBYTE,REPLBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL2_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL2_OUT]); \
   (CHP)->MCode[RXREPL2_DATA] = (REPLBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXREPL2_OUT]); \
   (CHP)->MCode[RXCMP2_DATA] = RXCMP2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMP2_OUT]); \
   (CHP)->MCode[INTCMP2_DATA] = INTCMP2_DIS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[INTCMP2_OUT]); \
   (CHP)->MCode[IGREP2_DATA] = REPLACE2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGREP2_OUT]); \
}

/*-------------------------------------------------------------------
Function: sEnRxStatusMode
Purpose:  Enable the Rx status mode
Call:     sEnRxStatusMode(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This places the channel in the receive status mode.  All subsequent
          reads of receive data using sReadRxWord() will return a data byte
          in the low word and a status byte in the high word.
---------------------------------------------------------------------*/
#define sEnRxStatusMode(CHP) sOutW((CHP)->ChanStat,STATMODE)

/*-------------------------------------------------------------------
Function: sEnTransmit
Purpose:  Enable transmit
Call:     sEnTransmit(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sEnTransmit(CHP) \
{ \
   (CHP)->TxControl[3] |= TX_ENABLE; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sEnTxIgnore1
Purpose:  Enable compare of Tx data with compare byte #1 and ignore (do not
          transmit) that byte if a match is found.
Call:     sEnTxIgnore1(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Tx data byte with
Return:   void
Comments: This function enables comparison of the transmit data byte
          with CmpByte.  If a match is found the transmit data byte
          is ignored, that is, it is not transmitted.

          Tx ignore 1 can be disabled with sDisTxCompare1().
---------------------------------------------------------------------*/
#define sEnTxIgnore1(CHP,CMPBYTE) \
{ \
   (CHP)->TxCompare[2] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxCompare[0]); \
   (CHP)->TxEnables[2] &= ~REP1W2_EN; \
   (CHP)->TxEnables[2] |= (COMP1_EN | IGN1_EN); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxEnables[0]); \
}

/*-------------------------------------------------------------------
Function: sEnTxIgnore2
Purpose:  Enable compare of Tx data with compare byte #2 and ignore (do not
          transmit) that byte if a match is found.
Call:     sEnTxIgnore2(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Tx data byte with
Return:   void
Comments: This function enables comparison of the transmit data byte
          with CmpByte.  If a match is found the transmit data byte
          is ignored, that is, it is not transmitted.

          Tx ignore 2 can be disabled with sDisTxCompare2().
---------------------------------------------------------------------*/
#define sEnTxIgnore2(CHP,CMPBYTE) \
{ \
   (CHP)->TxCompare[3] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxCompare[0]); \
   (CHP)->TxEnables[2] |= (COMP2_EN | IGN2_EN); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxEnables[0]); \
}

/*-------------------------------------------------------------------
Function: sEnTxReplace1With1
Purpose:  Enable compare of Tx data with compare byte #1 and replacement
          with a single byte if a match is found.
Call:     sEnTxReplace1With1(ChP,CmpByte,ReplByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Tx data byte with
          unsigned char ReplByte; Byte to replace Tx data byte with if
                                  a match is found on the compare.
Return:   void
Comments: This function enables comparison of the transmit data byte
          with CmpByte.  If a match is found the transmit data byte
          is replaced by ReplByte.

          Tx replace 1 with 1 can be disabled with sDisTxCompare1().
---------------------------------------------------------------------*/
#define sEnTxReplace1With1(CHP,CMPBYTE,REPLBYTE) \
{ \
   (CHP)->TxCompare[2] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxCompare[0]); \
   (CHP)->TxReplace1[2] = (REPLBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxReplace1[0]); \
   (CHP)->TxEnables[2] &= ~(REP1W2_EN | IGN1_EN); \
   (CHP)->TxEnables[2] |= COMP1_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxEnables[0]); \
}

/*-------------------------------------------------------------------
Function: sEnTxReplace1With2
Purpose:  Enable compare of Tx data with compare byte #1 and replacement
          with two bytes if a match is found.
Call:     sEnTxReplace1With2(ChP,CmpByte,ReplByte1,ReplByte2)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Tx data byte with
          unsigned char ReplByte1; First byte to replace Tx data byte with if
                                  a match is found on the compare.
          unsigned char ReplByte2; Second byte to replace Tx data byte with
                                  if a match is found on the compare.
Return:   void
Comments: This function enables comparison of the transmit data byte
          with CmpByte.  If a match is found the transmit data byte
          is replaced by bytes ReplByte1 and ReplByte2.  ReplByte1 will
          be transmitted first, ReplByte2 second.

          Tx replace 1 with 2 can be disabled with sDisTxCompare1().
---------------------------------------------------------------------*/
#define sEnTxReplace1With2(CHP,CMPBYTE,REPLBYTE1,REPLBYTE2) \
{ \
   (CHP)->TxCompare[2] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxCompare[0]); \
   (CHP)->TxReplace1[2] = (REPLBYTE1); \
   (CHP)->TxReplace1[3] = (REPLBYTE2); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxReplace1[0]); \
   (CHP)->TxEnables[2] &= ~IGN1_EN; \
   (CHP)->TxEnables[2] |= (COMP1_EN | REP1W2_EN); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxEnables[0]); \
}

/*-------------------------------------------------------------------
Function: sEnTxReplace2With1
Purpose:  Enable compare of Tx data with compare byte #2 and replacement
          with a single byte if a match is found.
Call:     sEnTxReplace2With1(ChP,CmpByte,ReplByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Tx data byte with
          unsigned char ReplByte; Byte to replace Tx data byte with if
                                  a match is found on the compare.
Return:   void
Comments: This function enables comparison of the transmit data byte
          with CmpByte.  If a match is found the transmit data byte
          is replaced by ReplByte.

          Tx replace 2 with 1 can be disabled with sDisTxCompare2().
---------------------------------------------------------------------*/
#define sEnTxReplace2With1(CHP,CMPBYTE,REPLBYTE) \
{ \
   (CHP)->TxCompare[3] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxCompare[0]); \
   (CHP)->TxReplace2[2] = (REPLBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxReplace2[0]); \
   (CHP)->TxEnables[2] &= ~IGN2_EN; \
   (CHP)->TxEnables[2] |= COMP2_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxEnables[0]); \
}

/*-------------------------------------------------------------------
Function: sEnTxSoftFlowCtl
Purpose:  Enable Tx Software Flow Control
Call:     sEnTxSoftFlowCtl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sEnTxSoftFlowCtl(CHP) \
{ \
   (CHP)->MCode[TXSWFC_DATA] = TXSWFC_EN; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[TXSWFC_OUT]); \
}

/*-------------------------------------------------------------------
  sIsTxSoftFlowCtlEnabled -
---------------------------------------------------------------------*/
#define sIsTxSoftFlowCtlEnabled(CHP) \
  ((CHP)->MCode[TXSWFC_DATA] == TXSWFC_EN)

/*-------------------------------------------------------------------
Function: sGetAiopID
Purpose:  Get the AIOP ID
Call:     sGetAiopID(CtlP,AiopNum)
          CONTROLLER_T *CtlP; Ptr to controller structure
          int AiopNum;
Return:   int: The AIOP ID if the AIOP exists, AIOPID_NULL if the
               AIOP does not exist.
Comments: The AIOP ID uniquely identifies the type of AIOP.
---------------------------------------------------------------------*/
#define sGetAiopID(CTLP,AIOPNUM) (CTLP)->AiopID[AIOPNUM]

/*-------------------------------------------------------------------
Function: sGetAiopIntStatus
Purpose:  Get the AIOP interrupt status
Call:     sGetAiopIntStatus(CtlP,AiopNum)
          CONTROLLER_T *CtlP; Ptr to controller structure
          int AiopNum; AIOP number
Return:   unsigned char: The AIOP interrupt status.  Bits 0 through 7
                         represent channels 0 through 7 respectively.  If a
                         bit is set that channel is interrupting.
---------------------------------------------------------------------*/
#define sGetAiopIntStatus(CTLP,AIOPNUM) sInB((CTLP)->AiopIntChanIO[AIOPNUM])

/*-------------------------------------------------------------------
Function: sGetAiopNumChan
Purpose:  Get the number of channels supported by an AIOP
Call:     sGetAiopNumChan(CtlP,AiopNum)
          CONTROLLER_T *CtlP; Ptr to controller structure
          int AiopNum; AIOP number
Return:   int: The number of channels supported by the AIOP
---------------------------------------------------------------------*/
#define sGetAiopNumChan(CTLP,AIOPNUM) (CTLP)->AiopNumChan[AIOPNUM]

/*-------------------------------------------------------------------
Function: sGetChanIntID
Purpose:  Get a channel's interrupt identification byte
Call:     sGetChanIntID(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: The channel interrupt ID.  Can be any
             combination of the following flags:
                RXF_TRIG:     Rx FIFO trigger level interrupt
                TXFIFO_MT:    Tx FIFO empty interrupt
                SRC_INT:      Special receive condition interrupt
                DELTA_CD:     CD change interrupt
                DELTA_CTS:    CTS change interrupt
                DELTA_DSR:    DSR change interrupt
---------------------------------------------------------------------*/
#define sGetChanIntID(CHP) (sInB((CHP)->IntID) & (RXF_TRIG | TXFIFO_MT | SRC_INT | DELTA_CD | DELTA_CTS | DELTA_DSR))

/*-------------------------------------------------------------------
Function: sGetChanNum
Purpose:  Get the number of a channel within an AIOP
Call:     sGetChanNum(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   int: Channel number within AIOP, or NULLCHAN if channel does
               not exist.
---------------------------------------------------------------------*/
#define sGetChanNum(CHP) (CHP)->ChanNum

/*-------------------------------------------------------------------
Function: sGetChanStatus
Purpose:  Get the channel status
Call:     sGetChanStatus(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned int: The channel status.  Can be any combination of
             the following flags:
                LOW BYTE FLAGS
                CTS_ACT:      CTS input asserted
                DSR_ACT:      DSR input asserted
                CD_ACT:       CD input asserted
                TXFIFOMT:     Tx FIFO is empty
                TXSHRMT:      Tx shift register is empty
                RDA:          Rx data available

                HIGH BYTE FLAGS
                STATMODE:     status mode enable bit
                RXFOVERFL:    receive FIFO overflow
                RX2MATCH:     receive compare byte 2 match
                RX1MATCH:     receive compare byte 1 match
                RXBREAK:      received BREAK
                RXFRAME:      received framing error
                RXPARITY:     received parity error
Warnings: This function will clear the high byte flags in the Channel
          Status Register.
---------------------------------------------------------------------*/
#define sGetChanStatus(CHP) sInW((CHP)->ChanStat)

/*-------------------------------------------------------------------
Function: sGetChanStatusLo
Purpose:  Get the low byte only of the channel status
Call:     sGetChanStatusLo(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: The channel status low byte.  Can be any combination
             of the following flags:
                CTS_ACT:      CTS input asserted
                DSR_ACT:      DSR input asserted
                CD_ACT:       CD input asserted
                TXFIFOMT:     Tx FIFO is empty
                TXSHRMT:      Tx shift register is empty
                RDA:          Rx data available
---------------------------------------------------------------------*/
#define sGetChanStatusLo(CHP) sInB((BIOA_T)(CHP)->ChanStat)

/*-------------------------------------------------------------------
Function: sGetControllerID
Purpose:  Get the controller ID
Call:     sGetControllerID(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   int: The controller ID if the controller exists, CTLID_NULL if
               the controller does not exist.
Comments: The controller ID uniquely identifies the type of controller.
---------------------------------------------------------------------*/
#define sGetControllerID(CTLP) (CTLP)->CtlID

/*-------------------------------------------------------------------
Function: sPCIGetControllerIntStatus
Purpose:  Get the controller interrupt status
Call:     sPCIGetControllerIntStatus(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   unsigned char: The controller interrupt status in the lower 4
                         bits and bit 4.  Bits 0 through 3 represent AIOP's 0
                         through 3 respectively.  Bit 4 is set if the  int
			 was generated from periodic.  If a bit is set that
                         AIOP is interrupting. 
---------------------------------------------------------------------*/
#define sPCIGetControllerIntStatus(CTLP) \
        ((sInW((CTLP)->PCI1IO) >> 8) & 0x1f)

/*-------------------------------------------------------------------
Function: sGetControllerIntStatus
Purpose:  Get the controller interrupt status
Call:     sGetControllerIntStatus(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   unsigned char: The controller interrupt status in the lower 4
                         bits.  Bits 0 through 3 represent AIOP's 0
                         through 3 respectively.  If a bit is set that
                         AIOP is interrupting.  Bits 4 through 7 will
                         always be cleared.
---------------------------------------------------------------------*/
#define sGetControllerIntStatus(CTLP) (sInB((CTLP)->MReg1IO) & 0x0f)

/*-------------------------------------------------------------------
Function: sGetControllerNumAiop
Purpose:  Get the number of AIOPs on a controller
Call:     sGetControllerNumAiop(CtlP)
          CONTROLLER_T *CtlP; Ptr to controller structure
Return:   int: The number of AIOPs on the controller.
---------------------------------------------------------------------*/
//#define sGetControllerNumAiop(CTLP) (CTLP)->NumAiop

/*-------------------------------------------------------------------
Function: sGetDevMap
Purpose:  Get an entry in the device map.
Call:     sGetDevMap(Ctl,Aiop,Chan)
          int Ctl; Controller number
          int Aiop; Aiop number within a controller
          int Chan; Channel number within an Aiop
Return:   int: The device number that Ctl, Aiop, and Chan map to, or NULLDEV
               if the device does not exist.
Comments: The device map is used to convert controller number, AIOP number,
          and channel number into a device number.

---------------------------------------------------------------------*/
#define sGetDevMap(CTL,AIOP,CHAN) sDevMapTbl[CTL][AIOP][CHAN]

/*-------------------------------------------------------------------
Function: sGetModemStatus
Purpose:  Get the modem status
Call:     sGetModemStatus(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: Modem status using flags CD_ACT, DSR_ACT, and
                         CTS_ACT.
---------------------------------------------------------------------*/
#define sGetModemStatus(CHP) (unsigned char)(sInB((BIOA_T)(CHP)->ChanStat) & (CD_ACT | DSR_ACT | CTS_ACT))

/*-------------------------------------------------------------------
Function: sGetRPlusModemRI
Purpose:  Get the modem status(DSR on upper unused ports have RI signal)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: Modem status using flags DSR_ACT signifying
          RI signal.
---------------------------------------------------------------------*/
#define sGetRPlusModemRI(CHP) (unsigned char)(sInB((BIOA_T)(CHP)->ChanStat+8) & (DSR_ACT))

/*-------------------------------------------------------------------
Function: sGetNextInBitMap
Purpose:  Get the next number needing service from a bit map.
Call:     sGetNextInBitMap(BitMap)
          unsigned char BitMap; The bit map.  Each bit set identifies an
                        entity that needs service.
Return:   int: The next number needing service, or -1 if nothing needs
               service.  If the bit map represents AIOPs or channels,
               NULLAIOP or NULLCHAN respectively are the return values if
               nothing needs service.
Comments: Immediately after calling sGetNextInBitMap(), sClrNextInBitMap()
          must be called to clear the bit of the number just returned.
---------------------------------------------------------------------*/
//#define sGetNextInBitMap(BITMAP) sBitMapToLowTbl[BITMAP]

/*-------------------------------------------------------------------
Function: sGetRxCnt
Purpose:  Get the number of data bytes in the Rx FIFO
Call:     sGetRxCnt(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   int: The number of data bytes in the Rx FIFO.
Comments: Byte read of count register is required to obtain Rx count.
---------------------------------------------------------------------*/
#define sGetRxCnt(CHP) sInW((CHP)->TxRxCount)

/*-------------------------------------------------------------------
Function: sGetRxStatus
Purpose:  Get a channel's receive status
Call:     sGetRxStatus(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: Receive status: 0 if no data is available, or the
                         RDA (Receive Data Available) flag if data is
                         available.
---------------------------------------------------------------------*/
#define sGetRxStatus(CHP) (sInB((BIOA_T)(CHP)->ChanStat) & RDA)

/*-------------------------------------------------------------------
Function: sGetTxCnt
Purpose:  Get the number of data bytes in the Tx FIFO
Call:     sGetTxCnt(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: The number of data bytes in the Tx FIFO.
Comments: Byte read of count register is required to obtain Tx count.
---------------------------------------------------------------------*/
#define sGetTxCnt(CHP) sInB((BIOA_T)(CHP)->TxRxCount)

/*-------------------------------------------------------------------
Function: sGetTxRxDataIO
Purpose:  Get the I/O address of a channel's TxRx Data register
Call:     sGetTxRxDataIO(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   WIOA_T: I/O address of a channel's TxRx Data register
---------------------------------------------------------------------*/
#define sGetTxRxDataIO(CHP) (CHP)->TxRxData

/*-------------------------------------------------------------------
Function: sGetTxSize
Purpose:  Get the maximum number of bytes allowed in a channel's Tx FIFO.
Call:     sGetTxSize(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   int: The maximum number of bytes allowed in the Tx FIFO.
---------------------------------------------------------------------*/
#define sGetTxSize(CHP) (CHP)->TxSize

/*-------------------------------------------------------------------
Function: sGetTxStatus
Purpose:  Get a channels transmit status
Call:     sGetTxStatus(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: Transmit status, can be 0 or any combination of the
             following flags:
                TXFIFOMT: Tx FIFO is empty
                TXSHRMT:  Tx shift register is empty
Comments: If the transmitter is completely drained the return value will
          be (TXFIFOMT | TXSHRMT).
---------------------------------------------------------------------*/
#define sGetTxStatus(CHP) (unsigned char)(sInB((BIOA_T)(CHP)->ChanStat) & (TXFIFOMT | TXSHRMT))

/*-------------------------------------------------------------------
Function: sInB
Purpose:  Read a byte from I/O space
Call:     sInB(io)
          BIOA_T io; I/O address to read from
Return:   unsigned char
---------------------------------------------------------------------*/
#define sInB(IO) READ_PORT_UCHAR(IO)


/*-------------------------------------------------------------------
Function: sInStrW
Purpose:  Read a string of words from I/O space
Call:     sInStrW(io,Buffer,Count)
          WIOA_T io: The I/O address to read from
          unsigned int *Buffer; Ptr to buffer for data read
          int Count; Number of words to read
Return:   void
Warnings: Buffer must be large enough to hold Count words.

          Watch out for macro side effects, the caller's Buffer and Count
          may be modified, depending how the macro is coded.
---------------------------------------------------------------------*/
#define sInStrW(IO,BUFFER,COUNT) READ_PORT_BUFFER_USHORT(IO,BUFFER,COUNT)

/*-------------------------------------------------------------------
Function: sInW
Purpose:  Read a word from I/O space
Call:     sInW(io)
          WIOA_T io; I/O address to read from
Return:   unsigned int
---------------------------------------------------------------------*/
#define sInW(IO) READ_PORT_USHORT(IO)

/*-------------------------------------------------------------------
Function: sOutB
Purpose:  Write a byte to I/O space
Call:     sOutB(io,Value)
          unsigned int io; I/O address to write to
          unsigned char Value; Value to write
Return:   void
---------------------------------------------------------------------*/
#define sOutB(IO,VAL) WRITE_PORT_UCHAR(IO,VAL)


/*-------------------------------------------------------------------
Function: sOutDW
Purpose:  Write a double word to I/O space
Call:     sOutDW(io,Value)
          unsigned int io; I/O address to write to
          unsigned long Value; Value to write
Return:   void
---------------------------------------------------------------------*/
#define sOutDW(IO,VAL) WRITE_PORT_ULONG(IO,VAL)

/*-------------------------------------------------------------------
Function: sOutStrW
Purpose:  Write a string of words to I/O space
Call:     sOutStrW(io,Buffer,Count)
          WIOA_T io: The I/O address to write to
          unsigned int far *Buffer; Ptr to buffer containing write data
          int Count; Number of words to write
Return:   void
Warnings: Watch out for macro side effects, the caller's Buffer and Count
          may be modified, depending how the macro is coded.
---------------------------------------------------------------------*/
#define sOutStrW(IO,BUFFER,COUNT) WRITE_PORT_BUFFER_USHORT(IO,BUFFER,COUNT)

/*-------------------------------------------------------------------
Function: sOutW
Purpose:  Write a word to I/O space
Call:     sOutW(io,Value)
          WIOA_T io; I/O address to write to
          unsigned int Value; Value to write
Return:   void
---------------------------------------------------------------------*/
#define sOutW(IO,VAL) WRITE_PORT_USHORT(IO,VAL)

/*-------------------------------------------------------------------
Function: sReadRxByte
Purpose:  Read a receive data byte from a channel.
Call:     sReadRxByte(io)
          BIOA_T io; Channel receive register I/O address.  This can
                    be obtained with sGetTxRxDataIO().
Return:   unsigned char: The receive data byte
---------------------------------------------------------------------*/
#define sReadRxByte(IO) sInB(IO)

/*-------------------------------------------------------------------
Function: sReadRxWord
Purpose:  Read two receive data bytes from a channel with a single word read
          is not in Rx Status Mode.  Read a data byte and a status byte if
          in Rx Status Mode.
Call:     sReadRxWord(io)
          WIOA_T io; Channel receive register I/O address.  This can
                    be obtained with sGetTxRxDataIO().
Return:   unsigned int: The two receive data bytes if not in Rx Status Mode.
             In this case the first data byte read is placed in the low byte,
             the second data byte read in the high byte.

             A data byte and a status byte if in Rx Status Mode.  In this case
             the data is placed in the low byte and the status in the high
             byte.  The status can be any of the following flags:
                STMBREAK:   Break
                STMFRAME:   Framing error
                STMRCVROVR: Receiver over run error
                STMPARITY:  Parity error
             The flag STMERROR is defined as (STMBREAK | STMFRAME | STMPARITY)
---------------------------------------------------------------------*/
#define sReadRxWord(IO) sInW(IO)

/*-------------------------------------------------------------------
Function: sResetAiop
Purpose:  Reset the AIOP
Call:     sResetAiop(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sResetAiop(CHP) \
{ \
   sOutB((CHP)->Cmd,RESET_ALL); \
   sOutB((CHP)->Cmd,0x0); \
}

/*-------------------------------------------------------------------
Function: sResetUART
Purpose:  Reset the channel's UART
Call:     sResetUART(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: The two sInB() instructions provide a delay >= 400nS.
---------------------------------------------------------------------*/
#define sResetUART(CHP) \
{ \
   sOutB((CHP)->Cmd,(UCHAR)(RESETUART | (CHP)->ChanNum)); \
   sOutB((CHP)->Cmd,(unsigned char)(CHP)->ChanNum); \
   sInB((CHP)->IntChan); \
   sInB((CHP)->IntChan); \
}

/*-------------------------------------------------------------------
Function: sSendBreak
Purpose:  Send a transmit BREAK signal
Call:     sSendBreak(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSendBreak(CHP) \
{ \
   (CHP)->TxControl[3] |= SETBREAK; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetBSChar
Purpose:  Set the BS (backspace) character
Call:     sSetBSChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the backspace character to
Return:   void
---------------------------------------------------------------------*/
#define sSetBSChar(CHP,CH) \
{ \
   (CHP)->BS1_DATA = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->BS1_OUT); \
   (CHP)->BS2_DATA = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->BS2_OUT); \
}

/*-------------------------------------------------------------------
Function: sSetData7
Purpose:  Set data bits to 7
Call:     sSetData7(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetData7(CHP) \
{ \
   (CHP)->TxControl[2] &= ~DATA8BIT; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetData8
Purpose:  Set data bits to 8
Call:     sSetData8(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetData8(CHP) \
{ \
   (CHP)->TxControl[2] |= DATA8BIT; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetDevMap
Purpose:  Set an entry in the device map.
Call:     sSetDevMap(Ctl,Aiop,Chan,Dev)
          int Ctl; Controller number
          int Aiop; Aiop number within a controller
          int Chan; Channel number within an Aiop
          int Dev; The device number that Ctl, Aiop, and Chan map to.
Return:   void
Comments: The device map is used to convert controller number, AIOP number,
          and channel number into a device number.  Function sSetDevMap()
          is used to initialize entries within the device map when the
          mapping is first established.
---------------------------------------------------------------------*/
#define sSetDevMap(CTL,AIOP,CHAN,DEV) sDevMapTbl[CTL][AIOP][CHAN] = (DEV)

/*-------------------------------------------------------------------
Function: sSetDTR
Purpose:  Set the DTR output
Call:     sSetDTR(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetDTR(CHP) \
{ \
   (CHP)->TxControl[3] |= SET_DTR; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetEOFChar
Purpose:  Set the EOF (end of file) character
Call:     sSetBSChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the EOF character to
Return:   void
---------------------------------------------------------------------*/
#define sSetEOFChar(CHP,CH) \
{ \
   (CHP)->MCode[EOF_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[EOF_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetEraseChar
Purpose:  Set Erase character
Call:     sSetEraseChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the erase character to
Return:   void
---------------------------------------------------------------------*/
#define sSetEraseChar(CHP,CH) \
{ \
   (CHP)->MCode[ERASE_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[ERASE_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetESCChar
Purpose:  Set the ESC (escape) character
Call:     sSetESCChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the ESC character to
Return:   void
---------------------------------------------------------------------*/
#define sSetESCChar(CHP,CH) \
{ \
   (CHP)->MCode[ESC_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[ESC_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetEvenParity
Purpose:  Set even parity
Call:     sSetEvenParity(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: Function sSetParity() can be used in place of functions sEnParity(),
          sDisParity(), sSetOddParity(), and sSetEvenParity().

Warnings: This function has no effect unless parity is enabled with function
          sEnParity().
---------------------------------------------------------------------*/
#define sSetEvenParity(CHP) \
{ \
   (CHP)->TxControl[2] |= EVEN_PAR; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetErrorIgn
Purpose:  Set Error processing to ignore errored characters
Call:     sSetErrorIgn(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetErrorIgn(CHP) \
{ \
   (CHP)->MCode[ERROR_DATA] = (IGNORE_ER); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[ERROR_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetErrorNorm
Purpose:  Set Error processing to treat errored character as normal
`         characters, no error processing is done.
Call:     sSetErrorNorm(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetErrorNorm(CHP) \
{ \
   (CHP)->MCode[ERROR_DATA] = (NORMAL_ER); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[ERROR_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetErrorRepl
Purpose:  Set Error processing to replace errored characters with NULL
Call:     sSetErrorRepl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetErrorRepl(CHP) \
{ \
   (CHP)->MCode[ERROR_DATA] = (REPLACE_ER); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[ERROR_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetKILLChar
Purpose:  Set the KILL character
Call:     sSetKILLChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the KILL character to
Return:   void
---------------------------------------------------------------------*/
#define sSetKILLChar(CHP,CH) \
{ \
   (CHP)->MCode[KILL1_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[KILL1_OUT]); \
   (CHP)->MCode[KILL2_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[KILL2_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetNLChar
Purpose:  Set the NL (new line) character
Call:     sSetNLChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the NL character to
Return:   void
---------------------------------------------------------------------*/
#define sSetNLChar(CHP,CH) \
{ \
   (CHP)->MCode[NEWLINE1_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[NEWLINE1_OUT]); \
   (CHP)->MCode[NEWLINE2_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[NEWLINE2_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetOddParity
Purpose:  Set odd parity
Call:     sSetOddParity(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: Function sSetParity() can be used in place of functions sEnParity(),
          sDisParity(), sSetOddParity(), and sSetEvenParity().

Warnings: This function has no effect unless parity is enabled with function
          sEnParity().
---------------------------------------------------------------------*/
#define sSetOddParity(CHP) \
{ \
   (CHP)->TxControl[2] &= ~EVEN_PAR; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetRTS
Purpose:  Set the RTS output
Call:     sSetRTS(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetRTS(CHP) \
{ \
   (CHP)->TxControl[3] |= SET_RTS; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetRxCmpVal0
Purpose:  Set Rx Compare Value 0 to a new value without changing the state
          of the enable or disable instructions.
Call:     sSetRxCmpVal0(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function only sets the value of CmpByte. It can be used to
          dynamically set the compare byte while the compare is active.
          It does not enable the compare or ignore functions.
---------------------------------------------------------------------*/
#define sSetRxCmpVal0(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL0_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[IGNORE0_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetRxCmpVal1
Purpose:  Set Rx Compare Value 1 to a new value without changing the state
          of the enable or disable instructions.
Call:     sSetRxCmpVal1(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function only sets the value of CmpByte. It can be used to
          dynamically set the compare byte while the compare is active.
          It does not enable the compare or ignore functions.
---------------------------------------------------------------------*/
#define sSetRxCmpVal1(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL1_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL1_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetRxCmpVal2
Purpose:  Set Rx Compare Value 2 to a new value without changing the state
          of the enable or disable instructions.
Call:     sSetRxCmpVal2(ChP,CmpByte)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char CmpByte; Byte to compare Rx data byte with
Return:   void
Comments: This function only sets the value of CmpByte. It can be used to
          dynamically set the compare byte while the compare is active.
          It does not enable the compare or ignore functions.
---------------------------------------------------------------------*/
#define sSetRxCmpVal2(CHP,CMPBYTE) \
{ \
   (CHP)->MCode[RXCMPVAL2_DATA] = (CMPBYTE); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXCMPVAL2_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetRxMask
Purpose:  Set the Rx mask value
Call:     sSetRxMask(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the Rx mask to
Return:   void
---------------------------------------------------------------------*/
#define sSetRxMask(CHP,CH) \
{ \
   (CHP)->MCode[RXMASK_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[RXMASK_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetRxTrigger
Purpose:  Set the Rx FIFO trigger level
Call:     sSetRxProcessor(ChP,Level)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Level; Number of characters in Rx FIFO at which the
             interrupt will be generated.  Can be any of the following flags:

             TRIG_NO:   no trigger
             TRIG_1:    1 character in FIFO
             TRIG_1_2:  FIFO 1/2 full
             TRIG_7_8:  FIFO 7/8 full
Return:   void
Comments: An interrupt will be generated when the trigger level is reached
          only if function sEnInterrupt() has been called with flag
          RXINT_EN set.  The RXF_TRIG flag in the Interrupt Idenfification
          register will be set whenever the trigger level is reached
          regardless of the setting of RXINT_EN.
---------------------------------------------------------------------*/
#define sSetRxTrigger(CHP,LEVEL) \
{ \
   (CHP)->RxControl[2] &= ~TRIG_MASK; \
   (CHP)->RxControl[2] |= LEVEL; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->RxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetTxSize
Purpose:  Set the maximum number of bytes allowed in a channel's Tx FIFO.
Call:     sSetTxSize(ChP,TxSize)
          CHANPTR_T ChP; Ptr to channel structure
          int TxSize; Maximum number of bytes allowed in Tx FIFO.
Return:   void
---------------------------------------------------------------------*/
#define sSetTxSize(CHP,TXSIZE) (CHP)->TxSize = (TXSIZE)

/*-------------------------------------------------------------------
Function: sSetSPChar
Purpose:  Set the SP (space) character
Call:     sSetSPChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the SP character to
Return:   void
---------------------------------------------------------------------*/
#define sSetSPChar(CHP,CH) \
{ \
   (CHP)->MCode[SPACE_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[SPACE_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetStop1
Purpose:  Set stop bits to 1
Call:     sSetStop1(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetStop1(CHP) \
{ \
   (CHP)->TxControl[2] &= ~STOP2; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetStop2
Purpose:  Set stop bits to 2
Call:     sSetStop2(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
---------------------------------------------------------------------*/
#define sSetStop2(CHP) \
{ \
   (CHP)->TxControl[2] |= STOP2; \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->TxControl[0]); \
}

/*-------------------------------------------------------------------
Function: sSetTxXOFFChar
Purpose:  Set the Tx XOFF flow control character
Call:     sSetTxXOFFChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the Tx XOFF character to
Return:   void
---------------------------------------------------------------------*/
#define sSetTxXOFFChar(CHP,CH) \
{ \
   (CHP)->MCode[TXXOFFVAL_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[TXXOFFVAL_OUT]); \
}

/*-------------------------------------------------------------------
Function: sSetTxXONChar
Purpose:  Set the Tx XON flow control character
Call:     sSetTxXONChar(ChP,Ch)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Ch; The value to set the Tx XON character to
Return:   void
---------------------------------------------------------------------*/
#define sSetTxXONChar(CHP,CH) \
{ \
   (CHP)->MCode[TXXONVAL_DATA] = (CH); \
   sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[TXXONVAL_OUT]); \
}

/*-------------------------------------------------------------------
Function: sStartRxProcessor
Purpose:  Start a channel's receive processor
Call:     sStartRxProcessor(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: This function is used to start a Rx processor after it was
          stopped with sStopRxProcessor() or sStopSWInFlowCtl().  It
          will restart both the Rx processor and software input flow control.
---------------------------------------------------------------------*/
#define sStartRxProcessor(CHP) sOutDW((CHP)->IndexAddr,*(ULONGPTR_T)&(CHP)->MCode[0])

/*-------------------------------------------------------------------
Function: sWriteTxByte
Purpose:  Write a transmit data byte to a channel.
          BIOA_T io: Channel transmit register I/O address.  This can
                           be obtained with sGetTxRxDataIO().
          unsigned char Data; The transmit data byte.
Return:   void
Warnings: This function writes the data byte without checking to see if
          sMaxTxSize is exceeded in the Tx FIFO.
---------------------------------------------------------------------*/
#define sWriteTxByte(IO,DATA) sOutB(IO,DATA)

/*-------------------------------------------------------------------
Function: sWriteTxWord
Purpose:  Write two transmit data bytes to a channel with a single word write
Call:     sWriteTxWord(io,Data)
          WIOA_T io: Channel transmit register I/O address.  This can
                           be obtained with sGetTxRxDataIO().
          unsigned int Data; The two transmit data bytes.  The low byte
             will be transmitted first, then the high byte.
Return:   void
---------------------------------------------------------------------*/
#define sWriteTxWord(IO,DATA) sOutW(IO,DATA)


//----- global vars
extern unsigned char MasterMCode1[];
extern unsigned char MCode1Reg[];
extern CONTROLLER_T sController[];
extern unsigned char sIRQMap[16];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\rocklog.h ===
//File Name: rocklog.mc
//Constant definitions for the I/O error code log values.

#ifndef _ROCKLOG_
#define _ROCKLOG_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SERIAL_RP_INIT_FAIL
//
// MessageText:
//
//  The RocketPort or RocketModem could not be initialized with the current settings.
//
#define SERIAL_RP_INIT_FAIL              ((NTSTATUS)0x80060001L)

//
// MessageId: SERIAL_RP_INIT_PASS
//
// MessageText:
//
//  The RocketPort/RocketModem driver has successfully initialized its hardware.
//
#define SERIAL_RP_INIT_PASS              ((NTSTATUS)0x40060002L)

//
// MessageId: SERIAL_NO_SYMLINK_CREATED
//
// MessageText:
//
//  Unable to create the symbolic link for %2.
//
#define SERIAL_NO_SYMLINK_CREATED        ((NTSTATUS)0x80060003L)

//
// MessageId: SERIAL_NO_DEVICE_MAP_CREATED
//
// MessageText:
//
//  Unable to create the device map entry for %2.
//
#define SERIAL_NO_DEVICE_MAP_CREATED     ((NTSTATUS)0x80060004L)

//
// MessageId: SERIAL_NO_DEVICE_MAP_DELETED
//
// MessageText:
//
//  Unable to delete the device map entry for %2.
//
#define SERIAL_NO_DEVICE_MAP_DELETED     ((NTSTATUS)0x80060005L)

//
// MessageId: SERIAL_UNREPORTED_IRQL_CONFLICT
//
// MessageText:
//
//  Another driver on the system, which did not report its resources, has already claimed interrupt %3 used by %2.
//
#define SERIAL_UNREPORTED_IRQL_CONFLICT  ((NTSTATUS)0xC0060006L)

//
// MessageId: SERIAL_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Not enough memory was available to allocate internal storage needed for %2.
//
#define SERIAL_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC0060007L)

//
// MessageId: SERIAL_NO_PARAMETERS_INFO
//
// MessageText:
//
//  No Parameters subkey was found for user defined data.
//
#define SERIAL_NO_PARAMETERS_INFO        ((NTSTATUS)0xC0060008L)

//
// MessageId: SERIAL_UNABLE_TO_ACCESS_CONFIG
//
// MessageText:
//
//  Specific user configuration data is unretrievable.
//
#define SERIAL_UNABLE_TO_ACCESS_CONFIG   ((NTSTATUS)0xC0060009L)

//
// MessageId: SERIAL_UNKNOWN_BUS
//
// MessageText:
//
//  The bus type for %2 is not recognizable.
//
#define SERIAL_UNKNOWN_BUS               ((NTSTATUS)0xC006000AL)

//
// MessageId: SERIAL_BUS_NOT_PRESENT
//
// MessageText:
//
//  The bus type for %2 is not available on this computer.
//
#define SERIAL_BUS_NOT_PRESENT           ((NTSTATUS)0xC006000BL)

//
// MessageId: SERIAL_INVALID_USER_CONFIG
//
// MessageText:
//
//  User configuration for parameter %2 must have %3.
//
#define SERIAL_INVALID_USER_CONFIG       ((NTSTATUS)0xC006000CL)

//
// MessageId: SERIAL_RP_RESOURCE_CONFLICT
//
// MessageText:
//
//  A resource conflict was detected, the RocketPort/RocketModem driver will not load.
//
#define SERIAL_RP_RESOURCE_CONFLICT      ((NTSTATUS)0xC006000DL)

//
// MessageId: SERIAL_RP_HARDWARE_FAIL
//
// MessageText:
//
//  The RocketPort/RocketModem driver could not initialize its hardware, the driver will not be loaded.
//
#define SERIAL_RP_HARDWARE_FAIL          ((NTSTATUS)0xC006000EL)

//
// MessageId: SERIAL_DEVICEOBJECT_FAILED
//
// MessageText:
//
//  The Device Object for the RocketPort or RocketModem could not be created, the driver will not load.
//
#define SERIAL_DEVICEOBJECT_FAILED       ((NTSTATUS)0xC006000FL)

//
// MessageId: SERIAL_CUSTOM_ERROR_MESSAGE
//
// MessageText:
//
//  %2
//
#define SERIAL_CUSTOM_ERROR_MESSAGE      ((NTSTATUS)0xC0060010L)

//
// MessageId: SERIAL_CUSTOM_INFO_MESSAGE
//
// MessageText:
//
//  %2
//
#define SERIAL_CUSTOM_INFO_MESSAGE       ((NTSTATUS)0x40060011L)

//
// MessageId: SERIAL_NT50_INIT_PASS
//
// MessageText:
//
//  The RocketPort/RocketModem driver has successfully installed.
//
#define SERIAL_NT50_INIT_PASS            ((NTSTATUS)0x40060012L)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\ssci.c ===
/*-------------------------------------------------------------------
| ssci.c - low level interface routines to rocketport hardware.

 03-16-98, add sModemSendROW for RocketModem - jl
 02-05-98, add sModemReset for RocketModem - jl
 10-22-96, add ReadAiopID to PCI case as hardware verification. - kpb

Copyright 1993-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

#define  ONE_SECOND     10
#define  TWO_SECONDS    (2 * ONE_SECOND)
#define  THREE_SECONDS  (3 * ONE_SECOND)
#define  FOUR_SECONDS   (4 * ONE_SECOND)
#define  FIVE_SECONDS   (5 * ONE_SECOND)
#define  TENTH_SECOND   (ONE_SECOND / 10)
#define  HALF_SECOND    (ONE_SECOND / 2)

// #define  DUMPDATA 1
#ifdef DUMPDATA
// in case of changed responses from modem, the following allows
// the unrecognized responses to be dumped to log...
void  DumpResponseByte(char buffer);
char  DumpArray[512];
int   DumpIndex = 0;
#endif

#ifdef PPC
// #define INTEL_ORDER 1
#endif

#ifdef ALPHA
#define INTEL_ORDER 1
#define WORD_ALIGN 1
#endif

#ifdef i386
#define INTEL_ORDER 1
#endif

#ifdef MIPS
// #define INTEL_ORDER 1
#endif

/* Master copy of AIOP microcode.  Organized as DWORDs.  The 1st word of each
   DWORD holds the microcode index, the second word holds the microcode
   data. */
unsigned char MasterMCode1[MCODE1_SIZE] =
{
/* indl  indh  dlo   dhi */
   0x00, 0x09, 0xf6, 0x82,
   0x02, 0x09, 0x86, 0xfb,
   0x04, 0x09, 0x00, 0x0a,
   0x06, 0x09, 0x01, 0x0a,
   0x08, 0x09, 0x8a, 0x13,
   0x0a, 0x09, 0xc5, 0x11,
   0x0c, 0x09, 0x86, 0x85,
   0x0e, 0x09, 0x20, 0x0a,
   0x10, 0x09, 0x21, 0x0a,
   0x12, 0x09, 0x41, 0xff,
   0x14, 0x09, 0x82, 0x00,
   0x16, 0x09, 0x82, 0x7b,
   0x18, 0x09, 0x8a, 0x7d,
   0x1a, 0x09, 0x88, 0x81,
   0x1c, 0x09, 0x86, 0x7a,
   0x1e, 0x09, 0x84, 0x81,
   0x20, 0x09, 0x82, 0x7c,
   0x22, 0x09, 0x0a, 0x0a 
};

/* Registers within microcode.  Organized as DWORDs.  The 1st word of each
   DWORD holds the microcode index of that register, the 2nd DWORD holds
   the current contents of that register. */
unsigned char MCode1Reg[MCODE1REG_SIZE] =
{
/* indl  indh  dlo   dhi */
   0x00, 0x09, 0xf6, 0x82,             /* 00: Stop Rx processor */
   0x08, 0x09, 0x8a, 0x13,             /* 04: Tx software flow control */
   0x0a, 0x09, 0xc5, 0x11,             /* 08: XON char */
   0x0c, 0x09, 0x86, 0x85,             /* 0c: XANY */
   0x12, 0x09, 0x41, 0xff,             /* 10: Rx mask char */
   0x14, 0x09, 0x82, 0x00,             /* 14: Compare/Ignore #0 */
   0x16, 0x09, 0x82, 0x7b,             /* 18: Compare #1 */
   0x18, 0x09, 0x8a, 0x7d,             /* 1c: Compare #2 */
   0x1a, 0x09, 0x88, 0x81,             /* 20: Interrupt #1 */
   0x1c, 0x09, 0x86, 0x7a,             /* 24: Ignore/Replace #1 */
   0x1e, 0x09, 0x84, 0x81,             /* 28: Interrupt #2 */
   0x20, 0x09, 0x82, 0x7c,             /* 2c: Ignore/Replace #2 */
   0x22, 0x09, 0x0a, 0x0a              /* 30: Rx FIFO Enable */
};

/* Controller structures */
/* IRQ number to MUDBAC register 2 mapping */
unsigned char sIRQMap[16] =
{
   0,0,0,0x10,0x20,0x30,0,0,0,0x40,0x50,0x60,0x70,0,0,0x80
};

//unsigned char sBitMapClrTbl[8] =
//   0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f

//unsigned char sBitMapSetTbl[8] =
//   0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80

/***************************************************************************
Function: sInitController
Purpose:  Initialization of controller global registers and controller
          structure.
Call:     **** This version of the call for all except Windows NT ****
          sInitController(CtlP,CtlNum,MudbacIO,AiopIOList,AiopIOListSize,
                          IRQNum,Frequency,PeriodicOnly)
Call:     **** This version of the call for Windows NT ***
          sInitController(CtlP,CtlNum,MudbacIO,AiopIOList,PhyAiopIOList,
          AiopIOListSize,IRQNum,Frequency,PeriodicOnly)
          CONTROLLER_T *CtlP; Ptr to controller structure
          int CtlNum; Controller number
          BIOA_T MudbacIO; Mudbac base I/O address.  For Win NT this
             is the TranslatedAddress returned by HalTranslateBusAddress().
          BIOA_T *AiopIOList; List of I/O addresses for each AIOP.
             This list must be in the order the AIOPs will be found on the
             controller.  Once an AIOP in the list is not found, it is
             assumed that there are no more AIOPs on the controller.
             For Win NT these are the TranslatedAddresses returned by
             HalTranslateBusAddress().
          unsigned int *PhyAiopIOList; List of physical I/O addresses for
             each AIOP, used by Win NT only.  These are the physical
             addresses corresponding to the TranslatedAddresses in
             AiopIOList.
          int AiopIOListSize; Number of addresses in AiopIOList
          int IRQNum; Interrupt Request number.  Can be any of the following:
                         0: Disable global interrupts
                         3: IRQ 3
                         4: IRQ 4
                         5: IRQ 5
                         9: IRQ 9
                         10: IRQ 10
                         11: IRQ 11
                         12: IRQ 12
                         15: IRQ 15
          unsigned char Frequency: A flag identifying the frequency
                   of the periodic interrupt, can be any one of the following:
                      FREQ_DIS - periodic interrupt disabled
                      FREQ_137HZ - 137 Hertz
                      FREQ_69HZ - 69 Hertz
                      FREQ_34HZ - 34 Hertz
                      FREQ_17HZ - 17 Hertz
                      FREQ_9HZ - 9 Hertz
                      FREQ_4HZ - 4 Hertz
                   If IRQNum is set to 0 the Frequency parameter is
                   overidden, it is forced to a value of FREQ_DIS.
          int PeriodicOnly: TRUE if all interrupts except the periodic
                               interrupt are to be blocked.
                            FALSE is both the periodic interrupt and
                               other channel interrupts are allowed.
                            If IRQNum is set to 0 the PeriodicOnly parameter is
                               overidden, it is forced to a value of FALSE.
Return:   int: 0 on success, errcode on failure

Comments: This function must be called immediately after sSetChannelDefaults()
          for each controller in the system.

          If periodic interrupts are to be disabled but AIOP interrupts
          are allowed, set Frequency to FREQ_DIS and PeriodicOnly to FALSE.

          If interrupts are to be completely disabled set IRQNum to 0.

          Setting Frequency to FREQ_DIS and PeriodicOnly to TRUE is an
          invalid combination.

          This function performs initialization of global interrupt modes,
          but it does not actually enable global interrupts.  To enable
          and disable global interrupts use functions sEnGlobalInt() and
          sDisGlobalInt().  Enabling of global interrupts is normally not
          done until all other initializations are complete.

          Even if interrupts are globally enabled, they must also be
          individually enabled for each channel that is to generate
          interrupts.
Warnings: No range checking on any of the parameters is done.

          No context switches are allowed while executing this function.

          After this function all AIOPs on the controller are disabled,
          they can be enabled with sEnAiop().
*/
int sInitController(CONTROLLER_T *CtlP,
//                    int CtlNum,
                    BIOA_T MudbacIO,
                    BIOA_T *AiopIOList,
                    unsigned int *PhyAiopIOList,
                    int AiopIOListSize,
                    int IRQNum,
                    unsigned char Frequency,
                    int PeriodicOnly,
                    int BusType,
                    int prescaler)
{
   // unsigned char MudbacID;             /* MUDBAC ID byte*/
   int i;
   BIOA_T io;                          /* an I/O address */
   unsigned int pio;                   /* physical I/O address for Win NT */
   WIOA_T IoIndexAddr;
   WIOA_T IoIndexData;
   // IoIndexAddr=(PUSHORT)((PUCHAR)io+_INDX_ADDR);
   // IoIndexData=(PUSHORT)((PUCHAR)io+_INDX_DATA);
      
   //CtlP->CtlNum = CtlNum;
   CtlP->BusType = BusType;
   CtlP->PortsPerAiop = 8;

   if (CtlP->BusType == Isa)
   {
     MyKdPrint(D_Ssci,("One ISA ROCKET \n"))
     CtlP->CtlID = CTLID_0001;        /* controller release 1 */
     if (AiopIOListSize == 0)
       AiopIOListSize = 32; // we figure out

     /* If we get here controller found, init MUDBAC and controller struct */
     CtlP->MBaseIO = MudbacIO;
     CtlP->MReg1IO = MudbacIO + 1;
     CtlP->MReg2IO = MudbacIO + 2;
     CtlP->MReg3IO = MudbacIO + 3;
     if (IRQNum > 15) IRQNum = 0;  // limit
     if (sIRQMap[IRQNum] == 0)     // interrupts globally disabled
     {
       MyKdPrint(D_Ssci,("No IRQ\n"))
       CtlP->MReg2 = 0;            // interrupt disable
       CtlP->MReg3 = 0;            // no periodic interrupts
     }
     else
     {
       MyKdPrint(D_Ssci,("IRQ used:%d\n",IRQNum))
       CtlP->MReg2 = sIRQMap[IRQNum];   // set IRQ number 
       CtlP->MReg3 = Frequency;         // set frequency 
       if(PeriodicOnly)                 // periodic interrupt only 
       {
         CtlP->MReg3 |= PERIODIC_ONLY;
       }
     }
     sOutB(CtlP->MReg2IO,CtlP->MReg2);
     sOutB(CtlP->MReg3IO,CtlP->MReg3);
     sControllerEOI(CtlP);               /* clear EOI if warm init */

     sDisGlobalInt(CtlP);
     MyKdPrint(D_Ssci,("Disabled ISA interrupts Mreg2:%x := %x\n",
                  CtlP->MReg2IO,CtlP->MReg2))

     /* Init AIOPs */
     CtlP->NumAiop = 0;

     for(i = 0;i < AiopIOListSize;i++)
     {
       io = AiopIOList[i];
       IoIndexAddr=(PUSHORT)(io+_INDX_ADDR);
       IoIndexData=(PUSHORT)(io+_INDX_DATA);
       pio = PhyAiopIOList[i];    /* io points to port, pio is the adrs */

       MyKdPrint(D_Ssci,("io=%xH  pio=%xH\n", (unsigned int)io,
            (unsigned int)pio))

       CtlP->AiopIO[i] = (WIOA_T)io;
       CtlP->AiopIntChanIO[i] = io + _INT_CHAN;

       MyKdPrint(D_Ssci,("Setup AIOP io, MReg2IO=%xH\n",
            (unsigned int)CtlP->MReg2IO))


       sOutB((CtlP->MReg2IO),(unsigned char)(CtlP->MReg2 | (i & 0x03))); /* AIOP index */
       sOutB(MudbacIO,(unsigned char)(pio >> 6)); /* set up AIOP I/O in MUDBAC */

       MyKdPrint(D_Ssci,("Enable AIOP\n"))

       sEnAiop(CtlP,i);                         /* enable the AIOP */

       MyKdPrint(D_Ssci,("Read AIOP ID\n"))

       CtlP->AiopID[i] = sReadAiopID(io);       /* read AIOP ID */

       if(CtlP->AiopID[i] == AIOPID_NULL)       /* if AIOP does not exist */
       {
         sDisAiop(CtlP,i);                     /* disable AIOP */
         break;                                /* done looking for AIOPs */
       }

       MyKdPrint(D_Ssci,("Read AIOP numchan\n"))
       CtlP->AiopNumChan[i] = sReadAiopNumChan((WIOA_T)io); /* num channels in AIOP */


       MyKdPrint(D_Ssci,("Setup Aiop Clk\n"))

       sOutW((WIOA_T)IoIndexAddr,_CLK_PRE);      /* clock prescaler */
       //sOutB((PUCHAR)IoIndexData,CLOCK_PRESC);
       sOutB((PUCHAR)IoIndexData, (BYTE)prescaler);
       CtlP->NumAiop++;                         /* bump count of AIOPs */

       MyKdPrint(D_Ssci,("Setup aiop done\n"))

       sDisAiop(CtlP,i);                        /* disable AIOP */
     }

     MyKdPrint(D_Ssci,("One ISA ROCKET with %d aiops\n",CtlP->NumAiop))

     if(CtlP->NumAiop == 0) {
       MyKdPrint(D_Error,("ISA NumAiop == 0\n"))
       return 1;  // error
     }
     return 0; // ok    // old:(CtlP->NumAiop);
   }  // end of ISA controller init
   else if(CtlP->BusType == PCIBus)
   {
     MyKdPrint(D_Ssci,("One PCI ROCKET \n"))
     //CtlP->CtlNum = CtlNum;
     CtlP->CtlID = CTLID_0001;           /* controller release 1 */
     MyKdPrint(D_Ssci,("Ctrl(%x) IrqNum: %x \n", CtlP, IRQNum))
     if(IRQNum == 0)            /* interrupts disabled for this controler*/
     {
       CtlP->PCI1 = 0x0008;     /* no periodic, interrupts disabled */
     }
     else
     {
       Frequency >>= 4;                /*Right shift 4 times to move 4:7 to  0:3 */
       CtlP->PCI1 |= Frequency;
       if(PeriodicOnly)                 /* periodic interrupt only */
       {
         CtlP->PCI1 |= PER_ONLY_PCI;
       }
     }

     CtlP->PCI1IO = (WIOA_T)((BIOA_T)AiopIOList[0] + _PCI_INT_FUNC);
     MyKdPrint(D_Ssci,("Setting PCI config reg with %x at %x\n",
                              CtlP->PCI1,CtlP->PCI1IO))    // move these calls to ssci.h
     sOutW(CtlP->PCI1IO,CtlP->PCI1);
////////////////////new/////////////////////
          ///CtlP->PortsPerAiop = 8;

      switch (CtlP->PCI_DevID)
      {
        case PCI_DEVICE_4Q:   // 4 Port Quadcable
        case PCI_DEVICE_4RJ:   // 4 Port RJ
          CtlP->PortsPerAiop = 4;

          break;
        case PCI_DEVICE_8RJ:   // 8 Port RJ
        case PCI_DEVICE_8O:   // 8 Port Octacable
        case PCI_DEVICE_8I:  // 8 Port interface
        case PCI_DEVICE_16I:  //16 Port interface
        case PCI_DEVICE_32I:  // 32 Port interface
        case PCI_DEVICE_SIEMENS8  :
        case PCI_DEVICE_SIEMENS16 :
          CtlP->PortsPerAiop = 8;
        break;

        case PCI_DEVICE_RMODEM6 :
          CtlP->PortsPerAiop = 6;
        break;

        case PCI_DEVICE_RMODEM4 :
          CtlP->PortsPerAiop = 4;
        break;

        case PCI_DEVICE_RPLUS4 :
        case PCI_DEVICE_RPLUS8 :
          CtlP->PortsPerAiop = 4;
        break;

        case PCI_DEVICE_RPLUS2 :
        case PCI_DEVICE_422RPLUS2 :
          CtlP->PortsPerAiop = 2;
        break;

        default:
          //Eprintf("Err,Bad PCI DevID:%d", CtlP->PCI_DevID);
        break;
      }  // switch
///////////////////////////////////////////

     /* Init AIOPs */
     CtlP->NumAiop = 0;
     for(i=0; i < AiopIOListSize; i++)
     {
       io = AiopIOList[i];
       CtlP->AiopIO[i] = (WIOA_T)io;
       CtlP->AiopIntChanIO[i] = (BIOA_T)io + _INT_CHAN;

       // 10-22-96, add this(only hardware-verification done) kpb.
       CtlP->AiopID[i] = sReadAiopID(io);       /* read AIOP ID */
       if(CtlP->AiopID[i] == AIOPID_NULL)       /* if AIOP does not exist */
       {
         break;                                /* done looking for AIOPs */
       }

///////old       CtlP->AiopNumChan[i] = sReadAiopNumChan((WIOA_T)io); /* num channels in AIOP */

      ////////////////////new///////////////////////
       CtlP->AiopNumChan[i] = CtlP->PortsPerAiop; /* num channels in AIOP */
      /////////////////////////////////////////////////////////////// 

       IoIndexAddr=(WIOA_T)((BIOA_T)io+_INDX_ADDR);
       IoIndexData=(WIOA_T)((BIOA_T)io+_INDX_DATA);
       sOutW((WIOA_T)IoIndexAddr,_CLK_PRE);      /* clock prescaler */

       sOutB((BIOA_T)IoIndexData, (BYTE)prescaler);
       CtlP->NumAiop++;                         /* bump count of AIOPs */
     }

     sDisGlobalIntPCI(CtlP);
     sPCIControllerEOI(CtlP);               /* clear EOI if warm init */
     
     MyKdPrint(D_Ssci,("One PCI ROCKET with %d aiops\n",CtlP->NumAiop))
     if(CtlP->NumAiop == 0) {
        MyKdPrint(D_Error,("PCI NumAiop == 0\n"))
        return 2;  // error
     }
     return 0;   // old:(CtlP->NumAiop);
  }  /*end of PCI rocket INIT */
  else { /* not PCI or ISA */
     MyKdPrint(D_Error,("Not ISA or PCI\n"))
     return 3; // old:(CTLID_NULL);
  }
  return 0;
}

/***************************************************************************
Function: sReadAiopID
Purpose:  Read the AIOP idenfication number directly from an AIOP.
Call:     sReadAiopID(io)
          BIOA_T io: AIOP base I/O address
Return:   int: Flag AIOPID_XXXX if a valid AIOP is found, where X
                 is replace by an identifying number.
          Flag AIOPID_NULL if no valid AIOP is found
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
int _CDECL sReadAiopID(BIOA_T io)
{
  unsigned char AiopID;               /* ID byte from AIOP */

  sOutB(io + _CMD_REG,RESET_ALL);     /* reset AIOP */
  sOutB(io + _CMD_REG,0x0);
  AiopID = sInB(io + _CHN_STAT0) & 0x07;
  if (AiopID == 0x06)                  /* AIOP release 1 */
    return(AIOPID_0001);
  else                                /* AIOP does not exist */
    return(AIOPID_NULL);
}

/***************************************************************************
Function: sReadAiopNumChan
Purpose:  Read the number of channels available in an AIOP directly from
          an AIOP.
Call:     sReadAiopNumChan(io)
          WIOA_T io: AIOP base I/O address
Return:   int: The number of channels available
Comments: The number of channels is determined by write/reads from identical
          offsets within the SRAM address spaces for channels 0 and 4.
          If the channel 4 space is mirrored to channel 0 it is a 4 channel
          AIOP, otherwise it is an 8 channel.
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
int _CDECL sReadAiopNumChan(WIOA_T io)
{
  unsigned int x;
  WIOA_T IoIndexAddr;
  WIOA_T IoIndexData;

  IoIndexAddr = (PUSHORT)((PUCHAR)io+_INDX_ADDR);
  IoIndexData = (PUSHORT)((PUCHAR)io+_INDX_DATA);
  sOutDW((DWIOA_T)IoIndexAddr, 0x12340000L); /* write to chan 0 SRAM */
  sOutW(IoIndexAddr,0);       /* read from SRAM, chan 0 */
  x = sInW(IoIndexData);
  sOutW(IoIndexAddr, 0x4000);  /* read from SRAM, chan 4 */
  if (x != sInW(IoIndexData))  /* if different must be 8 chan */
    return(8);
  else
    return(4);
}

/***************************************************************************
Function: sInitChan
Purpose:  Initialization of a channel and channel structure
Call:     sInitChan(CtlP,ChP,AiopNum,ChanNum)
          CONTROLLER_T *CtlP; Ptr to controller structure
          CHANPTR_T ChP; Ptr to channel structure
          int AiopNum; AIOP number within controller
          int ChanNum; Channel number within AIOP
Return:   int: TRUE if initialization succeeded, FALSE if it fails because channel
               number exceeds number of channels available in AIOP.
Comments: This function must be called before a channel can be used.
Warnings: No range checking on any of the parameters is done.

          No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
int _CDECL sInitChan(CONTROLLER_T *CtlP,
                     CHANPTR_T ChP,
                     int AiopNum,
                     int ChanNum)
{
   int i;
   WIOA_T AiopIO;
   WIOA_T ChIOOff;                      /* I/O offset of chan with AIOP */
   unsigned char *ChMCode;             /* channel copy of microcode */
   unsigned char *MasterMCode;         /* master copy of microcode */
   unsigned int ChOff;                 /* SRAM offset of channel within AIOP */
   static unsigned char MCode[4];      /* local copy of microcode double word*/
   WIOA_T AiopIndexAddr;

   if(ChanNum >= CtlP->AiopNumChan[AiopNum])
      return(FALSE);                   /* exceeds num chans in AIOP */

   /* Channel, AIOP, and controller identifiers */
   ChP->CtlP = CtlP;
   ChP->ChanID = CtlP->AiopID[AiopNum];
   ChP->AiopNum = AiopNum;
   ChP->ChanNum = ChanNum;

   /* Tx FIFO size */
   sSetTxSize(ChP,MAXTX_SIZE);

   /* Global direct addresses */
   AiopIO = CtlP->AiopIO[AiopNum];
   ChP->Cmd = (BIOA_T)AiopIO + _CMD_REG;
   ChP->IntChan = (BIOA_T)AiopIO + _INT_CHAN;
   ChP->IntMask = (BIOA_T)AiopIO + _INT_MASK;
   AiopIndexAddr=(WIOA_T)((BIOA_T)AiopIO+_INDX_ADDR);
   ChP->IndexAddr = (DWIOA_T)AiopIndexAddr;
   ChP->IndexData = (WIOA_T)((BIOA_T)AiopIO + _INDX_DATA);

   /* Channel direct addresses */
   ChIOOff = (WIOA_T)((BIOA_T)AiopIO + ChP->ChanNum * 2);
   ChP->TxRxData = (WIOA_T)((BIOA_T)ChIOOff + _TD0);
   ChP->ChanStat = (WIOA_T)((BIOA_T)ChIOOff + _CHN_STAT0);
   ChP->TxRxCount =(WIOA_T)((BIOA_T)ChIOOff + _FIFO_CNT0);
   ChP->IntID = (BIOA_T)AiopIO + ChP->ChanNum + _INT_ID0;


   /* Channel microcode initialization.  This writes a complete copy
      of the microcode into the SRAM. */
   MasterMCode = MasterMCode1;
   for(i = 0;i < MCODE1_SIZE; i+=4)
   {
      /* get low byte of index */
      MCode[0] = MasterMCode[i];
      /* get high byte of index */
      MCode[1] = MasterMCode[i+1] + 0x10 * ChanNum;
      /* get low microcode byte */
      MCode[2] = MasterMCode[i+2];
      /* get high microcode byte */
      MCode[3] = MasterMCode[i+3];
      sOutDW(ChP->IndexAddr,*((ULONGPTR_T)&MCode[0]));
   }

   /* Initialize SSCI copy of microcode registers.  This saves only the portion
      of the microcode that will be used as registers. */
   ChMCode = ChP->MCode;
   MasterMCode = MCode1Reg;
   for(i = 0;i < MCODE1REG_SIZE; i+=4)
   {
      /* low byte of index */
      ChMCode[i] = MasterMCode[i];
      /* high byte of index */
      ChMCode[i+1] = MasterMCode[i+1] + 0x10 * ChanNum;
      /* low microcode byte */
      ChMCode[i+2] = MasterMCode[i+2];
      /* high microcode byte */
      ChMCode[i+3] = MasterMCode[i+3];
   }


   /* Indexed registers */
   ChOff = (unsigned int)ChanNum * 0x1000;

   ChP->BaudDiv[0] = (unsigned char)(ChOff + _BAUD);
   ChP->BaudDiv[1] = (unsigned char)((ChOff + _BAUD) >> 8);
   //ChP->BaudDiv[2] = (unsigned char)BRD9600;
   //ChP->BaudDiv[3] = (unsigned char)(BRD9600 >> 8);
   // just default the baud register to something..
   ChP->BaudDiv[2] = (unsigned char)47;
   ChP->BaudDiv[3] = (unsigned char)(47 >> 8);
   sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->BaudDiv[0]);

   ChP->TxControl[0] = (unsigned char)(ChOff + _TX_CTRL);
   ChP->TxControl[1] = (unsigned char)((ChOff + _TX_CTRL) >> 8);
   ChP->TxControl[2] = 0;
   ChP->TxControl[3] = 0;
   sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxControl[0]);

   ChP->RxControl[0] = (unsigned char)(ChOff + _RX_CTRL);
   ChP->RxControl[1] = (unsigned char)((ChOff + _RX_CTRL) >> 8);
   ChP->RxControl[2] = 0;
   ChP->RxControl[3] = 0;
   sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->RxControl[0]);

   ChP->TxEnables[0] = (unsigned char)(ChOff + _TX_ENBLS);
   ChP->TxEnables[1] = (unsigned char)((ChOff + _TX_ENBLS) >> 8);
   ChP->TxEnables[2] = 0;
   ChP->TxEnables[3] = 0;
   sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxEnables[0]);

   ChP->TxCompare[0] = (unsigned char)(ChOff + _TXCMP1);
   ChP->TxCompare[1] = (unsigned char)((ChOff + _TXCMP1) >> 8);
   ChP->TxCompare[2] = 0;
   ChP->TxCompare[3] = 0;
   sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxCompare[0]);

   ChP->TxReplace1[0] = (unsigned char)(ChOff + _TXREP1B1);
   ChP->TxReplace1[1] = (unsigned char)((ChOff + _TXREP1B1) >> 8);
   ChP->TxReplace1[2] = 0;
   ChP->TxReplace1[3] = 0;
   sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxReplace1[0]);

   ChP->TxReplace2[0] = (unsigned char)(ChOff + _TXREP2);
   ChP->TxReplace2[1] = (unsigned char)((ChOff + _TXREP2) >> 8);
   ChP->TxReplace2[2] = 0;
   ChP->TxReplace2[3] = 0;
   sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxReplace2[0]);


   ChP->TxFIFOPtrs = ChOff + _TXF_OUTP;
   ChP->TxFIFO = ChOff + _TX_FIFO;

   sOutB(ChP->Cmd,(unsigned char)(ChanNum | RESTXFCNT)); /* apply reset Tx FIFO count */
   sOutB(ChP->Cmd,(unsigned char)ChanNum);  /* remove reset Tx FIFO count */
   sOutW((WIOA_T)ChP->IndexAddr,(USHORT)ChP->TxFIFOPtrs); /* clear Tx in/out ptrs */
   sOutW(ChP->IndexData,0);
   ChP->RxFIFOPtrs = ChOff + _RXF_OUTP;
   ChP->RxFIFO = ChOff + _RX_FIFO;

   sOutB(ChP->Cmd,(unsigned char)(ChanNum | RESRXFCNT)); /* apply reset Rx FIFO count */
   sOutB(ChP->Cmd,(unsigned char)ChanNum);  /* remove reset Rx FIFO count */
   sOutW((WIOA_T)ChP->IndexAddr,(USHORT)ChP->RxFIFOPtrs); /* clear Rx out ptr */
   sOutW(ChP->IndexData,0);
   sOutW((WIOA_T)ChP->IndexAddr,(USHORT)(ChP->RxFIFOPtrs + 2)); /* clear Rx in ptr */
   sOutW(ChP->IndexData,0);
   ChP->TxPrioCnt = ChOff + _TXP_CNT;
   sOutW((WIOA_T)ChP->IndexAddr,(USHORT)ChP->TxPrioCnt);
   sOutB((PUCHAR)ChP->IndexData,0);
   ChP->TxPrioPtr = ChOff + _TXP_PNTR;
   sOutW((WIOA_T)ChP->IndexAddr,(USHORT)ChP->TxPrioPtr);
   sOutB((PUCHAR)ChP->IndexData,0);
   ChP->TxPrioBuf = ChOff + _TXP_BUF;
   sEnRxProcessor(ChP);                /* start the Rx processor */

   return(TRUE);
}

/*****************************************************************************
Function: sGetRxErrStatus
Purpose:  Get a channel's receive error status
Call:     sGetRxErrStatus(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: Receive error status, can be 0 if there are no
                         errors or any combination of the following flags:
                             STMBREAK:   BREAK
                             STMFRAME:   framing error
                             STMRCVROVR: receiver over run error
                             STMPARITY:  parity error
Warnings: The channel must be in Rx Status Mode (see sEnRxStatusMode())
          before calling this function.

          No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
unsigned char _CDECL sGetRxErrStatus(CHANPTR_T ChP)
{
  unsigned int RxFIFOOut;             /* Rx FIFO out status ptr */

  sOutW((WIOA_T)ChP->IndexAddr, (USHORT)ChP->RxFIFOPtrs); /* get Rx FIFO out status ptr */
  RxFIFOOut = sInW(ChP->IndexData) * 2 + 1;
  sOutW((WIOA_T)ChP->IndexAddr, (USHORT)(ChP->RxFIFO + RxFIFOOut)); /* return the status */
  return(sInB((PUCHAR)ChP->IndexData) & (STMBREAK | STMFRAME | STMPARITY | STMRCVROVR));
}

/***************************************************************************
Function: sSetParity
Purpose:  Set parity to none, odd, or even.
Call:     sSetParity(ChP,Parity)
          CHANPTR_T ChP; Ptr to channel structure
          int Parity; Parity, can be one of the following:
                      0: no parity
                      1: odd parity
                      2: even parity
Return:   void
Comments: Function sSetParity() can be used in place of functions sEnParity(),
          sDisParity(), sSetOddParity(), and sSetEvenParity().
-------------------------------------------------------------------------*/
void _CDECL sSetParity(CHANPTR_T ChP,int Parity)
{
  if (Parity == 0)
  {
    ChP->TxControl[2] &= ~PARITY_EN;
  }
  else if (Parity == 1)
  {
    ChP->TxControl[2] |= PARITY_EN;

    ChP->TxControl[2]  &= ~EVEN_PAR;
  }
  else if (Parity == 2)
  {
    ChP->TxControl[2] |= (PARITY_EN | EVEN_PAR);
  }
  sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxControl[0]);
}

/***************************************************************************
Function: sStopRxProcessor
Purpose:  Stop the receive processor from processing a channel's microcode.
Call:     sStopRxProcessor(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: The receive processor can be started again with sStartRxProcessor().
          This function causes the receive processor to skip over the
          microcode for the stopped channel.  It does not stop it from
          processing other channels.
Warnings: No context switches are allowed while executing this function.

          Do not leave the receive processor stopped for more than one
          character time.

          After calling this function a delay of 4 uS is required to ensure
          that the receive processor is no longer processing microcode for
          this channel.
-------------------------------------------------------------------------*/
void _CDECL sStopRxProcessor(CHANPTR_T ChP)
{
  unsigned char MCode[4];             /* 1st two microcode bytes */

  MCode[0] = ChP->MCode[0];
  MCode[1] = ChP->MCode[1];
  MCode[3] = ChP->MCode[3];

  MCode[2] = 0x0a;            /* inc scan cnt inst to freeze Rx proc */
  sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&MCode[0]);
}

/***************************************************************************
Function: sStopSWInFlowCtl
Purpose:  Stop the receive processor from processing a channel's
          software input flow control microcode.
Call:     sStopSWInFlowCtl(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: The receive processor can be started again with sStartRxProcessor().
          This function causes the receive processor to skip over the
          software input flow control microcode for the stopped channel.
          It does not stop it from processing other channels.
Warnings: No context switches are allowed while executing this function.

          After calling this function a delay of 1 uS is required to ensure
          that the receive processor is no longer processing software input
          flow control microcode for this channel.
-------------------------------------------------------------------------*/
void _CDECL sStopSWInFlowCtl(CHANPTR_T ChP)
{
  unsigned char MCode[4];             /* 1st two microcode bytes */

  MCode[0] = ChP->MCode[0];
  MCode[1] = ChP->MCode[1];
  MCode[2] = ChP->MCode[2];

  MCode[3] = 0x0a;            /* inc scan cnt inst to freeze Rx proc */
  sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&MCode[0]);
}

/***************************************************************************
Function: sFlushRxFIFO
Purpose:  Flush the Rx FIFO
Call:     sFlushRxFIFO(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: To prevent data from being enqueued or dequeued in the Tx FIFO
          while it is being flushed the receive processor is stopped
          and the transmitter is disabled.  After these operations a
          4 uS delay is done before clearing the pointers to allow
          the receive processor to stop.  These items are handled inside
          this function.
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
void _CDECL sFlushRxFIFO(CHANPTR_T ChP)
{
  int i;
  unsigned char Ch;                   /* channel number within AIOP */
  int RxFIFOEnabled;                  /* TRUE if Rx FIFO enabled */

  if (sGetRxCnt(ChP) == 0)             /* Rx FIFO empty */
    return;                          /* don't need to flush */

  RxFIFOEnabled = FALSE;
  if (ChP->MCode[RXFIFO_DATA] == RXFIFO_EN) /* Rx FIFO is enabled */
  {
    RxFIFOEnabled = TRUE;
    sDisRxFIFO(ChP);                 /* disable it */
    for (i = 0;i < 2000/200;i++) /* delay 2 uS to allow proc to disable FIFO*/
      sInB(ChP->IntChan);
  }
  sGetChanStatus(ChP);          /* clear any pending Rx errors in chan stat */
  Ch = (unsigned char)sGetChanNum(ChP);
  sOutB(ChP->Cmd, (UCHAR)(Ch | RESRXFCNT));     /* apply reset Rx FIFO count */
  sOutB(ChP->Cmd,Ch);                 /* remove reset Rx FIFO count */
  sOutW((WIOA_T)ChP->IndexAddr, (USHORT)(ChP->RxFIFOPtrs)); /* clear Rx out ptr */
  sOutW(ChP->IndexData,0);
  sOutW((WIOA_T)ChP->IndexAddr, (USHORT)(ChP->RxFIFOPtrs + 2)); /* clear Rx in ptr */
  sOutW(ChP->IndexData, 0);
  if (RxFIFOEnabled)
    sEnRxFIFO(ChP);                  /* enable Rx FIFO */
}

/***************************************************************************
Function: sFlushTxFIFO
Purpose:  Flush the Tx FIFO
Call:     sFlushTxFIFO(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   void
Comments: To prevent data from being enqueued or dequeued in the Tx FIFO
          while it is being flushed the receive processor is stopped
          and the transmitter is disabled.  After these operations a
          4 uS delay is done before clearing the pointers to allow
          the receive processor to stop.  These items are handled inside
          this function.
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
void _CDECL sFlushTxFIFO(CHANPTR_T ChP)
{
  int i;
  unsigned char Ch;                   /* channel number within AIOP */
  int TxEnabled;                      /* TRUE if transmitter enabled */

  if (sGetTxCnt(ChP) == 0)             /* Tx FIFO empty */
    return;                          /* don't need to flush */

  TxEnabled = FALSE;
  if (ChP->TxControl[3] & TX_ENABLE)
  {
    TxEnabled = TRUE;
    sDisTransmit(ChP);               /* disable transmitter */
  }
  sStopRxProcessor(ChP);              /* stop Rx processor */
  for (i = 0;i < 4000/200;i++)         /* delay 4 uS to allow proc to stop */
    sInB(ChP->IntChan);
  Ch = (unsigned char)sGetChanNum(ChP);
  sOutB(ChP->Cmd,(UCHAR)(Ch | RESTXFCNT));     /* apply reset Tx FIFO count */
  sOutB(ChP->Cmd,Ch);                 /* remove reset Tx FIFO count */
  sOutW((WIOA_T)ChP->IndexAddr, (USHORT)(ChP->TxFIFOPtrs)); /* clear Tx in/out ptrs */
  sOutW(ChP->IndexData,0);
  if (TxEnabled)
    sEnTransmit(ChP);                /* enable transmitter */
  sStartRxProcessor(ChP);             /* restart Rx processor */
}

/***************************************************************************
Function: sFlushTxPriorityBuf
Purpose:  Flush the Tx priority buffer
Call:     sFlushTxPriorityBuf(ChP,unsigned char *Data)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char *Data; Next data byte to be transmitted from the
             Tx priority buffer before the flush occurred, if any.  If
             the return value is TRUE a byte is returned in "Data," if
             the return value is FALSE nothing is returned in "Data."
Return:   int: TRUE if there was data in the Tx priority buffer before
               the flush occurs.  In this case the next byte that would
               have been transmitted is returned in the "Data" parameter.
               FALSE if there was no data in the Tx priority buffer before
               the flush.
Comments: This flush returns the next byte in the priority buffer to
          allow that byte to be sent via sWriteTxByte() after all
          transmit flushing is complete.  This is done to allow pending
          XON and XOFF bytes to be transmitted regardless of the flush.
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
int _CDECL sFlushTxPriorityBuf(CHANPTR_T ChP,unsigned char *Data)
{
  unsigned int PrioState;       /* Tx prio buf status, count, and pointer */
  unsigned int BufOff;          /* Offset of next data byte in Tx prio buf */
  WIOA_T IndexAddr;
  WIOA_T IndexData;

  IndexAddr = (WIOA_T)ChP->IndexAddr;
  IndexData = (WIOA_T)ChP->IndexData;
  sDisTransmit(ChP);

  sOutW(IndexAddr, (USHORT)ChP->TxPrioCnt); /* get priority buf status */

  PrioState = sInW(IndexData);
  if (PrioState & PRI_PEND)            /* data in Tx prio buf */
  {
    BufOff = PrioState >> 8;   /* get offset of next data byte in buf */
    sOutW(IndexAddr,(USHORT)(ChP->TxPrioBuf + BufOff));
    *Data = sInB((BIOA_T)IndexData); /* return next data byte */
    sEnTransmit(ChP);
    return(TRUE);
  }

  sEnTransmit(ChP);                   /* no data in Tx prio buf */
  return(FALSE);
}

/***************************************************************************
Function: sGetTxPriorityCnt
Purpose:  Get the number of data bytes in the Tx priority buffer
Call:     sGetTxPriorityCnt(ChP)
          CHANPTR_T ChP; Ptr to channel structure
Return:   unsigned char: The number of data bytes in the Tx FIFO.
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
unsigned char _CDECL sGetTxPriorityCnt(CHANPTR_T ChP)
{
  unsigned char Cnt;

  sOutW((WIOA_T)ChP->IndexAddr, (USHORT)ChP->TxPrioCnt); /* get priority buf status */
  Cnt = sInB((BIOA_T)ChP->IndexData);
  if (Cnt & PRI_PEND)
    return(Cnt & 0x1f);              /* only lower 5 bits contain count */
  else
    return(0);
}


#ifndef INTEL_ORDER
/*---------------------------------------------------------------------
  sReadRxBlk - MIPS VERSION
|---------------------------------------------------------------------*/
int _CDECL sReadRxBlk(CHANPTR_T ChP,unsigned char *Buffer,int Count)
{
  int RetCount;
  int WordCount;

  int ByteCount = 0;
  unsigned short TempWord;

  RetCount = sGetRxCnt(ChP);          /* number bytes in Rx FIFO */

  /* are there pending chars? */
  if (RetCount <= 0)                   /* no data available */
    return(0x0);
  if (RetCount > Count)                /* only dequeue as much as requested */
    RetCount = Count;

  WordCount = RetCount >> 1;     /* compute count as words */
  while (WordCount--)
  {
    TempWord = sInW((WIOA_T)sGetTxRxDataIO(ChP));
    Buffer[ByteCount++] = TempWord & 0xff;
    Buffer[ByteCount++] = ( TempWord >> 8 ) & 0xff;
  }
  if (RetCount & 1)
  {
    Buffer[ByteCount++] = sInB( (BIOA_T)sGetTxRxDataIO(ChP));
  }

  return(RetCount);
}
#else   // NOT MIPS version
/*------------------------------------------------------------------------
Function: sReadRxBlk - X86 INTEL VERSION
Purpose:  Read a block of receive data from a channel
Call:     sReadRxBlk(ChP,Buffer,Count)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char *Buffer; Ptr to buffer for receive data
          int Count; Max number of bytes to read
Return:   int: Number of bytes actually read from the channel
Warnings: Buffer must be large enough to hold Count characters.

          This function must not be called when in Rx Status Mode.
-------------------------------------------------------------------------*/
int _CDECL sReadRxBlk(CHANPTR_T ChP,unsigned char *Buffer,int Count)
{
  int RetCount;
  int WordCount;
  USHORT UNALIGNED *WordP;
  WIOA_T io;

  RetCount = sGetRxCnt(ChP);          // number bytes in Rx FIFO 

  // are there pending chars?
  if (RetCount <= 0)                   // no data available
    return(0x0);
  if (RetCount > Count)                // only dequeue as much as requested
    RetCount = Count;


  WordCount = RetCount >> 1;          // compute count as words 
  WordP = (USHORT UNALIGNED *)Buffer;     // word ptr to buffer

  io = sGetTxRxDataIO(ChP);
#ifdef WORD_ALIGN
  while (WordCount--)
  {
    *WordP++ = sInW(io);
  }
#else
  sInStrW((PUSHORT)io, WordP, WordCount);
#endif

  if (RetCount & 1)                    // odd count 
  {
    Buffer[RetCount - 1] = sInB((PUCHAR)io); // read last byte
  }

  return(RetCount);
}
#endif  // INTEL X86 version


#ifndef INTEL_ORDER
/*---------------------------------------------------------------------
  sWriteTxBlk - MIPS VERSION
|---------------------------------------------------------------------*/
ULONG _CDECL sWriteTxBlk(CHANPTR_T ChP,PUCHAR Buffer,ULONG Count)
{
  ULONG RetCount;
  ULONG WordCount;
  unsigned short TempWordLo;
  unsigned short TempWordHi;
  int ByteCount = 0;

  RetCount = MAXTX_SIZE - (int)sGetTxCnt(ChP); /* open space in Tx FIFO*/
  if (RetCount <= 0)                   /* no space available */
    return(0x0);
  if (RetCount > Count)
    RetCount = Count;                /* only enqueue as much as requested */

  WordCount = RetCount >> 1 ;     /* compute count as words */
  while (WordCount--)
  {
    TempWordLo = Buffer[ByteCount++] & 0xff;
    TempWordHi = Buffer[ByteCount++];
    TempWordHi = (TempWordHi << 8) & 0xff00; /* shift to high byte */
    TempWordHi |= TempWordLo;
    sOutW((PUCHAR)sGetTxRxDataIO(ChP), TempWordHi);
  }

  if (RetCount & 1)
  {
    sOutB( (PUCHAR)sGetTxRxDataIO(ChP), Buffer[ByteCount++] );
  }

  return(RetCount);
}

#else // NOT MIPS
/*------------------------------------------------------------------------
Function: sWriteTxBlk
Purpose:  Write a block of transmit data to a channel
Call:     sWriteTxBlk(ChP,Buffer,Count)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char *Buffer; Ptr to buffer containing data to transmit
          int Count; Size of buffer in bytes
Return:   int: Number of bytes actually written to the channel
-------------------------------------------------------------------------*/
ULONG _CDECL sWriteTxBlk(CHANPTR_T ChP,PUCHAR Buffer,ULONG Count)
{
  ULONG RetCount;
  ULONG WordCount;
  USHORT UNALIGNED *WordP;
  WIOA_T io;

  // 250, restrict to WORD amounts (boundary access thing)
  RetCount = MAXTX_SIZE - sGetTxCnt(ChP);

  if (RetCount > Count)
  {
    RetCount = Count;                /* only enqueue as much as requested */

#ifdef WORD_ALIGN
    // try to keep aligned on WORD boundary
    //if (RetCount & 1)
    //{
    //  if (RetCount > 1)
    //    --RetCount;
    //}
#endif
  }

  if (RetCount <= 0)                   // no space or nothing to send
    return 0;

  WordCount = RetCount >> 1;          /* compute count as words */
  WordP = (PUSHORT)Buffer;            /* word ptr to buffer */
  io = sGetTxRxDataIO(ChP);

  /* Write the data */
#ifdef WORD_ALIGN
  while( WordCount-- )
  {
     sOutW(io, *WordP++);
  }
#else
  sOutStrW(io,WordP,WordCount);
#endif

  if (RetCount & 1)                    /* odd count */
  {
    WordP=WordP+WordCount;
    sOutB((PUCHAR)io, Buffer[RetCount - 1]); /* send last byte */
  }

  return(RetCount);
}
#endif


/*--------------------------------------------------------------------------
Function: sWriteTxPrioBlk
Purpose:  Write a block of priority transmit data to a channel
Call:     sWriteTxPrioBlk(ChP,Buffer,Count)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char *Buffer; Ptr to buffer containing data to transmit
          int Count; Size of buffer in bytes, TXP_SIZE bytes maximum.  If
                     Count > TXP_SIZE only TXP_SIZE bytes will be written.
Return:   int: Number of bytes actually written to the channel, 0 if none
               written.
Comments: The entire block of priority data is transmitted before any data
          in the Tx FIFO.
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
int _CDECL sWriteTxPrioBlk(CHANPTR_T ChP,unsigned char *Buffer,int Count)
{
  unsigned char DWBuf[4];                 /* buffer for double word writes */
  register DWIOA_T IndexAddr;
  int WordCount,i;
  unsigned int UNALIGNED *WordP;
  unsigned int *DWBufLoP;
  unsigned int *DWBufHiP;

  IndexAddr = ChP->IndexAddr;
  sOutW((WIOA_T)IndexAddr,(USHORT)ChP->TxPrioCnt);    /* get priority queue status */
  if (sInB((BIOA_T)ChP->IndexData) & PRI_PEND) /* priority queue busy */
    return(0);                            /* nothing sent */

  if (Count > TXP_SIZE)
    Count = TXP_SIZE;
  WordCount = Count >> 1;                 /* compute count as words */
  if (Count & 1)                          /* adjust for odd count */
    WordCount++;
  WordP = (unsigned int *)Buffer;         /* word ptr to buffer */

  DWBufLoP = (unsigned int *)&DWBuf[0];
  DWBufHiP = (unsigned int *)&DWBuf[2];
  *DWBufLoP = ChP->TxPrioBuf;             /* data byte address */
  for(i = 0;i < WordCount;i++)            /* write data to Tx prioity buf */
  {
    *DWBufHiP = WordP[i];                 /* data word value */
    sOutDW(IndexAddr,*(ULONGPTR_T)DWBuf); /* write it out */
    *DWBufLoP += 2;
  }

  *DWBufLoP = ChP->TxPrioCnt;             /* Tx priority count address */
  *DWBufHiP = PRI_PEND + Count;           /* indicate count bytes pending */
  sOutDW(IndexAddr, *(ULONGPTR_T)DWBuf);  /* write it out */
  return(Count);
}

/***************************************************************************
Function: sWriteTxPrioByte
Purpose:  Write a byte of priority transmit data to a channel
Call:     sWriteTxPrioByte(ChP,Data)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned char Data; The transmit data byte
Return:   int: 1 if the bytes is successfully written, otherwise 0.
Comments: The priority byte is transmitted before any data in the Tx FIFO.
Warnings: No context switches are allowed while executing this function.
-------------------------------------------------------------------------*/
int _CDECL sWriteTxPrioByte(CHANPTR_T ChP,unsigned char Data)
{
  unsigned char DWBuf[4];             /* buffer for double word writes */
  unsigned int UNALIGNED *WordPtr;
  register DWIOA_T IndexAddr;

  /* Don't write to prio buf unless guarenteed Tx FIFO is not empty because
     of bug in AIOP */
  if(sGetTxCnt(ChP) > 1)              /* write it to Tx priority buffer */
  {
    IndexAddr = ChP->IndexAddr;
    sOutW((WIOA_T)IndexAddr, (USHORT)ChP->TxPrioCnt); /* get priority buffer status */
    if (sInB((BIOA_T)ChP->IndexData) & PRI_PEND) /* priority buffer busy */
      return(0);                    /* nothing sent */

    WordPtr = (unsigned int *)(&DWBuf[0]);
    *WordPtr = ChP->TxPrioBuf;       /* data byte address */
    DWBuf[2] = Data;                 /* data byte value */
    sOutDW(IndexAddr, *((ULONGPTR_T)(&DWBuf[0]))); /* write it out */

    *WordPtr = ChP->TxPrioCnt;       /* Tx priority count address */
    DWBuf[2] = PRI_PEND + 1;         /* indicate 1 byte pending */
    DWBuf[3] = 0;                    /* priority buffer pointer */
    sOutDW(IndexAddr, *((ULONGPTR_T)(&DWBuf[0]))); /* write it out */
  }
  else                                /* write it to Tx FIFO */
  {
    sWriteTxByte((BIOA_T)sGetTxRxDataIO(ChP),Data);
  }
  return(1);                          /* 1 byte sent */
}

/***************************************************************************
Function: sEnInterrupts
Purpose:  Enable one or more interrupts for a channel
Call:     sEnInterrupts(ChP,Flags)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned int Flags: Interrupt enable flags, can be any combination
             of the following flags:
                TXINT_EN:   Interrupt on Tx FIFO empty
                RXINT_EN:   Interrupt on Rx FIFO at trigger level (see
                            sSetRxTrigger())
                SRCINT_EN:  Interrupt on SRC (Special Rx Condition)
                MCINT_EN:   Interrupt on modem input change
                CHANINT_EN: Allow channel interrupt signal to the AIOP's
                            Interrupt Channel Register.
Return:   void
Comments: If an interrupt enable flag is set in Flags, that interrupt will be
          enabled.  If an interrupt enable flag is not set in Flags, that
          interrupt will not be changed.  Interrupts can be disabled with
          function sDisInterrupts().

          This function sets the appropriate bit for the channel in the AIOP's
          Interrupt Mask Register if the CHANINT_EN flag is set.  This allows
          this channel's bit to be set in the AIOP's Interrupt Channel Register.

          Interrupts must also be globally enabled before channel interrupts
          will be passed on the the host.  This is done with function
          sEnGlobalInt().

          In some cases it may be desirable to disable interrupts globally but
          enable channel interrupts.  This would allow the global interrupt
          status register to be used to determine which AIOPs need service.
-------------------------------------------------------------------------*/
void _CDECL sEnInterrupts(CHANPTR_T ChP,unsigned int Flags)
{
  unsigned char Mask;                 /* Interrupt Mask Register */


  ChP->RxControl[2] |=
     ((unsigned char)Flags & (RXINT_EN | SRCINT_EN | MCINT_EN));

  sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->RxControl[0]);

  ChP->TxControl[2] |= ((unsigned char)Flags & TXINT_EN);

  sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxControl[0]);

  if(Flags & CHANINT_EN)
  {
    Mask = sInB(ChP->IntMask) | (1 << ChP->ChanNum);
    sOutB(ChP->IntMask,Mask);
  }
}

/***************************************************************************
Function: sDisInterrupts
Purpose:  Disable one or more interrupts for a channel
Call:     sDisInterrupts(ChP,Flags)
          CHANPTR_T ChP; Ptr to channel structure
          unsigned int Flags: Interrupt flags, can be any combination
             of the following flags:
                TXINT_EN:   Interrupt on Tx FIFO empty
                RXINT_EN:   Interrupt on Rx FIFO at trigger level (see
                            sSetRxTrigger())
                SRCINT_EN:  Interrupt on SRC (Special Rx Condition)
                MCINT_EN:   Interrupt on modem input change
                CHANINT_EN: Disable channel interrupt signal to the
                            AIOP's Interrupt Channel Register.
Return:   void
Comments: If an interrupt flag is set in Flags, that interrupt will be
          disabled.  If an interrupt flag is not set in Flags, that
          interrupt will not be changed.  Interrupts can be enabled with
          function sEnInterrupts().

          This function clears the appropriate bit for the channel in the AIOP's
          Interrupt Mask Register if the CHANINT_EN flag is set.  This blocks
          this channel's bit from being set in the AIOP's Interrupt Channel
          Register.
-------------------------------------------------------------------------*/
void _CDECL sDisInterrupts(CHANPTR_T ChP,unsigned int Flags)
{
  unsigned char Mask;                 /* Interrupt Mask Register */

  ChP->RxControl[2] &=
        ~((unsigned char)Flags & (RXINT_EN | SRCINT_EN | MCINT_EN));
  sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->RxControl[0]);
  ChP->TxControl[2] &= ~((unsigned char)Flags & TXINT_EN);
  sOutDW(ChP->IndexAddr,*(ULONGPTR_T)&ChP->TxControl[0]);

  if(Flags & CHANINT_EN)
  {
    Mask = sInB(ChP->IntMask) & (~(1 << ChP->ChanNum));
    sOutB(ChP->IntMask,Mask);
  }
}

/***************************************************************************
Function: sReadMicrocode
Purpose:  Read the microcode directly from a channel
Call:     sReadMicrocode(ChP,Buffer,Count)
          CHANPTR_T ChP; Ptr to channel structure
          char *Buffer; Ptr to buffer for microcode
          int Count; Number of bytes to read
Return:   void
Warnings: Buffer must be large enough to hold Count bytes.
-------------------------------------------------------------------------*/
void _CDECL sReadMicrocode(CHANPTR_T ChP,char *Buffer,int Count)
{
  WIOA_T IndexAddr;
  BIOA_T IndexData;
  unsigned int McodeOff;

  IndexAddr = (WIOA_T)ChP->IndexAddr;
  IndexData = (BIOA_T)ChP->IndexData;
  McodeOff = MCODE_ADDR + (unsigned int)sGetChanNum(ChP) * 0x1000;

  while(Count-- > 0)
  {
    sOutW(IndexAddr,(USHORT)(McodeOff++));
    *Buffer++ = sInB((BIOA_T)IndexData);
  }
}


/*------------------------------------------------------------------
 sSetBaudRate - Set the desired baud rate.  Return non-zero on error.
|-------------------------------------------------------------------*/
int sSetBaudRate(CHANNEL_T *ChP,
                 ULONG desired_baud,
                 USHORT SetHardware)
{
  ULONG diff;
  ULONG act_baud;
  ULONG percent_error;
  ULONG div;
  ULONG base_clock_rate;
  ULONG clock_freq = ChP->CtlP->ClkRate;
  ULONG clk_prescaler = (ULONG)ChP->CtlP->ClkPrescaler;

  base_clock_rate = ((clock_freq/16) / ((clk_prescaler & 0xf)+1));

  ///////////////////////////////////////
  // calculate the divisor for our hardware register.
  // this is really just div = clk/desired_baud -1.  but we do some
  // work to minimize round-off error.
  if (desired_baud <= 0)
    desired_baud = 1;  // guard against div 0

  div =  ((base_clock_rate+(desired_baud>>1)) / desired_baud) - 1;
  if (div > 8191)  // overflow hardware divide register
    div = 8191;

  // this is really just (clk) / (div+1) but we do some
     // work to minimize round-off error.
  act_baud = (base_clock_rate+((div+1)>>1)) / (div+1);

  if (desired_baud > act_baud)
    diff = desired_baud - act_baud;
  else
    diff = act_baud - desired_baud;

  percent_error = (diff * 100) / desired_baud;
  if (percent_error > 5)
    return (int) percent_error;

  if (SetHardware)
  {
    sChanOutWI(ChP, _BAUD, div);
  }
  return 0;

}

/*------------------------------------------------------------------
Function: sChanOutWI
Purpose:  Write an Indirect Register on the Rocket Port Board
Call:     sChanOutWI(CHANNEL_T *ChP, WORD RegNum,  WORD val)
          CHANPTR_T ChP; Ptr to channel structure
          WORD RegNum;   Indirect Register Number to Write
          WORD val;      Value to Write.
Return:   void
Comments: This is a little slower than using macros but far less ugly
          and error prone.  Macros should only be used where speed is
          imperative.
|-------------------------------------------------------------------*/
void sChanOutWI(CHANNEL_T *ChP, USHORT RegNum, ULONG  val)
{
  UCHAR m[4];
  USHORT ChOff;

   ChOff = ChP->ChanNum * 0x1000;   // change this to look up table
             // see about speeding this up:
   m[0] = (unsigned char)(ChOff + RegNum);
   m[1] = (unsigned char)((ChOff + RegNum) >> 8);
   m[2] = (unsigned char) val;
   m[3] = (unsigned char)(val >> 8);
   sOutDW(ChP->IndexAddr,*(ULONG *)&m[0]);
}

/*------------------------------------------------------------------
Function: sModemReset
Purpose:  Set or clear reset state on second generation RocketModem
Call:     sModemReset(CHANNEL_T *ChP, int on)
          CHANNEL_T *ChP; Ptr to channel structure
          int on;         on!=0 to enable reset; on=0 to clear reset
Return:   void
Comments: The newer RocketModem boards power up in a reset state.
          This routine is used to clear the board from reset state or
          re-enable a reset state.  Called from the driver during
          initialization to clear the reset and via an ioctl to
          manually reset the board.  [jl] 980206
BUGBUG: this code violates io-resource handling under NT and will
  probably break running on ALPHA machines due to bypassing NT's
  io-mapping scheme(i.e. should not be doing AiopIO[1] = AiopIO[0] +..)
  Also, this driver is probably not calling IoResource calls to claim
  this IO space properly(could result in conflicting hardware.)
|-------------------------------------------------------------------*/
void sModemReset(CHANNEL_T *ChP, int on)
{
  CONTROLLER_T *CtlP;
  WIOA_T    addr;
  BYTE    val;

  CtlP = ChP->CtlP;

  if (CtlP->BusType == Isa)
  {
    // ensure second aiop CS is enabled.  there will be no physical
    // aiop to enable, but the CS (which ususally goes to an aiop
    // is routed to a latch, which latches the RESET signal.  we
    // have to also ensure that the mudback-Isa bus controller
    // aiopic io-addr has been configured for the proper address
    // space.  since the rocketmodem Isa product is limited to
    // eight ports, we know that the second aiop will be configured
    // 400h above the first eight port aiop chip...
     val = sInB(CtlP->MBaseIO + 3);

    // read in, see if aiop[1] enabled...
    if ((CtlP->AiopIO[1] != (PUSHORT)((unsigned int)(CtlP->AiopIO[0]) + 0x400)) ||
        ((val & 2) == 0))
    {
      // cr second aiop chip not enabled. Isa board alias
       CtlP->AiopIO[1] = (PUSHORT)((unsigned int)(CtlP->AiopIO[0]) + 0x400);

      // tell mudback where to position the base-io of the aiopic...
       val = sInB(CtlP->MBaseIO + 2); // read in irq, aiop-io reg
       sOutB(CtlP->MBaseIO + 2, (BYTE)((val & 0xfc) | (1 & 0x03))); //aiop index

      // setup aiop i/o in mudbac...
       sOutB(CtlP->MBaseIO, (BYTE)((unsigned int)CtlP->AiopIO[1] >> 6));
     }
    sEnAiop(CtlP,1);      //  enable the (un)AIOP
   }
  else if (CtlP->BusType == PCIBus)
  {
    // PCI bus RocketModem reset...
    // we reference where the second AIOP would be, if there were one,..
     CtlP->AiopIO[1] = (PUSHORT)((unsigned int)CtlP->AiopIO[0] + 0x40);
   }

  // the latch has 3-pin mux which determines which latch the
  // data gets routed to.  these pins are hooked to the first
  // three address lines.  the fourth address line (8h) is used
  // as the data line.
   addr = CtlP->AiopIO[1];

  // adjust reset state...
   sOutB(((PUCHAR)(addr) + ChP->ChanNum + (on ? 0 : 8)), 0);

  // disable the aiop; must disable to prevent chip select from getting hit
  // with continuous pulses (causing reset to occur).

  // additionally it seems that a read of some other address is required
  // before the disable or the first channel on the board goes back into the
  // reset state.  there's nothing special about ChP->IntChan...a read of
  // any port would probably work...
   sInB(ChP->IntChan);

  if (CtlP->BusType == Isa)
  {
    sDisAiop(CtlP, 1);
  }
}

/*------------------------------------------------------------------
Function: sModemWriteROW
Purpose:  Send the "Rest of World" configuration string to the
          RocketModem port.
Call:     sModemSendROW(CHANNEL_T *ChP, USHORT CountryCode)
          CHANNEL_T *ChP;     Ptr to channel structure
          USHORT CountryCode; Country to configure the modem for
Return:   void
Comments: The ROW "SocketModem" RocketModem boards can compensate for
          the differences in various internation phone systems.  This
          function sends the appropriate configuration string based
          upon a registry setting specified by the user. [jl] 980316

          Modem should be hard reset before calling this function. Otherwise,
          use AT modem reset commands...
|-------------------------------------------------------------------*/
void sModemWriteROW(CHANNEL_T *ChP, USHORT CountryCode)
{
    CONTROLLER_T *CtlP = ChP->CtlP;
    char *ModemConfigString = {"AT*NCxxZ\r"};
    int   max;

    MyKdPrint(D_Init,("sModemWriteROW: %x, %x\n",(unsigned long)ChP,CountryCode)) // DEBUG

    if (CountryCode == ROW_NA) {
        MyKdPrint(D_Init,("ROW Write, North America\n"))
        return;
    }
/*
    create the country config string...
*/
    ModemConfigString[5] = '0' + (CountryCode / 10);
    ModemConfigString[6] = '0' + (CountryCode % 10);
    MyKdPrint(D_Init,("ROW Write, Chan:%d, Cfg:%s\n", ChP->ChanNum, ModemConfigString))

    time_stall(10); // TUNE       
    
    sFlushTxFIFO(ChP);     
    sFlushRxFIFO(ChP);     

    sSetBaudRate(ChP,9600,TRUE);
    sSetData8(ChP);

    sClrTxXOFF(ChP);
  
    sEnRTSFlowCtl(ChP);
    sEnCTSFlowCtl(ChP);
 
    if (sGetChanStatus(ChP) & STATMODE) {
        sDisRxStatusMode(ChP);
    }

    sGetChanIntID(ChP);

    sEnRxFIFO(ChP);     
    sEnTransmit(ChP);
        
    sSetRTS(ChP);
/*
    spin while port readies...
*/
    time_stall(10);

    sModemWriteDelay(ChP,ModemConfigString,strlen(ModemConfigString));

    (void) sModemRead(ChP,"OK",sizeof("OK\r") - 1,10);
   
    time_stall(1);

    sFlushRxFIFO(ChP);

    sClrRTS(ChP);
}

/*------------------------------------------------------------------
Function: sModemSpeakerEnable
Purpose:  Enable RocketModemII board speaker
Call:     sModemSpeakerEnable(CHANNEL_T *ChP)
          CHANNEL_T *ChP; Ptr to channel structure
Return:   void
Comments: Called from the driver during initialization to 
          enable the board speaker.
|-------------------------------------------------------------------*/
void sModemSpeakerEnable(CHANNEL_T *ChP)
{
    CONTROLLER_T *CtlP;
    WIOA_T    addr;
    BYTE    val;

    CtlP = ChP->CtlP;
/*
    PCI bus RocketModem reset...
*/
    if (CtlP->BusType != PCIBus)
        return;
/*
    we reference where the second AIOP would be,..
*/
    CtlP->AiopIO[1] = (PUSHORT)((unsigned int)CtlP->AiopIO[0] + 0x40);
/*
    the latch has 3-pin mux which determines which latch the
    data gets routed to.  these pins are hooked to the first
    three address lines.  the fourth address line (8h) is used
    as the data line...
*/
    addr = CtlP->AiopIO[1];
/*
    following is hack to enable the speaker (PCI cards only). we don't want
    to construct an extension and related storage for a speaker, so we'll
    just piggyback the enable of the speaker onto another channel...
*/
    sOutB(((PUCHAR)(addr) + 7 + 8), 0);
}

/*------------------------------------------------------------------
Function: sModemWriteDelay
Purpose:  Send a string to the RocketModem port, pausing for each character
     to clear the FIFO.
Call:     sModemSendROW(CHANNEL_T *ChP, char *string,int length)
     CHANNEL_T *ChP;     Ptr to channel structure
     char *string;       String to write
     int  length         Length of string, not including any trailing null
Return:   void
Comments: Output characters one at a time
|-------------------------------------------------------------------*/

void 
sModemWriteDelay(CHANNEL_T *ChP,char *string,int length)
{
    int   index,count;
    unsigned char  buffer[2];

    sFlushTxFIFO(ChP);
    sFlushRxFIFO(ChP);

    if (
    (length <= 0) 
    || 
    (string == (char *)NULL)
    )
        return;

    index = 0;
    count = 0;

    while (length--) {
        while (count = (int)sGetTxCnt(ChP)) {
/*
    byte or bytes in transmit FIFO. wait a while. adjust interval...
*/
            ms_time_stall(10 * count);
/*
    no change? assume FIFO stuck, bail out of loop...
*/
            if (count == (int)sGetTxCnt(ChP)) {
                break;
            }
        }
/*
    transmit FIFO probably available. put a byte in it, pause a moment...
*/
        sWriteTxByte((BIOA_T)sGetTxRxDataIO(ChP),(unsigned char)string[index]);

        ++index;
    }
}

/********************************************************************

   send string to modem...

*********************************************************************/
void 
sModemWrite(CHANNEL_T *ChP, char *string, int length)
{
    if (
    (length <= 0) 
    || 
    (string == (char *)NULL)
    )
        return;

    sWriteTxBlk(ChP, (unsigned char *)string, length);
}

/********************************************************************

   look for match on a particular character string...

********************************************************************/
int sModemRead(CHANNEL_T *ChP, char *string,int length, int poll_retries)
{
    unsigned char    buffer;
    long    count;
    int     arg_index;
    int     read_retries;
    WIOA_T  io;
    unsigned int   fifo_data;

#ifdef DUMPDATA
    DumpIndex = 0; 
#endif
/*
    bail if board not installed...
*/
    fifo_data = (unsigned int)sGetRxCnt(ChP);
/*
    see if board installed and functioning. if not, architecture returns
    bad value. if so, stonewall on read...
*/
    if (fifo_data > (unsigned int)RXFIFO_SIZE)
    return(-1);
   
    io = sGetTxRxDataIO(ChP);

    poll_retries *= 10;

    buffer = (char)0;

    arg_index = 0;
/*
    search until we see a match on the argument characters, or we run out of data...
*/
    do {
        while (sGetRxCnt(ChP) > 0) {
            buffer = sReadRxByte((PUCHAR)io);

#ifdef DUMPDATA
            DumpResponseByte(buffer);
#endif
/*
    force response to upper case, since responses are different depending on
    whether the modem was loaded already or not...
*/
            if (buffer >= 'a')
                buffer ^= 0x20;

            if (string[arg_index] == buffer) {
                ++arg_index;
/*
    see if we're done. if so, bail with good return code...
*/
                if (arg_index == length) {
                    time_stall(TENTH_SECOND);
#ifdef DUMPDATA
                    while (sGetRxCnt(ChP) > 0) {
                        buffer = sReadRxByte((PUCHAR)io);
                        DumpResponseByte(buffer);
                    }
                    MyKdPrint(D_Init,("sModemRead: %x [%s]\n",(unsigned long)ChP,DumpArray))
#endif
                    sFlushRxFIFO(ChP);
                    return(0);
                }
            }
            else {
                arg_index = 0;
            }
        }

        ms_time_stall(10);
    } while (poll_retries-- > 0);

#ifdef DUMPDATA
    MyKdPrint(D_Init,("sModemRead: %x [%s]\n",(unsigned long)ChP,DumpArray))
#endif

    return(-1);
}

/********************************************************************

   look for match on two possibilities...

********************************************************************/
int sModemReadChoice(CHANNEL_T *ChP,
    char *string0,
    int length0,
    char *string1,
    int length1,
    int poll_retries)
{
    char    buffer;
    long    count;
    int     arg_index0;
    int     arg_index1;
    char    *ptr;
    WIOA_T  io;
    unsigned int   fifo_data;

#ifdef DUMPDATA
    DumpIndex = 0;
#endif
    MyKdPrint(D_Init,("sModemReadChoice: %x\n",(unsigned long)ChP))

    poll_retries *= 10;
/*
    bail if board not installed...
*/
    fifo_data = (unsigned int)sGetRxCnt(ChP);
/*
    see if board installed and functioning. if not, architecture returns
    likely -1. if so, stonewall on read...
*/
    if (fifo_data > (unsigned int)RXFIFO_SIZE)
        return(-1);

    io = sGetTxRxDataIO(ChP);

    buffer = (char)0;

    arg_index0 = 0;
    arg_index1 = 0;
/*
    first, we discard characters until we see a match on the argument characters, 
    or we run out of data...
*/
    do {
        while (sGetRxCnt(ChP) > 0) {
            buffer = sReadRxByte((PUCHAR)io);

#ifdef DUMPDATA
            DumpResponseByte(buffer);
#endif
/*
    force response to upper case, since responses can be different depending on 
    whether the modem was loaded already or not...
*/
            if (buffer >= 'a')
                buffer ^= 0x20;
/*
    check first argument...
*/
            if (string0[arg_index0] == buffer) {
                ++arg_index0;
/*
    see if we're done matching on string 0...
*/
                if (arg_index0 >= length0) {
                    time_stall(TENTH_SECOND);

#ifdef DUMPDATA
                    while (sGetRxCnt(ChP) > 0) {
                        buffer = sReadRxByte((PUCHAR)io);
                        DumpResponseByte(buffer);
                    }
                    MyKdPrint(D_Init,("sModemReadChoice: %x\r\n[%s]\n",(unsigned long)ChP,DumpArray))
#endif
                    sFlushRxFIFO(ChP);
                    return(0);
                }
            }
            else {
                arg_index0 = 0;
            }
/*
    check argument 1...
*/
            if (string1[arg_index1] == buffer) {
                ++arg_index1;
/*
    see if we're done matching on string 1...
*/
                if (arg_index1 >= length1) {
                    time_stall(TENTH_SECOND);

#ifdef DUMPDATA
                    while (sGetRxCnt(ChP) > 0) {
                        buffer = sReadRxByte((PUCHAR)io);
                        DumpResponseByte(buffer);
                    }
                    MyKdPrint(D_Init,("sModemReadChoice: %x\r\n[%s]\n",(unsigned long)ChP,DumpArray))
#endif
                    sFlushRxFIFO(ChP);
                    return(1);
                }
            }
            else {
                arg_index1 = 0;
            }
        }

        ms_time_stall(10);

    } while (poll_retries-- > 0);
/*
    no match...
*/
#ifdef DUMPDATA
    MyKdPrint(D_Init,("sModemReadChoice: %x\r\n[%s]\n",(unsigned long)ChP,DumpArray))
#endif

    sFlushRxFIFO(ChP);

    return(-1);
}

/********************************************************************

   check transmit FIFO...

*********************************************************************/
int sTxFIFOStatus(CHANNEL_T *ChP)
{
    unsigned int fifo_size;
/*
    see if board installed and functioning. if not, architecture returns
    bad count. if so, stonewall on fifo ready...
*/
    fifo_size = (unsigned int)sGetTxCnt(ChP);

    if (fifo_size > (unsigned int)TXFIFO_SIZE)
        return(MAXTX_SIZE);

    if (MAXTX_SIZE <= (unsigned int)sGetTxCnt(ChP))
        return(MAXTX_SIZE);
/*
    return number of data bytes in FIFO...
*/
    return(sGetTxCnt(ChP));
}

/********************************************************************

  check available space in transmit FIFO. there's two checks here:
  one for whether the FIFO is present;
  one for whether the FIFO is full...

*********************************************************************/
int sTxFIFOReady(CHANNEL_T *ChP)
{
    unsigned int   fifo_size;
/*
    see if board installed and functioning. if not, architecture likely returns
    a bad value. if so, stonewall on fifo ready...
*/
    fifo_size = (unsigned int)sGetTxCnt(ChP);

    if (fifo_size > (unsigned int)TXFIFO_SIZE)
        return(0);
/*
    if number of data bytes currently in FIFO is greater than the
    available space, return busy for now...
*/
    if (sGetTxCnt(ChP) >= MAXTX_SIZE)
        return(0);
/*
    return (size of FIFO - number of data bytes in FIFO)...
*/
    return(MAXTX_SIZE - sGetTxCnt(ChP));
}

/********************************************************************

  discard pending data in receive FIFO. pull in data until data
  runs out or count goes to zero...

*********************************************************************/
int sRxFIFOReady(CHANNEL_T *ChP)
{
    unsigned char   buffer;
    int     retries;
    WIOA_T  io;
    unsigned int  count;

    count = (unsigned int)sGetRxCnt(ChP);

    if (count > (unsigned int)RXFIFO_SIZE)
        return(-1);

    if (!count)
        return(0);

    retries = 20;

    io = sGetTxRxDataIO(ChP);

    do {
        count = RXFIFO_SIZE + 2;            // set to size of FIFO + slop...

        while (
        (sGetRxCnt(ChP)) 
        && 
        (count--)
        ) {
            buffer = sReadRxByte((PUCHAR)io);
        }
/*
    if receive FIFO is now empty, bail out. if it was full, though,
    pause a moment and then check to see if it has refilled -
    if it has, flush that, and then check again. what we're trying to do
    here is empty the FIFO, and still detect a run-on condition...
*/
        if (count)
            return(0);

        ms_time_stall(10);

    } while (--retries);
/*
    receive FIFO didn't empty, though we gave it several chances...
*/
    return(-1);
}

#ifdef DUMPDATA

/********************************************************************

   dump responses to log...

********************************************************************/
void DumpResponseByte(char buffer)
{
    if (DumpIndex < sizeof(DumpArray) - 2) {
        switch (buffer) {
            case '\n': {
                DumpArray[DumpIndex++] = '\\';
                DumpArray[DumpIndex++] = 'n';
                break;
            }

            case '\r': {
                DumpArray[DumpIndex++] = '\\';
                DumpArray[DumpIndex++] = 'r';
                break;
            }

            case '\t': {
                DumpArray[DumpIndex++] = '\\';
                DumpArray[DumpIndex++] = 't';
                break;
            }

            case '\0': {
                DumpArray[DumpIndex++] = '\\';
                DumpArray[DumpIndex++] = '0';
                break;
            }

            default: {
                if (buffer < ' ') {
                    DumpArray[DumpIndex++] = '?';    
                }
                else {
                    DumpArray[DumpIndex++] = buffer;
                }
            }
        }

        DumpArray[DumpIndex] = 0;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\utils.h ===
//----- utils.h

VOID SyncUp(IN PKINTERRUPT IntObj,
            IN PKSPIN_LOCK SpinLock,
            IN PKSYNCHRONIZE_ROUTINE SyncProc,
            IN PVOID Context);

VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    );

VOID
SerialGetNextIrp(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent,
    IN PSERIAL_DEVICE_EXTENSION extension
    );

VOID
SerialTryToCompleteCurrent(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess OPTIONAL,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PSERIAL_START_ROUTINE Starter OPTIONAL,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp OPTIONAL,
    IN LONG RefType
    );

VOID
SerialRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL
    );

NTSTATUS
SerialStartOrQueue(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    );

VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

//--- error.h
VOID
SerialCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

//--- flush.h

NTSTATUS SerialFlush(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS SerialStartFlush(IN PSERIAL_DEVICE_EXTENSION Extension);

//---- purge.h
NTSTATUS SerialStartPurge(IN PSERIAL_DEVICE_EXTENSION Extension);

//---- qsfile.h

NTSTATUS
SerialQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//----  routines to deal with unicode bloat

//----  typedefs to convienently allocate uniccode struct and buffer
typedef struct {
  UNICODE_STRING ustr;
  WCHAR wstr[240];
} USTR_240;

typedef struct {
  UNICODE_STRING ustr;
  WCHAR wstr[160];
} USTR_160;

typedef struct {
  UNICODE_STRING ustr;
  WCHAR wstr[80];
} USTR_80;

typedef struct {
  UNICODE_STRING ustr;
  WCHAR wstr[40];
} USTR_40;

OUT PCHAR UToC1(IN PUNICODE_STRING ustr);

OUT PCHAR UToCStr(
         IN OUT PCHAR Buffer,
         IN PUNICODE_STRING ustr,
         IN int BufferSize);

OUT PUNICODE_STRING CToU1(IN const char *c_str);

OUT PUNICODE_STRING CToU2(IN const char *c_str);

OUT PUNICODE_STRING CToUStr(
         OUT PUNICODE_STRING Buffer,
         IN const char * c_str,
         IN int BufferSize);

VOID WStrToCStr(OUT PCHAR c_str, IN PWCHAR w_str, int max_size);
int get_reg_value(
                  IN HANDLE keyHandle,
                  OUT PVOID outptr,
                  IN PCHAR val_name,
                  int max_size);

void OurTrace(char *leadstr, char *newdata);
void TraceDump(PSERIAL_DEVICE_EXTENSION ext, char *newdata, int sCount, int style);
void TracePut(char *newdata, int sCount);
int __cdecl our_vsnprintf(char *buffer, size_t Limit, const char *format, va_list Next);
void __cdecl TTprintf(char *leadstr, const char *format, ...);
void __cdecl Tprintf(const char *format, ...);
void __cdecl Sprintf(char *dest, const char *format, ...);
void __cdecl Dprintf(const char *format, ...);
void __cdecl Eprintf(const char *format, ...);
void MyAssertMessage(char *filename, int line);
void EvLog(char *mess);
char *our_ultoa(unsigned long u, char* s, int radix);
char *our_ltoa(long value, char* s, int radix);

int listfind(char *str, char **list);
int our_isdigit(char c);
int getnumbers(char *str, long *nums, int max_nums, int hex_flag);
int getstr(char *deststr, char *textptr, int *countptr, int max_size);
int my_lstricmp(char *str1, char *str2);
int getint(char *textptr, int *countptr);
int getnum(char *str, int *index);
int my_sub_lstricmp(const char *name, const char *codeline);
unsigned int gethint(char *bufptr, int *countptr);
int my_toupper(int c);
void hextoa(char *str, unsigned int v, int places);
void our_free(PVOID ptr, char *str);
PVOID our_locked_alloc(ULONG size, char *str);
void our_assert(int id, int line);

int mac_cmp(UCHAR *mac1, UCHAR *mac2);
void time_stall(int tenth_secs);
void ms_time_stall(int millisecs);
WCHAR *str_to_wstr_dup(char *str, int alloc_space);
int BoardExtToNumber(PSERIAL_DEVICE_EXTENSION board_ext);
int NumDevices(void);
int NumPorts(PSERIAL_DEVICE_EXTENSION board_ext);
int PortExtToIndex(PSERIAL_DEVICE_EXTENSION port_ext,
             int driver_flag);
int is_board_in_use(PSERIAL_DEVICE_EXTENSION board_ext);
PSERIAL_DEVICE_EXTENSION find_ext_by_name(char *name, int *dev_num);
PSERIAL_DEVICE_EXTENSION find_ext_by_index(int dev_num, int port_num);
int our_open_key(OUT PHANDLE phandle,
                 IN OPTIONAL HANDLE relative_key_handle,
                 IN char *regkeyname,
                 IN ULONG attribs);
int our_enum_key(IN HANDLE handle,
                 IN int index,
                 IN CHAR *buffer,
                 IN ULONG max_buffer_size,
                 OUT PCHAR *retdataptr);
int our_query_value(IN HANDLE Handle,
                    IN char *key_name, 
                    IN CHAR *buffer,
                    IN ULONG max_buffer_size,
                    OUT PULONG type,
                    OUT PCHAR *retdataptr);
int our_enum_value(IN HANDLE handle,
                   IN int index,
                   IN CHAR *buffer,
                   IN ULONG max_buffer_size,
                   OUT PULONG type,
                   OUT PCHAR *retdataptr,
                   OUT PCHAR sz_retname);
int our_set_value(IN HANDLE Handle,
                    IN char *key_name,
                    IN PVOID pValue,
                    IN ULONG value_size,
                    IN ULONG value_type);
int our_open_device_reg(OUT HANDLE *pHandle,
                        IN PSERIAL_DEVICE_EXTENSION dev_ext,
                        IN ULONG RegOpenRights);
int our_open_driver_reg(OUT HANDLE *pHandle,
                        IN ULONG RegOpenRights);
#define our_close_key(handle) \
  { if (handle) {ZwClose(handle); handle = NULL;} }

void ModemReset(PSERIAL_DEVICE_EXTENSION ext, int on);
void ModemSpeakerEnable(PSERIAL_DEVICE_EXTENSION ext);
void ModemWriteROW(PSERIAL_DEVICE_EXTENSION ext, USHORT CountryCode);
void ModemWrite(PSERIAL_DEVICE_EXTENSION ext,char *string,int length);
void ModemWriteDelay(PSERIAL_DEVICE_EXTENSION ext,char *string,int length);
void ModemIOReady(PSERIAL_DEVICE_EXTENSION ext,int speed);
void ModemUnReady(PSERIAL_DEVICE_EXTENSION ext);
int  ModemRead(PSERIAL_DEVICE_EXTENSION ext,char *s0,int len0,int poll_retries);
int  ModemReadChoice(PSERIAL_DEVICE_EXTENSION ext,char *s0,int len0,char *s1,int len1,int poll_retries);
int  TxFIFOReady(PSERIAL_DEVICE_EXTENSION ext);   
int  TxFIFOStatus(PSERIAL_DEVICE_EXTENSION ext);
int  RxFIFOReady(PSERIAL_DEVICE_EXTENSION ext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\waitmask.c ===
/*-------------------------------------------------------------------
| waitmask.c -

3-30-99 - fix cancel event operation(race-condition) to avoid
  potential bug-check on queued eventwait cancel.
11-24-98 - update event kdprint debug messages - kpb
Copyright 1993-99 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

/*------------------------------------------------------------------
 SerialCancelWait - (setup in ioctl.c currently, 3-28-98, kpb)
    This routine is used to cancel a irp that is waiting on a comm event.
|-------------------------------------------------------------------*/
VOID SerialCancelWait(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)

{
  PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;

  MyKdPrint(D_Ioctl,("CancelWait\n"))
  // take out, 3-30-99, kpb... Extension->IrpMaskLocation = NULL;
  if (Extension->CurrentWaitIrp)
  {
    PIRP Irp_tmp;

    MyKdPrint(D_Ioctl,("Cancel a Wait\n"))

    //***** add, 3-30-99, kpb, cause crash on read thread in dos box without
    // grab from ISR timer or interrupt routine.
    SyncUp(Driver.InterruptObject,
           &Driver.TimerLock,
           SerialGrabWaitFromIsr,
           Extension);
    //***** end add, 3-30-99

    // ExtTrace(Extension,D_Ioctl, "Cancel Event");
    Extension->CurrentWaitIrp->IoStatus.Information = 0;
    Extension->CurrentWaitIrp->IoStatus.Status = STATUS_CANCELLED;

    Irp_tmp = Extension->CurrentWaitIrp;
    IoSetCancelRoutine(Irp_tmp, NULL);  // add 9-15-97, kpb
    Extension->CurrentWaitIrp = 0;
    IoReleaseCancelSpinLock(Irp->CancelIrql);
    SerialCompleteRequest(Extension, Irp_tmp, IO_SERIAL_INCREMENT);
  }
  else
  {
    IoReleaseCancelSpinLock(Irp->CancelIrql);
    ExtTrace(Extension,D_Ioctl, "Err Cancel Event!");
    MyKdPrint(D_Ioctl,("No Wait to Cancel\n"))
  }
}

/*------------------------------------------------------------------
 SerialCompleteWait - called by isr.c via CommWaitDpc.  It nulls out
   IrpMaskLocation to signal control passed back to us.
|-------------------------------------------------------------------*/
VOID SerialCompleteWait(IN PKDPC Dpc,IN PVOID DeferredContext,
                        IN PVOID SystemContext1, IN PVOID SystemContext2)
{
    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;
    PIRP Irp_tmp;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

   MyKdPrint(D_Ioctl,("Complete Wait\n"))
   IoAcquireCancelSpinLock(&OldIrql);

   if (Extension->CurrentWaitIrp != 0)
   {
    MyKdPrint(D_Ioctl,("Complete a Wait\n"))
    ExtTrace2(Extension,D_Ioctl, "Event Done Got:%xH Mask:%xH",
              *(ULONG *) Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer,
              Extension->IsrWaitMask);

     Extension->WaitIsISRs = 0;
     Extension->IrpMaskLocation = &Extension->DummyIrpMaskLoc;

     // caller sets the ULONG bit flags indicating event at .SystemBuffer
     //*(ULONG *)Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer = 0;
     Extension->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;
     Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
     Irp_tmp = Extension->CurrentWaitIrp;
     IoSetCancelRoutine(Irp_tmp, NULL);  // add 9-15-97, kpb
     Extension->CurrentWaitIrp = 0;
     IoReleaseCancelSpinLock(OldIrql);
     SerialCompleteRequest(Extension, Irp_tmp, IO_SERIAL_INCREMENT);
   }
   else
   {
     MyKdPrint(D_Ioctl,("No wait to complete\n"))
     IoReleaseCancelSpinLock(OldIrql);
   }
}

/*------------------------------------------------------------------
  SerialGrabWaitFromIsr - Take back the wait packet from the ISR by
   reseting IrpMaskLocation in extension.  Need to use a sync with
   isr/timer routine to avoid contention in multiprocessor environments.

   Called from sync routine or with timer spinlock held.

  App - Can set IrpMaskLocation to give read-irp handling to the ISR without
    syncing to ISR.
  ISR - Can reset ReadPending to give wait-irp handling back to app-time.

  If App wants to grab control of read-irp handling back from ISR, then
  it must sync-up with the isr/timer routine which has control.
|-------------------------------------------------------------------*/
BOOLEAN SerialGrabWaitFromIsr(PSERIAL_DEVICE_EXTENSION Extension)
{
  Extension->WaitIsISRs = 0;
  Extension->IrpMaskLocation = &Extension->DummyIrpMaskLoc;
  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\rk5\rocklog.h ===
//File Name: rocklog.mc
//Constant definitions for the I/O error code log values.

#ifndef _ROCKLOG_
#define _ROCKLOG_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SERIAL_RP_INIT_FAIL
//
// MessageText:
//
//  The RocketPort or RocketModem could not be initialized with the current settings.
//
#define SERIAL_RP_INIT_FAIL              ((NTSTATUS)0x80060001L)

//
// MessageId: SERIAL_RP_INIT_PASS
//
// MessageText:
//
//  The RocketPort/RocketModem driver has successfully initialized its hardware.
//
#define SERIAL_RP_INIT_PASS              ((NTSTATUS)0x40060002L)

//
// MessageId: SERIAL_NO_SYMLINK_CREATED
//
// MessageText:
//
//  Unable to create the symbolic link for %2.
//
#define SERIAL_NO_SYMLINK_CREATED        ((NTSTATUS)0x80060003L)

//
// MessageId: SERIAL_NO_DEVICE_MAP_CREATED
//
// MessageText:
//
//  Unable to create the device map entry for %2.
//
#define SERIAL_NO_DEVICE_MAP_CREATED     ((NTSTATUS)0x80060004L)

//
// MessageId: SERIAL_NO_DEVICE_MAP_DELETED
//
// MessageText:
//
//  Unable to delete the device map entry for %2.
//
#define SERIAL_NO_DEVICE_MAP_DELETED     ((NTSTATUS)0x80060005L)

//
// MessageId: SERIAL_UNREPORTED_IRQL_CONFLICT
//
// MessageText:
//
//  Another driver on the system, which did not report its resources, has already claimed interrupt %3 used by %2.
//
#define SERIAL_UNREPORTED_IRQL_CONFLICT  ((NTSTATUS)0xC0060006L)

//
// MessageId: SERIAL_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Not enough memory was available to allocate internal storage needed for %2.
//
#define SERIAL_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC0060007L)

//
// MessageId: SERIAL_NO_PARAMETERS_INFO
//
// MessageText:
//
//  No Parameters subkey was found for user defined data.
//
#define SERIAL_NO_PARAMETERS_INFO        ((NTSTATUS)0xC0060008L)

//
// MessageId: SERIAL_UNABLE_TO_ACCESS_CONFIG
//
// MessageText:
//
//  Specific user configuration data is unretrievable.
//
#define SERIAL_UNABLE_TO_ACCESS_CONFIG   ((NTSTATUS)0xC0060009L)

//
// MessageId: SERIAL_UNKNOWN_BUS
//
// MessageText:
//
//  The bus type for %2 is not recognizable.
//
#define SERIAL_UNKNOWN_BUS               ((NTSTATUS)0xC006000AL)

//
// MessageId: SERIAL_BUS_NOT_PRESENT
//
// MessageText:
//
//  The bus type for %2 is not available on this computer.
//
#define SERIAL_BUS_NOT_PRESENT           ((NTSTATUS)0xC006000BL)

//
// MessageId: SERIAL_INVALID_USER_CONFIG
//
// MessageText:
//
//  User configuration for parameter %2 must have %3.
//
#define SERIAL_INVALID_USER_CONFIG       ((NTSTATUS)0xC006000CL)

//
// MessageId: SERIAL_RP_RESOURCE_CONFLICT
//
// MessageText:
//
//  A resource conflict was detected, the RocketPort/RocketModem driver will not load.
//
#define SERIAL_RP_RESOURCE_CONFLICT      ((NTSTATUS)0xC006000DL)

//
// MessageId: SERIAL_RP_HARDWARE_FAIL
//
// MessageText:
//
//  The RocketPort/RocketModem driver could not initialize its hardware, the driver will not be loaded.
//
#define SERIAL_RP_HARDWARE_FAIL          ((NTSTATUS)0xC006000EL)

//
// MessageId: SERIAL_DEVICEOBJECT_FAILED
//
// MessageText:
//
//  The Device Object for the RocketPort or RocketModem could not be created, the driver will not load.
//
#define SERIAL_DEVICEOBJECT_FAILED       ((NTSTATUS)0xC006000FL)

//
// MessageId: SERIAL_CUSTOM_ERROR_MESSAGE
//
// MessageText:
//
//  %2
//
#define SERIAL_CUSTOM_ERROR_MESSAGE      ((NTSTATUS)0xC0060010L)

//
// MessageId: SERIAL_CUSTOM_INFO_MESSAGE
//
// MessageText:
//
//  %2
//
#define SERIAL_CUSTOM_INFO_MESSAGE       ((NTSTATUS)0x40060011L)

//
// MessageId: SERIAL_NT50_INIT_PASS
//
// MessageText:
//
//  The RocketPort/RocketModem driver has successfully installed.
//
#define SERIAL_NT50_INIT_PASS            ((NTSTATUS)0x40060012L)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\utils.c ===
/*-------------------------------------------------------------------
| utils.c -
    This module contains code that perform queueing and completion
    manipulation on requests.
1-21-99  fix tick count [#] on peer traces. kpb.
11-24-98 Minor adjustment to purge to when WaitOnTx selected. kpb.
6-01-98 Add modem reset/row routines (generic for VS and Rkt)
3-18-98 Add time_stall function for modem settle time after reset clear - jl
3-04-98 Add synch. routine back in to synch up to isr service routine. kpb.
7-10-97 Adjust SerialPurgeTxBuffers to not purge tx-hardware buffer
  as per MS driver.  Now we only purge it if it is flowed-off.

Copyright 1993-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

//-- local funcs
BOOLEAN SerialPurgeRxBuffers(IN PVOID Context);
BOOLEAN SerialPurgeTxBuffers(IN PVOID Context, int always);
NTSTATUS SerialStartFlush(IN PSERIAL_DEVICE_EXTENSION Extension);

static char *szParameters = {"\\Parameters"};

/*----------------------------------------------------------------------------
 SyncUp - sync up to either the IRQ or Timer-DPC.  If an Interrupt is
  used, then we must use KeSynchronizeExecution(), if a timer-dpc is used
  then we 
|----------------------------------------------------------------------------*/
VOID SyncUp(IN PKINTERRUPT IntObj,
            IN PKSPIN_LOCK SpinLock,
            IN PKSYNCHRONIZE_ROUTINE SyncProc,
            IN PVOID Context)
{
 KIRQL OldIrql;

  if (IntObj != NULL)
  {
    KeSynchronizeExecution(IntObj, SyncProc, Context);
  }
  else // assume spinlock, using timer
  {
    KeAcquireSpinLock(SpinLock, &OldIrql);
    SyncProc(Context);
    KeReleaseSpinLock(SpinLock, OldIrql );
  }
}

/*--------------------------------------------------------------------------
 SerialKillAllReadsOrWrites -
    This function is used to cancel all queued and the current irps
    for reads or for writes.
Arguments:
    DeviceObject - A pointer to the serial device object.
    QueueToClean - A pointer to the queue which we're going to clean out.
    CurrentOpIrp - Pointer to a pointer to the current irp.
Return Value:
    None.
|--------------------------------------------------------------------------*/
VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    )
{

  KIRQL cancelIrql;
  PDRIVER_CANCEL cancelRoutine;

  // We acquire the cancel spin lock.  This will prevent the
  // irps from moving around.
  IoAcquireCancelSpinLock(&cancelIrql);

  // Clean the list from back to front.
  while (!IsListEmpty(QueueToClean))
  {
    PIRP currentLastIrp = CONTAINING_RECORD(
                              QueueToClean->Blink,
                              IRP,
                              Tail.Overlay.ListEntry
                              );

    RemoveEntryList(QueueToClean->Blink);

    cancelRoutine = currentLastIrp->CancelRoutine;
    currentLastIrp->CancelIrql = cancelIrql;
    currentLastIrp->CancelRoutine = NULL;
    currentLastIrp->Cancel = TRUE;

    cancelRoutine( DeviceObject, currentLastIrp );

    IoAcquireCancelSpinLock(&cancelIrql);

  }

  // The queue is clean.  Now go after the current if it's there.
  if (*CurrentOpIrp)
  {
    cancelRoutine = (*CurrentOpIrp)->CancelRoutine;
    (*CurrentOpIrp)->Cancel = TRUE;

    // If the current irp is not in a cancelable state
    // then it *will* try to enter one and the above
    // assignment will kill it.  If it already is in
    // a cancelable state then the following will kill it.

    if (cancelRoutine)
    {
      (*CurrentOpIrp)->CancelRoutine = NULL;
      (*CurrentOpIrp)->CancelIrql = cancelIrql;

      // This irp is already in a cancelable state.  We simply
      // mark it as canceled and call the cancel routine for it.

      cancelRoutine( DeviceObject, *CurrentOpIrp );
    }
    else
    {
        IoReleaseCancelSpinLock(cancelIrql);
    }
  }
  else
  {
      IoReleaseCancelSpinLock(cancelIrql);
  }
}


/*--------------------------------------------------------------------------
 SerialGetNextIrp -
    This function is used to make the head of the particular
    queue the current irp.  It also completes the what
    was the old current irp if desired.
Arguments:
    CurrentOpIrp - Pointer to a pointer to the currently active
                   irp for the particular work list.  Note that
                   this item is not actually part of the list.
    QueueToProcess - The list to pull the new item off of.
    NextIrp - The next Irp to process.  Note that CurrentOpIrp
              will be set to this value under protection of the
              cancel spin lock.  However, if *NextIrp is NULL when
              this routine returns, it is not necessaryly true the
              what is pointed to by CurrentOpIrp will also be NULL.
              The reason for this is that if the queue is empty
              when we hold the cancel spin lock, a new irp may come
              in immediately after we release the lock.
    CompleteCurrent - If TRUE then this routine will complete the
                      irp pointed to by the pointer argument
                      CurrentOpIrp.
Return Value: None.
|--------------------------------------------------------------------------*/
VOID
SerialGetNextIrp(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent,
    IN PSERIAL_DEVICE_EXTENSION extension
    )
{
  PIRP oldIrp;
  KIRQL oldIrql;

  IoAcquireCancelSpinLock(&oldIrql);

  oldIrp = *CurrentOpIrp;

  if (oldIrp) {
    if (CompleteCurrent)
    {
      MyAssert(!oldIrp->CancelRoutine);
    }
  }

  // Check to see if there is a new irp to start up.
  if (!IsListEmpty(QueueToProcess))
  {
    PLIST_ENTRY headOfList;

    headOfList = RemoveHeadList(QueueToProcess);

    *CurrentOpIrp = CONTAINING_RECORD(
                        headOfList,
                        IRP,
                        Tail.Overlay.ListEntry
                        );

    IoSetCancelRoutine( *CurrentOpIrp, NULL );
  }
  else
  {
    *CurrentOpIrp = NULL;
  }

  *NextIrp = *CurrentOpIrp;
  IoReleaseCancelSpinLock(oldIrql);

  if (CompleteCurrent)
  {
    if (oldIrp) {
      SerialCompleteRequest(extension, oldIrp, IO_SERIAL_INCREMENT);
    }
  }
}


/*--------------------------------------------------------------------------
SerialTryToCompleteCurrent -
    This routine attempts to kill all of the reasons there are
    references on the current read/write.  If everything can be killed
    it will complete this read/write and try to start another.
    NOTE: This routine assumes that it is called with the cancel
          spinlock held.
Arguments:
    Extension - Simply a pointer to the device extension.
    SynchRoutine - A routine that will synchronize with the isr
                   and attempt to remove the knowledge of the
                   current irp from the isr.  NOTE: This pointer
                   can be null.
    IrqlForRelease - This routine is called with the cancel spinlock held.
                     This is the irql that was current when the cancel
                     spinlock was acquired.
    StatusToUse - The irp's status field will be set to this value, if
                  this routine can complete the irp.
Return Value:
    None.
|--------------------------------------------------------------------------*/
VOID
SerialTryToCompleteCurrent(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess OPTIONAL,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PSERIAL_START_ROUTINE Starter OPTIONAL,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp OPTIONAL,
    IN LONG RefType
    )
{
 KIRQL OldIrql;

  // We can decrement the reference to "remove" the fact
  // that the caller no longer will be accessing this irp.

  SERIAL_CLEAR_REFERENCE(*CurrentOpIrp, RefType);

  if (SynchRoutine)
  {
#ifdef USE_SYNC_LOCKS
    if (Driver.InterruptObject != NULL)
    {
      KeSynchronizeExecution(Driver.InterruptObject, SynchRoutine, Extension);
    }
    else // assume spinlock, using timer dpc
    {
      KeAcquireSpinLock(&Driver.TimerLock, &OldIrql);
      SynchRoutine(Extension);
      KeReleaseSpinLock(&Driver.TimerLock, OldIrql );
    }
#else
    SynchRoutine(Extension);
#endif
  }

  // Try to run down all other references to this irp.
  SerialRundownIrpRefs(
      CurrentOpIrp,
      IntervalTimer,
      TotalTimer
      );

  // See if the ref count is zero after trying to kill everybody else.
  if (!SERIAL_REFERENCE_COUNT(*CurrentOpIrp))
  {
    PIRP newIrp;
    // The ref count was zero so we should complete this request.
    // The following call will also cause the current irp to be completed.
    (*CurrentOpIrp)->IoStatus.Status = StatusToUse;

    if (StatusToUse == STATUS_CANCELLED)
    {
      (*CurrentOpIrp)->IoStatus.Information = 0;
    }

    if (GetNextIrp)
    {
      IoReleaseCancelSpinLock(IrqlForRelease);

      GetNextIrp(
          CurrentOpIrp,
          QueueToProcess,
          &newIrp,
          TRUE,
          Extension
          );

      if (newIrp) {
        Starter(Extension);
      }
    }
    else
    {
      PIRP oldIrp = *CurrentOpIrp;

      // There was no get next routine.  We will simply complete
      // the irp.  We should make sure that we null out the
      // pointer to the pointer to this irp.

      *CurrentOpIrp = NULL;

      IoReleaseCancelSpinLock(IrqlForRelease);

      SerialCompleteRequest(Extension, oldIrp, IO_SERIAL_INCREMENT);
    }
  }
  else
  {
      IoReleaseCancelSpinLock(IrqlForRelease);
  }
}

/*--------------------------------------------------------------------------
 SerialRundownIrpRefs -
    This routine runs through the various items that *could*
    have a reference to the current read/write.  It try's to kill
    the reason.  If it does succeed in killing the reason it
    will decrement the reference count on the irp.
    NOTE: This routine assumes that it is called with the cancel
          spin lock held.
Arguments:
    CurrentOpIrp - Pointer to a pointer to current irp for the
                   particular operation.
    IntervalTimer - Pointer to the interval timer for the operation.
                    NOTE: This could be null.
    TotalTimer - Pointer to the total timer for the operation.
                 NOTE: This could be null.
Return Value:
    None.
|--------------------------------------------------------------------------*/
VOID
SerialRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL
    )
{
  // This routine is called with the cancel spin lock held
  // so we know only one thread of execution can be in here
  // at one time.
  // First we see if there is still a cancel routine.  If
  // so then we can decrement the count by one.
  if ((*CurrentOpIrp)->CancelRoutine)
  {
    SERIAL_CLEAR_REFERENCE(*CurrentOpIrp, SERIAL_REF_CANCEL);
    IoSetCancelRoutine(
        *CurrentOpIrp,
        NULL
        );
  }
  if (IntervalTimer)
  {
    // Try to cancel the operations interval timer.  If the operation
    // returns true then the timer did have a reference to the
    // irp.  Since we've canceled this timer that reference is
    // no longer valid and we can decrement the reference count.
    // If the cancel returns false then this means either of two things:
    // a) The timer has already fired.
    // b) There never was an interval timer.
    // In the case of "b" there is no need to decrement the reference
    // count since the "timer" never had a reference to it.
    // In the case of "a", then the timer itself will be coming
    // along and decrement it's reference.  Note that the caller
    // of this routine might actually be the this timer, but it
    // has already decremented the reference.

    if (KeCancelTimer(IntervalTimer))
    {
        SERIAL_CLEAR_REFERENCE(*CurrentOpIrp,SERIAL_REF_INT_TIMER);
    }
  }

  if (TotalTimer)
  {
    // Try to cancel the operations total timer.  If the operation
    // returns true then the timer did have a reference to the
    // irp.  Since we've canceled this timer that reference is
    // no longer valid and we can decrement the reference count.
    // If the cancel returns false then this means either of two things:
    // a) The timer has already fired.
    // b) There never was an total timer.
    // In the case of "b" there is no need to decrement the reference
    // count since the "timer" never had a reference to it.
    // In the case of "a", then the timer itself will be coming
    // along and decrement it's reference.  Note that the caller
    // of this routine might actually be the this timer, but it
    // has already decremented the reference.

    if (KeCancelTimer(TotalTimer))
    {
        SERIAL_CLEAR_REFERENCE(*CurrentOpIrp,SERIAL_REF_TOTAL_TIMER);
    }
  }
}

/*--------------------------------------------------------------------------
 SerialStartOrQueue -
    This routine is used to either start or queue any requst
    that can be queued in the driver.
Arguments:
    Extension - Points to the serial device extension.
    Irp - The irp to either queue or start.  In either
          case the irp will be marked pending.
    QueueToExamine - The queue the irp will be place on if there
                     is already an operation in progress.
    CurrentOpIrp - Pointer to a pointer to the irp the is current
                   for the queue.  The pointer pointed to will be
                   set with to Irp if what CurrentOpIrp points to
                   is NULL.
    Starter - The routine to call if the queue is empty.
Return Value:
    This routine will return STATUS_PENDING if the queue is
    not empty.  Otherwise, it will return the status returned
    from the starter routine (or cancel, if the cancel bit is
    on in the irp).
|--------------------------------------------------------------------------*/
NTSTATUS
SerialStartOrQueue(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    )
{
  KIRQL oldIrql;

  IoAcquireCancelSpinLock(&oldIrql);

  // If this is a write irp then take the amount of characters
  // to write and add it to the count of characters to write.
  if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_WRITE)
  {
    Extension->TotalCharsQueued +=
        IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length;

  } else if ((IoGetCurrentIrpStackLocation(Irp)->MajorFunction
              == IRP_MJ_DEVICE_CONTROL) &&
             ((IoGetCurrentIrpStackLocation(Irp)
               ->Parameters.DeviceIoControl.IoControlCode ==
               IOCTL_SERIAL_IMMEDIATE_CHAR) ||
              (IoGetCurrentIrpStackLocation(Irp)
               ->Parameters.DeviceIoControl.IoControlCode ==
               IOCTL_SERIAL_XOFF_COUNTER)))
  {
      Extension->TotalCharsQueued++;  // immediate char
  }

  if ((IsListEmpty(QueueToExamine)) && !(*CurrentOpIrp))
  {
    // There was no current operation.  Mark this one as
    // current and start it up.
    *CurrentOpIrp = Irp;

    IoReleaseCancelSpinLock(oldIrql);

    return Starter(Extension);
  }
  else
  {
    // We don't know how long the irp will be in the
    // queue.  So we need to handle cancel.
    if (Irp->Cancel)
    {
      IoReleaseCancelSpinLock(oldIrql);

      Irp->IoStatus.Status = STATUS_CANCELLED;

      SerialCompleteRequest(Extension, Irp, 0);

      return STATUS_CANCELLED;

    }
    else
    {

      Irp->IoStatus.Status = STATUS_PENDING;
      IoMarkIrpPending(Irp);

      InsertTailList(
          QueueToExamine,
          &Irp->Tail.Overlay.ListEntry
          );

      IoSetCancelRoutine( Irp, SerialCancelQueued );

      IoReleaseCancelSpinLock(oldIrql);

      return STATUS_PENDING;
    }
  }
}

/*--------------------------------------------------------------------------
 SerialCancelQueued -
    This routine is used to cancel Irps that currently reside on
    a queue.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP to be canceled.
Return Value:
    None.
|--------------------------------------------------------------------------*/
VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
  PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
  PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

  Irp->IoStatus.Status = STATUS_CANCELLED;
  Irp->IoStatus.Information = 0;

  RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

  // If this is a write irp then take the amount of characters
  // to write and subtract it from the count of characters to write.
  if (irpSp->MajorFunction == IRP_MJ_WRITE)
  {
    extension->TotalCharsQueued -= irpSp->Parameters.Write.Length;
  }
  else if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)
  {
    // If it's an immediate then we need to decrement the
    // count of chars queued.  If it's a resize then we
    // need to deallocate the pool that we're passing on
    // to the "resizing" routine.
    if ((irpSp->Parameters.DeviceIoControl.IoControlCode ==
         IOCTL_SERIAL_IMMEDIATE_CHAR) ||
        (irpSp->Parameters.DeviceIoControl.IoControlCode ==
         IOCTL_SERIAL_XOFF_COUNTER))
    {
      extension->TotalCharsQueued--;
    }

#ifdef COMMENT_OUT
//#ifdef DYNAMICQUEUE // Dynamic transmit queue size
    else if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
               IOCTL_SERIAL_SET_QUEUE_SIZE)
    {
      // We shoved the pointer to the memory into the
      // the type 3 buffer pointer which we KNOW we
      // never use.
      MyAssert(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

      our_free(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

      irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    }
#endif //DYNAMICQUEUE

  }

  IoReleaseCancelSpinLock(Irp->CancelIrql);

  SerialCompleteRequest(extension, Irp, IO_SERIAL_INCREMENT);
}

/*--------------------------------------------------------------------------
Routine Description:
    If the current irp is not an IOCTL_SERIAL_GET_COMMSTATUS request and
    there is an error and the application requested abort on errors,
    then cancel the irp.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP to test.
Return Value:
    STATUS_SUCCESS or STATUS_CANCELLED.
|--------------------------------------------------------------------------*/
NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
  PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
  NTSTATUS status = STATUS_SUCCESS;

  if ((extension->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) &&
      extension->ErrorWord)
  {

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    // There is a current error in the driver.  No requests should
    // come through except for the GET_COMMSTATUS.

    if ((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) ||
        (irpSp->Parameters.DeviceIoControl.IoControlCode !=
         IOCTL_SERIAL_GET_COMMSTATUS))
    {
      status = STATUS_CANCELLED;
      Irp->IoStatus.Status = STATUS_CANCELLED;
      Irp->IoStatus.Information = 0;

      SerialCompleteRequest(extension, Irp, 0);
    }
  }
  return status;
}


/*--------------------------------------------------------------------------
Routine Description:
    This routine is invoked at dpc level to in response to
    a comm error.  All comm errors kill all read and writes
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device object.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
|--------------------------------------------------------------------------*/
VOID
SerialCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

  PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;

  UNREFERENCED_PARAMETER(Dpc);
  UNREFERENCED_PARAMETER(SystemContext1);
  UNREFERENCED_PARAMETER(SystemContext2);

  SerialKillAllReadsOrWrites(
      Extension->DeviceObject,
      &Extension->WriteQueue,
      &Extension->CurrentWriteIrp
      );

  SerialKillAllReadsOrWrites(
      Extension->DeviceObject,
      &Extension->ReadQueue,
      &Extension->CurrentReadIrp
      );

}

/*--------------------------------------------------------------------------
Routine Description:
    This is the dispatch routine for flush.  Flushing works by placing
    this request in the write queue.  When this request reaches the
    front of the write queue we simply complete it since this implies
    that all previous writes have completed.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request
Return Value:
    Could return status success, cancelled, or pending.
|--------------------------------------------------------------------------*/
NTSTATUS SerialFlush(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
  PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;

  ExtTrace(Extension,D_Ioctl,("Flush"))

  Irp->IoStatus.Information = 0L;

  if (SerialIRPPrologue(Extension) == TRUE)
  {
    if (Extension->ErrorWord)
    {
      if (SerialCompleteIfError( DeviceObject, Irp ) != STATUS_SUCCESS)
      {
        return STATUS_CANCELLED;
      }
    }

    return SerialStartOrQueue(
             Extension,
             Irp,
             &Extension->WriteQueue,
             &Extension->CurrentWriteIrp,
             SerialStartFlush
             );
  }
  else
  {
    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
    return STATUS_NO_SUCH_DEVICE;
  }

}

/*--------------------------------------------------------------------------
Routine Description:
    This routine is called if there were no writes in the queue.
    The flush became the current write because there was nothing
    in the queue.  Note however that does not mean there is
    nothing in the queue now!  So, we will start off the write
    that might follow us.
Arguments:
    Extension - Points to the serial device extension
Return Value:
    This will always return STATUS_SUCCESS.
|--------------------------------------------------------------------------*/
NTSTATUS SerialStartFlush(IN PSERIAL_DEVICE_EXTENSION Extension)
{
  PIRP NewIrp;

  Extension->CurrentWriteIrp->IoStatus.Status = STATUS_SUCCESS;

  // The following call will actually complete the flush.

  SerialGetNextWrite(
      &Extension->CurrentWriteIrp,
      &Extension->WriteQueue,
      &NewIrp,
      TRUE,
      Extension
      );

  if (NewIrp)
  {
    MyAssert(NewIrp == Extension->CurrentWriteIrp);
    SerialStartWrite(Extension);
  }

  return STATUS_SUCCESS;

}

/*--------------------------------------------------------------------------
 SerialStartPurge -
Routine Description:
    Depending on the mask in the current irp, purge the interrupt
    buffer, the read queue, or the write queue, or all of the above.
Arguments:
    Extension - Pointer to the device extension.
Return Value:
    Will return STATUS_SUCCESS always.  This is reasonable
    since the DPC completion code that calls this routine doesn't
    care and the purge request always goes through to completion
    once it's started.
|--------------------------------------------------------------------------*/
NTSTATUS SerialStartPurge(IN PSERIAL_DEVICE_EXTENSION Extension)
{
  PIRP NewIrp;
  do
  {
    ULONG Mask;
    Mask = *((ULONG *)
           (Extension->CurrentPurgeIrp->AssociatedIrp.SystemBuffer));

    if (Mask & SERIAL_PURGE_RXABORT)
    {
      SerialKillAllReadsOrWrites(
          Extension->DeviceObject,
          &Extension->ReadQueue,
          &Extension->CurrentReadIrp
          );
    }

    if (Mask & SERIAL_PURGE_RXCLEAR)
    {
      KIRQL OldIrql;
      // Flush the Rocket Tx FIFO
      KeAcquireSpinLock(
          &Extension->ControlLock,
          &OldIrql
          );

//    KeSynchronizeExecution(
//          Driver.Interrupt,
//          SerialPurgeRxBuffers,
//          Extension
//          );
      SerialPurgeRxBuffers(Extension);

      KeReleaseSpinLock(
          &Extension->ControlLock,
          OldIrql
          );
    }

    if (Mask & SERIAL_PURGE_TXABORT)
    {
      SerialKillAllReadsOrWrites(
          Extension->DeviceObject,
          &Extension->WriteQueue,
          &Extension->CurrentWriteIrp
          );
      SerialKillAllReadsOrWrites(
          Extension->DeviceObject,
          &Extension->WriteQueue,
          &Extension->CurrentXoffIrp
          );

      if (Extension->port_config->WaitOnTx)
      {
        // if they have this option set, then
        // really do a purge of tx hardware buffer.
        SerialPurgeTxBuffers(Extension, 1);
      }

    }

    if (Mask & SERIAL_PURGE_TXCLEAR)
    {
      KIRQL OldIrql;

      // Flush the Rocket Rx FIFO and the system side buffer
      // Note that we do this under protection of the
      // the drivers control lock so that we don't hose
      // the pointers if there is currently a read that
      // is reading out of the buffer.
      KeAcquireSpinLock(&Extension->ControlLock, &OldIrql);

//    KeSynchronizeExecution(
//         Driver.Interrupt,
//         SerialPurgeTxBuffers,
//         Extension
//         );
      if (Extension->port_config->WaitOnTx)
        SerialPurgeTxBuffers(Extension, 1);  // force
      else
        SerialPurgeTxBuffers(Extension, 0);  // only if flowed off

      KeReleaseSpinLock(&Extension->ControlLock, OldIrql);
    }

    Extension->CurrentPurgeIrp->IoStatus.Status = STATUS_SUCCESS;
    Extension->CurrentPurgeIrp->IoStatus.Information = 0;

    SerialGetNextIrp(
        &Extension->CurrentPurgeIrp,
        &Extension->PurgeQueue,
        &NewIrp,
        TRUE,
        Extension
        );

  } while (NewIrp);

  return STATUS_SUCCESS;
}

/*--------------------------------------------------------------------------
Routine Description:
    Flushes out the Rx data pipe: Rocket Rx FIFO, Host side Rx buffer
    NOTE: This routine is being called from KeSynchronizeExecution.
Arguments:
    Context - Really a pointer to the device extension.
|--------------------------------------------------------------------------*/
BOOLEAN SerialPurgeRxBuffers(IN PVOID Context)
{
  PSERIAL_DEVICE_EXTENSION Extension = Context;

  q_flush(&Extension->RxQ);        // flush our rx buffer

#ifdef S_VS
  PortFlushRx(Extension->Port);    // flush rx hardware
#else
  sFlushRxFIFO(Extension->ChP);
  //Extension->RxQ.QPut = Extension->RxQ.QGet = 0;
#endif

  return FALSE;
}

/*--------------------------------------------------------------------------
Routine Description:
    Flushes the Rocket Tx FIFO
    NOTE: This routine is being called from KeSynchronizeExecution(not).
Arguments:
    Context - Really a pointer to the device extension.
|--------------------------------------------------------------------------*/
BOOLEAN SerialPurgeTxBuffers(IN PVOID Context, int always)
{
  PSERIAL_DEVICE_EXTENSION Extension = Context;

/* The stock com-port driver does not purge its hardware queue,
   but just ignores TXCLEAR.  Since we do flow-control in hardware
   buffer and have a larger buffer, we will purge it only if it
   is "stuck" or flowed off.

   This hopefully provides a somewhat compatible and useful match.

   We shouldn't need to check for EV_TXEMPTY here, as the ISR will
   take care of this.
 */

#ifdef S_VS
  // check for tx-flowed off condition
  if ((Extension->Port->msr_value & MSR_TX_FLOWED_OFF) || always)
    PortFlushTx(Extension->Port);    // flush tx hardware
#else
  {
    int TxCount;
    ULONG wstat;

    if (always)
    {
      sFlushTxFIFO(Extension->ChP);
    }
    else
    {
      wstat = sGetChanStatusLo(Extension->ChP);

      // check for tx-flowed off condition
      if ((wstat & (TXFIFOMT | TXSHRMT)) == TXSHRMT)
      {
        wstat = sGetChanStatusLo(Extension->ChP);
        if ((wstat & (TXFIFOMT | TXSHRMT)) == TXSHRMT)
        {
          TxCount = sGetTxCnt(Extension->ChP);
          ExtTrace1(Extension,D_Ioctl,"Purge %d bytes from Hardware.", TxCount);
          sFlushTxFIFO(Extension->ChP);
        }
      }
    }
  }
#endif

  return FALSE;
}

/*--------------------------------------------------------------------------
Routine Description:
    This routine is used to query the end of file information on
    the opened serial port.  Any other file information request
    is retured with an invalid parameter.
    This routine always returns an end of file of 0.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request
Return Value:
    The function value is the final status of the call
|--------------------------------------------------------------------------*/
NTSTATUS
SerialQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
  // The status that gets returned to the caller and
  // set in the Irp.

  NTSTATUS Status;
  BOOLEAN acceptingIRPs;

  // The current stack location.  This contains all of the
  // information we need to process this particular request.

  PIO_STACK_LOCATION IrpSp;

  UNREFERENCED_PARAMETER(DeviceObject);

  acceptingIRPs = SerialIRPPrologue((PSERIAL_DEVICE_EXTENSION)DeviceObject->
             DeviceExtension);

  if (acceptingIRPs == FALSE)
  {
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
    SerialCompleteRequest((PSERIAL_DEVICE_EXTENSION)DeviceObject->
      DeviceExtension, Irp, IO_NO_INCREMENT);
    return STATUS_NO_SUCH_DEVICE;
  }

  if (SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
  {
    return STATUS_CANCELLED;
  }
  IrpSp = IoGetCurrentIrpStackLocation(Irp);
  Irp->IoStatus.Information = 0L;
  Status = STATUS_SUCCESS;
  if (IrpSp->Parameters.QueryFile.FileInformationClass ==
      FileStandardInformation)
  {
    PFILE_STANDARD_INFORMATION Buf = Irp->AssociatedIrp.SystemBuffer;
    Buf->AllocationSize = RtlConvertUlongToLargeInteger(0ul);
    Buf->EndOfFile = Buf->AllocationSize;
    Buf->NumberOfLinks = 0;
    Buf->DeletePending = FALSE;
    Buf->Directory = FALSE;
    Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);
  }
  else if (IrpSp->Parameters.QueryFile.FileInformationClass ==
           FilePositionInformation)
  {
    ((PFILE_POSITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->
      CurrentByteOffset = RtlConvertUlongToLargeInteger(0ul);
    Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);
  }
  else
  {
    Status = STATUS_INVALID_PARAMETER;
  }

  Irp->IoStatus.Status = Status;
  SerialCompleteRequest((PSERIAL_DEVICE_EXTENSION)DeviceObject->
       DeviceExtension, Irp, 0);

  return Status;

}

/*--------------------------------------------------------------------------
Routine Description:
    This routine is used to set the end of file information on
    the opened serial port.  Any other file information request
    is retured with an invalid parameter.
    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request
Return Value:
The function value is the final status of the call
|--------------------------------------------------------------------------*/
NTSTATUS
SerialSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
  // The status that gets returned to the caller and
  // set in the Irp.
  NTSTATUS Status;
  BOOLEAN acceptingIRPs;

  UNREFERENCED_PARAMETER(DeviceObject);

  acceptingIRPs = SerialIRPPrologue((PSERIAL_DEVICE_EXTENSION)DeviceObject->
             DeviceExtension);

  if (acceptingIRPs == FALSE)
  {
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
    SerialCompleteRequest((PSERIAL_DEVICE_EXTENSION)DeviceObject->
      DeviceExtension, Irp, IO_NO_INCREMENT);
    return STATUS_NO_SUCH_DEVICE;
  }

  if (SerialCompleteIfError( DeviceObject, Irp ) != STATUS_SUCCESS)
  {
    return STATUS_CANCELLED;
  }

  Irp->IoStatus.Information = 0L;

  if ((IoGetCurrentIrpStackLocation(Irp)->
          Parameters.SetFile.FileInformationClass ==
       FileEndOfFileInformation) ||
      (IoGetCurrentIrpStackLocation(Irp)->
          Parameters.SetFile.FileInformationClass ==
       FileAllocationInformation))
  {
    Status = STATUS_SUCCESS;
  }
  else
  {
    Status = STATUS_INVALID_PARAMETER;
  }

  Irp->IoStatus.Status = Status;

  SerialCompleteRequest((PSERIAL_DEVICE_EXTENSION)DeviceObject->
    DeviceExtension, Irp, 0);

  return Status;
}

/*--------------------------------------------------------------------------
 UToC1 -  Simple convert from NT-Unicode string to c-string.
  !!!!!!!Uses a statically(static prefix) allocated buffer!!!!!
  This means that it is NOT re-entrant.  Which means only one thread can
  use this call at a time.  Also, a thread could get in trouble if it
  tried to use it twice recursively(calling a function that uses this,
  which calls a function which uses this.)  Since these translator functions
  are used mainly during driver initialization and teardown, we do not have
  to worry about multiple callers at that time.  Any calls which may be
  time sliced(port-calls) should not use this routine due to possible
  time-slice conflict with another thread.  It should allocate a variable
  on the stack and use UToCStr().
|--------------------------------------------------------------------------*/
OUT PCHAR UToC1(IN PUNICODE_STRING ustr)
{
  // we make it a ULONG to avoid alignment problems(gives ULONG alignment).
  static char cstr[140];

  return UToCStr(cstr, ustr, sizeof(cstr));
}

/*--------------------------------------------------------------------------
 UToCStr -
  Purpose:  Convert a Unicode string to c-string.  Used to easily convert
    given a simple char buffer.
  Parameters:
   Buffer - Working buffer to set up the c-string AND ansi_string struct in.
   u_str  - unicode string structure.
   BufferSize - number of bytes in Buffer which we can use.

  Return:  pointer to our c-string on success, NULL on err.
|--------------------------------------------------------------------------*/
OUT PCHAR UToCStr(
         IN OUT PCHAR Buffer,
         IN PUNICODE_STRING ustr,
         IN int BufferSize)
{
  // assume unicode structure over Buffer.
  ANSI_STRING astr;

  astr.Buffer = Buffer;
  astr.Length = 0;
  astr.MaximumLength = BufferSize - 1;

  if (RtlUnicodeStringToAnsiString(&astr,ustr,FALSE) == STATUS_SUCCESS)
    return Buffer; // ok

  MyKdPrint(D_Init,("Bad UToCStr!\n"))
  Buffer[0] = 0;
  return Buffer;
}

/*--------------------------------------------------------------------------
 CToU1 -  Simple convert from c-string to NT-Unicode string.
  !!!!!!!Uses a statically(static prefix) allocated buffer!!!!!
  This means that it is NOT re-entrant.  Which means only one thread can
  use this call at a time.  Also, a thread could get in trouble if it
  tried to use it twice recursively(calling a function that uses this,
  which calls a function which uses this.)  Since these translator functions
  are used mainly during driver initialization and teardown, we do not have
  to worry about multiple callers at that time.  Any calls which may be
  time sliced(port-calls) should not use this routine due to possible
  time-slice conflict with another thread.  It should allocate a variable
  on the stack and use CToUStr().
|--------------------------------------------------------------------------*/
OUT PUNICODE_STRING CToU1(IN const char *c_str)
{
  // we make it a ULONG to avoid alignment problems(gives ULONG alignment).
  static USTR_160 ubuf;  // equal to 160 normal chars length

  return CToUStr(
          (PUNICODE_STRING) &ubuf, // where unicode struct & string gets put
          c_str,                   // our c-string we wish to convert
          sizeof(ubuf));
}

/*--------------------------------------------------------------------------
 CToU2 -  Simple convert from c-string to NT-Unicode string.
  !!!!!!!Uses a statically(static prefix) allocated buffer!!!!!
  This means that it is NOT re-entrant.  Which means only one thread can
  use this call at a time.  Also, a thread could get in trouble if it
  tried to use it twice recursively(calling a function that uses this,
  which calls a function which uses this.)  Since these translator functions
  are used mainly during driver initialization and teardown, we do not have
  to worry about multiple callers at that time.  Any calls which may be
  time sliced(port-calls) should not use this routine due to possible
  time-slice conflict with another thread.  It should allocate a variable
  on the stack and use CToUStr().
|--------------------------------------------------------------------------*/
OUT PUNICODE_STRING CToU2(IN const char *c_str)
{
  // we make it a ULONG to avoid alignment problems(gives ULONG alignment).
  static USTR_160 ubuf;  // equal to 160 normal chars length

  return CToUStr(
          (PUNICODE_STRING) &ubuf, // where unicode struct & string gets put
          c_str,                   // our c-string we wish to convert
          sizeof(ubuf));
}

/*--------------------------------------------------------------------------
  Function: CToUStr
  Purpose:  Convert a c-style null-terminated char[] string to a Unicode string
  Parameters:
   Buffer - Working buffer to set up the unicode structure AND 
     unicode_string in.
   c_str  - normal c-style string.
   BufferSize - number of bytes in Buffer which we can use.

  Return:  pointer to our converted UNICODE_STRING on success, NULL on err.
|-------------------------------------------------------------------------*/
OUT PUNICODE_STRING CToUStr(
         OUT PUNICODE_STRING Buffer,
         IN const char * c_str,
         IN int BufferSize)
{
  // assume unicode structure followed by wchar Buffer.
  USTR_40 *us = (USTR_40 *)Buffer;
  ANSI_STRING astr; // ansi structure, temporary go between

  RtlInitAnsiString(&astr, c_str);  // c-str to ansi-string struct

  // configure the unicode string to: point the buffer ptr to the wstr.
  us->ustr.Buffer = us->wstr;
  us->ustr.Length = 0;
  us->ustr.MaximumLength = BufferSize - sizeof(UNICODE_STRING);

  // now translate from ansi-c-struct-str to unicode-struct-str
  if (RtlAnsiStringToUnicodeString(&us->ustr,&astr,FALSE) == STATUS_SUCCESS)
     return (PUNICODE_STRING) us; // ok - return ptr

  MyKdPrint(D_Init,("Bad CToUStr!\n"))
  return NULL;   // error
}

/*--------------------------------------------------------------------------
  Function: WStrToCStr
  Purpose:  Convert a wide-string to byte-c-style string.
    Assume wstr is null-terminated.
|-------------------------------------------------------------------------*/
VOID WStrToCStr(OUT PCHAR c_str, IN PWCHAR w_str, int max_size)
{
  int i = 0;

  // assume unicode structure followed by wchar Buffer.
  while ((*w_str != 0) && (i < (max_size-1)))
  {
    *c_str = (CHAR) *w_str;
    ++c_str;
    ++w_str;
    ++i;
  }
  *c_str = 0;
}

/*--------------------------------------------------------------------------
  get_reg_value -
|-------------------------------------------------------------------------*/
int get_reg_value(
                  IN HANDLE keyHandle,
                  OUT PVOID outptr,
                  IN PCHAR val_name,
                  int max_size)
{
  NTSTATUS status = STATUS_SUCCESS;
  char tmparr[80];
  PKEY_VALUE_PARTIAL_INFORMATION parInfo =
    (PKEY_VALUE_PARTIAL_INFORMATION) &tmparr[0];
  int stat = 0;
  ULONG length = 0;
  USTR_40 ubuf;  // equal to 40 normal chars length
  PUNICODE_STRING ustr;

  ustr = CToUStr(
         (PUNICODE_STRING) &ubuf, // where unicode struct & string gets put
         val_name,                   // our c-string we wish to convert
         sizeof(ubuf));
  if (ustr == NULL)
    return 3;  // err

  status = ZwQueryValueKey (keyHandle,
                            ustr,  // input reg key name
                            KeyValuePartialInformation,
                            parInfo,
                            sizeof(tmparr) -2,
                            &length);

  if (NT_SUCCESS(status))
  {
    if (parInfo->Type == REG_SZ)
    {
      tmparr[length] = 0;  // null terminate it.
      tmparr[length+1] = 0;  // null terminate it.
      WStrToCStr((PCHAR) outptr, (PWCHAR)&parInfo->Data[0], max_size);
    }
    else if (parInfo->Type == REG_DWORD)
    {
      *((ULONG *)outptr) = *((ULONG *) &parInfo->Data[0]);
    }
    else
    {
      stat = 1;
      MyKdPrint(D_Error,("regStrErr56!\n"))
    }
  }
  else
  {
    stat = 2;
    MyKdPrint(D_Error,("regStrErr57!\n"))
  }

  return stat;
}

#if DBG
/*-----------------------------------------------------------------------
 MyAssertMessage - Our Assertion error message.  We do our own assert
  because the normal DDK ASSERT() macro only works or reports under
  checked build of NT OS.
|-----------------------------------------------------------------------*/
void MyAssertMessage(char *filename, int line)
{
  MyKdPrint(D_Init,("ASSERT FAILED!!! File %s, line %d !!!!\n", filename, line))

#ifdef COMMENT_OUT
  char str[40];
  strcpy(str, "FAIL:");
  strcat(str, filename);
  strcat(str, " ln:%d ");
  mess1(str, line);
#endif
}
#endif

/*-----------------------------------------------------------------------
 EvLog - EvLog an event to NT's event log.
|-----------------------------------------------------------------------*/
void EvLog(char *mess)
{
  static USTR_160 ubuf;  // our own private buffer(static)
  UNICODE_STRING *u;
  NTSTATUS event_type;


  if (mess == NULL)
  {
    MyKdPrint(D_Init,("EvLog Err1!\n"))
    return;
  }
  if ((mess[0] == 'E') && (mess[1] == 'r'))  // "Error..."
    event_type = SERIAL_CUSTOM_ERROR_MESSAGE;
  else if ((mess[0] == 'W') && (mess[1] == 'a'))  // "Warning..."
    event_type = SERIAL_CUSTOM_ERROR_MESSAGE;
  else
    event_type = SERIAL_CUSTOM_INFO_MESSAGE;
 
  u = CToUStr(
         (PUNICODE_STRING) &ubuf, // where unicode struct & string gets put
         mess,                    // our c-string we wish to convert
         sizeof(ubuf));

  if (u==NULL)
  {
    MyKdPrint(D_Init,("EvLog Err2!\n"))
    return;
  }

  // MyKdPrint(D_Init,("EvLog Size:%d, messsize:%d!\n",u->Length, strlen(mess) ))

  EventLog(Driver.GlobalDriverObject,
           STATUS_SUCCESS,
           event_type,  // red"stop" or blue"i"..
           u->Length + sizeof(WCHAR),
           u->Buffer);
}


/*-------------------------------------------------------------------
| our_ultoa -
|--------------------------------------------------------------------*/
char * our_ultoa(unsigned long u, char* s, int radix)
{
  long pow, prevpow;
  int digit;
  char* p;

  if ( (radix < 2) || (36 < radix) )
  {
     *s = 0;
    return s;
  }

  if (u == 0)
  {
    s[0] = '0';
    s[1] = 0;    
    return s;
  }

  p = s;

  for (prevpow=0, pow=1; (u >= (unsigned long)pow) && (prevpow < pow);  pow *= radix)
    prevpow=pow;

  pow = prevpow;

  while (pow != 0)      
  {
    digit = u/pow;

    *p = (digit <= 9) ? ('0'+digit) : ( ('a'-10)+digit);
    p++;

    u -= digit*pow;
    pow /= radix;
  }

  *p = 0;
  return s;
}

/*-------------------------------------------------------------------
| our_ltoa -
|--------------------------------------------------------------------*/
char * our_ltoa(long value, char* s, int radix)
{
  unsigned long u;
  long pow, prevpow;
  int digit;
  char* p;

  if ( (radix < 2) || (36 < radix) )
  {
     *s = 0;
    return s;
  }

  if (value == 0)
  {
    s[0] = '0';
    s[1] = 0;    
    return s;
  }

  p = s;

  if ( (radix == 10) && (value < 0) )
  {
    *p++ = '-';
    value = -value;
  }

  *(long*)&u = value;
  
  for (prevpow=0, pow=1; (u >= (unsigned long)pow) && (prevpow < pow);  pow *= radix)
    prevpow=pow;

  pow = prevpow;

  while (pow != 0)      
  {
    digit = u/pow;

    *p = (digit <= 9) ? ('0'+digit) : ( ('a'-10)+digit);
    p++;

    u -= digit*pow;
    pow /= radix;
  }

  *p = 0;
  return s;
}

/*-------------------------------------------------------------------
| our_assert -
|--------------------------------------------------------------------*/
void our_assert(int id, int line)
{
  Tprintf("Assert %d line:%d!", id, line);
}

/*-------------------------------------------------------------------
| TTprintf - Trace printf with prefix.  Dump trace messages to debug port.
    With TRACE_PORT turned on, this allows us to use a spare port for
    tracing another.
|--------------------------------------------------------------------*/
void __cdecl TTprintf(char *leadstr, const char *format, ...)
{
#ifdef TRACE_PORT
#endif
  char  temp[120];
  va_list  Next;
  int sCount, ls;

  ls = strlen(leadstr);
  memcpy(temp, leadstr, ls);
  temp[ls++] = ' ';

  va_start(Next, format);
  our_vsnprintf(&temp[ls], 78, format, Next);
  sCount = strlen(temp);

  temp[sCount++] = '[';
  our_ultoa( (long) Driver.PollCnt, &temp[sCount], 10);
  sCount += strlen(&temp[sCount]);
  temp[sCount++] = ']';

  temp[sCount++] = 0xd;
  temp[sCount++] = 0xa;
  temp[sCount] = 0;

  TracePut(temp, sCount);

  // dump out to normal nt debug console
  DbgPrint(temp);
}

/*-------------------------------------------------------------------
| Tprintf - Trace printf.  Dump trace messages to debug port.
    With TRACE_PORT turned on, this allows us to use a spare port for
    tracing another.
|--------------------------------------------------------------------*/
void __cdecl Tprintf(const char *format, ...)
{
#ifdef TRACE_PORT
#endif
  char  temp[100];
  va_list  Next;
  int sCount;

  va_start(Next, format);
  our_vsnprintf(temp, 78, format, Next);

  sCount = strlen(temp);
  temp[sCount++] = '[';
  our_ultoa( (long) Driver.PollCnt, &temp[sCount], 10);
  sCount += strlen(&temp[sCount]);
  temp[sCount++] = ']';

  temp[sCount++] = 0xd;
  temp[sCount++] = 0xa;
  temp[sCount] = 0;

  TracePut(temp, sCount);

  // dump out to normal nt debug console
  DbgPrint(temp);
}

/*-------------------------------------------------------------------
| OurTrace - Trace, put data into debug ports buffer.
|--------------------------------------------------------------------*/
void OurTrace(char *leadstr, char *newdata)
{
  char  temp[86];
  int ls, ds;
  ls = strlen(leadstr);
  if (ls > 20)
    ls = 20;
  ds = strlen(newdata);
  if (ds > 60)
    ds = 60;
  memcpy(temp, leadstr, ls);
  temp[ls++] = ' ';
  memcpy(&temp[ls], newdata, ds);
  ds += ls;
  temp[ds++] = 0xd;
  temp[ds++] = 0xa;
  temp[ds] = 0;

  TracePut(temp, ds);

  // dump out to normal nt debug console
  DbgPrint(temp);
}

/*-------------------------------------------------------------------
| TraceDump - Trace, put data into debug ports buffer.
|--------------------------------------------------------------------*/
void TraceDump(PSERIAL_DEVICE_EXTENSION ext, char *newdata, int sCount, int style)
{
 int len,i,j;
 char trace_buf[50];

  len = sCount;
  j = 0;
  trace_buf[j++] = ' ';
  trace_buf[j++] = 'D';
  trace_buf[j++] = 'A';
  trace_buf[j++] = 'T';
  trace_buf[j++] = 'A';
  trace_buf[j++] = ':';
  // dump data into the trace buffer in a hex or ascii dump format
  if (len > 32) len = 32;
  for (i=0; i<len; i++)
  {
    trace_buf[j] = (CHAR) newdata[i];
    if ((trace_buf[j] < 0x20) || (trace_buf[j] > 0x80))
      trace_buf[j] = '.';
    ++j;
  }
  trace_buf[j++] = 0xd;
  trace_buf[j++] = 0xa;
  trace_buf[j] = 0;

  TracePut(trace_buf, j);
}

/*-------------------------------------------------------------------
| TracePut - Trace, put data into debug ports buffer.
|--------------------------------------------------------------------*/
void TracePut(char *newdata, int sCount)
{
#ifdef TRACE_PORT
//  int RxFree,i;
  KIRQL controlIrql;
//  PSERIAL_DEVICE_EXTENSION extension;

  // drop this into our debug queue...

  //----- THIS COMES BACK AS DISPATCH_LEVEL OR PASSIVE LEVEL, is it
  //----- SAFE FOR SPINLOCK TO HAVE BOTH ??????
  //-- YES, SpinLocks meant for calling when <= DISPATCH_LEVEL
#if DBG
  if ((KeGetCurrentIrql() != DISPATCH_LEVEL) &&
      (KeGetCurrentIrql() != PASSIVE_LEVEL))
  {
    MyKdPrint(D_Error, ("BAD IRQL:%d ", KeGetCurrentIrql(), newdata))
    return;
  }
#endif

  if (sCount == 0)
    sCount = strlen(newdata);

  KeAcquireSpinLock(&Driver.DebugLock, &controlIrql);
  q_put(&Driver.DebugQ, (BYTE *) newdata, sCount);
  KeReleaseSpinLock(&Driver.DebugLock, controlIrql);
#endif
}

/*-------------------------------------------------------------------
| Dprintf -
|--------------------------------------------------------------------*/
void __cdecl Dprintf(const char *format, ...)
{
  char  temp[100];
  va_list  Next;

  va_start(Next, format);
  our_vsnprintf(temp, 100, format, Next);

  // EvLog(temp);

  // dump out to normal nt debug console
  DbgPrint(temp);
  DbgPrint("\n");
}

/*-------------------------------------------------------------------
| Sprintf -
|--------------------------------------------------------------------*/
void __cdecl Sprintf(char *dest, const char *format, ...)
{
  va_list Next;

  va_start(Next, format);
  our_vsnprintf(dest, 80, format, Next);
}

/*-------------------------------------------------------------------
| Eprintf -
|--------------------------------------------------------------------*/
void __cdecl Eprintf(const char *format, ...)
{
  char  temp[80];
  va_list  Next;

  va_start(Next, format);
  our_vsnprintf(temp, 79, format, Next);

  if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
    EvLog(temp);
  }
  strcat(temp, "\n");
  DbgPrint(temp);
}

/*-------------------------------------------------------------------
| our_vsnprintf -
|--------------------------------------------------------------------*/
int __cdecl our_vsnprintf(char *buffer, size_t Limit, const char *format, va_list Next)
{
#ifndef BOOL
#define BOOL int
#endif
  int   InitLimit = Limit;  // Limit at entry point
  BOOL  bMore;    // Loop control
  int    Width;    // Optional width
  int   Precision;    // Optional precision
  char  *str;      // String
  char  strbuf[36];    // Constructed string
  int    len;      // Length of string
  int    nLeadingZeros;  // Number of leading zeros required
  int    nPad;      // Number of pad characters required
  char  cPad;      // Current pad character ('0' or ' ')
  char  *sPrefix;    // Prefix string
  unsigned long val;    // Value of current number
  BOOL  bLeftJustify;    // Justification
  BOOL  bPlusSign;    // Show plus sign?
  BOOL  bBlankSign;    // Blank for positives?
  BOOL  bZeroPrefix;    // Want 0x for hex, 0 for octal?
  BOOL  bIsShort;    // TRUE if short
  BOOL  bIsLong;    // TRUE if long

#define PUTONE(c) if (Limit) { --Limit; *buffer++ = c; } else c;

#define  fLeftJustify  (1 << 0)
#define fPlusSign  (1 << 1)
#define fZeroPad  (1 << 2)
#define fBlankSign  (1 << 3)
#define fPrefixOX  (1 << 4)

#define fIsShort  (1 << 5)
#define fIsLong    (1 << 6)

  if (Limit == 0)
    return -1;
  Limit--;      // Leave room for terminating NULL

  while (*format != '\0')
  {
    // Everything but '%' is copied to buffer
    if (*format != '%')
      // '%' gets special handling here
      PUTONE(*format++)
    else
    {
      // Set default flags, etc
      Width = 0;
      Precision = -1;
      cPad = ' ';
      bLeftJustify = FALSE;
      bPlusSign = FALSE;
      bBlankSign = FALSE;
      bZeroPrefix = FALSE;
      bIsShort = FALSE;
      bIsLong = FALSE;
      sPrefix = "";
        
      format++;
      bMore = TRUE;
      while (bMore)
      {
        // optional flags
        switch (*format)
        {
          case '-':  bLeftJustify = TRUE; format++; break;
          case '+':  bPlusSign = TRUE; format++; break;
          case '0':  cPad = '0'; format++; break;
          case ' ':  bBlankSign = TRUE; format++; break;
          case '#':  bZeroPrefix = TRUE; format++; break;
          default:   bMore = FALSE;
        }
      }

      // optional width
      if (*format == '*')
      {
        Width = (int) va_arg(Next, int);
        format++;
      }
      else if (our_isdigit(*format))
      {
        while (our_isdigit(*format))
        {
          Width *= 10;
          Width += (*format++) - '0';
        }
      }

      // optional precision
      if (*format == '.')
      {
        format++;
        Precision = 0;
        if (*format == '*')
        {
          Precision = (int) va_arg(Next, int);
          format++;
        }
        else while (our_isdigit(*format))
        {
          Precision *= 10;
          Precision += (*format++) - '0';
        }
      }

      // optional size
      switch (*format)
      {
        case 'h':  bIsShort = TRUE; format++; break;
        case 'l':  bIsLong = TRUE;  format++; break;
      }

      // All controls are completed, dispatch on the conversion character
      switch (*format++)
      {
        case 'd':
        case 'i':
          if (bIsLong)    // Signed long int
            our_ltoa( (long) va_arg(Next, long), strbuf, 10);
          else      // Signed int
            our_ltoa( (long) va_arg(Next, int), strbuf, 10);
            //    _itoa( (int) va_arg(Next, int), strbuf, 10);

          if (strbuf[0] == '-')
            sPrefix = "-";
          else
          {
            if (bPlusSign)
              sPrefix = "+";
            else if (bBlankSign)
              sPrefix = " ";
          }
          goto EmitNumber;


        case 'u':
          if (bIsLong)    // Unsigned long int
            our_ultoa( (long) va_arg(Next, long), strbuf, 10);
          else      // Unsigned int
            our_ultoa( (long) (int) va_arg(Next, int), strbuf, 10);
          goto EmitNumber;
      
        // set sPrefix for these...
        case 'o':
          if (bZeroPrefix)
            sPrefix = "0";

          if (bIsLong)
            val = (long) va_arg(Next, long);
          else
            val = (int) va_arg(Next, int);
      
          our_ultoa(val, strbuf, 8);
          if (val == 0)
            sPrefix = "";
          goto EmitNumber;

        case 'x':
        case 'X':
          if (bZeroPrefix)
            sPrefix = "0x";

          if (bIsLong)
            val = (unsigned long) va_arg(Next, long);
          else
            val = (unsigned int) va_arg(Next, int);
      
          our_ultoa(val, strbuf, 16);
          if (val == 0)
            sPrefix = "";
          goto EmitNumber;

        case 'c':
          strbuf[0] = (char) va_arg(Next, char);
          str = strbuf;
          len = 1;
          goto EmitString;

        case 's':
          str = (char *) va_arg(Next, char*);
          len =  strlen(str);
          if (Precision != -1 &&
              Precision < len)
            len = Precision;
          goto EmitString;

        case 'n':
        case 'p':
          break;
      
        case '%':
          strbuf[0] = '%';
          str = strbuf;
          len = 1;
          goto EmitString;
          break;

        case 'f':
        case 'e':
        case 'E':
        case 'g':
        case 'G':
          str = "<float format not supported>";
          len =  strlen(str);
          goto EmitString;

        default:
          str = "<bad format character>";
          len =  strlen(str);
          goto EmitString;
      }


EmitNumber:
      if (Precision == -1)
        Precision = 1;
      str = strbuf;
      if (*str == '-')
        str++;    // if negative, already have prefix
      len =  strlen(str);

      nLeadingZeros = Precision - len;
      if (nLeadingZeros < 0)
        nLeadingZeros = 0;

      nPad = Width - (len + nLeadingZeros +  strlen(sPrefix));
      if (nPad < 0)
        nPad = 0;

      if (nPad && !bLeftJustify)
      {
        // Left padding required
        while (nPad--)
        {
          PUTONE(cPad);
        }
        nPad = 0;    // Indicate padding completed
      }
        
      while (*sPrefix != '\0')
        PUTONE(*sPrefix++);

      while (nLeadingZeros-- > 0)
        PUTONE('0');

      while (len-- > 0)
      {
        PUTONE(*str++);
      }
        
      if (nPad)
      {
        // Right padding required
        while (nPad--)
          PUTONE(' ');
      }

      goto Done;


EmitString:
      // Here we have the string ready to emit.  Handle padding, etc.
      if (Width > len)
        nPad = Width - len;
      else
        nPad = 0;

      if (nPad && !bLeftJustify)
      {
        // Left padding required
        while (nPad--)
          PUTONE(cPad);
      }

      while (len-- > 0)
        PUTONE(*str++);

      if (nPad)
      {
        // Right padding required
        while (nPad--)
          PUTONE(' ');
      }

Done:  ;
    }
  }

  *buffer = '\0';
  return InitLimit - Limit - 1;    // Don't count terminating NULL
}

/*-------------------------------------------------------------------
| our_isdigit - 
|--------------------------------------------------------------------*/
int our_isdigit(char c)
{
  if ((c >= '0') && (c <= '9'))
    return 1;
  return 0;
}

/*-----------------------------------------------------------------
 listfind - find matching string in list.  List is null terminated.
|------------------------------------------------------------------*/
int listfind(char *str, char **list)
{
 int i=0;

  for (i=0; list[i] != NULL; i++)
  {
    if (my_lstricmp(str, list[i]) == 0)  // match
      return i;
  }
  return -1;
}

/*-----------------------------------------------------------------
 getnum - get a number.  Hex or Dec.
|------------------------------------------------------------------*/
int getnum(char *str, int *index)
{
  int i,val;
  int ch_i;

  *index = 0;
  ch_i = 0;
  while (*str == ' ')
  {
    ++str;
    ++ch_i;
  }

  if ((*str == '0') && (my_toupper(str[1]) == 'X'))
  {
    str += 2;
    ch_i += 2;
    val = (int) gethint(str,&i);
    if (i==0)
      return 0;
  }
  else
  {
    val = getint(str,&i);
    if (i==0)
      return 0;
  }
  ch_i += i;
  *index = ch_i;  // num bytes consumed
  return val;
}

/*-----------------------------------------------------------------
 getnumbers - get numbers from string, comma or space delimited.
   return number of integers read.
|------------------------------------------------------------------*/
int getnumbers(char *str, long *nums, int max_nums, int hex_flag)
{
// int stat;
  int i,j, num_cnt;
  ULONG *wnums = (ULONG *)nums;

  i = 0;
  num_cnt = 0;
  while (num_cnt < max_nums)
  {
    while ((str[i] == ' ') || (str[i] == ',') || (str[i] == ':'))
      ++i;
    if (hex_flag)
      wnums[num_cnt] = gethint(&str[i],  &j);
    else
      nums[num_cnt] = getint(&str[i],  &j);
    i += j;
    if (j == 0) return num_cnt;
    else ++num_cnt;
  }
  return num_cnt;
}

/*-----------------------------------------------------------------
 my_lstricmp -
|------------------------------------------------------------------*/
int my_lstricmp(char *str1, char *str2)
{
  if ((str1 == NULL) || (str2 == NULL))
    return 1;  // not a match

  if ((*str1 == 0) || (*str2 == 0))
    return 1;  // not a match

  while ( (my_toupper(*str1) == my_toupper(*str2)) && 
          (*str1 != 0)  && (*str2 != 0))
  {
   ++str1;
   ++str2;
  }
  if ((*str1 == 0) && (*str2 == 0))
    return 0;  // ok match

  return 1;  // no match
}

/*-----------------------------------------------------------------
 my_sub_lstricmp -
|------------------------------------------------------------------*/
int my_sub_lstricmp(const char *name, const char *codeline)
{
  int c;

  if ((name == NULL) || (codeline == NULL))
    return 1;  // not a match

  if ((*name == 0) || (*codeline == 0))
    return 1;  // not a match

  while ( (my_toupper(*name) == my_toupper(*codeline)) && 
          (*name != 0)  && (*codeline != 0))
  {
   ++name;
   ++codeline;
  }

  // return if either is at end of string
  if (*name == 0)
  {
    c = my_toupper(*codeline);
    if ((c <= 'Z') && (c >= 'A'))
      return 1;  // not a match
    if (c == '_')
      return 1;  // not a match

    return 0;  // ok match
  }
  return 1;  // no match
}

/*------------------------------------------------------------------------
| getstr - grab a text string parameter off a command line.
|-----------------------------------------------------------------------*/
int getstr(char *deststr, char *textptr, int *countptr, int max_size)
{
//  int number;
  int tempcount, i;

  *deststr = 0;

  tempcount = 0;
  while ((*textptr == ' ') || (*textptr == ','))
  {
    ++textptr;
    ++tempcount;
  }

  i = 0;
  while ((*textptr != 0) && (*textptr != ' ') && (*textptr != ',') &&
         (i < max_size) )
  {
    *deststr++ = *textptr;
    ++textptr;
    ++tempcount;
    ++i;
  }
  *deststr = 0;

  *countptr = tempcount;
  return 0;
}

/*------------------------------------------------------------------------
| getint -
|-----------------------------------------------------------------------*/
int getint(char *textptr, int *countptr)
{
  int number;
  int tempcount;
  int negate = 0;
  int digit_cnt = 0;

  tempcount = 0;
  number = 0;
  while (*textptr == 0x20)
  {
    ++textptr;
    ++tempcount;
  }

  if (*textptr == '-')
  {
    ++textptr;
    ++tempcount;
    negate = 1;
  }

  while ( ((*textptr >= 0x30) && (*textptr <= 0x39)) )
  {
    number = (number * 10) + ( *textptr & 0x0f);
    ++textptr;
    ++tempcount;
    ++digit_cnt;
  }

  if (digit_cnt == 0)
  {
    tempcount = 0;
    number = 0;
  }

  if (countptr)
    *countptr = tempcount;

  if (negate)
    return (-number);
  return number;
} /* getint */

/*------------------------------------------------------------------------
| gethint - for finding hex words.
|-----------------------------------------------------------------------*/
unsigned int gethint(char *bufptr, int *countptr)
{
  unsigned int count;
  unsigned char temphex;
  unsigned int number;
  int digit_cnt = 0;

  number = 0;
  count = 0;

  while (*bufptr == 0x20)
  {
    ++bufptr;
    ++count;
  }

  while ( ((*bufptr >= 0x30) && (*bufptr <= 0x39))
                                  ||
          ((my_toupper(*bufptr) >= 0x41) && (my_toupper(*bufptr) <= 0x46)) )
  {
    if (*bufptr > 0x39)
      temphex = (my_toupper(*bufptr) & 0x0f) + 9;
    else
      temphex = *bufptr & 0x0f;
    number = (number * 16) + temphex;
    ++bufptr;
    ++count;
    ++digit_cnt;
  }

  if (digit_cnt == 0)
  {
    count = 0;
    number = 0;
  }

  if (countptr)
    *countptr = count;

  return number;
} /* gethint */

/*-----------------------------------------------------------------
 my_toupper - to upper case
|------------------------------------------------------------------*/
int my_toupper(int c)
{
  if ((c >= 'a') && (c <= 'z'))
    return ((c-'a') + 'A');
  else return c;
}

/*----------------------------------------------------------------------------
| hextoa -
|----------------------------------------------------------------------------*/
void hextoa(char *str, unsigned int v, int places)
{
  while (places > 0)
  {
    --places;
    if ((v & 0xf) < 0xa)
      str[places] = '0' + (v & 0xf);
    else
      str[places] = 'A' + (v & 0xf) - 0xa;
    v >>= 4;
  }
}

//#define DUMP_MEM
#if DBG
#define TRACK_MEM
#endif
/*----------------------------------------------------------------------------
| our_free -
|----------------------------------------------------------------------------*/
void our_free(PVOID ptr, char *str)
{
#ifdef TRACK_MEM
  ULONG size;
  BYTE *bptr;

  if (ptr == NULL)
  {
    MyKdPrint(D_Error, ("MemFree Null Error\n"))
    //Tprintf("ERR,MemNull Err!");
    return;
  }
  bptr = ptr;
  bptr -= 16;
  if (*((DWORD *)bptr) != 0x1111)  // frame it with something we can check
  {
    MyKdPrint(D_Error, ("MemFree Frame Error\n"))
    //Tprintf("ERR, MemFree Frame!");
  }
  bptr += 4;
  size = *((DWORD *)bptr); // frame it with something we can check
  bptr -= 4;

  Driver.mem_alloced -= size;  // track how much memory we are using
#ifdef DUMP_MEM
  MyKdPrint(D_Init, ("Free:%x(%d),%s, [T:%d]\n",bptr, size, str, Driver.mem_alloced))
  //Tprintf("Free:%x(%d),%s, [T:%d]",bptr, size, str, Driver.mem_alloced);
#endif
  ExFreePool(bptr);
#else
  ExFreePool(ptr);
#endif
}

/*----------------------------------------------------------------------------
| our_locked_alloc -
|----------------------------------------------------------------------------*/
PVOID our_locked_alloc(ULONG size, char *str)
{
 BYTE *bptr;

#ifdef TRACK_MEM
  int i;
  size += 16;
#endif

  bptr = ExAllocatePool(NonPagedPool, size);
  if (bptr == NULL)
  {
    MyKdPrint(D_Error, ("MemCreate Fail\n"))
    //Tprintf("ERR, MemCreate Error!");
    return NULL;
  }
  RtlZeroMemory(bptr, size);

#ifdef TRACK_MEM

#ifdef DUMP_MEM
  MyKdPrint(D_Init, ("Alloc:%x(%d),%s\n",bptr, size, str))
  //Tprintf("Alloc:%x(%d),%s",bptr, size, str);
#endif


  *((DWORD *)bptr) = 0x1111;      // frame it with something we can check
  bptr += 4;
  *((DWORD *)bptr) = size;
  bptr += 4;
  for (i=0; i<4; i++)  // copy the name
  {
    bptr[i] = str[i];
    if (str[i] == 0)
      break;
  }
  bptr += 8;
#endif

  Driver.mem_alloced += size;  // track how much memory we are using
  return bptr;
}

#ifdef S_VS
/*----------------------------------------------------------------------
 mac_cmp - compare two 6-byte mac addresses, return -1 if mac1 < ma2,
  0 if mac1==mac2, 1 if mac1 > mac2.
|----------------------------------------------------------------------*/
int mac_cmp(UCHAR *mac1, UCHAR *mac2)
{
 int i;
  for (i=0; i<6; i++)
  {
    if (mac1[i] != mac2[i])
    {
      if (mac1[i] < mac2[i])
        return -1;
      else
        return  1;
    }
  }
  return  0;  // same
}
#endif

/*----------------------------------------------------------------------
 time_stall -
|----------------------------------------------------------------------*/
void time_stall(int tenth_secs)
{
  int i;
  LARGE_INTEGER WaitTime; // Actual time req'd for buffer to drain

  // set wait-time to .1 second.(-1000 000 = relative(-), 100-ns units)
  WaitTime.QuadPart = -1000000L * tenth_secs;
  KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);

#if 0
  // this is wasteing resources, see new version above
  // wait .4 seconds for response
  for (i=0; i<tenth_secs; i++)
  {
    // set wait-time to .1 second.(-1000 000 = relative(-), 100-ns units)
    //WaitTime = RtlConvertLongToLargeInteger(-1000000L);
    // set wait-time to .1 second.(-1000 000 = relative(-), 100-ns units)
    WaitTime.QuadPart = -1000000L;
    KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);
  }
#endif
}


/*----------------------------------------------------------------------
 ms_time_stall -
|----------------------------------------------------------------------*/
void ms_time_stall(int millisecs)
{
  int i;
  LARGE_INTEGER WaitTime; // Actual time req'd for buffer to drain

  // set wait-time to .001 second.(-10000 = relative(-), 100-ns units)
  WaitTime.QuadPart = -10000L * millisecs;
  KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);
}


/*----------------------------------------------------------------------
 str_to_wstr_dup - allocate wchar string and convert from char to wchar.
|----------------------------------------------------------------------*/
WCHAR *str_to_wstr_dup(char *str, int alloc_space)
{
  WCHAR *wstr;
  WCHAR *wtmpstr;
  int siz;
  siz = (strlen(str) * 2) + 4;

  wstr = ExAllocatePool (alloc_space, siz);
  if ( wstr ) {
    RtlZeroMemory(wstr, siz);
    wtmpstr = wstr;
    while (*str != 0)
    {
      *wtmpstr = (WCHAR) *str;
      ++wtmpstr;
      ++str;
    }
  }
  return wstr;
}
 
/*----------------------------------------------------------------------
  NumDevices - return number of devices in device linked list.
|----------------------------------------------------------------------*/
int NumDevices(void)
{
  PSERIAL_DEVICE_EXTENSION board_ext = NULL;
  int num_devices;

  num_devices = 0;
  while (board_ext != NULL)
  {
    board_ext = board_ext->board_ext;
    ++num_devices;
  }
  return num_devices;
}

/*----------------------------------------------------------------------
  NumPorts - return number of ports for a device based on the actual
    number of Object extensions linked to our device.
    board_ext - board/device to return number of ports, or NULL for
      a count of all ports for all boards.
|----------------------------------------------------------------------*/
int NumPorts(PSERIAL_DEVICE_EXTENSION board_ext)
{
  int num_devices;
  PSERIAL_DEVICE_EXTENSION port_ext;
  int all_devices = 0;

  if (board_ext == NULL)
  {
    all_devices = 1;
    board_ext = Driver.board_ext;
  }

  num_devices = 0;
  while (board_ext != NULL)
  {
    port_ext = board_ext->port_ext;
    while (port_ext != NULL)
    {
      port_ext = port_ext->port_ext;
      ++num_devices;
    }
    if (all_devices)
      board_ext = board_ext->board_ext;  // next
    else
      board_ext = NULL;  // only the one
  }

  return num_devices;
}

/*----------------------------------------------------------------------
  BoardExtToNumber - generate a board number based on the position
    in linked list with head Driver.board_ext.  Used for NT4.0 driver
    install to report a board number.
|----------------------------------------------------------------------*/
int BoardExtToNumber(PSERIAL_DEVICE_EXTENSION board_ext)
{
  PSERIAL_DEVICE_EXTENSION ext;
  int board_num;

  if (board_ext == NULL)
    return 0;

  // walk list of boards to determine which "board number" we are
  board_num = 0;
  ext = Driver.board_ext;
  while (ext != NULL)
  {
    if (board_ext == ext)
    {
      return board_num;
    }
    ext = ext->board_ext;
    ++board_num;
  }

  return 0;  // return first board index as default.
}

/*----------------------------------------------------------------------
  PortExtToIndex - Given a port extension, return the index into
   the devices or drivers ports.
  driver_flag - if set, then return in relation to driver, otherwise
    return port index in relation to parent device.
|----------------------------------------------------------------------*/
int PortExtToIndex(PSERIAL_DEVICE_EXTENSION port_ext,
             int driver_flag)
{
  PSERIAL_DEVICE_EXTENSION b_ext;
  PSERIAL_DEVICE_EXTENSION p_ext;
  int port_num;

  if (port_ext == NULL)
    return 0;

  // walk list of boards & ports
  port_num = 0;
  b_ext = Driver.board_ext;
  while (b_ext != NULL)
  {
    if (!driver_flag)
      port_num = 0;
    p_ext = b_ext->port_ext;
    while (p_ext != NULL)
    {
      if (p_ext == port_ext)
        return port_num;
      p_ext = p_ext->port_ext;
      ++port_num;
    }
    b_ext = b_ext->board_ext;
  }

  // walk list of boards & pdo ports
  port_num = 0;
  b_ext = Driver.board_ext;
  while (b_ext != NULL)
  {
    if (!driver_flag)
      port_num = 0;
    p_ext = b_ext->port_pdo_ext;
    while (p_ext != NULL)
    {
      if (p_ext == port_ext)
        return port_num;
      p_ext = p_ext->port_ext;
      ++port_num;
    }
    b_ext = b_ext->board_ext;
  }
  MyKdPrint(D_Error,("PortExtErr5!\n"))
  return 0;  // return 0(same as first port) if not found
}

/*----------------------------------------------------------------------------
| find_ext_by_name - Given name("COM5"), find the extension structure
|----------------------------------------------------------------------------*/
PSERIAL_DEVICE_EXTENSION find_ext_by_name(char *name, int *dev_num)
{
  int Dev;
  PSERIAL_DEVICE_EXTENSION ext;
  PSERIAL_DEVICE_EXTENSION board_ext;

  board_ext = Driver.board_ext;
  while (board_ext)
  {
    ext = board_ext->port_ext;
    Dev = 0;
    while (ext)
    {
      if (my_lstricmp(name, ext->SymbolicLinkName) == 0)
      {
        if (dev_num != NULL)
          *dev_num = Dev;
        return ext;
      }
      ++Dev;
      ext = ext->port_ext;  // next in chain
    }  // while port extension
    board_ext = board_ext->board_ext;  // next in chain
  }  // while board extension
  return NULL;
}

/*----------------------------------------------------------------------------
| is_board_in_use - Given Board extension, determine if anyone is using it.
    (If any ports associated with it are open.)
|----------------------------------------------------------------------------*/
int is_board_in_use(PSERIAL_DEVICE_EXTENSION board_ext)
{
  PSERIAL_DEVICE_EXTENSION port_ext;
  int in_use = 0;
#ifdef S_VS
  int i;
  Hdlc *hd;
#endif

  if (board_ext == NULL)
    return 0;

#ifdef S_VS
  hd = board_ext->hd;
  if ( hd ) {
    for( i=0; i<2; i++ ) {
      if ( (hd->TxCtlPackets[i]) &&
           (hd->TxCtlPackets[i]->ProtocolReserved[1]) ) {
        in_use = 1;
      }
    }
    for( i=0; i<HDLC_TX_PKT_QUEUE_SIZE; i++ ) {
      if ( (hd->TxPackets[i]) &&
           (hd->TxPackets[i]->ProtocolReserved[1]) ) {
        in_use = 1;
      }
    }
  }
#endif

  port_ext = board_ext->port_ext;
  while((in_use == 0) && (port_ext != NULL)) {
    if (port_ext->DeviceIsOpen) {
      in_use = 1;
    }
#ifdef S_VS
    hd = port_ext->hd;
    if ( hd ) {
      for( i=0; i<2; i++ ) {
        if ( (hd->TxCtlPackets[i]) &&
             (hd->TxCtlPackets[i]->ProtocolReserved[1]) ) {
          in_use = 1;
        }
      }
      for( i=0; i<HDLC_TX_PKT_QUEUE_SIZE; i++ ) {
        if ( (hd->TxPackets[i]) &&
             (hd->TxPackets[i]->ProtocolReserved[1]) ) {
          in_use = 1;
        }
      }
    }
#endif
    port_ext = port_ext->port_ext;
  }
  return in_use; // not in use.
}

/*----------------------------------------------------------------------------
| find_ext_by_index - Given device X and port Y, find the extension structure
    If port_num is -1, then a board ext is assumed to be looked for.
|----------------------------------------------------------------------------*/
PSERIAL_DEVICE_EXTENSION find_ext_by_index(int dev_num, int port_num)
{
  PSERIAL_DEVICE_EXTENSION ext;
  PSERIAL_DEVICE_EXTENSION board_ext;
  int bn;
  int pn;

  bn = -1;
  pn = -1;

  board_ext = Driver.board_ext;
  while ( (board_ext) && (bn < dev_num) )
  {
    bn++;
    if (bn == dev_num) {
      ext = board_ext->port_ext;
      if (port_num == -1)
        return board_ext;  // they wanted a board ext.
      while (ext)
      {
        pn++;
        if (pn == port_num)
          return ext;
        else
          ext = ext->port_ext;          // next in port chain
      }
    }
    board_ext = board_ext->board_ext;   // next in device chain
  }
  return NULL;
}

/*----------------------------------------------------------------------------
| ModemReset - wrappers around hardware routines to put SocketModems into or
| clear SocketModems from reset state.
|----------------------------------------------------------------------------*/
void ModemReset(PSERIAL_DEVICE_EXTENSION ext, int on)
{
#ifdef S_RK
  sModemReset(ext->ChP, on);
#else
  if (on == 1)
  {
    // put the modem into reset state (firmware will pull it out of reset
    // automatically)
    ext->Port->action_reg |= ACT_MODEM_RESET;
  }
  else
  {
    // don't need to do anything to clear a modem from reset on the vs
  }
#endif
}

/*-----------------------------------------------------------------
  our_enum_key - Enumerate a registry key, handle misc stuff.
|------------------------------------------------------------------*/
int our_enum_key(IN HANDLE handle,
                 IN int index,
                 IN CHAR *buffer,
                 IN ULONG max_buffer_size,
                 OUT PCHAR *retdataptr)
{
  NTSTATUS status;
  PKEY_BASIC_INFORMATION KeyInfo;
  ULONG actuallyReturned;
  
  KeyInfo = (PKEY_BASIC_INFORMATION) buffer;
  max_buffer_size -= 8;  // subtract off some space for nulling end, slop, etc.

  // return a pointer to the start of data.
  *retdataptr = ((PCHAR)(&KeyInfo->Name[0]));

  // Pad the name returned with 2 wchar zeros.
  RtlZeroMemory( ((PUCHAR)(&KeyInfo->Name[0])), sizeof(WCHAR)*2);

  status = ZwEnumerateKey(handle,
                          index,
                          KeyBasicInformation,
                          KeyInfo,
                          max_buffer_size,
                          &actuallyReturned);

  if (status == STATUS_NO_MORE_ENTRIES)
  {
     //MyKdPrint(D_Init, ("Done.\n"))
     return 1;  // err, done
  }
  if (status != STATUS_SUCCESS)
  {
    MyKdPrint(D_Error, ("Err3G\n"))
    return 2;  // err
  }

  if (KeyInfo->NameLength > max_buffer_size)  // check limits
      KeyInfo->NameLength = max_buffer_size;

  // Pad the name returned with 2 wchar zeros.
  RtlZeroMemory( ((PUCHAR)(&KeyInfo->Name[0]))+KeyInfo->NameLength,
                 sizeof(WCHAR)*2);

  return 0;  // ok, done
}

/*-----------------------------------------------------------------
  our_enum_value - Enumerate a registry value, handle misc stuff.
|------------------------------------------------------------------*/
int our_enum_value(IN HANDLE handle,
                   IN int index,
                   IN CHAR *buffer,
                   IN ULONG max_buffer_size,
                   OUT PULONG type,
                   OUT PCHAR *retdataptr,
                   OUT PCHAR sz_retname)
{
  NTSTATUS status;
  PKEY_VALUE_FULL_INFORMATION KeyValueInfo;
  //PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
  ULONG actuallyReturned;
  ULONG i;

  KeyValueInfo = (PKEY_VALUE_FULL_INFORMATION) buffer;
  max_buffer_size -= 8;  // subtract off some space for nulling end, slop, etc.

  // Pad the name returned with 2 wchar zeros.
  RtlZeroMemory( ((PUCHAR)(&KeyValueInfo->Name[0])), sizeof(WCHAR)*2);

  // return a pointer to the start of data.
  *retdataptr = ((PCHAR)(&KeyValueInfo->Name[0]));
  *sz_retname = 0;

  status = ZwEnumerateValueKey(handle,
                          index,
                          KeyValueFullInformation,
                          KeyValueInfo,
                          max_buffer_size,
                          &actuallyReturned);

  if (status == STATUS_NO_MORE_ENTRIES)
  {
    //MyKdPrint(D_Init, ("Done.\n"))
    return 1;  // err, done
  }
  if (status != STATUS_SUCCESS)
  {
    MyKdPrint(D_Init, ("Err3H\n"))
    return 2;  // err
  }

  if (KeyValueInfo->NameLength < 80)  // limit to 40 char entries
  {
    for (i=0; i<(KeyValueInfo->NameLength/2); i++)
    {
      sz_retname[i] = (CHAR)KeyValueInfo->Name[i];
    }
    sz_retname[i] = 0;
  }

  *retdataptr = ((PCHAR) KeyValueInfo) + KeyValueInfo->DataOffset;

  // Pad the data returned with 2 wchar zeros.
  RtlZeroMemory( (PUCHAR)(*retdataptr + KeyValueInfo->DataLength),
                 sizeof(WCHAR)*2);
  if (type != NULL)
    *type = KeyValueInfo->Type;
  return 0;  // ok, done
}

/*-----------------------------------------------------------------
  our_query_value - get data from an entry in the registry.
    We give a generic buffer space(and size), and the routine passes
    back a ptr (into this generic buffer space where the data
    is read into.
|------------------------------------------------------------------*/
int our_query_value(IN HANDLE Handle,
                    IN char *key_name, 
                    IN CHAR *buffer,
                    IN ULONG max_buffer_size,
                    OUT PULONG type,
                    OUT PCHAR *retdataptr)
{
  NTSTATUS status;
  PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
  ULONG length;
  OUT USTR_40 ubuf;  // about 90 bytes on stack

  if (strlen(key_name) > 38)
  {
    MyKdPrint(D_Error, ("Err, KeyValue Len!\n"))
    return 2;
  }

  // convert our name to unicode;
  CToUStr(
         (PUNICODE_STRING) &ubuf, // where unicode struct & string gets put
         key_name,                // our c-string we wish to convert
         sizeof(ubuf));

  KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
  max_buffer_size -= 8;  // subtract off some space for nulling end, slop, etc.

  // return a pointer to the start of data.
  *retdataptr = ((PCHAR)(&KeyValueInfo->Data[0]));

  // Pad the name returned with 2 wchar zeros.
  RtlZeroMemory( ((PUCHAR)(&KeyValueInfo->Data[0])), sizeof(WCHAR)*2);

  status = ZwQueryValueKey (Handle,
                            (PUNICODE_STRING) &ubuf,  // input reg key name
                            KeyValuePartialInformation,
                            KeyValueInfo,
                            max_buffer_size,
                            &length);

  if (status != STATUS_SUCCESS)
  {
    //MyKdPrint(D_Init, ("No Value\n"))
    return 1;  // err
  }

  if (KeyValueInfo->DataLength > max_buffer_size)
    KeyValueInfo->DataLength = max_buffer_size;

  // Pad the data returned with a null,null.
  RtlZeroMemory( ((PUCHAR)(&KeyValueInfo->Data[0]))+KeyValueInfo->DataLength,
                 sizeof(WCHAR)*2);
  if (type != NULL)
    *type = KeyValueInfo->Type;
  return 0; // ok
}

/*-----------------------------------------------------------------
  our_set_value - get data from an entry in the registry.
|------------------------------------------------------------------*/
int our_set_value(IN HANDLE Handle,
                    IN char *key_name,
                    IN PVOID pValue,
                    IN ULONG value_size,
                    IN ULONG value_type)
{
  NTSTATUS status;
  PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
  ULONG length;
  OUT USTR_40 ubuf_name;  // about 90 bytes on stack
  OUT USTR_40 ubuf_val;  // about 90 bytes on stack

  if (strlen(key_name) > 38)
  {
    MyKdPrint(D_Error, ("Err, KeyValue Len!\n"))
    return 2;
  }

  // convert our name to unicode;
  CToUStr(
         (PUNICODE_STRING) &ubuf_name, // where unicode struct & string gets put
         key_name,                // our c-string we wish to convert
         sizeof(ubuf_name));

  if (value_type == REG_SZ)
  {
    // convert our value to unicode;
    CToUStr(
         (PUNICODE_STRING) &ubuf_val, // where unicode struct & string gets put
         (char *)pValue,                // our c-string we wish to convert
         sizeof(ubuf_val));
    MyKdPrint(D_Init, ("set_value reg_sz %s=%s\n",
         key_name, (char *)pValue))

    pValue  = (PVOID)ubuf_val.ustr.Buffer;
    value_size = ubuf_val.ustr.Length;
  }

  status = ZwSetValueKey (Handle,
                        (PUNICODE_STRING) &ubuf_name,
                        0,  // type optional
                        value_type,
                        pValue,
                        value_size);

  if (status != STATUS_SUCCESS)
  {
    MyKdPrint(D_Error, ("Error setting reg %\n",key_name))
    return 1;  // err
  }

  return 0; // ok
}

/*-----------------------------------------------------------------
  our_open_key - Make sure *pHandle is initialized to NULL, because
    this routine auto-closes the handle with ZwClose().
|------------------------------------------------------------------*/
int our_open_key(OUT PHANDLE phandle,
                 IN OPTIONAL HANDLE relative_key_handle,
                 IN char *regkeyname,
                 IN ULONG attribs)
{
  OBJECT_ATTRIBUTES objAttribs;
  NTSTATUS status;
  OUT USTR_160 ubuf;  // about 340 bytes on the stack

  if (strlen(regkeyname) > 158)
  {
    MyKdPrint(D_Error, ("Err, Key Len!\n"))
    return 2;
  }

  // convert our name to unicode;
  CToUStr(
         (PUNICODE_STRING) &ubuf, // where unicode struct & string gets put
         regkeyname,              // our c-string we wish to convert
         sizeof(ubuf));

  // if previously open, then close it up.
  if (*phandle != NULL)
  {
    ZwClose(*phandle);
    *phandle = NULL;
  }
  InitializeObjectAttributes(&objAttribs,
                              (PUNICODE_STRING) &ubuf,
                              OBJ_CASE_INSENSITIVE,
                              relative_key_handle,  // root dir relative handle
                              NULL);  // security desc

  status = ZwOpenKey(phandle,
                     attribs,
                     &objAttribs);

  if ((status != STATUS_SUCCESS) && (attribs == KEY_ALL_ACCESS))
  {
    MyKdPrint(D_Error, ("OpenKey,Try to Create %s, status 0x%x\n", regkeyname,status))
    status = ZwCreateKey(phandle,
                         attribs, //KEY_ALL_ACCESS, etc
                         &objAttribs,
                         0,  // index, optional
                         NULL,  // ptr to unicode string, class
                         REG_OPTION_NON_VOLATILE,
                         NULL);  // disposition, tells if created

    if (status == STATUS_SUCCESS)
    {
      // try to open the original key again.
      status = ZwOpenKey(phandle,
                         attribs,
                         &objAttribs);
    }
    else
    {
      MyKdPrint(D_Error, ("OpenKey,Error Creating %s\n", regkeyname))
    }
  }

  if (status != STATUS_SUCCESS)
  {
    MyKdPrint(D_Error, ("OpenKey,Error Opening %s, status 0x%x\n", regkeyname,status))
    //MyKdPrint(D_Init, ("Failed ZwOpenKey\n"))
    *phandle = NULL;  // make sure null if not open
    return 1;
  }

  return 0;
}

/*-----------------------------------------------------------------
  our_open_device_reg -
|------------------------------------------------------------------*/
int our_open_device_reg(OUT HANDLE *pHandle,
                        IN PSERIAL_DEVICE_EXTENSION dev_ext,
                        IN ULONG RegOpenRights)
{
  NTSTATUS status;
  HANDLE DriverHandle = NULL;
  HANDLE DevHandle = NULL;
#if TRY_NEW_NT50
  // PLUGPLAY_REGKEY_DRIVER opens up the control\class\{guid}\node
  // PLUGPLAY_REGKEY_DEVICE opens up the enum\enum-type\node\Device Parameters
  status = IoOpenDeviceRegistryKey(dev_ext->Pdo,
                                   PLUGPLAY_REGKEY_DRIVER,
                                   RegOpenRights, pHandle);
  if (status != STATUS_SUCCESS)
  {
    //MyKdPrint(D_Init, ("Failed ZwOpenKey\n"))
    *phandle = NULL;  // make sure null if not open
    return 1;
  }
#else
  {
    int j, stat;
    char dev_str[60];
    char tmpstr[200];
    OBJECT_ATTRIBUTES objAttribs;

    MyKdPrint(D_Init, ("our_open_device_reg\n"))
#if NT50
    if (dev_ext->config->szNt50DevObjName[0] == 0)
    {
      MyKdPrint(D_Error, ("Error, device options Pnp key!\n"))
      *pHandle = NULL;
      return 1;  // err
    }
    Sprintf(dev_str, "%s\\%s",
            szParameters, dev_ext->config->szNt50DevObjName);
#else
    j = BoardExtToNumber(dev_ext);
    Sprintf(dev_str, "%s\\Device%d", szParameters, BoardExtToNumber(dev_ext));
#endif

    // force a creation of "Parameters" if not exist
    stat = our_open_driver_reg(&DriverHandle,
                               KEY_ALL_ACCESS);
    if (stat)
    {
      MyKdPrint(D_Error, ("Err4b!\n"))
      *pHandle = NULL;
      return 1;
    }
    ZwClose(DriverHandle);
    DriverHandle = NULL;

	MyKdPrint(D_Init, ("Driver.OptionRegPath: %s\n", dev_str))

    stat = MakeRegPath(dev_str);  // this forms Driver.OptionRegPath
    if (stat) {
      *pHandle = NULL;
      return 1;
    }

    UToCStr(tmpstr, &Driver.OptionRegPath, sizeof(tmpstr));

    stat = our_open_key(pHandle,
                        NULL,
                        tmpstr,
                        RegOpenRights);

    if (stat != 0)
    {
      MyKdPrint(D_Error, ("Err3e\n"))
      *pHandle = NULL;  // make sure null if not open
      return 1;
    }
  }
#endif
  return 0;
}

/*-----------------------------------------------------------------
  our_open_driver_reg -
|------------------------------------------------------------------*/
int our_open_driver_reg(OUT HANDLE *pHandle,
                        IN ULONG RegOpenRights)
{
  NTSTATUS status;
  int j, stat;
  OBJECT_ATTRIBUTES objAttribs;
  char tmpstr[200];

  stat = MakeRegPath(szParameters);  // this forms Driver.OptionRegPath
  if ( stat ) {
    *pHandle = NULL;  // make sure null if not open
    return 1;
  }

  UToCStr(tmpstr, &Driver.OptionRegPath, sizeof(tmpstr));

  stat = our_open_key(pHandle,
               NULL,
               tmpstr,
               RegOpenRights);

  if (stat != 0)
  {
    MyKdPrint(D_Error, ("Failed ZwOpenKey %s\n",tmpstr))
    *pHandle = NULL;  // make sure null if not open
    return 1;
  }
  return 0;
}

/*----------------------------------------------------------------------------
| ModemSpeakerEnable - wrappers around hardware routines to enable the 
| RocketModemII speaker...
|----------------------------------------------------------------------------*/
void ModemSpeakerEnable(PSERIAL_DEVICE_EXTENSION ext)
{
    MyKdPrint(D_Init,("ModemSpeakerEnable: %x\n",(unsigned long)ext))
#ifdef S_RK
    sModemSpeakerEnable(ext->ChP);
#endif
}

/*----------------------------------------------------------------------------
| ModemWriteROW - wrappers around hardware routines to send ROW config
| commands to SocketModems.
|----------------------------------------------------------------------------*/
void ModemWriteROW(PSERIAL_DEVICE_EXTENSION ext,USHORT CountryCode)
{
  int count;
  char *ModemConfigString;

  MyKdPrint(D_Init,("ModemWriteROW: %x, %x\n",(unsigned long)ext,CountryCode)) // DEBUG
  time_stall(10);   // DEBUG

#ifdef S_RK

  sModemWriteROW(ext->ChP,CountryCode);

#else
  {
  // fix so compiles, 1-18-99 kpb
  static char *ModemConfigString = {"AT*NCxxZ\r"};

  if (CountryCode == 0) {
    // bad country code, skip the write and let modem use power-on default
    MyKdPrint(D_Init,("Undefined ROW Write\n"))
    return;
  }

  if (CountryCode == ROW_NA) {
    MyKdPrint(D_Init,("ROW Write, North America\n"))
    return;
  }

  // create the country config string
  ModemConfigString[5] = '0' + (CountryCode / 10);
  ModemConfigString[6] = '0' + (CountryCode % 10);

  PortFlushTx(ext->Port);     /* we just reset, so a flush shouldn't matter */
  q_put(&ext->Port->QOut, ModemConfigString, strlen(ModemConfigString));
  }

#endif
}

#ifdef S_RK
/********************************************************************

   wrappers around hardware routines to send strings to modems...

*********************************************************************/
void 
ModemWrite(PSERIAL_DEVICE_EXTENSION ext,char *string,int length)
{
    sModemWrite(ext->ChP,string,length);
}

/********************************************************************

   wrappers around hardware routines to send strings to modems...

*********************************************************************/
int 
ModemRead(PSERIAL_DEVICE_EXTENSION ext,
    char *string,int length,
    int poll_retries)
{
    return(sModemRead(ext->ChP,string,length,poll_retries));
}

/********************************************************************

   wrappers around hardware routines to send strings to modems...

*********************************************************************/
int 
ModemReadChoice(PSERIAL_DEVICE_EXTENSION ext,
    char *s0,int len0,
    char *s1,int len1,
    int poll_retries)
{
    return(sModemReadChoice(ext->ChP,s0,len0,s1,len1,poll_retries));
}

/********************************************************************

   wrappers around hardware routines to send strings to modems, one
    byte at a time...

*********************************************************************/
void    
ModemWriteDelay(PSERIAL_DEVICE_EXTENSION ext,
    char *string,int length)
{
    sModemWriteDelay(ext->ChP,string,length);
}

/********************************************************************

   wrappers around hardware routines to check FIFO status...

*********************************************************************/
int 
RxFIFOReady(PSERIAL_DEVICE_EXTENSION ext)
{
    return(sRxFIFOReady(ext->ChP));
}

int 
TxFIFOReady(PSERIAL_DEVICE_EXTENSION ext)
{
    return(sTxFIFOReady(ext->ChP));
}

int 
TxFIFOStatus(PSERIAL_DEVICE_EXTENSION ext)
{
    return(sTxFIFOStatus(ext->ChP));
}


/********************************************************************

   wrappers around hardware routines to prepare modem ports for IO...

*********************************************************************/
void 
ModemIOReady(PSERIAL_DEVICE_EXTENSION ext,int speed)
{
    if (sSetBaudRate(ext->ChP,speed,FALSE)) {
        MyKdPrint(D_Init,("Unable to set baud rate to %d\n",speed))
        return;
    }
    sFlushTxFIFO(ext->ChP);
    sFlushRxFIFO(ext->ChP);

    ext->BaudRate = speed;
    sSetBaudRate(ext->ChP,ext->BaudRate,TRUE);

    sSetData8(ext->ChP);
    sSetParity(ext->ChP,0);   // No Parity
    sSetRxMask(ext->ChP,0xff);

    sClrTxXOFF(ext->ChP)            /* destroy any pending stuff */

    sEnRTSFlowCtl(ext->ChP);
    sEnCTSFlowCtl(ext->ChP);

    if (sGetChanStatus(ext->ChP) & STATMODE) {
        sDisRxStatusMode(ext->ChP);
    }

    sGetChanIntID(ext->ChP);

    sEnRxFIFO(ext->ChP);
    sEnTransmit(ext->ChP);      /* enable transmitter if not already enabled */

    sSetDTR(ext->ChP);
    sSetRTS(ext->ChP);
}

/********************************************************************

   wrappers around hardware routines to shut down modem ports for now...

*********************************************************************/
void 
ModemUnReady(PSERIAL_DEVICE_EXTENSION ext)
{
    sFlushTxFIFO(ext->ChP);
    sFlushRxFIFO(ext->ChP);

    sSetData8(ext->ChP);
    sSetParity(ext->ChP,0);
    sSetRxMask(ext->ChP,0xff);

    ext->BaudRate = 9600;
    sSetBaudRate(ext->ChP,ext->BaudRate,TRUE);

    sClrTxXOFF(ext->ChP)      // destroy any pending stuff

    if (sGetChanStatus(ext->ChP) & STATMODE) {
        sDisRxStatusMode(ext->ChP);
    }

    sGetChanIntID(ext->ChP);

    sDisRTSFlowCtl(ext->ChP);
    sDisCTSFlowCtl(ext->ChP);
 
    sClrRTS(ext->ChP);
    sClrDTR(ext->ChP);

    time_stall(1);    // wait for port to quiet...
}
#endif  // S_RK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\wmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial driver.

Environment:

    Kernel mode

Revision History :
--*/

#include "precomp.h"
#include <wmistr.h>

NTSTATUS
SerialSystemControlDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS
SerialTossWMIRequest(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex);
NTSTATUS
SerialSetWmiDataItem(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex, IN ULONG InstanceIndex,
                     IN ULONG DataItemId,
                     IN ULONG BufferSize, IN PUCHAR PBuffer);
NTSTATUS
SerialSetWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                      IN ULONG GuidIndex, IN ULONG InstanceIndex,
                      IN ULONG BufferSize,
                      IN PUCHAR PBuffer);
NTSTATUS
SerialQueryWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                        IN ULONG GuidIndex, 
                        IN ULONG InstanceIndex,
                        IN ULONG InstanceCount,
                        IN OUT PULONG InstanceLengthArray,
                        IN ULONG OutBufferSize,
                        OUT PUCHAR PBuffer);
NTSTATUS
SerialQueryWmiRegInfo(IN PDEVICE_OBJECT PDevObj, OUT PULONG PRegFlags,
                      OUT PUNICODE_STRING PInstanceName,
                      OUT PUNICODE_STRING *PRegistryPath,
                      OUT PUNICODE_STRING MofResourceName,
                      OUT PDEVICE_OBJECT *Pdo);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESRP0, SerialSystemControlDispatch)
#pragma alloc_text(PAGESRP0, SerialTossWMIRequest)
#pragma alloc_text(PAGESRP0, SerialSetWmiDataItem)
#pragma alloc_text(PAGESRP0, SerialSetWmiDataBlock)
#pragma alloc_text(PAGESRP0, SerialQueryWmiDataBlock)
#pragma alloc_text(PAGESRP0, SerialQueryWmiRegInfo)
#endif


NTSTATUS
SerialSystemControlDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;
    PSERIAL_DEVICE_EXTENSION pDevExt
      = (PSERIAL_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    PAGED_CODE();

    status = WmiSystemControl(   &pDevExt->WmiLibInfo,
                                 DeviceObject, 
                                 Irp,
                                 &disposition);
    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(pDevExt->LowerDeviceObject, Irp);
            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(pDevExt->LowerDeviceObject, Irp);
            break;
        }        
    }
    
    return(status);

}


#define WMI_SERIAL_PORT_NAME_INFORMATION 0
#define WMI_SERIAL_PORT_COMM_INFORMATION 1
#define WMI_SERIAL_PORT_HW_INFORMATION   2
#define WMI_SERIAL_PORT_PERF_INFORMATION 3

GUID SerialPortNameGuid = SERIAL_PORT_WMI_NAME_GUID;
GUID SerialPortCommGuid = SERIAL_PORT_WMI_COMM_GUID;
GUID SerialPortHWGuid = SERIAL_PORT_WMI_HW_GUID;
GUID SerailPortPerfGuid = SERIAL_PORT_WMI_PERF_GUID;

WMIGUIDREGINFO SerialWmiGuidList[4] =
{
    { &SerialPortNameGuid, 1, 0 },
    { &SerialPortCommGuid, 1, 0 },
    { &SerialPortHWGuid, 1, 0 },
    { &SerailPortPerfGuid, 1, 0 }
};

//
// WMI System Call back functions
//



NTSTATUS
SerialTossWMIRequest(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex)
{
   PSERIAL_DEVICE_EXTENSION pDevExt;
   NTSTATUS status;

   PAGED_CODE();

   pDevExt = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;

   switch (GuidIndex) {

   case WMI_SERIAL_PORT_NAME_INFORMATION:
   case WMI_SERIAL_PORT_COMM_INFORMATION:
   case WMI_SERIAL_PORT_HW_INFORMATION:
   case WMI_SERIAL_PORT_PERF_INFORMATION:
      status = STATUS_INVALID_DEVICE_REQUEST;
      break;

   default:
      status = STATUS_WMI_GUID_NOT_FOUND;
      break;
   }

   status = WmiCompleteRequest(PDevObj, PIrp,
                                 status, 0, IO_NO_INCREMENT);

   return status;
}


NTSTATUS
SerialSetWmiDataItem(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex, IN ULONG InstanceIndex,
                     IN ULONG DataItemId,
                     IN ULONG BufferSize, IN PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    PBuffer has the new values for the data item


Return Value:

    status

--*/
{
   PAGED_CODE();

   //
   // Toss this request -- we don't support anything for it
   //

   return SerialTossWMIRequest(PDevObj, PIrp, GuidIndex);
}


NTSTATUS
SerialSetWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                      IN ULONG GuidIndex, IN ULONG InstanceIndex,
                      IN ULONG BufferSize,
                      IN PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    PBuffer has the new values for the data block


Return Value:

    status

--*/
{
   PAGED_CODE();

   //
   // Toss this request -- we don't support anything for it
   //

   return SerialTossWMIRequest(PDevObj, PIrp, GuidIndex);
}


NTSTATUS
SerialQueryWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                        IN ULONG GuidIndex, 
                        IN ULONG InstanceIndex,
                        IN ULONG InstanceCount,
                        IN OUT PULONG InstanceLengthArray,
                        IN ULONG OutBufferSize,
                        OUT PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
            
    BufferAvail on has the maximum size available to write the data
        block.

    PBuffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    ULONG size = 0;
    PSERIAL_DEVICE_EXTENSION pDevExt
       = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;

    PAGED_CODE();

    switch (GuidIndex) {
    case WMI_SERIAL_PORT_NAME_INFORMATION:
       size = pDevExt->WmiIdentifier.Length;

       if (OutBufferSize < (size + sizeof(USHORT))) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

       if (pDevExt->WmiIdentifier.Buffer == NULL) {
           status = STATUS_INSUFFICIENT_RESOURCES;
           break;
        }

        //
        // First, copy the string over containing our identifier
        //

        *(USHORT *)PBuffer = (USHORT)size;
        (UCHAR *)PBuffer += sizeof(USHORT);

        RtlCopyMemory(PBuffer, pDevExt->WmiIdentifier.Buffer, size);

        //
        // Increment total size to include the WORD containing our len
        //

        size += sizeof(USHORT);
        *InstanceLengthArray = size;
                
        status = STATUS_SUCCESS;

        break;

    case WMI_SERIAL_PORT_COMM_INFORMATION: 
       size = sizeof(SERIAL_WMI_COMM_DATA);

       if (OutBufferSize < size) {
          status = STATUS_BUFFER_TOO_SMALL;
          break;
        }

        *InstanceLengthArray = size;
        *(PSERIAL_WMI_COMM_DATA)PBuffer = pDevExt->WmiCommData;

        status = STATUS_SUCCESS;

        break;

    case WMI_SERIAL_PORT_HW_INFORMATION:
       size = sizeof(SERIAL_WMI_HW_DATA);

       if (OutBufferSize < size) {
          status = STATUS_BUFFER_TOO_SMALL;
          break;
       }

       *InstanceLengthArray = size;
       *(PSERIAL_WMI_HW_DATA)PBuffer = pDevExt->WmiHwData;

       status = STATUS_SUCCESS;

       break;

    case WMI_SERIAL_PORT_PERF_INFORMATION: 
      size = sizeof(SERIAL_WMI_PERF_DATA);

      if (OutBufferSize < size) {
         status = STATUS_BUFFER_TOO_SMALL;
         break;
      }

      *InstanceLengthArray = size;
      *(PSERIAL_WMI_PERF_DATA)PBuffer = pDevExt->WmiPerfData;

      status = STATUS_SUCCESS;

      break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest( PDevObj, PIrp,
                                  status, size, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
SerialQueryWmiRegInfo(IN PDEVICE_OBJECT PDevObj, OUT PULONG PRegFlags,
                      OUT PUNICODE_STRING PInstanceName,
                      OUT PUNICODE_STRING *PRegistryPath,
                      OUT PUNICODE_STRING MofResourceName,
                      OUT PDEVICE_OBJECT *Pdo)
                                                  
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered. 
            
    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.               

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is 
        required
                
    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
                
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt
       = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;
   
   PAGED_CODE();

   *PRegFlags = WMIREG_FLAG_INSTANCE_PDO;
   *PRegistryPath = &Driver.RegPath;
   //*PRegistryPath = &SerialGlobals.RegistryPath;
   *Pdo = pDevExt->Pdo;

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\waitmask.h ===
//---- waitmask.h

NTSTATUS
SerialStartMask(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

BOOLEAN
SerialGrabWaitFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGiveWaitToIsr(
    IN PVOID Context
    );

BOOLEAN
SerialFinishOldWait(
    IN PVOID Context
    );

VOID
SerialCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\infs\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d date -v 4.34.0.0

$(O)\netctmrk.inf: $(_INX)\netctmrk.inx $(_LNG)\netctmrk.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@   
    $(STAMP)          
    
$(O)\mdmctm1.inf: $(_INX)\mdmctm1.inx $(_LNG)\mdmctm1.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)          

$(O)\ctmaport.inf: $(_INX)\ctmaport.inx $(_LNG)\ctmaport.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\wmi.h ===
// wmi.h

#define SERIAL_WMI_PARITY_NONE  0U
#define SERIAL_WMI_PARITY_ODD   1U
#define SERIAL_WMI_PARITY_EVEN  2U
#define SERIAL_WMI_PARITY_SPACE 3U
#define SERIAL_WMI_PARITY_MARK  4U

#define SERIAL_WMI_STOP_1   0U
#define SERIAL_WMI_STOP_1_5 1U
#define SERIAL_WMI_STOP_2   2U

#define SERIAL_WMI_INTTYPE_LATCHED 0U
#define SERIAL_WMI_INTTYPE_LEVEL   1U

typedef struct _SERIAL_WMI_COMM_DATA {
   //
   // Name -- inside struct
   //

   //
   // Baud rate
   //

   UINT32 BaudRate;

   //
   // BitsPerByte;
   //

   UINT32 BitsPerByte;

   //
   // Parity -- see SERIAL_WMI_PARITY_XXXX
   //

   UINT32 Parity;

   //
   // Parity Enabled
   //

   BOOLEAN ParityCheckEnable;

   //
   // Stop Bits - see SERIAL_WMI_STOP_XXXX
   //

   UINT32 StopBits;

   //
   // XOff Character
   //

   UINT32 XoffCharacter;

   //
   // Xoff Xmit Threshold
   //

   UINT32 XoffXmitThreshold;

   //
   // XOn Character
   //

   UINT32 XonCharacter;

   //
   // XonXmit Threshold
   //

   UINT32 XonXmitThreshold;

   //
   // Maximum Baud Rate
   //

   UINT32 MaximumBaudRate;

   //
   // Maximum Output Buffer Size
   //

   UINT32 MaximumOutputBufferSize;

   //
   // Support 16-bit mode (NOT!)
   //

   BOOLEAN Support16BitMode;

   //
   // Support DTRDSR
   //

   BOOLEAN SupportDTRDSR;

   //
   // Support Interval Timeouts
   //

   BOOLEAN SupportIntervalTimeouts;

   //
   // Support parity check
   //

   BOOLEAN SupportParityCheck;

   //
   // Support RTS CTS
   //

   BOOLEAN SupportRTSCTS;

   //
   // Support XOnXOff
   //

   BOOLEAN SupportXonXoff;

   //
   // Support Settable Baud Rate
   //

   BOOLEAN SettableBaudRate;

   //
   // Settable Data Bits
   //

   BOOLEAN SettableDataBits;

   //
   // Settable Flow Control
   //

   BOOLEAN SettableFlowControl;

   //
   // Settable Parity
   //

   BOOLEAN SettableParity;

   //
   // Settable Parity Check
   //

   BOOLEAN SettableParityCheck;

   //
   // Settable Stop Bits
   //

   BOOLEAN SettableStopBits;

   //
   // Is Busy
   //

   BOOLEAN IsBusy;

} SERIAL_WMI_COMM_DATA, *PSERIAL_WMI_COMM_DATA;

typedef struct _SERIAL_WMI_HW_DATA {
   //
   // IRQ Number
   //

   UINT32 IrqNumber;

   //
   // IRQ Vector;
   //

   UINT32 IrqVector;

   //
   // IRQ Level
   //

   UINT32 IrqLevel;

   //
   // IRQ Affinity Mask
   //

   UINT32 IrqAffinityMask;

   //
   // Interrupt Type
   //

   UINT32 InterruptType;

   //
   // Base IO Addr
   //

   ULONG_PTR BaseIOAddress;

} SERIAL_WMI_HW_DATA, *PSERIAL_WMI_HW_DATA;


typedef struct _SERIAL_WMI_PERF_DATA {

   //
   // Bytes received in current session
   //

   UINT32 ReceivedCount;

   //
   // Bytes transmitted in current session
   //

   UINT32 TransmittedCount;

   //
   // Framing errors in current session
   //

   UINT32 FrameErrorCount;

   //
   // Serial overrun errors in current session
   //

   UINT32 SerialOverrunErrorCount;

   //
   // Buffer overrun errors in current session
   //

   UINT32 BufferOverrunErrorCount;

   //
   // Parity errors in current session
   //

   UINT32 ParityErrorCount;
} SERIAL_WMI_PERF_DATA, *PSERIAL_WMI_PERF_DATA;


#define SERIAL_WMI_GUID_LIST_SIZE 4

extern WMIGUIDREGINFO SerialWmiGuidList[SERIAL_WMI_GUID_LIST_SIZE];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\write.c ===
/*-------------------------------------------------------------------
| write.c -
 1-22-99 - add missing IoReleaseCancelSpinLock() to CompleteWrite(),
   missing since 1-18-99 changes. kpb.
 1-18-99 - Adjust sync lock for write packets to avoid bugchecks with
  wait on tx option. kpb
 9-25-98 - bugfix, immediate write could drop 1 byte due to faulty
   txport buffer check.
Copyright 1993-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

/************************************************************************
Routine Description:
    This is the dispatch routine for write.  It validates the parameters
    for the write request and if all is ok then it places the request
    on the work queue.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request
Return Value:
    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return STATUS_PENDING.
************************************************************************/
NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    NTSTATUS Status;
    BOOLEAN acceptingIRPs;

    acceptingIRPs = SerialIRPPrologue(Extension);

    if (acceptingIRPs == FALSE) {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
      SerialCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
      return STATUS_NO_SUCH_DEVICE;
   }

   if (Extension->DeviceType == DEV_BOARD)
   {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
      SerialCompleteRequest (Extension, Irp, IO_NO_INCREMENT);
      return STATUS_NOT_SUPPORTED;
   };

#ifdef TRACE_PORT
    if (Extension->TraceOptions)
    {
      if (Extension->TraceOptions & 1)  // trace messages
      {
        Tprintf("Write, Len:%d",
          (ULONG) IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length);

        // dump data into the trace buffer in a hex or ascii dump format
        TraceDump(Extension,
                  Irp->AssociatedIrp.SystemBuffer,
                  IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length,0);
      }
      else if (Extension->TraceOptions & 4)  // trace output data
      {
        TracePut(
                 Irp->AssociatedIrp.SystemBuffer,
                 IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length);
      }
    }
#endif

    if (Extension->ErrorWord)
    {
      if (SerialCompleteIfError( DeviceObject, Irp ) != STATUS_SUCCESS)
      {
        ExtTrace(Extension,D_Error, " ErrorSet!");
        return STATUS_CANCELLED;
      }
    }

    Irp->IoStatus.Information = 0L;

    // Quick check for a zero length write.  If it is zero length
    // then we are already done!
    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length)
    {
//------ 10-22-96, start code addition to speed up 1-byte writes
#define WRT_LEN (IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length)

#ifdef S_VS
  // vs1000 code
      if (!Extension->port_config->WaitOnTx)  // have to let ISR handle physical end detect
      {
      if (WRT_LEN < OUT_BUF_SIZE)
      {
         // ISR is locked out since it only handles IRP's queued up
         // any other contention problems?
        //extension->lock_out_other_tasks = 1;
        if ((Extension->CurrentWriteIrp == NULL)  // no current write
            && (IsListEmpty(&Extension->WriteQueue)))  // no queued up output data
        {
          // if room in hardware
          // bug: kpb, 9-22-98
          //if ( (ULONG)(OUT_BUF_SIZE-PortGetTxCnt(Extension->Port)) >= WRT_LEN)
          if ( (ULONG)(PortGetTxRoom(Extension->Port)) > WRT_LEN)
          {

                             // Send it all ,WriteTxBlk will chk fifo
            q_put(&Extension->Port->QOut,
                        (PUCHAR)(Irp->AssociatedIrp.SystemBuffer),
                        WRT_LEN);
            Extension->ISR_Flags |= TX_NOT_EMPTY;  // use to detect fifo empty
            Extension->OurStats.TransmittedCount += WRT_LEN;
            ++Extension->sent_packets;
            Irp->IoStatus.Information = WRT_LEN;
            ExtTrace(Extension,D_Ioctl, " ,IMMED. WRITE");

            Irp->IoStatus.Status = STATUS_SUCCESS;
            SerialCompleteRequest(Extension, Irp, 0);
            return STATUS_SUCCESS;
          }
        }
      } // if (WRT_LEN < OUT_BUF_SIZE)
      } // if (!Extension->port_config->WaitOnTx)
#else
  // rocketport code
      if (!Extension->port_config->WaitOnTx)  // have to let ISR handle physical end detect
      {
      if (WRT_LEN <= MAXTX_SIZE)
      {
         // ISR is locked out since it only handles IRP's queued up
        if ((Extension->CurrentWriteIrp == NULL)  // no current write
            && (IsListEmpty(&Extension->WriteQueue)))  // no queued up output data
        {
          // if room in hardware
          if ( (ULONG)(MAXTX_SIZE-sGetTxCnt(Extension->ChP)) >= WRT_LEN)
          {
            if (Extension->Option & OPTION_RS485_SOFTWARE_TOGGLE)
            {
              if ((Extension->DTRRTSStatus & SERIAL_RTS_STATE) == 0)
              {
                sSetRTS(Extension->ChP);
                Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
              }
            }
                             // Send it all ,WriteTxBlk will chk fifo
            sWriteTxBlk(Extension->ChP,
                        (PUCHAR)(Irp->AssociatedIrp.SystemBuffer),
                        WRT_LEN);
            Extension->ISR_Flags |= TX_NOT_EMPTY;  // use to detect fifo empty
            Extension->OurStats.TransmittedCount += WRT_LEN;
            ++Extension->sent_packets;
            Irp->IoStatus.Information = WRT_LEN;
            ExtTrace(Extension,D_Ioctl, " ,IMMED. WRITE");

            ++Extension->sent_packets;
            Irp->IoStatus.Status = STATUS_SUCCESS;
            SerialCompleteRequest(Extension, Irp, 0);
            return STATUS_SUCCESS;
          }
        }
      } // if (WRT_LEN <= MAXTX_SIZE)
      } // if (!Extension->port_config->WaitOnTx)
#endif  // rocketport code

//------ 10-22-96, end  code addition to speed up 1-byte writes

        // Put the write on the queue so that we can
        // process it when our previous writes are done.
        ++Extension->sent_packets;

        Status = SerialStartOrQueue(
                   Extension,
                   Irp,
                   &Extension->WriteQueue,
                   &Extension->CurrentWriteIrp,
                   SerialStartWrite
                   );
        if  (Status == STATUS_PENDING)
        {
          ExtTrace(Extension,D_Ioctl, " ,PENDING");
        }
        return Status;
    }
    else   // if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length)
    {
        Irp->IoStatus.Status = STATUS_SUCCESS;

        SerialCompleteRequest(Extension, Irp, 0 );

        return STATUS_SUCCESS;
    }
}


/***************************************************************************
Routine Description:
    This routine is used to start off any write.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the write.
Arguments:
    Extension - Points to the serial device extension
Return Value:
    This routine will return STATUS_PENDING for all writes
    other than those that we find are cancelled.
***************************************************************************/
NTSTATUS
SerialStartWrite(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )
{
    PIRP NewIrp;
    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;
    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    do {
        // If there is an xoff counter then complete it.

#ifdef REMOVED   // Will not suppor Xoff Counter IRP
        IoAcquireCancelSpinLock(&OldIrql);

        // We see if there is a actually an Xoff counter irp.
        // If there is, we put the write irp back on the head
        // of the write list.  We then kill the xoff counter.
        // The xoff counter killing code will actually make the
        // xoff counter back into the current write irp, and
        // in the course of completing the xoff (which is now
        // the current write) we will restart this irp.

        if(Extension->CurrentXoffIrp)
        {
            if (SERIAL_REFERENCE_COUNT(Extension->CurrentXoffIrp)) {
            {
                // The reference count is non-zero.  This implies that
                // the xoff irp has not made it through the completion
                // path yet.  We will increment the reference count
                // and attempt to complete it ourseleves.

                SERIAL_SET_REFERENCE(
                    Extension->CurrentXoffIrp,
                    SERIAL_REF_XOFF_REF
                    );

                //
                // The following call will actually release the
                // cancel spin lock.
                //

                SerialTryToCompleteCurrent(
                    Extension,
                    SerialGrabXoffFromIsr,
                    OldIrql,
                    STATUS_SERIAL_MORE_WRITES,
                    &Extension->CurrentXoffIrp,
                    NULL,
                    NULL,
                    &Extension->XoffCountTimer,
                    NULL,
                    NULL,
                    SERIAL_REF_XOFF_REF
                    );

            } else {

                //
                // The irp is well on its way to being finished.
                // We can let the regular completion code do the
                // work.  Just release the spin lock.
                //

                IoReleaseCancelSpinLock(OldIrql);

            }

        }
        else
        {
            IoReleaseCancelSpinLock(OldIrql);
        }
#endif //REMOVED

        UseATimer = FALSE;

        // Calculate the timeout value needed for the
        // request.  Note that the values stored in the
        // timeout record are in milliseconds.  Note that
        // if the timeout values are zero then we won't start
        // the timer.

        KeAcquireSpinLock( &Extension->ControlLock, &OldIrql );

        Timeouts = Extension->Timeouts;

        KeReleaseSpinLock( &Extension->ControlLock, OldIrql );

        if (Timeouts.WriteTotalTimeoutConstant ||
            Timeouts.WriteTotalTimeoutMultiplier)
        {
            PIO_STACK_LOCATION IrpSp = 
                 IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp);
            UseATimer = TRUE;
            TotalTime.QuadPart =
                ((LONGLONG)((UInt32x32To64(
                                 (IrpSp->MajorFunction == IRP_MJ_WRITE)?
                                     (IrpSp->Parameters.Write.Length):
                                     (1),
                                 Timeouts.WriteTotalTimeoutMultiplier
                                 )
                                 + Timeouts.WriteTotalTimeoutConstant)))
                * -10000;
        }

        // The irp may be going to the isr shortly.  Now
        // is a good time to initialize its reference counts.

        SERIAL_INIT_REFERENCE(Extension->CurrentWriteIrp);

        // We need to see if this irp should be canceled.

        IoAcquireCancelSpinLock(&OldIrql);

        if (Extension->CurrentWriteIrp->Cancel)
        {
            IoReleaseCancelSpinLock(OldIrql);
            ExtTrace(Extension,D_Ioctl, " (write canceled)");
            Extension->CurrentWriteIrp->IoStatus.Status = STATUS_CANCELLED;
            if (!SetFirstStatus)
            {
                FirstStatus = STATUS_CANCELLED;
                SetFirstStatus = TRUE;
            }
        }
        else
        {
            if(!SetFirstStatus)
            {
                // If we haven't set our first status, then
                // this is the only irp that could have possibly
                // not been on the queue.  (It could have been
                // on the queue if this routine is being invoked
                // from the completion routine.)  Since this
                // irp might never have been on the queue we
                // should mark it as pending.

                IoMarkIrpPending(Extension->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;

            }

            // We give the irp to to the isr to write out.
            // We set a cancel routine that knows how to
            // grab the current write away from the isr.
            // Since the cancel routine has an implicit reference
            // to this irp up the reference count.

            IoSetCancelRoutine(
                Extension->CurrentWriteIrp,
                SerialCancelCurrentWrite
                );

            SERIAL_SET_REFERENCE(
                Extension->CurrentWriteIrp,
                SERIAL_REF_CANCEL
                );

            if(UseATimer)
            {
                //ExtTrace(Extension,D_Ioctl, " (total timer used)");
                KeSetTimer(
                    &Extension->WriteRequestTotalTimer,
                    TotalTime,
                    &Extension->TotalWriteTimeoutDpc
                    );

                // This timer now has a reference to the irp.
                SERIAL_SET_REFERENCE(
                    Extension->CurrentWriteIrp,
                    SERIAL_REF_TOTAL_TIMER
                    );
            }
#ifdef NEW_WRITE_SYNC_LOCK
            // write some data now
            SyncUp(Driver.InterruptObject,
               &Driver.TimerLock,
               SerialGiveWriteToIsr,
               Extension);
#else
            SerialGiveWriteToIsr(Extension);
#endif
            IoReleaseCancelSpinLock(OldIrql);
            break;
        }

        // Well the write was canceled before we could start it up.
        // Try to get another.

        SerialGetNextWrite(
            &Extension->CurrentWriteIrp,
            &Extension->WriteQueue,
            &NewIrp,
            TRUE,
            Extension
            );
    } while (NewIrp);

    return FirstStatus;
}

/****************************************************************************
Routine Description:
    This routine completes the old write as well as getting
    a pointer to the next write.
    The reason that we have have pointers to the current write
    queue as well as the current write irp is so that this
    routine may be used in the common completion code for
    read and write.
Arguments:
    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.
    QueueToProcess - Pointer to the write queue.
    NewIrp - A pointer to a pointer to the irp that will be the
             current irp.  Note that this could end up pointing
             to a null pointer.  This does NOT necessaryly mean
             that there is no current write.  What could occur
             is that while the cancel lock is held the write
             queue ended up being empty, but as soon as we release
             the cancel spin lock a new irp came in from
             SerialStartWrite.
    CompleteCurrent - Flag indicates whether the CurrentOpIrp should
                      be completed.
Return Value:
    None.
****************************************************************************/
VOID
SerialGetNextWrite(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    PSERIAL_DEVICE_EXTENSION Extension
    )
{
//    LARGE_INTEGER charTime; // 100 ns ticks per char, related to baud rate
//    LARGE_INTEGER WaitTime; // Actual time req'd for buffer to drain

//    PSERIAL_DEVICE_EXTENSION Extension = CONTAINING_RECORD(
//                                             QueueToProcess,
 //                                            SERIAL_DEVICE_EXTENSION,
 //                                            WriteQueue
//                                             );

    do {
        // We could be completing a flush.

        if (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction
            == IRP_MJ_WRITE)
        {  //------- normal write block
            KIRQL OldIrql;

            // assert that our TotalCharsQueued var is not screwed up.
            MyAssert(Extension->TotalCharsQueued >=
                   (IoGetCurrentIrpStackLocation(*CurrentOpIrp)
                    ->Parameters.Write.Length));

            IoAcquireCancelSpinLock(&OldIrql);

            // increment our character count
            Extension->TotalCharsQueued -=
                IoGetCurrentIrpStackLocation(*CurrentOpIrp)
                ->Parameters.Write.Length;

            IoReleaseCancelSpinLock(OldIrql);

        }
        else if (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction
                   == IRP_MJ_DEVICE_CONTROL)
        {   //------- xoffcounter nonsense
            KIRQL OldIrql;
            PIRP Irp;
            PSERIAL_XOFF_COUNTER Xc;

            IoAcquireCancelSpinLock(&OldIrql);

            Irp = *CurrentOpIrp;
            Xc = Irp->AssociatedIrp.SystemBuffer;

            //
            // We should never have a xoff counter when we
            // get to this point.
            //

            ASSERT(!Extension->CurrentXoffIrp);

            //
            // We absolutely shouldn't have a cancel routine
            // at this point.
            //

            ASSERT(!Irp->CancelRoutine);

            // If CurrentXoffIrp is not equal to null, this
            // implies that this is the "second" time around
            // for this irp, which implies that we should really
            // be completing it this time.


            //
            // This could only be a xoff counter masquerading as
            // a write irp.
            //

            Extension->TotalCharsQueued--;

            //
            // Check to see of the xoff irp has been set with success.
            // This means that the write completed normally.  If that
            // is the case, and it hasn't been set to cancel in the
            // meanwhile, then go on and make it the CurrentXoffIrp.
            //

            if (Irp->IoStatus.Status != STATUS_SUCCESS) {

                //
                // Oh well, we can just finish it off.
                //
                NOTHING;

            } else if (Irp->Cancel) {

                Irp->IoStatus.Status = STATUS_CANCELLED;

            } else {

                //
                // Give it a new cancel routine, and increment the
                // reference count because the cancel routine has
                // a reference to it.
                //

                IoSetCancelRoutine(
                    Irp,
                    SerialCancelCurrentXoff
                    );

                SERIAL_SET_REFERENCE(
                    Irp,
                    SERIAL_REF_CANCEL
                    );

                //
                // We don't want to complete the current irp now.  This
                // will now get completed by the Xoff counter code.
                //

                CompleteCurrent = FALSE;

                //
                // Give the counter to the isr.
                //

                Extension->CurrentXoffIrp = Irp;
                //KeSynchronizeExecution(
                //    Driver.Interrupt,
                //    SerialGiveXoffToIsr,
                //    Extension
                //    );
                SerialGiveXoffToIsr(Extension);

                //
                // Start the timer for the counter and increment
                // the reference count since the timer has a
                // reference to the irp.
                //

                if(Xc->Timeout) 
                {
                  LARGE_INTEGER delta;
                  delta.QuadPart = -((LONGLONG)UInt32x32To64(
                                                     1000,
                                                     Xc->Timeout
                                                     ));

                  KeSetTimer(
                        &Extension->XoffCountTimer,
                        delta,
                        &Extension->XoffCountTimeoutDpc
                        );
                  SERIAL_SET_REFERENCE(Irp,SERIAL_REF_TOTAL_TIMER);
                }  // timeout
              }
              IoReleaseCancelSpinLock(OldIrql);
            }

        //
        // Note that the following call will (probably) also cause
        // the current irp to be completed.
        //

        SerialGetNextIrp(
            CurrentOpIrp,
            QueueToProcess,
            NewIrp,
            CompleteCurrent,
            Extension
            );

        if (!*NewIrp) {

            KIRQL OldIrql;

            IoAcquireCancelSpinLock(&OldIrql);
            //KeSynchronizeExecution(
            //    Extension->Interrupt,
            //    SerialProcessEmptyTransmit,
            //    Extension
            //    );
            //SerialProcessEmptyTransmit();
            IoReleaseCancelSpinLock(OldIrql);

            break;

        }
        else if (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction ==
                                                 IRP_MJ_FLUSH_BUFFERS )
        {  //------ flush operation
           // If flush, wait for Tx FIFO to empty before completing
           ExtTrace(Extension,D_Ioctl, "(end flush write)");
#ifdef S_RK
#ifdef COMMENT_OUT
  (took this out 9-22-97 - kpb)
           // Calculate 100ns ticks to delay for each character
           // Negate for call to KeDelay...
           charTime = RtlLargeIntegerNegate(SerialGetCharTime(Extension));

           // While Tx FIFO and Tx Shift Register aren't empty
           while ( (sGetChanStatusLo(Extension->ChP) & DRAINED) != DRAINED )
           {  WaitTime = RtlExtendedIntegerMultiply(charTime,
                                                    sGetTxCnt(Extension->ChP)
                                                    );
              KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);
           }
#endif
#endif
            //
            // If we encounter a flush request we just want to get
            // the next irp and complete the flush.
            //
            // Note that if NewIrp is non-null then it is also
            // equal to CurrentWriteIrp.
            //

            ASSERT((*NewIrp) == (*CurrentOpIrp));
            (*NewIrp)->IoStatus.Status = STATUS_SUCCESS;
        }   
        else {

            break;

        }
    } while (TRUE);
}


/********************************************************************
Routine Description:
    This routine is merely used to complete any write.  It
    assumes that the status and the information fields of
    the irp are already correctly filled in.
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
*********************************************************************/
VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{
    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    // make sure no one else grabbed it first, since ISR will
    // set this flag to 2 to indicate it is ours to end.
    if (Extension->WriteBelongsToIsr == 2)
    {
      Extension->WriteBelongsToIsr = 0;
      SerialTryToCompleteCurrent(
        Extension,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &Extension->CurrentWriteIrp,
        &Extension->WriteQueue,
        NULL,
        &Extension->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite,
        SERIAL_REF_ISR
        );
    }
    else
    {
      IoReleaseCancelSpinLock(OldIrql);
    }
}

/******************************************************************************
Routine Description:
    Try to start off the write by slipping it in behind
    a transmit immediate char, or if that isn't available
    and the transmit holding register is empty, "tickle"
    the UART into interrupting with a transmit buffer
    empty.
    NOTE: This routine is called by KeSynchronizeExecution.
    NOTE: This routine assumes that it is called with the
          cancel spin lock held.
Arguments:
    Context - Really a pointer to the device extension.
Return Value:
    This routine always returns FALSE.
******************************************************************************/
BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    )
{
  PSERIAL_DEVICE_EXTENSION Extension = Context;
  ULONG wCount;
  ULONG room;
  ULONG write_cnt;
  ULONG OurWriteLength;

  // The current stack location.  This contains all of the
  // information we need to process this particular request.

  PIO_STACK_LOCATION IrpSp;

  IrpSp = IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp);

  // We might have a xoff counter request masquerading as a
  // write.  The length of these requests will always be one
  // and we can get a pointer to the actual character from
  // the data supplied by the user.

  if (IrpSp->MajorFunction == IRP_MJ_WRITE)
  {
    //------ start code addition to avoid tx-lag, see if we can start
    // sending data to hardware immediately

    OurWriteLength = IrpSp->Parameters.Write.Length;
    write_cnt = 0;  // use this as a flag as well if we will write() now.
    if ((IsListEmpty(&Extension->WriteQueue)))  // no queued up output data
    {
      // the startwrite routine added CurrentWriteIrp which is us,
      // so we are the only Write Irp in existence.  This is important
      // so that isr.c is not trying to serve up off our irp que too.

      //// [bug, 3-28-98, kpb] room = sGetTxCnt(Extension->ChP);
#ifdef S_RK
      room = (ULONG)(MAXTX_SIZE-sGetTxCnt(Extension->ChP));
#else
      room = (ULONG) PortGetTxRoom(Extension->Port);
#endif
      if (room > 10)  // we have room in the hardware
      {
        // at this point we have some non-trivial amount of space in
        // the hardware buffer to put some data.
        write_cnt = IrpSp->Parameters.Write.Length;
      }

      if (write_cnt)  // we are going to write() now
      {
#ifdef S_RK
        // toggle rts if needed
        if (Extension->Option & OPTION_RS485_SOFTWARE_TOGGLE)
        {
          if ((Extension->DTRRTSStatus & SERIAL_RTS_STATE) == 0)
          {
            sSetRTS(Extension->ChP);
            Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
          }
        }
                         // Send as much as possible,WriteTxBlk will chk fifo
        wCount = sWriteTxBlk(Extension->ChP,
                    (PUCHAR)(Extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer),
                    write_cnt);
#else

                             // Send it all ,WriteTxBlk will chk fifo
        if (write_cnt > room)  // limit to what we have space for
             wCount = room;
        else wCount = write_cnt;
        q_put(&Extension->Port->QOut,
              (PUCHAR)(Extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer),
                       wCount);
#endif
        Extension->OurStats.TransmittedCount += wCount;
        Extension->CurrentWriteIrp->IoStatus.Information += wCount;

        // following used to detect fifo empty, semaphore
        // which passes control to the ISR routine.
        OurWriteLength = (IrpSp->Parameters.Write.Length - wCount);
        Extension->ISR_Flags |= TX_NOT_EMPTY;  
        // and gives this write to ISR
        ExtTrace(Extension,D_Ioctl, " , Immed Part Write");
      }  // write() it out
    }  // no queue write packets


    //------ 1-08-98, end code addition to avoid tx-lag
    //add irp to queue, give isr.c the write irp to finish
    Extension->WriteLength = OurWriteLength;
    if (Extension->port_config->WaitOnTx)
    {
      // then definitely let ISR finish it, ISR must wait for tx-fifo to drain
      Extension->WriteBelongsToIsr = 1;
    }
    else
    {
      if (OurWriteLength == 0)
      {
        // its done, finish it off
        Extension->WriteBelongsToIsr = 2;
        KeInsertQueueDpc( &Extension->CompleteWriteDpc, NULL, NULL );
      }
      else
        Extension->WriteBelongsToIsr = 1;
    }
  }
  else
  {
    // !!!!! WHAT is a xoff counter????
    // An xoff-counter is something the virtual 16450 uart driver uses
    // to send an xoff, it sends an xoff and also starts a timer for
    // what purpose I am not sure.  Tried some code where it just sends
    // an xoff without the timer, this seemed to work ok, but the sent
    // xoff should be synced up with the other outgoing data packets in
    // the order received from the app.

      //It's an xoff counter......
      Extension->WriteLength = 1;
      Extension->WriteCurrentChar =
          ((PUCHAR)Extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer) +
          FIELD_OFFSET(SERIAL_XOFF_COUNTER, XoffChar);
  }

//endwr:

  // The isr now has a reference to the irp.
  SERIAL_SET_REFERENCE(
        Extension->CurrentWriteIrp,
        SERIAL_REF_ISR
        );

  return FALSE;
}

/****************************************************************************
Routine Description:
    This routine is used to cancel the current write.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP to be canceled.
Return Value:
    None.
*****************************************************************************/
VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;

    ExtTrace(Extension,D_Ioctl, "(cancel cur-write)");
    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabWriteFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &Extension->CurrentWriteIrp,
        &Extension->WriteQueue,
        NULL,
        &Extension->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite,
        SERIAL_REF_CANCEL
        );
}


/***************************************************************************
Routine Description:
    This routine will try to timeout the current write.
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
***************************************************************************/
VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{
    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    ExtTrace(Extension,D_Ioctl, "(write-timeout)");
    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabWriteFromIsr,
        OldIrql,
        STATUS_TIMEOUT,
        &Extension->CurrentWriteIrp,
        &Extension->WriteQueue,
        NULL,
        &Extension->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite,
        SERIAL_REF_TOTAL_TIMER
        );
}

/***************************************************************************
Routine Description:
    This routine is used to grab the current irp, which could be timing
    out or canceling, from the ISR
    NOTE: This routine is being called from KeSynchronizeExecution.
    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.
Arguments:
    Context - Really a pointer to the device extension.
Return Value:
    Always false.
***************************************************************************/
BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    )
{
    PSERIAL_DEVICE_EXTENSION Extension = Context;
#ifdef NEW_WAIT
    ULONG in_q;
#endif

#ifdef NEW_WAIT
    if (Extension->WriteBelongsToIsr != 0)
    {
        // isr owns irp, or it is has queued dpc to complete it.
        // reset this flag to take back from the isr.
        Extension->WriteBelongsToIsr = 0;

        // We could have an xoff counter masquerading as a
        // write irp.  If so, don't update the write length.

        if (IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp)
            ->MajorFunction != IRP_MJ_WRITE)
        {
            Extension->CurrentWriteIrp->IoStatus.Information = 0;
        }
        else
        {
           SERIAL_CLEAR_REFERENCE(Extension->CurrentWriteIrp,
                                  SERIAL_REF_ISR);

           Extension->WriteLength = 0;
           if (Extension->port_config->WaitOnTx)
           {
             // want to report how many characters are "stuck", or did
             // not really make it out the port if a timeout occurs.
#ifdef S_RK
             in_q = sGetTxCnt(Extension->ChP);
#else
             //  may have add in box cout too?
             in_q = PortGetTxCnt(Extension->Port);
#endif
             if (Extension->CurrentWriteIrp->IoStatus.Information >= in_q)
               Extension->CurrentWriteIrp->IoStatus.Information -= in_q;
           }
        }
    }
#else
    // Check if the write length is non-zero.  If it is non-zero
    // then the ISR still owns the irp. We calculate the the number
    // of characters written and update the information field of the
    // irp with the characters written.  We then clear the write length
    // the isr sees.
    if (Extension->WriteLength)
    {
        // We could have an xoff counter masquerading as a
        // write irp.  If so, don't update the write length.

        if (IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp)
            ->MajorFunction == IRP_MJ_WRITE)
        {
            Extension->CurrentWriteIrp->IoStatus.Information =
                IoGetCurrentIrpStackLocation(
                    Extension->CurrentWriteIrp
                    )->Parameters.Write.Length -
                Extension->WriteLength;
        }
        else
        {
            Extension->CurrentWriteIrp->IoStatus.Information = 0;
        }

        SERIAL_CLEAR_REFERENCE(Extension->CurrentWriteIrp,
                               SERIAL_REF_ISR);

        Extension->WriteLength = 0;

    }
#endif

    return FALSE;
}

// Xoff Counter code: UNUSED
/*-----------------------------------------------------------------
SerialGrabXoffFromIsr -
Routine Description:
    This routine is used to grab an xoff counter irp from the
    isr when it is no longer masquerading as a write irp.  This
    routine is called by the cancel and timeout code for the
    xoff counter ioctl.
    NOTE: This routine is being called from KeSynchronizeExecution.
    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.
Arguments:
    Context - Really a pointer to the device extension.
Return Value:
    Always false.
|-----------------------------------------------------------------*/
BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    )
{
    PSERIAL_DEVICE_EXTENSION Extension = Context;

    if (Extension->CountSinceXoff) {

        //
        // This is only non-zero when there actually is a Xoff ioctl
        // counting down.
        //

        Extension->CountSinceXoff = 0;

        //
        // We decrement the count since the isr no longer owns
        // the irp.
        //

        SERIAL_CLEAR_REFERENCE(
            Extension->CurrentXoffIrp,
            SERIAL_REF_ISR
            );

    }

    return FALSE;
}

/******************************************************************************
Routine Description:
    This routine is merely used to truely complete an xoff counter irp.  It
    assumes that the status and the information fields of the irp are
    already correctly filled in.
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
******************************************************************************/
VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        Extension,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &Extension->CurrentXoffIrp,
        NULL,
        NULL,
        &Extension->XoffCountTimer,
        NULL,
        NULL,
        SERIAL_REF_ISR
        );

}


/*------------------------------------------------------------------
Routine Description:
    This routine is merely used to truely complete an xoff counter irp,
    if its timer has run out.
Arguments:
    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.
Return Value:
    None.
-------------------------------------------------------------------*/
VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabXoffFromIsr,
        OldIrql,
        STATUS_SERIAL_COUNTER_TIMEOUT,
        &Extension->CurrentXoffIrp,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        SERIAL_REF_TOTAL_TIMER
        );

}

/*---------------------------------------------------------------
Routine Description:
    This routine is used to cancel the current write.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP to be canceled.
Return Value:
    None.
----------------------------------------------------------------*/
VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabXoffFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &Extension->CurrentXoffIrp,
        NULL,
        NULL,
        &Extension->XoffCountTimer,
        NULL,
        NULL,
        SERIAL_REF_CANCEL
        );
}

/*------------------------------------------------------------------------
Routine Description:
    This routine starts off the xoff counter.  It merely
    has to set the xoff count and increment the reference
    count to denote that the isr has a reference to the irp.
    NOTE: This routine is called by KeSynchronizeExecution.
    NOTE: This routine assumes that it is called with the
          cancel spin lock held.
Arguments:
    Context - Really a pointer to the device extension.
Return Value:
    This routine always returns FALSE.
------------------------------------------------------------------------*/
BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    )
{

    PSERIAL_DEVICE_EXTENSION Extension = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PSERIAL_XOFF_COUNTER Xc =
        Extension->CurrentXoffIrp->AssociatedIrp.SystemBuffer;

    Extension->CountSinceXoff = Xc->Counter;

    // The isr now has a reference to the irp.
    SERIAL_SET_REFERENCE(
        Extension->CurrentXoffIrp,
        SERIAL_REF_ISR
        );

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\write.h ===
//--- write.h

NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartWrite(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SerialGetNextWrite(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );


BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    );

VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    );

VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\addwiz.h ===
// addwiz.h

int DoAddWizPropPages(HWND hwndOwner);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\addwiz.c ===
/*-------------------------------------------------------------------
| addwiz.c - Add Device Wizard.
11-24-98 - zero out psh struct to ensure deterministic propsheet behavior. kpb
|--------------------------------------------------------------------*/
#include "precomp.h"

// testing!!!
#define ROCKETMODEM_PCI4_SUPPORT 1

static void set_field(HWND hDlg, WORD id);
static void get_field(HWND hDlg, WORD id);
//static int PaintIcon(HWND hWnd);

#ifdef NT50
// nt50 build does not link with this, so I made my own
#define strupr(s) my_strupr(s)
#endif
static void my_strupr(char *str);

static int FillDevicePropSheets(PROPSHEETPAGE *psp, LPARAM our_params);
static int InvalidMacAddress = 1;

#ifdef S_RK
  #define NUM_DEVPROP_SHEETS 7
  const LPSTR idWizIntro    = MAKEINTRESOURCE(IDD_ADD_WIZ_INTRO);
  const LPSTR idWizBus      = MAKEINTRESOURCE(IDD_ADD_WIZ_BUSTYPE);
  const LPSTR idWizModel    = MAKEINTRESOURCE(IDD_ADD_WIZ_BOARD);
  const LPSTR idWizNumPorts = MAKEINTRESOURCE(IDD_ADD_WIZ_NUMPORTS);
  const LPSTR idWizIoBase   = MAKEINTRESOURCE(IDD_ADD_WIZ_BASEIO);
  const LPSTR idWizCountry  = MAKEINTRESOURCE(IDD_ADD_WIZ_COUNTRY);
  const LPSTR idWizDone     = MAKEINTRESOURCE(IDD_ADD_WIZ_DONE);
#else
  #define NUM_DEVPROP_SHEETS 7
  const LPSTR idWizIntro    = MAKEINTRESOURCE(IDD_ADD_WIZ_INTRO);
  const LPSTR idWizDevice   = MAKEINTRESOURCE(IDD_ADD_WIZ_DEVICE);
  const LPSTR idWizNumPorts = MAKEINTRESOURCE(IDD_ADD_WIZ_NUMPORTS);
  const LPSTR idWizMac      = MAKEINTRESOURCE(IDD_ADD_WIZ_MAC);
  const LPSTR idWizCountry  = MAKEINTRESOURCE(IDD_ADD_WIZ_COUNTRY);
  const LPSTR idWizBackup   = MAKEINTRESOURCE(IDD_ADD_WIZ_BACKUP);
  const LPSTR idWizDone     = MAKEINTRESOURCE(IDD_ADD_WIZ_DONE);
#endif

  BOOL WINAPI WizIntroPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizBusPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizModelPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizNumPortsPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizIoBasePropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizCountryPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizDonePropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);

  // vs specific prototypes:
  BOOL WINAPI WizDevicePropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizNumPortsPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizMacPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);
  BOOL WINAPI WizBackupPropSheet(
        IN HWND   hDlg,
        IN UINT   uMessage,
        IN WPARAM wParam,
        IN LPARAM lParam);

/*------------------------------------------------------------------------
| FillDevicePropSheets - Setup pages for driver level property sheets.
|------------------------------------------------------------------------*/
static int FillDevicePropSheets(PROPSHEETPAGE *psp, LPARAM our_params)
{
  INT pi;
  static TCHAR title[20];

  load_str( glob_hinst, TITLESTR, title, CharSizeOf(title) );
  memset(psp, 0, sizeof(*psp) * NUM_DEVPROP_SHEETS);

  pi = 0;

  // Intro wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizIntro;
  psp[pi].pfnDlgProc = WizIntroPropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;

#ifdef S_RK
  // BusType wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizBus;
  psp[pi].pfnDlgProc = WizBusPropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
#endif

#ifdef S_RK
  // RocketPort/RocketModem Model wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizModel;
  psp[pi].pfnDlgProc = WizModelPropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
#else
  // VS1000/VS2000/RocketPort Serial Hub wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizDevice;
  psp[pi].pfnDlgProc = WizDevicePropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
#endif

  // NumPorts wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizNumPorts;
  psp[pi].pfnDlgProc = WizNumPortsPropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;

#ifdef S_RK
  // BaseIoAddress wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizIoBase;
  psp[pi].pfnDlgProc = WizIoBasePropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
#endif
  // RowCountryCode wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizCountry;
  psp[pi].pfnDlgProc = WizCountryPropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;

#ifdef S_VS
  // MacAddress wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizMac;
  psp[pi].pfnDlgProc = WizMacPropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
#endif

#ifdef S_VS
  // BackupServer wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizBackup;
  psp[pi].pfnDlgProc = WizBackupPropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
#endif

  // Done wizard page
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = idWizDone;
  psp[pi].pfnDlgProc = WizDonePropSheet;
  psp[pi].pszTitle = title;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;

  return 0;
}

/*------------------------------------------------------------------------
| DoAddWizPropPages - Main driver level property sheet for NT4.0
|------------------------------------------------------------------------*/
int DoAddWizPropPages(HWND hwndOwner)
{
  PROPSHEETPAGE psp[NUM_DEVPROP_SHEETS];
  PROPSHEETHEADER psh;
  OUR_INFO *our_params;
  INT stat;
  AddWiz_Config *aw_info;
#ifdef S_RK
  INT i, j;
  static WORD preferred_addresses[] = {0x180, 0x100, 0x140, 0x1c0,
                                       0x200, 0x240, 0x280, 0x2c0,
                                       0x300, 0x340, 0x380, 0x3c0, 0};
#endif

  our_params = glob_info;  // temporary kludge, unless we don't need re-entrantancy

  // init our add_wiz struct
  aw_info = glob_add_wiz;
  memset(aw_info, 0, sizeof(*aw_info));

  // set some defaults
  aw_info->CountryIdx = 0;
#ifdef S_RK
  aw_info->NumPorts = 8;
  strcpy(aw_info->BoardType, szRocketPort);
  aw_info->IoAddress = 0;   // next we'll try to pick a logical default address
  for (i = 0; (preferred_addresses[i] != 0) && (aw_info->IoAddress == 0); i++)
  {
    aw_info->IoAddress = preferred_addresses[i];    // our assumption
    for (j = 0; (j < glob_info->device_selected) && (aw_info->IoAddress != 0); j++)
    {
      if (wi->dev[j].IoAddress == preferred_addresses[i])
        // not available, so undo this default
        aw_info->IoAddress = 0;
    }
  }
#else
  aw_info->NumPorts = 16;
  strcpy(aw_info->BoardType, szSerialHub);    // first in list
  memset(aw_info->MacAddr, 0, sizeof(aw_info->MacAddr));
  aw_info->BackupServer = 0;
  aw_info->BackupTimer = 2;
#endif

  //Fill out the PROPSHEETPAGE data structure for the Client Area Shape
  //sheet
  FillDevicePropSheets(&psp[0], (LPARAM)our_params);

  //Fill out the PROPSHEETHEADER
  memset(&psh, 0, sizeof(PROPSHEETHEADER));  // add fix 11-24-98
  psh.dwSize = sizeof(PROPSHEETHEADER);
  psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
  psh.hwndParent = hwndOwner;
  psh.hInstance = glob_hinst;
  psh.pszIcon = "";
  psh.pszCaption = (LPSTR)"Add Device Wizard";
  psh.nPages = NUM_DEVPROP_SHEETS;
  psh.ppsp = (LPCPROPSHEETPAGE) &psp;

  //And finally display the dialog with the property sheets.

  stat = PropertySheet(&psh);

  if (aw_info->finished)
    return 0;  // ok
  else
    return 1;  // canceled out
}

/*----------------------------------------------------------
 WizIntroPropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizIntroPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);

    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_INTRO);
        break;

        case PSN_SETACTIVE:
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
        break;

        case PSN_WIZNEXT:
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}

#ifdef S_RK
/*----------------------------------------------------------
 WizBusPropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizBusPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);

    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
#if 0
      PaintIcon(hDlg);
#endif
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_BUSTYPE);
        break;

        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_ISA);
          set_field(hDlg, IDC_WIZ_PCI);

          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_WIZNEXT:
          get_field(hDlg, IDC_WIZ_ISA);
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}
#endif

#ifdef S_RK
/*----------------------------------------------------------
 WizModelPropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizModelPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
#if 0
      PaintIcon(hDlg);
#endif
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_CBOX_BOARD);
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_BOARD);
        break;

        case PSN_WIZNEXT:
          get_field(hDlg, IDC_WIZ_CBOX_BOARD);
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}
#endif

#ifdef S_VS
/*----------------------------------------------------------
 WizDevicePropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizDevicePropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_CBOX_DEVICE);
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_DEVICE);
        break;

        case PSN_WIZNEXT:
          get_field(hDlg, IDC_WIZ_CBOX_DEVICE);
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}
#endif

/*----------------------------------------------------------
 WizNumPortsPropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizNumPortsPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_CBOX_NUMPORTS);
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_NUMPORTS);
        break;

        case PSN_WIZNEXT:
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          get_field(hDlg, IDC_WIZ_CBOX_NUMPORTS);

#ifdef S_RK
          if (!aw->IsIsa) {
            // PCI
            if (!aw->IsModemDev) {
              // not a RocketModem, so we're done
              PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizDone);
              // tell sheet not to handle advance -- we overrode it
              SetWindowLong(hDlg, DWL_MSGRESULT, -1);
            }
            else
            {
              // new PCI RocketModem, so prompt for country
              PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizCountry);
              // tell sheet not to handle advance -- we overrode it
              SetWindowLong(hDlg, DWL_MSGRESULT, -1);
            }
          }
#else
  #ifdef VS2000_ROW_SUPPORT
          if (!aw->IsModemDev)
          {
  #endif
            // not a VS2000 - and/or - no ROW support; skip over Country page
            PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizMac);
            // tell sheet not to handle advance -- we overrode it
            SetWindowLong(hDlg, DWL_MSGRESULT, -1);
  #ifdef VS2000_ROW_SUPPORT
          }
  #endif
#endif
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}

#ifdef S_RK
/*----------------------------------------------------------
 WizIoBasePropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizIoBasePropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_CBOX_IOADDR);
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_BASEIO);
        break;

        case PSN_WIZNEXT:
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          get_field(hDlg, IDC_WIZ_CBOX_IOADDR);

          if (!aw->IsModemDev) {
            PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizDone);
            // tell sheet not to handle advance -- we overrode it
            SetWindowLong(hDlg, DWL_MSGRESULT, -1);
          }
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}
#endif

/*----------------------------------------------------------
 WizCountryPropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizCountryPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_CBOX_COUNTRY);
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_COUNTRY);
        break;

        case PSN_WIZBACK:
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);

          if (aw->IsIsa == 0)
          {
            // PCI RocketModem: back up to numports dialog instead of ioaddr
            PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizNumPorts);
            // tell sheet not to handle advance -- we overrode it
            SetWindowLong(hDlg, DWL_MSGRESULT, -1);
          }
        return TRUE;

        case PSN_WIZNEXT:
          get_field(hDlg, IDC_WIZ_CBOX_COUNTRY);
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}

#ifdef S_VS
/*----------------------------------------------------------
 WizMacPropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizMacPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_CBOX_MAC);
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_MAC);
        break;

        case PSN_WIZBACK:
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);

#ifdef VS2000_ROW_SUPPORT
          if (!aw->IsModemDev)
          {
#endif
            // not a VS2000 - and/or - no ROW support; skip over Country page
            PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizNumPorts);
            // tell sheet not to handle advance -- we overrode it
            SetWindowLong(hDlg, DWL_MSGRESULT, -1);
#ifdef VS2000_ROW_SUPPORT
          }
#endif
        break;

        case PSN_WIZNEXT:
          get_field(hDlg, IDC_WIZ_CBOX_MAC);
          if (InvalidMacAddress == 1)
            // don't allow advance to next field
            SetWindowLong(hDlg, DWL_MSGRESULT, -1);
          else
            SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}
#endif

#ifdef S_VS
/*----------------------------------------------------------
 WizBackupPropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizBackupPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  char tmpstr[60];
  WORD uCmd;
  HWND hwnd;
  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_COMMAND:
      uCmd = HIWORD(wParam);

      switch (LOWORD(wParam))
      {
        case IDC_WIZ_BACKUP_YES:
        case IDC_WIZ_BACKUP_NO:
          //--- enable or disable backup-timer field depending on backup server[]
          hwnd = GetDlgItem(hDlg, IDC_WIZ_CBOX_BACKUPTIME);
          if (IsDlgButtonChecked(hDlg, IDC_WIZ_BACKUP_YES))
            EnableWindow(hwnd,1);
          else EnableWindow(hwnd,0);
        break;
      }
    break;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          set_field(hDlg, IDC_WIZ_BACKUP_YES);
          set_field(hDlg, IDC_WIZ_CBOX_BACKUPTIME);
          //--- enable or disable backup-timer field depending on backup server[]
          hwnd = GetDlgItem(hDlg, IDC_WIZ_CBOX_BACKUPTIME);
          if (IsDlgButtonChecked(hDlg, IDC_WIZ_BACKUP_YES))
            EnableWindow(hwnd,1);
          else EnableWindow(hwnd,0);
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_BACKUP);
        break;

        case PSN_WIZNEXT:
          get_field(hDlg, IDC_WIZ_BACKUP_YES);
          get_field(hDlg, IDC_WIZ_CBOX_BACKUPTIME);
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}
#endif

/*----------------------------------------------------------
 WizDonePropSheet -
|-------------------------------------------------------------*/
BOOL WINAPI WizDonePropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
    return TRUE;  // No need for us to set the focus.

    case WM_PAINT:
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_SETACTIVE:
          PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_ADD_WIZ_DONE);
        break;

#ifdef S_RK
        case PSN_WIZBACK:
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          if (!aw->IsModemDev)
          {
            if (!aw->IsIsa)
            {
              // back up to the numports dialog
              PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizNumPorts);
              // tell sheet not to handle advance -- we overrode it
              SetWindowLong(hDlg, DWL_MSGRESULT, -1);
            }
            else
            {
              // back up to the base io dialog
              PropSheet_SetCurSelByID(((NMHDR *)lParam)->hwndFrom, idWizIoBase);
              // tell sheet not to handle advance -- we overrode it
              SetWindowLong(hDlg, DWL_MSGRESULT, -1);
            }
          }
        return TRUE;
#endif

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
          aw->finished = 1;

          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }

    default :
    return FALSE;
  }
}

#ifdef S_VS
/*----------------------------------------------------------
 set_mac_field -
|------------------------------------------------------------*/
static int set_mac_field(HWND hDlg, WORD id)
{
  HWND hwnd;
  char tmpstr[60];
  int stat;
  int i;
  int addr_used, nbytes, found;
  BYTE *macbuf;
  BYTE *mac;

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  //------------------ fill in mac addr selection
  hwnd = GetDlgItem(hDlg, id);
  SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

  // alloc 8byte mac-address fields(2 times as many as could be configured)
  found = 0;
  nbytes = 0;
  macbuf = our_get_ping_list(&stat, &nbytes);

  if (stat == 0)
  {
    for (i=0; i<nbytes/8; i++)
    {
      mac = &macbuf[i*8];
      //if (mac_match(mac, aw->MacAddr))
      //  found = 1;
      //mess("macgot:%s",macbuf);

      format_mac_addr(tmpstr, mac);

      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) tmpstr);
    }
  }
  
  addr_used = 1;
  
  if ( (mac_match(aw->MacAddr, broadcast_addr)) ||
       (mac_match(aw->MacAddr, mac_zero_addr)) )
    addr_used = 0;
  
  if (addr_used)
  {
    mac = &aw->MacAddr[0];
    format_mac_addr(tmpstr, mac);
  
    if (!found)  // configured mac-addr not in list yet
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) tmpstr);
  }
  else
  {
    memset(aw->MacAddr, 0, 6);
    strcpy(tmpstr, "00 C0 4E # # #");
  }
  // set the text in the window
  SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "00 C0 4E # # #");
  SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) tmpstr);

  return 0;
}
#endif

/*-------------------------------------------------------------------
| get_field - Run when a selection is changed.
|--------------------------------------------------------------------*/
static void get_field(HWND hDlg, WORD id)
{
  char tmpstr[60];
  int i;

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch (id)
  {
#ifdef S_RK
    case IDC_WIZ_ISA:
    case IDC_WIZ_PCI:
      if (IsDlgButtonChecked(hDlg, IDC_WIZ_ISA))
        aw->IsIsa = 1;
      else aw->IsIsa = 0;
    break;
#endif

#ifdef S_RK
    case IDC_WIZ_CBOX_BOARD:
      GetDlgItemText(hDlg, id, aw->BoardType, sizeof(aw->BoardType));

      aw->IsModemDev = 0;

      if (!strcmp(aw->BoardType, szRocketModem))
        aw->IsModemDev = TYPE_RM_VS2000;
      else if (!strcmp(aw->BoardType, szRocketModemII))
        aw->IsModemDev = TYPE_RMII;
      else if (!strcmp(aw->BoardType, szRocketModem_i))
        aw->IsModemDev = TYPE_RM_i;

    break;
#endif

#ifdef S_VS
    case IDC_WIZ_CBOX_DEVICE:
      GetDlgItemText(hDlg, id, aw->BoardType, sizeof(aw->BoardType));
      if (!strcmp(aw->BoardType, szSerialHub))
      {
        aw->IsHub = 1;
        aw->IsModemDev = 0;
      }
      else
      {
        aw->IsHub = 0;
        if (!strcmp(aw->BoardType, szVS2000))
          aw->IsModemDev = TYPE_RM_VS2000;
        else
          aw->IsModemDev = 0;
      }
    break;
#endif

#ifdef S_RK
    case IDC_WIZ_CBOX_IOADDR:
      GetDlgItemText(hDlg, id, tmpstr, 58);
      aw->IoAddress = gethint(tmpstr, &i);
    break;
#endif

    case IDC_WIZ_CBOX_NUMPORTS:
      GetDlgItemText(hDlg, id, tmpstr, 58);
      aw->NumPorts = getint(tmpstr, &i);
    break;

    case IDC_WIZ_CBOX_COUNTRY:
      GetDlgItemText(hDlg, id, tmpstr, 58);
      aw->CountryIdx = 0;

      if (aw->IsModemDev == TYPE_RM_VS2000) {

        for (
        i = 0; 
        i < NUM_ROW_COUNTRIES; 
        i++
        ) {

          if (!strcmp(tmpstr, RowInfo[i].RowCountryName)) {
            aw->CountryIdx = i;
            aw->CountryCode = RowInfo[i].RowCountryCode;
            break;
          }
        }
      }
      else if (aw->IsModemDev == TYPE_RM_i) {

        for (
        i = 0; 
        i < NUM_CTR_ROW_COUNTRIES; 
        i++
        ) {

          if (!strcmp(tmpstr, CTRRowInfo[i].RowCountryName)) {
            aw->CountryIdx = i;
            aw->CountryCode = CTRRowInfo[i].RowCountryCode;
            break;
          }
        }
      }
      else if (aw->IsModemDev) {
        aw->CountryIdx = 0;
        aw->CountryCode = RowInfo[0].RowCountryCode;
      }
    break;

#ifdef S_VS
    case IDC_WIZ_CBOX_MAC:
          // get_mac_field() is shared and is in devprop.c
      InvalidMacAddress = get_mac_field(hDlg, id, aw->MacAddr);
    break;

    case IDC_WIZ_BACKUP_NO:
    case IDC_WIZ_BACKUP_YES:
      if (IsDlgButtonChecked(hDlg, IDC_WIZ_BACKUP_YES))
        aw->BackupServer = 1;
      else aw->BackupServer = 0;
    break;

    case IDC_WIZ_CBOX_BACKUPTIME:
      //------------------ get the backup timer value
      GetDlgItemText(hDlg, id, tmpstr, 19);
      if (sscanf(tmpstr, "%ld", &i) == 1)
        aw->BackupTimer = i;

      if (aw->BackupTimer < 2)
        aw->BackupTimer = 2;
    break;
#endif

  }
}

/*----------------------------------------------------------
 set_field -
|------------------------------------------------------------*/
static void set_field(HWND hDlg, WORD id)
{
  HWND hwnd;
  char tmpstr[60];
  int i;
#ifdef S_RK
  int j;
  BOOL is_avail;
  WORD baseaddr;
  static WORD hex_addresses[] = {0x100, 0x140, 0x180, 0x1c0,
                                 0x200, 0x240, 0x280, 0x2c0,
                                 0x300, 0x340, 0x380, 0x3c0, 0};
#endif

  AddWiz_Config *aw;
  aw = glob_add_wiz;

  switch(id)
  {
#ifdef S_RK
    case IDC_WIZ_ISA:
      SendDlgItemMessage(hDlg, IDC_WIZ_ISA, BM_SETCHECK, aw->IsIsa, 0);
      SendDlgItemMessage(hDlg, IDC_WIZ_PCI, BM_SETCHECK, 1 - aw->IsIsa, 0);
    break;
#endif

#ifdef S_RK
    case IDC_WIZ_CBOX_BOARD:
      //------------------ fill in board type (model) selection
      hwnd = GetDlgItem(hDlg, id);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      if (aw->IsIsa) {
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szRocketPort);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szRocketPort485);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szRocketModem);
      }
      else
      {
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szRocketPort);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szRocketPortPlus);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szRocketModemII);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szRocketModem_i);
      }
      // make sure there's a default
      SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) "R");
      // now try to select the last device chosen by user.  it may not be valid
      // if the user switched from ISA to PCI (for example) and the choice
      // isn't available on the new bus.
      SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) aw->BoardType);
    break;
#endif

#ifdef S_VS
    case IDC_WIZ_CBOX_DEVICE:
      //------------------ fill in board type (model) selection
      hwnd = GetDlgItem(hDlg, id);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szVS1000);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szVS2000);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szSerialHub);
      // make sure there's a default
      SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) aw->BoardType);
    break;
#endif

#ifdef S_RK
    case IDC_WIZ_CBOX_IOADDR:
      //------------------ fill in io base address selection
      hwnd = GetDlgItem(hDlg, id);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      for (i = 0; hex_addresses[i] != 0; i++)
      {
        baseaddr = hex_addresses[i];
        // see if this base address already chosen by another card
        is_avail = TRUE;  // our assumption
        for (j = 0; (j < glob_info->device_selected) && (is_avail); j++)
        {
          if (wi->dev[j].IoAddress == baseaddr)
            is_avail = FALSE;
        }
        if (is_avail)
        {
          wsprintf(tmpstr, "%x Hex", baseaddr);
          if (baseaddr == 0x180)
            strcat(tmpstr, " (default)");
          SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)tmpstr);
        }
      }
      // now make the previous choice the default choice
      if (aw->IoAddress == 0x180)
        wsprintf(tmpstr, "%x hex (default)", aw->IoAddress);
      else
        wsprintf(tmpstr, "%x hex", aw->IoAddress);
      SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) tmpstr);
    break;
#endif

    case IDC_WIZ_CBOX_NUMPORTS:
      //------------------ fill in numports selection
      hwnd = GetDlgItem(hDlg, id);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
#ifdef S_RK
      if ((aw->IsModemDev) && (aw->IsIsa == 0))
      {
        // PCI RocketModem can be 4 or 6 ports
# ifdef ROCKETMODEM_PCI4_SUPPORT
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP4);
# endif
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP6);
        // default the number of ports for the pci rocketmodem to 6
        aw->NumPorts = 6;
      }
      else
      {
        // all other boards follow this logic:
        if (strstr(aw->BoardType, szRocketPortPlus))
        {
          // Rocketport Plus available in a 2-port version
          SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP2);
        }
        if (!strstr(aw->BoardType, szRocketPort485))
        {
          // all except Rocketport 485 available in a 4-port version
          SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP4);
        }
        // all RocketPort variations available in an 8-port version
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP8);
        if (strlen(aw->BoardType) == strlen(szRocketPort))
        {
          // only standard boards available in 16 & 32 port versions
          SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP16);
          SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP32);
        }
      }
      wsprintf(tmpstr, "%d", aw->NumPorts);
      SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) tmpstr);
#else  // S_VS
      if (aw->IsModemDev)
      {
        // VS2000 only available in 8 port configuration
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP8);
        // default the number of ports for the VS2000 to 8
        aw->NumPorts = 8;
      }
      else if (aw->IsHub)
      {
        // SerialHub available in 4 (not yet) and 8 port configuration
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP4);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP8);
        // default the number of ports for the Serial Hub to 8
        aw->NumPorts = 8;
      }
      else
      {
        // we must have a VS1000 or VS1000/VS1100 combo
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP16);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP32);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP48);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP64);
        // default the number of ports for the VS1000 to 16
        aw->NumPorts = 16;
      }
      wsprintf(tmpstr, "%d", aw->NumPorts);
      SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) tmpstr);
#endif  // S_VS
    break;

    case IDC_WIZ_CBOX_COUNTRY:
      //------------------ fill in country selection
      hwnd = GetDlgItem(hDlg, id);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      if (aw->IsModemDev == TYPE_RM_VS2000) {

        for (
        i = 0; 
        i < NUM_ROW_COUNTRIES; 
        ++i
        ) {
          SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(RowInfo[i].RowCountryName));
        }

        SendMessage(
          hwnd, 
          CB_SELECTSTRING, 
          (WPARAM)-1,
          (LPARAM)(RowInfo[aw->CountryIdx].RowCountryName));
      }
      else if (aw->IsModemDev == TYPE_RM_i) {
      
        for (
        i = 0; 
        i < NUM_CTR_ROW_COUNTRIES; 
        ++i
        ) {
          SendMessage(
            hwnd, 
            CB_ADDSTRING, 
            0, 
            (LPARAM)(CTRRowInfo[i].RowCountryName));
        }

        SendMessage(
          hwnd, 
          CB_SELECTSTRING, 
          (WPARAM)-1,
          (LPARAM)(CTRRowInfo[aw->CountryIdx].RowCountryName));
      } 
      else if (aw->IsModemDev) {

        SendMessage(
          hwnd, 
          CB_ADDSTRING, 
          0, 
          (LPARAM)(RowInfo[0].RowCountryName));

        SendMessage(
          hwnd, 
          CB_SELECTSTRING, 
          (WPARAM)-1,
          (LPARAM)(RowInfo[0].RowCountryName));
      }
    break;

#ifdef S_VS
    case IDC_WIZ_CBOX_MAC:
      set_mac_field(hDlg, id);
    break;

    case IDC_WIZ_BACKUP_YES:
    case IDC_WIZ_BACKUP_NO:
      SendDlgItemMessage(hDlg, IDC_WIZ_BACKUP_YES, BM_SETCHECK,
                         aw->BackupServer, 0);
      SendDlgItemMessage(hDlg, IDC_WIZ_BACKUP_NO,  BM_SETCHECK,
                         1 - aw->BackupServer, 0);
    break;

    case IDC_WIZ_CBOX_BACKUPTIME:
      //------------------ fill in backup timer selection
      hwnd = GetDlgItem(hDlg, IDC_WIZ_CBOX_BACKUPTIME);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "2 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "5 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "10 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "30 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "60 min");

      if (aw->BackupTimer < 2)
        aw->BackupTimer = 2; // 2 minutes, no less

      wsprintf(tmpstr, "%d min", aw->BackupTimer);
      SetDlgItemText(hDlg, IDC_WIZ_CBOX_BACKUPTIME, tmpstr);
    break;
#endif
  }
}
#if 0
/*---------------------------------------------------------------------------
  PaintIcon - Paints the Icon in the property sheet.
|---------------------------------------------------------------------------*/
static int PaintIcon(HWND hWnd)
{
//   int status;
   HBITMAP      hBitMap;
   HGDIOBJ      hGdiObj;
   HDC          hDC, hMemDC ;
   PAINTSTRUCT  ps ;
   RECT spot, main;  // left, top, right, bottom
   static int cnt = 0;

  GetWindowRect(GetDlgItem(hWnd, IDB_HELP), &spot);
  GetWindowRect(hWnd, &main);
#ifdef COMMENT_OUT
  rect = &right;
  mess("hlp r:%d l:%d b:%d t:%d",
       rect->right, rect->left, rect->bottom, rect->top);
#endif
  spot.left -= main.left;
  spot.top -= main.top;

  spot.left += 5;
  spot.top  += 20; // spacing

   // load bitmap and display it

   hDC = BeginPaint( hWnd, &ps ) ;
   if (NULL != (hMemDC = CreateCompatibleDC( hDC )))
   {
      hBitMap = LoadBitmap(glob_hinst,
                           MAKEINTRESOURCE(BMP_SMALL_LOGO));

      hGdiObj = SelectObject(hMemDC, hBitMap);

      BitBlt( hDC, spot.left, spot.top, 100, 100, hMemDC, 0, 0, SRCCOPY ) ;
      //StretchBlt( hDC, 5, 5, 600,100, hMemDC, 0, 0, 446, 85, SRCCOPY ) ;
      DeleteObject( SelectObject( hMemDC, hGdiObj ) ) ;
      DeleteDC( hMemDC ) ;
   }
   EndPaint( hWnd, &ps ) ;
 return 0;
}
#endif

/*-------------------------------------------------------------------
| my_strupr -
|--------------------------------------------------------------------*/
static void my_strupr(char *str)
{
  while (*str != 0)
  {
    *str = (char) toupper(*str);
    ++str;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\commrkt.h ===
/*-----------------------------------------------------------------------------
 COMMRKT.H - Windows 3.1 COMM.DRV driver for RocketPort
             Prototypes for exported functions

This include file is only needed if you are running the RocketPort
Windows 3.1 driver(commrkt.drv, vcdrkt.vxd) and need to access ports above
COM9.  The driver contains additional functions(see below) which allow
you to open com-ports greater than COM9.

If you want the macros below to translate all standard Windows calls to
rocket calls(functions prefixed with a "rkt"), then define the following:
#define NEED_OVER_COM9
This will cause the macros defined below to take effect which will replace
the standard Windows comm-port function calls with the "rkt" function calls.

The rocket library commands will only work with the RocketPort ports,
the OpenComm() call will fail for the standard com ports(COM1,2).

The supplied commdrv.lib import library must then be linked in.
the actual functions are contained in the driver file called commrkt.drv
which is actually the Dynamic Link Library with these functions.

This solution is only available with the Windows 3.1 driver, and will not
work with any of our other Windows drivers.  If you move to Win95 or NT
environment we would suggest that you use the 32-bit programming model
to overcome the COM9 limitation associated with the 16-bit Windows API.
For Windows95 an alternative is to install the Windows 3.1 driver,
which will work in a compatibility mode for 16-bit applications.

Company: Comtrol Corporation
-----------------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C" {
#endif 

/* Controller initialization error codes.  OpenComm() and rktOpenComm()
   can both return these if the controller initialization fails on the
   first open the system attempts. */
#define IER_INIFILE   -20   /* Driver problem reading ROCKETPT.INI file */
#define IER_CTLINIT   -21   /* Controller hardware initialization error */
#define IER_CHANINIT  -22   /* Channel hardware initialization error */
#define IER_DEVSIZE   -23   /* Invalid number of devices found */
#define IER_CTLSIZE   -24   /* Invalid number of controllers found */
#define IER_NOINTHND  -25   /* Could not install interrupt handler */
#define IER_NOINT     -26   /* Interrupts are not occuring */

// the following may be switched on to access over COM9 limitation
// in 16-bit Windows, when used with the RocketPort Windows 3.1
// driver.  These are not available in the W95/WFW311/NT Comtrol
// Drivers.  The actual library functions exist in the "commrkt.drv"
// file(part of our driver.)  This is really just a dynamic link library,
// and the "commrkt.lib" is just an import library which tells the linker
// & compiler where to find these calls at runtime.
// These macros change every standard Windows Comm-API call in our program
// to the rkt##### special library call.

#ifdef NEED_OVER_COM9
#define BuildCommDCB     rktBuildCommDCB
#define ClearCommBreak   rktClearCommBreak
#define CloseComm        rktCloseComm
#define EnableCommNotification rktEnableCommNotification
#define EscapeCommFunction rktEscapeCommFunction
#define FlushComm        rktFlushComm
#define GetCommError     rktGetCommError
#define GetCommState     rktGetCommState
#define GetCommEventMask rktGetCommEventMask
#define OpenComm         rktOpenComm
#define ReadComm         rktReadComm
#define SetCommBreak     rktSetCommBreak
#define SetCommEventMask rktSetCommEventMask
#define SetCommState     rktSetCommState
#define TransmitCommChar rktTransmitCommChar
#define WriteComm        rktWriteComm
#endif

#ifndef _CDECL
#define _CDECL FAR PASCAL
#endif

int _CDECL rktBuildCommDCB(LPCSTR,DCB far *);
int _CDECL rktClearCommBreak(int);
int _CDECL rktCloseComm(int);
BOOL _CDECL rktEnableCommNotification(int,HWND,int,int);
LONG _CDECL rktEscapeCommFunction(int,int);
int _CDECL rktFlushComm(int,int);
int _CDECL rktGetCommError(int,COMSTAT far *);
int _CDECL rktGetCommState(int,DCB far *);
WORD _CDECL rktGetCommEventMask(int,int);
int _CDECL rktOpenComm(LPCSTR,UINT,UINT);
int _CDECL rktReadComm(int,void far *,int);
int _CDECL rktSetCommBreak(int);
UINT far * _CDECL rktSetCommEventMask(int,UINT);
int _CDECL rktSetCommState(DCB far *);
int _CDECL rktTransmitCommChar(int,char);
int _CDECL rktWriteComm(int,void far *,int);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\comutils.h ===
#ifdef __cplusplus
extern "C" {
#endif
// comtutil.h

// ioctl.h
// product_id codes
#define PRODUCT_UNKNOWN 0
#define NT_VS1000       1
#define NT_ROCKET       2
#define NT_RPSHSI			3

//---------------
// we setup our structure arrays with one of these things at the
// foot of the array as a standard header.  When we request data
// from the driver, this tells the driver what structure type and
// size follows.
typedef struct
{
  ULONG struct_type;
  ULONG struct_size;
  ULONG num_structs;
  ULONG var1;  // reserve
} PortMonBase;

typedef struct
{
  DWORD PlatformId;    // ioctl_open() will set this up.
  ULONG ctl_code;      // ioctl_open() will set this up.
  HANDLE hcom;         // handle to driver for ioctl calls.  ioctl_open sets up.
  TCHAR *driver_name;   // ioctl_open() will set this up.
  int product_id;  // ioctl_open() will set this up.

  PortMonBase *pm_base;  // base ptr to data buffer header
                         // application needs to set this up prior to call.

  int buf_size;   // byte size of buffer data to send/rec to/from driver
                  // application needs to set this up prior to call.

  int ret_bytes;   // number of bytes returned from call into driver.
                  // includes size of pmn header
} IoctlSetup;

//#define IOCTL_DEVSTAT     9  // device/link status(not used anymore)
#define IOCTL_PORTNAMES  10  // name array [12] bytes
#define IOCTL_PORTSTATUS 11  // port stats, array
#define IOCTL_DEBUGLOG   13  // driver debug log
#define IOCTL_OPTION     14  // option setup
#define IOCTL_MACLIST    15  // mac-scan list
#define IOCTL_NICSTAT    16  // nic status
#define IOCTL_DEVICESTAT 17  // device/link status
#define IOCTL_KICK_START 18  // get system going
#define IOCTL_PORT_RESET 19  // port reset -- mkm --

//---------------
// we get the port names from the driver once at startup.
typedef struct
{
  char  port_name[12];  // port name(0=end of port list),("."=not assigned)
} PortMonNames;

//---------------
// this is the raw data we continually get from from the driver.
typedef struct
{
  DWORD TxTotal;     // total number of sent bytes
  DWORD RxTotal;      // total number of receive bytes

  WORD TxPkts;   // number of write() packets
  WORD RxPkts;    // number of read() packets

  WORD overrun_errors; // receive over-run errors
  WORD framing_errors; // receive framing errors

  WORD  parity_errors;  // receive parity errors
  WORD status_flags;  // opened/close, flow-ctrl, out/in pin signals, etc
} PortMonStatus;


int APIENTRY ioctl_call(IoctlSetup *ioctl_setup);
int APIENTRY ioctl_open(IoctlSetup *ioctl_setup, int product_id);
#define ioctl_close(_ioctl_setup) \
  { if ((_ioctl_setup)->hcom != NULL) \
      CloseHandle((_ioctl_setup)->hcom); }

// reg.h

int APIENTRY reg_key_exists(HKEY handle, const TCHAR * keystr);
int APIENTRY reg_create_key(HKEY handle, const TCHAR * keystr);
int APIENTRY reg_set_str(HKEY handle,
                         const TCHAR * child_key,
                         const TCHAR * str_id,
                         const char *src,
                         int str_type);  // REG_SZ, REG_EXPAND_SZ
int APIENTRY reg_set_dword_del(HKEY handle,
                               const TCHAR * child_key,
                               const TCHAR * str_id,
                               DWORD new_value,
                               DWORD del_value);
int APIENTRY reg_delete_key(HKEY handle,
                            const TCHAR * child_key,
                            const TCHAR * str_id);
int APIENTRY reg_delete_value(HKEY handle,
                              const TCHAR * child_key,
                              const TCHAR * str_id);
int APIENTRY reg_set_dword(HKEY handle,
                           const TCHAR * child_key,
                           const TCHAR * str_id,
                           DWORD new_value);
int APIENTRY reg_get_str(HKEY handle,
                         const TCHAR * child_key,
                         const TCHAR * str_id,
                         char *dest,
                         int str_len);
int APIENTRY reg_get_dword(HKEY handle,
                           const TCHAR * child_key,
                           const TCHAR * str_id,
                           DWORD *dest);
int APIENTRY reg_open_key(HKEY handle,
                          HKEY *new_handle,
                          const TCHAR *keystr,
                          DWORD attribs);  // KEY_READ, KEY_ALL_ACCESS

#define reg_close_key(handle) \
  { if (handle) {RegCloseKey(handle); handle = NULL;} }
//----- setuppm.h
int APIENTRY make_progman_group(char **list,char *dest_dir);
int APIENTRY delete_progman_group(char **list, char *dest_dir);

//---- cutil.h

#define D_Error 0x00001
#define D_Warn  0x00002
#define D_Init  0x00004
#define D_Test  0x00008

#if DBG
extern int DebugLevel;
#define DbgPrintf(_Mask_,_Msg_) \
  { if (_Mask_ & DebugLevel) { OurDbgPrintf _Msg_;} }
#define DbgPrint(s) OutputDebugString(s)
#else
#define DbgPrintf(_Mask_,_Msg_)
#define DbgPrint(s)
#endif

void APIENTRY ascii_string(unsigned char *str);
void APIENTRY normalize_string(char *str);
int APIENTRY getstr(char *instr, char *outstr, int max_size);
int APIENTRY getnumbers(char *str, int *nums, int max_nums);
int APIENTRY listfind(char *str, char **list);
int APIENTRY my_lstricmp(char *str1, char *str2);
int APIENTRY my_substr_lstricmp(char far *str1, char far *str2);
int APIENTRY getint(char *textptr, int *countptr);
unsigned int APIENTRY gethint(char *bufptr, int *countptr);
int APIENTRY my_toupper(int c);
int APIENTRY my_lstrimatch(char *find_str, char *str_to_search);
void APIENTRY OurDbgPrintf(TCHAR *format, ...);

// ourfile.h

typedef struct {
  HANDLE  hfile;
  ULONG dwDesiredAccess;
  ULONG dwCreation;
  int flags; // 1h = eof, 2=error
} OUR_FILE;

void APIENTRY our_remove(TCHAR *name);
OUR_FILE * APIENTRY our_fopen(TCHAR *name, char *attr);
void APIENTRY our_fclose(OUR_FILE *fp);
int APIENTRY our_feof(OUR_FILE *fp);
int APIENTRY our_ferror(OUR_FILE *fp);
unsigned int APIENTRY our_fseek(OUR_FILE *fp, int pos, int relative);
void APIENTRY our_fputs(char *str, OUR_FILE *fp);
char * APIENTRY our_fgets(char *str, int maxlen, OUR_FILE *fp);
int APIENTRY our_fwrite(void *buffer, int size, int count, OUR_FILE *fp);
int APIENTRY our_fread(void *buffer, int size, int count, OUR_FILE *fp);


#ifdef __cplusplus
}
#endif
#ifdef __cplusplus
// ttywin.h

/* text window memory */
#define TROWS 35
#define TCOLS 86

class TTYwin {
  public:
  HWND hwnd;        // handle of our port window
  HFONT hfont;
  TCHAR text_buf[TROWS+2][TCOLS+3];
  int screen_update_flag;  // need to update the screen.
  int display_cur_row;
  int cur_row;
  int cur_col;
  int scr_size_x;
  int scr_size_y;
  int show_crlf;
  int caret_on;
  unsigned long text_color;
  HBRUSH hbrush_window;  // for painting background

  TTYwin();
  ~TTYwin();
  void TTYwin::init(HWND owner_hwnd);
  void TTYwin::set_color(int color_rgb);
  void TTYwin::set_size(int x, int y);
  void TTYwin::show_caret(int on);
  void TTYwin::mess_str(TCHAR *str, int len=0);
  void TTYwin::update_screen(int all_flag);
  void TTYwin::mess_line(TCHAR *str, int line_num);
  void TTYwin::mess_num(int num);
  void TTYwin::clear_scr(void);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\dripick.c ===
/*-------------------------------------------------------------------
| dripick.c - Driver Device Pick(main screen).
|--------------------------------------------------------------------*/
#include "precomp.h"

static BOOL FAR PASCAL on_command(HWND hDlg, UINT message,
                              WPARAM wParam, LPARAM lParam);
static int setup_buttons(HWND hDlg);
static void set_main_dlg_info(HWND hDlg);
static int do_tv_notify(HWND hDlg, UINT message,
                              WPARAM wParam, LPARAM lParam);
HIMAGELIST hTreeImage = NULL;

HBITMAP hbmBoard; 
HBITMAP hbmPort; 
HBITMAP hbmBoardMask; 
HBITMAP hbmPortMask; 

/*----------------------------------------------------------
 DevicePickSheet - Dlg window procedure for add on Advanced sheet.
|-------------------------------------------------------------*/
BOOL WINAPI DevicePickSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO * OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);
  UINT stat;
  static int first_time = 1;
  Port_Config *ps;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);

      DbgPrintf(D_Init, ("Dripick:Init 9\n"))
      if (glob_hwnd == NULL)
        glob_hwnd = hDlg;

      if (wi->NumDevices == 0)
      {
        EnableWindow(GetDlgItem(hDlg, IDB_REMOVE),0);
        EnableWindow(GetDlgItem(hDlg, IDB_PROPERTIES),0);
      }

      set_main_dlg_info(hDlg);
      SetFocus(GetDlgItem(hDlg, IDC_LBOX_DEVICE));
#if (defined(NT50))
  // if nt50  then get rid of <add> and <remove>
  // buttons
     
    ShowWindow(GetDlgItem(hDlg, IDB_ADD), SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDB_REMOVE), SW_HIDE);

#endif

    return TRUE;  // No need for us to set the focus.

    case PSM_QUERYSIBLINGS :
    {
      switch (HIWORD(wParam))
      {
        case QUERYSIB_GET_OUR_PROPS :
          // grab updated info from controls(don't have any)

          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return TRUE;
        break;

        default :
        return FALSE;
      }
    }

    case WM_COMMAND :
        on_command(hDlg, uMessage, wParam, lParam);
    return FALSE;

    case WM_PAINT:
      if (first_time)
      {
        first_time = 0;
        if (wi->NumDevices == 0)  // bring up wizard
        {
          PostMessage(hDlg, WM_COMMAND, IDB_ADD, 0);  // bring up add wiz
        }
#if (defined(NT50) && defined(S_VS))
        // they need to configure the mac-address...
        if (mac_match(wi->dev[0].MacAddr, mac_zero_addr))
          PostMessage(hDlg, WM_COMMAND, IDB_PROPERTIES, 0);  // bring up VS device sheet
#endif
      }
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :

      switch (((NMHDR *)lParam)->code)
      {
        //case TVN_STARTLABELEDIT:   no such thing
        //  DgbPrint(D_Test, ("start label edit"))
        //return FALSE;

        case TVN_ENDLABELEDIT:
        {
          TV_ITEM *item;
          item = &((TV_DISPINFO *)lParam)->item;

          // 80H bit used to mark tree item as a Device(not port)
          glob_info->device_selected = (item->lParam & 0x7f);
          glob_info->port_selected = (item->lParam >> 8);

          if (item->lParam & 0x80)  // a board is selected
               glob_info->selected = BOARD_SELECTED;
          else glob_info->selected = PORT_SELECTED;

          if (item->pszText != NULL)
          {
            int bad_label = 0;

            // on a board(we should trap start-of-edit!)
            if (glob_info->selected == BOARD_SELECTED)
            {
              if (strlen(item->pszText) > 59)  // limit to 59 chars
                item->pszText[60] = 0;
              strcpy(wi->dev[glob_info->device_selected].Name, item->pszText);
  DbgPrintf(D_Error,(TEXT("device label:%s\n"), item->pszText));
            }
            else
            {
              // copy over new name
              if ((strlen(item->pszText) > 10) ||
                  (strlen(item->pszText) == 0))
              {
                bad_label = 1; // don't keep the text, to long
              }
              _tcsupr(item->pszText);

              if (_tcsncmp(item->pszText, "COM", 3) != 0)
                bad_label = 2;
              else if (strlen(item->pszText) < 4)
                bad_label = 3;
              else if (!isdigit(item->pszText[3]))
                bad_label = 4;

              if (bad_label)
              {
                DbgPrintf(D_Error, (TEXT("Bad COM name, err%d"), bad_label))

                stat = our_message(&wi->ip,RcStr((MSGSTR+2)),MB_OK);
                return 0;  // don't keep the text, to long
              }
              ps = &wi->dev[glob_info->device_selected].ports[glob_info->port_selected];

              strcpy(ps->Name, item->pszText);
#if 0
              validate_port_name(ps, 1);  // if not valid, make it so

              DbgPrintf(D_Error,(TEXT("port label:%s\n"), item->pszText));

              if (wi->dev[glob_info->device_selected].NumPorts > 
                          (glob_info->port_selected+1))
              {
                set_main_dlg_info(hDlg);
                stat = our_message(&wi->ip,
"Rename in ascending order all remaining ports on this device?",MB_YESNO);
                if (stat == IDYES)
                {
                  rename_ascending(glob_info->device_selected,
                                   glob_info->port_selected);
                }
              }
#endif
            }
            set_main_dlg_info(hDlg);

            return 1;  // keep the text
          }
        }
        break;

        case TVN_SELCHANGED :
          {
          // selection change in the tree view, update buttons accordingly
          NM_TREEVIEW *nmtv;
          TV_ITEM *item;
          nmtv = (NM_TREEVIEW *) lParam;
          item = &nmtv->itemNew;

          // 80H bit used to mark tree item as a Device(not port)
          glob_info->device_selected = (item->lParam & 0x7f);
          glob_info->port_selected = (item->lParam >> 8);

          if (item->lParam & 0x80)  // a board is selected
               glob_info->selected = BOARD_SELECTED;
          else glob_info->selected = PORT_SELECTED;

          setup_buttons(hDlg);
          }
        break;

        case PSN_HELP :
          our_help(&wi->ip, IDD_MAIN_DLG);
        break;

        case PSN_QUERYCANCEL :
          // request that the other sheets gather up any changes.
          PropSheet_QuerySiblings(GetParent(hDlg),
                                  (WPARAM) (QUERYSIB_GET_OUR_PROPS << 16),
                                  0);

          if (allow_exit(1))  // request cancel
          {
            // the DWL_MSGRESULT field must be *FALSE* to tell QueryCancel
            // that an exit is acceptable.  The function result must be
            // *TRUE* to acknowledge that we handled the message.
            SetWindowLong(hDlg, DWL_MSGRESULT, FALSE); // allow cancel
            return TRUE;
          }
          else
          {
            // the DWL_MSGRESULT field must be *TRUE* to tell QueryCancel
            // that we don't want an exit.  The function result must be
            // *TRUE* to acknowledge that we handled the message.
            SetWindowLong(hDlg, DWL_MSGRESULT, TRUE); // don't allow cancel
            return TRUE;
          }
        break;

        case PSN_APPLY :
            // request that the other sheets gather up any changes.
            PropSheet_QuerySiblings(GetParent(hDlg),
                                    (WPARAM) (QUERYSIB_GET_OUR_PROPS << 16),
                                    0);
            if (!wi->DriverExitDone)
            {
            // now see if anything changed that needs saving
            if (allow_exit(0))  // request ok to save and exit
            {
              wi->DriverExitDone = 1;  // prevents other pages doing this
              // do the install/save of config params if not canceling..
#ifdef NT50
              our_nt50_exit();  // ok, quit
#else
              our_exit();  // nt40 exit
#endif
              SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
              //wi->SaveOnExit = 1;
            }
            else
            {
              SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            }
            }
            return TRUE;

        default :
            return FALSE;
      }

    default :
        return FALSE;
  }
}

#define YBITMAP 16
#define XBITMAP 16
//#define XBITMAP 24

/*-------------------------------------------------------------------
| set_main_dlg_info - Run to setup the various field selections.
  ran at start and when any changes are made.  Smart IO-selections
  which exclude themselves from double choose.
|--------------------------------------------------------------------*/
static void set_main_dlg_info(HWND hDlg)
{
 int i,j,bd;
 HWND hwnd;
 char tmpstr[80];
 Device_Config *dev;
 int first_time = 0;

 int dev_select = glob_info->device_selected;
 int port_select = glob_info->port_selected;
 int selected = glob_info->selected;

  //------------------ fill in the device selection window
  hwnd = GetDlgItem(hDlg, IDC_LBOX_DEVICE);

  {
    TV_ITEM tvItem;
    HTREEITEM tvSelectHandle;
    TV_INSERTSTRUCT tvIns;

    if (hTreeImage == NULL)
    {
      hTreeImage = ImageList_Create(XBITMAP,YBITMAP, TRUE, 2, 2);
#ifdef S_VS
      i = ImageList_AddMasked (hTreeImage, LoadBitmap(glob_hinst,
//                         MAKEINTRESOURCE(BMP_VS_BOX)), RGB(128,128,128));
                         MAKEINTRESOURCE(BMP_VS_BOX)), RGB(255,255,255));
#else
      i = ImageList_AddMasked (hTreeImage, LoadBitmap(glob_hinst,
                         MAKEINTRESOURCE(BMP_BOARDS)), RGB(0,128,128));
#endif

      ImageList_AddMasked (hTreeImage, LoadBitmap(glob_hinst,
                         MAKEINTRESOURCE(BMP_PORTSM)), RGB(0,128,128));

      glob_info->device_selected = 0;
      glob_info->port_selected = 0;
      glob_info->selected = BOARD_SELECTED;

      dev_select = glob_info->device_selected;
      port_select = glob_info->port_selected;
      selected = glob_info->selected;

      first_time = 1;
    }

    TreeView_DeleteAllItems(hwnd);

    TreeView_SetImageList(hwnd, hTreeImage, TVSIL_NORMAL);

    for (bd=0; bd< wi->NumDevices; bd++)
    {
      dev = &wi->dev[bd];

      tvItem.pszText = dev->Name;
      tvItem.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
      tvItem.iImage         = 0;
      tvItem.iSelectedImage = 0;
      tvItem.lParam         = bd | 0x80;

      tvIns.hParent         = TVGN_ROOT;
      tvIns.hInsertAfter    = TVGN_ROOT;
      tvIns.item            = tvItem;

      // And insert the item, returning its handle
      dev->tvHandle = TreeView_InsertItem ( hwnd, &tvIns );

      if ((selected == BOARD_SELECTED) && (dev_select == bd))
        tvSelectHandle = dev->tvHandle;

      if (tvSelectHandle == NULL)  // make sure it selects something
        tvSelectHandle = dev->tvHandle;

      for (j=0; j< wi->dev[bd].NumPorts; j++)
      {
#ifdef INDEXED_PORT_NAMES
        // generate the port name based on StartComIndex
        wsprintf(dev->ports[j].Name, "COM%d", dev->StartComIndex + j);
#endif

        tvItem.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
        tvItem.iImage         = 1;
        tvItem.iSelectedImage = 1;
        tvItem.pszText = dev->ports[j].Name;
        tvItem.lParam  = bd | (j<<8);

        // Fill out the TV_INSERTSTRUCT
        tvIns.hInsertAfter    = NULL;
        tvIns.hParent         = dev->tvHandle;
        tvIns.item            = tvItem;
        // And insert the item, returning its handle
        dev->ports[j].tvHandle = TreeView_InsertItem ( hwnd, &tvIns );

        if ((selected == PORT_SELECTED) && (port_select == j) &&
            (dev_select == bd))
          tvSelectHandle = dev->ports[j].tvHandle;
      }
    }

    // make sure all devices are expanded, showing their ports.
    for (bd=0; bd< wi->NumDevices; bd++)
    {
      dev = &wi->dev[bd];
      TreeView_Expand ( hwnd, dev->tvHandle, TVE_EXPAND);
    }

    if (wi->NumDevices > 0)
    {
      if (!first_time)
        TreeView_SelectItem(hwnd, tvSelectHandle);
    }
  }

  setup_buttons(hwnd);
}

/*-----------------------------------------------------------------------------
| on_command -
|-----------------------------------------------------------------------------*/
BOOL FAR PASCAL on_command(HWND hDlg, UINT message,
                              WPARAM wParam, LPARAM lParam)
{
 WORD uCmd;
 int i,j, stat;

#ifdef WIN32
  uCmd = HIWORD(wParam);
#else
  uCmd = HIWORD(lParam);
#endif

  switch (LOWORD(wParam))
  {
    case IDC_LBOX_DEVICE:
      if (uCmd == CBN_DBLCLK)
      {
        // this doesn't work
        if (glob_info->selected == BOARD_SELECTED)
             DoDevicePropPages(hDlg);
        else DoPortPropPages(hDlg, glob_info->device_selected, glob_info->port_selected);
        break;
      }

      //if (uCmd != CBN_SELCHANGE) break;
    break;

// for nt50 we don't have a remove or add button
#if ( (!defined(NT50)) )
    case IDB_REMOVE:
      if (wi->NumDevices < 1)
      {
        MessageBox(hDlg,"Use the Network Control Panel applet to remove this software.",
                   "Error",MB_OK|MB_ICONSTOP);
        break;
      }

#ifdef S_RK
      // force them to remove ISA boards in order
      i = glob_info->device_selected;
      if (wi->dev[i].IoAddress >= 0x100)  // isa board
      {
        ++i;
        for (; i<wi->NumDevices; i++)
        {
          if (wi->dev[i].IoAddress >= 0x100)  // isa board
          {
            MessageBox(hDlg,"You have to remove the last ISA board in the list first.",
                      "Error",MB_OK|MB_ICONSTOP);
            i = 100;  // don't let them remove
          }
        }

        if (i>=100)  // don't let them remove
          break;
      }
#endif

      // delete the device node
      j = 0;
      for (i=0; i<wi->NumDevices; i++)
      {
        if (i != glob_info->device_selected)
        {
          if (i != j)
            memcpy(&wi->dev[j], &wi->dev[i], sizeof(Device_Config));
          ++j;
        }
      }
      if (wi->NumDevices > 0)
        --wi->NumDevices;
      if (glob_info->device_selected > 0)
        --glob_info->device_selected;

      glob_info->selected = BOARD_SELECTED;

      if (wi->NumDevices == 0)
      {
        EnableWindow(GetDlgItem(hDlg, IDB_REMOVE),0);
        EnableWindow(GetDlgItem(hDlg, IDB_PROPERTIES),0);
      }
      set_main_dlg_info(hDlg);
    break;

    case IDB_ADD:
      {
        Device_Config *dev;
        /////////char tmpstr[80];
        if (wi->NumDevices == MAX_NUM_DEVICES)
        {
          wi->NumDevices = MAX_NUM_DEVICES;
          our_message(&wi->ip,RcStr((MSGSTR+3)),MB_OK);
          break;  // bail
        }
        dev = &wi->dev[wi->NumDevices];

        glob_info->device_selected = wi->NumDevices; // point to new one

        // clear out all ports config
        memset(dev->ports, 0, sizeof(Port_Config) * MAX_NUM_PORTS_PER_DEVICE);  // clear our structure

        ++wi->NumDevices;

        stat = DoAddWizPropPages(hDlg);  // add wizard sheet

        if (stat != 0)  // they canceled or didn't finish
        {
          if (wi->NumDevices > 0)  // error, so remove
            --wi->NumDevices;
          break;  // cancelled, so bail
        }

        if (wi->NumDevices == 0)  // shouldn't happen, but just in case
          break;

        if (glob_info->device_selected >= wi->NumDevices)
          glob_info->device_selected = wi->NumDevices - 1;

        // transfer the data from the wizard buffer to the new device buffer
        strncpy(dev->ModelName, glob_add_wiz->BoardType, sizeof(dev->ModelName));
        dev->ModemDevice = glob_add_wiz->IsModemDev;
        wi->ModemCountry = glob_add_wiz->CountryCode;
        dev->NumPorts = glob_add_wiz->NumPorts;
#ifdef S_RK
        dev->IoAddress = glob_add_wiz->IoAddress;
        if (!glob_add_wiz->IsIsa)
          dev->IoAddress = 1;
        wsprintf(dev->Name, "Rocket #%d", wi->NumDevices);
#else
        dev->HubDevice = glob_add_wiz->IsHub;
        dev->BackupServer = glob_add_wiz->BackupServer;
        dev->BackupTimer = glob_add_wiz->BackupTimer;
        memcpy(&dev->MacAddr, &glob_add_wiz->MacAddr, sizeof(dev->MacAddr));
        if (dev->HubDevice)
          wsprintf(dev->Name, "Rocket Serial Hub #%d", wi->NumDevices);
        else if (dev->ModemDevice)
          wsprintf(dev->Name, "VS2000 #%d", wi->NumDevices);
        else
          wsprintf(dev->Name, "VS1000 #%d", wi->NumDevices);
#endif
        {
          char tmpstr[20];
          // pick com-port names
          FormANewComPortName(tmpstr, NULL);
          for (i=0; i<dev->NumPorts; i++)
          {
            strcpy(dev->ports[i].Name, tmpstr);
            BumpPortName(tmpstr);
          }
        }

        //validate_device(dev, 1);

        if (dev->ModemDevice)
        {
          // lets turn on the RING emulation option on the ports
          for (i=0; i<dev->NumPorts; i++)
            dev->ports[i].RingEmulate = 1;
        }

        // now show it.
        if (DoDevicePropPages(hDlg) != 0)  // if they cancel out
        {
          if (wi->NumDevices > 0)  // error, so remove
            --wi->NumDevices;
        }

        if (wi->NumDevices != 0)
        {
          EnableWindow(GetDlgItem(hDlg, IDB_REMOVE),1);
          EnableWindow(GetDlgItem(hDlg, IDB_PROPERTIES),1);
        }

        set_main_dlg_info(hDlg);
      }
    break;
#endif

    case IDB_PROPERTIES:
      if (wi->NumDevices == 0)
        break;

      if (glob_info->device_selected >= wi->NumDevices)
        glob_info->device_selected = wi->NumDevices - 1;

      if (glob_info->selected == BOARD_SELECTED)
        DoDevicePropPages(hDlg);
      else
        DoPortPropPages(hDlg, glob_info->device_selected, glob_info->port_selected);
      set_main_dlg_info(hDlg);
      SetFocus(GetDlgItem(hDlg, IDC_LBOX_DEVICE));
    break;

  }
  return TRUE;
}

/*---------------------------------------------------------------------------
  setup_buttons - Enable or Disable buttons depending on circumstances.
|---------------------------------------------------------------------------*/
static int setup_buttons(HWND hDlg)
{
  if (glob_info->selected == BOARD_SELECTED)  // on a board
  {
    EnableWindow(GetDlgItem(hDlg, IDB_PROPERTIES),1);
    EnableWindow(GetDlgItem(hDlg, IDB_REMOVE),1);  // enable remove
    if (wi->NumDevices < MAX_NUM_DEVICES)
         EnableWindow(GetDlgItem(hDlg, IDB_ADD),1);
    else EnableWindow(GetDlgItem(hDlg, IDB_ADD),0);
  }
  else  // on a port
  {
    EnableWindow(GetDlgItem(hDlg, IDB_PROPERTIES),1);
    EnableWindow(GetDlgItem(hDlg, IDB_REMOVE),0);  // disable remove
    EnableWindow(GetDlgItem(hDlg, IDB_ADD),0);     // disable add
  }

  if (wi->NumDevices == 0)  // special case
  {
    EnableWindow(GetDlgItem(hDlg, IDB_REMOVE),0);
    EnableWindow(GetDlgItem(hDlg, IDB_PROPERTIES),0);
    EnableWindow(GetDlgItem(hDlg, IDB_ADD),1);     // enable add
  }
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\devprop.h ===
// devprop.h

int DoDevicePropPages(HWND hwndOwner);
void format_mac_addr(char *outstr, unsigned char *address);
int get_mac_field(HWND hDlg, WORD id, BYTE *MacAddr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\dripick.h ===
// dripick.h

BOOL FAR PASCAL main_dlg_proc(HWND hDlg, UINT message,
                              WPARAM wParam, LPARAM lParam);

BOOL WINAPI DevicePickSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\devprop.c ===
/*-------------------------------------------------------------------
| devprop.c - Device Properties Sheet.

 5-26-99 - fix picking inappropriate starting com-port index.
 2-02-99 - fix port rename problem, where it would skip over old port-names,
  also take out port-name from selection if owned by other drivers.
|--------------------------------------------------------------------*/
#include "precomp.h"

#define D_Level 0x20
// use a current and previous reading to measure the advance, or
// calculated value.  Drop occassional rollover case.
#define NORM_COUNTER(calc,curr,prev,last) \
{ \
  if ((curr) > (prev)) \
    calc = (last) + ((curr) - (prev)); \
  else \
    calc = (last); \
}

//#define  STATE_DISPLAY  1
#ifdef STATE_DISPLAY

#define STATE_CHANGE(newstate) \
{ \
  mess(&wi->ip, \
   "Currstate %s\nNewstate %s\n", \
   statestrings[pDstatus->verbose_advise_state], \
   statestrings[(newstate)]); \
  pDstatus->verbose_advise_state = (newstate); \
}
#else

#define STATE_CHANGE(newstate) \
{ \
  pDstatus->verbose_advise_state = (newstate); \
}
#endif

static void set_field(HWND hDlg, WORD id);
static void get_field(HWND hDlg, WORD id);
static int PaintIcon(HWND hWnd);
static int PaintLogo(HWND hWnd);

static int set_mac_field(HWND hDlg, WORD id);
static int set_io_addr_field(HWND hDlg, WORD id);

#define  MAX_DEVPROP_SHEETS 2

typedef struct
{
  int x;
  int y;
} POINT2D;

static int PaintRockers(HWND hWnd, int brd);
static int poly_border(POINT2D *pts, POINT2D *ends, int lines);
static void draw_but(HDC hDC, int x, int y, int cx, int cy, int but_in);

static int num_active_devprop_sheets = 1;  // always at least one

#ifdef S_VS

typedef struct {
  unsigned char  mac[6];
  unsigned char  flags;
  unsigned char  nic_index;
}DRIVER_MAC_STATUS;

typedef struct {
   ULONG struct_size;
   ULONG num_ports;
   ULONG total_loads;
   ULONG good_loads;
   ULONG backup_server;
   ULONG state;
   ULONG iframes_sent;
   ULONG rawframes_sent;  // was send_rawframes
   ULONG ctlframes_sent;  // was send_ctlframes
   ULONG iframes_resent;  // was pkt_resends
   ULONG iframes_outofseq;  // was ErrBadIndex
   ULONG frames_rcvd;    // was: rec_pkts
   ULONG nic_index;
   unsigned char dest_addr[6];
} PROBE_DEVICE_STRUCT;

typedef struct {
  ULONG struct_size;
  ULONG Open;
  ULONG pkt_sent;
  ULONG pkt_rcvd_ours;
  ULONG pkt_rcvd_not_ours;
  char NicName[64];
  unsigned char address[6];
} PROBE_NIC_STRUCT;

typedef struct {
  int   verbose_advise_state;  // index into big advise string
  int   vsl_detected;  // number of vs's found from broadcast ping
  int   vsl_available; // number of vs's available found from broadcast ping
  BYTE  vsl_load_status;  // flags info come back from broadcast query replys
  BYTE  vsl_device_status_found;  // 1=driver found matching VS config.
  BYTE  vsl_nic_status_found;  // 1=driver found NIC config.
  BYTE  vsl_driver_found;  // 1=we can talk to driver, 0=driver not loaded
  BYTE  vsl_ping_device_found;  // 1=we found it during a ping
  BYTE  vsl_mac_list_found;  // 1=ping delivered a list of macs on network

   PROBE_NIC_STRUCT curr_nic;
   PROBE_NIC_STRUCT prev_nic;
   PROBE_NIC_STRUCT calc_nic;
   PROBE_NIC_STRUCT temp_nic;
   PROBE_DEVICE_STRUCT curr_dev;
   PROBE_DEVICE_STRUCT prev_dev;
   PROBE_DEVICE_STRUCT calc_dev;
   PROBE_DEVICE_STRUCT temp_dev;
} DSTATUS;

#define  FLAG_APPL_RUNNING  0x01
#define  FLAG_NOT_OWNER    0x02
#define  FLAG_OWNER_TIMEOUT  0x04

static void set_status_field(HWND hDlg,WORD id,DSTATUS *pDstatus);
static void check_traffic_activity(DSTATUS *pDstatus);
static void get_status(DSTATUS *pDstatus,int reset);
static BYTE *ping_devices(DSTATUS *pDstatus, int *nBytes);
static void build_advisor_display(HWND hDlg,DSTATUS *pDstatus,int reset);

char *vslink_state_table[] = {      // 27 May BF
  "Init",
  "InitOwn",
  "SendCode",
  "Connect",
  "Active",
  "Invalid",
};

#define  VSL_STATE_INIT     0
#define  VSL_STATE_INITOWN  1
#define  VSL_STATE_SENDCODE 2
#define  VSL_STATE_CONNECT  3
#define  VSL_STATE_ACTIVE   4

// these values are used in port.c in the driver:
//#define ST_INIT          0
//#define ST_GET_OWNERSHIP 1
//#define ST_SENDCODE      2
//#define ST_CONNECT       3
//#define ST_ACTIVE        4

#define  NIC_STATE_INVALID  0
#define  NIC_STATE_CLOSED  1
#define  NIC_STATE_OPEN    2
#define  NIC_STATE_UNDEFINED  3

#define STATE_not_init          0
#define STATE_driver_not_avail  1
#define STATE_nic_not_avail     2
#define STATE_no_vslinks_avail  3
#define STATE_vslink_not_avail  4
#define STATE_not_configured    5
#define STATE_not_owner         6
#define STATE_vslink_not_ready  7
#define STATE_ok_no_traffic     8
#define STATE_ok                9
#define STATE_poor_link        10
#define STATE_reset            11
//#define STATE_network_not_avail

#if 0
char *AdvisoryString[] = {        // 27 May BF
/* 1 */  "Device is active and OK.",
/* 2 */  "No data traffic exchanged since last inquiry.",
#endif

char *AdvisoryString[] = {        // 27 May BF
"Uninitialized.",

"The driver is not running.  If you just installed the driver \
you will need to exit the program before the driver starts.",

"Unable to find a Network Interface Controller (NIC) card.",

"Can't detect any Comtrol devices. Check Ethernet connectors and insure \
device is powered on.",

"Can't detect device with specified MAC address on any network. Verify MAC \
address of unit, check Ethernet connectors and insure device is powered on.",

"Device with specified MAC address was detected, but isn't configured for \
this server. Return to 'Device Setup' dialog, configure, save configuration, \
and restart server.",

"Device detected and is configured for this server, but is not yet assigned \
to this server.",

"Device detected, initializing.",

"Device is active and OK, no data traffic exchanged since last inquiry.",

"Device is active and OK.",

"Poor connection to device. Check connectors, cabling, and insure proper LAN \
termination.",

"Counts reset.",
};

static int dstatus_initialized = 0;
static DSTATUS glob_dstatus;

#endif

int FillDevicePropSheets(PROPSHEETPAGE *psp, LPARAM our_params);
BOOL WINAPI DevicePropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);

BOOL WINAPI StatusPropSheet(      // 27 May BF
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);

/*------------------------------------------------------------------------
| FillDevicePropSheets - Setup pages for driver level property sheets.
|------------------------------------------------------------------------*/
int FillDevicePropSheets(PROPSHEETPAGE *psp, LPARAM our_params)
{
  INT pi;
  static TCHAR devsetstr[40], devadvstr[40];

  memset(psp, 0, sizeof(*psp) * MAX_DEVPROP_SHEETS);

  pi = 0;

  // prop device sheet.
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
#ifdef S_VS
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_VS_DEVICE_SETUP);
#else
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_DEVICE_SETUP);
#endif
  psp[pi].pfnDlgProc = DevicePropSheet;
  load_str( glob_hinst, (TITLESTR+1), devsetstr, CharSizeOf(devsetstr) );
  psp[pi].pszTitle = devsetstr;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
  num_active_devprop_sheets = 1;

#ifdef S_VS
  // prop status sheet.
  psp[pi].dwSize    = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags   = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags   = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance   = glob_hinst;
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_STATUS);
  psp[pi].pfnDlgProc  = StatusPropSheet;
  load_str( glob_hinst, (TITLESTR+2), devadvstr, CharSizeOf(devadvstr) );
  psp[pi].pszTitle    = devadvstr;
  psp[pi].lParam    = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
  ++num_active_devprop_sheets;
#endif

  return 0;
}

/*------------------------------------------------------------------------
| DoDevicePropPages - Main driver level property sheet for NT4.0
|------------------------------------------------------------------------*/
int DoDevicePropPages(HWND hwndOwner)
{
    PROPSHEETPAGE psp[MAX_DEVPROP_SHEETS];
    PROPSHEETHEADER psh;
    OUR_INFO *our_params;
    INT stat;
    static TCHAR devpropstr[40];

    our_params = glob_info;  // temporary kludge, unless we don't need re-entrantancy 

    //Fill out the PROPSHEETPAGE data structure for the Client Area Shape
    //sheet
    FillDevicePropSheets(&psp[0], (LPARAM)our_params);

    //Fill out the PROPSHEETHEADER
    memset(&psh, 0, sizeof(PROPSHEETHEADER));

    psh.dwSize = sizeof(PROPSHEETHEADER);
    //psh.dwFlags = PSH_USEICONID | PSH_PROPSHEETPAGE;
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = glob_hinst;
    psh.pszIcon = "";
    load_str( glob_hinst, (TITLESTR+9), devpropstr, CharSizeOf(devpropstr) );
    psh.pszCaption = devpropstr;
    psh.nPages = num_active_devprop_sheets;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;
#ifdef S_VS
    if (!dstatus_initialized)
    {
      dstatus_initialized = 1;
      memset(&glob_dstatus, 0, sizeof(glob_dstatus));
      //establish a base point for packet stats...
      get_status(&glob_dstatus,0);
    }
#endif
    //And finally display the dialog with the property sheets.

    stat = PropertySheet(&psh);
  return 0;
}

/*----------------------------------------------------------
 DevicePropSheet - Dlg window procedure for add on Advanced sheet.
|-------------------------------------------------------------*/
BOOL WINAPI DevicePropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
  OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);
  //UINT stat;
  WORD uCmd;
  HWND hwnd;

  switch(uMessage)
  {

    case WM_INITDIALOG :
        OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
        // save in case of cancel
        //memcpy(&org_dev, &wi->dev[glob_info->device_selected], sizeof(org_dev));

        set_field(hDlg, IDC_EB_NAME);
#ifdef S_VS
        set_field(hDlg, IDC_CBOX_NUMPORTS);
#endif
        set_field(hDlg, IDC_CBOX_SC);
#ifdef S_VS
        set_field(hDlg, IDC_CBOX_MACADDR);
        set_field(hDlg, IDC_BACKUP_SERVER);
        set_field(hDlg, IDC_BACKUP_TIMER);
#else
#if (defined(NT50) && defined(S_RK))
  // if nt50 and rocketport then get rid of io-address field as
  // nt takes care of io-allocation for us.
        ShowWindow(GetDlgItem(hDlg, IDC_CBOX_IOADDR), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDL_ISA_BUS_LABEL), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDL_BASE_ADDR_LABEL), SW_HIDE);
#endif

        set_field(hDlg, IDC_CBOX_IOADDR);
        set_field(hDlg, IDC_LBL_SUMMARY1);
        set_field(hDlg, IDC_LBL_SUMMARY2);
#endif
    return TRUE;  // No need for us to set the focus.

    case WM_COMMAND:
      uCmd = HIWORD(wParam);

      switch (LOWORD(wParam))
      {
        case IDC_BACKUP_SERVER:
          //--- enable or disable backup-timer field depending on backup server[]
          hwnd = GetDlgItem(hDlg, IDC_BACKUP_TIMER);
          if (IsDlgButtonChecked(hDlg, IDC_BACKUP_SERVER))
            EnableWindow(hwnd,1);
          else EnableWindow(hwnd,0);
        break;

#ifdef S_RK
#if (!defined(NT50))
        case IDC_CBOX_IOADDR:
          if (uCmd == CBN_SELCHANGE)
          {
            get_field(hDlg, IDC_CBOX_IOADDR);

            PaintRockers(hDlg, glob_info->device_selected);
          }
        break;
#endif
#endif
      }
    return FALSE;

    case WM_PAINT:
      PaintIcon(hDlg);
#ifdef S_RK
      PaintLogo(GetDlgItem(hDlg, IDC_RKT_LOGO));
#else
      PaintLogo(GetDlgItem(hDlg, IDC_VS_LOGO));
#endif
#ifdef S_RK
#if (!defined(NT50))
      PaintRockers(hDlg, glob_info->device_selected);
#endif
#endif
    return FALSE;

    case WM_HELP:
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_HELP :
#ifdef S_VS
          our_help(&wi->ip, IDD_VS_DEVICE_SETUP);
#else
          our_help(&wi->ip, IDD_DEVICE_SETUP);
#endif
        break;

        case PSN_APPLY :
          get_field(hDlg, IDC_EB_NAME);
          get_field(hDlg, IDC_CBOX_SC);
#ifdef S_VS
          get_field(hDlg, IDC_CBOX_NUMPORTS);
          get_field(hDlg, IDC_CBOX_MACADDR);
          get_field(hDlg, IDC_BACKUP_SERVER);
          get_field(hDlg, IDC_BACKUP_TIMER);
#else
          get_field(hDlg, IDC_CBOX_IOADDR);
#endif
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return TRUE;

        default :
          return FALSE;
      }
    break;

    default :
    //  return FALSE;
	  break;
  }
  return FALSE;
}

/*----------------------------------------------------------
 set_field -
|------------------------------------------------------------*/
static void set_field(HWND hDlg, WORD id)
{
  HWND hwnd;
  char tmpstr[60];
  Device_Config *dev;
  int i;

  dev = &wi->dev[glob_info->device_selected];

  switch(id)
  {
    case IDC_EB_NAME:
      SetDlgItemText(hDlg, id, dev->Name);
    break;

    case IDC_LBL_SUMMARY1:
      wsprintf(tmpstr, "%s - %d  ",
               dev->ModelName,
               dev->NumPorts);
      if (dev->IoAddress == 1)
        strcat(tmpstr, "PCI");
      else
        strcat(tmpstr, "ISA");
      SetDlgItemText(hDlg, id, tmpstr);
    break;

    case IDC_LBL_SUMMARY2:
      strcpy(tmpstr,"");

      if (dev->ModemDevice == TYPE_RM_VS2000) {

        for (
        i = 0; 
        i < NUM_ROW_COUNTRIES; 
        i++
        ) {
          if (wi->ModemCountry == RowInfo[i].RowCountryCode)  
            break;
        }
        wsprintf(
          tmpstr, 
          "Configured for: %s",
          (i == NUM_ROW_COUNTRIES) ? RowInfo[0].RowCountryName : RowInfo[i].RowCountryName);
      }
      else if (dev->ModemDevice == TYPE_RM_i) {

        strcpy(tmpstr,CTRRowInfo[0].RowCountryName);  // default 

        for (
        i = 0; 
        i < NUM_CTR_ROW_COUNTRIES; 
        i++
        ) {
          if (wi->ModemCountry == CTRRowInfo[i].RowCountryCode)  
            break;
        }
        wsprintf(
          tmpstr, 
          "Configured for: %s",
          (i == NUM_CTR_ROW_COUNTRIES) ? CTRRowInfo[0].RowCountryName : CTRRowInfo[i].RowCountryName);
      }
      else if (dev->ModemDevice) {

        wsprintf(
          tmpstr, 
          "Configured for: %s",
          RowInfo[0].RowCountryName);
      }

      SetDlgItemText(hDlg, id, tmpstr);
    break;

#ifdef S_VS
    case IDC_CBOX_NUMPORTS:
      hwnd = GetDlgItem(hDlg, id);
      if (dev->ModemDevice)
      {
DbgPrintf(D_Test, ("vs2000 fill\n"))
        // VS2000 only available in 8 port configuration
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP8);
      }
      else if (dev->HubDevice)
      {
DbgPrintf(D_Test, ("hubdev fill\n"))
        // SerialHub available in 4 (not yet) and 8 port configuration
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP4);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP8);
        // default the number of ports for the Serial Hub to 8
      }
      else
      {
DbgPrintf(D_Test, ("vs fill\n"))
        // we must have a VS1000 or VS1000/VS1100 combo
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP16);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP32);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP48);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szNP64);
      }
      wsprintf(tmpstr, "%d", dev->NumPorts);
      SendMessage(hwnd, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(char far *) tmpstr);
    break;
#endif

#ifdef S_VS
    case IDC_CBOX_MACADDR:
      set_mac_field(hDlg, id);
    break;
#endif

    case IDC_CBOX_SC:
      //---------------------- setup starting com port

      hwnd = GetDlgItem(hDlg, IDC_CBOX_SC);
      {
        int foundName = 0;
        int pi = 0;
        SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
        for (i=1; i<1024; i++)
        {
          wsprintf(tmpstr,"COM%d", i);
          if ((!IsPortNameInSetupUse(tmpstr)) &&  // not ours already
              (IsPortNameInRegUse(tmpstr) == 1))  // not ours in registry
          {
            // someone elses name, don't put in our list
          }
          else
          {
            SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM) tmpstr);

            if ((foundName == 0) &&(_tcsicmp(tmpstr, dev->ports[0].Name) == 0))
            {
               foundName = pi;
            }
            ++pi;
          }
        }
        SendMessage(hwnd, CB_SETCURSEL, foundName, (LPARAM)0);

        // this was setting "COM300" from list instead of "COM3" for some reason
        // under NT2000, So go back to index way.   kpb, 5-26-99
        //SendMessage(hwnd, CB_SELECTSTRING, 0, (LPARAM)dev->ports[0].Name);
      }

    break;

    case IDC_BACKUP_SERVER:
      //------------------ fill in "BackupServer" option
      SendDlgItemMessage(hDlg, IDC_BACKUP_SERVER, BM_SETCHECK, dev->BackupServer, 0);
       //--- enable or disable backup-timer field depending on backup server[]
      hwnd = GetDlgItem(hDlg, IDC_BACKUP_TIMER);
      if (IsDlgButtonChecked(hDlg, IDC_BACKUP_SERVER))
        EnableWindow(hwnd,1);
      else EnableWindow(hwnd,0);
    break;

    case IDC_BACKUP_TIMER:
      //------------------ fill in backup timer selection
      hwnd = GetDlgItem(hDlg, IDC_BACKUP_TIMER);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "2 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "5 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "10 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "30 min");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "60 min");

      if (dev->BackupTimer < 2) dev->BackupTimer = 2; // 2 minute, no less

      wsprintf(tmpstr, "%d min", dev->BackupTimer);
      SetDlgItemText(hDlg, IDC_BACKUP_TIMER, tmpstr);
    break;

    case IDC_CBOX_IOADDR:
      set_io_addr_field(hDlg, id);
    break;
  }
}

/*-------------------------------------------------------------------
| get_field -
|--------------------------------------------------------------------*/
static void get_field(HWND hDlg, WORD id)
{
  char tmpstr[60];
  Device_Config *dev;
  int stat, i, chk;
  int val;

  dev = &wi->dev[glob_info->device_selected];

  switch (id)
  {
    case IDC_EB_NAME:
      GetDlgItemText(hDlg, IDC_EB_NAME, dev->Name, 59);
    break;

#ifdef S_VS
    case IDC_CBOX_NUMPORTS:
    {
      int bad = 0;
      GetDlgItemText(hDlg, id, tmpstr, 19);
      stat= sscanf(tmpstr,"%ld",&val);

      if ((stat == 1) && (val >= 0))
      {
        if (val == 4)
          dev->NumPorts = (int) val;
        else if (val == 8)
          dev->NumPorts = (int) val;
        else if (val == 16)
          dev->NumPorts = (int) val;
        else if (val == 32)
          dev->NumPorts = (int) val;
        else if (val == 48)
          dev->NumPorts = (int) val;
        else if (val == 64)
          dev->NumPorts = (int) val;
        else
         bad = 1;
      }
      else
      {
        bad = 1;
        dev->NumPorts = 16;
      }

      if (bad)
      {
        our_message(&wi->ip,RcStr(MSGSTR),MB_OK);
        //ret_stat = 1;
      }
    }
    break;
#endif

#ifdef S_VS
    case IDC_CBOX_MACADDR:
      get_mac_field(hDlg, id, dev->MacAddr);
    break;
#endif

    case IDC_CBOX_SC:
      GetDlgItemText(hDlg, id, tmpstr, 58);
      if (_tcsicmp(tmpstr, dev->ports[0].Name) != 0) //changed
      {
        //StartComIndex = getint(&tmpstr[3], &i);  // COM# num
        for (i=0; i<dev->NumPorts; i++)
        {
          strcpy(dev->ports[i].Name, tmpstr);  // put in new name
          BumpPortName(tmpstr);

          // if its not our name already
          if (!IsPortNameInSetupUse(tmpstr))
          {
            chk = 0;
            // keep picking new name if this name is already
            // owned based on the names exported in the registry.
            while ((IsPortNameInRegUse(tmpstr) == 1) && (chk < 1024))
            {
              BumpPortName(tmpstr);
              ++chk;
            }
          }
        }
      }
    break;

    case IDC_BACKUP_SERVER:
      //------------------ get the backup server chk box.
      if (IsDlgButtonChecked(hDlg, IDC_BACKUP_SERVER))
           dev->BackupServer = 1;
      else dev->BackupServer = 0;

    break;

    case IDC_BACKUP_TIMER:
      //------------------ get the backup timer value
      //bad = 0;
      GetDlgItemText(hDlg, id, tmpstr, 19);
      stat= sscanf(tmpstr,"%ld",&val);
      if (stat == 1)
        dev->BackupTimer = val;

      if (dev->BackupTimer < 2)
        dev->BackupTimer = 2;
    break;

    case IDC_CBOX_IOADDR:
      //------------------ get the io-address
      GetDlgItemText(hDlg, IDC_CBOX_IOADDR, tmpstr, 19);
      if (tmpstr[0] == 'N')       // Not Available (PCI)
        dev->IoAddress = 1;
      else
      {
        stat= sscanf(tmpstr,"%lx",&val);
    
        if ((stat == 1) && (val >= 2))
        {
          dev->IoAddress = val;
        }
      }
    break;
  }
}

/*----------------------------------------------------------
 set_io_addr_field -
|------------------------------------------------------------*/
static int set_io_addr_field(HWND hDlg, WORD id)
{
  int io_pick, i, v;
  WORD lo;
  BOOL is_avail;
  static WORD hex_addresses[] = {0x100, 0x140, 0x180, 0x1c0,
                                 0x200, 0x240, 0x280, 0x2c0,
                                 0x300, 0x340, 0x380, 0x3c0, 0};
  HWND hwnd;
  char tmpstr[60];
  Device_Config *dev;

  dev = &wi->dev[glob_info->device_selected];


  //------------------ fill io-address
  hwnd = GetDlgItem(hDlg, IDC_CBOX_IOADDR);
  SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
  io_pick = 0;

  if (dev->IoAddress == 1)  // pci
  {
    io_pick = 1;

    strcpy(tmpstr, "N/A");
    SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM) tmpstr);
    SendMessage(hwnd, CB_SELECTSTRING, (WPARAM) -1, (LPARAM)(char far *) tmpstr);
  }
  else
  {
    for (i=0; hex_addresses[i] != 0; i++)
    {
      lo = hex_addresses[i];
      if (dev->IoAddress == lo)
      {
        io_pick = i;
      }

      // decide whether the current address is already in use or is available
      is_avail = TRUE;    // assume true unless we find otherwise
      for (v = 0; v < wi->NumDevices; v++)
      {
        if ((wi->dev[v].IoAddress == lo) &&
            (v != glob_info->device_selected))
        {
          is_avail = FALSE;
          break;
        }
      }

      if (is_avail)
      {
        wsprintf(tmpstr,"%x Hex",lo);
        if (lo == 0x180)
          strcat(tmpstr," Default");
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM) tmpstr);

        // if this was the user's choice from the wizard, highlight it
        if (lo == dev->IoAddress)
          SendMessage(hwnd, CB_SELECTSTRING, (WPARAM) -1, (LPARAM)(char far *) tmpstr);
      }
    }
  }

  // control whether the io base address combo box is enabled or disabled
  if (wi->dev[glob_info->device_selected].IoAddress == 1)
    EnableWindow(hwnd, 0);
  else
    EnableWindow(hwnd, 1);

  return 0;
}

#ifdef S_VS
/*----------------------------------------------------------
 set_mac_field -
|------------------------------------------------------------*/
static int set_mac_field(HWND hDlg, WORD id)
{
  HWND hwnd;
  char tmpstr[60];
  Device_Config *dev;
  int i;
  int addr_used, nbytes;
  BYTE *macbuf;
  BYTE *mac;

  dev = &wi->dev[glob_info->device_selected];

  //------------------ fill in mac addr selection
  hwnd = GetDlgItem(hDlg, id);
  SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

    // ping the devices to get mac list to display, also collect
    // info for device advisor
  macbuf = ping_devices(&glob_dstatus, &nbytes);
  if ((macbuf != NULL) && (nbytes != 0))
  {
    for (i=0; i<nbytes/8; i++)
    {
      mac = &macbuf[i*8];
      format_mac_addr(tmpstr, mac);

      if (mac[6] & FLAG_APPL_RUNNING)
      {
        if (mac[6] & FLAG_NOT_OWNER)
        {
          strcat(tmpstr, " (used)");
        }
        else
        {
          if (!mac_match(mac, dev->MacAddr))
          {
            // why are devices saying we are owner when our server is
            // not configured for them??? this must be a bug in box?
            strcat(tmpstr, " (Used)"); 
          }
          else strcat(tmpstr, " (ours)");
        }
      }
      else
      {
        // just leave it blank
        // strcat(tmpstr, " (free)");
      }
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) tmpstr);
    }

  }
  
  addr_used = 1;
  
  if ( (mac_match(dev->MacAddr, broadcast_addr)) ||
       (mac_match(dev->MacAddr, mac_zero_addr)) )
    addr_used = 0;
  
  if (addr_used)
  {
    mac = &dev->MacAddr[0];
    format_mac_addr(tmpstr, mac);
  }
  else
  {
    memset(dev->MacAddr, 0, 6);
    strcpy(tmpstr, "00 C0 4E # # #");
  }
  // set the text in the window
  SetDlgItemText(hDlg, IDC_CBOX_MACADDR, tmpstr);
  SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "00 C0 4E # # #");

  DbgPrintf(D_Level,(TEXT("END set_macfield\n")));

  return 0;
}

/*----------------------------------------------------------
 get_mac_field -
|------------------------------------------------------------*/
int get_mac_field(HWND hDlg, WORD id, BYTE *MacAddr)
{
 int mac_nums[6];
 int stat,i;
 char tmpstr[64];
 Device_Config *dev;
 int bad;
 int ret_stat = 0;

 if (glob_info->device_selected >= wi->NumDevices)
     glob_info->device_selected = 0;
 dev = &wi->dev[glob_info->device_selected];

 bad = 0;
  GetDlgItemText(hDlg, id, tmpstr, 20);
  {
    stat = sscanf(tmpstr, "%x %x %x %x %x %x",
              &mac_nums[0], &mac_nums[1], &mac_nums[2],
              &mac_nums[3], &mac_nums[4], &mac_nums[5]);
    if (stat == 6)
    {
      for (i=0; i<6; i++)
      {
        if (mac_nums[0] > 0xff)
          bad = 1;
      }
      if (!bad)
      {
        MacAddr[0] = mac_nums[0];
        MacAddr[1] = mac_nums[1];
        MacAddr[2] = mac_nums[2];
        MacAddr[3] = mac_nums[3];
        MacAddr[4] = mac_nums[4];
        MacAddr[5] = mac_nums[5];
        if (mac_match(broadcast_addr, dev->MacAddr))
        {
          memset(dev->MacAddr,0,6);  // all zeros = auto
        }
      }
      else
        bad = 1;
    }
    else
      bad = 1;
  }  // not autodetect

  if (bad)
  {
    our_message(&wi->ip,RcStr((MSGSTR+1)),MB_OK);
    memset(MacAddr,0,6);  // all zeros = auto
    ret_stat = 1;
  }
  return ret_stat;
}
#endif

#ifdef S_RK
/*---------------------------------------------------------------------------
  PaintRockers - Paints the Rocker Switches
|---------------------------------------------------------------------------*/
static int PaintRockers(HWND hWnd, int brd)
{
  HDC hDC;
  //POINT2D pts[18];
  //POINT2D epts[6];
  //HBRUSH hbrush;
  RECT rect;
  int x,y,cx,cy, sw_i, top;
  int sw_size = 8;
  int sw_space = 2;
  //int num_hi = 2;
  int but_in;
  int sw_on[8];
  int i;
  //static HPEN hpens = NULL;
  //static HPEN hpenh = NULL;
  //static HBRUSH hbrushf = NULL;
  int base_x = 300;
  int base_y = 120;
  char tmpstr[40];

  int x_cell_size;
  int y_cell_size;
  int brd_index;
  int io_address;

  RECT spot, main;  // left, top, right, bottom

  i = glob_info->device_selected;
  if (wi->dev[i].IoAddress < 0x100)  // not isa board
    return 1;  // err, no switches

  // figure out the rocker address
  brd_index = 0;
  io_address = 0;
  for (i=0; i<wi->NumDevices; i++)
  {
    if (wi->dev[i].IoAddress >= 0x100)  // isa board
    {
      if (brd_index == 0)
      {
        io_address = wi->dev[i].IoAddress;
      }
      if (i == glob_info->device_selected)
        break;
      ++brd_index;
    }
  }
  io_address += (brd_index * 0x400);  // example: 180H, 580H, ..

  hDC = GetDC(hWnd);

  // position to the left of the io-address field
  GetWindowRect(GetDlgItem(hWnd, IDC_CBOX_IOADDR), &spot);
  GetWindowRect(hWnd, &main);
  spot.right -= main.left;
  spot.top -= main.top;
  base_x = spot.right + 25;
  base_y = spot.top;

  x_cell_size = sw_size + sw_space;
  y_cell_size = sw_size + sw_space;

  // calculate which switch is on.
  io_address += 0x40;  // go from 180 to 1c0(rockers set mudbac address)
  io_address >>= 6;  // kill 40H worth(rocker sw1 starts at 40h)
  for (i=0; i<8; i++)
  {
    if (io_address & 1)
         sw_on[i] = 0;
    else sw_on[i] = 1;
    io_address >>= 1;  // to next bit
  }

  // erase background and draw border of rockers
  x = base_x - (sw_space*3);
  y = base_y - ((sw_size + sw_space) * 2);
  cx = ((sw_size + sw_space) * 9);
  cy = ((sw_size + sw_space) * 6);
  draw_but(hDC, x,y,cx,cy, 2);

  // draw the rockers
  // top and left border, poly_border will calculate line endpts to draw
  SelectObject(hDC, GetStockObject(NULL_BRUSH));
  for (sw_i = 0; sw_i < 8; ++sw_i)  // rocker switches
  {
    for (top = 0; top < 2; ++top)  // top = 1 if at top of rocker
    {
    if (top)
    {
      // draw the switch(as a popped up button)
      but_in = 0;
      y = base_y;
      if (!sw_on[sw_i])
        y += ((sw_size + sw_space));
      cx = sw_size;
      cy = sw_size;
    }
    else
    {
      // draw the slot(as a pushed in button hole)
      but_in = 1;
      x = base_x + ((sw_size + sw_space) * sw_i);
      y = base_y + ((sw_size + sw_space) * top);
      cx = sw_size;
      cy = (sw_size * 2) + sw_space;
    }

    draw_but(hDC, x,y,cx,cy, but_in);

  }  // top

  // draw the rocker switch number
  rect.left = x;
  rect.right = x + 6;
  rect.top = base_y + ((sw_size + sw_space) * 2);
  rect.bottom = rect.top + 14;
  SetBkMode(hDC,TRANSPARENT);
  SetTextColor(hDC,GetSysColor(COLOR_BTNTEXT));
  wsprintf(tmpstr, "%d", sw_i+1);
  DrawText(hDC, tmpstr, strlen(tmpstr), &rect,
           DT_CENTER | DT_VCENTER | DT_WORDBREAK);
  }  // sw_i

  // draw the "ON"
  rect.left = base_x;
  rect.right = base_x + 18;
  rect.top = base_y - (sw_size + sw_space) - 6;
  rect.bottom = rect.top + 14;
  SetBkMode(hDC,TRANSPARENT);
  SetTextColor(hDC,GetSysColor(COLOR_BTNTEXT));
  DrawText(hDC, "ON", 2, &rect,
           DT_CENTER | DT_VCENTER | DT_WORDBREAK);

  ReleaseDC(hWnd, hDC);

  return 0;
}

/*----------------------------------------------------------
 draw_but - draw a button
|------------------------------------------------------------*/
static void draw_but(HDC hDC, int x, int y, int cx, int cy, int but_in)
{
  static HPEN hpens = NULL;
  static HPEN hpenh = NULL;
  static HBRUSH hbrushf = NULL;
  POINT2D pts[18];
  POINT2D epts[6];
  int num_hi = 2;  // number of highlight lines.

  epts[0].x = x;
  epts[0].y = y+cy;
  epts[1].x = x;
  epts[1].y = y;
  epts[2].x = x+cx;
  epts[2].y = y;
  epts[3].x = x+cx;
  epts[3].y = y+cy;

  // setup some pens to use
  if (hpens == NULL)
  {
    hpens = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNSHADOW));
    hpenh = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNHILIGHT));
    hbrushf = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
  }

  if (but_in & 2) // fill background, black outline(special kludge case)
  {
    SelectObject(hDC, hbrushf);
    SelectObject(hDC, GetStockObject(BLACK_PEN));
    Polyline(hDC, (POINT *)&epts[0], 4);
    but_in &= 1;
  }
  SelectObject(hDC, GetStockObject(NULL_BRUSH));

  poly_border(pts, epts, num_hi);  // calculate endpts
    if (but_in)
       SelectObject(hDC, GetStockObject(BLACK_PEN)); // pushed in look
  else SelectObject(hDC, GetStockObject(WHITE_PEN));
  Polyline(hDC, (POINT *)&pts[0], num_hi*3);

  if (num_hi > 1)
  {    // draw the middle shade inbetween hilite lines
    if (but_in)
         SelectObject(hDC, hpens); // pushed in look, shadow on top
    else SelectObject(hDC, hpenh); // hilite on top
    Polyline(hDC, (POINT *)&pts[num_hi*3-3], 3);
  }

  // bottom and right border
  SelectObject(hDC, GetStockObject(NULL_BRUSH));
  epts[1].x = x+cx;
  epts[1].y = y+cy;

  poly_border(pts, epts, num_hi);  // calc bottom line endpts
  if (but_in)
       SelectObject(hDC, GetStockObject(WHITE_PEN));  // pushed out look
  else SelectObject(hDC, GetStockObject(BLACK_PEN));
  Polyline(hDC, (POINT *)&pts[0], num_hi*3);

  if (num_hi > 1)
  {
    if (but_in)
         SelectObject(hDC, hpenh); // pushed out look
    else SelectObject(hDC, hpens);
    Polyline(hDC, (POINT *)&pts[num_hi*3-3], 3);
  }
}

/*----------------------------------------------------------
 poly_border - fill in pnts to shadow or highlight a button
   using one polyline call.
    ends[] - ctrl pnts, 3 for box(top & left) or (bottom & right)
|------------------------------------------------------------*/
static int poly_border(POINT2D *pts, POINT2D *ends, int lines)
{
  int li;
  int pi,j;
  static POINT2D top[3] = {{1,-1}, {1,1}, {-1,1}};
  static POINT2D bot[3] = {{1,-1}, {-1,-1}, {-1,1}};
  POINT2D *adj;

  if (ends[1].x == ends[0].x)
       adj = top;
  else adj = bot;

  pi = 0;
  li = 0;
  while (li < lines)
  {
    for (j=0; j<3; j++)
    {
      pts[pi].x = ends[j].x + (li * adj[j].x);
      pts[pi].y = ends[j].y + (li * adj[j].y);
      ++pi;
    }
    if ((lines & 1) == 0)  // odd
    {
      ++li;
      for (j=2; j>=0; j--)
      {
        pts[pi].x = ends[j].x + (li * adj[j].x);
        pts[pi].y = ends[j].y + (li * adj[j].y);
        ++pi;
      }
    }
    ++li;
  }
  return pi;
}
#endif

/*---------------------------------------------------------------------------
  PaintIcon - Paints the Icon in the property sheet.
|---------------------------------------------------------------------------*/
static int PaintIcon(HWND hWnd)
{
//   int status;
   HBITMAP      hBitMap;
   HGDIOBJ      hGdiObj;
   HDC          hDC, hMemDC ;
   PAINTSTRUCT  ps ;
   RECT spot, main;  // left, top, right, bottom

  GetWindowRect(GetDlgItem(hWnd, IDB_HELP), &spot);
  GetWindowRect(hWnd, &main);
#ifdef COMMENT_OUT
  rect = &right;
  mess("hlp r:%d l:%d b:%d t:%d",
       rect->right, rect->left, rect->bottom, rect->top);
#endif
  spot.left -= main.left;
  spot.top -= main.top;

  spot.left += 5;
  spot.top  += 20; // spacing

   // load bitmap and display it

   hDC = BeginPaint( hWnd, &ps ) ;
   if (NULL != (hMemDC = CreateCompatibleDC( hDC )))
   {
      hBitMap = LoadBitmap(glob_hinst,
                           MAKEINTRESOURCE(BMP_SMALL_LOGO));

      hGdiObj = SelectObject(hMemDC, hBitMap);

      BitBlt( hDC, spot.left, spot.top, 100, 100, hMemDC, 0, 0, SRCCOPY ) ;
      //StretchBlt( hDC, 5, 5, 600,100, hMemDC, 0, 0, 446, 85, SRCCOPY ) ;
      DeleteObject( SelectObject( hMemDC, hGdiObj ) ) ;
      DeleteDC( hMemDC ) ;
   }
   EndPaint( hWnd, &ps ) ;
 return 0;
}

/*---------------------------------------------------------------------------
  PaintLogo - Paints the logo bitmap in the device property sheet
|---------------------------------------------------------------------------*/
static int PaintLogo(HWND hWnd)
{
   HBITMAP      hBitMap;
   HGDIOBJ      hGdiObj;
   HDC          hDC, hMemDC;
   PAINTSTRUCT  ps;
   BITMAP       bm;
   RECT         r;
   POINT        pt;

   // load bitmap and display it
   hDC = BeginPaint( hWnd, &ps ) ;
   GetClientRect(hWnd, &r);
   if (NULL != (hMemDC = CreateCompatibleDC( hDC )))
   {
#ifdef S_RK
      if (wi->dev[glob_info->device_selected].ModemDevice == TYPE_RM_VS2000)
        hBitMap = LoadBitmap(glob_hinst, MAKEINTRESOURCE(BMP_RKTMODEM_LOGO));
      else if (wi->dev[glob_info->device_selected].ModemDevice == TYPE_RMII)
        hBitMap = LoadBitmap(glob_hinst, MAKEINTRESOURCE(BMP_RKTMODEMII_LOGO));
      else if (wi->dev[glob_info->device_selected].ModemDevice == TYPE_RM_i)
        hBitMap = LoadBitmap(glob_hinst, MAKEINTRESOURCE(BMP_RKTMODEM_INTL_LOGO));
      else
        hBitMap = LoadBitmap(glob_hinst, MAKEINTRESOURCE(BMP_RKTPORT_LOGO));
#else
      if (wi->dev[glob_info->device_selected].HubDevice == 1)
        hBitMap = LoadBitmap(glob_hinst, MAKEINTRESOURCE(BMP_RKTHUB_LOGO));
      else
        hBitMap = LoadBitmap(glob_hinst, MAKEINTRESOURCE(BMP_VS_FULL_LOGO));
#endif

      hGdiObj = SelectObject(hMemDC, hBitMap);
      GetObject(hBitMap, sizeof(BITMAP), (PSTR) &bm);
      pt.x = r.right - r.left + 1;
      pt.y = r.bottom - r.top + 1;
      StretchBlt( hDC, 0, 0, pt.x, pt.y, hMemDC, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY );
      DeleteObject( SelectObject( hMemDC, hGdiObj ) ) ;
      DeleteDC( hMemDC ) ;
   }
   EndPaint( hWnd, &ps ) ;
 return 0;
}

#ifdef S_VS
/*------------------------------------------------------------------------
 StatusPropSheet -
  dialogue window procedure for add-on device status sheet...
|------------------------------------------------------------------------*/
BOOL WINAPI 
StatusPropSheet(
  IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
  OUR_INFO *OurProps;
  WORD  uCmd;
  
  OurProps = (OUR_INFO *)GetWindowLong(hDlg,DWL_USER);

  switch (uMessage) {

    case WM_INITDIALOG: {

      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;

      SetWindowLong(hDlg,DWL_USER,(LONG)OurProps);

      return TRUE;
    }
    case WM_COMMAND: {
      uCmd = HIWORD(wParam);

      switch (LOWORD(wParam)) {

        //check for reset button pushed...
        case IDB_STAT_RESET: { 
            
          build_advisor_display(hDlg,&glob_dstatus,1);

          return(TRUE);
        }

        //check for refresh button pushed...
        case IDB_REFRESH: { 

          build_advisor_display(hDlg,&glob_dstatus,0);

          return(TRUE);
        }
      }
      return FALSE;
    } 
    case WM_PAINT: {

      PaintIcon(hDlg);

      return FALSE;
    }
    case WM_HELP: {

      our_context_help(lParam);

      return FALSE;
    }
    case WM_NOTIFY : {

      switch (((NMHDR *)lParam)->code){
        case PSN_HELP : {
          our_help(&wi->ip, IDD_STATUS);
          break;
        }

        case PSN_SETACTIVE : {
          build_advisor_display(hDlg,&glob_dstatus,0);
          return TRUE;
        }
        default : {
          return FALSE;
        }
      }
      break;
    }
    default : {
      return FALSE;
    }
  }
}

/*------------------------------------------------------------------------
  build_advisor_display -
|------------------------------------------------------------------------*/
static void build_advisor_display(HWND hDlg,DSTATUS *pDstatus,int reset)
{
  int nBytes;
  int do_ping;

  get_status(pDstatus,reset);

  if ((pDstatus->vsl_device_status_found) &&
      (pDstatus->calc_dev.state == VSL_STATE_ACTIVE))
  {
    // no need for ping, since our driver is not configured for
    // the mac address we think it is, or our driver says it is
    // running like a champ.
    do_ping = 0;
  }
  else
  {
    // the device is inactive, so do ping, see if we can see it on
    // network.
    do_ping = 1;
  }

  if (do_ping)
  {
    // ping returns -1 if bad, 0 if MAC not found, 1 if found...
    ping_devices(pDstatus, &nBytes);
  }

  set_status_field(hDlg,IDC_ST_PM_LOADS,pDstatus);
  set_status_field(hDlg,IDC_ST_STATE,pDstatus);
  set_status_field(hDlg,IDC_ST_NIC_DVC_NAME,pDstatus);
  set_status_field(hDlg,IDC_ST_NIC_MAC,pDstatus);
  set_status_field(hDlg,IDC_ST_NIC_PKT_SENT,pDstatus);
  set_status_field(hDlg,IDC_ST_NIC_PKT_RCVD_OURS,pDstatus);
  set_status_field(hDlg,IDC_ST_NIC_PKT_RCVD_NOT_OURS,pDstatus);

  set_status_field(hDlg,IDC_ST_VSL_MAC,pDstatus);
  set_status_field(hDlg,IDC_ST_VSL_DETECTED,pDstatus);
  set_status_field(hDlg,IDC_ST_VSL_STATE,pDstatus);
  set_status_field(hDlg,IDC_ST_VSL_IFRAMES_SENT,pDstatus);
  set_status_field(hDlg,IDC_ST_VSL_IFRAMES_RCVD,pDstatus);
  set_status_field(hDlg,IDC_ST_VSL_IFRAMES_RESENT,pDstatus);
  set_status_field(hDlg,IDC_ST_VSL_IFRAMES_OUTOFSEQ,pDstatus);
}

/*------------------------------------------------------------------------
  set_status_field -
|------------------------------------------------------------------------*/
static void 
set_status_field(HWND hDlg,WORD id,DSTATUS *pDstatus)
{
  char  tmpstr[100];
  Device_Config *vs;
  unsigned int  total;
  PROBE_NIC_STRUCT *d_nic    = &pDstatus->calc_nic;
  PROBE_DEVICE_STRUCT *d_dev = &pDstatus->calc_dev;

  tmpstr[0] = 0;
  vs = &wi->dev[glob_info->device_selected];
  switch(id) {

    case IDC_EB_NAME:
      SetDlgItemText(hDlg,id,vs->Name);
    break;

    case IDC_ST_STATE:
      SetDlgItemText(
        hDlg,
        id,
        (LPCTSTR)(AdvisoryString[pDstatus->verbose_advise_state]));
    break;

    case IDC_ST_NIC_DVC_NAME:
      if (pDstatus->vsl_nic_status_found)  // 1=driver found nic status.
        strcpy(tmpstr,d_nic->NicName);
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_NIC_MAC:
      if (pDstatus->vsl_nic_status_found)  // 1=driver found nic status.
        format_mac_addr(tmpstr, d_nic->address);
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_VSL_MAC:
      format_mac_addr(tmpstr, vs->MacAddr);
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_VSL_DETECTED:
      if (pDstatus->vsl_mac_list_found)
      {
        wsprintf(tmpstr,
           "%d/%d",
           pDstatus->vsl_detected,
           pDstatus->vsl_available);
      }
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_VSL_STATE:
      if (pDstatus->vsl_device_status_found)  // 1=driver found matching VS config.
      {
        if (d_dev->state < 5)
          strcpy(tmpstr, vslink_state_table[d_dev->state]);
      }
      else
      {
        // indicate to the user that our mac-address has not been
        // saved off and transferred to the driver
        strcpy(tmpstr, "Not Configured");
      }

      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_VSL_IFRAMES_SENT:
      if (pDstatus->vsl_device_status_found)  // 1=driver found matching VS config.
      {
        //count = 0;
        total = d_dev->iframes_sent;
        total += d_dev->ctlframes_sent;
        wsprintf(tmpstr,"%d",total);
      }
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_VSL_IFRAMES_RESENT:
      if (pDstatus->vsl_device_status_found)  // 1=driver found matching VS config.
      {
        wsprintf(tmpstr,"%d",d_dev->iframes_resent);
      }
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_VSL_IFRAMES_RCVD:
      if (pDstatus->vsl_device_status_found)  // 1=driver found matching VS config.
      {
        wsprintf(tmpstr,"%d",d_dev->frames_rcvd);
      }
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_VSL_IFRAMES_OUTOFSEQ:
      if (pDstatus->vsl_device_status_found)  // 1=driver found matching VS config.
      {
        wsprintf(tmpstr,"%d",d_dev->iframes_outofseq);
      }
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_NIC_PKT_SENT:
      if (pDstatus->vsl_nic_status_found)  // 1=driver found nic status.
        wsprintf(tmpstr,"%d",d_nic->pkt_sent);
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_NIC_PKT_RCVD_OURS:
      if (pDstatus->vsl_nic_status_found)  // 1=driver found nic status.
        wsprintf(tmpstr,"%d",d_nic->pkt_rcvd_ours);
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_NIC_PKT_RCVD_NOT_OURS:
      if (pDstatus->vsl_nic_status_found)  // 1=driver found nic status.
        wsprintf(tmpstr,"%d",d_nic->pkt_rcvd_not_ours);
      SetDlgItemText(hDlg,id,tmpstr);
    break;

    case IDC_ST_PM_LOADS:
      tmpstr[0] = 0;
      if (pDstatus->vsl_device_status_found)  // 1=driver found matching VS config.
      {
        wsprintf(tmpstr, "%d/%d",
           d_dev->good_loads,
           d_dev->total_loads);
      }
      SetDlgItemText(hDlg,id,tmpstr);
    break;
  }  // end of switch
}  // end proc

#define  IOCTL_STAT_BUFSIZE  500
/*------------------------------------------------------------------------
  get_status - query the driver for device network statistics and
    associated nic card network statistics.  These stats are kept
    as overflow/wrapping DWORD counters in driver, we do some math
    on current and previous values read to determine calculated values.
|------------------------------------------------------------------------*/
static void get_status(DSTATUS *pDstatus,int reset)
{
  Device_Config *vs;
  PROBE_NIC_STRUCT    *curr_nic = &pDstatus->curr_nic;
  PROBE_NIC_STRUCT    *prev_nic = &pDstatus->prev_nic;
  PROBE_NIC_STRUCT    *calc_nic = &pDstatus->calc_nic;
  PROBE_NIC_STRUCT    *temp_nic = &pDstatus->temp_nic;

  PROBE_DEVICE_STRUCT *curr_dev = &pDstatus->curr_dev;
  PROBE_DEVICE_STRUCT *prev_dev = &pDstatus->prev_dev;
  PROBE_DEVICE_STRUCT *calc_dev = &pDstatus->calc_dev;
  PROBE_DEVICE_STRUCT *temp_dev = &pDstatus->temp_dev;
  int    rc;
  BYTE  *pIoctlStatusBuf,
      *pNicStatBuf;
  IoctlSetup  ioctl_setup;
  int    product_id;

DbgPrintf(D_Level,(TEXT("get_status\n")));

  product_id = NT_VS1000;
  vs = &wi->dev[glob_info->device_selected];

  STATE_CHANGE(STATE_not_init);

     //open path for ioctl to retrieve device status list. make sure path
     //exists first...
  memset(&ioctl_setup,0,sizeof(IoctlSetup));

  rc = ioctl_open(&ioctl_setup,product_id); 

  if (rc != 0)
  { 
    pDstatus->vsl_driver_found = 0;  // 1=we can talk to driver, 0=driver not loaded
    pDstatus->vsl_device_status_found = 0;  // 1=driver found matching VS config.
    pDstatus->vsl_nic_status_found = 0;  // 1=driver found nic status.
    DbgPrintf(D_Error,(TEXT("Err1A\n")));
    //error. could not talk to driver. bail...
    STATE_CHANGE(STATE_driver_not_avail);
    return;   
  }

  //alloc space for all NIC and VSlink status reports...
  pIoctlStatusBuf = calloc(1,IOCTL_STAT_BUFSIZE);
  memset(pIoctlStatusBuf,0,IOCTL_STAT_BUFSIZE);

  pNicStatBuf = &pIoctlStatusBuf[sizeof(PortMonBase)];

    // tell the driver which device we want to query by sending
    // the mac-address as the id.
  memcpy(pNicStatBuf,vs->MacAddr,sizeof(vs->MacAddr));

    //see if we need to signal driver to reset statistics...
    // no, don't reset the driver statistics!
  pNicStatBuf[sizeof(vs->MacAddr)] = 0;
    //pNicStatBuf[sizeof(vs->MacAddr)] = (reset) ? 1 : 0;

  //adjust size of status buffer down by length of ioctl control block...
  ioctl_setup.buf_size = IOCTL_STAT_BUFSIZE;

  //store --> to status buffer into ioctl control block...
  ioctl_setup.pm_base = (PortMonBase *) pIoctlStatusBuf;
  ioctl_setup.pm_base->struct_type = IOCTL_DEVICESTAT;
  ioctl_setup.pm_base->struct_size = IOCTL_STAT_BUFSIZE - sizeof(PortMonBase);
  ioctl_setup.pm_base->num_structs = 0;
  ioctl_setup.pm_base->var1 = 0;

    // update prev_dev to curr_dev before getting new values
  memcpy(prev_dev, curr_dev, sizeof(*prev_dev));

  rc = ioctl_call(&ioctl_setup);  // get device status

  if (rc) {
    pDstatus->vsl_device_status_found = 0;  // 1=driver found matching VS config.
    DbgPrintf(D_Test, ("probe, dev not found\n"))
    ioctl_close(&ioctl_setup);
    DbgPrintf(D_Error,(TEXT("Err1B\n")));
    memset(calc_nic, 0, sizeof(curr_nic));
    //STATE_CHANGE(STATE_driver_not_avail);
    STATE_CHANGE(STATE_not_configured);
    free(pIoctlStatusBuf);
    return;  // failed ioctl call
  }
  pDstatus->vsl_device_status_found = 1;  // 1=driver found matching VS config.
  DbgPrintf(D_Test, ("probe, dev found\n"))

    // copy over our new device info
  memcpy(curr_dev, pNicStatBuf, sizeof(*curr_dev));
  if (curr_dev->struct_size != sizeof(*curr_dev))
  {
    DbgPrintf(D_Level, (TEXT("dev bad size:%d\n"), curr_dev->struct_size));
  }

    // save calculated values temporarily in temp_dev
  memcpy(temp_dev, calc_dev, sizeof(*temp_dev));
    // update calc_dev from curr_dev, just copy over
  memcpy(calc_dev, curr_dev, sizeof(*calc_dev));

    // use a current and previous reading to measure the advance, or
    // calculated value which is put in calc value.
  NORM_COUNTER(calc_dev->iframes_sent, curr_dev->iframes_sent,
               prev_dev->iframes_sent, temp_dev->iframes_sent);
  NORM_COUNTER(calc_dev->ctlframes_sent, curr_dev->ctlframes_sent,
               prev_dev->ctlframes_sent, temp_dev->ctlframes_sent);
  NORM_COUNTER(calc_dev->rawframes_sent, curr_dev->rawframes_sent,
               prev_dev->rawframes_sent, temp_dev->rawframes_sent);
  NORM_COUNTER(calc_dev->iframes_resent, curr_dev->iframes_resent,
               prev_dev->iframes_resent, temp_dev->iframes_resent);
  NORM_COUNTER(calc_dev->frames_rcvd, curr_dev->frames_rcvd,
               prev_dev->frames_rcvd, temp_dev->frames_rcvd);
  NORM_COUNTER(calc_dev->iframes_outofseq, curr_dev->iframes_outofseq,
               prev_dev->iframes_outofseq, temp_dev->iframes_outofseq);

  DbgPrintf(D_Level, (TEXT("iframes_sent - ca:%d cu:%d pr:%d te:%d\n"),
                       calc_dev->iframes_sent, curr_dev->iframes_sent,
                       prev_dev->iframes_sent, temp_dev->iframes_sent));

  DbgPrintf(D_Level, (TEXT("iframes_sent - ca:%d cu:%d pr:%d te:%d\n"),
                   calc_dev->ctlframes_sent, curr_dev->ctlframes_sent,
                   prev_dev->ctlframes_sent, temp_dev->ctlframes_sent));

  DbgPrintf(D_Level, (TEXT("frames_rcvd - ca:%d cu:%d pr:%d te:%d\n"),
                   calc_dev->frames_rcvd, curr_dev->frames_rcvd,
                   prev_dev->frames_rcvd, temp_dev->frames_rcvd));

  if (curr_dev->nic_index != 0)
  {
    DbgPrintf(D_Level, (TEXT("nic index:%d\n"), curr_dev->nic_index));
  }

    // tell driver which nic card we want to probe info on
  *((BYTE *)pNicStatBuf) = (BYTE) curr_dev->nic_index;
  *((BYTE *)pNicStatBuf+1) = 0;
  ioctl_setup.pm_base->struct_type = IOCTL_NICSTAT;
  ioctl_setup.pm_base->struct_size = IOCTL_STAT_BUFSIZE - sizeof(PortMonBase);
  ioctl_setup.pm_base->num_structs = 0;

    // update prev_dev to curr_dev before calculation
  memcpy(prev_nic, curr_nic, sizeof(*prev_nic));

  rc = ioctl_call(&ioctl_setup);  // get NIC and board status...

  if (rc) {
    pDstatus->vsl_nic_status_found = 0;  // 1=driver found nic status.
    ioctl_close(&ioctl_setup);
    DbgPrintf(D_Error, (TEXT("nic not avail\n")));
    STATE_CHANGE(STATE_nic_not_avail);
    free(pIoctlStatusBuf);
    return;  // failed ioctl call
  }
  pDstatus->vsl_nic_status_found = 1;  // 1=driver found nic status.

    // copy over our new device info
  memcpy(curr_nic, pNicStatBuf, sizeof(*curr_nic));
  if (curr_nic->struct_size != sizeof(*curr_nic))
  {
    DbgPrintf(D_Error, (TEXT("nic bad size:%d\n"), curr_nic->struct_size));
  }

    // save calculated values temporarily in temp_nic
  memcpy(temp_nic, calc_nic, sizeof(*temp_nic));
    // update calc_nic from curr_dev
  memcpy(calc_nic, curr_nic, sizeof(*calc_nic));

    // use a current and previous reading to measure the advance, or
    // calculated value which is put in calc value.
  NORM_COUNTER(calc_nic->pkt_sent, curr_nic->pkt_sent,
               prev_nic->pkt_sent, temp_nic->pkt_sent);
  NORM_COUNTER(calc_nic->pkt_rcvd_ours, curr_nic->pkt_rcvd_ours,
               prev_nic->pkt_rcvd_ours, temp_nic->pkt_rcvd_ours);
  NORM_COUNTER(calc_nic->pkt_rcvd_not_ours, curr_nic->pkt_rcvd_not_ours,
               prev_nic->pkt_rcvd_not_ours, temp_nic->pkt_rcvd_not_ours);

  DbgPrintf(D_Level, (TEXT("pkt_sent - ca:%d cu:%d pr:%d te:%d\n"),
                 calc_nic->pkt_sent, curr_nic->pkt_sent,
                 prev_nic->pkt_sent, temp_nic->pkt_sent));
  DbgPrintf(D_Level, (TEXT("pkt_rcvd_ours - ca:%d cu:%d pr:%d te:%d\n"),
                 calc_nic->pkt_rcvd_ours, curr_nic->pkt_rcvd_ours,
                 prev_nic->pkt_rcvd_ours, temp_nic->pkt_rcvd_ours));
  DbgPrintf(D_Level, (TEXT("pkt_rcvd_not_ours - ca:%d cu:%d pr:%d te:%d\n"),
                 calc_nic->pkt_rcvd_not_ours, curr_nic->pkt_rcvd_not_ours,
                 prev_nic->pkt_rcvd_not_ours, temp_nic->pkt_rcvd_not_ours));

  if (reset) {
    DbgPrintf(D_Level, (TEXT("Reset NicStats\n")));
    calc_dev->iframes_sent = 0;
    calc_dev->ctlframes_sent = 0;
    calc_dev->rawframes_sent = 0;
    calc_dev->iframes_resent = 0;
    calc_dev->frames_rcvd = 0;
    calc_dev->iframes_outofseq = 0;

    calc_nic->pkt_sent = 0;
    calc_nic->pkt_rcvd_ours = 0;
    calc_nic->pkt_rcvd_not_ours = 0;

    ioctl_close(&ioctl_setup);
    STATE_CHANGE(STATE_reset);
    free(pIoctlStatusBuf);
    return;
  }

    //check state of NIC card...
  if (!pDstatus->curr_nic.Open)
  {
    ioctl_close(&ioctl_setup);
    DbgPrintf(D_Level, (TEXT("Nic Not Open\n")));
    memset(calc_nic, 0, sizeof(curr_nic));
    STATE_CHANGE(STATE_nic_not_avail);
    //STATE_CHANGE(STATE_network_not_avail);
    free(pIoctlStatusBuf);
    return;
  }

  switch (curr_dev->state)
  {
    case VSL_STATE_INIT:
      if (pDstatus->vsl_detected) // if some devices found in ping mac list
      {
        if (pDstatus->vsl_ping_device_found)  // if our mac found in pinged list
        {
          if ((pDstatus->vsl_load_status & FLAG_NOT_OWNER) == FLAG_NOT_OWNER) {
            STATE_CHANGE(STATE_not_owner);
          }
          else if ((pDstatus->vsl_load_status & FLAG_APPL_RUNNING) == 0) {
            STATE_CHANGE(STATE_vslink_not_ready);
          }
        }
        else  // not found in list
        {
          STATE_CHANGE(STATE_vslink_not_avail);
        }
      }
      else  // none found in ping
      {
        STATE_CHANGE(STATE_no_vslinks_avail);
      }
    break;

    case VSL_STATE_ACTIVE:
      STATE_CHANGE(STATE_ok_no_traffic);
      check_traffic_activity(pDstatus);
    break; // end of state_active

    case VSL_STATE_INITOWN: 
    case VSL_STATE_SENDCODE: 
    case VSL_STATE_CONNECT:
    default:
      STATE_CHANGE(STATE_vslink_not_ready);
    break;
  } // end of switch on state

  ioctl_close(&ioctl_setup);
  free(pIoctlStatusBuf);

  DbgPrintf(D_Level, (TEXT("get_status done\n")));
  return;
}

/*------------------------------------------------------------------------
  check_traffic_activity -
    check activity on NIC, network, & VS-Link device...
|------------------------------------------------------------------------*/
static void check_traffic_activity(DSTATUS *pDstatus)
{ 
   PROBE_NIC_STRUCT    *curr_nic = &pDstatus->curr_nic;
   PROBE_NIC_STRUCT    *prev_nic = &pDstatus->prev_nic;
   PROBE_NIC_STRUCT    *calc_nic = &pDstatus->calc_nic;
   PROBE_DEVICE_STRUCT *curr_dev = &pDstatus->curr_dev;
   PROBE_DEVICE_STRUCT *prev_dev = &pDstatus->prev_dev;
   PROBE_DEVICE_STRUCT *calc_dev = &pDstatus->calc_dev;

   ULONG percent_dropped;

   // don't divide by zero
   if ((curr_dev->iframes_outofseq + curr_dev->frames_rcvd) > 0)
     percent_dropped = ((curr_dev->iframes_outofseq * 100) / 
             (curr_dev->iframes_outofseq + curr_dev->frames_rcvd) > 2);
   else
     percent_dropped = 0;

  /*
  iframes_sent are hdlc protocol data packets;
  ctlframes_sent are hdlc protocol control packets;
  rawframes_sent are write remote, read trace query, go, and upload 
    binary command packets;
  iframes_resent are data packets retransmitted.
  iframes_outofseq are data packets received out of order.
  */

  DbgPrintf(D_Level, (TEXT("Check Traffic\n")));

  if ((curr_dev->iframes_sent + curr_dev->ctlframes_sent) ==
      (prev_dev->iframes_sent + prev_dev->ctlframes_sent)) { 
    // no sent packets to the higher levels in the VS-Link recently...
    STATE_CHANGE(STATE_ok_no_traffic);

    // no send traffic - see if we've any recent receive traffic for
    // delivery to higher levels...
    if (curr_dev->frames_rcvd == prev_dev->frames_rcvd)  
      STATE_CHANGE(STATE_ok_no_traffic);
  }
  else if (curr_dev->frames_rcvd == prev_dev->frames_rcvd) { 
    // we've recently received any VS-Link packets for delivery to higher levels...
    STATE_CHANGE(STATE_ok_no_traffic);
  }
  else {
    //connection appears ok so far. dig in deeper...
    STATE_CHANGE(STATE_ok);
  }

  DbgPrintf(D_Level, (TEXT("Check Traffic 2\n")));

  //evaluate link integrity. see if we're retransmitting packets to this
  //VS-Link...
  if (curr_dev->iframes_resent != prev_dev->iframes_resent) {
    STATE_CHANGE(STATE_poor_link);
  }
  else if ((curr_nic->pkt_rcvd_not_ours != prev_nic->pkt_rcvd_not_ours) &&
           (curr_nic->pkt_rcvd_ours == prev_nic->pkt_rcvd_ours)) {
    // all we're getting are packets that we're passing onto some 
    //other driver. we should be getting responses from the VS-Links...
    STATE_CHANGE(STATE_poor_link);
  }
  else if (curr_dev->iframes_outofseq != prev_dev->iframes_outofseq) { 
    // we've received VS-Link packets out-of-sequence since last click...
    STATE_CHANGE(STATE_poor_link);
  }
  else if ((curr_dev->iframes_outofseq) &&
           (percent_dropped > 0)) {
    // received 2% or more of VS-Link packets out-of-sequence (value per BF)...
    STATE_CHANGE(STATE_poor_link);
  }
  DbgPrintf(D_Level, (TEXT("Check Traffic Done\n")));
}

/*------------------------------------------------------------------------
 ping_devices -
  ping for all active VS-Link devices, collect info for device advisor.
  Return NULL or to list of mac-addresses.
|------------------------------------------------------------------------*/
static BYTE *ping_devices(DSTATUS *pDstatus, int *nBytes)
{
  Device_Config *vs;
  int    rc,
      nbytes;
  BYTE  *MacBuf;
  int    product_id;
  int    index;
  DRIVER_MAC_STATUS  *pMacStatus;

  product_id = NT_VS1000;
  pDstatus->vsl_ping_device_found = 0;

  DbgPrintf(D_Level, (TEXT("Ping Devices\n")));

  vs = &wi->dev[glob_info->device_selected];

  MacBuf = our_get_ping_list(&rc, &nbytes);
  pMacStatus = (DRIVER_MAC_STATUS  *) MacBuf;
  if (rc) {
    nbytes = 0;
    *nBytes = 0;
    pDstatus->vsl_mac_list_found = 0;
    DbgPrintf(D_Error, (TEXT("Err Mac List1\n")));
    return NULL;  // failed ioctl call
  }

  //are there any VS-Link MAC addresses out on the network?...
  pDstatus->vsl_available  = 0;
  pDstatus->vsl_load_status = 0;
  pDstatus->vsl_detected = (nbytes / sizeof(DRIVER_MAC_STATUS));
  pDstatus->vsl_mac_list_found = 1;

  rc = 0;

  if ((nbytes / sizeof(DRIVER_MAC_STATUS)) == 0) {
    DbgPrintf(D_Level, (TEXT("Zero Mac List\n")));
    *nBytes = 0;
    return NULL;  // failed ioctl call
  }

  *nBytes = nbytes;  // return number of bytes of mac list read

  // ok; is our target one of them?...
  for (index = 0; 
       index < (nbytes / (int)sizeof(DRIVER_MAC_STATUS)); 
       index++)
  {
      // generate count of available VS-Links for loading at this time...
    if ( ((pMacStatus->flags & FLAG_APPL_RUNNING) == 0) ||
         (pMacStatus->flags & FLAG_OWNER_TIMEOUT) )         
      ++pDstatus->vsl_available;

      //target MAC matches?...
    if (mac_match(pMacStatus->mac,vs->MacAddr))
    {
      //ok; save its load status...
      pDstatus->vsl_load_status = pMacStatus->flags;
      pDstatus->vsl_ping_device_found = 1;
      rc = 1;
    }
      ++pMacStatus;
  }  // end of for loop

  return MacBuf;
}
#endif

/*------------------------------------------------------------------------
 format_mac_addr -
|------------------------------------------------------------------------*/
void format_mac_addr(char *outstr, unsigned char *address)
{
  wsprintf(outstr,
         "%02X %02X %02X %02X %02X %02X",
         address[0],
         address[1],
         address[2],
         address[3],
         address[4],
         address[5]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\driprop.c ===
/*-------------------------------------------------------------------
| driprop.c - Driver level Properties Sheet.
|--------------------------------------------------------------------*/
#include "precomp.h"

static void set_field(HWND hDlg, WORD id);
static void get_field(HWND hDlg, WORD id);
static void context_menu(void);

static Driver_Config *adv_org_wi = NULL;  // original info, use to detect changes

/*----------------------------------------------------------
 AdvDriverSheet - Dlg window procedure for add on Advanced sheet.
|-------------------------------------------------------------*/
BOOL WINAPI AdvDriverSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
 OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
#ifdef NT50
      glob_hwnd = hDlg;
#endif
      if (adv_org_wi == NULL)
        adv_org_wi =  (Driver_Config *) calloc(1,sizeof(Driver_Config));

      memcpy(adv_org_wi, wi, sizeof(*wi));  // save copy of original

      set_field(hDlg, IDC_VERBOSE);
      set_field(hDlg, IDC_GLOBAL485);
      set_field(hDlg, IDC_CBOX_SCAN_RATE);
#ifdef NT50
#if ALLOW_NO_PNP_PORTS
      set_field(hDlg, IDC_PNP_PORTS);
#else
      // hide this option for now.
      ShowWindow(GetDlgItem(hDlg, IDC_PNP_PORTS), SW_HIDE);
#endif
#endif
    return TRUE;  // No need for us to set the focus.

    case PSM_QUERYSIBLINGS :
    {
      switch (HIWORD(wParam))
      {
        case QUERYSIB_GET_OUR_PROPS :
          // grab updated info from controls(don't have any)

          get_field(hDlg, IDC_VERBOSE);
          get_field(hDlg, IDC_GLOBAL485);
          get_field(hDlg, IDC_CBOX_SCAN_RATE);
#ifdef NT50
#if ALLOW_NO_PNP_PORTS
          get_field(hDlg, IDC_PNP_PORTS);
#endif
#endif

          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return TRUE;
        break;

        default :
        return FALSE;
      }
    }

    case WM_COMMAND:
      switch (LOWORD(wParam))
      {
        case IDB_DEF:
          wi->VerboseLog = 0;
          wi->ScanRate = 0;
          wi->GlobalRS485 = 0;
#ifdef NT50
          wi->NoPnpPorts = 0;
#endif
 
          set_field(hDlg, IDC_VERBOSE);
          set_field(hDlg, IDC_GLOBAL485);
          set_field(hDlg, IDC_CBOX_SCAN_RATE);
#ifdef NT50
#if ALLOW_NO_PNP_PORTS
          set_field(hDlg, IDC_PNP_PORTS);
#endif
#endif
        break;

        case IDM_ADVANCED_MODEM_INF:
          //mess(&wi->ip, "1.) modem inf");
          update_modem_inf(1);
        break;

        case IDM_PM:             // Try out the add pm group dde stuff
          setup_make_progman_group(0);
        break;
      }
    return FALSE;

    case WM_PAINT:
        //
    return FALSE;

    case WM_CONTEXTMENU:     // right-click
      context_menu();
    break;

    case WM_HELP:            // question mark thing
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_KILLACTIVE :
          // we're losing focus to another page...
          // make sure we update the Global485 variable here.
          get_field(hDlg, IDC_GLOBAL485);
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return FALSE;  // allow focus change
        break;

        case PSN_HELP :
          our_help(&wi->ip, WIN_NT);
        break;

        case PSN_QUERYCANCEL :
          // request that the other sheets gather up any changes.
          PropSheet_QuerySiblings(GetParent(hDlg),
                                  (WPARAM) (QUERYSIB_GET_OUR_PROPS << 16),
                                  0);

          if (allow_exit(1))  // request cancel
          {
            // the DWL_MSGRESULT field must be *FALSE* to tell QueryCancel
            // that an exit is acceptable.  The function result must be
            // *TRUE* to acknowledge that we handled the message.
            SetWindowLong(hDlg, DWL_MSGRESULT, FALSE); // allow cancel
            return TRUE;
          }
          else
          {
            // the DWL_MSGRESULT field must be *TRUE* to tell QueryCancel
            // that we don't want an exit.  The function result must be
            // *TRUE* to acknowledge that we handled the message.
            SetWindowLong(hDlg, DWL_MSGRESULT, TRUE); // don't allow cancel
            return TRUE;
          }
        break;

        case PSN_APPLY :
            // request that the other sheets gather up any changes.
            PropSheet_QuerySiblings(GetParent(hDlg),
                                    (WPARAM) (QUERYSIB_GET_OUR_PROPS << 16),
                                    0);

            if (!wi->DriverExitDone)
            {
            // now see if anything changed that needs saving
            if (allow_exit(0))  // request ok to save and exit
            {
              wi->DriverExitDone = 1;  // prevents other pages doing this
              // do the install/save of config params if not canceling..
#ifdef NT50
              our_nt50_exit();  // ok, quit
#else
              our_exit();  // nt40 exit
#endif
              SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
              //wi->SaveOnExit = 1;
            }
            else
            {
              SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            }
            }
          return TRUE;

        default :
        return FALSE;
      }  // switch ->code
    break;  // case wmnotify

    default :
    // return FALSE;
    break;
  }  // switch(uMessage)
  return FALSE;
}

/*----------------------------------------------------------------------------
| scr_to_cur -  Our window screen pos to windows absolute cursor position.
|-----------------------------------------------------------------------------*/
static void scr_to_cur(HWND hwnd, POINT *pt)
{
 RECT rec;
 int cx, cy;

  GetWindowRect(hwnd, &rec);
  cx = GetSystemMetrics(SM_CXFRAME);
  cy = GetSystemMetrics(SM_CYCAPTION) + (cx-1);
  pt->x += (rec.left + cx);
  pt->y += ( rec.top + cy);
}

/*----------------------------------------------------------
 context_menu -
|------------------------------------------------------------*/
static void context_menu(void)
{
  HMENU hpop_menu;
  POINT scr_pt;
  int stat;
  scr_pt.x = 200;
  scr_pt.y = 200;

  hpop_menu = CreatePopupMenu();
  if (hpop_menu == NULL)
  {
    mess(&wi->ip, "Error from CreatePopMenu");
    return;
  }

  
#ifndef NT50
  AppendMenu(hpop_menu,  0, IDM_ADVANCED_MODEM_INF, "Update RAS modem.inf");
#endif
  AppendMenu(hpop_menu,  0, 0x11, "Run Wcom Test Terminal");
  AppendMenu(hpop_menu,  0, 0x12, "Run Portman Program");
  AppendMenu(hpop_menu,  0, 0x10, "Run Peer tracer");
  if (setup_utils_exist())
  {
    AppendMenu(hpop_menu,  0, IDM_PM, "Add Program Manager Menu Selections");
  }

  //scr_to_cur(glob_hwnd, &scr_pt);
  GetCursorPos(&scr_pt);
#if 0
  stat = TrackPopupMenu(hpop_menu,
                     0, /* flags */
                     //TPM_NONOTIFY, /* flags */
                     scr_pt.x, scr_pt.y, /* x,y */
                     0, /* 0 reserved */
                     glob_hwnd,
                     NULL);
#endif

  stat = TrackPopupMenuEx(hpop_menu,
                     TPM_NONOTIFY | TPM_RETURNCMD, /* flags */
                     scr_pt.x, scr_pt.y, /* x,y */
                     //0, /* 0 reserved */
                     glob_hwnd,
                     NULL);
  if (stat == IDM_ADVANCED_MODEM_INF)
  {
    update_modem_inf(1);
  }
  else if (stat == IDM_PM)
  {
    stat = make_progman_group(progman_list_nt, wi->ip.dest_dir);
  }
  else if (stat == 0x10)
  {
    GetSystemDirectory(gtmpstr,144);
    
    strcat(gtmpstr, "\\");
    strcat(gtmpstr, OurAppDir);
    SetCurrentDirectory(gtmpstr);
    strcat(gtmpstr, "\\peer.exe");
    WinExec(gtmpstr, SW_RESTORE);
  }
  else if (stat == 0x11)
  {
    GetSystemDirectory(gtmpstr,144);
    strcat(gtmpstr, "\\");
    strcat(gtmpstr, OurAppDir);
    SetCurrentDirectory(gtmpstr);
    strcat(gtmpstr, "\\wcom32.exe");
    WinExec(gtmpstr, SW_RESTORE);
  }
  else if (stat == 0x12)
  {
    GetSystemDirectory(gtmpstr,144);
    strcat(gtmpstr, "\\");
    strcat(gtmpstr, OurAppDir);
    SetCurrentDirectory(gtmpstr);
    strcat(gtmpstr, "\\portmon.exe");
    WinExec(gtmpstr, SW_RESTORE);
  }


  DestroyMenu(hpop_menu);
}

/*----------------------------------------------------------
 get_field -
|------------------------------------------------------------*/
static void get_field(HWND hDlg, WORD id)
{

  char tmpstr[60];
  UINT stat;
  INT val;

  //if (our_device_index >= wi->NumDevices)
  //  our_device_index = 0;
  //pc = &wi->dev[our_device_index].ports[our_port_index];

  switch(id)
  {
    case IDC_VERBOSE :
      //------------------ fill in "verbose event logging" option
      if (IsDlgButtonChecked(hDlg, id))
           wi->VerboseLog = 1;
      else wi->VerboseLog = 0;
    break;

    case IDC_PNP_PORTS :
#if ALLOW_NO_PNP_PORTS
  // don't allow them to change this here for now...
      if (IsDlgButtonChecked(hDlg, id))
           wi->NoPnpPorts = 1;
      else wi->NoPnpPorts = 0;
#endif
    break;

    case IDC_GLOBAL485 :
      if (IsDlgButtonChecked(hDlg, id))
        wi->GlobalRS485 = 1;
      else
        wi->GlobalRS485 = 0;
    break;

    case IDC_CBOX_SCAN_RATE :
      //------------------------- check scan_rate edit field
      GetDlgItemText(hDlg, id, tmpstr, 59);
      stat= sscanf(tmpstr,"%d",&val);
      if ((stat == 1) && (val >= 0))
      {
        wi->ScanRate = (int) val;
        //wsprintf(tmpstr, "scan:%d", wi->ScanRate);
        //P_TRACE(tmpstr);
      }
    break;
  }
}

/*----------------------------------------------------------
 set_field -
|------------------------------------------------------------*/
static void set_field(HWND hDlg, WORD id)
{
  HWND hwnd;
  char tmpstr[80];


  //if (our_device_index >= wi->NumDevices)
  //  our_device_index = 0;
  //pc = &wi->dev[our_device_index].ports[our_port_index];

  switch(id)
  {
    case IDC_VERBOSE :
      //------------------ fill in "verbose log" option
      SendDlgItemMessage(hDlg, id, BM_SETCHECK, wi->VerboseLog, 0);
    break;

    case IDC_GLOBAL485 :
      //------------------ fill in "global rs485" option
      SendDlgItemMessage(hDlg, id, BM_SETCHECK, wi->GlobalRS485, 0);
    break;

#if ALLOW_NO_PNP_PORTS
    case IDC_PNP_PORTS :
      SendDlgItemMessage(hDlg, id, BM_SETCHECK, wi->NoPnpPorts, 0);
    break;
#endif

    case IDC_CBOX_SCAN_RATE :
      hwnd = GetDlgItem(hDlg, IDC_CBOX_SCAN_RATE);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "1");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "2");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "4");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) RcStr(MSGSTR+21));
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "20");

      if (wi->ScanRate < 0) wi->ScanRate = 0;
      if ((wi->ScanRate == 0) || (wi->ScanRate == 10))
        lstrcpy(tmpstr,RcStr(MSGSTR+21));
      else wsprintf(tmpstr,"%d",wi->ScanRate);
      SetDlgItemText(hDlg, IDC_CBOX_SCAN_RATE, tmpstr);
    break;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\nt40.h ===
int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
				   LPSTR lpCmdLine, int nCmdShow);
LRESULT FAR PASCAL  MainWndProc(HWND hwnd, UINT message,
						WPARAM wParam, LPARAM lParam);
int DoDriverPropPages(HWND hwndOwner);

// globals vars -
int do_progman_add;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\nt40.c ===
/*------------------------------------------------------------------------
| nt40.c - nt4.0 non-pnp setup.exe code - WinMain, etc.
12-11-98 - use szAppTitle(.rc str) instead of aptitle for prop sheet title.
|------------------------------------------------------------------------*/
#include "precomp.h"

/*----------------------- local vars ---------------------------------*/
static int unattended_flag = 0;
static int test_mode = 0;
static HMENU hMenuMain;

int do_progman_add = 0;

static int auto_install(void);

// for nt4.0, we are a .EXE, so we need a WinMain...
/*------------------------------------------------------------------------
| WinMain - Main program entry for NT4.0 EXE setup program.
|------------------------------------------------------------------------*/
int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
				   LPSTR lpCmdLine, int nCmdShow)
{
  MSG      msg;
  WNDCLASS  wc;
  HWND hwnd;
  HACCEL  hAccel;
  char *buf;
  int i, stat;


#if DBG
   DebugLevel |= (D_Test | D_Error) ;
#endif

   glob_hinst = hInstance;  // ptr to dll hinstance

   if (hPrevInstance)	// Other instances of app running?
   {
     MessageBox(0,"Program is already running!","",MB_OK);
     return 0;
   }

  InitCommonControls();   // Initialize the common control library.

  if (setup_init())
  {
     return 0;
  } 


  buf = lpCmdLine;
  i=0;
  while ((*buf != 0) && (i < 80))
  {
    if ((*buf == '-') || (*buf == '/'))
    {
      ++buf;
      ++i;
      switch(toupper(*buf++))
      {
        case 'A':  // auto-install
          unattended_flag = 1;
        break;
        //return stat;

        case 'H':  // help
          our_help(&wi->ip, WIN_NT);
        return 0;

        case 'P':  // add program manager group
          do_progman_add = 1;  // add progman group
        break;

        case 'N':
          wi->install_style = INS_SIMPLE;  // default to original nt4.0 style
        break;

        case 'R':  // remove driver and files
          //        stat = our_message(&wi->ip,
          //"Would you like this setup program to remove this driver and related files?",
          // MB_YESNO);
          //  if (stat == IDYES)
          if (toupper(*buf)  == 'A')
            remove_driver(1);
          else
            remove_driver(0);
        return 0;

        case 'T':  // test mode, run only to test ui
          test_mode = 1;
        break;
        case 'Z':  // test mode, run only to test
          if (toupper(*buf)  == 'I')
            setup_service(OUR_INSTALL_START, OUR_SERVICE);  // do a remove on the service
          else
            setup_service(OUR_REMOVE, OUR_SERVICE);  // do a remove on the service
        return 0;

        case '?':  // our help
                  stat = our_message(&wi->ip,
"options>SETUP /options\n \
  A - auto install routine\n \
  P - add  program manager group\n \
  N - no inf file, simple install\n \
  H - display driver help info\n \
  R - remove driver(should do from control-panel first)",
 MB_OK);
        return 0;

      }  // switch
    }  // if (option)
    ++i;
    ++buf;
  }  // while options

   if (unattended_flag)
   {
     unattended_add_port_entries(&wi->ip,
                                 8, // num_entries
                                 5); // start_port:com5
     stat = auto_install();
     return stat;
   }

   if (!hPrevInstance)	// Other instances of app running?
   {
     // MAIN WINDOW
     wc.style       = CS_HREDRAW | CS_VREDRAW;	// Class style(s).
     wc.lpfnWndProc = MainWndProc;
     wc.cbClsExtra  = 0;	// No per-class extra data.
     wc.cbWndExtra  = 0;	// No per-window extra data.
     wc.hInstance   = hInstance;	// Application that owns the class.
     wc.hIcon       = LoadIcon(hInstance, "SETUPICON");
     wc.hCursor     = LoadCursor(NULL, IDC_ARROW);
     wc.hbrBackground = (HBRUSH) (COLOR_APPWORKSPACE + 1);
     wc.lpszMenuName  = NULL;  // Name of menu resource in .RC file.
     wc.lpszClassName = szAppName; // Name used in call to CreateWindow.
     RegisterClass(&wc);
   }
   hMenuMain = LoadMenu (glob_hinst, "MAIN_MENU");

   hAccel = LoadAccelerators (glob_hinst, "SetupAccel") ;

	/* Create a main window for this application instance.  */
   hwnd = CreateWindowEx(
                WS_EX_CONTEXTHELP,  // gives question mark help thing
		szAppName,          // See RegisterClass() call.
                                   // Text for window title bar.
                 szAppTitle,
    WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_CLIPCHILDREN,
//                 WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,  // Window style.
//                 CW_USEDEFAULT, CW_USEDEFAULT, // Def. horz, vert pos.
                 0,0, // Def. horz, vert pos.
                 300, 200, // Default width, height
//                 455, 435, // Default width, height
                 NULL,      // No Parent Window
                 hMenuMain,     // Use the window class menu.
                 hInstance, // This instance owns this window.
                 NULL);     // Pointer not needed.

   //ShowWindow (hwnd, nCmdShow);
   //UpdateWindow (hwnd);

             // Enter the modified message loop
  while (GetMessage(&msg, NULL, 0, 0))
  {
    if (!TranslateAccelerator (hwnd, hAccel, &msg))
    {
      if (glob_hDlg == 0 || !IsDialogMessage(glob_hDlg, &msg))
      {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
      }
    }
  }
  return msg.wParam;
}

/*------------------------------------------------------------------------
| MainWndProc - Main Window Proc.
|------------------------------------------------------------------------*/
LRESULT FAR PASCAL MainWndProc(HWND hwnd, UINT message,
						WPARAM wParam, LPARAM lParam)
{
 HDC hdc;
 PAINTSTRUCT ps;
 int stat;
 int QuitFlag = 0;

  switch (message)
  {
    case WM_CREATE: // Initialize Global vars

      glob_hwnd = hwnd;

      wi->NumDevices = 0;

      get_nt_config(wi); // Read the configuration information from the registry.
      copy_setup_init();  // make a copy of config data for change detection

      validate_config(1);  // validate and auto-fixup if config hosed

      // src_dir should always equal dest_dir since
      // INF copies files over files in NT.  Otherwise they
      // are running setup.exe before doing network install
      if (my_lstricmp(wi->ip.src_dir, wi->ip.dest_dir) != 0)
      {
        if (wi->ip.major_ver < 5)  // NT5.0 does not support 4.0 network inf files
        {
          if (wi->install_style != INS_SIMPLE)
          {
            // if they didn't explicitly ask for a non-adapter install
            // then: ask them(if allowed), or tell them about the control
            // panel/network to install correctly.
#ifdef ALLOW_NON_NET_INSTALL
            stat = our_message(&wi->ip,
              "Would you like to install this software?",
              MB_YESNO);

            if (stat != IDYES)
            {
              stat = our_message(&wi->ip,
"Would you like to view the help information?",MB_YESNO);
              if (stat == IDYES)
                our_help(&wi->ip, WIN_NT);
              QuitFlag = 1;
              PostQuitMessage(0);  // end the setup program.
            }
            wi->install_style = INS_SIMPLE;  // non-network adapter install
            do_progman_add = 1;   // force full install
#else
            if (!test_mode)  // test mode to allow us to continue(for programmers)
            {
              stat = our_message(&wi->ip,
"The software should be added as a network adapter in the control panel. \
Would you like to view the help information?",MB_YESNO);
              if (stat == IDYES)
                our_help(&wi->ip, WIN_NT);
              QuitFlag = 1;
              PostQuitMessage(0);  // end the setup program.
            }
#endif
          }
        }  // not nt5.0 or above

        if (wi->nt_reg_flags & 1)  // not installed(missing important reg entries)
        {
          wi->install_style = INS_SIMPLE;
          // do full install since we are not running out of cur dir.
          do_progman_add = 1; 
        }
        else  // is installed, but running setup somewhere besides rocket dir
        {
          // just update the thing.
          wi->install_style = INS_SIMPLE;
          // do full install since we are not running out of cur dir.
          do_progman_add = 1; 
        }
      }

      // if registry not setup correctly, and not asking for a simple
      // install, then tell them the registry is screwed up.
      if ( (wi->nt_reg_flags & 1) && (!(wi->install_style == INS_SIMPLE)))
      {
        stat = our_message(&wi->ip,
"Some Registry entries are missing for this Software, You may need to \
reinstall it from the Control Panel, Network applet.  Are you sure you \
want to continue?", MB_YESNO);
        if (stat != IDYES) {
          QuitFlag = 1;
          PostQuitMessage(0);  // end the setup program.
        }
      }

      // the NT install INF file copys files to our install directory,
      // so the following check is not good indicator if it is "reinstall"

      if (my_lstricmp(wi->ip.src_dir, wi->ip.dest_dir) != 0)
        do_progman_add = 1;

      //----- fire up the main level of property sheets.
      if (!QuitFlag)
        // eliminate the flash of showing and erasing the property sheet
        DoDriverPropPages(hwnd);  // in nt40.c

      // end the program.
      PostQuitMessage(0);  // end the setup program.
    return 0;
  
    case WM_SETFOCUS:
      SetFocus(glob_hDlg);
    return 0;

    case WM_COMMAND:	// message: command from application menu

      switch(wParam)
      {
        case IDM_F1:
          our_help(&wi->ip, WIN_NT);
        break;

        case IDM_ADVANCED_MODEM_INF:
          update_modem_inf(1);
        break;

        case IDM_PM:             // Try out the add pm group dde stuff

          stat = make_progman_group(progman_list_nt, wi->ip.dest_dir);
          if (stat)
          {
            our_message(&wi->ip,"Error setting up Program group",MB_OK);
            return 0;
          }
        break;

#ifdef COMMENT_OUT
        case IDM_ADVANCED:
          DialogBox(glob_hinst,
             MAKEINTRESOURCE(IDD_DRIVER_OPTIONS),
             hwnd,
             adv_driver_setup_dlg_proc);
        break;

        case IDM_EDIT_README:   // edit readme.txt
          strcpy(gtmpstr, "notepad.exe ");
          strcat(gtmpstr, wi->ip.src_dir);
          strcat(gtmpstr,"\\readme.txt");
          WinExec(gtmpstr, SW_RESTORE);
        break;
#endif

        return 0;

        case IDM_HELP:
          our_help(&wi->ip, WIN_NT);
        return 0;

        case IDM_HELPABOUT:
          strcpy(gtmpstr, szAppTitle);
          //strcpy(gtmpstr, aptitle);
          wsprintf(&gtmpstr[strlen(gtmpstr)],
                   " Version %s\nCopyright (c) 1995-97 Comtrol Corp.",
                   VERSION_STRING);
          MessageBox(hwnd, gtmpstr, "About",MB_OK);
        return 0;
     }
    break;

    case WM_SIZE:
      //frame_width = LOWORD(lParam);
      //frame_height = HIWORD(lParam);
    break; // have to let default have this too!

    case WM_PAINT:
      // PaintMainBMP(hwnd);
      hdc = BeginPaint(hwnd, &ps);
      EndPaint(hwnd, &ps);
      return 0;

    case WM_HELP:            // question mark thing
      our_context_help(lParam);
    break;

    case WM_SYSCOMMAND:
      if ((wParam & 0xfff0) == SC_CLOSE)
      {
        if (allow_exit(1) == 0)  // ok, quit
        {
        }
        else
        {
          return 0;  // we handled this, don't exit app.
        }
      }
      
    break;

    case WM_QUIT:
    case WM_DESTROY:  // message: window being destroyed
      PostQuitMessage(0);
    return 0 ;

    default:
    break;
  }
  return DefWindowProc(hwnd, message, wParam, lParam);
}

/*------------------------------------------------------------------------
| auto_install - No prompt default installation, for automated installs.
|------------------------------------------------------------------------*/
static int auto_install(void)
{
 //int stat;

  wi->ip.prompting_off = 1;  // turn our_message() prompting off.

  get_nt_config(wi);  // get configured io-addresses, irq, etc

  copy_setup_init();  // make a copy of config data for change detection

  // if 0 dev-nodes setup, add 1 for the user.
  if (wi->NumDevices == 0)
  {
    ++wi->NumDevices;
    validate_device(&wi->dev[0], 1);
  }

  do_install();
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\driprop.h ===
// driprop.h

BOOL WINAPI AdvDriverSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\ourver.h ===
#ifdef S_RK
  #define VER_PRODUCTNAME           "RocketPort RocketModem RocketModemII RocketModem i(TM) Series Async Adapters for the Microsoft Windows(TM) Operating System\0"
  #define VER_INTERNALNAME          "RocketPort"
  #define VER_PRODUCTVERSION_STR  "4.41"
  #define VER_PRODUCTVERSION      4,41
#else
  #define VER_PRODUCTNAME           "VS1000/VS2000, RocketPort Serial Hub for the Microsoft Windows(TM) Operating System\0"
  #define VER_INTERNALNAME          "VSLinkA"
  #define VER_PRODUCTVERSION_STR  "2.41"
  #define VER_PRODUCTVERSION       2,41
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\nt50.h ===
BOOL WINAPI DevicePropPage(
      LPVOID pinfo,   // points to PROPSHEETPAGE_REQUEST, see setupapi.h
      LPFNADDPROPSHEETPAGE pfnAdd, // add sheet function
      LPARAM lParam);  // add sheet function data handle?
int our_nt50_exit(void);
int nt5_open_dev_key(HKEY *hkey);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\portprop.c ===
/*-------------------------------------------------------------------
| portprop.c - Port Properties Sheet.
|--------------------------------------------------------------------*/
#include "precomp.h"

#define D_Level 0x10
static void set_field(HWND hDlg, WORD id);
static void get_field(HWND hDlg, WORD id);
//static int PaintIcon(HWND hWnd);

#define MAX_PORTPROP_SHEETS       3
#define QUERYSIB_CLONE_PORT_PROPS 1
#define CLONEOPT_ALL              1   // clone to all ports
#define CLONEOPT_DEVICE           2   // clone to all ports on selected device
#define CLONEOPT_SELECT           3   // clone to selected ports (lParam = *list)

int FillPortPropSheets(PROPSHEETPAGE *psp, LPARAM our_params);
BOOL WINAPI PortPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);
BOOL WINAPI PortProp485Sheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);
BOOL WINAPI PortPropModemSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);

static int our_port_index   = 0;
static int our_device_index = 0;
static int num_active_portprop_sheets = 1;  // always at least one

/*------------------------------------------------------------------------
| FillPortPropSheets - Setup pages for driver level property sheets.
|------------------------------------------------------------------------*/
int FillPortPropSheets(PROPSHEETPAGE *psp, LPARAM our_params)
{
  INT pi;
  static TCHAR portsetstr[40], rs485str[40], modemstr[40];

  memset(psp, 0, sizeof(*psp) * MAX_PORTPROP_SHEETS);

  pi = 0;

  //----- main prop device sheet.
  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_PORT_OPTIONS);
  psp[pi].pfnDlgProc = PortPropSheet;
  load_str( glob_hinst, (TITLESTR+4), portsetstr, CharSizeOf(portsetstr) );
  psp[pi].pszTitle = portsetstr;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;
  num_active_portprop_sheets = 1;

  //----- rs-485 prop device sheet.
  if (((strstr(wi->dev[glob_info->device_selected].ModelName, "485")) &&
       (our_port_index < 2)) ||
      (wi->GlobalRS485 == 1))
  {
    psp[pi].dwSize = sizeof(PROPSHEETPAGE);
    //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
    psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
    psp[pi].hInstance = glob_hinst;
    psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_PORT_485_OPTIONS);
    psp[pi].pfnDlgProc = PortProp485Sheet;
    load_str( glob_hinst, (TITLESTR+5), rs485str, CharSizeOf(rs485str) );
    psp[pi].pszTitle = rs485str;
    psp[pi].lParam = (LPARAM)our_params;
    psp[pi].pfnCallback = NULL;
    ++pi;
    ++num_active_portprop_sheets;
  }


  //----- modem prop device sheet.
  if (wi->dev[glob_info->device_selected].ModemDevice)
  {
    psp[pi].dwSize = sizeof(PROPSHEETPAGE);
    //psp[pi].dwFlags = PSP_USEICONID | PSP_USETITLE;
    psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP;
    psp[pi].hInstance = glob_hinst;
    psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_PORT_MODEM_OPTIONS);
    psp[pi].pfnDlgProc = PortPropModemSheet;
    load_str( glob_hinst, (TITLESTR+6), modemstr, CharSizeOf(modemstr) );
    psp[pi].pszTitle = modemstr;
    psp[pi].lParam = (LPARAM)our_params;
    psp[pi].pfnCallback = NULL;
    ++pi;
    ++num_active_portprop_sheets;
  }

  return 0;
}

/*------------------------------------------------------------------------
| DoPortPropPages - Main driver level property sheet for NT4.0
|------------------------------------------------------------------------*/
int DoPortPropPages(HWND hwndOwner, int device, int port)
{
  PROPSHEETPAGE psp[MAX_PORTPROP_SHEETS];
  PROPSHEETHEADER psh;
  OUR_INFO *our_params;
  INT stat;
  Port_Config *pc;
  char title[40];

    wi->ChangesMade = 1;  // indicate changes made, as send_to_driver
                          // does not calculate this yet

    our_port_index   = port;
    our_device_index = device;

    pc = &wi->dev[our_device_index].ports[our_port_index];
    strcpy(title, pc->Name);
    strcat(title, RcStr(MSGSTR+29));

    our_params = glob_info;  // temporary kludge, unless we don't need re-entrantancy

    //Fill out the PROPSHEETPAGE data structure for the Client Area Shape
    //sheet
    FillPortPropSheets(&psp[0], (LPARAM)our_params);

    //Fill out the PROPSHEETHEADER
    memset(&psh, 0, sizeof(PROPSHEETHEADER));

    psh.dwSize = sizeof(PROPSHEETHEADER);
    //psh.dwFlags = PSH_USEICONID | PSH_PROPSHEETPAGE;
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = glob_hinst;
    psh.pszIcon = "";
    psh.pszCaption = (LPSTR) title; //"Port Properties";
    //psh.nPages = NUM_PORTPROP_SHEETS;
    psh.nPages = num_active_portprop_sheets;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    //And finally display the dialog with the property sheets.

    stat = PropertySheet(&psh);
  return 0;
}

/*----------------------------------------------------------
 context_menu -
|------------------------------------------------------------*/
static void context_menu(void)
{
  HMENU hpop_menu;
  POINT scr_pt;
  int stat;
  scr_pt.x = 200;
  scr_pt.y = 200;

  hpop_menu = CreatePopupMenu();
  if (hpop_menu == NULL)
  {
    mess(&wi->ip, "Error from CreatePopMenu");
    return;
  }
  //AppendMenu(hpop_menu,  0, 0x10, "Run Peer tracer");
  AppendMenu(hpop_menu,  0, 0x11, "Run Wcom Test Terminal");

  GetCursorPos(&scr_pt);

  stat = TrackPopupMenuEx(hpop_menu,
                     TPM_NONOTIFY | TPM_RETURNCMD, /* flags */
                     scr_pt.x, scr_pt.y, /* x,y */
                     //0, /* 0 reserved */
                     glob_hwnd,
                     NULL);

  GetSystemDirectory(gtmpstr,144);
  strcat(gtmpstr, "\\");
  strcat(gtmpstr, OurAppDir);
  SetCurrentDirectory(gtmpstr);

  if (stat == 0x11)
  {
    strcat(gtmpstr, "\\wcom32.exe \\\\.\\");
    strcat(gtmpstr, wi->dev[our_device_index].ports[our_port_index].Name);
  }
  WinExec(gtmpstr, SW_RESTORE);

  DestroyMenu(hpop_menu);
}

/*----------------------------------------------------------
 PortPropSheet - Dlg window procedure for add on Advanced sheet.
|-------------------------------------------------------------*/
BOOL WINAPI PortPropSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
 OUR_INFO * OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);
 WORD uCmd;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
 
      // save in case of cancel
      //memcpy(&org_pc, &wi->dev[our_device_index].ports[our_port_index],
      //  sizeof(org_pc));

      set_field(hDlg, IDC_PORT_LOCKBAUD     );
      set_field(hDlg, IDC_PORT_WAIT_ON_CLOSE);
      set_field(hDlg, IDC_PORT_WONTX        );
      set_field(hDlg, IDC_MAP_CDTODSR       );
      set_field(hDlg, IDC_MAP_2TO1          );
      set_field(hDlg, IDC_RING_EMULATE      );

                  //  Return TRUE to set focus to first control
    return TRUE;  // No need for us to set the focus.

    case PSM_QUERYSIBLINGS :
    {
      switch (HIWORD(wParam))
      {
        case QUERYSIB_CLONE_PORT_PROPS :
        {
          // low word of wParam is which ports to clone to...
          // currently we only support "all", but this is the place to add
          // other specific handling.
          int devnum;
          int portnum;
          Port_Config *srcport, *destport;

          #ifdef DEBUG
            char debugstr[80];
          #endif

          // make sure we have current values before cloning
          get_field(hDlg, IDC_PORT_LOCKBAUD     );
          get_field(hDlg, IDC_PORT_WAIT_ON_CLOSE);
          get_field(hDlg, IDC_PORT_WONTX        );
          get_field(hDlg, IDC_MAP_CDTODSR       );
          get_field(hDlg, IDC_MAP_2TO1          );
          get_field(hDlg, IDC_RING_EMULATE      );

          srcport = &wi->dev[our_device_index].ports[our_port_index];

          switch (LOWORD(wParam))
          {
            case CLONEOPT_ALL:
            {
              // apply the options on this page to all other ports
              for (devnum = 0; devnum < wi->NumDevices; devnum++)
              {
                for (portnum = 0; portnum < wi->dev[devnum].NumPorts; portnum++)
                {
                  destport = &wi->dev[devnum].ports[portnum];

                  // is it target different than the source?
                  if (destport != srcport)
                  {
                    // yep, so apply the source's options to the target
                    DbgPrintf(D_Level,
                       (TEXT("cloning general options from port %s to port %s\n"),
                       srcport->Name, destport->Name));

                    destport->LockBaud      = srcport->LockBaud;
                    destport->TxCloseTime   = srcport->TxCloseTime;
                    destport->WaitOnTx      = srcport->WaitOnTx;
                    destport->MapCdToDsr    = srcport->MapCdToDsr;
                    destport->Map2StopsTo1  = srcport->Map2StopsTo1;
                    destport->RingEmulate   = srcport->RingEmulate;
                  }
                }
              }
              break;
            }

            case CLONEOPT_DEVICE:
            {
              // apply the options on this page to all other ports on same device
              /* not yet implemented */
              break;
            }

            case CLONEOPT_SELECT:
            {
              // apply the options on this page to the list of selected ports
              // lParam is a pointer to a list of ports.
              /* not yet implemented */
              break;
            }

            default:
              // unknown clone option -- skip it
              break;
          }

          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return TRUE;
          break;
        }

      default :
      return FALSE;
      }
    }

    case WM_COMMAND :
#ifdef WIN32
      uCmd = HIWORD(wParam);
#else
      uCmd = HIWORD(lParam);
#endif

      switch (LOWORD(wParam))
      {
        case IDB_DEF:  // actually the defaults button
        {
          Port_Config *pc;
          pc= &wi->dev[our_device_index].ports[our_port_index];
 
          //pc->options  = 0;

          pc->RingEmulate = 0;
          pc->MapCdToDsr = 0;
          pc->WaitOnTx = 0;
          pc->Map2StopsTo1 = 0;
          pc->LockBaud = 0;
          pc->TxCloseTime = 0;
          // should we be doing this?  they are on another page(kpb)
          pc->RS485Override = 0;
          pc->RS485Low = 0;

          set_field(hDlg, IDC_PORT_LOCKBAUD     );
          set_field(hDlg, IDC_PORT_WAIT_ON_CLOSE);
          set_field(hDlg, IDC_PORT_WONTX        );
          set_field(hDlg, IDC_MAP_CDTODSR       );
          set_field(hDlg, IDC_MAP_2TO1          );
          set_field(hDlg, IDC_RING_EMULATE      );
        }
        break;
      }
    return FALSE;

    case WM_PAINT:
#if 0
          PaintIcon(hDlg);
#endif
    return FALSE;

    case WM_HELP:            // question mark thing
      our_context_help(lParam);
    return FALSE;

    case WM_CONTEXTMENU:     // right-click
      context_menu();
    break;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_HELP :
          our_help(&wi->ip, IDD_PORT_OPTIONS);
        break;

        case PSN_APPLY :
 
          get_field(hDlg, IDC_PORT_LOCKBAUD     );
          get_field(hDlg, IDC_PORT_WAIT_ON_CLOSE);
          get_field(hDlg, IDC_PORT_WONTX        );
          get_field(hDlg, IDC_MAP_CDTODSR       );
          get_field(hDlg, IDC_MAP_2TO1          );
          get_field(hDlg, IDC_RING_EMULATE      );

          if (IsDlgButtonChecked(hDlg, IDC_CLONE))
          {
            PropSheet_QuerySiblings(GetParent(hDlg),
                                    (WPARAM)((QUERYSIB_CLONE_PORT_PROPS << 16) + CLONEOPT_ALL),
                                    0);
          }

          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return TRUE;

        default :
        return FALSE;
      }
    break;

    default :
    // return FALSE;
	  break;
  }
  return FALSE;
}

/*----------------------------------------------------------
 PortProp485Sheet -
|-------------------------------------------------------------*/
BOOL WINAPI PortProp485Sheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
 OUR_INFO * OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);
 WORD uCmd;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
  
      // save in case of cancel
      //memcpy(&org_pc, &wi->dev[our_device_index].ports[our_port_index],
      //  sizeof(org_pc));

      set_field(hDlg, IDC_PORT_RS485_TLOW   );
      set_field(hDlg, IDC_PORT_RS485_LOCK   );

                  //  Return TRUE to set focus to first control
    return TRUE;  // No need for us to set the focus.

    case PSM_QUERYSIBLINGS :
    {
      switch (HIWORD(wParam))
      {
        case QUERYSIB_CLONE_PORT_PROPS :
        {
          // low word of wParam is which ports to clone to...
          // currently we only support "all", but this is the place to add
          // other specific handling.
          int devnum;
          int portnum;
          Port_Config *srcport, *destport;

          #ifdef DEBUG
            char debugstr[80];
          #endif

          // make sure we have current values before cloning
          get_field(hDlg, IDC_PORT_RS485_TLOW   );
          get_field(hDlg, IDC_PORT_RS485_LOCK   );

          srcport = &wi->dev[our_device_index].ports[our_port_index];

          switch (LOWORD(wParam))
          {
            case CLONEOPT_ALL:
            {
              int maxport;

              // apply the options on this page to all other ports
              for (devnum = 0; devnum < wi->NumDevices; devnum++)
              {
                if ((strstr(wi->dev[devnum].ModelName, "485")) ||
                    (wi->GlobalRS485 == 1))
                {
                  // we're only going to apply RS485 settings to other
                  // 485 boards (unless the global RS485 flag is on)
                  if (wi->GlobalRS485 == 1)
                    maxport = wi->dev[devnum].NumPorts;
                  else
                    maxport = 2;
                  for (portnum = 0; portnum < maxport; portnum++)
                  {
                    destport = &wi->dev[devnum].ports[portnum];

                    // is it target different than the source?
                    if (destport != srcport)
                    {
                      // yep, so apply the source's options to the target
                      DbgPrintf(D_Level,
                       (TEXT("cloning rs-485 options from port %s to port %s\n"),
                       srcport->Name, destport->Name));

                      destport->RS485Low      = srcport->RS485Low;
                      destport->RS485Override = srcport->RS485Override;
                    }
                  }
                }
              }
              break;
            }

            case CLONEOPT_DEVICE:
            {
              // apply the options on this page to all other ports on same device
              /* not yet implemented */
              break;
            }

            case CLONEOPT_SELECT:
            {
              // apply the options on this page to the list of selected ports
              // lParam is a pointer to a list of ports.
              /* not yet implemented */
              break;
            }

            default:
              // unknown clone option -- skip it
              break;
          }

          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return TRUE;
          break;
        }

      default :
      return FALSE;
      }
    }

    case WM_COMMAND :
#ifdef WIN32
      uCmd = HIWORD(wParam);
#else
      uCmd = HIWORD(lParam);
#endif

      switch (LOWORD(wParam))
      {
        case IDB_DEF:  // actually the defaults button
        {
          Port_Config *pc;
          pc= &wi->dev[our_device_index].ports[our_port_index];
          // pc->options  = 0;

          pc->RS485Override = 0;
          pc->RS485Low = 0;

          set_field(hDlg, IDC_PORT_RS485_TLOW   );
          set_field(hDlg, IDC_PORT_RS485_LOCK   );
        }
        break;
      }
    return FALSE;

    case WM_PAINT:
#if 0
      PaintIcon(hDlg);
#endif
    return FALSE;

    case WM_HELP:            // question mark thing
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_HELP :
          our_help(&wi->ip, IDD_PORT_485_OPTIONS);
        break;

        case PSN_APPLY :
          get_field(hDlg, IDC_PORT_RS485_TLOW   );
          get_field(hDlg, IDC_PORT_RS485_LOCK   );
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }
    default :
        return FALSE;
  }
}

/*----------------------------------------------------------
 request_modem_reset -
|-------------------------------------------------------------*/

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)
#define METHOD_BUFFERED                 0
#define FILE_ANY_ACCESS                 0
#define FILE_DEVICE_SERIAL_PORT         0x0000001b

#define IOCTL_RCKT_SET_MODEM_RESET \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80d,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_CLEAR_MODEM_RESET \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80e,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RCKT_SEND_MODEM_ROW \
      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 0x80f,METHOD_BUFFERED,FILE_ANY_ACCESS)

void request_modem_reset(int device_index, int port_index)
{
  HANDLE hDriver;     // file handle to driver device
  Port_Config *pc;    // config information about the port to reset
  ULONG retBytes;

  // attempt to open communications with the driver
  hDriver = CreateFile(szDriverDevice, GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE, 0,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
  if (hDriver != INVALID_HANDLE_VALUE)
  {
    // double-check that it is a modem device!
    if (wi->dev[device_index].ModemDevice)
    {
      pc = &wi->dev[device_index].ports[port_index];

      // send the ioctl to put the modem into the reset state
      DeviceIoControl(hDriver, IOCTL_RCKT_SET_MODEM_RESET,
                      pc->Name, sizeof(pc->Name),
                      pc->Name, sizeof(pc->Name),
                      &retBytes, 0);

      // delay briefly before pulling modem out of reset state
      Sleep(45);

      // send the ioctl to pull the modem out of reset state
      DeviceIoControl(hDriver, IOCTL_RCKT_CLEAR_MODEM_RESET,
                      pc->Name, sizeof(pc->Name),
                      pc->Name, sizeof(pc->Name),
                      &retBytes, 0);

      Sleep(65);

      // if country code is North America or invalid, we're done
      // if country code is default or invalid, we're done
      if (
      (wi->ModemCountry)
      &&
      ( (wi->dev[device_index].ModemDevice == TYPE_RM_VS2000)
        &&
        (wi->ModemCountry != RowInfo[0].RowCountryCode))
      ||
      ( (wi->dev[device_index].ModemDevice == TYPE_RM_i)
        &&
        (wi->ModemCountry != CTRRowInfo[0].RowCountryCode))
      ) {
        // wait for the modem to stablize before sending country code command
        // (about 4 seconds!)
        Sleep(4000);

        // send the ioctl to configure the country code
        DeviceIoControl(hDriver, IOCTL_RCKT_SEND_MODEM_ROW,
                        pc->Name, sizeof(pc->Name),
                        pc->Name, sizeof(pc->Name),
                        &retBytes, 0);

      }
    }

    // close communications with the driver
    CloseHandle(hDriver);
  }
}

/*----------------------------------------------------------
 PortPropModemSheet -
|-------------------------------------------------------------*/
BOOL WINAPI PortPropModemSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
 OUR_INFO * OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);
 WORD uCmd;

  switch(uMessage)
  {
    case WM_INITDIALOG :
      OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
  
      // save in case of cancel
      //memcpy(&org_pc, &wi->dev[our_device_index].ports[our_port_index],
      //  sizeof(org_pc));

      if (wi->dev[our_device_index].ModemDevice)
      {
        // parent device for this port provides modems, enable reset button
        EnableWindow(GetDlgItem(hDlg, IDB_RESET), 1);
      }
      else
      {
        // parent device for this port has no modems, disable the reset button
        EnableWindow(GetDlgItem(hDlg, IDB_RESET), 0);
      }

                  //  Return TRUE to set focus to first control
    return TRUE;  // No need for us to set the focus.

    case WM_COMMAND :
#ifdef WIN32
      uCmd = HIWORD(wParam);
#else
      uCmd = HIWORD(lParam);
#endif

      switch (LOWORD(wParam))
      {
        case IDB_RESET:
          request_modem_reset(our_device_index, our_port_index);
        break;
      }
    return FALSE;

    case WM_PAINT:
#if 0
      PaintIcon(hDlg);
#endif
    return FALSE;

    case WM_HELP:            // question mark thing
      our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_HELP :
          our_help(&wi->ip, IDD_PORT_MODEM_OPTIONS);
        break;

        case PSN_APPLY :
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

        default :
        return FALSE;
      }
    default :
        return FALSE;
  }
}

/*-------------------------------------------------------------------
| get_field - Run when a selection is changed.
|--------------------------------------------------------------------*/
static void get_field(HWND hDlg, WORD id)
{
 char tmpstr[60];
 int i;
  Port_Config *pc;
//  HWND hwnd;

  pc= &wi->dev[our_device_index].ports[our_port_index];

  switch (id)
  {
    case IDC_PORT_LOCKBAUD:
      GetDlgItemText(hDlg, id, tmpstr, 58);
      pc->LockBaud = getint(tmpstr, &i);
    break;

    case IDC_PORT_WAIT_ON_CLOSE:
      GetDlgItemText(hDlg, id, tmpstr, 58);
      pc->TxCloseTime = getint(tmpstr, &i);
    break;

    case IDC_PORT_WONTX:
      if (IsDlgButtonChecked(hDlg, IDC_PORT_WONTX))
           pc->WaitOnTx = 1;
      else pc->WaitOnTx = 0;
    break;
    case IDC_PORT_RS485_TLOW:
      if (IsDlgButtonChecked(hDlg, IDC_PORT_RS485_TLOW))
           pc->RS485Low = 1;
      else pc->RS485Low = 0;
    break;
    case IDC_PORT_RS485_LOCK:
      if (IsDlgButtonChecked(hDlg, IDC_PORT_RS485_LOCK))
           pc->RS485Override = 1;
      else pc->RS485Override = 0;
    break;
    case IDC_MAP_CDTODSR:
      if (IsDlgButtonChecked(hDlg, IDC_MAP_CDTODSR))
           pc->MapCdToDsr = 1;
      else pc->MapCdToDsr = 0;
    break;
    case IDC_MAP_2TO1:
      if (IsDlgButtonChecked(hDlg, IDC_MAP_2TO1))
           pc->Map2StopsTo1 = 1;
      else pc->Map2StopsTo1 = 0;
    break;
    case IDC_RING_EMULATE :
      if (IsDlgButtonChecked(hDlg, IDC_RING_EMULATE))
           pc->RingEmulate = 1;
      else pc->RingEmulate = 0;
    break;
  }
}

/*----------------------------------------------------------
 set_field -
|------------------------------------------------------------*/
static void set_field(HWND hDlg, WORD id)
{
  HWND hwnd;
  char tmpstr[60];
  Port_Config *pc;

  if (our_device_index >= wi->NumDevices)
    our_device_index = 0;
  pc = &wi->dev[our_device_index].ports[our_port_index];

  //------------------ fill in name selection
  //SetDlgItemText(hDlg, IDC_, pc->Name);
  switch(id)
  {
    case IDC_PORT_LOCKBAUD:
      //------------------ fill in baud override selection
      hwnd = GetDlgItem(hDlg, IDC_PORT_LOCKBAUD);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) RcStr(MSGSTR+22));
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "57600");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "115200");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "230400");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "460800");
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) "921600");
      wsprintf(tmpstr, "%d", pc->LockBaud);
      if (pc->LockBaud == 0)
        strcpy(tmpstr,RcStr(MSGSTR+22));
      SetDlgItemText(hDlg, IDC_PORT_LOCKBAUD, tmpstr);
    break;

    case IDC_PORT_RS485_LOCK:
      //------------------ fill in "rs485 override?" option
      SendDlgItemMessage(hDlg, IDC_PORT_RS485_LOCK, BM_SETCHECK,
        pc->RS485Override, 0);
    break;

    case IDC_MAP_CDTODSR:
      //------------------ fill in "map CD to DSR?" option
      SendDlgItemMessage(hDlg, IDC_MAP_CDTODSR, BM_SETCHECK,
        pc->MapCdToDsr, 0);
    break;

    case IDC_MAP_2TO1:
      //------------------ fill in "map 2 to 1 stops?" option
      SendDlgItemMessage(hDlg, IDC_MAP_2TO1, BM_SETCHECK,
        pc->Map2StopsTo1, 0);
    break;

    case IDC_PORT_RS485_TLOW:
      //------------------ fill in "rs485 toggle low?" option
      SendDlgItemMessage(hDlg, IDC_PORT_RS485_TLOW, BM_SETCHECK,
        pc->RS485Low, 0);
    break;

    case IDC_PORT_WONTX:
      //------------------ fill in "wait on tx?" option
      SendDlgItemMessage(hDlg, IDC_PORT_WONTX, BM_SETCHECK,
        pc->WaitOnTx, 0);
    break;

    case IDC_PORT_WAIT_ON_CLOSE:
      //------------------ fill in wait on tx close option
      hwnd = GetDlgItem(hDlg, IDC_PORT_WAIT_ON_CLOSE);
      SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) RcStr(MSGSTR+23));
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) RcStr(MSGSTR+24));
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) RcStr(MSGSTR+25));
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) RcStr(MSGSTR+26));
      SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(char far *) RcStr(MSGSTR+27));
      // no, need some better way to default this to 1 or 2 seconds
      //if (pc->TxCloseTime == 0)
      //   strcpy(tmpstr, "1 sec");  // 0 means to the driver same as 6-seconds
      wsprintf(tmpstr, "%d %s", pc->TxCloseTime, RcStr(MSGSTR+28));
      SetDlgItemText(hDlg, IDC_PORT_WAIT_ON_CLOSE, tmpstr);
    break;

    case IDC_RING_EMULATE:
      SendDlgItemMessage(hDlg, IDC_RING_EMULATE, BM_SETCHECK,
        pc->RingEmulate, 0);
    break;
  }
}

#if 0
/*---------------------------------------------------------------------------
  PaintIcon - Paints the Icon in the property sheet.
|---------------------------------------------------------------------------*/
static int PaintIcon(HWND hWnd)
{
//   int status;
   HBITMAP      hBitMap;
   HGDIOBJ      hGdiObj;
   HDC          hDC, hMemDC ;
   PAINTSTRUCT  ps ;
   RECT spot, main;  // left, top, right, bottom
   static int cnt = 0;

  GetWindowRect(GetDlgItem(hWnd, IDB_DEF), &spot);
  GetWindowRect(hWnd, &main);
#ifdef COMMENT_OUT
  rect = &right;
  mess("hlp r:%d l:%d b:%d t:%d",
       rect->right, rect->left, rect->bottom, rect->top);
#endif
  spot.left -= main.left;
  spot.top -= main.top;

  spot.left += 5;
  spot.top  += 20; // spacing

   // load bitmap and display it

   hDC = BeginPaint( hWnd, &ps ) ;
   if (NULL != (hMemDC = CreateCompatibleDC( hDC )))
   {
      hBitMap = LoadBitmap(glob_hinst,
                           MAKEINTRESOURCE(BMP_SMALL_LOGO));

      hGdiObj = SelectObject(hMemDC, hBitMap);

      BitBlt( hDC, spot.left, spot.top, 100, 100, hMemDC, 0, 0, SRCCOPY ) ;
      //StretchBlt( hDC, 5, 5, 600,100, hMemDC, 0, 0, 446, 85, SRCCOPY ) ;
      DeleteObject( SelectObject( hMemDC, hGdiObj ) ) ;
      DeleteDC( hMemDC ) ;
   }
   EndPaint( hWnd, &ps ) ;
 return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\portprop.h ===
// portprop.h

int DoPortPropPages(HWND hwndOwner, int device, int port);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\opstr.c ===
/*-----------------------------------------------------------------------
 opstr.c - Option Strings.  These are strings which define the options
  associated with the driver at the three levels: driver, device, port.
  This code is special, in that the source may be used for both driver
  and setup program, so consists only of the strings which can be shared
  in source code.

  This has expanded to other code which should be shared by
  both setup program and driver.

Copyright 1998 Comtrol(TM) Corporation.
|-----------------------------------------------------------------------*/
#include "precomp.h"

// driver options
const char szVerboseLog[]   = {"VerboseLog"};
const char szNumDevices[]   = {"NumDevices"};
const char szNoPnpPorts[]     = {"NoPnpPorts"};
const char szScanRate[]     = {"ScanRate"};
const char szModemCountry[] = {"ModemCountry"};
const char szGlobalRS485[]  = {"GlobalRS485Options"};

// device options
//const char szStartComIndex[] = {"StartComIndex"};
const char szNumPorts[]      = {"NumPorts"};
const char szMacAddr[]       = {"MacAddr"};
const char szBackupServer[]  = {"BackupServer"};
const char szBackupTimer[]   = {"BackupTimer"};
const char szName[]          = {"Name"};
const char szModelName[]     = {"ModelName"};
const char szIoAddress[]     = {"IoAddress"};
const char szModemDevice[]   = {"ModemDevice"};
const char szHubDevice[]     = {"HubDevice"};

// port options
const char szWaitOnTx[]      = {"WaitOnTx"};
const char szRS485Override[] = {"RS485Override"};
const char szRS485Low[]      = {"RS485Low"};
const char szTxCloseTime[]   = {"TxCloseTime"};
const char szLockBaud[]      = {"LockBaud"};
const char szMap2StopsTo1[]  = {"Map2StopsTo1"};
const char szMapCdToDsr[]    = {"MapCdToDsr"};
const char szRingEmulate[]    = {"RingEmulate"};

Our_Options driver_options[] = {
  // driver options
  {szVerboseLog,     OP_VerboseLog   , OP_T_DWORD, OP_F_VSRK},
  {szNumDevices,     OP_NumDevices   , OP_T_DWORD, OP_F_VSRK},
#ifdef NT50
  {szNoPnpPorts,       OP_NoPnpPorts     , OP_T_DWORD, OP_F_VSRK},
#endif
  {szScanRate,       OP_ScanRate     , OP_T_DWORD, OP_F_VSRK},
  {szModemCountry,   OP_ModemCountry , OP_T_DWORD, OP_F_VSRK},
  {szGlobalRS485,    OP_GlobalRS485  , OP_T_DWORD, OP_F_VSRK},
  {NULL,0,0,0}
};

Our_Options device_options[] = {
  // device options
//  {szStartComIndex,  OP_StartComIndex, OP_T_DWORD , OP_F_VSRK},
  {szNumPorts,       OP_NumPorts     , OP_T_DWORD , OP_F_VSRK},
#ifdef S_VS
  {szMacAddr,        OP_MacAddr      , OP_T_STRING, OP_F_VS},
  {szBackupServer,   OP_BackupServer , OP_T_DWORD , OP_F_VS},
  {szBackupTimer,    OP_BackupTimer  , OP_T_DWORD , OP_F_VS},
#endif
  {szName,           OP_Name         , OP_T_STRING, OP_F_VSRK},
  {szModelName,      OP_ModelName    , OP_T_STRING, OP_F_VSRK},
#ifdef S_RK
#ifndef NT50
  {szIoAddress,      OP_IoAddress    , OP_T_DWORD , OP_F_RK},
#endif
#endif
  {szModemDevice,    OP_ModemDevice  , OP_T_DWORD , OP_F_VSRK},
  {szHubDevice,      OP_HubDevice    , OP_T_DWORD , OP_F_VS},
  {NULL,0,0,0}
};

Our_Options port_options[] = {
  // port options
  {szWaitOnTx,       OP_WaitOnTx     , OP_T_DWORD,  OP_F_VSRK},
  {szRS485Override,  OP_RS485Override, OP_T_DWORD,  OP_F_VSRK},
  {szRS485Low,       OP_RS485Low     , OP_T_DWORD,  OP_F_VSRK},
  {szTxCloseTime,    OP_TxCloseTime  , OP_T_DWORD,  OP_F_VSRK},
  {szLockBaud,       OP_LockBaud     , OP_T_DWORD,  OP_F_VSRK},
  {szMap2StopsTo1,   OP_Map2StopsTo1 , OP_T_DWORD,  OP_F_VSRK},
  {szMapCdToDsr,     OP_MapCdToDsr   , OP_T_DWORD,  OP_F_VSRK},
  {szName,           OP_PortName     , OP_T_STRING, OP_F_VSRK},
  {szRingEmulate,    OP_RingEmulate  , OP_T_DWORD,  OP_F_VSRK},
  {NULL,0,0,0}
};

#define INFO_WANT_NUMPORTS        0
#define INFO_WANT_MODEM_DEVICE    1
#define INFO_WANT_HUB_DEVICE      2
#define INFO_WANT_PORTS_PER_AIOP  3
#define INFO_WANT_DEF_CLOCK_PRESC 4

static int IdToInfo(int id, int *ret_dword, int info_wanted);

/*-----------------------------------------------------------------
  IdToInfo -
|------------------------------------------------------------------*/
static int IdToInfo(int id, int *ret_val, int info_wanted)
{ 
 int num_ports = 8;
 int modem_device = 0;
 int hub_device = 0;
 int ret_stat = 0;  // ok
 
    switch (id)
    {
      case PCI_DEVICE_RPLUS2:
      case PCI_DEVICE_422RPLUS2:
        num_ports = 2;
      break;

      case PCI_DEVICE_RPLUS4:
        num_ports = 4;
      break;

      case PCI_DEVICE_4Q  :
        num_ports = 4;
      break;

      case PCI_DEVICE_RMODEM4:
        num_ports = 4;
        modem_device = 1;
      break;

      case PCI_DEVICE_8RJ :
        num_ports = 8;
      break;
      case PCI_DEVICE_4RJ :
        num_ports = 4;
      break;
      case PCI_DEVICE_8O  :
        num_ports = 8;
      break;
      case PCI_DEVICE_8I  :
        num_ports = 8;
      break;
      case PCI_DEVICE_RPLUS8:
        num_ports = 8;
      break;
      case PCI_DEVICE_SIEMENS8:
        num_ports = 8;
      break;

      case PCI_DEVICE_16I :
        num_ports = 16;
      break;
      case PCI_DEVICE_SIEMENS16:
        num_ports = 16;
      break;

      case PCI_DEVICE_32I :
        num_ports = 32;
      break;

      case PCI_DEVICE_RMODEM6 :
        num_ports = 6;
        modem_device = 1;
      break;

      case ISA_DEVICE_RPORT4:  // rocketport
        num_ports = 4;
      break;
      case ISA_DEVICE_RPORT8:
        num_ports = 8;
      break;
      case ISA_DEVICE_RPORT16:
        num_ports = 16;
      break;
      case ISA_DEVICE_RPORT32:
        num_ports = 32;
      break;

      case ISA_DEVICE_RMODEM4:  // rocketmodem isa
        num_ports = 4;
        modem_device = 1;
      break;
      case ISA_DEVICE_RMODEM8:  // rocketmodem isa
        num_ports = 8;
        modem_device = 1;
      break;
      case NET_DEVICE_VS1000:
        num_ports = 16;  // vs1000, base is 16, expandable
      break;
      case NET_DEVICE_VS2000:  // vs2000, base is 8?
        num_ports = 8;
        modem_device = 1;
      break;
      case NET_DEVICE_RHUB8:  // vshub-8 port
        num_ports = 8;
        hub_device = 1;
      break;
      case NET_DEVICE_RHUB4:  // vshub-4 port
        num_ports = 4;
        hub_device = 1;
      break;
      default:
        ret_stat = 1; // err, unknown device
      break;
    }

  switch (info_wanted)
  {
    case INFO_WANT_NUMPORTS:
      *ret_val = num_ports;
    break;

    case INFO_WANT_MODEM_DEVICE:
      *ret_val = modem_device;
    break;

    case INFO_WANT_HUB_DEVICE:
      *ret_val = hub_device;
    break;

#if 0
    case INFO_WANT_PORTS_PER_AIOP:
        if (PortsPerAiop > num_ports)
            PortsPerAiop = num_ports;
      *ret_val = PortsPerAiop;

    case INFO_WANT_DEF_CLOCK_PRESC:
      *ret_val = clk_prescaler;
    break;
#endif

    default:
      ret_stat = 2; // unkown info request
    break;
  }
  return ret_stat;
}

/*-----------------------------------------------------------------
  id_to_num_ports - pci model-id number used, rest come from NT5 .inf
    files.
|------------------------------------------------------------------*/
int id_to_num_ports(int id)
{ 
 int stat;
 int num_ports;

  stat = IdToInfo(id, &num_ports, INFO_WANT_NUMPORTS);
  return num_ports;
}

/*-----------------------------------------------------------------
  IsHubDevice -
|------------------------------------------------------------------*/
int IsHubDevice(int Hardware_ID)
{ 
 int stat;
 int ishub;

  stat = IdToInfo(Hardware_ID, &ishub, INFO_WANT_HUB_DEVICE);
  return ishub;
}

/*-----------------------------------------------------------------
  IsModemDevice -
|------------------------------------------------------------------*/
int IsModemDevice(int Hardware_ID)
{ 
 int stat;
 int ismodemdev;

  stat = IdToInfo(Hardware_ID, &ismodemdev, INFO_WANT_MODEM_DEVICE);
  return ismodemdev;
}

/*-----------------------------------------------------------------
  HdwIDStrToID - Parse the hardware ID string obtained by the WinNT
    Pnp system.
    This is broke if we ever get ID's starting digit >= HEX(A,B..)
|------------------------------------------------------------------*/
int HdwIDStrToID(int *Hardware_ID, char *idstr)
{ 
  char *s = idstr;
#define _IS_STR_DIGIT(c) ((c >= '0') && (c <= '9'))
#define _IS_STR_LET_D(c) ((c == 'D') || (c == 'd'))

  if (strlen(s) < 12)  // a isa hardware id
  {
    while ( (*s != 0) && (!_IS_STR_DIGIT(*s)) )  // find digit
      ++s;
  }
  else // a pci hardware id
  {
    while ( (*s != 0) && (!_IS_STR_LET_D(*s)) ) // find "DEV_
      ++s;
    if (*s != 0)
      ++s;  // pass up the 'D'
    while ( (*s != 0) && (!_IS_STR_DIGIT(*s)) )  // find digit
      ++s;
    // asume we found "DEV_000X"
  }

  if (*s == 0)
  {
    *Hardware_ID = 0;  // unknown
    return 1;  // err
  }

  *Hardware_ID = gethint(s, NULL);
  return 0;  // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\nt50.c ===
/*-----------------------------------------------------------------------
| nt50.c - NT5.0 specific code for VSLinkA/RocketPort Windows Install
  Program.

   This compiles into a DLL library which is installed(via INF) into
   the SYSTEM directory.  The INF file also hooks us into the system
   as a property page associated with the device.  Also, our co-installer
   DLL calls into us as well to perform configuration tasks(initial
   install, un-install).

   The .NumDevices option is used to save the number of Devices in
   our configuration.  Under NT50, we don't use it as such.  This setup
   dll only concerns itself with 1 device, and lets NT5.0 OS handle
   the list of devices.  So NumDevices always gets set to 1 under NT5.0
   even if we have more than one device which our driver is controlling.

11-24-98 - add some code toward clean up of files after uninstall, kpb.

Copyright 1998. Comtrol(TM) Corporation.
|-----------------------------------------------------------------------*/
#include "precomp.h"
#include <msports.h>

#define D_Level 0x40

static int write_config(int clear_it);
static int FindPortNodes(void);
static int read_config(void);
static int get_pnp_devicedesc(TCHAR *name);
static int nt5_get_pnp_dev_id(int *id);
static void uninstall_device(void);

int get_device_name(void);
int do_nt50_install(void);

BOOL WINAPI ClassInsProc(
      int func_num,     // our function to carry out.
      LPVOID our_info);  // points to our data struct

static int get_pnp_setup_info(void);
static int get_device_property(char *ret_name, int max_size);
static int get_pnp_isa_address(void);

static void test_config(void);

// following can be turned on to provide a User Interface during the
// install time of the driver.  Only problem is that NT5.0 fires up
// the driver first, and are ports
//#define TRY_UI 1
#ifdef TRY_UI
int DoCLassPropPages(HWND hwndOwner);
int FillClassPropertySheets(PROPSHEETPAGE *psp, LPARAM our_params);
BOOL WINAPI ClassSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam);
#endif

//#define DO_SHOWIT
#ifdef DO_SHOWIT
#define ShowMess(s) OutputDebugString(s);
static void show_install_info(OUR_INFO *pi);
static void show_debug_info(OUR_INFO *pi,
                           ULONG dev_id,
                           TCHAR *desc_str);

static int DumpPnpTree(void);
static void show_tree_node(DEVINST devInst,
                           ULONG dev_id,
                           TCHAR *desc_str);
static void show_tree_node_reg(DEVINST devInst,
                               TCHAR *key_name);

static TCHAR *spdrp_names[] = {
TEXT("DEVICEDESC"),
TEXT("HARDWAREID"),
TEXT("COMPATIBLEIDS"),
TEXT("NTDEVICEPATHS"),
TEXT("SERVICE"),
TEXT("CONFIGURATION"),  // x5
TEXT("CONFIGURATIONVECTOR"),
TEXT("CLASS"),
TEXT("CLASSGUID"),
TEXT("DRIVER"),
TEXT("CONFIGFLAGS"),  // xA
TEXT("MFG"),
TEXT("FRIENDLYNAME"),
TEXT("LOCATION_INFORMATION"),
TEXT("PHYSICAL_DEVICE_OBJECT_NAME"),
TEXT("CAPABILITIES"),
TEXT("UI_NUMBER"),  // x10
TEXT("UPPERFILTERS"),
TEXT("LOWERFILTERS"),
TEXT("BUSTYPEGUID"),  // x13
TEXT("LEGACYBUSTYPE"),
TEXT("BUSNUMBER"),
TEXT("invalid")};

static TCHAR *cm_drp_names[] = {
TEXT("DEVICEDESC"), // DeviceDesc REG_SZ property (RW)
TEXT("HARDWAREID"), // HardwareID REG_MULTI_SZ property (RW)
TEXT("COMPATIBLEIDS"), // CompatibleIDs REG_MULTI_SZ property (RW)
TEXT("NTDEVICEPATHS"), // Unsupported, DO NOT USE
TEXT("SERVICE"), // Service REG_SZ property (RW)
TEXT("CONFIGURATION"), // Configuration REG_RESOURCE_LIST property (R)
TEXT("CONFIGURATIONVECTOR"), // ConfigurationVector REG_RESOURCE_REQUIREMENTS_LIST property (R)
TEXT("CLASS"), // Class REG_SZ property (RW)
TEXT("CLASSGUID"), // ClassGUID REG_SZ property (RW)
TEXT("DRIVER"), // Driver REG_SZ property (RW)
TEXT("CONFIGFLAGS"), // ConfigFlags REG_DWORD property (RW)
TEXT("MFG"), // Mfg REG_SZ property (RW)
TEXT("FRIENDLYNAME"), // 0x0d FriendlyName REG_SZ property (RW)
TEXT("LOCATION_INFORMATION"), // LocationInformation REG_SZ property (RW)
TEXT("PHYSICAL_DEVICE_OBJECT_NAME"), // PhysicalDeviceObjectName REG_SZ property (R)
TEXT("CAPABILITIES"), // 0x10 Capabilities REG_DWORD property (R)
TEXT("UI_NUMBER"), // UiNumber REG_DWORD property (R)
TEXT("UPPERFILTERS"), // UpperFilters REG_MULTI_SZ property (RW)
TEXT("LOWERFILTERS"), // LowerFilters REG_MULTI_SZ property (RW)
TEXT("BUSTYPEGUID"), // Bus Type Guid, GUID, (R)
TEXT("LEGACYBUSTYPE"), // Legacy bus type, INTERFACE_TYPE, (R)
TEXT("BUSNUMBER"), // x16 Bus Number, DWORD, (R)
TEXT("invalid")};

// these are under Control\Class\Guid\Node
static TCHAR *dev_node_key_names[] = {
TEXT("ProviderName"),
TEXT("MatchingDeviceId"),
TEXT("DriverDesc"),
TEXT("InfPath"),
TEXT("InfSection"),
TEXT("isa_board_index"),
NULL};

static TCHAR glob_ourstr[4000];
/*----------------------------------------------------------
 show_install_info - show all the driver install info.
|------------------------------------------------------------*/
static void show_install_info(OUR_INFO *pi)
{
 int i;

  //if (MessageBox( GetFocus(), TEXT("Want Info?"), TEXT("aclass"), MB_YESNO | MB_ICONINFORMATION ) ==
  //   IDYES)
  {
    ShowMess(TEXT("**SPDRP****"));
    glob_ourstr[0] = 0;
    for (i=0; i<(SPDRP_MAXIMUM_PROPERTY-1); i++)
    {
      show_debug_info(pi, i, spdrp_names[i]);
    }
    ShowMess(glob_ourstr);
    //MessageBox( GetFocus(), glob_ourstr, TEXT("aclass"), MB_OK | MB_ICONINFORMATION );
  }
}

/*----------------------------------------------------------
 show_debug_info -
|------------------------------------------------------------*/
static void show_debug_info(OUR_INFO *pi,
                           ULONG dev_id,
                           TCHAR *desc_str)
{
 static TCHAR tmpstr[500];
 static TCHAR showstr[500];
 TCHAR smstr[40];
 ULONG RegType;
 ULONG ReqSize,i;
 unsigned char *b_ptr;
 int stat;

  showstr[0] = 0;

  RegType = 0;
  ReqSize = 0;
  stat = SetupDiGetDeviceRegistryProperty(pi->DeviceInfoSet,
                                   pi->DeviceInfoData,
                                   dev_id,
                                   &RegType,  // reg data type
                                   (PBYTE)tmpstr,
                                   sizeof(tmpstr),
                                   &ReqSize);  // size thing

  if (stat == FALSE)
  {
    stat = GetLastError();
    if (stat == 13)
    {
      return;  // don't display this
    }
    wsprintf(showstr, TEXT("Error:%d[%xH] ReqSize:%d"), stat, stat, ReqSize);
  }
  else if (RegType == REG_SZ)
  {
    wsprintf(showstr, TEXT("SZ:%s"), tmpstr);
  }
  else if (RegType == REG_DWORD)
  {
    wsprintf(showstr, TEXT("Dword:%xH"), *((ULONG *) tmpstr));
  }
  else if (RegType == REG_EXPAND_SZ)
  {
    wsprintf(showstr, TEXT("EXP_SZ:%s"), tmpstr);
  }
  else if (RegType == REG_MULTI_SZ)
  {
    wsprintf(showstr, TEXT("MULTI_SZ:%s"), tmpstr);
  }
  else if (RegType == REG_BINARY)
  {
    lstrcpy(showstr, TEXT("BIN:"));
    b_ptr = (unsigned char *)tmpstr;
    for (i=0; i<ReqSize; i++)
    {
      if ((b_ptr[i] >= 0x20) && (b_ptr[i] < 0x80))
        wsprintf(smstr, TEXT("%c"), b_ptr[i]);
      else
        wsprintf(smstr, TEXT("<%x>"), b_ptr[i]);
      lstrcat(showstr, smstr);
      if (i > 200) break;
    }
  }
  else
  {
    wsprintf(showstr, TEXT("BadType:%xH"), RegType);
  }
  if (lstrlen(showstr) > 200)
    showstr[200] = 0;

  if (lstrlen(glob_ourstr) < 3700)
  {
    lstrcat(glob_ourstr, desc_str);
    lstrcat(glob_ourstr, TEXT(" - "));
    lstrcat(glob_ourstr, showstr);
    lstrcat(glob_ourstr, TEXT("\n"));
  }
}

/*-----------------------------------------------------------------------------
| DumpPnpTree - Dump the pnp tree devnodes.
|-----------------------------------------------------------------------------*/
static int DumpPnpTree(void)
{
  DEVINST     devInst;
  DEVINST     devInstNext;
  CONFIGRET   cr;
  ULONG       walkDone = 0;
  ULONG       len;
  static CHAR buf[800];
  HKEY hKey;
  int  di,pi;
  ULONG val_type;

#if DBG
  //DebugBreak();
#endif

  //cr = CM_Locate_DevNode(&devInst, NULL, 0);

  // Get Root DevNode
  //
  cr = CM_Locate_DevNode(&devInst, NULL, 0);

  if (cr != CR_SUCCESS)
  {
    return 1;  // err
  }

  // Do a depth first search for the DevNode with a matching parameter
  while (!walkDone)
  {
    cr = CR_SUCCESS;
    glob_ourstr[0] = 0;
    lstrcat(glob_ourstr,TEXT("-CM_DRP-----"));
    for (di=CM_DRP_MIN; di<CM_DRP_MAX; di++)
    {
      show_tree_node(devInst, di, cm_drp_names[di-CM_DRP_MIN]);
    }

    lstrcat(glob_ourstr,TEXT("-KEYS--"));
    di = 0;
    while (dev_node_key_names[di] != NULL)
    {
      show_tree_node_reg(devInst, dev_node_key_names[di]);
      ++di;
    }
    ShowMess(glob_ourstr);

#if 0
    // Get the DriverName value
    //
    buf[0] = 0;
    len = sizeof(buf);
    cr = CM_Get_DevNode_Registry_Property(devInst,
              CM_DRP_CLASS, NULL, buf, &len, 0);
    if (cr == CR_SUCCESS && strcmp("Ports", buf) == 0)
    {
      //P_TRACE("Ports");
      // grab the "MatchingDeviceId"
      cr = CM_Open_DevNode_Key(
           devInst,
           KEY_READ,    // IN  REGSAM         samDesired,
           0,           // IN  ULONG          ulHardwareProfile,
           RegDisposition_OpenExisting,
           &hKey,       //OUT PHKEY          phkDevice,
           CM_REGISTRY_SOFTWARE); // IN  ULONG          ulFlags

      if (cr == CR_SUCCESS)
      {
        buf[0] = 0;
        len = sizeof(buf);
        cr = RegQueryValueEx(hKey,
                    TEXT("MatchingDeviceId"),
                    0,
                    &val_type,
                    (PBYTE) buf,
                    &len);
        if (cr != ERROR_SUCCESS)
        {
          buf[0] = 0;
        }

        RegCloseKey(hKey);
      }  // if openreg
    } // if "Ports"
#endif

    // This DevNode didn't match, go down a level to the first child.
    //
    cr = CM_Get_Child(&devInstNext,
                      devInst,
                      0);

    if (cr == CR_SUCCESS)
    {
        devInst = devInstNext;
        continue;
    }

    // Can't go down any further, go across to the next sibling.  If
    // there are no more siblings, go back up until there is a sibling.
    // If we can't go up any further, we're back at the root and we're
    // done.
    //
    for (;;)
    {
      cr = CM_Get_Sibling(&devInstNext,
                          devInst,
                          0);
      
      if (cr == CR_SUCCESS)
      {
          devInst = devInstNext;
          break;
      }

      cr = CM_Get_Parent(&devInstNext,
                         devInst,
                         0);

      if (cr == CR_SUCCESS)
      {
          devInst = devInstNext;
      }
      else
      {
          walkDone = 1;
          break;
      }
    } // for (;;)
  } // while (!walkDone)

  return 2;  // done;
}

/*----------------------------------------------------------
 show_tree_node -
|------------------------------------------------------------*/
static void show_tree_node(DEVINST devInst,
                           ULONG dev_id,
                           TCHAR *desc_str)
{
 CONFIGRET   cr;
 static TCHAR tmpstr[500];
 static TCHAR showstr[500];
 TCHAR smstr[40];
 ULONG RegType;
 ULONG ReqSize,i;
 unsigned char *b_ptr;
 int stat;

  showstr[0] = 0;

  RegType = 0;
  ReqSize = 0;
  cr = CM_Get_DevNode_Registry_Property(devInst,
            dev_id, &RegType, tmpstr, &ReqSize, 0);

  if (cr != CR_SUCCESS)
  {
    stat = GetLastError();
    if (stat == 997)
    {
      return;  // don't display this
    }
    wsprintf(showstr, TEXT("Error:%d[%xH] ReqSize:%d"), stat, stat, ReqSize);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_SZ)
  {
    wsprintf(showstr, TEXT("SZ:%s"), tmpstr);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_DWORD)
  {
    wsprintf(showstr, TEXT("Dword:%xH"), *((ULONG *) tmpstr));
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_EXPAND_SZ)
  {
    wsprintf(showstr, TEXT("EXP_SZ:%s"), tmpstr);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_MULTI_SZ)
  {
    wsprintf(showstr, TEXT("MULTI_SZ:%s"), tmpstr);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_BINARY)
  {
    lstrcpy(showstr, TEXT("BIN:"));
    b_ptr = (unsigned char *)tmpstr;
    for (i=0; i<ReqSize; i++)
    {
      if ((b_ptr[i] >= 0x20) && (b_ptr[i] < 0x80))
        wsprintf(smstr, TEXT("%c"), b_ptr[i]);
      else
        wsprintf(smstr, TEXT("<%x>"), b_ptr[i]);
      lstrcat(showstr, smstr);
      if (i > 200) break;
    }
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else
  {
    wsprintf(showstr, TEXT("BadType:%xH"), RegType);
    //MessageBox( GetFocus(), tmpstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  if (lstrlen(showstr) > 200)
    showstr[200] = 0;

  if (lstrlen(glob_ourstr) < 3700)
  {
    lstrcat(glob_ourstr, desc_str);
    lstrcat(glob_ourstr, TEXT(" - "));
    lstrcat(glob_ourstr, showstr);
    lstrcat(glob_ourstr, TEXT("\n"));
  }
}

/*----------------------------------------------------------
 show_tree_node_reg -
|------------------------------------------------------------*/
static void show_tree_node_reg(DEVINST devInst,
                               TCHAR *key_name)
{
 CONFIGRET   cr;
 static TCHAR tmpstr[500];
 static TCHAR showstr[500];
 TCHAR smstr[40];
 ULONG RegType;
 ULONG ReqSize,i;
 unsigned char *b_ptr;
 int stat;
 TCHAR *desc_str = key_name;
 HKEY hKey;

  showstr[0] = 0;

  cr = CM_Open_DevNode_Key(
       devInst,
       KEY_READ,    // IN  REGSAM         samDesired,
       0,           // IN  ULONG          ulHardwareProfile,
       RegDisposition_OpenExisting,
       &hKey,       //OUT PHKEY          phkDevice,
       CM_REGISTRY_SOFTWARE); // IN  ULONG          ulFlags

  if (cr == CR_SUCCESS)
  {
    RegType = 0;
    ReqSize = 0;

    tmpstr[0] = 0;
    ReqSize = sizeof(tmpstr);
    cr = RegQueryValueEx(hKey,
                key_name,
                0,
                &RegType,
                (PBYTE) tmpstr,
                &ReqSize);
    if (cr != ERROR_SUCCESS)
    {
      tmpstr[0] = 0;
    }

    RegCloseKey(hKey);
  }  // if openreg
  else
  {
    tmpstr[0] = 0;
    ShowMess(TEXT("**Error Opening Key!\n"));
  }

  if (cr != CR_SUCCESS)
  {
    stat = GetLastError();
    //if (stat == 997)
    //{
    //  return;  // don't display this
    //}
    wsprintf(showstr, TEXT("Error:%d[%xH] ReqSize:%d"), stat, stat, ReqSize);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_SZ)
  {
    wsprintf(showstr, TEXT("SZ:%s"), tmpstr);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_DWORD)
  {
    wsprintf(showstr, TEXT("Dword:%xH"), *((ULONG *) tmpstr));
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_EXPAND_SZ)
  {
    wsprintf(showstr, TEXT("EXP_SZ:%s"), tmpstr);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_MULTI_SZ)
  {
    wsprintf(showstr, TEXT("MULTI_SZ:%s"), tmpstr);
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else if (RegType == REG_BINARY)
  {
    lstrcpy(showstr, TEXT("BIN:"));
    b_ptr = (unsigned char *)tmpstr;
    for (i=0; i<ReqSize; i++)
    {
      if ((b_ptr[i] >= 0x20) && (b_ptr[i] < 0x80))
        wsprintf(smstr, TEXT("%c"), b_ptr[i]);
      else
        wsprintf(smstr, TEXT("<%x>"), b_ptr[i]);
      lstrcat(showstr, smstr);
      if (i > 200) break;
    }
    //MessageBox( GetFocus(), showstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  else
  {
    wsprintf(showstr, TEXT("BadType:%xH"), RegType);
    //MessageBox( GetFocus(), tmpstr, desc_str, MB_OK | MB_ICONINFORMATION );
  }
  if (lstrlen(showstr) > 200)
    showstr[200] = 0;

  if (lstrlen(glob_ourstr) < 3700)
  {
    lstrcat(glob_ourstr, desc_str);
    lstrcat(glob_ourstr, TEXT(" - "));
    lstrcat(glob_ourstr, showstr);
    lstrcat(glob_ourstr, TEXT("\n"));
  }
}

#endif

// we are a DLL, so we need a LibMain...
/*----------------------------------------------------------
 LibMain -
|-------------------------------------------------------------*/
BOOL APIENTRY LibMain( HANDLE hDll, DWORD dwReason, LPVOID lpReserved )
{
    //DMess("LibMain");

    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        glob_hinst = hDll;
        DisableThreadLibraryCalls((struct HINSTANCE__ *) hDll);
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_THREAD_ATTACH:
    default:
        break;
    }
    return TRUE;
}


/*----------------------------------------------------------
 DevicePropPage - DLL Entry Point from NT5.0 PnP manager to
   add property sheets.  Not the entry point for NT4.0,
   see nt40.c code WinMain().

    Exported Entry-point for adding additional device manager
    property
    sheet pages.  Registry specifies this routine under
    Control\Class\PortNode::EnumPropPage32="vssetup.dll,DevicePropPage"
    entry.  This entry-point gets called only when the Device
    Manager asks for additional property pages.

Arguments:
      LPVOID pinfo - points to PROPSHEETPAGE_REQUEST, see setupapi.h
      LPFNADDPROPSHEETPAGE pfnAdd - function ptr to call to add sheet.
      LPARAM lParam  - add sheet functions private data handle.

Return Value:
    TRUE on success
    FALSE if pages could not be added
|------------------------------------------------------------*/
BOOL WINAPI DevicePropPage(
      LPVOID pinfo,   // points to PROPSHEETPAGE_REQUEST, see setupapi.h
      LPFNADDPROPSHEETPAGE pfnAdd, // add sheet function
      LPARAM lParam)  // add sheet function data handle?
{
 PSP_PROPSHEETPAGE_REQUEST ppr = (PSP_PROPSHEETPAGE_REQUEST) pinfo;
 PROPSHEETPAGE   psp[NUM_DRIVER_SHEETS];
 HPROPSHEETPAGE  hpage[NUM_DRIVER_SHEETS];
 OUR_INFO *pi;
 int i;
 int stat;

  setup_init();  // build our main structs

  pi = glob_info;  // temporary kludge, unless we don't need re-entrantancy

    // copy the important port handles
  pi->DeviceInfoSet = ppr->DeviceInfoSet;
  pi->DeviceInfoData = ppr->DeviceInfoData;

#ifdef DO_SHOWIT
  if (MessageBox( GetFocus(), TEXT("Want Info?"), TEXT("aclass"), MB_YESNO | MB_ICONINFORMATION ) ==
     IDYES)
  {
    show_install_info(pi);
    DumpPnpTree();
  }
#endif

  //glob_hwnd = hDlg;

  wi->NumDevices = 0;

  // get the name that NT associates with this device, so we can
  // store and retrieve config information based on this also.

  stat = get_device_name();
  if (stat)
  {
    // something is seriously wrong if we can't get our device
    // name.  This is something NT uses as a name.
    DbgPrintf(D_Error, (TEXT("err5f\n")));
  }

  wi->NumDevices = 1;  // for pnp, devices are independent
  get_pnp_setup_info();  // read in pnp info
  get_pnp_devicedesc(wi->dev[0].Name);  // read in pnp description

  get_nt_config(wi);  // get configured vslink device settings.
  if (wi->dev[0].ModelName[0] == 0)
  {
#ifdef S_RK
    if ((wi->dev[0].HardwareId == PCI_DEVICE_RPLUS2) ||
        (wi->dev[0].HardwareId == PCI_DEVICE_422RPLUS2) ||
        (wi->dev[0].HardwareId == PCI_DEVICE_RPLUS4) ||
        (wi->dev[0].HardwareId == PCI_DEVICE_RPLUS8))
    {
      strcpy(wi->dev[0].ModelName, szRocketPortPlus);
    }
    else if ((wi->dev[0].HardwareId == ISA_DEVICE_RMODEM4) ||
             (wi->dev[0].HardwareId == ISA_DEVICE_RMODEM8) ||
             (wi->dev[0].HardwareId == PCI_DEVICE_RMODEM6) ||
             (wi->dev[0].HardwareId == PCI_DEVICE_RMODEM4))
    {
      strcpy(wi->dev[0].ModelName, szRocketModem);
    }
    else
    {
      strcpy(wi->dev[0].ModelName, szRocketPort);
    }
    //szRocketPort485
#endif

#ifdef S_VS
    if (wi->dev[0].HardwareId == NET_DEVICE_VS2000)
    {
      strcpy(wi->dev[0].ModelName, szVS2000);
    }
    else if ((wi->dev[0].HardwareId == NET_DEVICE_RHUB8) ||
        (wi->dev[0].HardwareId == NET_DEVICE_RHUB4))
    {
      strcpy(wi->dev[0].ModelName, szSerialHub);
    }
    else // if (wi->dev[0].HardwareId == NET_DEVICE_VS1000)
    {
      strcpy(wi->dev[0].ModelName, szVS1000);
    }
#endif

  }
  validate_config(1);

  //test_config();

  // if 0 dev-nodes setup, add 1 for the user.
  if (wi->NumDevices == 0)
  {
    ++wi->NumDevices;
    validate_device(&wi->dev[0], 1);
  }

  copy_setup_init();  // make a copy of config data for change detection

  FillDriverPropertySheets(&psp[0], (LPARAM)pi);

  // allocate our "Setting" sheet
  for (i=0; i<NUM_DRIVER_SHEETS; i++)
  {
    hpage[i] = CreatePropertySheetPage(&psp[i]);
    if (!hpage[i])
    {
      DbgPrintf(D_Error,(TEXT("err1a\n")));
      return FALSE;
    }

    // add the thing in.
    if (!pfnAdd(hpage[i], lParam))
    {
      DbgPrintf(D_Error,(TEXT("err1b\n")));
      DestroyPropertySheetPage(hpage[i]);  // error, dump it
      return FALSE;
    }
  }
 return TRUE;
}

/*------------------------------------------------------------------------
| ClassInsProc - Class Install entry for NT5.0 setup of driver.
    The co-class installer file(ctmasetp.dll,..) gets called at inital
    setup time, and calls us to bring up an initial user interface,
    or to handle other items.
|------------------------------------------------------------------------*/
BOOL WINAPI ClassInsProc(
      int func_num,     // our function to carry out.
      LPVOID our_info)  // points to our data struct
{
  int stat;
  //TCHAR tmpstr[200];
  typedef struct {
    ULONG size;
    HDEVINFO         DeviceInfoSet;  // a plug & play context handle
    PSP_DEVINFO_DATA DeviceInfoData; // a plug & play context handle
  } CLASS_OUR_INFO;
  CLASS_OUR_INFO *ci;
  OUR_INFO *pi;
  int i;

  switch (func_num)
  {
    case 0x40:  // RocketPort Class Install time.
    case 0x41:  // RocketPort Class Install time, quite install
    case 0x80:  // VS Class Install time.
    case 0x81:  // VS Class Install time, quite install
#if 0
    // don't pop up user interface on install, just use defaults
    // as best we can for now.

      ci = (CLASS_OUR_INFO *) our_info;
      setup_init();  // build our main structs

      pi = glob_info;  // temporary kludge, unless we don't need re-entrantancy

      // copy the important port handles
      pi->DeviceInfoSet = ci->DeviceInfoSet;
      pi->DeviceInfoData = ci->DeviceInfoData;

      //glob_hwnd = hDlg;
      wi->NumDevices = 1;

      // get the name that NT associates with this device, so we can
      // store and retrieve config information based on this also.
      stat = get_device_name();
      {
        get_pnp_setup_info();
        get_nt_config(wi);  // get configured vslink device settings.
        //validate_config();
      }
      if (stat)
      {
        // something is seriously wrong if we can't get our device
        // name.  This is something NT uses as a name.
        DbgPrintf(D_Error,(TEXT("err5f\n")));
      }

      // if 0 dev-nodes setup, add 1 for the user.
      if (wi->NumDevices == 0)
      {
        ++wi->NumDevices;
        validate_device(&wi->dev[0], 1);
      }

      copy_setup_init();  // make a copy of config data for change detection

      validate_config(1);  // make sure port names are setup

      if ((func_num & 1) == 0) // normal
      {
        DoDriverPropPages(GetFocus());  // in nt40.c
        // force it to save things off(probably should disable
        // cancel button, instead of this kludge).
        do_nt50_install();
      }
      else  // quite
      {
        wi->ip.prompting_off = 1;  // turn our_message() prompting off.
        do_nt50_install();
      }
#endif
    break;

    case 0x42:  // UnInstall RocketPort Device time.
    case 0x82:  // UnInstall VS Device time.
      DbgPrintf(D_Test, (TEXT("uninstall time\n")));

      ci = (CLASS_OUR_INFO *) our_info;
      setup_init();  // build our main structs

      pi = glob_info;  // temporary kludge, unless we don't need re-entrantancy
      // copy the important port handles
      pi->DeviceInfoSet = ci->DeviceInfoSet;
      pi->DeviceInfoData = ci->DeviceInfoData;
      wi->NumDevices = 1;

      // get the name that NT associates with this device, so we can
      // store and retrieve config information based on this also.
      stat = get_device_name();
      if (stat == 0)
      {
        get_pnp_setup_info();
        //get_nt_config(wi);  // get configured vslink device settings.
        //validate_config();
        uninstall_device();
      }
    break;

    default:
      return 1;  // error, bad func_num
    break;
  }  // switch

  return 0;
}

/*-----------------------------------------------------------------------------
| get_pnp_setup_info - 
|-----------------------------------------------------------------------------*/
static int get_pnp_setup_info(void)
{
 static TCHAR tmpstr[600];
 TCHAR *ptr;
 int stat;
 int Hardware_ID = 0;

  // grab the board type information.  Tells us what type of
  // board we have
  stat = get_device_property(tmpstr, 580);
  if (stat != 0)
    return 1;
  DbgPrintf(D_Level, (TEXT("dev_prop:%s\n"), tmpstr) );

  // Find out what the PnP manager thinks my NT Hardware ID is
  // "CtmPort0000" for RocketPort port,
  // "CtmVPort0000" for VS port,
  // "CtmRK1002" for isa-board rocketport,
  // "CtmRM1002" for isa-board rocketmodem,
  // "CtmVS1003" for VS1000
  // for pci we are getting a multi-wstring, 400 bytes long with
  //  "PCI\VEN_11FE&DEV_0003&SUBSYS00000...",0,"PCI\VEN.."

  stat = HdwIDStrToID(&Hardware_ID, tmpstr);
  if (stat)
  {
    DbgPrintf(D_Error, (TEXT("Err, Unknown pnpid:%s\n"), tmpstr))
  }

  stat = id_to_num_ports(Hardware_ID);

  if ((Hardware_ID & 0xfff) == 0)  // marked as pci
    wi->dev[0].IoAddress = 1;  // indicate to setup prog it is a PCI board

  if (Hardware_ID & 0x1000)  // marked as isa
    get_pnp_isa_address();

  // correct number of ports setting if it doesn't match
  //if (wi->dev[0].NumPorts != stat)
  //{
  //  DbgPrintf(D_Level, (TEXT("Correct NumPorts!\n")));
    wi->dev[0].NumPorts = stat;
  //}

  wi->dev[0].HardwareId = Hardware_ID;

  // check for HubDevice, ModemDevice, etc.
  if (IsHubDevice(Hardware_ID))
    wi->dev[0].HubDevice = 1;

  if (IsModemDevice(Hardware_ID))
    wi->dev[0].ModemDevice = 1;

  DbgPrintf(D_Level, (TEXT("Num Ports:%d\n"),stat));

  return 0;
}

/*-----------------------------------------------------------------------------
| get_device_property - return "rckt1003", or whatever, see INF file for
   selections.  For PCI this returns a long multi-sz string.
|-----------------------------------------------------------------------------*/
static int get_device_property(char *ret_name, int max_size)
{
  int stat, i,j;
  ULONG RegType;
  ULONG ReqSize;

  ret_name[0] = 0;
  stat = SetupDiGetDeviceRegistryProperty(glob_info->DeviceInfoSet,
                                 glob_info->DeviceInfoData,
                                 SPDRP_HARDWAREID,
                                 &RegType,  // reg data type
                                 (PBYTE)ret_name,
                                 max_size,
                                 &ReqSize);  // size thing
  if (stat == FALSE)
  {
    return 1;  // err
  }
  if ((RegType != REG_MULTI_SZ) && (RegType != REG_SZ))
  {
    return 2;  // err
    // error
  }

  return 0;  // ok
}

/*-----------------------------------------------------------------------------
| our_nt50_exit - return 1 if not allowing to exit.  return 0 if ok to exit.
|-----------------------------------------------------------------------------*/
int our_nt50_exit(void)
{
 int stat;

 OUR_INFO *pi;
 DWORD  DataSize;
 DWORD DataType;
 DWORD dstat;
 DWORD Val;
 HKEY   hkey;

  pi = glob_info;  // temporary kludge, unless we don't need re-entrantancy
  {
    stat = do_nt50_install();

    if (wi->NeedReset)
      our_message(&wi->ip,RcStr((MSGSTR+4)), MB_OK);

    write_config(1);  // clear out msports claims
    write_config(0);  // reclaim any new changed port names
  }
  return 0; 
}

/*-----------------------------------------------------------------------------
| get_device_name - return name in wi->ip.szNt50DevObjName[], ret 0 on success.
   Pnp puts config data into a registry node associated with the device.
   We put a lot of our config information into a related registry node.
   This related node is derived by and index saved and read from the pnp-node.
   So the first device added we assign a index of 0, and get a derived name
   of "Device0".  The 2nd device we add to the system sees the first, and
   saves an index value of 1, to get a associated device name of "Device1".

   The driver actually writes these index values out to the registry, not
   the setup program.   This is because the driver fires up before setup
   has a chance to run.
|-----------------------------------------------------------------------------*/
int get_device_name(void)
{
  int i;
  int stat;

  i = 0;
  stat = nt5_get_pnp_dev_id(&i);
  if (stat)
  {
    DbgPrintf(D_Test,(TEXT("failed to get pnp id\n")))
  }
  wsprintf(wi->ip.szNt50DevObjName, "Device%d", i);

  DbgPrintf(D_Test,(TEXT("pnp idstr:%s\n"), wi->ip.szNt50DevObjName))

  return 0;  // ok
}

/*-----------------------------------------------------------------------------
| nt5_get_pnp_dev_id - Get pnp device ID.  Pnp can have devices come and go
   dynamically, so a simple list of devices does not work. This is because
   we are no longer in charge of the master list.  We just get called
   from ths OS, which handles half of the installation.  This approximates
   a simple list of devices by reading a unique "Device#" number which the
   driver creates and stores in the software key:
   Driver:
     Upon startup, reads Pnp_Software_Reg_Area\CtmNodeID
     if (not exist)
     {
       derive unique device id number by enumerating
         Service\Rocketport\Parameters\"Device#" key entries.
       Add this key entry and also save number off as CtmNodeID.
     }
     Read in its device configuration from 
         Service\Rocketport\Parameters\"Device#" key.
   Setup Config Program:
     Upon startup, reads Pnp_Software_Reg_Area\CtmNodeID
     for its "Device#" to use in reading reg config area:
         Service\Rocketport\Parameters\"Device#" key entries.

Note on pnp registr areas:

  Hardware key is something like:
    HKLM\CurrentControlSet\Enum\Root\MultiPortSerial\0000   ; ISA or net device
    or 
    HKLM\CurrentControlSet\Enum\VEN_11FE&DEV......\0000   ; PCI device
    or (vs driver bus enumerated port entry):
    HKLM\CurrentControlSet\Enum\CtmvPort\RDevice\10&Port000 ; enumerated port

  Software key is something like:
    HKLM\CurrentControlSet\Control\Class\{50906CB8-....}\0000   ; MPS
    or for a port:
    HKLM\CurrentControlSet\Control\Class\{4D36E978-....}\0000   ; PORTS

  The hardware key is a reg. tree structure which reflects the hardware
  configuration.  The software key is more of a flat reg. structure
  which reflects the devices in the system.  Software area uses GUID
  names to catagorize and name types of hardware.

  The Hardware keys are hidden by default in the NT5 registry.
  Use a tool called PNPREG.EXE /U to Unlock this area, then regedit
  will see beyond enum.  PNPREG /L will lock(hide) it.

  The hardware key contains a link to the software key.
|-----------------------------------------------------------------------------*/
static int nt5_get_pnp_dev_id(int *id)
{
 HKEY hkey;
 int stat;
 DWORD id_dword;

  stat = nt5_open_dev_key(&hkey);
  if (stat)
  {
    *id = 0;
    return 1;
  }
  stat = reg_get_dword(hkey, "", "CtmNodeId", &id_dword);
  reg_close_key(hkey);
  if (stat)
  {
    // it should have been there, the driver should set this up to
    // a unique index value.  But if not, we use 0.
    *id = 0;
    return 2;
  }
  // return the unique index value which is used to derive the
  // registry configuration area "Device#".
  *id = (int) id_dword;

  return 0;
}

/*-----------------------------------------------------------------------------
| nt5_open_dev_key -
|-----------------------------------------------------------------------------*/
int nt5_open_dev_key(HKEY *hkey)
{
  CONFIGRET   cr;

  cr = CM_Open_DevNode_Key(
           glob_info->DeviceInfoData->DevInst,
           KEY_ALL_ACCESS,
           0,           
           RegDisposition_OpenExisting,
           hkey,       
           CM_REGISTRY_SOFTWARE); // _SOFTWARE worked!(under CLASS)
           //CM_REGISTRY_HARDWARE); // _HARDWARE no open!
           //CM_REGISTRY_CONFIG); // _CONFIG wrote under HardwareConfig

  if (cr != CR_SUCCESS)
  {
    DbgPrintf(D_Error,(TEXT("nt50 pnp reg open fail:%d\n"), GetLastError()));
    *hkey = NULL;
    return 1;
  }
  return 0;
}

#if DBG
/*-----------------------------------------------------------------------------
| read_config - Save the config for the device  Just a test.
|-----------------------------------------------------------------------------*/
static int read_config(void)
{
int stat;

 DWORD  DataSize;
 DWORD DataType;
 DWORD Err;
 DWORD Val;
 HKEY   hkey;
  DEVINST     devInst;
  CONFIGRET   cr;


static char *szNumPorts = {"NumPorts"};
static char *szTestVal = {"TestVal"};
  stat = 0;

  DbgPrintf(D_Test,(TEXT("read config\n")));
  if((hkey = SetupDiOpenDevRegKey(glob_info->DeviceInfoSet,
                                  glob_info->DeviceInfoData,
                                  DICS_FLAG_GLOBAL,
                                  0,
                                  DIREG_DEV,
                                  //DIREG_DRV,
                                  KEY_READ)) == INVALID_HANDLE_VALUE) {
      DbgPrintf(D_Error,(TEXT("DI open fail:%xH\n"), GetLastError()));
      stat = 1;
  }
  if (stat == 0)
  {
    DataSize = sizeof(DWORD);   // max size of return str
    Err = RegQueryValueEx(hkey, szNumPorts, NULL, &DataType,
                        (BYTE *) &Val, &DataSize);
    if (Err != ERROR_SUCCESS)
    {
        DbgPrintf(D_Error,(TEXT("OpenDevReg fail\n")));
        Val = 0;
    }
    DbgPrintf(D_Test,(TEXT("NumPorts=%d\n"), Val));
    RegCloseKey(hkey);
  }

  DbgPrintf(D_Test,(TEXT("write config\n")));
  stat = 0;
  if((hkey = SetupDiOpenDevRegKey(glob_info->DeviceInfoSet,
                                  glob_info->DeviceInfoData,
                                  DICS_FLAG_GLOBAL,
                                  0,
                                  DIREG_DEV,
                                  //DIREG_DRV,
                                  //KEY_ALL_ACCESS)) == INVALID_HANDLE_VALUE) {
                                  KEY_WRITE)) == INVALID_HANDLE_VALUE) {
      DbgPrintf(D_Error,(TEXT("DI write open fail:%xH\n"), GetLastError()));
      stat = 1;
  }
  if (stat == 0)
  {
    stat = reg_set_dword(hkey, "", szTestVal, 0x1234);
    if (stat)
    {
      DbgPrintf(D_Error,(TEXT("write val fail\n")));
    }
    RegCloseKey(hkey);
  }

  devInst = glob_info->DeviceInfoData->DevInst;
  if (devInst == 0)
  {
    DbgPrintf(D_Error,(TEXT("err6g\n")));
    return 1;  // err
  }

  cr = CM_Open_DevNode_Key(
           devInst,
           KEY_READ,    // IN  REGSAM         samDesired,
           0,           // IN  ULONG          ulHardwareProfile,
           RegDisposition_OpenExisting,
           &hkey,       //OUT PHKEY          phkDevice,
           //CM_REGISTRY_SOFTWARE); // _SOFTWARE worked!(under CLASS)
           CM_REGISTRY_HARDWARE); // _HARDWARE no open!
           //CM_REGISTRY_CONFIG); // _CONFIG wrote under HardwareConfig

  if (cr == CR_SUCCESS)
  {
    DataSize = sizeof(DWORD);   // max size of return str
    Err = RegQueryValueEx(hkey, szNumPorts, NULL, &DataType,
                        (BYTE *) &Val, &DataSize);
    if (Err != ERROR_SUCCESS)
    {
        DbgPrintf(D_Error,(TEXT("Reg query fail\n")));
        Val = 0;
    }
    DbgPrintf(D_Test,(TEXT("cr NumPorts=%d\n"), Val));
    RegCloseKey(hkey);
  }
  else
  {
    DbgPrintf(D_Error,(TEXT("CM open fail:%d\n"), GetLastError()));
  }

  cr = CM_Open_DevNode_Key(
           devInst,
           //KEY_ALL_ACCESS,
           KEY_WRITE,
           0,           
           RegDisposition_OpenExisting,
           &hkey,       
           //CM_REGISTRY_SOFTWARE); // _SOFTWARE worked!(under CLASS)
           CM_REGISTRY_HARDWARE); // _HARDWARE no open!
           //CM_REGISTRY_CONFIG); // _CONFIG wrote under HardwareConfig

  if (cr == CR_SUCCESS)
  {
    stat = reg_set_dword(hkey, "", szTestVal, 0x1234);
    if (stat)
    {
      DbgPrintf(D_Error,(TEXT("write val fail\n")));
    }
    else
    {
      DbgPrintf(D_Test,(TEXT("write val ok\n")));
    }
    RegCloseKey(hkey);
  }
  else
  {
    DbgPrintf(D_Error,(TEXT("CM write open fail:%d\n"), GetLastError()));
  }

  return 0;
}
#endif

/*-----------------------------------------------------------------------------
| get_pnp_devicedesc -
|-----------------------------------------------------------------------------*/
static int get_pnp_devicedesc(TCHAR *name)
{
 CONFIGRET cr;
 DWORD len;
  // Get the Device name
  len = 60;

  cr = CM_Get_DevNode_Registry_Property(glob_info->DeviceInfoData->DevInst,
            CM_DRP_DEVICEDESC,
            NULL,
            (PBYTE)name,
            &len,
            0);

  if (cr != CR_SUCCESS)
  {
    DbgPrintf(D_Error,(TEXT("err, no fr.name.\n")));
    return 2;  // err
  }
  DbgPrintf(D_Test, (TEXT("get friendlyname:%s\n"), name));
  return 0;  // ok
}

#if 0
/*-----------------------------------------------------------------------------
| set_pnp_devicedesc -
|-----------------------------------------------------------------------------*/
static int set_pnp_devicedesc(TCHAR *name)
{
 CONFIGRET cr;

  // Set the Device name

  cr = CM_Set_DevNode_Registry_Property(
          glob_info->DeviceInfoData->DevInst,
          CM_DRP_DEVICEDESC,
          (PBYTE)name,
          (lstrlen(name) + 1) * sizeof(TCHAR),
          0);

  if (cr != CR_SUCCESS)
  {
    DbgPrintf(D_Error,(TEXT("err3d\n")));
    return 2;  // err
  }
  return 0;  // ok
}
#endif

/*-----------------------------------------------------------------------------
| write_config - Save the config for the device - Set pnp port names so
   they match our configuration.  Also, try to keep MSPORTS.DLL com-port
   name database in sync with our stuff by detecting when our pnp comport
   name changes, and calling msports routines to free and claim port names.

   We call this routine once with clear_it SET, then call it again with
   it clear.  This is because we must clear ALL port claims from msports.dll
   (which holds a database in services\serial reg area) prior to re-claiming
   new port names.  This is because if we overlap, we run into trouble.
|-----------------------------------------------------------------------------*/
static int write_config(int clear_it)
{
 DEVINST devInst;
 Device_Config *dev;
 Port_Config *port;
 int  i,pi, str_i, stat;
 CONFIGRET cr;
 ULONG len;
 TCHAR buf[120];
 TCHAR curname[40];
 HKEY hKey;
 int port_index = 0;
 int port_i;
 ULONG val_type;
 HCOMDB hPort = NULL;

  FindPortNodes();  // fill in all port->hPnpNode

  for(i=0; i<wi->NumDevices; i++)   // Loop through all possible boards
  {
    dev = &wi->dev[i];
    for(pi=0; pi<dev->NumPorts; pi++)   // Loop through all ports
    {
      port = &dev->ports[pi];

      if (port->hPnpNode != 0) // have a DEVINST handle for it.
      {
        devInst = (DEVINST) port->hPnpNode;

        if (!clear_it)
        {
          len = sizeof(buf);
#ifdef S_RK
          wsprintf(buf, "Comtrol RocketPort %d (%s)", port_index, port->Name);
#else
          wsprintf(buf, "Comtrol VS Port %d (%s)", port_index, port->Name);
#endif
          cr = CM_Set_DevNode_Registry_Property(devInst,
                                        CM_DRP_FRIENDLYNAME,
                                        (PBYTE)buf,
                                        (lstrlen(buf) + 1) * sizeof(TCHAR),
                                        0);
          if (cr != CR_SUCCESS)
          {
            DbgPrintf(D_Error,(TEXT("err7d\n")));
          }
        }
        cr = CM_Open_DevNode_Key(
             devInst,
             KEY_ALL_ACCESS,   // IN  REGSAM         samDesired,
             0,           // IN  ULONG          ulHardwareProfile,
             RegDisposition_OpenExisting,
             &hKey,       //OUT PHKEY          phkDevice,
             CM_REGISTRY_HARDWARE); // IN  ULONG          ulFlags

        wsprintf(buf, "%s", port->Name);
        if (cr == CR_SUCCESS)
        {
          curname[0] = 0;
          len = sizeof(curname);
          cr = RegQueryValueEx(hKey,
                    TEXT("PortName"),
                    0,
                    &val_type,
                    (PBYTE) curname,
                    &len);
          if (cr != CR_SUCCESS)
          {
            DbgPrintf(D_Error,(TEXT("error reading portname\n")));
          }

          if (_tcsicmp(curname, buf) != 0)  // it's changed!
          {
            DbgPrintf(D_Test,(TEXT("com name from:%s, to %s\n"), curname, buf));
            if (hPort == NULL)
              cr = ComDBOpen(&hPort);
            if (hPort == NULL)
            {
              DbgPrintf(D_Error,(TEXT("err dbcom 1d\n")));
            }
            else
            {
              if (clear_it)
              {
                // clear out name
                port_i = ExtractNameNum(curname);
                if ((port_i > 0) && (port_i < 256))
                {
                  ComDBReleasePort(hPort, port_i);
                  DbgPrintf(D_Test,(TEXT("Free Old:%d\n"), port_i));
                }
              }
              else
              {
                port_i = ExtractNameNum(buf);
                if ((port_i > 0) && (port_i < 256))
                {
                  ComDBClaimPort(hPort, port_i, 1 /* force*/, NULL);
                  DbgPrintf(D_Test,(TEXT("Claim New:%d\n"), port_i));
                }
              }
            }
            if (!clear_it)
            {
              RegSetValueEx(hKey,
                          "PortName",
                          0,
                          REG_SZ,
                          (PBYTE) buf,
                          (lstrlen(buf) + 1) * sizeof(TCHAR) );
            }
          }  // not matched, com-port name changed
          RegCloseKey(hKey);
        }  // opened dev node key
        else {
          DbgPrintf(D_Error,(TEXT("err7e\n")));
             }
      } // if (port->hPnpNode != 0)
      else
      {
        DbgPrintf(D_Level,(TEXT("Bad Pnp Name Find\n")));
      }
      ++port_index;
    }  // for(pi=0; pi<dev->NumPorts; pi++)
  } // for(i=0; i<wi->NumDevices; i++)

  if (hPort != NULL)
    ComDBClose(hPort);

  return 0; 
}

/*------------------------------------------------------------------------
| uninstall_device - 
|------------------------------------------------------------------------*/
static void uninstall_device(void)
{

#ifdef DO_SHOWIT
  if (MessageBox( GetFocus(), TEXT("UNINSTALL, Want Info?"), TEXT("aclass"), MB_YESNO | MB_ICONINFORMATION ) ==
     IDYES)
  {
    show_install_info(glob_info);
    DumpPnpTree();
  }
#endif

  clear_nt_device(wi);

  //if (this_is_last_device)
  //  remove_driver(1);
}

/*-----------------------------------------------------------------------------
| FindPortNodes - Find the pnp tree devnodes which hold our port names.
    Put the handle into our port config struct for easy access.
    We start the search at our device node.
|-----------------------------------------------------------------------------*/
static int FindPortNodes(void)
{
  DEVINST     devInst;
  DEVINST     devInstNext;
  CONFIGRET   cr;
  ULONG       walkDone = 0;
  ULONG       len;
  CHAR buf[120];
  HKEY hKey;
  int  di,pi;
  int port_index;
  Device_Config *dev;
  Port_Config *port;
  ULONG val_type;

  // clear out all stale pnpnode handles before re-creating this list
  for(di=0; di<wi->NumDevices; di++)   // Loop through all possible boards
  {
    dev = &wi->dev[di];
    for(pi=0; pi<dev->NumPorts; pi++)   // Loop through all ports
    {
      dev->ports[pi].hPnpNode = 0;
    }
  }

#if 0
  // Get Root DevNode
  //
  cr = CM_Locate_DevNode(&devInst, NULL, 0);

  if (cr != CR_SUCCESS)
  {
    return 1;  // err
  }
#endif
  devInst = glob_info->DeviceInfoData->DevInst;
  if (devInst == 0)
  {
    DbgPrintf(D_Error,(TEXT("err6g\n")));
    return 1;  // err
  }

DbgPrintf(D_Level, (TEXT("search nodes\n")));

  cr = CM_Get_Child(&devInstNext,
                    devInst,
                    0);

  while (cr == CR_SUCCESS)
  {
    devInst = devInstNext;

    // Get the DriverName value
    //
    buf[0] = 0;
    len = sizeof(buf);
    cr = CM_Get_DevNode_Registry_Property(devInst,
              CM_DRP_CLASS, NULL, buf, &len, 0);
    if (cr == CR_SUCCESS && strcmp("Ports", buf) == 0)
    {
      // grab the "MatchingDeviceId"
      cr = CM_Open_DevNode_Key(
           devInst,
           KEY_READ,    // IN  REGSAM         samDesired,
           0,           // IN  ULONG          ulHardwareProfile,
           RegDisposition_OpenExisting,
           &hKey,       //OUT PHKEY          phkDevice,
           CM_REGISTRY_SOFTWARE); // IN  ULONG          ulFlags

      if (cr == CR_SUCCESS)
      {
        buf[0] = 0;
        len = sizeof(buf);
        cr = RegQueryValueEx(hKey,
                    TEXT("MatchingDeviceId"),
                    0,
                    &val_type,
                    (PBYTE) buf,
                    &len);
        if (cr != ERROR_SUCCESS)
        {
          buf[0] = 0;
        }
#ifdef S_RK
        if (strstr(buf, "ctmport") != NULL)  // found it
#else
        if (strstr(buf, "ctmvport") != NULL)  // found it
#endif
        {
          int k, dev_num;

          k = sscanf(&buf[8], "%d", &dev_num);
          if (k==1)
          {
            port_index = 0;
            // found a vs port node, so save a reference to this node
            // in our config struct for simple reference.
            //save_pnp_node(j, devInst);
            for(di=0; di<wi->NumDevices; di++)   // Loop through all possible boards
            {
              dev = &wi->dev[di];
              for(pi=0; pi<dev->NumPorts; pi++)   // Loop through all ports
              {
                port = &dev->ports[pi];
                if (port_index == dev_num) // found our matching index
                {
                  port->hPnpNode = (HANDLE) devInst;
                }
                ++port_index;
              }  // for pi
            }  // for di
          }  // if scanf
        }  // if strstr "ctmvport"

        RegCloseKey(hKey);
      }  // if openreg
    } // if "Ports"

    // Get next child
    cr = CM_Get_Sibling(&devInstNext,
                          devInst,
                          0);
  } // while (!cr_success)

  return 2;  // done;
}

/*-----------------------------------------------------------------------------
| do_nt50_install -
|-----------------------------------------------------------------------------*/
int do_nt50_install(void)
{
 int stat = 0;
 int do_remove = 0;
 int do_modem_inf = 0;
 static int in_here = 0;

  if (in_here)  // problem hitting OK button twice(sets off two of these)
    return 2;

  in_here = 1;

  if (wi->nt_reg_flags & 4) // initial install, no setupversion string found
  {
    if (setup_utils_exist())
    {
      setup_make_progman_group(1);  // 1=with prompt
    }
    wi->nt_reg_flags &= ~4;
  }

  if (!wi->ChangesMade)
    send_to_driver(0);  // evaluate if anything changed

  stat = send_to_driver(1);
  stat = set_nt_config(wi);
  in_here = 0;

  if (stat)
    return 1; // error

  return 0; // ok
}

/*----------------------------------------------------------------------------
| get_pnp_isa_address - 
|-----------------------------------------------------------------------------*/
static int get_pnp_isa_address(void)
{
  int IoBase;
  LOG_CONF LogConfig;
  RES_DES ResDes;
  IO_RESOURCE IoResource;
  //IRQ_RESOURCE IrqResource;
  CONFIGRET cr;
  int status;

  status = CM_Get_First_Log_Conf(&LogConfig,
             (DEVINST)(glob_info->DeviceInfoData->DevInst),
             ALLOC_LOG_CONF);
  //if (status != CR_SUCCESS)
  //  mess(&wi->ip, "No ALLOC lc %xH\n",status);

  if (status != CR_SUCCESS)
    return 1;

  // get the Io base port
  status = CM_Get_Next_Res_Des(&ResDes, LogConfig, ResType_IO, NULL, 0);
  if (status != CR_SUCCESS)
  {
    return 2;
  }

  cr = CM_Get_Res_Des_Data(ResDes, &IoResource, sizeof(IO_RESOURCE), 0);
  CM_Free_Res_Des_Handle(ResDes);

  if(cr != CR_SUCCESS)
  {
    return 3;
  }

  IoBase = (int)IoResource.IO_Header.IOD_Alloc_Base;
  //mess(&wi->ip, "OK 1c, Base:%xH\n", IoBase);

  if ((IoBase < 0x400) && (IoBase >= 0x100))
    wi->dev[0].IoAddress = IoBase;
  else
    wi->dev[0].IoAddress = 0;

  return 0;
}

#if 0
/*----------------------------------------------------------------------------
| test_config - See what we can do concerning the allocated IO resources.
|-----------------------------------------------------------------------------*/
static void test_config(void)
{
  int IoBase;
  LOG_CONF LogConfig;
  RES_DES ResDes;
  IO_RESOURCE IoResource;
  //IRQ_RESOURCE IrqResource;
  CONFIGRET cr;
  int status;

  //glob_ourstr[0] = 0;
  //lstrcat(glob_ourstr, "Test Config:\n");
//  mess(&wi->ip, "Test Config");

  status = CM_Get_First_Log_Conf(&LogConfig,
             (DEVINST)(glob_info->DeviceInfoData->DevInst),
             BOOT_LOG_CONF);
  if (status != CR_SUCCESS)
    mess(&wi->ip, "No BOOT lc %xH\n",status);
  else
    mess(&wi->ip, "Got BOOT lc\n");

  status = CM_Get_First_Log_Conf(&LogConfig,
             (DEVINST)(glob_info->DeviceInfoData->DevInst),
             FORCED_LOG_CONF);
  if (status != CR_SUCCESS)
    mess(&wi->ip, "No FORCED lc %xH\n",status);
  else
    mess(&wi->ip, "Got FORCED lc\n");

  status = CM_Get_First_Log_Conf(&LogConfig,
             (DEVINST)(glob_info->DeviceInfoData->DevInst),
             BASIC_LOG_CONF);
  if (status != CR_SUCCESS)
    mess(&wi->ip, "No BASIC lc %xH\n",status);
  else
    mess(&wi->ip, "Got BASIC lc\n");

  status = CM_Get_First_Log_Conf(&LogConfig,
             (DEVINST)(glob_info->DeviceInfoData->DevInst),
             FORCED_LOG_CONF);
  if (status != CR_SUCCESS)
    mess(&wi->ip, "No FORCED lc %xH\n",status);
  else
    mess(&wi->ip, "Got FORCED lc\n");

  status = CM_Get_First_Log_Conf(&LogConfig,
             (DEVINST)(glob_info->DeviceInfoData->DevInst),
             ALLOC_LOG_CONF);
  if (status != CR_SUCCESS)
    mess(&wi->ip, "No ALLOC lc %xH\n",status);
  else
    mess(&wi->ip, "Got ALLOC lc\n");

  if (status != CR_SUCCESS)
    return;
  //
  // First, get the Io base port
  //
  status = CM_Get_Next_Res_Des(&ResDes, LogConfig, ResType_IO, NULL, 0);
  if (status != CR_SUCCESS)
  {
    mess(&wi->ip, "Error 1b\n");
    return;
  }
  mess(&wi->ip, "OK 1b\n");

  cr = CM_Get_Res_Des_Data(ResDes, &IoResource, sizeof(IO_RESOURCE), 0);
  CM_Free_Res_Des_Handle(ResDes);

  if(cr != CR_SUCCESS)
  {
    mess(&wi->ip, "Error 1c\n");
    return;
  }

  IoBase = (int)IoResource.IO_Header.IOD_Alloc_Base;
  mess(&wi->ip, "OK 1c, Base:%xH\n", IoBase);

   //OldIrq = IrqResource.IRQ_Header.IRQD_Alloc_Num;

#if 0
  // We don't want to popup the configuration UI if the 'quiet install' flag is
  // set _and_ we already have a forced config (pre-install support).
  if (CM_Get_First_Log_Conf(&ForcedLogConf, glob_info->DeviceInfoData->DevInst, FORCED_LOG_CONF) == CR_SUCCESS)
  {
    CM_Free_Log_Conf_Handle(ForcedLogConf);

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams))
    {
      if(FirstTime && (DeviceInstallParams.Flags & DI_QUIETINSTALL))
      {
        DisplayPropSheet = FALSE;
      }
    }
  }
#endif
}
#endif


#ifdef TRY_UI

#define MAX_NUM_CLASS_SHEETS 3

PROPSHEETPAGE class_psp[MAX_NUM_CLASS_SHEETS];
int num_class_pages = 0;

/*------------------------------------------------------------------------
| DoCLassPropPages - 
|------------------------------------------------------------------------*/
int DoCLassPropPages(HWND hwndOwner,
                     SP_PROPSHEETPAGE_REQUEST *propreq)
{
    PROPSHEETPAGE *psp;
    PROPSHEETHEADER psh;
    OUR_INFO * our_params;
    INT stat;
    //SP_PROPSHEETPAGE_REQUEST propreq;
    //typedef struct _SP_PROPSHEETPAGE_REQUEST {
    //DWORD            cbSize;
    //DWORD            PageRequested;
    //HDEVINFO         DeviceInfoSet;
    //PSP_DEVINFO_DATA DeviceInfoData;


    //Fill out the PROPSHEETPAGE data structure for the Background Color
    //sheet

//    our_params = glob_info;  // temporary kludge, unless we don't need re-entrantancy 
    psp = &class_psp[0];

    //Fill out the PROPSHEETPAGE data structure for the Client Area Shape
    //sheet
    FillClassPropertySheets(&psp[0], (LPARAM)our_params);
    ++num_class_pages;

    //Fill out the PROPSHEETHEADER

    //stat = DevicePropPage(
    //  (LPVOID) propreq,   // points to PROPSHEETPAGE_REQUEST, see setupapi.h
    //  (LPFNADDPROPSHEETPAGE) ClassAddPropPage, // add sheet function
    //  0)  // add sheet function data handle?

    memset(&psh, 0, sizeof(PROPSHEETHEADER));  // add fix 11-24-98

    psh.dwSize = sizeof(PROPSHEETHEADER);
    //psh.dwFlags = PSH_USEICONID | PSH_PROPSHEETPAGE;
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = glob_hinst;
    psh.pszIcon = TEXT("");
    psh.nPages = num_class_pages;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    //And finally display the dialog with the two property sheets.


    stat = PropertySheet(&psh);

//BOOL WINAPI DevicePropPage(
//      LPVOID pinfo,   // points to PROPSHEETPAGE_REQUEST, see setupapi.h
//      LPFNADDPROPSHEETPAGE pfnAdd, // add sheet function
//      LPARAM lParam)  // add sheet function data handle?

  return 0;
}

/*------------------------------------------------------------------------
| ClassAddPropPage - Call back function to add a prop page.
|------------------------------------------------------------------------*/
BOOL WINAPI ClassAddPropPage(HPROPSHEETPAGE hpage, LPARAM lparam)
{
  PropSheet_AddPage(lparam, hpage);
}

/*------------------------------------------------------------------------
| FillClassPropertySheets - Setup pages for driver level property sheets.
|------------------------------------------------------------------------*/
int FillClassPropertySheets(PROPSHEETPAGE *psp, LPARAM our_params)
{
  INT pi;
  static TCHAR titlestr[40];

  memset(psp, 0, sizeof(*psp) * NUM_CLASS_SHEETS);

  pi = 0;

  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP | PSH_NOAPPLYNOW;
  psp[pi].hInstance = glob_hinst;
//  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_CLASS_DLG);
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_DRIVER_OPTIONS);
  psp[pi].pfnDlgProc = ClassSheet;
  load_str( glob_hinst, (TITLESTR+3), titlestr, CharSizeOf(titlestr) );
  psp[pi].pszTitle = TEXT("Setup");
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;

  return 0;
}

/*----------------------------------------------------------
 ClassSheet - Dlg window procedure for add on Advanced sheet.
|-------------------------------------------------------------*/
BOOL WINAPI ClassSheet(
      IN HWND   hDlg,
      IN UINT   uMessage,
      IN WPARAM wParam,
      IN LPARAM lParam)
{
 ////OUR_INFO *OurProps = (OUR_INFO *)GetWindowLong(hDlg, DWL_USER);

  switch(uMessage)
  {
    case WM_INITDIALOG :
      ////OurProps = (OUR_INFO *)((LPPROPSHEETPAGE)lParam)->lParam;
      ////SetWindowLong(hDlg, DWL_USER, (LONG)OurProps);
#ifdef NT50
      glob_hwnd = hDlg;
#endif
    stat = DevicePropPage(
      (LPVOID) propreq,   // points to PROPSHEETPAGE_REQUEST, see setupapi.h
      (LPFNADDPROPSHEETPAGE) ClassAddPropPage, // add sheet function
      0)  // add sheet function data handle?

      //set_field(hDlg, IDC_VERBOSE);
    return TRUE;  // No need for us to set the focus.

    case WM_COMMAND:
    return FALSE;

    case WM_PAINT:
    return FALSE;

    case WM_CONTEXTMENU:     // right-click
      //context_menu();
    break;

    case WM_HELP:            // question mark thing
      //our_context_help(lParam);
    return FALSE;

    case WM_NOTIFY :
      switch (((NMHDR *)lParam)->code)
      {
        case PSN_KILLACTIVE :
          // we're losing focus to another page...
          // make sure we update the Global485 variable here.
          //get_field(hDlg, IDC_GLOBAL485);
          SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return FALSE;  // allow focus change
        break;

        case PSN_HELP :
          //our_help(&wi->ip, WIN_NT);
        break;

        case PSN_QUERYCANCEL :
            // the DWL_MSGRESULT field must be *FALSE* to tell QueryCancel
            // that an exit is acceptable.  The function result must be
            // *TRUE* to acknowledge that we handled the message.
            SetWindowLong(hDlg, DWL_MSGRESULT, FALSE); // allow cancel
            return TRUE;
        break;

        case PSN_APPLY :
              SetWindowLong(hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
          return TRUE;

        default :
        return FALSE;
      }  // switch ->code
    break;  // case wmnotify

    default :
    return FALSE;
  }  // switch(uMessage)
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\opstr.h ===
// opstr.h

//----- Pnp-ID Defines
/* PCI Defines */
#define PCI_VENDOR_ID           0x11fe
#define PCI_DEVICE_32I          0x0001
#define PCI_DEVICE_8I           0x0002
#define PCI_DEVICE_16I          0x0003
#define PCI_DEVICE_4Q           0x0004
#define PCI_DEVICE_8O           0x0005
#define PCI_DEVICE_8RJ          0x0006
#define PCI_DEVICE_4RJ          0x0007
#define PCI_DEVICE_SIEMENS8     0x0008
#define PCI_DEVICE_SIEMENS16    0x0009
#define PCI_DEVICE_RPLUS4       0x000a
#define PCI_DEVICE_RPLUS8       0x000b
#define PCI_DEVICE_RMODEM6      0x000c
#define PCI_DEVICE_RMODEM4      0x000d
#define PCI_DEVICE_RPLUS2       0x000e
#define PCI_DEVICE_422RPLUS2    0x000f

#define ISA_DEVICE_RPORT4       0x1001
#define ISA_DEVICE_RPORT8       0x1002
#define ISA_DEVICE_RPORT16      0x1003
#define ISA_DEVICE_RPORT32      0x1004
#define ISA_DEVICE_RMODEM4      0x2001
#define ISA_DEVICE_RMODEM8      0x2002
#define NET_DEVICE_VS1000       0x3001  // 16 to 64 port
#define NET_DEVICE_VS2000       0x3002  // 8 port
#define NET_DEVICE_RHUB8        0x3003
#define NET_DEVICE_RHUB4        0x3004

// ids for Our_Option.var_type
#define OP_T_DWORD  0
#define OP_T_STRING 1
#define OP_T_BOOL   2

// flags for Our_Option.flags
#define OP_F_VS             1
#define OP_F_RK             2
#define OP_F_VSRK           3
#define OP_F_SETUP_ONLY     8

typedef struct {
  const char * name;  // name of option see lists
  int id;     // unique id, also has bit which tells option type.
  WORD var_type;  // see OP_T_* types, 0=DWORD, 1=String, 2=BOOL
  WORD    flags;  // see OP_F_* types
} Our_Options;

// driver options
extern const char szVerboseLog[]   ;
extern const char szNumDevices[]   ;
extern const char szNoPnpPorts[]   ;
extern const char szScanRate[]     ;
extern const char szModemCountry[] ;
extern const char szGlobalRS485[]  ;

#define OP_VerboseLog    0x100
#define OP_NumDevices    0x101
#define OP_NoPnpPorts    0x102
#define OP_ScanRate      0x103
#define OP_ModemCountry  0x104
#define OP_GlobalRS485   0x105

// device options
//extern const char szStartComIndex[] ;
extern const char szNumPorts[]      ;
extern const char szMacAddr[]       ;
extern const char szBackupServer[]  ;
extern const char szBackupTimer[]   ;
extern const char szName[]          ;
extern const char szModelName[]     ;
extern const char szIoAddress[]     ;
extern const char szModemDevice[]   ;
extern const char szHubDevice[]     ;

//#define OP_StartComIndex   0x200
#define OP_NumPorts        0x201
#define OP_MacAddr         0x202
#define OP_BackupServer    0x203
#define OP_BackupTimer     0x204
#define OP_Name            0x205
#define OP_ModelName       0x206
#define OP_IoAddress       0x207
#define OP_ModemDevice     0x208
#define OP_HubDevice       0x209

// port options
extern const char szWaitOnTx[]      ;
extern const char szRS485Override[] ;
extern const char szRS485Low[]      ;
extern const char szTxCloseTime[]   ;
extern const char szLockBaud[]      ;
extern const char szMap2StopsTo1[]  ;
extern const char szMapCdToDsr[]    ;
extern const char szRingEmulate[]   ;
  	
#define OP_WaitOnTx         0x400
#define OP_RS485Override    0x401
#define OP_RS485Low         0x402
#define OP_TxCloseTime      0x403
#define OP_LockBaud         0x404
#define OP_Map2StopsTo1     0x405
#define OP_MapCdToDsr       0x406
#define OP_PortName         0x407
#define OP_RingEmulate      0x408

extern Our_Options driver_options[];
extern Our_Options device_options[];
extern Our_Options port_options[];

int HdwIDStrToID(int *Hardware_ID, char *idstr);
int id_to_num_ports(int id);
int IsHubDevice(int Hardware_ID);
int IsModemDevice(int Hardware_ID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\rocku.h ===
/* rocku.h */

int copy_files_nt(InstallPaths *ip);
int clear_nt_device(Driver_Config *wi);

int get_nt_config(Driver_Config *wi);
int set_nt_config(Driver_Config *wi);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\precomp.h ===
/*** #include <windowsx.h> ***/
#define STRICT
#include <windows.h>
#include <stdio.h>
#include <direct.h>
#include <stdlib.h>
#include <malloc.h>
#include <ctype.h>
#include <tchar.h>
#include <string.h>
#include <setupapi.h>

//#include <comutils.h>
#include "comutils.h"
#include "setupu.h"
#include "ourver.h"
#include "setup.h"
#ifdef NT50
#include <cfgmgr32.h>
#include <htmlhelp.h>
#include "nt50.h"
#endif
#include "nt40.h"
#include "resource.h"
#include "rocku.h"
#include "devprop.h"
#include "dripick.h"
#include "driprop.h"
#include "portprop.h"
#include "addwiz.h"
#include "strings.h"
#include "opstr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SETUP.RC
//
#define IDD_DIALOG1                     101
#define SETUPICON_ALT                   102
#define IDD_ADD_WIZ_INTRO               104
#define IDD_ADD_WIZ_COUNTRY             105
#define IDD_ADD_WIZ_DONE                106
#define IDD_ADD_WIZ_NUMPORTS            107
#define IDD_PORT_MODEM_OPTIONS          108
#define IDD_ADD_WIZ_DEVICE              110
#define IDD_ADD_WIZ_MAC                 111
#define IDD_ADD_WIZ_BACKUP              112
#define IDM_CLOSE                       200
#define IDM_EXIT                        201
#define IDM_PM                          202
#define IDM_STATS                       203
#define IDM_EDIT_README                 204
#define IDM_ADVANCED                    205
#define IDM_HELP                        206
#define IDM_HELPABOUT                   207
#define IDM_ADVANCED_NAMES              208
#define IDM_ADVANCED_MODEM_INF          209
#define IDM_F1                          220
#define IDC_LBOX_DEVICE                 308
#define IDC_EB_NAME                     309
#define IDC_CBOX_NUMPORTS               311
#define IDC_CBOX_MACADDR                312
#define IDC_CBOX_IRQ                    313
#define IDC_CBOX_SC                     314
#define IDC_CBOX_TYPE                   315
#define IDC_BACKUP_SERVER               316
#define IDC_BACKUP_TIMER                317
#define IDC_CBOX_IOADDR                 318
#define IDC_USE_IRQ                     319
#define IDD_MAIN_DLG                    450
#define IDD_DRIVER_OPTIONS              451
#define IDD_DRIVER_OPTIONS_NT50         452
#define IDD_DEVICE_SETUP                453
#define IDD_VS_DEVICE_SETUP             454
#define IDD_PORTLIST_PICK               455
#define IDD_PORT_OPTIONS                456
#define IDD_PORT_485_OPTIONS            457
#define IDD_ADD_WIZ_BUSTYPE             458
#define IDD_ADD_WIZ_BOARD               459
#define IDD_ADD_WIZ_BASEIO              460
#define BMP_FULL_LOGO                   500
#define BMP_SMALL_LOGO                  501
#define BMP_BOARDS                      502
#define BMP_PORTSM                      503
#define BMP_VS_FULL_LOGO_NT50           504
#define BMP_VS_FULL_LOGO                505
#define BMP_VS_BOX                      506
#define BMP_COMTROL_LOGO                507
#define BMP_RKTMODEM_LOGO               508
#define BMP_RKTMODEMII_LOGO             509
#define BMP_RKTMODEM_INTL_LOGO          510
#define BMP_RKTPORT_LOGO                511
#define BMP_RKTHUB_LOGO                 512

#define TITLESTR  700
#define MSGSTR    710

#define IDC_PN3                         1004
#define IDC_PN2                         1005
#define IDC_PN1                         1006
#define IDC_GROUP                       1008
#define IDC_WIZ1_ISA                    1011
#define IDC_WIZ1_ISA2                   1012
#define IDC_WIZ_CBOX_COUNTRY            1012
#define IDC_WIZ_CBOX_NUMPORTS           1013
#define IDC_LBL_SUMMARY1                1014
#define IDC_LBL_SUMMARY2                1015
#define IDC_CLONE                       1016
#define IDD_STATUS                      1018
#define IDC_GLOBAL485                   1019
#define IDC_RKT_LOGO                    1020
#define IDC_VS_LOGO                     1021
#define IDC_WIZ_CBOX_MAC                1024
#define IDC_WIZ_DEVICE_SELECT           1025
#define IDC_WIZ_CBOX_DEVICE             1025
#define IDC_ST_STATE                    1026
#define IDC_ST_NIC_MAC                  1027
#define IDC_ST_NIC_DVC_NAME             1031
#define IDC_ST_VSL_STATE                1032
#define IDC_ST_VSL_MAC                  1033
#define IDC_ST_VSL_IFRAMES_RCVD         1036
#define IDC_ST_VSL_IFRAMES_SENT         1037
#define IDC_ST_NIC_PKT_RCVD_NOT_OURS    1038
#define IDC_ST_VSL_IFRAMES_RESENT       1039
#define IDC_ST_NIC_PKT_RCVD_OURS        1040
#define IDC_ST_NIC_PKT_SENT             1041
#define IDC_ST_VSL_IFRAMES_OUTOFSEQ     1042
#define IDC_ST_VSL_DETECTED             1043
#define IDC_ST_PM_LOADS                 1044
#define IDC_PS_PORT                     1046
#define IDC_WIZ_BACKUP_NO               1047
#define IDC_WIZ_BACKUP_YES              1048
#define IDC_WIZ_CBOX_BACKUPTIME         1049
#define IDC_CBOX_MAPBAUD                1084
#define IDC_CBOX_SCAN_RATE              1085
#define IDC_VERBOSE                     1086
#define IDC_PNP_PORTS                   1087
#define IDB_DEF                         1089
#define IDB_DONE                        1090
#define IDB_ADD                         1091
#define IDB_REMOVE                      1092
#define IDB_PROPERTIES                  1093
#define IDB_HELP                        1094
#define IDB_INSTALL                     1095
#define IDC_VERSION                     1096
#define IDM_OPTIONS                     1097
#define IDB_RESET                       1098
#define IDB_REFRESH                     1099
#define IDB_STAT_RESET                  1100
#define IDC_PORT_WONTX                  1150
#define IDC_PORT_RS485_TLOW             1151
#define IDC_PORT_RS485_LOCK             1152
#define IDC_PORT_WAIT_ON_CLOSE          1153
#define IDC_PORT_LOCKBAUD               1154
#define IDC_MAP_CDTODSR                 1155
#define IDC_MAP_2TO1                    1156
#define IDC_WIZ_ISA                     1180
#define IDC_WIZ_PCI                     1181
#define IDC_WIZ_BOARD_SELECT            1182
#define IDC_WIZ_CBOX_BOARD              1182
#define IDC_WIZ_CBOX_IOADDR             1183
#define IDC_RING_EMULATE                1184
#define IDS_INSTALL_GROUP               2500
#define IDS_AP_TITLE                    2501
#define IDS_MODEM_INF_ENTRY             2502
#define IDS_VS_INSTALL_GROUP            2503
#define IDS_VS_AP_TITLE                 2504
#define IDS_VS_MODEM_INF_ENTRY          2505
#define IDL_BASE_ADDR_LABEL             2506
#define IDL_ISA_BUS_LABEL               2507
#define IDC_STATIC                      -1
#define IDC_PN0                         -1
#define IDC_CONF                        -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1050
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\setup.h ===
//--- setup.h

// pluck the version out of ourver.h
#define VERSION_STRING VER_PRODUCTVERSION_STR

#define NUM_DRIVER_SHEETS 2

// these are now defined in the individual make files
//#define NT50
//#define S_VS   // vslink
//#define S_RK   // rocketport

#define CharSizeOf(s) (sizeof(s) / sizeof(TCHAR))

// for vs1000, which can have 64 ports:
#define MAX_NUM_PORTS_PER_DEVICE 64

// property sheet message sent to other sheets at same level
// to gather up changes
// from windows controls into our c-structs.
#define QUERYSIB_GET_OUR_PROPS 100

//---- macro to see if mac-addresses match
#define mac_match(_addr1, _addr2) \
     ( (*((DWORD *)_addr1) == *((DWORD *)_addr2) ) && \
       (*((WORD *)(_addr1+4)) == *((WORD *)(_addr2+4)) ) )

#define BOARD_SELECTED  0
#define PORT_SELECTED   1

typedef struct {
  HDEVINFO         DeviceInfoSet;  // a plug & play context handle
  PSP_DEVINFO_DATA DeviceInfoData; // a plug & play context handle
  int device_selected;      // the current/selected device(board or vs-box)
  int port_selected;        // the current/selected port
  int selected;             // tree view selection: 0=board selected, 1=port
} OUR_INFO;

typedef struct {
  int IsIsa;                // isa?  0 = pci bus
  int IsHub;                // serial hub?  0 = VS1000/2000
  int IoAddress;            // io base address
  int IsModemDev;           // 1=VS2000 or RocketModem
  int CountryIdx;           // list index for country code
  int CountryCode;          // actual country code
  int NumPorts;             // number of ports on board
  char BoardType[50];       // name of board model (e.g., RocketModem)
  BYTE MacAddr[6];          // mac addr, ff ff ff ff ff ff = auto
  int finished;             // flag
  int BackupServer;         // 1=backup server, 0=normal server
  int BackupTimer;          // delay timeout for backup to kick in(minutes)
} AddWiz_Config;

#define TYPE_RM_VS2000  1       
#define TYPE_RMII       2       
#define TYPE_RM_i       3

int DoDriverPropPages(HWND hwndOwner);
int allow_exit(int want_to_cancel);
void our_exit(void);

// for flags in setup_service
#define OUR_REMOVE        1
#define OUR_RESTART       2
#define OUR_INSTALL_START 4

// for which_service in setup_service
#define OUR_SERVICE 0
#define OUR_DRIVER  1
int setup_service(int flags, int which_service);

int our_help(InstallPaths *ip, int index);
void our_context_help(LPARAM lParam);
int ioctl_talk(unsigned char *buf, int ioctl_type,
                      unsigned char **ret_buf, int *ret_size);
int update_modem_inf(int ok_prompt);
int setup_utils_exist(void);
int setup_make_progman_group(int prompt);
int setup_init(void);
int copy_setup_init(void);
int remove_driver(int all);
int send_to_driver(int send_it);
int do_install(void);
int FillDriverPropertySheets(PROPSHEETPAGE *psp, LPARAM our_params);
int get_mac_list(char *buf, int in_buf_size, int *ret_buf_size);
BYTE *our_get_ping_list(int *ret_stat, int *ret_bytes);

int validate_config(int auto_correct);
int validate_port(Port_Config *ps, int auto_correct);
int validate_port_name(Port_Config *ps, int auto_correct);
int validate_device(Device_Config *dev, int auto_correct);
int FormANewComPortName(IN OUT TCHAR *szComName, IN TCHAR *szDefName);
int IsPortNameInSetupUse(IN TCHAR *szComName);
int IsPortNameInRegUse(IN TCHAR *szComName);
int GetLastValidName(IN OUT TCHAR *szComName);
void rename_ascending(int device_selected,
                      int port_selected);
int StripNameNum(IN OUT TCHAR *szComName);
int ExtractNameNum(IN TCHAR *szComName);
int BumpPortName(IN OUT TCHAR *szComName);

/* PCI Defines(copied from ssci.h in driver code) */
#define PCI_VENDOR_ID           0x11fe
#define PCI_DEVICE_32I          0x0001
#define PCI_DEVICE_8I           0x0002
#define PCI_DEVICE_16I          0x0003
#define PCI_DEVICE_4Q           0x0004
#define PCI_DEVICE_8O           0x0005
#define PCI_DEVICE_8RJ          0x0006
#define PCI_DEVICE_4RJ          0x0007
#define PCI_DEVICE_SIEMENS8     0x0008
#define PCI_DEVICE_SIEMENS16    0x0009
#define PCI_DEVICE_RPLUS4       0x000a
#define PCI_DEVICE_RPLUS8       0x000b
#define PCI_DEVICE_RMODEM6      0x000c
#define PCI_DEVICE_RMODEM4      0x000d
#define PCI_DEVICE_RPLUS2       0x000e
#define PCI_DEVICE_422RPLUS2    0x000f

/*--------------------------  Global Variables  ---------------------*/
//extern char *aptitle;
extern char *szAppName;
extern char *OurServiceName;
extern char *OurDriverName;
extern char *OurAppDir;
extern char *szSetup_hlp;
extern char szAppTitle[];
extern char *szDeviceNames[];


extern char *progman_list_nt[];
extern unsigned char broadcast_addr[6];
extern unsigned char mac_zero_addr[6];
extern HWND glob_hwnd;
extern HINSTANCE glob_hinst;      // current instance
extern char gtmpstr[200];
extern HWND  glob_hDlg;
extern int glob_device_index;
extern OUR_INFO *glob_info;
extern AddWiz_Config *glob_add_wiz;
extern Driver_Config *wi;      // current info
extern Driver_Config *org_wi;  // original info, use to detect changes
//extern Driver_Config *adv_org_wi;  // original info, use to detect changes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\setupu.c ===
/*--------------------------------------------------------------------------
  setupu.c - setup driver utilitities.
|--------------------------------------------------------------------------*/
#include "precomp.h"

char *szSlash      = {"\\"};
char *szSYSTEM     = {"SYSTEM"};
char *szCurrentControlSet = {"CurrentControlSet"};
char *szEnum       = {"Enum"};
char *szServices   = {"Services"};
char *szParameters = {"Parameters"};
char *szSecurity   = {"Security"};
char *szLinkage    = {"Linkage"};
char *szEventLog   = {"EventLog"};
char *szSystem     = {"System"};

// just turn debug for this module off
#define D_Level 0

/*----------------------------------------------------------------------
| setup_install_info - Get the version of Windows info, and the source path
   of where we are running from
|----------------------------------------------------------------------*/
int APIENTRY setup_install_info(InstallPaths *ip,
                 HINSTANCE hinst,
                 char *NewServiceName,  // "RocketPort" or "VSLink"
                 char *NewDriverName,   // "rocket.sys" or "vslink.sys"
                 char *NewAppName,      // "Comtrol RocketPort,RocketModem Install"
                 char *NewAppDir)       // "rocket" or "vslink"

{
  DWORD ver_info;
  char *str;
  int i;

  struct w_ver_struct {
    BYTE win_major;
    BYTE win_minor;
    BYTE dos_major;
    BYTE dos_minor;
  } *w_ver;

  ver_info = GetVersion();
  w_ver = (struct w_ver_struct *) &ver_info;

  if (ver_info < 0x80000000)
  {
    ip->win_type = WIN_NT;
    //wsprintf (szVersion, "Microsoft Windows NT %u.%u (Build: %u)",
    //(DWORD)(LOBYTE(LOWORD(dwVersion))),
    //(DWORD)(HIBYTE(LOWORD(dwVersion))),
    //      (DWORD)(HIWORD(dwVersion)) );
  }

  ip->major_ver = w_ver->win_major;
  ip->minor_ver = w_ver->win_minor;
  if (ip->win_type == WIN_UNKNOWN)
  {
    ip->win_type = WIN_NT;  // force it
  }

  //GetWindowsDirectory(ip->win_dir,144);
  //GetSystemDirectory(ip->system_dir,144);
  ip->hinst = hinst;

  // Initialize the default source path so that it uses the same
  // drive that the SETUP.EXE application was executed from.
  GetModuleFileName(hinst, ip->src_dir, sizeof(ip->src_dir));

  // chop off file name leaving only the directory
  str = ip->src_dir;
  i = strlen(str);
  if (i > 0) --i;
  while ((str[i] != '\\') && (i != 0))
    --i;
  if (i==0)
    str[0] = 0;  // problem, no install dir
  else
  {
    str[i] = 0;  // terminate over "\"
  }

  strcpy(ip->szServiceName, NewServiceName);
  strcpy(ip->szDriverName,  NewDriverName);
  strcpy(ip->szAppName,     NewAppName);
  strcpy(ip->szAppDir,     NewAppDir);

  GetSystemDirectory(ip->dest_dir, 144);
  strcat(ip->dest_dir, "\\");
  strcat(ip->dest_dir, NewAppDir);

  return 0;
}

/*------------------------------------------------------------------------
| unattended_add_port_entries - Add port entries so that RAS will "see"
   some ports which we can install to.  Normally the driver puts these
   entries in the reg on startup, the reg hardware area gets re-built
   every startup.  This is a kludge so that unattended install can
   go on to add RAS ports.
|------------------------------------------------------------------------*/
int APIENTRY unattended_add_port_entries(InstallPaths *ip,
                                         int num_entries,
                                         int start_port)
{
 int i;

static char *szSHDSt = {"HARDWARE\\DEVICEMAP\\SERIALCOMM"};
char szName[20];
char szCom[20];
char str[180];
//DWORD dwstat;

   if (start_port == 0)
     start_port = 5;

   reg_create_key(NULL, szSHDSt);  // "HARDWARE\\DEVICEMAP\\SERIALCOMM"

   for (i=0; i<num_entries; i++)
   {
     wsprintf(szCom,    "COM%d", i+start_port);
     strcpy(szName, ip->szAppDir);  // "Rocket" or "VSLink"
     wsprintf(str, "%d", i);
     strcat(szName, str);
     reg_set_str(NULL, szSHDSt, szName, szCom, REG_SZ);
   }
  return 0;
}

/*-----------------------------------------------------------------
  remove_driver_reg_entries - 
|------------------------------------------------------------------*/
int APIENTRY remove_driver_reg_entries(char *ServiceName)
{
 int stat;
 char str[180];

  //our_message("Nuking RocketPort Reg Entry",MB_OK);

  make_szSCS(str, ServiceName);
  stat = reg_delete_key(NULL, str, szEnum);
  stat = reg_delete_key(NULL, str, szParameters);
  stat = reg_delete_key(NULL, str, szSecurity);
  stat = reg_delete_key(NULL, str, szLinkage);

  make_szSCS(str, NULL);
  stat = reg_delete_key(NULL, str, ServiceName);
  if (stat) {
    DbgPrintf(D_Level, ("Error 4E\n"))
  }

  // get rid of the Services\EventLog\..RocketPort entry
  make_szSCSES(str, NULL);
  stat = reg_delete_key(NULL, str, ServiceName);
  if (stat) {
    DbgPrintf(D_Level, ("Error 4F\n"))
  }
#ifdef NT50
#if 0
  remove_pnp_reg_entries();
#endif
#endif
  return 0;
}

#if 0
  this is experimental
/*--------------------------------------------------------------------------
| remove_pnp_reg_entries -
|--------------------------------------------------------------------------*/
int APIENTRY remove_pnp_reg_entries(void)
{
 DWORD stat, keystat;
static char *enum_pci = {"SYSTEM\\CurrentControlSet\\Enum\\PCI"};
static char *enum_root = {"SYSTEM\\CurrentControlSet\\Enum\\root"};
//static char root_name[124];
 char node_name[140];
 char *pc;
 DWORD node_i;
 HKEY hKey;

  DbgPrintf(D_Level, ("Looking\n"))

  keystat = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      enum_pci,
                      0,
                      KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
                      &hKey);

  if (keystat != ERROR_SUCCESS)
  {
    DbgPrintf(D_Level, ("Err14a\n"))
    return 1;
  }

  node_i = 0;
  stat = RegEnumKey (hKey, node_i++, node_name, 138);
  while (stat == ERROR_SUCCESS)
  {
    pc = node_name;
    while (*pc)
    {
      *pc = toupper(*pc);
      ++pc;
    }

    if (strstr(node_name, "VEN_11FE") != 0)
    {
       // found a Comtrol hardware node
      DbgPrintf(D_Level, ("Found Node:%s\n", node_name))
      stat = RegDeleteKeyNT(hKey, node_name);
      if (stat != ERROR_SUCCESS)
      {
        DbgPrintf(D_Level, ("No Delete\n"))
      }
      //stat = reg_delete_key(NULL, node_name, node_name);
    }
    stat = RegEnumKey (hKey, node_i++, node_name, 68);
  }
  RegCloseKey (hKey);   // Close the key handle.
  return 0;
}
#endif

/*--------------------------------------------------------------------------
 RegDeleteKeyNT -
   A registry key that is opened by an application can be deleted
   without error by another application in both Windows 95 and
   Windows NT. This is by design.
|--------------------------------------------------------------------------*/
DWORD APIENTRY RegDeleteKeyNT(HKEY hStartKey , LPTSTR pKeyName )
{
   DWORD   dwRtn, dwSubKeyLength;
   LPTSTR  pSubKey = NULL;
   TCHAR   szSubKey[256]; // (256) this should be dynamic.
   HKEY    hKey;

   // do not allow NULL or empty key name
   if ( pKeyName &&  lstrlen(pKeyName))
   {
      if( (dwRtn=RegOpenKeyEx(hStartKey,pKeyName,
         0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS)
      {
         while (dwRtn == ERROR_SUCCESS )
         {
            dwSubKeyLength = 250;
            dwRtn=RegEnumKeyEx(
                           hKey,
                           0,       // always index zero
                           szSubKey,
                           &dwSubKeyLength,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                         );

            if(dwRtn == ERROR_NO_MORE_ITEMS)
            {
               dwRtn = RegDeleteKey(hStartKey, pKeyName);
               break;
            }
            else if(dwRtn == ERROR_SUCCESS)
               dwRtn=RegDeleteKeyNT(hKey, szSubKey);
         }
         RegCloseKey(hKey);
         // Do not save return code because error
         // has already occurred
      }
      else
      {
        DbgPrintf(D_Level, ("Access Error\n"))
      }
   }
   else
      dwRtn = ERROR_BADKEY;
   return dwRtn;
}

/*---------------------------------------------------------------------------
| modem_inf_change - go make the needed changes to the modem.inf file.
|  Make a backup copy too.
|----------------------------------------------------------------------------*/
int APIENTRY modem_inf_change(InstallPaths *ip,
                              char *modemfile,
                              char *szModemInfEntry)
{
 int i=0;
 int stat = 1;
 OUR_FILE *fp;   // in
 OUR_FILE *fp2;  // out
 OUR_FILE *fp_new;  // entries file to add
 char buf[202];
 char *str;
 char *szRAS={"\\RAS\\"};
 int section = 0;
 int chk;

 DbgPrintf(D_Level, ("chg inf start\n"))

               // first backup original modem.inf if not done already.
  stat = backup_modem_inf(ip);
  if (stat)
    return 1;  // err, couldn't backup modem.inf

 DbgPrintf(D_Level, ("chg A\n"))
  GetSystemDirectory(buf, 144);
  strcat(buf,"\\");
  strcat(buf,modemfile);
  fp_new  = our_fopen(buf, "rb");    // rocket\rocket35.inf
 DbgPrintf(D_Level, ("chg B\n"))

  if (fp_new == NULL)
  {
    wsprintf(ip->tmpstr,RcStr((MSGSTR+15)),buf);
    stat = our_message(ip, ip->tmpstr, MB_OK);
    return 1;
  }

  GetSystemDirectory(ip->dest_str, 144);
  strcat(ip->dest_str, szRAS);
  strcat(ip->dest_str,"modem.inf");

     //----- now copy modem.inf to modem.rk0 as a base to read from and
     // write new file
  GetSystemDirectory(ip->src_str, 144);
  strcat(ip->src_str, szRAS);
  strcat(ip->src_str,"modem.rk0");

  stat = our_copy_file(ip->src_str, ip->dest_str);
  if (stat)
  {
    wsprintf(ip->tmpstr,RcStr((MSGSTR+16)), ip->dest_str, ip->src_str, stat);
    stat = our_message(ip, ip->tmpstr, MB_OK);
    return 2;  // err
  }

  fp  = our_fopen(ip->src_str, "rb");    // modem.rk0
  if (fp == NULL)
  {
    wsprintf(ip->tmpstr,RcStr((MSGSTR+17)), ip->src_str);
    stat = our_message(ip, ip->tmpstr, MB_OK);
    return 1;
  }

  fp2 = our_fopen(ip->dest_str, "wb");   // modem.inf
  if (fp2 == NULL)
  {
    wsprintf(ip->tmpstr, "Tried to open the %s file for changes, but could not open it.", ip->dest_str);
    our_fclose(fp);
    return 1;
  }

  chk = 0;
  while ((our_fgets(buf, 200, fp)) && (!our_feof(fp)) && (!our_ferror(fp)) && (!our_ferror(fp2)) &&
         (chk < 30000))
  {
    ++chk;
    // search and kill any 0x1a eof markers
    str = buf;
    while (*str != 0)
    {
      if (*str == 0x1a)
        *str = ' ';  // change eof to space
      ++str;
    }
    
    // pass up spaces
    str = buf;
    while (*str == ' ')
      ++str;
    if (*str == '[')
    {
      
      if (str[0] == '[')  // starting new section
      {
        section = 0;  // not our section to worry about

        if (my_substr_lstricmp(str, szModemInfEntry) == 0)  // match
        {
          // make sure 
          section = 1;
        }
      }  // end of new [] section header
    }

    // process all entries here
    if (section == 1)
      str[0] = 0;  // first delete all "[Comtrol RocketModem]" entries

    if (str[0] != 0)
    {
      str = buf;  // don't skip spaces
      our_fputs(buf,fp2);
    }
  }  // end of while fgets();

  stat = 0;
  if ( (our_ferror(fp)) || (our_ferror(fp2)) || (chk >= 10000))
  {
    stat = 3;  // error
  }

  if (stat)
  {
    our_fclose(fp);
    our_fclose(fp2);
    our_fclose(fp_new);
    // try to restore to the read file backup(modem.rk0)
    stat = our_copy_file(ip->dest_str, ip->src_str);
    wsprintf(ip->tmpstr, "Errors encountered while making %s file changes.", ip->dest_str);
    stat = 3;  // error
  }
  else
  {
    // append the changes to it

    our_fputs("\x0d\x0a",fp2);
    our_fputs(szModemInfEntry, fp2);
    our_fputs("\x0d\x0a;-------------------\x0d\x0a",fp2);
    while ((our_fgets(buf, 200, fp_new)) && (!our_feof(fp_new)) && (!our_ferror(fp2)))
    {
      our_fputs(buf,fp2);
    }
    our_fclose(fp);
    our_fclose(fp2);
    our_fclose(fp_new);
    our_remove(ip->src_str);  // kill temporary modem.rk0 file
  }

  return stat;
}

/*---------------------------------------------------------------------------
| backup_modem_inf -  backs up to modem.bak.
|----------------------------------------------------------------------------*/
int APIENTRY backup_modem_inf(InstallPaths *ip)
{
 int stat = 1;
 char *szRAS = {"\\RAS\\"};
 OUR_FILE *fp;

               // first copy modem.inf over to our directory as a backup
  GetSystemDirectory(ip->dest_str, 144);
  strcat(ip->dest_str, szRAS);
  strcat(ip->dest_str,"modem.bak");

  GetSystemDirectory(ip->src_str, 144);
  strcat(ip->src_str, szRAS);
  strcat(ip->src_str,"modem.inf");

  fp  = our_fopen(ip->dest_str, "rb");  // see if already backed up
  if (fp == NULL)
  {
    stat = our_copy_file(ip->dest_str, ip->src_str);
    if (stat != 0)
    {
      wsprintf(ip->tmpstr,RcStr((MSGSTR+18)), ip->src_str, stat);
      our_message(ip, ip->tmpstr, MB_OK);
      return 1;  // err
    }
  }
  else our_fclose(fp);

  return 0; // ok
}

/*---------------------------------------------------------------------------
| service_man - Handle installation, removal, starting, stopping of NT
   services(or drivers.).
|----------------------------------------------------------------------------*/
int APIENTRY service_man(LPSTR lpServiceName, LPSTR lpBinaryPath, int chore)
{ 
  SC_HANDLE hSCManager = NULL; 
  SC_HANDLE hService   = NULL; 
  SC_LOCK   lSCLock    = NULL; 
//  SERVICE_STATUS ServiceStatus;
  BOOL Status = 1;  // success
  int stat = 0;  // ret status(0=ok)
 
  hSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS ); 
 
  if (hSCManager == NULL) 
  { 
     return 2; 
  } 
    //---- Lock the service database
  lSCLock = LockServiceDatabase( hSCManager ); 
  if (lSCLock == NULL) 
  { 
    CloseServiceHandle( hSCManager ); 
    return 1; 
  }

  if ((chore != CHORE_INSTALL) && (chore != CHORE_INSTALL_SERVICE))
  {
    hService = OpenService( hSCManager, lpServiceName, SERVICE_ALL_ACCESS);
    if (hService == NULL)
    {
      UnlockServiceDatabase( lSCLock ); 
      CloseServiceHandle( hSCManager ); 
      return 2;
    }
  }

  switch(chore)
  {
    case CHORE_INSTALL:
      // Create the service
      hService = CreateService( hSCManager, 
                            lpServiceName,     // Service's name 
                            lpServiceName,     // Display name (new for NT) 
                            SERVICE_ALL_ACCESS,// Access (allow all) 
                            SERVICE_KERNEL_DRIVER, // Service type 
                            SERVICE_AUTO_START,    // Startup behavior 
                            0x1,               // Error control 
                            lpBinaryPath,      // Full pathname of binary 
                            NULL,              // Load order group 
                            NULL,              // Tag ID 
                            NULL,              // Dependencies (none) 
                            NULL,              // Account name 
                            NULL               // Password 
                            ); 
      if (hService == NULL)
        stat = 5;
      Status = 0;
    break;

    case CHORE_START:
      // Unlock the database
      if (lSCLock != NULL)
      {
        UnlockServiceDatabase( lSCLock ); 
        lSCLock = NULL;
      }

      Status = StartService(hService,  0, NULL);
      //if (Status !=
      if (Status == 0)  // false
      {
        stat = GetLastError();
        Status = 1;
      }
    break;

    case CHORE_STOP:
      {
        SERVICE_STATUS ss;
        Status = ControlService(hService,  SERVICE_CONTROL_STOP, &ss);
        if (Status == 0)  // false
        {
          stat = GetLastError();
          if (stat == 0)
            stat = 1234;
          Status = 1;
        }
      }
    break;

    case CHORE_REMOVE:
      Status = DeleteService(hService);
    break;

    case CHORE_INSTALL_SERVICE:
      // Create the service
      hService = CreateService( hSCManager, 
                            lpServiceName,     // Service's name 
                            lpServiceName,     // Display name (new for NT) 
                            SERVICE_ALL_ACCESS,// Access (allow all)
                            SERVICE_WIN32_OWN_PROCESS, // Service type
                            SERVICE_AUTO_START,    // Startup behavior
                            SERVICE_ERROR_NORMAL,  // Error control
                            lpBinaryPath,      // Full pathname of binary
                            NULL,              // Load order group
                            NULL,              // Tag ID
                            NULL,              // Dependencies (none)
                            NULL,              // Account name
                            NULL               // Password
                            );
      if (hService == NULL)
        stat = 6;
      //Status = 0;
    break;

    case CHORE_IS_INSTALLED:
      // return without error to indicate it is installed.
    break;
  }
  if (Status == 0)  // false
    stat = 8;

  // Close our handle to the new service
  if (hService != NULL)
    CloseServiceHandle(hService); 

  // Unlock the database
  if (lSCLock != NULL)
    UnlockServiceDatabase( lSCLock ); 

  // Free our handle to the service control manager
  CloseServiceHandle( hSCManager ); 
  return stat; 
} 

/*-----------------------------------------------------------------
  make_szSCS - Services area.
    form ascii string: "SYSTEM\CurrentControlSet\Services"
|------------------------------------------------------------------*/
int APIENTRY make_szSCS(char *str, const char *szName)
{
  strcpy(str, szSYSTEM);  strcat(str, szSlash);
  strcat(str, szCurrentControlSet); strcat(str, szSlash);
  strcat(str, szServices);
  if (szName != NULL)
  {
    strcat(str, szSlash);
    strcat(str, szName);
  }
  return 0;
}

/*-----------------------------------------------------------------
  make_szSCSES - Event log reg area
   form ascii string: "SYSTEM\CurrentControlSet\Services\EventLog\System"
|------------------------------------------------------------------*/
int APIENTRY make_szSCSES(char *str, const char *szName)
{
  strcpy(str, szSYSTEM);  strcat(str, szSlash);
  strcat(str, szCurrentControlSet); strcat(str, szSlash);
  strcat(str, szServices); strcat(str, szSlash);
  strcat(str, szEventLog); strcat(str, szSlash);
  strcat(str, szSystem);
  if (szName != NULL)
  {
    strcat(str, szSlash);
    strcat(str, szName);
  }
  return 0;
}

/*---------------------------------------------------------------------------
| copy_files - copy a list of files from wi->src_dir to wi->dest_dir
|   Uses the wi->src_str & wi->dest_str.  Assumes you want the same name
|   as copying from.
|----------------------------------------------------------------------------*/
int APIENTRY copy_files(InstallPaths *ip, char **files)
{
 int i=0;
 int stat;

  if (my_lstricmp(ip->src_dir, ip->dest_dir) == 0) // src_dir == dest_drv
    return 0;

  while (files[i] != NULL)
  {
    strcpy(ip->src_str, ip->src_dir);
    strcat(ip->src_str, szSlash);
    strcat(ip->src_str, files[i]);

    strcpy(ip->dest_str, ip->dest_dir);
    strcat(ip->dest_str, szSlash);
    strcat(ip->dest_str, files[i]);
again1:
    stat = our_copy_file(ip->dest_str, ip->src_str);
    if (stat)
    {
      //if (stat == 1)  // error opening read file
      //  return 1;  // don't report errors, since some driver sets differ in
                   // which files they include
      // (that was a stupid idea(karl to karl)!)

      wsprintf(ip->tmpstr,RcStr((MSGSTR+19)), ip->src_str, ip->dest_str);
      stat = our_message(ip, ip->tmpstr, MB_ABORTRETRYIGNORE);
      if (stat == IDABORT)
        return 1;  // error
      if (stat == IDRETRY) goto again1;
    }
    ++i;
  }
  return 0;
}

/*---------------------------------------------------------------------------
| our_copy_file - copy a file from here to there.
|----------------------------------------------------------------------------*/
int APIENTRY our_copy_file(char *dest, char *src)
{
 int stat;

  // just use the stock Win32 function
  stat = CopyFile(src, dest,
                  0);  // 1=fail if exist
  if (stat)
    return 0; // ok, worked

  return 1; // failed

#ifdef COMMENT_OUT
 char *buf;
 unsigned int bytes, wbytes;
 int err = 0;
 int chk = 0;

 OUR_FILE *fp1, *fp2;

  buf = (char *) malloc(0x4010);
  if (buf == NULL)
  {
    //our_message("Error, no memory",MB_OK);
    return 6;  // no mem
  }

  fp1 = our_fopen(src,"rb");
  if (fp1 == NULL)
  {
    //our_message("Error Opening to read",MB_OK);
    free(buf);
    return 1;  // no src
  }

  fp2 = our_fopen(dest,"wb");
  if (fp2 == NULL)
  {
    //our_message("Error Opening to write",MB_OK);
    free(buf);
    our_fclose(fp1);
    return 2;  /* err opening dest */
  }

  bytes = our_fread(buf, 1, 0x4000, fp1);
  while ((bytes > 0) && (!err))
  {
    ++chk;
    if (chk > 10000)
      err = 5;
    wbytes = our_fwrite(buf, 1, bytes, fp2);
    if (wbytes != bytes)
    {
      err = 3;
    }
    bytes = our_fread(buf, 1, 0x4000, fp1);

    if (our_ferror(fp1))
    {
      //our_message("Error reading",MB_OK);
      err = 4;
    }
    if (our_ferror(fp2))
    {
      //our_message("Error writing",MB_OK);
      err = 6;
    }
  }

  free(buf);
  our_fclose(fp1);
  our_fclose(fp2);

  return err;  // 0=ok, else error
#endif
}

/*-----------------------------------------------------------------------------
| our_message -
|-----------------------------------------------------------------------------*/
int APIENTRY our_message(InstallPaths *ip, char *str, WORD option)
{
  if (ip->prompting_off)
  {
    // we are doing unattended install, and don't want user interface
    // popping up.  So just say YES or OK to all prompts.
    if (option == MB_YESNO)
      return IDYES;
    return IDOK;
  }
  return MessageBox(GetFocus(), str, ip->szAppName, option);
}

/*-----------------------------------------------------------------------------
| load_str -
|-----------------------------------------------------------------------------*/
int APIENTRY load_str(HINSTANCE hinst, int id, char *dest, int str_size)
{
  dest[0] = 0;
  if (!LoadString(hinst, id, dest, str_size) )
  {
    wsprintf(dest,"Err,str-id %d", id);
    MessageBox(GetFocus(), dest, "Error", MB_OK);
    return 1;
  }
  return 0;
}

#if 0
/*-----------------------------------------------------------------------------
| our_id_message -
|-----------------------------------------------------------------------------*/
int APIENTRY our_id_message(InstallPaths *ip, int id, WORD prompt)
{
 int stat;
  if (ip->prompting_off)
  {
    // we are doing unattended install, and don't want user interface
    // popping up.  So just say YES or OK to all prompts.
    if (option == MB_YESNO)
      return IDYES;
    return IDOK;
  }

  load_str(ip->hinst, id, ip->tmpstr, CharSizeOf(ip->tmpstr));
  stat = our_message(ip, ip->tmpstr, prompt);
  return stat;
}
#endif

/*---------------------------------------------------------------------------
| mess - message
|---------------------------------------------------------------------------*/
void APIENTRY mess(InstallPaths *ip, char *format, ...)
{
  va_list next;
  char buf[200];

  if (ip->prompting_off)
    return;

  va_start(next, format);
  vsprintf(buf, format, next);
  MessageBox(GetFocus(), buf, ip->szAppName, MB_OK);
}

TCHAR *
RcStr( int MsgIndex )
{
  static TCHAR RcStrBuf[200];

  load_str(glob_hinst, MsgIndex, RcStrBuf, CharSizeOf(RcStrBuf) );
  if (!LoadString(glob_hinst, MsgIndex, RcStrBuf, CharSizeOf(RcStrBuf)) ) {
    wsprintf(RcStrBuf,"Err, str-id %d", MsgIndex);
  }

  return RcStrBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\rocku.c ===
/*-----------------------------------------------------------------------
 rocku.c - Utils for setup program.  Get and Set registry settings.

11-05-97 V1.12, Add backup server fields to registry.

Copyright 1997,98 Comtrol(TM) Corporation.
|-----------------------------------------------------------------------*/
#include "precomp.h"

// had a problem with c-file stuff with DLL build, uncomment to ignore problem
//#define NO_CLIB_FILE_STUFF

static char *szSetupVer = {"SetupVersion"};

//---- port options:

static char *szParameters = {"Parameters"};
static char *szLinkage    = {"Linkage"};
static char *szSlash = {"\\"};
static char *szDeviceNode = {"Device%d"};
static char *szPortNode = {"Port%d"};

//static char gstr[200];

static int get_reg_option(int OptionVarType,
                          HKEY RegKey,
                          const char *szVarName,
                          char *szValue,
                          int szValueSize,
                          DWORD *ret_dword);

#ifdef NT50
/*-----------------------------------------------------------------
  clear_nt_device - clear out the Device# entries.
|------------------------------------------------------------------*/
int clear_nt_device(Driver_Config *wi)
{
 DWORD dstat;
 char tmpstr[50];
 char reg_str[240];
 HKEY DrvHandle = NULL;
 HKEY NewHandle = NULL;
 Device_Config *dev;

 int stat;

  DbgPrintf(D_Test, (TEXT("clear_nt_device\n")));

#ifdef NT50
  make_szSCS(reg_str, szServiceName);
  stat = reg_open_key(NULL, &NewHandle, reg_str, KEY_READ);
#else
  make_szSCS(reg_str, szServiceName);
  stat = reg_open_key(NULL, &NewHandle, reg_str, KEY_READ);
#endif
  if (stat == 0)
  {
    stat = reg_open_key(NewHandle, &DrvHandle, szParameters, KEY_READ);
    reg_close_key(NewHandle);
  }
  else
  {
    DbgPrintf(D_Error, (TEXT("no service key %s\n"), reg_str));
    return 1;
  }

  if (DrvHandle == NULL)
  {
    DbgPrintf(D_Error, (TEXT("no drv key for %s\n"), szParameters));
    return 2;
  }

  dev = &wi->dev[0];
#if (defined(NT50))
    // for nt50 and rocketport, the os tracks our devices, and
    // we use a pnp name to stash our configuration
  strcpy(tmpstr, wi->ip.szNt50DevObjName);
#else
  wsprintf(tmpstr, szDeviceNode, dev_i);
#endif

  RegDeleteKeyNT(DrvHandle, tmpstr);
  reg_close_key(DrvHandle);

  return 0;
}
#endif

/*-----------------------------------------------------------------
  get_nt_config - Read the configuration information from the registry.
|------------------------------------------------------------------*/
int get_nt_config(Driver_Config *wi)
{
 DWORD dstat, option_dword;               //hopefully ERROR_SUCCESS
 int dev_i, pi;
 Device_Config *dev;
 Port_Config *port;
 char tmpstr[50];
 char reg_str[240];
 char option_str[240];
 Our_Options *options;

 HKEY DrvHandle = NULL;
 HKEY DevHandle = NULL;
 HKEY PortHandle = NULL;
 //HKEY NewHandle = NULL;

 int stat;
#ifdef S_VS
 int mac_nums[6];
#endif
  DbgPrintf(D_Test, (TEXT("get_nt_config\n")));

  make_szSCS(reg_str, szServiceName);

  strcat(reg_str, szSlash);
  strcat(reg_str, szParameters);

  wi->nt_reg_flags = 0;      // default these flags to zero
  // get setup version string, helps us track if this is initial
  // install, if we are upgrading setup, etc.
  stat = reg_get_str(NULL, reg_str, szSetupVer, tmpstr, 10);
  if (stat != 0)
  {
     // failed to load this, so mark as initial install.
     wi->nt_reg_flags |= 4;  // initial install(no version string found).
  }

  wi->VerboseLog = 0;
#ifndef NT50
  wi->NumDevices = 0;  
#endif
  wi->NoPnpPorts = 0;
  wi->ScanRate = 0;
  wi->GlobalRS485 = 0;
  wi->ModemCountry = mcNA;            // North America

  options = driver_options;  // point at first in array(null terminated list)
  stat = reg_open_key(NULL, &DrvHandle, reg_str, KEY_READ);
  if (stat != 0)
  {
    DbgPrintf(D_Error, (TEXT("bad drv handle:%s\n"),reg_str));
  }
  while (options->name != NULL)
  {
    dstat = get_reg_option(options->var_type,  // dword, string, etc
                           DrvHandle,
                           options->name,  // name of var. to get
                           option_str,
                           60,
                           &option_dword);
    if (dstat == 0) // ok we read it
    {
      //DbgPrintf(D_Test, (TEXT("got drv op %s\n"), options->name));
      
      switch(options->id)
      {
        case OP_VerboseLog:
          wi->VerboseLog = option_dword;
        break;
        case OP_NumDevices:
          wi->NumDevices = option_dword;
        break;
        case OP_NoPnpPorts:
          wi->NoPnpPorts = option_dword;
        break;
        case OP_ScanRate:
          wi->ScanRate = option_dword;
        break;
        case OP_ModemCountry:
          wi->ModemCountry = option_dword;
        break;
        case OP_GlobalRS485:
          wi->GlobalRS485 = option_dword;
        break;
      }
    }
    else
    {
      //DbgPrintf(D_Error, (TEXT("no driver option %s\n"),options->name));
    }
    ++options; // next in list
  }  // while

  if (wi->NumDevices > MAX_NUM_DEVICES)   // limit to some sane value
     wi->NumDevices = MAX_NUM_DEVICES;
    // Loop through all possible boards/devices

  if (DrvHandle != NULL)
  {
    stat = reg_open_key(DrvHandle, &DevHandle, szParameters, KEY_READ);
  }

  //--- read in device options
  for(dev_i=0; dev_i<wi->NumDevices; dev_i++)
  {
    dev = &wi->dev[dev_i];
#if (defined(NT50))
      // for nt50 and rocketport, the os tracks our devices, and
      // we use a pnp name to stash our configuration
    strcpy(tmpstr, wi->ip.szNt50DevObjName);
#else
    wsprintf(tmpstr, szDeviceNode,dev_i);
#endif
    stat = reg_open_key(DrvHandle, &DevHandle, tmpstr, KEY_READ);
    if (stat)
    {
      DbgPrintf(D_Error, (TEXT("no dev key for %s\n"), tmpstr));
      continue;
    }

    options = device_options;  // point at first in array(null terminated list)
    while (options->name != NULL)
    {
      dstat = get_reg_option(options->var_type,  // dword, string, etc
                             DevHandle,
                             options->name,  // name of var. to get
                             option_str, 60, &option_dword);  // return string value
      if (dstat == 0) // ok we read it
      {
        //DbgPrintf(D_Test, (TEXT("got dev op %s\n"), options->name));
        switch(options->id)
        {
          case OP_NumPorts:
            dev->NumPorts = option_dword;
          break;
#ifdef S_VS
          case OP_MacAddr:
            stat = sscanf(option_str, "%x %x %x %x %x %x",
                     &mac_nums[0], &mac_nums[1], &mac_nums[2],
                     &mac_nums[3], &mac_nums[4], &mac_nums[5]);
            if (stat == 6)
            {
              dev->MacAddr[0] = mac_nums[0];
              dev->MacAddr[1] = mac_nums[1];
              dev->MacAddr[2] = mac_nums[2];
              dev->MacAddr[3] = mac_nums[3];
              dev->MacAddr[4] = mac_nums[4];
              dev->MacAddr[5] = mac_nums[5];

  DbgPrintf(D_Test, ("read config mac: %x %x %x %x %x %x\n",
           dev->MacAddr[0], dev->MacAddr[1], dev->MacAddr[2],
           dev->MacAddr[3], dev->MacAddr[4], dev->MacAddr[5]))
            }
          break;
          case OP_BackupServer:
            dev->BackupServer = option_dword;
          break;
          case OP_BackupTimer:
            dev->BackupTimer = option_dword;
    DbgPrintf(D_Test,(TEXT("reg backTimer:%d\n"), dev->BackupTimer));
          break;
#endif
          case OP_Name:
            if (strlen(option_str) >= sizeof(dev->Name))
              option_str[sizeof(dev->Name)-1] = 0;
            strcpy(dev->Name, option_str);
          break;
          case OP_ModelName:
            if (strlen(option_str) >= sizeof(dev->ModelName))
              option_str[sizeof(dev->ModelName)-1] = 0;
            strcpy(dev->ModelName, option_str);
          break;
#ifdef S_RK
          case OP_IoAddress:
            dev->IoAddress = option_dword;
          break;
#endif
          case OP_ModemDevice:
            dev->ModemDevice = option_dword;
          break;
          case OP_HubDevice:
            dev->HubDevice = option_dword;
          break;
        }
      }
      else
      {
        DbgPrintf(D_Test, (TEXT("NOT got dev op %s\n"), options->name));
      }
      ++options;
    }

    for(pi=0; pi<dev->NumPorts; pi++)   // Loop through all ports
    {
      port = &dev->ports[pi];

      port->LockBaud = 0;
      port->TxCloseTime = 0;
      port->MapCdToDsr = 0;
      port->RingEmulate = 0;
      port->WaitOnTx = 0;
      port->RS485Override = 0;
      port->RS485Low = 0;
      port->Map2StopsTo1 = 0;

      wsprintf(tmpstr, szPortNode,pi);
      stat = reg_open_key(DevHandle, &PortHandle, tmpstr, KEY_READ);
      if (stat)
      {
        DbgPrintf(D_Error, (TEXT("no port key: %s\n"), tmpstr));
        if (DevHandle == NULL)
        {
          DbgPrintf(D_Error, (TEXT("no dev handle\n")));
        }
        continue;
      }

      options = port_options;  // point at first in array(null terminated list)
      while (options->name != NULL)
      {
        dstat = get_reg_option(options->var_type,  // dword, string, etc
                               PortHandle,
                               options->name,  // name of var. to get
                               option_str, 60, &option_dword);  // return string value
        if (dstat == 0) // ok we read it
        {
          //DbgPrintf(D_Test, (TEXT("got port op %s\n"), options->name));
          switch(options->id)
          {
            case OP_WaitOnTx:
              port->WaitOnTx = option_dword;
            break;
            case OP_RS485Override:
              port->RS485Override = option_dword;
            break;
            case OP_RS485Low:
              port->RS485Low = option_dword;
            break;
            case OP_TxCloseTime:
              port->TxCloseTime = option_dword;
            break;
            case OP_LockBaud:
              port->LockBaud = option_dword;
            break;
            case OP_Map2StopsTo1:
              port->Map2StopsTo1 = option_dword;
            break;
            case OP_MapCdToDsr:
              port->MapCdToDsr = option_dword;
            break;
            case OP_RingEmulate:
              port->RingEmulate = option_dword;
            break;
            case OP_PortName:
              if (strlen(option_str) >= sizeof(port->Name))
                option_str[sizeof(port->Name)-1] = 0;
              strcpy(port->Name, option_str);
            break;
          }
        }
        ++options;
      }
      //wsprintf(dev->Name, "COM%d", pi+5);
      reg_close_key(PortHandle);
    }  // numports
    reg_close_key(DevHandle);
  }  // for all devices(boards or boxes)

  reg_close_key(DrvHandle);

                         // "SYSTEM\\CurrentControlSet\\Services -
                         //   \\EventLog\\System\\RocketPort"
  make_szSCSES(reg_str, szServiceName);
  if (!reg_key_exists(NULL,reg_str))
       wi->nt_reg_flags |= 1;  // missing important registry info(possibly)

  make_szSCS(reg_str, szServiceName);
  strcat(reg_str, szSlash); strcat(reg_str, szLinkage);
  if (!reg_key_exists(NULL, reg_str))
       wi->nt_reg_flags |= 2;  // missing linkage thing(did not install via network inf)

  return 0;
}

/*----------------------------------------------------------------------
 get_reg_option - read in a option from the registry, and convert it to
   ascii.
|----------------------------------------------------------------------*/
static int get_reg_option(int OptionVarType,
                          HKEY RegKey,
                          const char *szVarName,
                          char *szValue,
                          int szValueSize,
                          DWORD *ret_dword)
{
 int stat = 1;  // err
 //ULONG dwValue;

  if (RegKey == NULL)
    return 1;

  if (OptionVarType == OP_T_STRING)  // string option type
  {
    szValue[0] = 0;
    stat = reg_get_str(RegKey, "", szVarName, szValue, szValueSize);
    if (stat)
      szValue[0] = 0;
  }
  else  // DWORD option type
  {
    stat = reg_get_dword(RegKey, "", szVarName, ret_dword);
    if (stat)
      *ret_dword = 0;
  }
  return stat;
}

/*-----------------------------------------------------------------
  set_nt_config - Set the configuration information.
|------------------------------------------------------------------*/
int set_nt_config(Driver_Config *wi)
{
 int  i,pi, stat;
 char tmpstr[150];
 char str[240];
 DWORD dstat, dwstat;
 int bad_error = 0;
 int new_install = 0;
 Device_Config *dev;
 Port_Config *port;
 HKEY DrvHandle = NULL;
 HKEY DevHandle = NULL;
 HKEY PortHandle = NULL;
 HKEY NewHandle = NULL;

  DbgPrintf(D_Test, (TEXT("set_nt_config\n")));
  // -------- create the following if not present:
  // "SYSTEM\\CurrentControlSet\\Services\\RocketPort",
  make_szSCS(str, szServiceName);
  if (!reg_key_exists(NULL, str))
    dstat = reg_create_key(NULL, str);

  stat = reg_open_key(NULL, &NewHandle, str, KEY_ALL_ACCESS);
  if (stat)
  {
    DbgPrintf(D_Test, (TEXT("bad service handle:%s\n"),str));
  }

  // -------- create the following if not present:
  // "SYSTEM\\CurrentControlSet\\Services\\RocketPort\\Parameters",
  if (!reg_key_exists(NewHandle, szParameters))
    dstat = reg_create_key(NewHandle, szParameters);  // create it

  stat = reg_open_key(NewHandle, &DrvHandle, szParameters, KEY_ALL_ACCESS);
  if (stat)
  {
    DbgPrintf(D_Test, (TEXT("bad drv handle:%s\n"),str));
  }
  reg_close_key(NewHandle);

  //----- set setup version string, helps us track if this is initial
  // install, if we are upgrading setup, etc.
  dstat = reg_set_str(DrvHandle, "", szSetupVer, VERSION_STRING, REG_SZ);

  //---- see if parameter is present, if not assume it
  //---- is a new install(as apposed to changing parameters).
  dstat = reg_get_dword(DrvHandle, "", szNumDevices, &dwstat);
  if (dstat)
     new_install = 1;  // new install

  // -------- create the following if not present:
  // "SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\RocketPort"
  make_szSCSES(str, szServiceName);
  if (!reg_key_exists(NULL,str))
    dstat = reg_create_key(NULL,str);

                  // ---- Set the Event ID message-file name.
  strcpy(tmpstr, "%SystemRoot%\\system32\\IoLogMsg.dll;");
  strcat(tmpstr, "%SystemRoot%\\system32\\drivers\\");
  strcat(tmpstr, wi->ip.szDriverName);
  dstat = reg_set_str(NULL, str, "EventMessageFile", tmpstr, REG_EXPAND_SZ);
   
                  // ---- Set the supported types flags.
  dstat = reg_set_dword(NULL, str, "TypesSupported",
                  EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE |
                  EVENTLOG_INFORMATION_TYPE);

                  // ---- Setup some NT-specific registry variables
                  // "SYSTEM\\CurrentControlSet\\Services\\RocketPort",
  make_szSCS(str, szServiceName);
  dstat = reg_set_dword(NULL, str, "ErrorControl", SERVICE_ERROR_IGNORE); // 0

  dstat = reg_set_str(NULL, str, "Group", "Extended Base", REG_SZ);

  strcpy(tmpstr, "System32\\Drivers\\");
  strcat(tmpstr, wi->ip.szDriverName);
  dstat = reg_set_str(NULL, str, "ImagePath", tmpstr, REG_SZ);

  // allows user(programmer) to turn following off and leave it off!

  if (new_install) // fresh install
  {
#ifdef NT50
    dstat = reg_set_dword(NULL, str, "Start", 3); // SERVICE_DEMAND_START
#else
    dstat = reg_set_dword(NULL, str, "Start", SERVICE_AUTO_START);  // 2
#endif
  }
  dstat = reg_set_dword(NULL, str, "Tag", 1);  // 1 (load order)
  dstat = reg_set_dword(NULL, str, "Type", SERVICE_KERNEL_DRIVER);  // 1

  dstat = reg_set_dword_del(DrvHandle,"", szNumDevices, wi->NumDevices,0);
  dstat = reg_set_dword_del(DrvHandle,"", szModemCountry, wi->ModemCountry, mcNA);
  dstat = reg_set_dword_del(DrvHandle,"", szGlobalRS485, wi->GlobalRS485, 0);
  dstat = reg_set_dword_del(DrvHandle,"", szVerboseLog, wi->VerboseLog,0);
  dstat = reg_set_dword_del(DrvHandle,"", szScanRate, wi->ScanRate,0);
  dstat = reg_set_dword_del(DrvHandle,"", szNoPnpPorts, wi->NoPnpPorts,0);

  reg_close_key(DrvHandle);
#if (defined(NT50) && defined(USE_PNP_AREA))
  stat = nt5_open_dev_key(&NewHandle);
#else
  make_szSCS(str, szServiceName);
  stat = reg_open_key(NULL, &NewHandle, str, KEY_ALL_ACCESS);
  if (stat)
  {
    DbgPrintf(D_Test, (TEXT("bad service handle:%s\n"),str));
  }
#endif

  // -------- create the following if not present:
  // "SYSTEM\\CurrentControlSet\\Services\\RocketPort\\Parameters",
  if (!reg_key_exists(NewHandle, szParameters))
    dstat = reg_create_key(NewHandle, szParameters);  // create it

  stat = reg_open_key(NewHandle, &DrvHandle, szParameters, KEY_ALL_ACCESS);
  if (stat)
  {
    DbgPrintf(D_Test, (TEXT("Bad drv handle:%s\n"),str));
  }
  reg_close_key(NewHandle);


  for(i=0; i<wi->NumDevices; i++)   // Loop through all possible boxes
  {
    dev = &wi->dev[i];

#if (defined(NT50))
# ifdef USE_PNP_AREA
    tmpstr[0] = 0;
# else
      // for nt50 and rocketport, the os tracks our devices, and
      // we use a pnp name to stash our configuration
    strcpy(tmpstr, wi->ip.szNt50DevObjName);
#endif
#else
    wsprintf(tmpstr, szDeviceNode,i);
#endif

    if (tmpstr[0] != 0)
    {
      if (!reg_key_exists(DrvHandle, tmpstr))
        dstat = reg_create_key(DrvHandle, tmpstr);  // create it

      stat = reg_open_key(DrvHandle, &DevHandle, tmpstr, KEY_ALL_ACCESS);
      if (stat)
      {
        DbgPrintf(D_Test, (TEXT("bad dev handle:%s\n"),tmpstr));
      }
    }
    else
    {
      // must be nt50 pnp, where we write out to the pnp reg area.
      DevHandle = DrvHandle;
    }

    DbgPrintf(D_Test, (TEXT("set reg dev %s \n"), tmpstr));
    dstat = reg_set_dword_del(DevHandle,"", szNumPorts, dev->NumPorts,0);
    dstat = reg_set_str(DevHandle,"", szName, dev->Name, REG_SZ);
    dstat = reg_set_dword_del(DevHandle,"", szModemDevice, dev->ModemDevice, 0);
    dstat = reg_set_dword_del(DevHandle,"", szHubDevice, dev->HubDevice, 0);
    dstat = reg_set_str(DevHandle,"", szModelName, dev->ModelName, REG_SZ);
#ifdef S_VS
    dstat = reg_set_dword_del(DevHandle,"", szBackupServer, dev->BackupServer,0);
    dstat = reg_set_dword_del(DevHandle,"", szBackupTimer, dev->BackupTimer,0);
    wsprintf(tmpstr, "%x %x %x %x %x %x",
              dev->MacAddr[0], dev->MacAddr[1], dev->MacAddr[2],
              dev->MacAddr[3], dev->MacAddr[4], dev->MacAddr[5]);
    dstat = reg_set_str(DevHandle,"", szMacAddr, tmpstr,REG_SZ);
#else
  // rocket
    dstat = reg_set_dword_del(DevHandle,"", szIoAddress, dev->IoAddress,0);
#endif

    for(pi=0; pi<dev->NumPorts; pi++)   // Loop through all ports
    {
      port = &dev->ports[pi];
      wsprintf(tmpstr, szPortNode,pi);

      if (!reg_key_exists(DevHandle, tmpstr))
        dstat = reg_create_key(DevHandle, tmpstr);  // create it

      stat = reg_open_key(DevHandle, &PortHandle, tmpstr, KEY_ALL_ACCESS);
      if (stat)
      {
        DbgPrintf(D_Test, (TEXT("bad port handle:%s\n"),tmpstr));
      }

      //DbgPrintf(D_Test, (TEXT("set port %s \n"), tmpstr));
      dstat = reg_set_str(PortHandle,"", szName, port->Name, REG_SZ);
      dstat = reg_set_dword_del(PortHandle,"", szLockBaud, port->LockBaud, 0);
      dstat = reg_set_dword_del(PortHandle,"", szTxCloseTime, port->TxCloseTime, 0);
      dstat = reg_set_dword_del(PortHandle,"", szMapCdToDsr, port->MapCdToDsr, 0);
      dstat = reg_set_dword_del(PortHandle,"", szRingEmulate, port->RingEmulate, 0);
      dstat = reg_set_dword_del(PortHandle,"", szWaitOnTx, port->WaitOnTx, 0);
      dstat = reg_set_dword_del(PortHandle,"", szRS485Override, port->RS485Override, 0);
      dstat = reg_set_dword_del(PortHandle,"", szRS485Low, port->RS485Low, 0);
      dstat = reg_set_dword_del(PortHandle,"", szMap2StopsTo1, port->Map2StopsTo1, 0);
      reg_close_key(PortHandle);
    }  // ports loop

    // clear out any old box keys(bugbug:this won't work with values in it!)
    for(pi=dev->NumPorts; pi<MAX_NUM_PORTS_PER_DEVICE; pi++)// Loop through all ports
    {
      port = &dev->ports[pi];
      wsprintf(tmpstr, szPortNode,pi);

      if (reg_key_exists(DevHandle, tmpstr))
        reg_delete_key(DevHandle, "", tmpstr);  // create it
    }
    reg_close_key(DevHandle);
  }  // dev loop

  reg_close_key(DrvHandle);

  return 0;  // ok
}

/*----------------------------------------------------------------------
| copy_files_nt - Handle file copies for either Windows NT
|----------------------------------------------------------------------*/
int copy_files_nt(InstallPaths *ip)
{
 char *pstr;
 int stat;
#ifdef S_VS
 static char *nt_files[] = {
                            "ctmmdm35.inf",
                            "readme.txt",
                            "setup.exe",
                            "setup.hlp",
                            "wcom32.exe",
                            "wcom.hlp",
                            "portmon.exe",
                            "portmon.hlp",
                            "peer.exe",
                            "peer.hlp",
                            NULL};

 static char *nt_driver[] = {"vslinka.sys",
                             "vslinka.bin",
                             NULL};
#else
 static char *nt_files[] = {
                            "ctmmdm35.inf",
                            "readme.txt",
                            "setup.exe",
                            "setup.hlp",
                            "wcom32.exe",
                            "wcom.hlp",
                            "portmon.exe",
                            "portmon.hlp",
                            "peer.exe",
                            "ctmmdmld.rm",
                            "ctmmdmfw.rm",
                            "peer.hlp",
                            NULL};

 static char *nt_driver[] = {"rocket.sys",
                             NULL};

#endif
 static char *nt_inf[] = {  "mdmctm1.inf",
                            NULL};

  //------ Copy driver to the driver dir
  GetSystemDirectory(ip->dest_dir, 144);
  strcat(ip->dest_dir,"\\Drivers");

  stat = copy_files(ip, nt_driver);
  if (stat)
     return 1;  // error

  GetSystemDirectory(ip->dest_dir, 144);
  pstr = ip->dest_dir;
  while (*pstr)  // find end of string
    ++pstr;
  while ((*pstr != '\\')  && (pstr != ip->dest_dir)) // find "\\System32"
    --pstr;
  *pstr = 0;  // null terminate here
  strcat(ip->dest_dir,"\\Inf");  // copy to INF directory

  stat = copy_files(ip, nt_inf);

  GetSystemDirectory(ip->dest_dir, 144);
#ifdef S_VS
  strcat(ip->dest_dir, "\\vslink");
#else
  strcat(ip->dest_dir, "\\rocket");
#endif
#ifndef NO_CLIB_FILE_STUFF
  _mkdir(ip->dest_dir);
#endif
  stat = copy_files(ip, nt_files);

  return 0;  // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\setup.c ===
/*-----------------------------------------------------------------------
| setup.c - VSLinkA/RocketPort Windows Install Program.
12-11-98 - use szAppTitle(.rc str) instead of aptitle for prop sheet title.
11-24-98 - zero out psh struct to ensure deterministic propsheet behavior. kpb
10-23-98 - in send_to_driver, fix ioctl_close() when inappropriate,
  caused crash on setup exit.
 9-25-98 - on nt4 uninstall, rename setup.exe to setupold.exe since
   we can't delete it.  This fixes backward compatibility problem.
Copyright 1998. Comtrol(TM) Corporation.
|-----------------------------------------------------------------------*/
#include "precomp.h"

#define D_Level 0x100

static int option_changed(char *value_str,
                   int *ret_chg_flag,
                   int *ret_unknown_flag,
                   Our_Options *option,
                   int device_index,
                   int port_index);
static int send_option(char *str_value,
                Our_Options *option,
                int device_index,
                int port_index,
                char *ioctl_buf,
                IoctlSetup *ioctl_setup);
static int auto_install(void);
int our_ioctl_call(IoctlSetup *ioctl_setup);
static int remove_old_infs(void);

int debug_flags = 1;
int prompting_off = 0; // turn our_message() prompting off for auto-install

/*----------------------- local vars ---------------------------------*/
static char *szSlash = {"\\"};

static char szInstallGroup[60];
static char szModemInfEntry[60];

#if DBG
static TCHAR *dbg_label = TEXT("DBG_VERSION");
#endif

char szAppTitle[60];
#ifdef S_VS
//----------- VSLinkA Specific Strings and variables
//char *aptitle = {"Comtrol Hardware Setup, Comtrol Corporation"};
char *szAppName = {"VS1000/VS2000/RocketPort Serial Hub"};
char *OurServiceName = {"VSLinka"};
char *OurDriverName = {"VSLinka.sys"};
char *OurAppDir = {"VSLink"};
#ifdef NT50
char *szSetup_hlp = {"vssetup.hlp"};
#else
char *szSetup_hlp = {"setup.hlp"};
#endif

char *progman_list_nt[] = {
  szInstallGroup,   //  "Comtrol VS Link",   // group Description
  "vslink.grp",        // group file name
#ifndef NT50
  "Comtrol Hardware Setup", // item 1
  "setup.exe",         // file 1
#endif
  "Test Terminal",     // item 2
  "wcom32.exe",        // file 2

  "Port Monitor",      // item 3
  "portmon.exe",       // file 3
  NULL};
#else
//----------- RocketPort Specific Strings and variables
//char *aptitle = {"RocketPort Setup, Comtrol Corporation"};
char *szAppName = {"RocketPort"};
char *OurServiceName = {"RocketPort"};
char *OurDriverName = {"rocket.sys"};
char *OurAppDir = {"Rocket"};
#ifdef NT50
char *szSetup_hlp = {"ctmasetp.chm"};
#else
char *szSetup_hlp = {"setup.hlp"};
#endif

char *progman_list_nt[] = {
  szInstallGroup,   //  "Comtrol RocketPort RocketModem",   // group Description
  "rocket.grp",        // group file name
#ifndef NT50
  "RocketPort Setup",  // item 1
  "setup.exe",       // file 1
#endif
  "Test Terminal",     // item 2
  "wcom32.exe",        // file 2

  "Port Monitor",      // item 3
  "portmon.exe",       // file 3
  NULL};
#endif

//	WinHelp array. commented out values are defined, but unused.
//	in alphabetical order...
//
const DWORD help_ids[] = {
IDB_ADD,      IDB_ADD,
IDB_DEF,      IDB_DEF,
//	IDB_DONE,IDB_DONE,
//	IDB_HELP,IDB_HELP,
//	IDB_INSTALL,IDB_INSTALL,
IDB_PROPERTIES,  IDB_PROPERTIES,
IDB_REFRESH,     IDB_REFRESH,
IDB_REMOVE,      IDB_REMOVE,
IDB_RESET,       IDB_RESET,
IDB_STAT_RESET,  IDB_STAT_RESET,
IDC_BACKUP_SERVER, IDC_BACKUP_SERVER,
IDC_BACKUP_TIMER,  IDC_BACKUP_TIMER,
IDC_CBOX_IOADDR,   IDC_CBOX_IOADDR,
//	IDC_CBOX_IRQ,IDC_CBOX_IRQ,
IDC_CBOX_MACADDR,  IDC_CBOX_MACADDR,
//	IDC_CBOX_MAPBAUD,IDC_CBOX_MAPBAUD,
IDC_CBOX_NUMPORTS, IDC_CBOX_NUMPORTS,
IDC_CBOX_SC,       IDC_CBOX_SC,
IDC_CBOX_SCAN_RATE,IDC_CBOX_SCAN_RATE,
//	IDC_CBOX_TYPE,IDC_CBOX_TYPE,
IDC_CLONE,         IDC_CLONE,
//	IDC_CONF,IDC_CONF,
IDC_EB_NAME,       IDC_EB_NAME,
IDC_GROUP,         IDC_GROUP,
IDC_LBL_SUMMARY1,  IDC_LBL_SUMMARY1,
IDC_LBL_SUMMARY2,  IDC_LBL_SUMMARY2,
IDC_LBOX_DEVICE,   IDC_LBOX_DEVICE,
IDC_MAP_2TO1,      IDC_MAP_2TO1,
IDC_MAP_CDTODSR,   IDC_MAP_CDTODSR,
IDC_RING_EMULATE, IDC_RING_EMULATE,
//	IDC_PN0,IDC_PN0,
//	IDC_PN1,IDC_PN1,
//	IDC_PN2,IDC_PN2,
//	IDC_PN3,IDC_PN3,
IDC_PNP_PORTS,      IDC_PNP_PORTS,
IDC_PORT_LOCKBAUD,  IDC_PORT_LOCKBAUD,
IDC_PORT_RS485_LOCK,IDC_PORT_RS485_LOCK,
IDC_PORT_RS485_TLOW,IDC_PORT_RS485_TLOW,
IDC_PORT_WAIT_ON_CLOSE,  IDC_PORT_WAIT_ON_CLOSE,
IDC_PORT_WONTX,     IDC_PORT_WONTX,
IDC_PS_PORT,        IDC_PS_PORT,
IDC_ST_NIC_DVC_NAME,IDC_ST_NIC_DVC_NAME,
IDC_ST_NIC_MAC,     IDC_ST_NIC_MAC,
IDC_ST_NIC_PKT_RCVD_NOT_OURS,  IDC_ST_NIC_PKT_RCVD_NOT_OURS,
IDC_ST_NIC_PKT_RCVD_OURS,      IDC_ST_NIC_PKT_RCVD_OURS,
IDC_ST_NIC_PKT_SENT,  IDC_ST_NIC_PKT_SENT,
IDC_ST_PM_LOADS,      IDC_ST_PM_LOADS,
IDC_ST_STATE,         IDC_ST_STATE,
IDC_ST_VSL_DETECTED,  IDC_ST_VSL_DETECTED,
IDC_ST_VSL_IFRAMES_OUTOFSEQ, IDC_ST_VSL_IFRAMES_OUTOFSEQ,
IDC_ST_VSL_IFRAMES_RCVD,     IDC_ST_VSL_IFRAMES_RCVD,
IDC_ST_VSL_IFRAMES_RESENT,   IDC_ST_VSL_IFRAMES_RESENT,
IDC_ST_VSL_IFRAMES_SENT,     IDC_ST_VSL_IFRAMES_SENT,
IDC_ST_VSL_MAC,    IDC_ST_VSL_MAC,
IDC_ST_VSL_STATE,  IDC_ST_VSL_STATE,
//	IDC_USE_IRQ,IDC_USE_IRQ,
IDC_VERBOSE,  IDC_VERBOSE,
IDC_VERSION,  IDC_VERSION,
//	IDC_WIZ1_ISA,IDC_WIZ1_ISA,
//	IDC_WIZ1_ISA2,IDC_WIZ1_ISA2,
IDC_WIZ_BOARD_SELECT,   IDC_WIZ_BOARD_SELECT,
IDC_WIZ_CBOX_COUNTRY,   IDC_WIZ_CBOX_COUNTRY,
IDC_WIZ_CBOX_IOADDR,    IDC_WIZ_CBOX_IOADDR,
IDC_WIZ_CBOX_NUMPORTS,  IDC_WIZ_CBOX_NUMPORTS,
IDC_WIZ_CBOX_MAC,       IDC_WIZ_CBOX_MAC,
IDC_WIZ_ISA,  IDC_WIZ_ISA,
IDC_WIZ_PCI,  IDC_WIZ_PCI,
//	IDC_ADD_WIZ1,IDC_ADD_WIZ1,
//	IDC_ADD_WIZ2,IDC_ADD_WIZ2,
//	IDC_ADD_WIZ3,IDC_ADD_WIZ3,
IDD_ADD_WIZ_BASEIO,  IDD_ADD_WIZ_BASEIO,
IDD_ADD_WIZ_BOARD,   IDD_ADD_WIZ_BOARD,
IDD_ADD_WIZ_BUSTYPE, IDD_ADD_WIZ_BUSTYPE,
IDD_ADD_WIZ_COUNTRY, IDD_ADD_WIZ_COUNTRY,
IDD_ADD_WIZ_DONE,    IDD_ADD_WIZ_DONE,
IDD_ADD_WIZ_INTRO,   IDD_ADD_WIZ_INTRO,
IDD_ADD_WIZ_NUMPORTS,IDD_ADD_WIZ_NUMPORTS,

IDD_ADD_WIZ_DEVICE, IDD_ADD_WIZ_DEVICE,
IDD_ADD_WIZ_MAC, IDD_ADD_WIZ_MAC,
IDD_ADD_WIZ_BACKUP, IDD_ADD_WIZ_BACKUP,

IDD_DEVICE_SETUP,    IDD_DEVICE_SETUP,
IDD_DIALOG1,         IDD_DIALOG1,
IDD_DRIVER_OPTIONS,  IDD_DRIVER_OPTIONS,
IDD_DRIVER_OPTIONS_NT50, IDD_DRIVER_OPTIONS_NT50,
IDD_MAIN_DLG,        IDD_MAIN_DLG,
IDD_PORT_485_OPTIONS,IDD_PORT_485_OPTIONS,
IDD_PORT_MODEM_OPTIONS, IDD_PORT_MODEM_OPTIONS,
IDD_PORT_OPTIONS,       IDD_PORT_OPTIONS,
//	IDD_PORTLIST_PICK,   IDD_PORTLIST_PICK,
//	IDD_PROPPAGE_MEDIUM,IDD_PROPPAGE_MEDIUM,
IDD_STATUS,IDD_STATUS,  IDD_STATUS,IDD_STATUS,
IDD_VS_DEVICE_SETUP,    IDD_VS_DEVICE_SETUP,
IDM_ADVANCED,           IDM_ADVANCED,
IDM_ADVANCED_MODEM_INF, IDM_ADVANCED_MODEM_INF,
IDM_ADVANCED_NAMES,     IDM_ADVANCED_NAMES,
IDC_GLOBAL485, IDC_GLOBAL485,
//	IDM_CLOSE,IDM_CLOSE,
//	IDM_EDIT_README,IDM_EDIT_README,
IDM_EXIT,   IDM_EXIT,
//	IDM_F1,IDM_F1,
//	IDM_HELP,IDM_HELP,
//	IDM_HELPABOUT,IDM_HELPABOUT,
//	IDM_OPTIONS,IDM_OPTIONS,
//	IDM_PM,IDM_PM,
//	IDM_STATS,IDM_STATS,
	0xffffffff, 0,
	0, 0};

/*--------------------------  Global Variables  ---------------------*/
TCHAR m_szRegSerialMap[] = TEXT( "Hardware\\DeviceMap\\SerialComm" );

unsigned char broadcast_addr[6] = {0xff,0xff,0xff,0xff,0xff,0xff};
unsigned char mac_zero_addr[6] = {0,0,0,0,0,0};
HWND glob_hwnd = NULL;
HINSTANCE glob_hinst = 0;     // current instance
char gtmpstr[200];
HWND  glob_hDlg = 0;

OUR_INFO *glob_info = NULL;   // global context handles and general baggage to carry.
AddWiz_Config *glob_add_wiz;  // transfer buffer from Add Device wizard

Driver_Config *wi;      // current info
Driver_Config *org_wi;  // original info, use to detect changes

/*------------------------------------------------------------------------
| FillDriverPropertySheets - Setup pages for driver level property sheets.
|------------------------------------------------------------------------*/
int FillDriverPropertySheets(PROPSHEETPAGE *psp, LPARAM our_params)
{
  INT pi;
  static TCHAR mainsetstr[40], optstr[40];

  memset(psp, 0, sizeof(*psp) * NUM_DRIVER_SHEETS);

  pi = 0;

  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP | PSH_NOAPPLYNOW;
  psp[pi].hInstance = glob_hinst;
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_MAIN_DLG);
  psp[pi].pfnDlgProc = DevicePickSheet;
  load_str( glob_hinst, (TITLESTR+7), mainsetstr, CharSizeOf(mainsetstr) );
  psp[pi].pszTitle = mainsetstr;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;
  ++pi;

  psp[pi].dwSize = sizeof(PROPSHEETPAGE);
  psp[pi].dwFlags = PSP_USETITLE | PSP_HASHELP | PSH_NOAPPLYNOW;
  psp[pi].hInstance = glob_hinst;
#ifdef NT50
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_DRIVER_OPTIONS_NT50);
#else
  psp[pi].pszTemplate = MAKEINTRESOURCE(IDD_DRIVER_OPTIONS);
#endif
  psp[pi].pfnDlgProc = AdvDriverSheet;
  load_str( glob_hinst, (TITLESTR+8), optstr, CharSizeOf(optstr) );
  psp[pi].pszTitle = optstr;
  psp[pi].lParam = (LPARAM)our_params;
  psp[pi].pfnCallback = NULL;

  return 0;
}

/*------------------------------------------------------------------------
| setup_init - Instantiate and setup our main structures.  Also, allocate
    space for a original config struct(org_wi) for later detection
    of changes made to master config copy(wi).
|------------------------------------------------------------------------*/
int setup_init(void)
{
 int size,i;

  //---- allocate global baggage struct
  glob_info = (OUR_INFO *) calloc(1,sizeof(OUR_INFO));

  //---- allocate global add wizard transfer buffer
  glob_add_wiz = (AddWiz_Config *) calloc(1, sizeof(AddWiz_Config));

  //---- allocate driver struct
  size = sizeof(Driver_Config);
  wi =  (Driver_Config *) calloc(1,size);
  memset(wi, 0, size);  // clear our structure

  org_wi =  (Driver_Config *) calloc(1,size);
  memset(wi, 0, size);  // clear our structure

  //---- allocate device structs
  size = sizeof(Device_Config) * MAX_NUM_DEVICES;
  wi->dev     =  (Device_Config *) calloc(1,size);
  memset(wi->dev, 0, size);  // clear our structure

  org_wi->dev     =  (Device_Config *) calloc(1,size);
  memset(org_wi->dev, 0, size);  // clear our structure

  //---- allocate port structs
  for (i=0; i<MAX_NUM_DEVICES; i++)
  {
    size = sizeof(Port_Config) * MAX_NUM_PORTS_PER_DEVICE;
    wi->dev[i].ports = (Port_Config *) calloc(1,size);
    memset(wi->dev[i].ports, 0, size);  // clear our structure

    org_wi->dev[i].ports = (Port_Config *) calloc(1,size);
    memset(org_wi->dev[i].ports, 0, size);  // clear our structure
  }

  wi->install_style = INS_NETWORK_INF;  // default to original nt4.0 style

#if defined(S_VS)
  if (load_str(glob_hinst, IDS_VS_INSTALL_GROUP, szInstallGroup, CharSizeOf(szInstallGroup)))
  {
    MessageBox(GetFocus(), "Error String Load", OurServiceName, MB_OK);
    return 1;
  }
  load_str(glob_hinst, IDS_VS_AP_TITLE, szAppTitle, CharSizeOf(szAppTitle));
  load_str(glob_hinst, IDS_VS_MODEM_INF_ENTRY, szModemInfEntry, CharSizeOf(szModemInfEntry));
#else
  if (load_str(glob_hinst, IDS_INSTALL_GROUP, szInstallGroup, CharSizeOf(szInstallGroup)))
  {
    MessageBox(GetFocus(), "Error String Load", OurServiceName, MB_OK);
    return 1;
  }
  load_str(glob_hinst, IDS_AP_TITLE, szAppTitle, CharSizeOf(szAppTitle));
  load_str(glob_hinst, IDS_MODEM_INF_ENTRY, szModemInfEntry, CharSizeOf(szModemInfEntry));
#endif

  // fill in InstallPaths structure : system info, directory names, etc.
  setup_install_info(&wi->ip,    // our InstallPaths structure to fill out.
                     glob_hinst,     // stuff to fill it out with...
                     OurServiceName,
                     OurDriverName,
                     szAppTitle,
                     OurAppDir);

  return 0;  // ok
}

/*------------------------------------------------------------------------
| copy_setup_init - Make a copy of our original config to detect changes
   in our master copy later.  This is a bit wasteful of memory, especially
   since we just create space for max. num devices and ports, but memory
   is cheap.
   Should call this after setup_init() allocates these config structs,
   and after we input/read the initial configuration from the registry.
|------------------------------------------------------------------------*/
int copy_setup_init(void)
{
 int i;
 int size;
 Device_Config *save_dev;
 Port_Config *save_port;

  //--- copy the driver configuration
  save_dev = org_wi->dev;  // retain, don't overwrite this with memcpy!
  memcpy(org_wi, wi, sizeof(*wi));  // save copy of original
  org_wi->dev = save_dev;  // restore our ptr to our device array

  for (i=0; i<MAX_NUM_DEVICES; i++)
  {
    //--- copy the device configuration array
    save_port = org_wi->dev[i].ports;  // retain, don't overwrite this with memcpy!
    memcpy(&org_wi->dev[i], &wi->dev[i], sizeof(Device_Config));  // save copy of original
    org_wi->dev[i].ports = save_port;  // restore our ptr to our device array

    size = sizeof(Port_Config) * MAX_NUM_PORTS_PER_DEVICE;

    //--- copy the port configuration array
    memcpy(org_wi->dev[i].ports, wi->dev[i].ports, size);  // save copy of original
  }

  return 0;  // ok
}

/*------------------------------------------------------------------------
| DoDriverPropPages - Main driver level property sheet for NT4.0
|------------------------------------------------------------------------*/
int DoDriverPropPages(HWND hwndOwner)
{
    PROPSHEETPAGE psp[NUM_DRIVER_SHEETS];
    PROPSHEETHEADER psh;
    OUR_INFO * our_params;
    INT stat;

    //Fill out the PROPSHEETPAGE data structure for the Background Color
    //sheet

    our_params = glob_info;  // temporary kludge, unless we don't need re-entrantancy 

    //Fill out the PROPSHEETPAGE data structure for the Client Area Shape
    //sheet
    FillDriverPropertySheets(&psp[0], (LPARAM)our_params);

    //Fill out the PROPSHEETHEADER

    memset(&psh, 0, sizeof(PROPSHEETHEADER));  // add fix 11-24-98
    psh.dwSize = sizeof(PROPSHEETHEADER);
    //psh.dwFlags = PSH_USEICONID | PSH_PROPSHEETPAGE;
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = glob_hinst;
    psh.pszIcon = "";
    //psh.pszCaption = (LPSTR) aptitle;  //"Driver Properties";
    psh.pszCaption = (LPSTR) szAppTitle;  //"Driver Properties";

    psh.nPages = NUM_DRIVER_SHEETS;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    //And finally display the dialog with the two property sheets.
  DbgPrintf(D_Init, ("Init 8\n"))

    stat = PropertySheet(&psh);

  return 0;
}

/*---------------------------------------------------------------------------
  our_context_help -
|---------------------------------------------------------------------------*/
void our_context_help(LPARAM lParam)
{
  LPHELPINFO lphi;
  HWND  helpWin;

  lphi = (LPHELPINFO) lParam;
  if ((lphi->iContextType == HELPINFO_MENUITEM) ||
      (lphi->iContextType == HELPINFO_WINDOW))
  {
    //wsprintf(gtmpstr, "id:%d", lphi->iCtrlId);
    //our_message(gtmpstr,MB_OK);

    //strcpy(gtmpstr, wi->ip.src_dir);
    //strcat(gtmpstr,szSlash);
    //strcat(gtmpstr,szSetup_hlp);
//    strcpy(gtmpstr, szSetup_hlp);
	  wsprintf(gtmpstr, "%s\\%s", wi->ip.src_dir, szSetup_hlp);
#ifdef NT50
	strcat(gtmpstr, "::/");
	strcat(gtmpstr, "resource.txt");
    helpWin = HtmlHelp((HWND) lphi->hItemHandle, gtmpstr,
             HH_TP_HELP_WM_HELP, (DWORD)help_ids);
	if (!helpWin) {

      DbgPrintf(D_Level, ("Failed to open WhatsThis help window\n"));
	}
#else
    WinHelp((HWND) lphi->hItemHandle, gtmpstr,
             HELP_WM_HELP, (DWORD)help_ids);
#endif
    //WinHelp((HWND) lphi->hItemHandle, szSetup_hlp,
    //        HELP_WM_HELP, (DWORD)  help_ids);
    //WinHelp(GetFocus(),szSetup_hlp, HELP_CONTEXT, lphi->iCtrlId);
  }

#ifdef COMMENT_OUT
  if (lphi->iContextType == HELPINFO_MENUITEM)
  {
    wsprintf(gtmpstr, "id:%d", lphi->iCtrlId);
    our_message(gtmpstr,MB_OK);

    i = 0;
    while ((help_ids[i*2] != lphi->iCtrlId) &&
           (help_ids[i*2] != 0xffffffff))
     ++i;
    if (help_ids[i*2] != 0xffffffff)
      WinHelp(GetFocus(),szSetup_hlp, HELP_CONTEXT, help_ids[i*2+1]);
    else WinHelp(GetFocus(),szSetup_hlp, HELP_CONTEXT, WIN_NT);
  }
  if (lphi->iContextType == HELPINFO_WINDOW)
  {
    wsprintf(gtmpstr, "id:%d", lphi->iCtrlId);
    our_message(gtmpstr,MB_OK);

    i = 0;
    while ((help_ids[i*2]  != lphi->iCtrlId) &&
           (help_ids[i*2] != 0xffffffff))
     ++i;
    if (help_ids[i*2] != 0xffffffff)
      WinHelp(GetFocus(),szSetup_hlp, HELP_CONTEXTPOPUP, help_ids[i*2+1]);
    else WinHelp(GetFocus(),szSetup_hlp, HELP_CONTEXT, WIN_NT);
  
    //WinHelp(GetFocus(),szSetup_hlp, HELP_CONTEXT, lphi->dwContextId);

    //WinHelp((HWND) lphi->hItemHandle, szSetup_hlp,
    //             HELP_WM_HELP, (DWORD)  help_ids);
  }
#endif
}

/*---------------------------------------------------------------------------
  remove_old_infs - A new common Comtrol modem inf file is called mdmctm1.inf,
    and replaces older individual ones called: mdmrckt.inf & mdmvsa1.inf.
    We must remove the older ones on install to clear out the older entries.
|---------------------------------------------------------------------------*/
static int remove_old_infs(void)
{
  static TCHAR *sz_inf = TEXT("\\inf\\");

  // delete the old inf\mdmrckt.inf file
  GetWindowsDirectory(wi->ip.dest_str,144);
  strcat(wi->ip.dest_str, sz_inf);
  strcat(wi->ip.dest_str, "mdmrckt.inf");
  DeleteFile(wi->ip.dest_str);

  // delete the old inf\mdmvsa1.inf file
  GetWindowsDirectory(wi->ip.dest_str,144);
  strcat(wi->ip.dest_str, sz_inf);
  strcat(wi->ip.dest_str, "mdmvsa1.inf");
  DeleteFile(wi->ip.dest_str);
  return 0; // ok
}

/*---------------------------------------------------------------------------
  remove_driver - clear out the driver from the system as much as possible.
|---------------------------------------------------------------------------*/
int remove_driver(int all)
{
 int stat,i;
 static char *delete_list[] = {
   "peer.exe",
   "peer.hlp",
   "portmon.exe",
   "portmon.hlp",
   "wcom32.exe",
   "wcom.hlp",
   //"setup.exe",  // since setup is running, a sharing violation prevents this
   "readme.txt",
   "history.txt",
#ifdef S_VS
   "vssetup.hlp",
   "vssetup.gid",
#else
   "rksetup.hlp",
   "rksetup.gid",
   "ctmmdmld.rm",
   "ctmmdmfw.rm",
#endif
   "wcom.gid",
   "portmon.gid",
   "calcs.dat",
   "ctmmdm35.inf",
   "portmon.vew",
   NULL};

   // delete the drivers\rocket.sys driver file
   GetSystemDirectory(wi->ip.dest_str,144);
   strcat(wi->ip.dest_str, "\\drivers\\");
   strcat(wi->ip.dest_str, wi->ip.szDriverName);
   DeleteFile(wi->ip.dest_str);

#ifdef S_VS
   // form "vslinka.bin", and delete the file from drivers dir
   // cut off .sys as "vslink."
   wi->ip.dest_str[strlen(wi->ip.dest_str) - 3] = 0; 
   strcat(wi->ip.dest_str, "bin");
   DeleteFile(wi->ip.dest_str);
#endif

   if (all)
   {
     // had some problems implementing, so the "all" is for
     // test right now.

     // delete most of the files in system32\ROCKET directory
     i = 0;
     while (delete_list[i] != NULL)
     {
       //wsprintf(tmpstr, "
       //MessageBox(0, s, "Debug", MB_OK);
       
       GetSystemDirectory(wi->ip.dest_str,144);
       strcat(wi->ip.dest_str, szSlash);
       strcat(wi->ip.dest_str, wi->ip.szAppDir);
       strcat(wi->ip.dest_str, szSlash);
       strcat(wi->ip.dest_str, delete_list[i]);
       DeleteFile(wi->ip.dest_str);
       ++i;
     }
#ifndef NT50
       // we can't just delete ourselves, so we rename ourselves
       // and that is good enough.
       GetSystemDirectory(wi->ip.dest_str,144);
       strcat(wi->ip.dest_str, szSlash);
       strcat(wi->ip.dest_str, wi->ip.szAppDir);
       strcat(wi->ip.dest_str, szSlash);
       strcpy(wi->ip.src_str, wi->ip.dest_str);
       strcat(wi->ip.dest_str, "setupold.exe");
       strcat(wi->ip.src_str, "setup.exe");
       stat = MoveFileEx(wi->ip.src_str, wi->ip.dest_str, MOVEFILE_REPLACE_EXISTING);
#endif
   }

   // kill our program manager
   stat = delete_progman_group(progman_list_nt, wi->ip.dest_dir);

   // remove some registry entries
   stat = remove_driver_reg_entries(wi->ip.szServiceName);

   setup_service(OUR_REMOVE, OUR_SERVICE);  // do a remove on the service
   return 0;
}

/*-----------------------------------------------------------------------------
| allow_exit - Performs 3 tasks:
  1.) If cancel selected: check to see if we allow the user to cancel
      out of the setup program.  If its an initial install, then force
      them to save it  off with an OK selection.
  2.) If cancel selected: Handle prompting to ask the user if they
      really want to cancel without saving.
  3.) If saving, make sure a valid save set is resident.  If not,
  do various things.

   RETURNS: true if we are allowing a cancel, false if we don't allow it.
|-----------------------------------------------------------------------------*/
int allow_exit(int want_to_cancel)
{
 int allow_it = 0;
 int stat;

  if (!wi->ChangesMade)
    send_to_driver(0);  // evaluate if anything changed(sets ChangesMade if true)

  if (want_to_cancel)  // they want to cancel out of the setup program
  {
    if ((do_progman_add)  // if initial add, don't let them decline
        && (wi->install_style == INS_NETWORK_INF))
    {
      our_message(&wi->ip,RcStr((MSGSTR+5)),MB_OK);
    }
    else
    {
#ifndef NT50
  // only prompt for nt40, I don't want the prompt for nt50...
      if (wi->ChangesMade)
      {
        stat = our_message(&wi->ip,"Quit without making changes?",MB_YESNO);
        if (stat == IDYES)
        {
          allow_it = 1;
        }
      }
      else
#endif
        allow_it = 1;
    }
  }
  else  // they pressed OK
  {
    if (wi->NumDevices == 0)  // all devices removed, hmmm...
    {
      if ((wi->nt_reg_flags & 2) || // missing linkage thing(did not install via network inf)
          (wi->install_style == INS_SIMPLE))
      {
  stat = our_message(&wi->ip,RcStr((MSGSTR+6)),MB_YESNO);
        if (stat == IDYES)
        {
          remove_driver(1);
          //PostQuitMessage(0);  // end the setup program.
          allow_it = 1;
        }
      }
      else
      {
#ifdef NT50
     our_message(&wi->ip,RcStr((MSGSTR+20)),MB_OK);
#else
     our_message(&wi->ip,RcStr((MSGSTR+7)),MB_OK);
#endif
      }
    }
    else
    {
#ifndef NT50
  // only prompt for nt40, I don't want the prompt for nt50...
  // maybe we should yank it out for 40 too.
      if (wi->ChangesMade)
      {
        stat = our_message(&wi->ip, "Save configuration changes and exit?", MB_YESNO);
        if (stat == IDYES)
        {
          allow_it = 1;
        }
      }
      else
#endif
          allow_it = 1;
    }
  }
  return allow_it;
}

/*-----------------------------------------------------------------------------
| our_exit - save/do install on exit if required.
|-----------------------------------------------------------------------------*/
void our_exit(void)
{
 int stat;
 static int did_exit = 0;

  // prop pages have independent action which under nt5.0 cause multiple
  // exit points, this did_exit thing prevents prompting and saving twice..
  if (did_exit)  
    return;

  {
    if (wi->NumDevices > 0)
    {
#ifndef NT50
      // only setup service for NT4.0 for now..
      stat = do_install();

      setup_service(OUR_RESTART, OUR_SERVICE);  // restart the service
#endif

      if (wi->NeedReset)
        our_message(&wi->ip,RcStr((MSGSTR+8)),MB_OK);
    }
#ifndef NT50
    else
      setup_service(OUR_REMOVE, OUR_SERVICE);  // do a remove on the service
#endif
  }
}

/*-----------------------------------------------------------------------------
| do_install -
|-----------------------------------------------------------------------------*/
int do_install(void)
{
 int stat = 0;
 int do_remove = 0;
 int do_modem_inf = 0;
 static int in_here = 0;

  if (in_here)  // problem hitting OK button twice(sets off two of these)
    return 2;

  in_here = 1;

#ifndef NT50
  if (do_progman_add)
  {
    if (wi->ip.major_ver == 3)  // for NT3.51
      do_modem_inf = 1;   // only do on initial install
  }
  if (do_progman_add)
  {
    // if no inf file, then copy over the files ourselves if initial
    // install.
    if (wi->install_style == INS_SIMPLE)
    {
      SetCursor(LoadCursor(NULL, IDC_WAIT));  // load hourglass cursor
      stat = copy_files_nt(&wi->ip);
      SetCursor(LoadCursor(NULL, IDC_ARROW));  // load arrow

      if (stat != 0)
           our_message(&wi->ip, "Error while copying files", MB_OK);
    }
    stat = setup_make_progman_group(0);  // no prompt

    remove_old_infs();  // kill any old modem infs
  }
#endif

  in_here = 0;

#ifndef NT50
  if (do_modem_inf)
    update_modem_inf(0);

  if (!do_progman_add)  // if initial add, don't let them decline
  {
    if (!wi->ChangesMade)
      send_to_driver(0);  // evaluate if anything changed
      // i'm getting tire of all these prompts(kb, 8-16-98)...
#if 0
    if (wi->ChangesMade)
    {
      strcpy(gtmpstr, "Setup will now save the new configuration.");
      if (our_message(&wi->ip, gtmpstr, MB_OKCANCEL) != IDOK)
        return 1;  // error
    }
#endif
  }

  if (do_progman_add)
  {
    if (wi->install_style == INS_SIMPLE)
    {
      strcpy(gtmpstr, "System32\\Drivers\\");
      strcat(gtmpstr, OurDriverName);
      stat = service_man(OurServiceName, OurDriverName, CHORE_INSTALL);
      //sprintf(gtmpstr, "Install service, result=%x", stat);
      //our_message(&wi->ip, gtmpstr, MB_OK);
    }
  }
#endif

  stat = send_to_driver(1);

  stat = set_nt_config(wi);

  // new, fire the thing up right away after saving options
  if (do_progman_add)
  {
    // try to start the service
//    setup_service(OUR_RESTART, OUR_DRIVER);  // restart the service
  }

  if (stat)
    return 1; // error

  return 0; // ok
}

/*-----------------------------------------------------------------------------
| setup_service - setup our service.  The service reads the scanrates of
   VS & RocketPort drivers on startup, and adjusts NT's tick based then.
   So we need to restart this service.
   flags: 1H = stop & remove, 2 = restart it, 4 = install & start
   which_service: 0=ctmservi common service task.  1=vs or rk driver.
|-----------------------------------------------------------------------------*/
int setup_service(int flags, int which_service)
{
 static char *Ctmservi_OurUserServiceName = {"ctmservi"};

 char OurUserServiceName[60];
 char OurUserServicePath[60];
//#define DEBUG_SERVICE_FUNC

 int installed = 0;
 int stat;

 if (which_service == 0)  // our common service
 {
   strcpy(OurUserServiceName, Ctmservi_OurUserServiceName);
   strcpy(OurUserServicePath, Ctmservi_OurUserServiceName);
   strcat(OurUserServicePath, ".exe");
 }
 else if (which_service == 1)  // rk or vs driver service
 {
   strcpy(OurUserServiceName, OurServiceName);  // driver
   strcpy(OurUserServicePath, OurDriverName);
 }

 DbgPrintf(D_Test, ("Service %s Flags:%xH\n", OurUserServiceName, flags))

 if (service_man(OurUserServiceName, OurUserServicePath,
     CHORE_IS_INSTALLED) == 0)  // it's installed
  {
    installed = 1;
    DbgPrintf(D_Test, (" Installed\n"))
  }
  else
  {
    DbgPrintf(D_Test, (" Not Installed\n"))
  }

  if (flags & 1)  // remove
  {
    DbgPrintf(D_Test, (" srv remove\n"))
    if (installed)
    {
      DbgPrintf(D_Test, (" srv remove a\n"))
      stat = service_man(OurUserServiceName, OurUserServicePath, CHORE_STOP);
      if (stat != 0)
      {
        DbgPrintf(D_Error, ("Error %d stopping service\n", stat))
      }
      DbgPrintf(D_Test, (" srv remove b\n"))
      stat = service_man(OurUserServiceName, OurUserServicePath, CHORE_REMOVE);
      if (stat != 0)
      {
        DbgPrintf(D_Error, ("Error %d removing service\n", stat))
      }
      installed = 0;
    }
  }

  if (flags & 2)  // restart it
  {
    DbgPrintf(D_Test, (" srv restart\n"))
    if (!installed)
    {
      DbgPrintf(D_Test, (" srv restart a\n"))
      flags |= 4;  // install & start it
    }
    else
    {
      DbgPrintf(D_Test, (" srv restart b\n"))
      stat = service_man(OurUserServiceName, OurUserServicePath, CHORE_STOP);
      if (stat != 0)
      {
        DbgPrintf(D_Error, ("Error %d stopping service\n", stat))
      }

      // the start was failing with a 1056 error(instance already running)
      Sleep(100L);

      stat = service_man(OurUserServiceName, OurUserServicePath, CHORE_START);
      if (stat != 0)
      {
        DbgPrintf(D_Error, ("Error %d starting service\n", stat))
      }
    }

  }

  if (flags & 4)  // install & start it
  {
    DbgPrintf(D_Test, (" srv install & start\n"))
    if (!installed)
    {
      DbgPrintf(D_Test, (" srv install & start a\n"))
      stat = service_man(OurUserServiceName, OurUserServicePath,
               CHORE_INSTALL_SERVICE);
      if (stat != 0)
      {
        DbgPrintf(D_Error, ("Error %d installing service\n", stat))
      }
      stat = service_man(OurUserServiceName, OurUserServicePath, CHORE_START);
      if (stat != 0)
      {
        DbgPrintf(D_Error, ("Error %d starting service\n", stat))
      }
    }
  }
  return 0;
}

/*-----------------------------------------------------------------------------
| setup_utils_exist - tells if utils like wcom32.exe, portmon.exe, rksetup.exe
    exist.  For NT5.0, embedded in OS we may not have utils.
|-----------------------------------------------------------------------------*/
int setup_utils_exist(void)
{
 ULONG dstat;

  strcpy(gtmpstr, wi->ip.dest_dir);
  // first installed file in list
  strcat(gtmpstr,"\\");
  strcat(gtmpstr,progman_list_nt[3]);
  dstat = GetFileAttributes(gtmpstr);
  if (dstat != 0xffffffff)  // it must exist
    return 1; // exists
  return 0; // does not exist
}

/*-----------------------------------------------------------------------------
| setup_make_progman_group -
|-----------------------------------------------------------------------------*/
int setup_make_progman_group(int prompt)
{
 int stat;
  if (prompt)
  {
    if (our_message(&wi->ip, RcStr((MSGSTR+9)), MB_YESNO) != IDYES)
      return 0;
  }

  stat = make_progman_group(progman_list_nt, wi->ip.dest_dir);

  if (stat)
  {
    our_message(&wi->ip,RcStr((MSGSTR+10)),MB_OK);
  }
  return stat;
}

/*-----------------------------------------------------------------------------
| update_modem_inf - query and update modem.inf file for rocketmodem entries.
|-----------------------------------------------------------------------------*/
int update_modem_inf(int ok_prompt)
{
 int stat;
 int do_it = 1;

  if (ok_prompt)
  {
    do_it = 0;
#ifdef S_VS
    strcpy(gtmpstr, RcStr((MSGSTR+11)));
#else
    strcpy(gtmpstr, RcStr((MSGSTR+12)));
#endif
    if (our_message(&wi->ip, gtmpstr, MB_OKCANCEL) == IDOK)
      do_it = 1;
  }

  if (do_it)
  {
#ifdef S_VS
    stat = modem_inf_change(&wi->ip, "VsLink\\ctmmdm35.inf", szModemInfEntry);
#else
    stat = modem_inf_change(&wi->ip, "Rocket\\ctmmdm35.inf", szModemInfEntry);
#endif

    if (stat)
    {
      our_message(&wi->ip,RcStr((MSGSTR+13)),MB_OK);
      return 1; // error
    }
    else
    {
      if (ok_prompt)
        our_message(&wi->ip,RcStr((MSGSTR+14)),MB_OK);
        return 1; // error
    }
  }
  return 0; // ok
}

#ifdef S_VS
/*-----------------------------------------------------------------------------
| get_mac_list - get mac address list from driver which polls network for
    boxes and returns us a list of mac-addresses(with 2-extra bytes of
    misc. bits of information.)
|-----------------------------------------------------------------------------*/
int get_mac_list(char *buf, int in_buf_size, int *ret_buf_size)
{
 IoctlSetup ioctl_setup;
 int product_id = NT_VS1000;
 int stat;

  memset(&ioctl_setup, 0 , sizeof(ioctl_setup));
  stat = ioctl_open(&ioctl_setup, product_id);  // just ensure we can open

  if (stat != 0) // error from ioctl
  {
    *ret_buf_size = 0;
    // could not talk to driver
    return 1;
  }

  ioctl_setup.buf_size = in_buf_size - sizeof(*ioctl_setup.pm_base);
  ioctl_setup.pm_base = (PortMonBase *) buf;
  ioctl_setup.pm_base->struct_type = IOCTL_MACLIST;  // get mac-address list

  stat = ioctl_call(&ioctl_setup);  // get names, number of ports
  if (stat)
  {
    ioctl_close(&ioctl_setup);
    *ret_buf_size = 0;
    return 0x100;  // failed ioctl call
  }
  ioctl_close(&ioctl_setup);
  *ret_buf_size = ioctl_setup.ret_bytes - sizeof(ioctl_setup.pm_base[0]);
  return 0; // ok
}

/*------------------------------------------------------------------------
 our_get_ping_list - cause the driver to do a broadcast ping on
   all devices, and obtain a list of returned mac-addresses and misc.
   query flag settings in an array.  We allocated buffer space and
   just leave it for program/os to clean up.
|------------------------------------------------------------------------*/
BYTE *our_get_ping_list(int *ret_stat, int *ret_bytes)
{
  static char *ioctl_buf = NULL;  // we alloc this once, then it remains
  BYTE *macbuf;
  //BYTE *mac;
  int found, nbytes, stat;

  if (ioctl_buf == NULL)
  {
    // alloc 8byte mac-address fields(2 times as many as could be configured)
    ioctl_buf = calloc(1, (MAX_NUM_DEVICES*8)*2);
  }
  memset(ioctl_buf, 0,  (MAX_NUM_DEVICES*8)*2);
  found = 0;
  nbytes = 0;
  macbuf = &ioctl_buf[sizeof(PortMonBase)];  // ptr past header

  // call to get mac-address list of boxes on network
  SetCursor(LoadCursor(NULL, IDC_WAIT));  // load hourglass cursor

  stat = get_mac_list(ioctl_buf, (MAX_NUM_DEVICES*8)*2, &nbytes);

  SetCursor(LoadCursor(NULL, IDC_ARROW));  // load arrow
  *ret_stat = stat;
  *ret_bytes = nbytes;
  return macbuf;
}

#endif

/*-----------------------------------------------------------------------------
| send_to_driver -
   send_to_driver - if set, then send it to driver.
     if not set, then just determine if changes were made
|-----------------------------------------------------------------------------*/
int send_to_driver(int send_it)
{
  char ioctl_buffer[200];
  char value_str[100];
  char *ioctl_buf;
  IoctlSetup ioctl_setup;
  Our_Options *options;
  int dev_i, stat;
  int op_i;
  int chg_flag;
  int unknown_value;
  int pi;
  int changes_found=0;
  int changes_need_reboot=0;
  Device_Config *dev;


   // for ioctl calls into driver
#ifdef S_VS
 int product_id = NT_VS1000;
#else
 int product_id = NT_ROCKET;
#endif

  if (send_it)
  {
    DbgPrintf(D_Level,(TEXT("send_to_driver\n")));
    memset(&ioctl_setup, 0 , sizeof(ioctl_setup));
    memset(&ioctl_buffer, 0 , sizeof(ioctl_buffer));
    stat = ioctl_open(&ioctl_setup, product_id);  // just ensure we can open

    if (stat != 0) // error from ioctl
    {
      // could not talk to driver
      DbgPrintf(D_Level,(TEXT("Driver Not Present\n")));
      wi->NeedReset = 1;
      return 1;
    }

    ioctl_setup.buf_size = sizeof(ioctl_buffer) - sizeof(*ioctl_setup.pm_base);
    ioctl_setup.pm_base = (PortMonBase *)ioctl_buffer;
    ioctl_setup.pm_base->struct_type = IOCTL_OPTION;  // set options
    ioctl_buf = (char *) &ioctl_setup.pm_base[1];  // ptr to past header(about 16 bytes)
  }

  options = driver_options;
  op_i = 0;
  while (options[op_i].name != NULL)
  {
    option_changed(value_str, &chg_flag, &unknown_value, &options[op_i],
                   0,0);

    if (chg_flag)
    {
      changes_found = 1;
      if (send_it)
      {
        stat = send_option(value_str,
                  &options[op_i],
                  0,
                  0,ioctl_buf, &ioctl_setup);
        if (stat != 0)
          changes_need_reboot = 1;
      }  // send_it
    }
    ++op_i;
  }

  DbgPrintf(D_Level,(TEXT("send_to_driver 1\n")));
  for(dev_i=0; dev_i<wi->NumDevices; dev_i++)   // Loop through all possible boards
  {
    dev = &wi->dev[dev_i];
    op_i = 0;
    options = device_options;
    while (options[op_i].name != NULL)
    {
      option_changed(value_str, &chg_flag, &unknown_value, &options[op_i],
                     dev_i,0);

      if (chg_flag)
      {
        changes_found = 1;
        if (send_it)
        {
          stat = send_option(value_str,
                  &options[op_i],
                  dev_i,
                  0,ioctl_buf, &ioctl_setup);
          if (stat != 0)
            changes_need_reboot = 1;
        }  // send_it
      }  // chg_flag
      ++op_i;
    }  // device strings

    for(pi=0; pi<dev->NumPorts; pi++)   // Loop through all possible boards
    {
      op_i = 0;
      options = port_options;
      while (options[op_i].name != NULL)
      {
        option_changed(value_str, &chg_flag, &unknown_value, &options[op_i],
                       dev_i, pi);

        if (chg_flag)
        {
          changes_found = 1;
  
          if (send_it)
          {
            stat = send_option(value_str,
                     &options[op_i],
                     dev_i,
                     pi, ioctl_buf, &ioctl_setup);
            if (stat != 0)
              changes_need_reboot = 1;
          }  // send_it
        }  // chg_flag
        ++op_i;
      }  // port strings
    }  // for pi=0; ..ports
  }   // for dev_i = num_devices

  if (changes_need_reboot)
    wi->NeedReset = 1;

  if (changes_found)
    wi->ChangesMade = 1;

  if (send_it)
  {
    ioctl_close(&ioctl_setup);
  }
  return 0;
}

/*-----------------------------------------------------------------------------
| send_option - send option over to driver.
|-----------------------------------------------------------------------------*/
static int send_option(char *value_str,
                Our_Options *option,
                int device_index,
                int port_index,
                char *ioctl_buf,
                IoctlSetup *ioctl_setup)
{
  char dev_name[80];
  int stat;

#if (defined(NT50))
  strcpy(dev_name, wi->ip.szNt50DevObjName);
#else
  wsprintf(dev_name, "%d", device_index);
#endif

  if (option->id & 0x100)  // its a driver option
  {
    wsprintf(ioctl_buf, "%s=%s", option->name, value_str);
  }
  else if (option->id & 0x200)  // its a device option
  {
    wsprintf(ioctl_buf, "device[%s].%s=%s",
            dev_name, option->name, value_str);
  }
  else if (option->id & 0x400)  // its a port option
  {
    wsprintf(ioctl_buf, "device[%s].port[%d].%s=%s",
        dev_name, port_index,
        option->name, value_str);
  }

  stat = our_ioctl_call(ioctl_setup);
  if (stat == 52)
  {
    //special return code indicating driver doesn't care or know about
    // this option(its setup only option.)
    stat = 0;  // change to ok.
  }
  return stat;

  //if (stat != 0)
  //    changes_need_reboot = 1;
}

/*-----------------------------------------------------------------------------
| option_changed - detect if an option changed, and format a new value
|-----------------------------------------------------------------------------*/
static int option_changed(char *value_str,
                   int *ret_chg_flag,
                   int *ret_unknown_flag,
                   Our_Options *option,
                   int device_index,
                   int port_index)
{
  int chg_flag = 0;
  int value = 0;
  int org_value = 0;
  int unknown_value = 0;
  Port_Config *port, *org_port;
  Device_Config *org_dev, *dev;

  dev = &wi->dev[device_index];
  org_dev = &org_wi->dev[device_index];

  port     = &dev->ports[port_index];
  org_port = &org_dev->ports[port_index];

  if (option->id & 0x300)  // port level option
  {
  }
  else if (option->id & 0x200)  // device level option
  {
  }
  else if (option->id & 0x100)  // driver level option
  {
  }
  *value_str = 0;

  switch(option->id)
  {
    //------ Driver Options ------
    case OP_VerboseLog:
      value = wi->VerboseLog;  org_value = org_wi->VerboseLog;
    break;
    case OP_NumDevices:
      value = wi->NumDevices;  org_value = org_wi->NumDevices;
    break;
#ifdef NT50
    case OP_NoPnpPorts:
      value = wi->NoPnpPorts;  org_value = org_wi->NoPnpPorts;
    break;
#endif
    case OP_ScanRate:
      value = wi->ScanRate;  org_value = org_wi->ScanRate;
    break;

    case OP_ModemCountry:
      value = wi->ModemCountry; org_value = org_wi->ModemCountry;
    break;
    case OP_GlobalRS485:
      value = wi->GlobalRS485; org_value = org_wi->GlobalRS485;
    break;

    //------ Device Options ------
#if 0  // don't send this to driver, make it go away
    case OP_StartComIndex  :
      value = dev->StartComIndex;  org_value = org_dev->StartComIndex;
    break;
#endif
    case OP_NumPorts        :
      value = dev->NumPorts;  org_value = org_dev->NumPorts;
    break;
    case OP_MacAddr         :
      if (!mac_match(dev->MacAddr, org_dev->MacAddr))
      {
        chg_flag = 1;
        wsprintf(value_str, "%x %x %x %x %x %x",
                 dev->MacAddr[0], dev->MacAddr[1], dev->MacAddr[2],
                 dev->MacAddr[3], dev->MacAddr[4], dev->MacAddr[5]);
      }
    break;

#ifdef S_VS
    case OP_BackupServer:
      value = dev->BackupServer;  org_value = org_dev->BackupServer;
    break;

    case OP_BackupTimer:
      value = dev->BackupTimer;  org_value = org_dev->BackupTimer;
    break;
#endif

    case OP_Name:
      if (strcmp(dev->Name, org_dev->Name) != 0)
      {
        chg_flag = 1;
        strcpy(value_str, dev->Name);
      }
    break;

    case OP_ModelName:
      if (strcmp(dev->ModelName, org_dev->ModelName) != 0)
      {
        chg_flag = 1;
        strcpy(value_str, dev->ModelName);
      }
    break;

#ifdef S_RK
    case OP_IoAddress:
      value = dev->IoAddress;  org_value = org_dev->IoAddress;
    break;
#endif

    case OP_ModemDevice:
      value = dev->ModemDevice;  org_value = org_dev->ModemDevice;
    break;

    case OP_HubDevice:
      value = dev->HubDevice;  org_value = org_dev->HubDevice;
    break;

    //------ Port Options ------
    case OP_WaitOnTx :
      value = port->WaitOnTx;
      org_value = org_port->WaitOnTx;
    break;
    case OP_RS485Override :
      value = port->RS485Override;
      org_value = org_port->RS485Override;
    break;
    case OP_RS485Low :
      value = port->RS485Low;
      org_value = org_port->RS485Low;
    break;
    case OP_TxCloseTime :
      value = port->TxCloseTime;  org_value = org_port->TxCloseTime;
    break;
    case OP_LockBaud :
      value = port->LockBaud;  org_value = org_port->LockBaud;
    break;
    case OP_Map2StopsTo1 :
      value = port->Map2StopsTo1;
      org_value = org_port->Map2StopsTo1;
    break;
    case OP_MapCdToDsr :
      value = port->MapCdToDsr;
      org_value = org_port->MapCdToDsr;
    break;
    case OP_RingEmulate :
      value = port->RingEmulate;
      org_value = org_port->RingEmulate;
    break;
    case OP_PortName :
      if (strcmp(port->Name, org_port->Name) != 0)
      {
        DbgPrintf(D_Test, ("chg port name:%s to %s\n",
             org_port->Name, port->Name))
        chg_flag = 1;
        strcpy(value_str, port->Name);
      }
    break;
    default:
      DbgPrintf(D_Error,(TEXT("Unknown Option %s ID:%x\n"),
                 option->name,
                 option->id));
      unknown_value = 1;
    break;
  }

  if ( (!unknown_value) &&
       (!(option->var_type == OP_T_STRING)) )
  {
    if (value != org_value)
    {
      chg_flag = 1;
      wsprintf(value_str, "%d", value);
    }
  }

  if (chg_flag)
  {
    DbgPrintf(D_Level,(TEXT("changed:%s\n"),option->name));
  }
  if (unknown_value)
  {
    DbgPrintf(D_Level,(TEXT("Unknown value:%s\n"),option->name));
  }
  *ret_chg_flag = chg_flag;
  *ret_unknown_flag = unknown_value;
  return 0;
}

/*-----------------------------------------------------------------------------
| our_ioctl_call - send our ascii option data to driver.  Driver will
   return 0 if successful, other values assume error, value of 52 if the 
   driver does not known what the option is.
|-----------------------------------------------------------------------------*/
int our_ioctl_call(IoctlSetup *ioctl_setup)
{
 int stat;
 char *pstr;

   stat = ioctl_call(ioctl_setup);
   if (stat)
   {
     return 0x100;  // failed ioctl call
   }

   //otherwise, driver returns "Option stat:#" with a decimal return code.
   pstr = (char *)&ioctl_setup->pm_base[1];  // find the return status value from the driver
   while ((*pstr != 0) && (*pstr != ':'))
     ++pstr;
   if (*pstr == ':')
   {
     ++pstr;
     stat = getint(pstr, NULL);  // atoi(), return driver code
     if (stat == 0)
     {
       //DbgPrintf(D_Level, (TEXT("ok ioctl\n")));
     }
     else
     {
       //DbgPrintf(D_Level, (TEXT("bad ioctl\n")));
     }
   }
   else
   {
     //DbgPrintf(D_Level, (TEXT("err ret on ioctl\n")));
     stat = 0x101;  // no return status given
   }

   return stat;
}

/*-----------------------------------------------------------------------------
| our_help -
|-----------------------------------------------------------------------------*/
int our_help(InstallPaths *ip, int index)
{
  strcpy(ip->tmpstr, ip->src_dir);
  strcat(ip->tmpstr,szSlash);
  strcat(ip->tmpstr,szSetup_hlp);

#ifdef NT50
  HtmlHelp(GetFocus(),ip->tmpstr, HH_HELP_CONTEXT, index);
#else
  WinHelp(GetFocus(),ip->tmpstr, HELP_CONTEXT, index);
#endif
  return 0;
}

/*-----------------------------------------------------------------
  validate_config -
|------------------------------------------------------------------*/
int validate_config(int auto_correct)
{
  int di, stat;
  Device_Config *dev;
  int invalid = 0;

  DbgPrintf(D_Level, ("validate_config\n"))
  for (di=0; di<wi->NumDevices; di++)
  {
    dev = &wi->dev[di];

    stat = validate_device(dev, 1);
    if (stat)
      invalid = 1;

  }
  return invalid;
}

/*-----------------------------------------------------------------------------
 validate_device - 
|-----------------------------------------------------------------------------*/
int validate_device(Device_Config *dev, int auto_correct)
{
 int invalid = 0;
 Port_Config *ps;
 int pi,stat;

  DbgPrintf(D_Level, ("validate_dev\n"))
  //----- verify the name is not blank
  if (dev->Name[0] == 0)
  {
    invalid = 1;
    if (auto_correct)
    {
#ifdef S_VS
      wsprintf(dev->Name, "VS #%d", wi->NumDevices+1);  // user designated name
#else
      wsprintf(dev->Name, "RK #%d", wi->NumDevices+1);  // user designated name
#endif
    }
  }

  //----- verify the number of ports is non-zero
  if (dev->NumPorts == 0)
  {
    invalid = 1;
    if (auto_correct)
    {
      dev->NumPorts = 8;  // 8 is common for rocketport
    }
  }

#ifdef S_RK
  //----- verify the number of ports is non-zero
  if (dev->IoAddress == 0)
  {
    invalid = 1;
    if (auto_correct)
    {
      if (dev->IoAddress == 0)
        dev->IoAddress = 1;  // setup for a pci-board
    }
  }
#endif

  if (wi->ModemCountry == 0)  // not valid
      wi->ModemCountry = mcNA;            // North America

#ifdef S_VS
  if (dev->BackupTimer < 2) dev->BackupTimer = 2; // 2 minute, no less
#endif

  for (pi=0; pi<dev->NumPorts; pi++)
  {
    ps = &dev->ports[pi];

    stat = validate_port(ps, auto_correct);
    if (stat)
      invalid = 1;
  }

  if (invalid)
  {
    DbgPrintf(D_Error, ("validate_dev:invalid config\n"))
  }

  return invalid;
}

/*-----------------------------------------------------------------------------
 validate_port - 
|-----------------------------------------------------------------------------*/
int validate_port(Port_Config *ps, int auto_correct)
{
 int invalid = 0;

  //DbgPrintf(D_Level, ("validate_port\n"))

  invalid = validate_port_name(ps, auto_correct);
  return invalid;
}

/*-----------------------------------------------------------------------------
 validate_port_name - 
|-----------------------------------------------------------------------------*/
int validate_port_name(Port_Config *ps, int auto_correct)
{
 int stat;
 int bad = 0;
 char oldname[26];
 int invalid = 0;

  //DbgPrintf(D_Level, ("validate_port_name 0\n"))
  stat = 0;
  //----- verify the name is unique
  if (ps->Name[0] == 0) {
    bad = 1;  // error, need a new name
  }

#if 0
  // take out due to tech. difficulties in the artificial intelligence area
  //DbgPrintf(D_Level, ("validate_port_name 1\n"))
  if (bad == 0)
  {
    stat = IsPortNameInSetupUse(ps->Name);
    if (stat > 1)
      bad = 2;  // error, more than one defined in our config
  }
  if (bad == 0)  // its ok, not in use
  {
    stat = IsPortNameInRegUse(ps->Name);
    if (stat == 2)  // in use, but by our driver, so ok
      stat = 0;
    if (stat != 0)
      bad = 3;  // error, more than one defined in our config
  }
#endif

  //DbgPrintf(D_Level, ("validate_port_name 2\n"))
  strcpy(oldname, ps->Name);
  if (bad != 0)  // need a new name, this one won't work
  {
    invalid = 1;
    if (auto_correct)
    {
      ps->Name[0] = 0;  // need this for newname func to work
      FormANewComPortName(ps->Name, NULL);
    }
    DbgPrintf(D_Level, (" New Name:%s Old:%s Code:%d\n", ps->Name, oldname, bad))
  }
  return invalid;
}

#if 0
/*-----------------------------------------------------------------------------
 rename_ascending - rename the rest of the ports on the board in
   ascending order.
|-----------------------------------------------------------------------------*/
void rename_ascending(int device_selected,
                      int port_selected)
{
  Device_Config *dev;
  Port_Config *ps;
  int i;
  char name[20];

   dev = &wi->dev[device_selected];
   ps = &dev->ports[port_selected];

   for (i=port_selected+1; i<dev->NumPorts; i++)
   {
     ps = &dev->ports[i];
     FormANewComPortName(name, dev->ports[port_selected-1].Name);
     strcpy(ps->Name, name);
     //validate_port_name(ps, 1);
   }
}
#endif

/*-----------------------------------------------------------------------------
  FormANewComPortName -
|-----------------------------------------------------------------------------*/
int FormANewComPortName(IN OUT TCHAR *szComName, IN TCHAR *szDefName)
{
  char try_name[25];
  int stat;
  char base_name[20];
  int num;
  //DbgPrintf(D_Level, ("Form a new name\n"))

   base_name[0] = 0;
   if (szDefName != NULL)
     strcpy(base_name, szDefName);
   else
     GetLastValidName(base_name);

   //DbgPrintf(D_Level, ("Base name:%s\n", base_name))

   num = ExtractNameNum(base_name);  // num = 3 if "COM3"
   if (num == 0)
     num = 3;
   else ++num;
   StripNameNum(base_name);

   if (base_name[0] == 0)
   {
     strcat(base_name, "COM");
   }

  stat = 2;
  while (stat != 0)
  {
    wsprintf(try_name, TEXT("%s%d"), base_name, num);
    //DbgPrintf(D_Level, ("try:%s\n", try_name))

    if (IsPortNameInSetupUse(try_name) != 0)
    {
       DbgPrintf(D_Level, (" SetupUse\n"))
       stat = 2;  // port in use by us
    }
    else
    {
      stat = IsPortNameInRegUse(try_name);
      if (stat)
      {
        if ( stat == 2 ) {
          stat = 0;
        } else {
          DbgPrintf(D_Level, (" InRegUse\n"))
        }
      }
    }
    if (stat == 0)
    {
      strcpy(szComName, try_name);
    }
    ++num;
  }
  //DbgPrintf(D_Level, ("End FormANewComPortName\n"))
  return 0;
}

/*-----------------------------------------------------------------------------
  GetLastValidName - Get a com-port name which makes sense to start naming
   things at.  So if our last com-port name is "COM45", then return this.
   Pick the Com-port with the highest number.
|-----------------------------------------------------------------------------*/
int GetLastValidName(IN OUT TCHAR *szComName)
{
 int di, pi;
 int last_di, last_pi;
 char tmpName[20];
 int num=0;

  for (di=0; di<wi->NumDevices; di++)
  {
    for (pi=0; pi<wi->dev[di].NumPorts; pi++)
    {
      strcpy(tmpName, wi->dev[di].ports[pi].Name);
      if (ExtractNameNum(tmpName) > num)
      {
        num = ExtractNameNum(tmpName);
        strcpy(szComName, wi->dev[di].ports[pi].Name);
        last_di = di;
        last_pi = pi;
      }
    }
  }
  if (num == 0)
    szComName[0] = 0;

  //DbgPrintf(D_Level, ("LastValidName:%s [%d.%d]\n", szComName, last_di, last_pi))
  return 0;
}

/*-----------------------------------------------------------------------------
  BumpPortName - Add 1 to the number of the comport name, so change "COM23"
    to "COM24".
|-----------------------------------------------------------------------------*/
int BumpPortName(IN OUT TCHAR *szComName)
{
  char tmpstr[25];
  int i;

  strcpy(tmpstr, szComName);
  i = ExtractNameNum(szComName);
  if (i< 1)
    i = 1;
  ++i;
  StripNameNum(tmpstr);
  wsprintf(szComName, "%s%d", tmpstr, i);
  return 0;
}

/*-----------------------------------------------------------------------------
  StripNameNum -
|-----------------------------------------------------------------------------*/
int StripNameNum(IN OUT TCHAR *szComName)
{
 char *pstr;

  pstr = szComName;
  while ((!isdigit(*pstr)) && (*pstr != 0))
  {
    pstr++;
  }
  *pstr = 0;  // null terminate at digit

  return 0;
}

/*-----------------------------------------------------------------------------
  ExtractNameNum -
|-----------------------------------------------------------------------------*/
int ExtractNameNum(IN TCHAR *szComName)
{
 int num;
 char *pstr;

   pstr = szComName;
   while ((!isdigit(*pstr)) && (*pstr != 0))
   {
     pstr++;
   }
   if (*pstr == 0)
     num = 0;
   else
     num = atoi(pstr);
   return num;
}

/*-----------------------------------------------------------------------------
  IsPortNameInSetupUse - Checks our setup info to see if com-port name is
    unique.
|-----------------------------------------------------------------------------*/
int IsPortNameInSetupUse(IN TCHAR *szComName)
{
 int di, pi;
 int times_in_use = 0;

  for (di=0; di<wi->NumDevices; di++)
  {
    for (pi=0; pi<wi->dev[di].NumPorts; pi++)
    {
      if (_tcsicmp(szComName, wi->dev[di].ports[pi].Name) == 0)
      {
        ++times_in_use;
#if DBG
        //if (times_in_use > 1)
        //  DbgPrintf(D_Level, (" %s InSetupUs:%d, [%d %d]\n",
        //     szComName, times_in_use, di, pi))
#endif
      }
    }
  }
  return times_in_use;
}

/*------------------------------------------------------------------------
  IsPortNameInRegUse - Checks registry area where com-ports typically export
    com-port names under NT.
    return 0=not in use, 1=in use by other driver,  2=in use by our driver.
|------------------------------------------------------------------------*/
int IsPortNameInRegUse(IN TCHAR *szComName)
{
  HKEY   hkey;
  int    i, nEntries;
  ULONG  dwSize, dwBufz;
  ULONG  dwType;
  TCHAR  szSerial[ 40 ];
  TCHAR  szCom[ 40 ];
  TCHAR  szDriver[8];

  _tcsncpy(szDriver, OurDriverName, 6);  // something to match to "vslink" or "rocket"
  szDriver[6] = 0;
  _tcsupr(szDriver);

                                     // "Hardware\\DeviceMap\\SerialComm"
  if( !RegOpenKeyEx( HKEY_LOCAL_MACHINE, m_szRegSerialMap,
                     0L, KEY_READ, &hkey ) )
  {
    dwBufz = sizeof( szSerial );
    dwSize = sizeof( szCom );
    nEntries = i = 0;

    while( !RegEnumValue( hkey, i++, szSerial, &dwBufz,
                          NULL, &dwType, (LPBYTE) szCom, &dwSize ) )
    {
      if (dwType != REG_SZ)
         continue;

      _tcsupr(szCom);
      _tcsupr(szSerial);
      if (_tcsicmp(szComName, szCom) == 0)
      {
        // compare 5 characters of the key name to our driver name
        if (_tcsstr(szSerial, szDriver) != NULL)
        {
          //DbgPrintf(D_Level, (" %s InRegUseUsOurs [%s,%s]\n", szComName,
          //  szSerial, szDriver))
          return 2; // in use, but probably ours
        }
        else
        {
          //DbgPrintf(D_Level, (" %s InRegUseUsNotOurs [%s,%s]\n", szComName,
          //  szSerial, szDriver))
          return 1;  // it's in use, someone elses driver
        }
      }
      ++nEntries;

      dwSize = sizeof( szCom );
      dwBufz = sizeof( szSerial );
    }

    RegCloseKey( hkey );
  }
  return 0;  // not in use
}

#ifdef LOG_MESS
/*------------------------------------------------------------------------
| log_mess -
|------------------------------------------------------------------------*/
void log_mess(char *str, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  FILE *fp;
  int i;

  static struct {
    WORD value;
    char *string;
  }
  ddd[200] =
  {
    {WM_COMPACTING, "WM_COMPACTING"},
    {WM_WININICHANGE, "WM_WININICHANGE"},
    {WM_SYSCOLORCHANGE, "WM_SYSCOLORCHANGE"},
    {WM_QUERYNEWPALETTE, "WM_QUERYNEWPALETTE"},
    {WM_PALETTEISCHANGING, "WM_PALETTEISCHANGING"},
    {WM_PALETTECHANGED, "WM_PALETTECHANGED"},
    {WM_FONTCHANGE, "WM_FONTCHANGE"},
    {WM_SPOOLERSTATUS, "WM_SPOOLERSTATUS"},
    {WM_DEVMODECHANGE, "WM_DEVMODECHANGE"},
    {WM_TIMECHANGE, "WM_TIMECHANGE"},
    {WM_NULL, "WM_NULL"},
    {WM_USER, "WM_USER"},
    {WM_PENWINFIRST, "WM_PENWINFIRST"},
    {WM_PENWINLAST, "WM_PENWINLAST"},
#ifdef WIN16
    {WM_COALESCE_FIRST, "WM_COALESCE_FIRST"},
    {WM_COALESCE_LAST, "WM_COALESCE_LAST"},
#endif
    {WM_POWER, "WM_POWER"},
    {WM_QUERYENDSESSION, "WM_QUERYENDSESSION"},
    {WM_ENDSESSION, "WM_ENDSESSION"},
    {WM_QUIT, "WM_QUIT"},
#ifdef WIN16
    {WM_SYSTEMERROR, "WM_SYSTEMERROR"},
#endif
    {WM_CREATE, "WM_CREATE"},
    {WM_NCCREATE, "WM_NCCREATE"},
    {WM_DESTROY, "WM_DESTROY"},
    {WM_NCDESTROY, "WM_NCDESTROY"},
    {WM_SHOWWINDOW, "WM_SHOWWINDOW"},
    {WM_SETREDRAW, "WM_SETREDRAW"},
    {WM_ENABLE, "WM_ENABLE"},
    {WM_SETTEXT, "WM_SETTEXT"},
    {WM_GETTEXT, "WM_GETTEXT"},
    {WM_GETTEXTLENGTH, "WM_GETTEXTLENGTH"},
    {WM_WINDOWPOSCHANGING, "WM_WINDOWPOSCHANGING"},
    {WM_WINDOWPOSCHANGED, "WM_WINDOWPOSCHANGED"},
    {WM_MOVE, "WM_MOVE"},
    {WM_SIZE, "WM_SIZE"},
    {WM_QUERYOPEN, "WM_QUERYOPEN"},
    {WM_CLOSE, "WM_CLOSE"},
    {WM_GETMINMAXINFO, "WM_GETMINMAXINFO"},
    {WM_PAINT, "WM_PAINT"},
    {WM_ERASEBKGND, "WM_ERASEBKGND"},
    {WM_ICONERASEBKGND, "WM_ICONERASEBKGND"},
    {WM_NCPAINT, "WM_NCPAINT"},
    {WM_NCCALCSIZE, "WM_NCCALCSIZE"},
    {WM_NCHITTEST, "WM_NCHITTEST"},
    {WM_QUERYDRAGICON, "WM_QUERYDRAGICON"},
    {WM_DROPFILES, "WM_DROPFILES"},
    {WM_ACTIVATE, "WM_ACTIVATE"},
    {WM_ACTIVATEAPP, "WM_ACTIVATEAPP"},
    {WM_NCACTIVATE, "WM_NCACTIVATE"},
    {WM_SETFOCUS, "WM_SETFOCUS"},
    {WM_KILLFOCUS, "WM_KILLFOCUS"},
    {WM_KEYDOWN, "WM_KEYDOWN"},
    {WM_KEYUP, "WM_KEYUP"},
    {WM_CHAR, "WM_CHAR"},
    {WM_DEADCHAR, "WM_DEADCHAR"},
    {WM_SYSKEYDOWN, "WM_SYSKEYDOWN"},
    {WM_SYSKEYUP, "WM_SYSKEYUP"},
    {WM_SYSCHAR, "WM_SYSCHAR"},
    {WM_SYSDEADCHAR, "WM_SYSDEADCHAR"},
    {WM_KEYFIRST, "WM_KEYFIRST"},
    {WM_KEYLAST, "WM_KEYLAST"},
    {WM_MOUSEMOVE, "WM_MOUSEMOVE"},
    {WM_LBUTTONDOWN, "WM_LBUTTONDOWN"},
    {WM_LBUTTONUP, "WM_LBUTTONUP"},
    {WM_LBUTTONDBLCLK, "WM_LBUTTONDBLCLK"},
    {WM_RBUTTONDOWN, "WM_RBUTTONDOWN"},
    {WM_RBUTTONUP, "WM_RBUTTONUP"},
    {WM_RBUTTONDBLCLK, "WM_RBUTTONDBLCLK"},
    {WM_MBUTTONDOWN, "WM_MBUTTONDOWN"},
    {WM_MBUTTONUP, "WM_MBUTTONUP"},
    {WM_MBUTTONDBLCLK, "WM_MBUTTONDBLCLK"},
    {WM_MOUSEFIRST, "WM_MOUSEFIRST"},
    {WM_MOUSELAST, "WM_MOUSELAST"},
    {WM_NCMOUSEMOVE, "WM_NCMOUSEMOVE"},
    {WM_NCLBUTTONDOWN, "WM_NCLBUTTONDOWN"},
    {WM_NCLBUTTONUP, "WM_NCLBUTTONUP"},
    {WM_NCLBUTTONDBLCLK, "WM_NCLBUTTONDBLCLK"},
    {WM_NCRBUTTONDOWN, "WM_NCRBUTTONDOWN"},
    {WM_NCRBUTTONUP, "WM_NCRBUTTONUP"},
    {WM_NCRBUTTONDBLCLK, "WM_NCRBUTTONDBLCLK"},
    {WM_NCMBUTTONDOWN, "WM_NCMBUTTONDOWN"},
    {WM_NCMBUTTONUP, "WM_NCMBUTTONUP"},
    {WM_NCMBUTTONDBLCLK, "WM_NCMBUTTONDBLCLK"},
    {WM_MOUSEACTIVATE, "WM_MOUSEACTIVATE"},
    {WM_CANCELMODE, "WM_CANCELMODE"},
    {WM_TIMER, "WM_TIMER"},
    {WM_INITMENU, "WM_INITMENU"},
    {WM_INITMENUPOPUP, "WM_INITMENUPOPUP"},
    {WM_MENUSELECT, "WM_MENUSELECT"},
    {WM_MENUCHAR, "WM_MENUCHAR"},
    {WM_COMMAND, "WM_COMMAND"},
    {WM_HSCROLL, "WM_HSCROLL"},
    {WM_VSCROLL, "WM_VSCROLL"},
    {WM_CUT, "WM_CUT"},
    {WM_COPY, "WM_COPY"},
    {WM_PASTE, "WM_PASTE"},
    {WM_CLEAR, "WM_CLEAR"},
    {WM_UNDO, "WM_UNDO"},
    {WM_RENDERFORMAT, "WM_RENDERFORMAT"},
    {WM_RENDERALLFORMATS, "WM_RENDERALLFORMATS"},
    {WM_DESTROYCLIPBOARD, "WM_DESTROYCLIPBOARD"},
    {WM_DRAWCLIPBOARD, "WM_DRAWCLIPBOARD"},
    {WM_PAINTCLIPBOARD, "WM_PAINTCLIPBOARD"},
    {WM_SIZECLIPBOARD, "WM_SIZECLIPBOARD"},
    {WM_VSCROLLCLIPBOARD, "WM_VSCROLLCLIPBOARD"},
    {WM_HSCROLLCLIPBOARD, "WM_HSCROLLCLIPBOARD"},
    {WM_ASKCBFORMATNAME, "WM_ASKCBFORMATNAME"},
    {WM_CHANGECBCHAIN, "WM_CHANGECBCHAIN"},
    {WM_SETCURSOR, "WM_SETCURSOR"},
    {WM_SYSCOMMAND, "WM_SYSCOMMAND"},
    {WM_MDICREATE, "WM_MDICREATE"},
    {WM_MDIDESTROY, "WM_MDIDESTROY"},
    {WM_MDIACTIVATE, "WM_MDIACTIVATE"},
    {WM_MDIRESTORE, "WM_MDIRESTORE"},
    {WM_MDINEXT, "WM_MDINEXT"},
    {WM_MDIMAXIMIZE, "WM_MDIMAXIMIZE"},
    {WM_MDITILE, "WM_MDITILE"},
    {WM_MDICASCADE, "WM_MDICASCADE"},
    {WM_MDIICONARRANGE, "WM_MDIICONARRANGE"},
    {WM_MDIGETACTIVE, "WM_MDIGETACTIVE"},
    {WM_MDISETMENU, "WM_MDISETMENU"},
    {WM_CHILDACTIVATE, "WM_CHILDACTIVATE"},
    {WM_INITDIALOG, "WM_INITDIALOG"},
    {WM_NEXTDLGCTL, "WM_NEXTDLGCTL"},
    {WM_PARENTNOTIFY, "WM_PARENTNOTIFY"},
    {WM_ENTERIDLE, "WM_ENTERIDLE"},
    {WM_GETDLGCODE, "WM_GETDLGCODE"},
#ifdef WIN16
    {WM_CTLCOLOR, "WM_CTLCOLOR"},
#endif
    {WM_CTLCOLORMSGBOX, "WM_CTLCOLORMSGBOX"},
    {WM_CTLCOLOREDIT, "WM_CTLCOLOREDIT"},
    {WM_CTLCOLORLISTBOX, "WM_CTLCOLORLISTBOX"},
    {WM_CTLCOLORBTN, "WM_CTLCOLORBTN"},
    {WM_CTLCOLORDLG, "WM_CTLCOLORDLG"},
    {WM_CTLCOLORSCROLLBAR, "WM_CTLCOLORSCROLLBAR"},
    {WM_CTLCOLORSTATIC, "WM_CTLCOLORSTATIC"},

    {WM_SETFONT, "WM_SETFONT"},
    {WM_GETFONT, "WM_GETFONT"},
    {WM_DRAWITEM, "WM_DRAWITEM"},
    {WM_MEASUREITEM, "WM_MEASUREITEM"},
    {WM_DELETEITEM, "WM_DELETEITEM"},
    {0xfff0, "WM_?"}
};

  fp = fopen("log.tmp", "a");
  if (fp == NULL) return;
  i = 0;

  while (ddd[i].value != 0xfff0)
  {
    if (message == ddd[i].value) break;
    ++i;
  }

  if (ddd[i].value == 0xfff0)  /* not found */
  {
    if ((message >= WM_USER) && (message <= (WM_USER+0x100)))
      fprintf(fp, "%s,WM_USER+%x> ", str, message-WM_USER);
    else
      fprintf(fp, "%s,%s %x> ", str, ddd[i].string, message);
  }
  else
    fprintf(fp, "%s,%s> ", str, ddd[i].string);

  fprintf(fp, "h:%x, m:%x, w:%x, lh:%x ll:%x\n", hwnd, message, wParam,
                               HIWORD(lParam),  LOWORD(lParam));

  fclose(fp);
}

#endif

#ifndef S_VS
#ifndef S_RK
ERROR, makefile should define S_VS or S_RK
#endif
#endif

#ifdef S_VS
#ifdef S_RK
ERROR, makefile should define S_VS or S_RK
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\setupu.h ===
// setupu.h

//--- flags for win_type
#define WIN_UNKNOWN     0
#define WIN_NT          1
#define WIN_95          2

//--- country codes for SocketModem support
#define mcNotUsed         0
#define mcAustria         1
#define mcBelgium         2
#define mcDenmark         3
#define mcFinland         4
#define mcFrance          5
#define mcGermany         6
#define mcIreland         7
#define mcItaly           8
#define mcLuxembourg      9
#define mcNetherlands     10
#define mcNorway          11
#define mcPortugal        12
#define mcSpain           13
#define mcSweden          14
#define mcSwitzerland     15
#define mcUK              16
#define mcGreece          17
#define mcIsrael          18
#define mcCzechRep        19
#define mcCanada          20
#define mcMexico          21
#define mcUSA             22         
#define mcNA              mcUSA          // North America
#define mcHungary         23
#define mcPoland          24
#define mcRussia          25
#define mcSlovacRep       26
#define mcBulgaria        27
// 28
// 29
#define mcIndia           30
// 31
// 32
// 33
// 34
// 35
// 36
// 37
// 38
// 39
#define mcAustralia       40
#define mcChina           41
#define mcHongKong        42
#define mcJapan           43
#define mcPhilippines     mcJapan
#define mcKorea           44
// 45
#define mcTaiwan          46
#define mcSingapore       47
#define mcNewZealand      48

typedef struct {
  HINSTANCE hinst;    // needed for some system calls
  int prompting_off;  // turns prompting off(silent install).
  int win_type;       // 0=unknown, 1=NT, 2=win95
  int major_ver;
  int minor_ver;

       // this holds the pnp-name we use as a registry key to hold
       // our device parameters in the registry for RocketPort & NT50
  char szNt50DevObjName[50];  // typical: "Device_002456

  char szServiceName[50];   // typical: "RocketPort"
  char szDriverName[50];    // typical: "Rocket.sys"
  char szAppDir[50];        // typical: "Rocket"
  char szAppName[150];      // typical: "RocketPort/RocketModem Setup"

  char src_dir[250];        // typical: "a:\"
  char dest_dir[250];       // typical: "c:\windows\system32\rocket

  // following are used as convenient buffer for build src/dest filenames
  char src_str[256];
  char dest_str[256];
  char tmpstr[256];
} InstallPaths;

//--- flags for io_sel[]
#define PCI_SEL 1
#define MCA_SEL 2

//--- flags for install_type
#define INS_NETWORK_INF   1     // traditional nt4.0 network install(oemsetup.inf)
#define INS_NT50_INF      2     // plug n pray nt5.0 install(rocketpt.inf)
#define INS_SIMPLE        3     // no inf, we installed

typedef struct Port_Config;     // forward decl.

// option_flags: option to ignore some tx-buffering
//#define OPT_WAITONTX       1
// option_flags: option to always process with 485 control on rts signal
//#define OPT_RS485_OVERRIDE 2
// option_flags: option to process 485 rts to low(backward) to enable tx.
//#define OPT_RS485_LOW      4
// option_flags: option to map CD to DSR.
//#define OPT_MAP_CDTODSR    8
// option_flags: option to map 2 stop bits to 1
//#define OPT_MAP_2TO1       10

typedef struct {
  int index;
  char  Name[16];       // actual com port name(example: "COM#")
  //char  Desc[42];       // a user description tag for convience
  DWORD LockBaud;       // override for the baud rate

  //DWORD Options;        // see bit options
  DWORD WaitOnTx : 1;
  DWORD RS485Override : 1;
  DWORD RS485Low : 1;
  DWORD Map2StopsTo1 : 1;
  DWORD MapCdToDsr : 1;
  DWORD RingEmulate : 1;

  DWORD TxCloseTime;    // seconds to wait for tx to finish spooling on close.
  HTREEITEM tvHandle;   // treeview handle
#ifdef NT50
 HANDLE hPnpNode;  // handle to device node
#endif
} Port_Config;

typedef struct {
  char Name[64];       // user designated name(limit to 59 chars please)
  char ModelName[50];  // (e.g., "RocketModem")
  BYTE MacAddr[6];     // mac addr, ff ff ff ff ff ff = auto
  int NumPorts;
  int ModemDevice;     // 1=RocketModem & VS2000, 0=RocketPort & VS1000
  int HubDevice;       // 1=SerialHub family, 0=VS family
  int IoAddress;       // rocketport(0=not installed, 1=pci, 0x180 = def isa io)
  int StartComIndex;   // first port(0=auto)
  int BackupServer;    // 1=backup server, 0=normal server
  int BackupTimer;     // delay timeout for backup to kick in(minutes)
  Port_Config *ports;  // ptr to an array of ports config structs
  HTREEITEM tvHandle;  // treeview handle
  int HardwareId;      // Pnp reads in a unique id from the reg/inf files.
} Device_Config;

#define MAX_NUM_DEVICES 64

typedef struct {
   int driver_type;  // 0=rocketport, 1=vs1000...

   // NT4.0 used older network style INF files, we need to switch
   // to newer NT5.0 style INF files.  As a alternative to both,
   // we allow running without an INF file where we copy over the
   // needed files and setup the registry directly.
  int install_style;

  int nt_reg_flags;     // 1H=new install, 2H=Missing registry entries

  // following is array of device config structs.
  Device_Config *dev;   // ptr to array of Device structs, up to MAX_NUM_DEVICES.
  int NumDevices;

  // following used to hold the current selection of io-addr, irq, etc.
  int  irq_sel;         //

  int ScanRate;       // in millisecond units.
  int VerboseLog;     // true if we want verbose event logging
  int NoPnpPorts;       // true if nt5.0 pnp ports active
  int UseIRQ;         // true if user wants to use an irq
  int ModemCountry;   // modem country code for internal modem devices
  int GlobalRS485;    // display RS485 options on all ports

  int DriverExitDone; // tells if we did all the Driver exit stuff.
  int NeedReset;      // flag, true if we need a reset to invoke changes
  int ChangesMade;    // flag, true if changes were made.

  InstallPaths ip;
} Driver_Config;

int APIENTRY setup_install_info(InstallPaths *ip,
                 HINSTANCE hinst,
                 char *NewServiceName,
                 char *NewDriverName,
                 char *NewAppName,
                 char *NewAppDir);

int APIENTRY remove_driver_reg_entries(char *ServiceName);
int APIENTRY remove_pnp_reg_entries(void);
DWORD APIENTRY RegDeleteKeyNT(HKEY hStartKey , LPTSTR pKeyName );
int APIENTRY modem_inf_change(InstallPaths *ip,
                              char *modemfile,
                              char *szModemInfEntry);
int APIENTRY backup_modem_inf(InstallPaths *ip);

#define CHORE_INSTALL 1
#define CHORE_START   2
#define CHORE_STOP    3
#define CHORE_REMOVE  4
#define CHORE_INSTALL_SERVICE 5
#define CHORE_IS_INSTALLED 6

int APIENTRY service_man(LPSTR lpServiceName, LPSTR lpBinaryPath, int chore);

int APIENTRY make_szSCS(char *str, const char *szName);
int APIENTRY make_szSCSES(char *str, const char *szName);
int APIENTRY copy_files(InstallPaths *ip, char **files);
int APIENTRY our_copy_file(char *dest, char *src);

int APIENTRY our_message(InstallPaths *ip, char *str, WORD option);
int APIENTRY load_str(HINSTANCE hinst, int id, char *dest, int str_size);
int APIENTRY our_id_message(InstallPaths *ip, int id, WORD prompt);
void APIENTRY mess(InstallPaths *ip, char *format, ...);
int APIENTRY unattended_add_port_entries(InstallPaths *ip,
                                         int num_entries,
                                         int start_port);
TCHAR *RcStr(int msgstrindx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\strings.c ===
#include "strings.h"

/* Module to hold const strings used in setup program */

#ifdef S_VS
const char * szServiceName      = {"VSLinkA"};
const char * szDriverDevice     = {"\\\\.\\vslinka"};
#else
const char * szServiceName      = {"RocketPort"};
const char * szDriverDevice     = {"\\\\.\\rocket"};
#endif

/* registry values - device options */
#ifdef S_RK
  const char * szRocketPort     = {"RocketPort"};
  const char * szRocketPort485  = {"RocketPort 485"};
  const char * szRocketPortPlus = {"RocketPort Plus"};
  const char * szRocketModem    = {"RocketModem"};
  const char * szRocketModemII  = {"RocketModemII"};
  const char * szRocketModem_i  = {"RocketModem i"};
#else
  const char * szVS1000         = {"VS1000"};
  const char * szVS2000         = {"VS2000"};
  const char * szSerialHub      = {"RocketPort Serial Hub"};
#endif

/* values - port options */
const char * szNP2            = {"2"};
const char * szNP4            = {"4"};
const char * szNP6            = {"6"};
const char * szNP8            = {"8"};
const char * szNP16           = {"16"};
const char * szNP32           = {"32"};
const char * szNP48           = {"48"};
const char * szNP64           = {"64"};

//--- country codes for SocketModem support
#define mcNotUsed         0
#define mcAustria         1
#define mcBelgium         2
#define mcDenmark         3
#define mcFinland         4
#define mcFrance          5
#define mcGermany         6
#define mcIreland         7
#define mcItaly           8
#define mcLuxembourg      9
#define mcNetherlands     10
#define mcNorway          11
#define mcPortugal        12
#define mcSpain           13
#define mcSweden          14
#define mcSwitzerland     15
#define mcUK              16
#define mcGreece          17
#define mcIsrael          18
#define mcCzechRep        19
#define mcCanada          20
#define mcMexico          21
#define mcUSA             22         
#define mcNA              mcUSA          // North America
#define mcHungary         23
#define mcPoland          24
#define mcRussia          25
#define mcSlovacRep       26
#define mcBulgaria        27
// 28
// 29
#define mcIndia           30
// 31
// 32
// 33
// 34
// 35
// 36
// 37
// 38
// 39
#define mcAustralia       40
#define mcChina           41
#define mcHongKong        42
#define mcJapan           43
#define mcPhilippines     mcJapan
#define mcKorea           44
// 45
#define mcTaiwan          46
#define mcSingapore       47
#define mcNewZealand      48
//
//  this table is for the 33.6K V.34 ROW modems, & RocketModemII...
//
row_entry RowInfo[NUM_ROW_COUNTRIES] =
                  {{mcNA,       "North America"},
                  { mcFrance,   "France"},
                  { mcGermany,  "Germany"},
                  { mcItaly,    "Italy"},
                  { mcSweden,   "Sweden"},
                  { mcUK,       "United Kingdom"}};
//
//  this table is for the 56K V.90 ROW modems...
//
row_entry CTRRowInfo[NUM_CTR_ROW_COUNTRIES] =
                  {{mcUK,           "United Kingdom"},
                  { mcDenmark,      "Denmark"},
                  { mcFrance,       "France"},
                  { mcGermany,      "Germany"},
                  { mcIreland,      "Ireland"},
                  { mcItaly,        "Italy"},
                  { mcJapan,        "Japan"},
                  { mcNetherlands,  "Netherlands"},
                  { mcPhilippines,  "Philippines"},
                  { mcSpain,        "Spain"},
                  { mcSweden,       "Sweden"},
                  { mcSwitzerland,  "Switzerland"}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyclom-y\cd1400.h ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Bus/Port Driver
*	
*   This file:      cd1400.h
*	
*   Description:    This file contains the Cirrus CD1400 serial
*                   controller related contants, macros, addresses,
*                   etc.
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/


#ifndef CD1400
#define CD1400 1


/* max number of chars in the FIFO */

#define MAX_CHAR_FIFO   (12)

/* Firmware Revision Code */

#define REV_G		0x46


/* CD1400 registers */

/* Global Registers */

#define GFRCR  (2 * 0x40)
#define CAR    (2 * 0x68)
#define GCR    (2 * 0x4b)
#define SVRR   (2 * 0x67)
#define RICR   (2 * 0x44)
#define TICR   (2 * 0x45)
#define MICR   (2 * 0x46)
#define RIR    (2 * 0x6b)
#define TIR    (2 * 0x6a)
#define MIR    (2 * 0x69)
#define PPR    (2 * 0x7e)

/* Virtual Registers */

#define RIVR   (2 * 0x43)
#define TIVR   (2 * 0x42)
#define MIVR   (2 * 0x41)
#define TDR    (2 * 0x63)
#define RDSR   (2 * 0x62)
#define MISR   (2 * 0x4c)
#define EOSRR  (2 * 0x60)

/* Channel Registers */

#define LIVR   (2 * 0x18)
#define CCR    (2 * 0x05)
#define SRER   (2 * 0x06)
#define COR1   (2 * 0x08)
#define COR2   (2 * 0x09)
#define COR3   (2 * 0x0a)
#define COR4   (2 * 0x1e)
#define COR5   (2 * 0x1f)
#define CCSR   (2 * 0x0b)
#define RDCR   (2 * 0x0e)
#define SCHR1  (2 * 0x1a)
#define SCHR2  (2 * 0x1b)
#define SCHR3  (2 * 0x1c)
#define SCHR4  (2 * 0x1d)
#define SCRL   (2 * 0x22)
#define SCRH   (2 * 0x23)
#define LNC    (2 * 0x24)
#define MCOR1  (2 * 0x15)
#define MCOR2  (2 * 0x16)
#define RTPR   (2 * 0x21)
#define MSVR1  (2 * 0x6c)
#define MSVR2  (2 * 0x6d)
#define PVSR   (2 * 0x6f)
#define RBPR   (2 * 0x78)
#define RCOR   (2 * 0x7c)
#define TBPR   (2 * 0x72)
#define TCOR   (2 * 0x76)


/* Register Settings */

/* Channel Access Register  (CAR) */

#define CHAN0	0x00
#define CHAN1 	0x01
#define CHAN2	0x02
#define CHAN3	0x03
 
/* Channel Option Register 1 (COR1)  */

#define  COR1_NONE_PARITY     0x10
#define  COR1_ODD_PARITY      0xc0
#define  COR1_EVEN_PARITY     0x40
#define  COR1_MARK_PARITY     0xb0
#define  COR1_SPACE_PARITY    0x30
#define  COR1_PARITY_MASK     0xf0
#define  COR1_PARITY_ENABLE_MASK 0x60

#define  COR1_1_STOP    0x00
#define  COR1_1_5_STOP  0x04
#define  COR1_2_STOP    0x08
#define  COR1_STOP_MASK 0x0c

#define  COR1_5_DATA		0x00
#define  COR1_6_DATA		0x01
#define  COR1_7_DATA		0x02
#define  COR1_8_DATA		0x03
#define  COR1_DATA_MASK	0x03

/* Channel Option Register 2  (COR2) */

#define IMPL_XON	0x80
#define AUTO_TXFL	0x40
#define EMBED_TX_ENABLE 0x20
#define LOCAL_LOOP_BCK 	0x10
#define REMOTE_LOOP_BCK 0x08
#define RTS_AUT_OUTPUT	0x04
#define CTS_AUT_ENABLE	0x02

/* Channel Option Register 3  (COR3) */

#define SPL_CH_DRANGE	0x80  /* special character detect range */
#define SPL_CH_DET1	0x40  /* enable special char. detect on SCHR4-SCHR3 */
#define FL_CTRL_TRNSP	0x20  /* Flow Control Transparency */
#define SPL_CH_DET2	0x10  /* Enable spl char. detect on SCHR2-SCHR1 */
#define REC_FIFO_12CH	0x0c  /* Receive FIFO threshold= 12 chars */


/* Global Configuration Register (GCR) values */

#define GCR_CH0_IS_SERIAL	0x00

/* Prescaler Period Register (PPR) values */

#define CLOCK_20_1MS	0x27
#define CLOCK_25_1MS	0x31
#define CLOCK_60_1MS	0x75

/* Channel Command Register (CCR) values */

#define CCR_RESET_CHANNEL           0x80
#define CCR_RESET_CD1400            0x81
#define CCR_FLUSH_TXFIFO            0x82
#define CCR_CORCHG_COR1             0x42
#define CCR_CORCHG_COR2             0x44
#define CCR_CORCHG_COR1_COR2        0x46
#define CCR_CORCHG_COR3             0x48
#define CCR_CORCHG_COR3_COR1        0x4a
#define CCR_CORCHG_COR3_COR2        0x4c
#define CCR_CORCHG_COR1_COR2_COR3   0x4e
#define CCR_SENDSC_SCHR1            0x21
#define CCR_SENDSC_SCHR2            0x22
#define CCR_SENDSC_SCHR3            0x23
#define CCR_SENDSC_SCHR4            0x24
#define CCR_DIS_RX                  0x11
#define CCR_ENA_RX                  0x12
#define CCR_DIS_TX                  0x14
#define CCR_ENA_TX                  0x18
#define CCR_DIS_TX_RX               0x15
#define CCR_DIS_TX_ENA_RX           0x16
#define CCR_ENA_TX_DIS_RX           0x19
#define CCR_ENA_TX_RX               0x1a

/* Service Request Enable Register (SRER) values */

#define SRER_TXRDY         0x04
#define SRER_TXMPTY        0x02


// Read from CD1400 registers

#define CD1400_READ(ChipAddress,IsPci,Register)             \
   (READ_REGISTER_UCHAR((ChipAddress)+((Register)<<(IsPci))))

// Write to CD1400 registers

#define CD1400_WRITE(ChipAddress,IsPci,Register,Value)      \
do                                                          \
{                                                           \
   WRITE_REGISTER_UCHAR(                                    \
      (ChipAddress)+ ((Register) << (IsPci)),               \
      (UCHAR)(Value)                                        \
      );                                                    \
} while (0);

#define CD1400_DISABLE_ALL_INTERRUPTS(ChipAddress,IsPci,CdChannel)  \
do                                                                  \
{                                                                   \
    CD1400_WRITE((ChipAddress),(IsPci),CAR,(CdChannel & 0x03));     \
    CD1400_WRITE((ChipAddress),(IsPci),SRER,0x00);                  \
                                                                    \
} while (0);


#endif /* CD1400 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\setup\strings.h ===
#define NUM_ROW_COUNTRIES 6
#define NUM_CTR_ROW_COUNTRIES 12

typedef struct {
  int RowCountryCode;
  char RowCountryName[40];
} row_entry;

/*-----------------------------------------------------------------*/

extern const char * szServiceName;
extern const char * szDriverDevice;

/* registry values - device options */
#ifdef S_RK
  extern const char * szRocketPort;
  extern const char * szRocketPort485;
  extern const char * szRocketPortPlus;
  extern const char * szRocketModem;
  extern const char * szRocketModemII;
  extern const char * szRocketModem_i;
#else
  extern const char * szVS1000;
  extern const char * szVS2000;
  extern const char * szSerialHub;
#endif

/* registry values - port options */

extern const char * szNP2;
extern const char * szNP4;
extern const char * szNP6;
extern const char * szNP8;
extern const char * szNP16;
extern const char * szNP32;
extern const char * szNP48;
extern const char * szNP64;

extern row_entry RowInfo[NUM_ROW_COUNTRIES];
extern row_entry CTRRowInfo[NUM_CTR_ROW_COUNTRIES];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyclom-y\cyyguid.h ===
/*--------------------------------------------------------------------------
*   
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*   
*   Cyclom-Y Enumerator Driver
*   
*   This file:      cyyguid.h
*   
*   Description:    Defines GUIDs for function device classes and device 
*                   events used in Plug & Play.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*   
*   Complies with Cyclades SW Coding Standard rev 1.3.
*   
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#ifdef DEFINE_GUID   // don't break compiles of drivers that 
                     // include this header but don't want the
                     // GUIDs

// {27111c90-e3ee-11d2-90f6-0000b4341b13} 
DEFINE_GUID( GUID_BUS_TYPE_CYCLOMY, 
             0x27111c90L, 0xe3ee, 0x11d2, 0x90, 0xf6, 0x00, 0x00, 0xb4, 0x34, 0x1b, 0x13 );

// {6EF3E5F9-C75D-471c-BC7A-3E349058F7C8}
DEFINE_GUID( GUID_CYCLOMY_BUS_ENUMERATOR, 
             0x6ef3e5f9, 0xc75d, 0x471c, 0xbc, 0x7a, 0x3e, 0x34, 0x90, 0x58, 0xf7, 0xc8);

#endif   // DEFINE_GUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyclom-y\cyclom-y.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      cyclom-y.c
*	
*   Description:    This module contains contains the entry points 
*                   for a standard bus PNP / WDM driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "pch.h"

//
// Declare some entry functions as pageable, and make DriverEntry
// discardable
//

NTSTATUS DriverEntry(PDRIVER_OBJECT, PUNICODE_STRING);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, Cyclomy_DriverUnload)
#endif

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING UniRegistryPath
    )
/*++
Routine Description:

    Initialize the entry points of the driver.

--*/
{
    ULONG i;
    PRTL_QUERY_REGISTRY_TABLE QueryTable = NULL;
    ULONG breakOnEntryDefault = FALSE;
    ULONG shouldBreakOnEntry = FALSE;

    UNREFERENCED_PARAMETER (UniRegistryPath);

    Cyclomy_KdPrint_Def (SER_DBG_SS_TRACE, ("Driver Entry\n"));
    Cyclomy_KdPrint_Def (SER_DBG_SS_TRACE, ("RegPath: %x\n", UniRegistryPath));

    //
    // Get the BreakOnEntry from the registry
    //

    if (NULL == (QueryTable = ExAllocatePool(
                         PagedPool,
                         sizeof(RTL_QUERY_REGISTRY_TABLE)*2
                          ))) {
        Cyclomy_KdPrint_Def (SER_DBG_PNP_ERROR,
              ("Failed to allocate memory to query registry\n"));
    } else {
        RtlZeroMemory(
                 QueryTable,
                 sizeof(RTL_QUERY_REGISTRY_TABLE)*2
                  );

        QueryTable[0].QueryRoutine = NULL;
        QueryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        QueryTable[0].EntryContext = &shouldBreakOnEntry;
        QueryTable[0].Name      = L"BreakOnEntry";
        QueryTable[0].DefaultType   = REG_DWORD;
        QueryTable[0].DefaultData   = &breakOnEntryDefault;
        QueryTable[0].DefaultLength= sizeof(ULONG);

        // BUGBUG: The rest of the table isn't filled in!

        if (!NT_SUCCESS(RtlQueryRegistryValues(
             RTL_REGISTRY_SERVICES,
             L"cyclom-y",
             QueryTable,
             NULL,
             NULL))) {
               Cyclomy_KdPrint_Def (SER_DBG_PNP_ERROR,
                   ("Failed to get BreakOnEntry level from registry.  Using default\n"));
               shouldBreakOnEntry = breakOnEntryDefault;
        }

        ExFreePool( QueryTable );
    }


    if (shouldBreakOnEntry) {
        DbgBreakPoint();
    }


    DriverObject->MajorFunction [IRP_MJ_CREATE] =
    DriverObject->MajorFunction [IRP_MJ_CLOSE]  = Cyclomy_CreateClose;
    DriverObject->MajorFunction [IRP_MJ_PNP]    = Cyclomy_PnP;
    DriverObject->MajorFunction [IRP_MJ_POWER]  = Cyclomy_Power;
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = Cyclomy_IoCtl;
    DriverObject->MajorFunction [IRP_MJ_SYSTEM_CONTROL] = Cyclomy_DispatchPassThrough;
    DriverObject->DriverUnload = Cyclomy_DriverUnload;
    DriverObject->DriverExtension->AddDevice = Cyclomy_AddDevice;

    return STATUS_SUCCESS;
}


NTSTATUS
CyclomySyncCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                      IN PKEVENT CyclomySyncEvent)
{
   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);


   KeSetEvent(CyclomySyncEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
Cyclomy_CreateClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++
Routine Description:
    Some outside source is trying to create a file against us.

    If this is for the FDO (the bus itself) then the caller is trying to
    open the propriatary conection to tell us which serial port to enumerate.

    If this is for the PDO (an object on the bus) then this is a client that
    wishes to use the serial port.
--*/
{
   PIO_STACK_LOCATION irpStack;
   NTSTATUS status;
   PFDO_DEVICE_DATA fdoData;
   KEVENT completionEvent;
   PDEVICE_OBJECT pNextDevice;


   UNREFERENCED_PARAMETER(DeviceObject);

   status = STATUS_INVALID_DEVICE_REQUEST;
   Irp->IoStatus.Information = 0;
    
   fdoData = DeviceObject->DeviceExtension;
   if (fdoData->IsFDO) {

      if (fdoData->DevicePnPState == Deleted){         
         status = STATUS_DELETE_PENDING;
      } else {

         irpStack = IoGetCurrentIrpStackLocation(Irp);

         switch (irpStack->MajorFunction) {

         case IRP_MJ_CREATE:

            Cyclomy_KdPrint_Def(SER_DBG_SS_TRACE, ("Create"));
            if ((fdoData->DevicePnPState == RemovePending) || 
               (fdoData->DevicePnPState == SurpriseRemovePending)) {
               status = STATUS_DELETE_PENDING;
            } else {
               status = STATUS_SUCCESS;
            }
            break;

         case IRP_MJ_CLOSE:

            Cyclomy_KdPrint_Def (SER_DBG_SS_TRACE, ("Close \n"));
            status = STATUS_SUCCESS;
            break;
         }
      }
   }

   Irp->IoStatus.Status = status;
   IoCompleteRequest (Irp, IO_NO_INCREMENT);
   return status;
}

NTSTATUS
Cyclomy_IoCtl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    PCOMMON_DEVICE_DATA     commonData;
    PFDO_DEVICE_DATA        fdoData;

    Cyclomy_KdPrint_Def (SER_DBG_IOCTL_TRACE, ("Cyclomy_IoCtl\n"));

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_DEVICE_CONTROL == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;
    fdoData = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;

    //
    // We only take Device Control requests for the FDO.
    // That is the bus itself.

    if (!commonData->IsFDO) {
        //
        // These commands are only allowed to go to the FDO.
        //   
        status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    status = Cyclomy_IncIoCount (fdoData);

    if (!NT_SUCCESS (status)) {
        //
        // This bus has received the PlugPlay remove IRP.  It will no longer
        // respond to external requests.
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    // Actually, we don't handle any Ioctl.
    status = STATUS_INVALID_DEVICE_REQUEST;

    Cyclomy_DecIoCount (fdoData);

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
}

VOID
Cyclomy_DriverUnload (
    IN PDRIVER_OBJECT Driver
    )
/*++
Routine Description:
    Clean up everything we did in driver entry.

--*/
{
    UNREFERENCED_PARAMETER (Driver);
    PAGED_CODE();

    //
    // All the device objects should be gone.
    //

    ASSERT (NULL == Driver->DeviceObject);

    //
    // Here we free any resources allocated in DriverEntry
    //

    return;
}

NTSTATUS
Cyclomy_IncIoCount (
    PFDO_DEVICE_DATA Data
    )
{
    InterlockedIncrement (&Data->OutstandingIO);
    if (Data->DevicePnPState == Deleted) {

        if (0 == InterlockedDecrement (&Data->OutstandingIO)) {
            KeSetEvent (&Data->RemoveEvent, 0, FALSE);
        }
        return STATUS_DELETE_PENDING;
    }
    return STATUS_SUCCESS;
}

VOID
Cyclomy_DecIoCount (
    PFDO_DEVICE_DATA Data
    )
{
    if (0 == InterlockedDecrement (&Data->OutstandingIO)) {
        KeSetEvent (&Data->RemoveEvent, 0, FALSE);
    }
}

NTSTATUS
Cyclomy_DispatchPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
Routine Description:

    Passes a request on to the lower driver.

--*/
{
    PIO_STACK_LOCATION IrpStack = 
            IoGetCurrentIrpStackLocation( Irp );

#if 1
        Cyclomy_KdPrint_Def (SER_DBG_SS_TRACE, ( 
            "[Cyclomy_DispatchPassThrough] "
            "IRP: %8x; "
            "MajorFunction: %d\n",
            Irp, 
            IrpStack->MajorFunction ));
#endif

    //
    // Pass the IRP to the target
    //
    IoSkipCurrentIrpStackLocation (Irp);
    
    if (((PPDO_DEVICE_DATA) DeviceObject->DeviceExtension)->IsFDO) {
        return IoCallDriver( 
            ((PFDO_DEVICE_DATA) DeviceObject->DeviceExtension)->TopOfStack,
            Irp );
    } else {
        return IoCallDriver( 
            ((PFDO_DEVICE_DATA) ((PPDO_DEVICE_DATA) DeviceObject->
                DeviceExtension)->ParentFdo->DeviceExtension)->TopOfStack,
                Irp );
    }
}           

void
Cyclomy_InitPDO (
    ULONG               Index,
    PDEVICE_OBJECT      Pdo,
    PFDO_DEVICE_DATA    FdoData
    )
/*
Description:
    Common code to initialize a newly created cyclom-y pdo.
    Called either when the control panel exposes a device or when Cyclom-Y senses
    a new device was attached.

Parameters:
    Pdo - The pdo
    FdoData - The fdo's device extension
    //Exposed - Was this pdo was found by serenum (FALSE) or was it was EXPOSEd by 
    //    a control panel applet (TRUE)?        -> Removed in build 2072
*/
{

    ULONG FdoFlags = FdoData->Self->Flags;
    PPDO_DEVICE_DATA pdoData = Pdo->DeviceExtension;

    HANDLE keyHandle;
    NTSTATUS status;
    
    //
    // Check the IO style
    //
    if (FdoFlags & DO_BUFFERED_IO) {
        Pdo->Flags |= DO_BUFFERED_IO;
    } else if (FdoFlags & DO_DIRECT_IO) {
        Pdo->Flags |= DO_DIRECT_IO;
    }
    
    //
    // Increment the pdo's stacksize so that it can pass irps through
    //
    Pdo->StackSize += FdoData->Self->StackSize;
    
    //
    // Initialize the rest of the device extension
    //
    pdoData->PortIndex = Index;
    pdoData->IsFDO = FALSE;
    pdoData->Self = Pdo;
    pdoData->ParentFdo = FdoData->Self;
    pdoData->Attached = TRUE; // attached to the bus

    INITIALIZE_PNP_STATE(pdoData);

    pdoData->DebugLevel = FdoData->DebugLevel;  // Copy the debug level

    pdoData->DeviceState = PowerDeviceD0;
    pdoData->SystemState = PowerSystemWorking;

    //
    // Add the pdo to cyclom-y's list
    //

    ASSERT(FdoData->AttachedPDO[Index] == NULL);
    ASSERT(FdoData->PdoData[Index] == NULL);
//  ASSERT(FdoData->NumPDOs == 0);  rem because NumPDOs can be > 0 in cyclom-y

    FdoData->AttachedPDO[Index] = Pdo;
    FdoData->PdoData[Index] = pdoData;
    FdoData->NumPDOs++;

    Pdo->Flags &= ~DO_DEVICE_INITIALIZING;  // Moved to end in DDK final version
    Pdo->Flags |= DO_POWER_PAGABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyclom-y\cyclom-y.h ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      cyclom-y.h
*	
*   Description:    This module contains the common private declarations 
*                   for the cyyport enumerator.
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#ifndef CYCLOMY_H
#define CYCLOMY_H

#include "cyyhw.h"

#define DEVICE_OBJECT_NAME_LENGTH   128     // Copied from serial.h

#define CYY_PDO_NAME_BASE L"\\Cyy\\"


#define CYCLOMY_POOL_TAG (ULONG)'YcyC'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
   ExAllocatePoolWithTag(type, size, CYCLOMY_POOL_TAG)


#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect


//
// Debugging Output Levels
//

#define SER_DBG_STARTUP_SHUTDOWN_MASK  0x0000000F
#define SER_DBG_SS_NOISE               0x00000001
#define SER_DBG_SS_TRACE               0x00000002
#define SER_DBG_SS_INFO                0x00000004
#define SER_DBG_SS_ERROR               0x00000008

#define SER_DBG_PNP_MASK               0x000000F0
#define SER_DBG_PNP_NOISE              0x00000010
#define SER_DBG_PNP_TRACE              0x00000020
#define SER_DBG_PNP_INFO               0x00000040
#define SER_DBG_PNP_ERROR              0x00000080
#define SER_DBG_PNP_DUMP_PACKET        0x00000100

#define SER_DBG_IOCTL_TRACE            0x00000200
#define SER_DBG_POWER_TRACE            0x00000400
#define SER_DBG_CYCLADES               0x00000800

#define SER_DEFAULT_DEBUG_OUTPUT_LEVEL 0x00000000
//#define SER_DEFAULT_DEBUG_OUTPUT_LEVEL 0xFFFFFFFF


#if DBG
#define Cyclomy_KdPrint(_d_,_l_, _x_) \
            if ((_d_)->DebugLevel & (_l_)) { \
               DbgPrint ("Cyclom-y: "); \
               DbgPrint _x_; \
            }

#define Cyclomy_KdPrint_Cont(_d_,_l_, _x_) \
            if ((_d_)->DebugLevel & (_l_)) { \
               DbgPrint _x_; \
            }

#define Cyclomy_KdPrint_Def(_l_, _x_) \
            if (SER_DEFAULT_DEBUG_OUTPUT_LEVEL & (_l_)) { \
               DbgPrint ("Cyclom-y: "); \
               DbgPrint _x_; \
            }

#define TRAP() DbgBreakPoint()
#define DbgRaiseIrql(_x_,_y_) KeRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_) KeLowerIrql(_x_)
#else

#define Cyclomy_KdPrint(_d_, _l_, _x_)
#define Cyclomy_KdPrint_Cont(_d_, _l_, _x_)
#define Cyclomy_KdPrint_Def(_l_, _x_)
#define TRAP()
#define DbgRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)

#endif

#if !defined(MIN)
#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))
#endif


//
// These are the states a PDO or FDO transition upon
// receiving a specific PnP Irp. Refer to the PnP Device States
// diagram in DDK documentation for better understanding.
//

typedef enum _DEVICE_PNP_STATE {

    NotStarted = 0,         // Not started yet
    Started,                // Device has received the START_DEVICE IRP
    StopPending,            // Device has received the QUERY_STOP IRP
    Stopped,                // Device has received the STOP_DEVICE IRP
    RemovePending,          // Device has received the QUERY_REMOVE IRP
    SurpriseRemovePending,  // Device has received the SURPRISE_REMOVE IRP
    Deleted,                // Device has received the REMOVE_DEVICE IRP
    UnKnown                 // Unknown state

} DEVICE_PNP_STATE;


//
// A common header for the device extensions of the PDOs and FDO
//

typedef struct _COMMON_DEVICE_DATA
{
    PDEVICE_OBJECT  Self;
    // A backpointer to the device object for which this is the extension

    BOOLEAN         IsFDO;

//    BOOLEAN         Removed;   // Added in build 2072
    // Has this device been removed?  Should we fail any requests?

    // We track the state of the device with every PnP Irp
    // that affects the device through these two variables.
    
    DEVICE_PNP_STATE DevicePnPState;
    DEVICE_PNP_STATE PreviousPnPState;

    ULONG           DebugLevel;

    SYSTEM_POWER_STATE  SystemState;
    DEVICE_POWER_STATE  DeviceState;
} COMMON_DEVICE_DATA, *PCOMMON_DEVICE_DATA;

//
// The device extension for the PDOs.
// That is the serial ports of which this bus driver enumerates.
// (IE there is a PDO for the 201 serial port).
//

typedef struct _PDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    PDEVICE_OBJECT  ParentFdo;
    // A back pointer to the bus

    UNICODE_STRING  HardwareIDs;
    // Either in the form of bus\device
    // or *PNPXXXX - meaning root enumerated

    UNICODE_STRING  CompIDs;
    // compatible ids to the hardware id

    UNICODE_STRING  DeviceIDs;
    // Format: bus\device

    UNICODE_STRING  InstanceIDs;

    //
    // Text describing device
    //

    UNICODE_STRING DevDesc;

    BOOLEAN     Attached;

    //    BOOLEAN     Removed;  -> Removed in build 2072
    // When a device (PDO) is found on a bus and presented as a device relation
    // to the PlugPlay system, Attached is set to TRUE, and Removed to FALSE.
    // When the bus driver determines that this PDO is no longer valid, because
    // the device has gone away, it informs the PlugPlay system of the new
    // device relastions, but it does not delete the device object at that time.
    // The PDO is deleted only when the PlugPlay system has sent a remove IRP,
    // and there is no longer a device on the bus.
    //
    // If the PlugPlay system sends a remove IRP then the Removed field is set
    // to true, and all client (non PlugPlay system) accesses are failed.
    // If the device is removed from the bus Attached is set to FALSE.
    //
    // During a query relations Irp Minor call, only the PDOs that are
    // attached to the bus (and all that are attached to the bus) are returned
    // (even if they have been removed).
    //
    // During a remove device Irp Minor call, if and only if, attached is set
    // to FALSE, the PDO is deleted.
    //


   // The child devices will have to know which PortIndex they are.
   ULONG PortIndex;

} PDO_DEVICE_DATA, *PPDO_DEVICE_DATA;


//
// The device extension of the bus itself.  From whence the PDO's are born.
//

typedef struct _FDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    PDRIVER_OBJECT   DriverObject;

    UCHAR            PdoIndex;
    // A number to keep track of the Pdo we're allocating.
    // Increment every time we create a new PDO.  It's ok that it wraps.

    ULONG            NumPDOs;
    // The PDOs currently enumerated.

    PDEVICE_OBJECT   AttachedPDO[CYY_MAX_PORTS];

    PPDO_DEVICE_DATA PdoData[CYY_MAX_PORTS];

    PDEVICE_OBJECT  UnderlyingPDO;
    PDEVICE_OBJECT  TopOfStack;
    // the underlying bus PDO and the actual device object to which our
    // FDO is attached

    ULONG           OutstandingIO;
    // the number of IRPs sent from the bus to the underlying device object

    KEVENT          RemoveEvent;
    // On remove device plugplay request we must wait until all outstanding
    // requests have been completed before we can actually delete the device
    // object.

    UNICODE_STRING DevClassAssocName;
    // The name returned from IoRegisterDeviceClass Association,
    // which is used as a handle for IoSetDev... and friends.

    SYSTEM_POWER_STATE  SystemWake;
    DEVICE_POWER_STATE  DeviceWake;

    //
    // We keep the following values around so that we can connect
    // to the interrupt and report resources after the configuration
    // record is gone.
    //

    //
    // Translated vector
    //
    ULONG Vector;

    //
    // Translated Irql
    //
    KIRQL Irql;

    //
    // Untranslated vector
    //
    ULONG OriginalVector;

    //
    // Untranslated irql
    //
    ULONG OriginalIrql;

    //
    // Bus number
    //
    ULONG BusNumber;

    //
    // Interface type
    //
    INTERFACE_TYPE InterfaceType;
       
    //
    // Cyclom-Y hardware
    //
    PHYSICAL_ADDRESS PhysicalRuntime;
    PHYSICAL_ADDRESS TranslatedRuntime;
    ULONG            RuntimeLength;
    
    PHYSICAL_ADDRESS PhysicalBoardMemory;
    PHYSICAL_ADDRESS TranslatedBoardMemory;
    ULONG            BoardMemoryLength;
 
    PUCHAR           Runtime;
    PUCHAR           BoardMemory;

    ULONG            IsPci;

    PUCHAR           Cd1400Base[CYY_MAX_CHIPS];

    // We are passing the resources privatly to our children so that Device Manager will not 
    // complain about resource conflict between children.

    PIO_RESOURCE_REQUIREMENTS_LIST  PChildRequiredList;
    PCM_RESOURCE_LIST  PChildResourceList;
    ULONG              PChildResourceListSize;

    PCM_RESOURCE_LIST  PChildResourceListTr;
    ULONG              PChildResourceListSizeTr;

    ULONG            UINumber;

} FDO_DEVICE_DATA, *PFDO_DEVICE_DATA;

//
// Macros
//

#define INITIALIZE_PNP_STATE(_Data_)    \
        (_Data_)->DevicePnPState =  NotStarted;\
        (_Data_)->PreviousPnPState = NotStarted;

#define SET_NEW_PNP_STATE(_Data_, _state_) \
        (_Data_)->PreviousPnPState =  (_Data_)->DevicePnPState;\
        (_Data_)->DevicePnPState = (_state_);

#define RESTORE_PREVIOUS_PNP_STATE(_Data_)   \
        (_Data_)->DevicePnPState =   (_Data_)->PreviousPnPState;\

//
// Free the buffer associated with a Unicode string
// and re-init it to NULL
//

#define CyclomyFreeUnicodeString(PStr) \
{ \
   if ((PStr)->Buffer != NULL) { \
      ExFreePool((PStr)->Buffer); \
   } \
   RtlInitUnicodeString((PStr), NULL); \
}

//
// Prototypes
//

NTSTATUS
Cyclomy_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cyclomy_IoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cyclomy_InternIoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
Cyclomy_DriverUnload (
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
Cyclomy_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cyclomy_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cyclomy_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusDeviceObject
    );

NTSTATUS
Cyclomy_PnPRemove (
    PDEVICE_OBJECT      Device,
    PPDO_DEVICE_DATA    PdoData
    );

NTSTATUS
Cyclomy_FDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
Cyclomy_PDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PPDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
Cyclomy_IncIoCount (
    PFDO_DEVICE_DATA   Data
    );

VOID
Cyclomy_DecIoCount (
    PFDO_DEVICE_DATA   Data
    );

NTSTATUS
Cyclomy_DispatchPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cyclomy_ReenumerateDevices(
    IN PIRP                 Irp,
    IN PFDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
Cyclomy_InitMultiString(PFDO_DEVICE_DATA FdoData, PUNICODE_STRING MultiString,
                        ...);
void
Cyclomy_PDO_EnumMarkMissing(
    PFDO_DEVICE_DATA FdoData,
    PPDO_DEVICE_DATA PdoData);

NTSTATUS
Cyclomy_GetRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength,
    OUT PULONG ActualLength);

void
Cyclomy_InitPDO (
    ULONG               index,
    PDEVICE_OBJECT      pdoData,
    PFDO_DEVICE_DATA    fdoData
    );

NTSTATUS
CyclomySyncCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                      IN PKEVENT CyclomySyncEvent);

NTSTATUS
Cyclomy_GetResourceInfo(IN PDEVICE_OBJECT PDevObj,
                    IN PCM_RESOURCE_LIST PResList,
                    IN PCM_RESOURCE_LIST PTrResList);

VOID
Cyclomy_ReleaseResources(IN PFDO_DEVICE_DATA PDevExt);

NTSTATUS
Cyclomy_GotoPowerState(IN PDEVICE_OBJECT PDevObj,
                   IN PFDO_DEVICE_DATA PDevExt,
                   IN DEVICE_POWER_STATE DevPowerState);
NTSTATUS
Cyclomy_SystemPowerCompletion(IN PDEVICE_OBJECT PDevObj, UCHAR MinorFunction,
                          IN POWER_STATE PowerState, IN PVOID Context,
                          PIO_STATUS_BLOCK IoStatus);

NTSTATUS
Cyclomy_ItemCallBack(
                  IN PVOID Context,
                  IN PUNICODE_STRING PathName,
                  IN INTERFACE_TYPE BusType,
                  IN ULONG BusNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
                  IN CONFIGURATION_TYPE ControllerType,
                  IN ULONG ControllerNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
                  IN CONFIGURATION_TYPE PeripheralType,
                  IN ULONG PeripheralNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
                  );

NTSTATUS
Cyclomy_BuildRequirementsList(
                          OUT PIO_RESOURCE_REQUIREMENTS_LIST *PChildRequiredList_Pointer,
                          IN PCM_RESOURCE_LIST PResourceList, IN ULONG NumberOfResources
                          );

NTSTATUS
Cyclomy_BuildResourceList(
                      OUT PCM_RESOURCE_LIST *POutList_Pointer,
                      OUT ULONG *ListSize_Pointer,
                      IN PCM_RESOURCE_LIST PInList,
                      IN ULONG NumberOfResources
                      );

ULONG
Cyclomy_DoesBoardExist(
                   IN PFDO_DEVICE_DATA Extension
                   );

ULONG
Cyclomy_DoesBoardExist(
                   IN PFDO_DEVICE_DATA Extension
                   );

VOID
Cyclomy_EnableInterruptInPLX(
      IN PFDO_DEVICE_DATA PDevExt
      );

VOID
CyyLogError(
              IN PDRIVER_OBJECT DriverObject,
              IN PDEVICE_OBJECT DeviceObject OPTIONAL,
              IN PHYSICAL_ADDRESS P1,
              IN PHYSICAL_ADDRESS P2,
              IN ULONG SequenceNumber,
              IN UCHAR MajorFunctionCode,
              IN UCHAR RetryCount,
              IN ULONG UniqueErrorValue,
              IN NTSTATUS FinalStatus,
              IN NTSTATUS SpecificIOStatus,
              IN ULONG LengthOfInsert1,
              IN PWCHAR Insert1,
              IN ULONG LengthOfInsert2,
              IN PWCHAR Insert2
              );

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
);

#endif // endef CYCLOMY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyclom-y\cyyhw.h ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Bus/Port Driver
*	
*   This file:      cyyhw.h
*	
*   Description:    This module contains the common hardware declarations 
*                   for the parent driver (cyclom-y) and child driver
*                   (cyyport).
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#ifndef CYYHW_H
#define CYYHW_H


#define MAX_DEVICE_ID_LEN     200	// This definition was copied from NTDDK\inc\cfgmgr32.h
									// Always check if this value was changed. 
									// This is the maximum length for the Hardware ID.

#define CYYPORT_PNP_ID_WSTR         L"Cyclom-Y\\Port"
#define CYYPORT_PNP_ID_STR          "Cyclom-Y\\Port"
#define CYYPORT_DEV_ID_STR          "Cyclom-Y\\Port"

#define CYY_NUMBER_OF_RESOURCES     3     // Memory, PLX Memory, Interrupt


// Cyclom-Y hardware
#define CYY_RUNTIME_LENGTH          0x00000080
#define CYY_MAX_CHIPS 	            8
#define CYY_CHANNELS_PER_CHIP       4
#define CYY_MAX_PORTS	            (CYY_CHANNELS_PER_CHIP*CYY_MAX_CHIPS)

// Custom register offsets
#define CYY_CLEAR_INTR	            0x1800	//Isa; for PCI, multiply by 2
#define CYY_RESET_16	               0x1400	//Isa; for PCI, multiply by 2
#define CYY_PCI_TYPE	               0x3400	//PCI (no need to multiply by 2)

// Values in CYY_PCI_TYPE register
#define CYY_PLX9050		(0x0b)
#define CYY_PLX9060		(0x0c)
#define CYY_PLX9080		(0x0d)

// Runtime registers (or Local Configuration registers)
#define PLX9050_INT_OFFSET	(0x4c)
#define PLX9060_INT_OFFSET	(0x68)
#define PLX9050_INT_ENABLE (0x00000043UL)
#define PLX9060_INT_ENABLE (0x00000900UL)


// Write to Custom registers

#define CYY_RESET_BOARD(BaseBoardAddress,IsPci)             \
do                                                          \
{                                                           \
   WRITE_REGISTER_UCHAR(                                    \
      (BaseBoardAddress)+(CYY_RESET_16 << IsPci),           \
      0x00                                                  \
      );                                                    \
} while (0);


#define CYY_CLEAR_INTERRUPT(BaseBoardAddress,IsPci)         \
do                                                          \
{                                                           \
   WRITE_REGISTER_UCHAR(                                    \
      (BaseBoardAddress)+(CYY_CLEAR_INTR << IsPci),         \
      0x00                                                  \
      );                                                    \
} while (0);

#define CYY_READ_PCI_TYPE(BaseBoardAddress)                 \
   (READ_REGISTER_UCHAR((BaseBoardAddress)+CYY_PCI_TYPE))

#define PLX9050_READ_INTERRUPT_CONTROL(BaseBoardAddress)       \
   (READ_REGISTER_ULONG((PULONG)((BaseBoardAddress)+PLX9050_INT_OFFSET)))

#define PLX9050_WRITE_INTERRUPT_CONTROL(BaseBoardAddress,Value)   \
do {                                                              \
   WRITE_REGISTER_ULONG(                                          \
      (PULONG)((BaseBoardAddress)+PLX9050_INT_OFFSET),            \
      Value                                                       \
      );                                                          \
} while (0);

#define PLX9060_READ_INTERRUPT_CONTROL(BaseBoardAddress)          \
   (READ_REGISTER_ULONG((PULONG)((BaseBoardAddress)+PLX9060_INT_OFFSET)))

#define PLX9060_WRITE_INTERRUPT_CONTROL(BaseBoardAddress,Value)   \
do {                                                              \
   WRITE_REGISTER_ULONG(                                          \
      (PULONG)((BaseBoardAddress)+PLX9060_INT_OFFSET),            \
      Value                                                       \
      );                                                          \
} while (0);

#endif // ndef CYCOMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyclom-y\enum.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      enum.c
*	
*   Description:    This module contains the enumeration code needed 
*                   to figure out whether or not a device is attached 
*                   to the serial port.  If there is one, it will 
*                   obtain the PNP COM ID (if the device is PNP) and
*                   parse out the relevant fields.
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "pch.h"

#define MAX_DEVNODE_NAME        256 // Total size of Device ID


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESENM, Cyclomy_ReenumerateDevices)

//#pragma alloc_text (PAGE, Cyclomy_GetRegistryKeyValue)
#endif

#if !defined(__isascii)
#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#endif // !defined(__isascii)

NTSTATUS
Cyclomy_ReenumerateDevices(IN PIRP Irp, IN PFDO_DEVICE_DATA FdoData)
/*++

Routine Description:

    This enumerates the cyclom-y bus which is represented by Fdo (a pointer
    to the device object representing the cyclom-y bus). It creates new PDOs
    for any new devices which have been discovered since the last enumeration

Arguments:

    FdoData - Pointer to the fdo's device extension
              for the serial bus which needs to be enumerated
    Irp - Pointer to the Irp which was sent to reenumerate.

Return value:

    NTSTATUS

--*/
{
   PIRP NewIrp;
   NTSTATUS status = STATUS_SUCCESS;
   KEVENT event;
   KTIMER timer;

   IO_STATUS_BLOCK IoStatusBlock;
   UNICODE_STRING pdoUniName;
   UNICODE_STRING instanceStr;
   WCHAR instanceNumberBuffer[20];
   static ULONG currentInstance = 0;
//   PDEVICE_OBJECT pdo = FdoData->AttachedPDO;
   PDEVICE_OBJECT pdo;
   PPDO_DEVICE_DATA pdoData;

   UNICODE_STRING HardwareIDs;
   UNICODE_STRING CompIDs;
   UNICODE_STRING DeviceIDs;
   UNICODE_STRING DevDesc;
   UNICODE_STRING InstanceIDs;

   ULONG i;

   WCHAR pdoName[] = CYY_PDO_NAME_BASE;

   ULONG FdoFlags = FdoData->Self->Flags;

   ULONG numPorts;

   UNREFERENCED_PARAMETER (Irp);

   PAGED_CODE();

   // Cyclom-Y port enumeration

   numPorts = 0;
   for (i=0; i < CYY_MAX_CHIPS; i++) {
      if (FdoData->Cd1400Base[i]){
         numPorts += 4;
      }
   }


//************************************************************************
// HARDCODE NUMBER OF PORTS TO 1

// numPorts = 1;

//************************************************************************


   Cyclomy_KdPrint(FdoData,SER_DBG_CYCLADES,("numPorts detected = %d\n",numPorts));

   if (numPorts < FdoData->NumPDOs) {
      for (i=numPorts; i < CYY_MAX_PORTS; i++) {
         pdo = FdoData->AttachedPDO[i];
         if (pdo != NULL) {
            // Something was there. The device must have been unplugged.
            // Remove the PDO.
            Cyclomy_PDO_EnumMarkMissing(FdoData, pdo->DeviceExtension);
         }
      }
      goto ExitReenumerate;
   }

   if (numPorts == FdoData->NumPDOs) {
      // All ports already enumerated.
      Cyclomy_KdPrint(FdoData,SER_DBG_CYCLADES,("All ports already enumerated\n",numPorts));
      goto ExitReenumerate;
   }


   // New ports that need to be enumerated.

   RtlZeroMemory(&pdoUniName,sizeof(UNICODE_STRING));
   pdoUniName.MaximumLength = DEVICE_OBJECT_NAME_LENGTH * sizeof(WCHAR);
   pdoUniName.Buffer = ExAllocatePool(PagedPool,pdoUniName.MaximumLength
                                    + sizeof(WCHAR));
   if (pdoUniName.Buffer == NULL) {
      Cyclomy_KdPrint(FdoData,SER_DBG_CYCLADES,("Couldn't allocate memory for device name\n"));
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto ExitReenumerate; 
   }


   for (i=FdoData->NumPDOs; numPorts && (i< CYY_MAX_PORTS); i++) {
      
      UCHAR          RawString[MAX_DEVICE_ID_LEN];
      ANSI_STRING    AnsiString;


      RtlZeroMemory(pdoUniName.Buffer,pdoUniName.MaximumLength);
      pdoUniName.Length = 0;
      RtlAppendUnicodeToString(&pdoUniName,pdoName);
      RtlInitUnicodeString(&instanceStr, NULL);
      instanceStr.MaximumLength = sizeof(instanceNumberBuffer);
      instanceStr.Buffer = instanceNumberBuffer;
      RtlIntegerToUnicodeString(currentInstance++, 10, &instanceStr);
      RtlAppendUnicodeStringToString(&pdoUniName, &instanceStr);


      //
      // Allocate a pdo
      //
      status = IoCreateDevice(FdoData->Self->DriverObject,
                              sizeof(PDO_DEVICE_DATA), &pdoUniName,
                              FILE_DEVICE_UNKNOWN,
                              FILE_AUTOGENERATED_DEVICE_NAME, FALSE, &pdo);

      if (!NT_SUCCESS(status)) {
         Cyclomy_KdPrint(FdoData, SER_DBG_SS_ERROR, ("Create device failed\n"));
         ExFreePool(pdoUniName.Buffer);
         goto ExitReenumerate; 
      }

      Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE,
                      ("Created PDO on top of filter: %x\n",pdo));

      pdoData = pdo->DeviceExtension;
         

      RtlInitUnicodeString(&pdoData->HardwareIDs, NULL);
      RtlInitUnicodeString(&pdoData->CompIDs, NULL);
      RtlInitUnicodeString(&pdoData->DeviceIDs, NULL);
      RtlInitUnicodeString(&pdoData->DevDesc, NULL);
      RtlInitUnicodeString(&pdoData->InstanceIDs,NULL);


      // Hardware ID
      sprintf((PCHAR)RawString,"%s%u",CYYPORT_PNP_ID_STR,i+1); // Cyclom-Y\\Port1, etc
      Cyclomy_InitMultiString(FdoData, &pdoData->HardwareIDs, RawString, NULL);
      Cyclomy_KdPrint(FdoData,SER_DBG_CYCLADES,("Hardware Id %ws\n",pdoData->HardwareIDs.Buffer));

      // That's how ..\parclass\pnppdo.c does. (Fanny)
      // Instance ID
      sprintf((PCHAR)RawString,"%02u",i+1);
      RtlInitAnsiString(&AnsiString,(PCHAR)RawString);
      RtlAnsiStringToUnicodeString(&pdoData->InstanceIDs,&AnsiString,TRUE);
      Cyclomy_KdPrint(FdoData,SER_DBG_CYCLADES,("Instance Id %s\n",AnsiString.Buffer));

      // Device ID
      sprintf((PCHAR)RawString,CYYPORT_DEV_ID_STR); 
      RtlInitAnsiString(&AnsiString,(PCHAR)RawString);
      RtlAnsiStringToUnicodeString(&pdoData->DeviceIDs,&AnsiString,TRUE);
      Cyclomy_KdPrint(FdoData,SER_DBG_CYCLADES,("Device Id %s\n",AnsiString.Buffer));

      // Device Description
      sprintf((PCHAR)RawString,"Cyclom-Y Port %2u",i+1);
      RtlInitAnsiString(&AnsiString,(PUCHAR)RawString);
      RtlAnsiStringToUnicodeString(&pdoData->DevDesc,&AnsiString,TRUE);
      Cyclomy_KdPrint(FdoData,SER_DBG_CYCLADES,("Device Description %s\n",AnsiString.Buffer));

      Cyclomy_InitPDO(i, pdo, FdoData);
      
      numPorts--;
   
   }

   ExFreePool(pdoUniName.Buffer);


ExitReenumerate:;

   return status;
}

void
Cyclomy_PDO_EnumMarkMissing(PFDO_DEVICE_DATA FdoData, PPDO_DEVICE_DATA PdoData)
/*++

Routine Description:
    Removes the attached pdo from the fdo's list of children.

    NOTE: THIS FUNCTION CAN ONLY BE CALLED DURING AN ENUMERATION. If called
          outside of enumeration, Cyclom-y might delete it's PDO before PnP has
          been told the PDO is gone.

Arguments:
    FdoData - Pointer to the fdo's device extension
    PdoData - Pointer to the pdo's device extension

Return value:
    none

--*/
{
    ULONG IndexPDO = PdoData->PortIndex;
    Cyclomy_KdPrint (FdoData, SER_DBG_SS_TRACE, ("Removing Pdo %x\n",
                                                 PdoData->Self));
    ASSERT(PdoData->Attached);
    PdoData->Attached = FALSE;
    FdoData->AttachedPDO[IndexPDO] = NULL;
    FdoData->PdoData[IndexPDO] = NULL;
    FdoData->NumPDOs--;
}

NTSTATUS
Cyclomy_GetRegistryKeyValue(IN HANDLE Handle, IN PWCHAR KeyNameString,
                            IN ULONG KeyNameStringLength, IN PVOID Data,
                            IN ULONG DataLength, OUT PULONG ActualLength)
/*++

Routine Description:

    Reads a registry key value from an already opened registry key.

Arguments:

    Handle              Handle to the opened registry key

    KeyNameString       ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString

    Data                Buffer to place the key value in

    DataLength          Length of the data buffer

Return Value:

    STATUS_SUCCESS if all works, otherwise status of system call that
    went wrong.

--*/
{
    UNICODE_STRING              keyName;
    ULONG                       length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    NTSTATUS                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

    RtlInitUnicodeString (&keyName, KeyNameString);

    length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength
      + DataLength;
    fullInfo = ExAllocatePool(PagedPool, length);

    if (ActualLength != NULL) {
       *ActualLength = 0;
    }

    if (fullInfo) {
        ntStatus = ZwQueryValueKey (Handle,
                                  &keyName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

        if (NT_SUCCESS(ntStatus)) {
            //
            // If there is enough room in the data buffer, copy the output
            //

            if (DataLength >= fullInfo->DataLength) {
                RtlCopyMemory(Data, ((PUCHAR)fullInfo) + fullInfo->DataOffset,
                              fullInfo->DataLength);
                if (ActualLength != NULL) {
                   *ActualLength = fullInfo->DataLength;
                }
            }
        }

        ExFreePool(fullInfo);
    }

    if (!NT_SUCCESS(ntStatus) && !NT_ERROR(ntStatus)) {
       if (ntStatus == STATUS_BUFFER_OVERFLOW) {
          ntStatus = STATUS_BUFFER_TOO_SMALL;
       } else {
          ntStatus = STATUS_UNSUCCESSFUL;
       }
    }
    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyclom-y\pch.h ===
#include <ntddk.h>
#include <devioctl.h>
#include <initguid.h>
#include <wdmguid.h>
#include <ntddser.h>
#include <stdarg.h>
#include <stdio.h>
#include "cyyguid.h"
#include "log.h"
#include "cyclom-y.h"
#include "cd1400.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyclom-y\log.h ===
/*--------------------------------------------------------------------------
*
*   Copyright (C) Cyclades Corporation, 1996-2000.
*   All rights reserved.
*
*   Cyclom-Y Enumerator Driver
*	
*   This file:      log.mc
*
*   Description:    Messages that goes to the eventlog.
*
*   Notes:          This code supports Windows 2000 and i386 processor.
*
*   Complies with Cyclades SW Coding Standard rev 1.3.
*
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#ifndef _CYYLOG_
#define _CYYLOG_

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: CYY_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Not enough resources were available for the driver.
//
#define CYY_INSUFFICIENT_RESOURCES       ((NTSTATUS)0xC0041000L)

//
// MessageId: CYY_BOARD_NOT_MAPPED
//
// MessageText:
//
//  The Board Memory could not be translated to something the memory management system could understand.
//
#define CYY_BOARD_NOT_MAPPED             ((NTSTATUS)0xC0041001L)

//
// MessageId: CYY_RUNTIME_NOT_MAPPED
//
// MessageText:
//
//  The Runtime Registers could not be translated to something the memory management system could understand.
//
#define CYY_RUNTIME_NOT_MAPPED           ((NTSTATUS)0xC0041002L)

//
// MessageId: CYY_INVALID_RUNTIME_REGISTERS
//
// MessageText:
//
//  Invalid Runtime Registers base address.
//
#define CYY_INVALID_RUNTIME_REGISTERS    ((NTSTATUS)0xC0041003L)

//
// MessageId: CYY_INVALID_BOARD_MEMORY
//
// MessageText:
//
//  Invalid Board Memory address.
//
#define CYY_INVALID_BOARD_MEMORY         ((NTSTATUS)0xC0041004L)

//
// MessageId: CYY_INVALID_INTERRUPT
//
// MessageText:
//
//  Invalid Interrupt Vector.
//
#define CYY_INVALID_INTERRUPT            ((NTSTATUS)0xC0041005L)

//
// MessageId: CYY_UNKNOWN_BUS
//
// MessageText:
//
//  The bus type is not recognizable.
//
#define CYY_UNKNOWN_BUS                  ((NTSTATUS)0xC0041006L)

//
// MessageId: CYY_BUS_NOT_PRESENT
//
// MessageText:
//
//  The bus type is not available on this computer.
//
#define CYY_BUS_NOT_PRESENT              ((NTSTATUS)0xC0041007L)

//
// MessageId: CYY_GFRCR_FAILURE
//
// MessageText:
//
//  CD1400 not present or failure to read GFRCR register.
//
#define CYY_GFRCR_FAILURE                ((NTSTATUS)0xC0041008L)

//
// MessageId: CYY_CCR_FAILURE
//
// MessageText:
//
//  Failure to read CCR register in the CD1400.
//
#define CYY_CCR_FAILURE                  ((NTSTATUS)0xC0041009L)

//
// MessageId: CYY_BAD_CD1400_REVISION
//
// MessageText:
//
//  Invalid CD1400 revision number.
//
#define CYY_BAD_CD1400_REVISION          ((NTSTATUS)0xC004100AL)

//
// MessageId: CYY_NO_HW_RESOURCES
//
// MessageText:
//
//  No hardware resources available.
//
#define CYY_NO_HW_RESOURCES              ((NTSTATUS)0xC004100BL)

//
// MessageId: CYY_DEVICE_CREATION_FAILURE
//
// MessageText:
//
//  IoCreateDevice failed.
//
#define CYY_DEVICE_CREATION_FAILURE      ((NTSTATUS)0xC004100CL)

//
// MessageId: CYY_REGISTER_INTERFACE_FAILURE
//
// MessageText:
//
//  IoRegisterDeviceInterface failed.
//
#define CYY_REGISTER_INTERFACE_FAILURE   ((NTSTATUS)0xC004100DL)

//
// MessageId: CYY_GET_BUS_TYPE_FAILURE
//
// MessageText:
//
//  IoGetDeviceProperty LegacyBusType failed.
//
#define CYY_GET_BUS_TYPE_FAILURE         ((NTSTATUS)0xC004100EL)

//
// MessageId: CYY_GET_UINUMBER_FAILURE
//
// MessageText:
//
//  IoGetDeviceProperty DevicePropertyUINumber failed.
//
#define CYY_GET_UINUMBER_FAILURE         ((NTSTATUS)0x8004100FL)

//
// MessageId: CYY_SET_INTERFACE_STATE_FAILURE
//
// MessageText:
//
//  IoSetDeviceInterfaceState failed.
//
#define CYY_SET_INTERFACE_STATE_FAILURE  ((NTSTATUS)0xC0041010L)


#endif /* _CYYLOG_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyclom-y\log.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      log.c
*	
*   Description:    This module contains contains the entry points 
*                   for a standard bus PNP / WDM driver.
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/


#include "pch.h"

typedef enum _CYY_MEM_COMPARES {
    AddressesAreEqual,
    AddressesOverlap,
    AddressesAreDisjoint
    } CYY_MEM_COMPARES,*PCYY_MEM_COMPARES;

static const PHYSICAL_ADDRESS CyyPhysicalZero = {0};

CYY_MEM_COMPARES
CyyMemCompare(
                IN PHYSICAL_ADDRESS A,
                IN ULONG SpanOfA,
                IN PHYSICAL_ADDRESS B,
                IN ULONG SpanOfB
                )

/*++

Routine Description:

    Compare two phsical address.

Arguments:

    A - One half of the comparison.

    SpanOfA - In units of bytes, the span of A.

    B - One half of the comparison.

    SpanOfB - In units of bytes, the span of B.


Return Value:

    The result of the comparison.

--*/

{

   LARGE_INTEGER a;
   LARGE_INTEGER b;

   LARGE_INTEGER lower;
   ULONG lowerSpan;
   LARGE_INTEGER higher;

   //PAGED_CODE(); Non paged because it can be called during CyyLogError, which is no paged now.

   a = A;
   b = B;

   if (a.QuadPart == b.QuadPart) {

      return AddressesAreEqual;

   }

   if (a.QuadPart > b.QuadPart) {

      higher = a;
      lower = b;
      lowerSpan = SpanOfB;

   } else {

      higher = b;
      lower = a;
      lowerSpan = SpanOfA;

   }

   if ((higher.QuadPart - lower.QuadPart) >= lowerSpan) {

      return AddressesAreDisjoint;

   }

   return AddressesOverlap;

}


VOID
CyyLogError(
              IN PDRIVER_OBJECT DriverObject,
              IN PDEVICE_OBJECT DeviceObject OPTIONAL,
              IN PHYSICAL_ADDRESS P1,
              IN PHYSICAL_ADDRESS P2,
              IN ULONG SequenceNumber,
              IN UCHAR MajorFunctionCode,
              IN UCHAR RetryCount,
              IN ULONG UniqueErrorValue,
              IN NTSTATUS FinalStatus,
              IN NTSTATUS SpecificIOStatus,
              IN ULONG LengthOfInsert1,
              IN PWCHAR Insert1,
              IN ULONG LengthOfInsert2,
              IN PWCHAR Insert2
              )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject - A pointer to the driver object for the device.

    DeviceObject - A pointer to the device object associated with the
    device that had the error, early in initialization, one may not
    yet exist.

    P1,P2 - If phyical addresses for the controller ports involved
    with the error are available, put them through as dump data.

    SequenceNumber - A ulong value that is unique to an IRP over the
    life of the irp in this driver - 0 generally means an error not
    associated with an irp.

    MajorFunctionCode - If there is an error associated with the irp,
    this is the major function code of that irp.

    RetryCount - The number of times a particular operation has been
    retried.

    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.

    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.

    SpecificIOStatus - The IO status for a particular error.

    LengthOfInsert1 - The length in bytes (including the terminating NULL)
                      of the first insertion string.

    Insert1 - The first insertion string.

    LengthOfInsert2 - The length in bytes (including the terminating NULL)
                      of the second insertion string.  NOTE, there must
                      be a first insertion string for their to be
                      a second insertion string.

    Insert2 - The second insertion string.

Return Value:

    None.

--*/

{
   PIO_ERROR_LOG_PACKET errorLogEntry;

   PVOID objectToUse;
   SHORT dumpToAllocate = 0;
   PUCHAR ptrToFirstInsert;
   PUCHAR ptrToSecondInsert;

   //PAGED_CODE(); It can be called at raised IRQL.

   if (Insert1 == NULL) {
      LengthOfInsert1 = 0;
   }

   if (Insert2 == NULL) {
      LengthOfInsert2 = 0;
   }


   if (ARGUMENT_PRESENT(DeviceObject)) {

      objectToUse = DeviceObject;

   } else {

      objectToUse = DriverObject;

   }

   if (CyyMemCompare(
                       P1,
                       (ULONG)1,
                       CyyPhysicalZero,
                       (ULONG)1
                       ) != AddressesAreEqual) {

      dumpToAllocate = (SHORT)sizeof(PHYSICAL_ADDRESS);

   }

   if (CyyMemCompare(
                       P2,
                       (ULONG)1,
                       CyyPhysicalZero,
                       (ULONG)1
                       ) != AddressesAreEqual) {

      dumpToAllocate += (SHORT)sizeof(PHYSICAL_ADDRESS);

   }

   errorLogEntry = IoAllocateErrorLogEntry(
                                          objectToUse,
                                          (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                                  dumpToAllocate
                                                  + LengthOfInsert1 +
                                                  LengthOfInsert2)
                                          );

   if ( errorLogEntry != NULL ) {

      errorLogEntry->ErrorCode = SpecificIOStatus;
      errorLogEntry->SequenceNumber = SequenceNumber;
      errorLogEntry->MajorFunctionCode = MajorFunctionCode;
      errorLogEntry->RetryCount = RetryCount;
      errorLogEntry->UniqueErrorValue = UniqueErrorValue;
      errorLogEntry->FinalStatus = FinalStatus;
      errorLogEntry->DumpDataSize = dumpToAllocate;

      if (dumpToAllocate) {

         RtlCopyMemory(
                      &errorLogEntry->DumpData[0],
                      &P1,
                      sizeof(PHYSICAL_ADDRESS)
                      );

         if (dumpToAllocate > sizeof(PHYSICAL_ADDRESS)) {

            RtlCopyMemory(
                         ((PUCHAR)&errorLogEntry->DumpData[0])
                         +sizeof(PHYSICAL_ADDRESS),
                         &P2,
                         sizeof(PHYSICAL_ADDRESS)
                         );

            ptrToFirstInsert =
            ((PUCHAR)&errorLogEntry->DumpData[0])+(2*sizeof(PHYSICAL_ADDRESS));

         } else {

            ptrToFirstInsert =
            ((PUCHAR)&errorLogEntry->DumpData[0])+sizeof(PHYSICAL_ADDRESS);


         }

      } else {

         ptrToFirstInsert = (PUCHAR)&errorLogEntry->DumpData[0];

      }

      ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

      if (LengthOfInsert1) {

         errorLogEntry->NumberOfStrings = 1;
         errorLogEntry->StringOffset = (USHORT)(ptrToFirstInsert -
                                                (PUCHAR)errorLogEntry);
         RtlCopyMemory(
                      ptrToFirstInsert,
                      Insert1,
                      LengthOfInsert1
                      );

         if (LengthOfInsert2) {

            errorLogEntry->NumberOfStrings = 2;
            RtlCopyMemory(
                         ptrToSecondInsert,
                         Insert2,
                         LengthOfInsert2
                         );

         }

      }

      IoWriteErrorLogEntry(errorLogEntry);

   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyclom-y\power.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      power.c
*	
*   Description:    This module contains contains the power calls
*                   for the cyclom-y bus driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP, 
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
//#pragma alloc_text (PAGE, Cyclomy_Power)
//#pragma alloc_text (PAGE, Cyclomy_FDO_Power)
//#pragma alloc_text (PAGE, Cyclomy_PDO_Power)
#endif


typedef struct _POWER_COMPLETION_CONTEXT {

    PDEVICE_OBJECT  DeviceObject;
    PIRP            SIrp;

} POWER_COMPLETION_CONTEXT, *PPOWER_COMPLETION_CONTEXT;


VOID
OnPowerRequestComplete(
    PDEVICE_OBJECT DeviceObject,
    UCHAR MinorFunction,
    POWER_STATE state,
    POWER_COMPLETION_CONTEXT* PowerContext,
    PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

   Completion routine for D-IRP.

Arguments:


Return Value:

   NT status code

--*/
{
    PFDO_DEVICE_DATA   fdoData = (PFDO_DEVICE_DATA) PowerContext->DeviceObject->DeviceExtension;
    PIRP        sIrp = PowerContext->SIrp;

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (state);

    Cyclomy_KdPrint(fdoData,SER_DBG_POWER_TRACE, (">OnPowerRequestComplete\n"));

    //
    // Here we copy the D-IRP status into the S-IRP
    //
    sIrp->IoStatus.Status = IoStatus->Status;

    //
    // Release the IRP
    //
    PoStartNextPowerIrp(sIrp);
    IoCompleteRequest(sIrp, IO_NO_INCREMENT);

    //
    // Cleanup
    //
    ExFreePool(PowerContext);
    Cyclomy_DecIoCount(fdoData);

    Cyclomy_KdPrint(fdoData,SER_DBG_POWER_TRACE, ("<OnPowerRequestComplete\n"));

}

NTSTATUS
Cyclomy_FDOSystemPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++
--*/
{
    POWER_COMPLETION_CONTEXT* powerContext;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    PFDO_DEVICE_DATA    data;
    NTSTATUS    status = Irp->IoStatus.Status;

    UNREFERENCED_PARAMETER (Context);

    data = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;

    Cyclomy_KdPrint(data,SER_DBG_POWER_TRACE, (">SystemPowerComplete\n"));

    if (!NT_SUCCESS(status)) {

        PoStartNextPowerIrp(Irp);
        Cyclomy_DecIoCount (data);    
        Cyclomy_KdPrint(data,SER_DBG_POWER_TRACE, ("<SystemPowerComplete1\n"));
        return STATUS_SUCCESS;
    }

    stack = IoGetCurrentIrpStackLocation (Irp);
    powerState = stack->Parameters.Power.State;
                        
    switch (stack->Parameters.Power.State.SystemState) {
    case PowerSystemUnspecified:
        powerState.DeviceState = PowerDeviceUnspecified;
        break;

    case PowerSystemWorking:
        powerState.DeviceState = PowerDeviceD0;
        break;

    case PowerSystemSleeping1:
    case PowerSystemSleeping2:
    case PowerSystemSleeping3:
    case PowerSystemHibernate:
    case PowerSystemShutdown:
    case PowerSystemMaximum:
        powerState.DeviceState = PowerDeviceD3;
        break;

    default:
        powerState.DeviceState = PowerDeviceD3;
    }

    //
    // Send IRP to change device state
    //
    powerContext = (POWER_COMPLETION_CONTEXT*)
                ExAllocatePool(NonPagedPool, sizeof(POWER_COMPLETION_CONTEXT));

    if (!powerContext) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        powerContext->DeviceObject = DeviceObject;
        powerContext->SIrp = Irp;

        status = PoRequestPowerIrp(data->Self, IRP_MN_SET_POWER, powerState, OnPowerRequestComplete, 
                                   powerContext, NULL);
    }

    if (!NT_SUCCESS(status)) {

        Cyclomy_KdPrint(data,SER_DBG_POWER_TRACE, ("PoRequestPowerIrp %x\n",status));
        if (powerContext) {
            ExFreePool(powerContext);
        }

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        //IoCompleteRequest(Irp, IO_NO_INCREMENT); Toaster has this line.
        Cyclomy_DecIoCount(data);
        Cyclomy_KdPrint(data,SER_DBG_POWER_TRACE, ("<2SystemPowerComplete\n"));
        return status;
    }

    Cyclomy_KdPrint(data,SER_DBG_POWER_TRACE, ("<3SystemPowerComplete\n"));
    return STATUS_MORE_PROCESSING_REQUIRED;

}

NTSTATUS
Cyclomy_FDOPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++
--*/
{
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    PFDO_DEVICE_DATA    data;
//    NTSTATUS            status = STATUS_SUCCESS;    Removed in build 2072

    UNREFERENCED_PARAMETER (Context);

#if 0
    if (Irp->PendingReturned) {  
        IoMarkIrpPending(Irp);
    }
#endif

    data = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    Cyclomy_KdPrint(data,SER_DBG_POWER_TRACE, (">DevicePowerComplete\n"));

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        switch (powerType) {
        case DevicePowerState:
            //
            // Powering Up
            // 
            ASSERT (powerState.DeviceState < data->DeviceState);

            Cyclomy_DoesBoardExist(data); // To initialize CD1400
            
            Cyclomy_EnableInterruptInPLX(data); // Enable interrupt in the PLX

            data->DeviceState = powerState.DeviceState;

            PoSetPowerState (data->Self, powerType, powerState);

            break;

        default:
           break;
        }
        break;

    case IRP_MN_QUERY_POWER:

        ASSERT (IRP_MN_QUERY_POWER != stack->MinorFunction);
        break;

    default:
        //
        // Basically, this is ASSERT(0)
        //
        ASSERT (0xBADBAD == IRP_MN_QUERY_POWER);
        break;
    }


    PoStartNextPowerIrp (Irp);
    Cyclomy_DecIoCount (data);

    Cyclomy_KdPrint(data,SER_DBG_POWER_TRACE, ("<DevicePowerComplete\n"));
    //return status; Changed to below line in build 2072
    return STATUS_SUCCESS; // Continue completion...
}

NTSTATUS
Cyclomy_FDO_Power (
    PFDO_DEVICE_DATA    Data,
    PIRP                Irp
    )
/*++
--*/
{
    NTSTATUS            status;
    BOOLEAN             hookit = FALSE;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    // ADDED FANNY
    ULONG               indexPDO;

    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    status = Cyclomy_IncIoCount (Data);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        PoStartNextPowerIrp (Irp);
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        //
        // If it hasn't started, we just pass it through
        //

        //if (Data->Started != TRUE) {    // Added in DDK final version
        //    status = Irp->IoStatus.Status = STATUS_SUCCESS;
        //    break;
        //}
        if (Data->DevicePnPState != Started) {   // Toaster Bus compares to == NotStarted
            status = Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }

        Cyclomy_KdPrint(Data,
                     SER_DBG_PNP_TRACE,
                     ("Cyclomy-PnP Setting %s state to %d\n",
                      ((powerType == SystemPowerState) ?  "System" : "Device"),
                      powerState.SystemState));

        switch (powerType) {
        case DevicePowerState:

            Cyclomy_KdPrint(Data,SER_DBG_POWER_TRACE, ("SET_POWER Device %x\n",Irp));

            status = Irp->IoStatus.Status = STATUS_SUCCESS;

            if (Data->DeviceState < powerState.DeviceState) {
                //
                // Powering down
                //
                PoSetPowerState (Data->Self, powerType, powerState);
                Data->DeviceState = powerState.DeviceState;
            } else if (Data->DeviceState > powerState.DeviceState) {
                //
                // Powering Up
                //
                hookit = TRUE;
            }
            
            break;

        case SystemPowerState: 

            Cyclomy_KdPrint(Data,SER_DBG_POWER_TRACE, ("SET_POWER System %x\n",Irp));

            IoMarkIrpPending(Irp);
            IoCopyCurrentIrpStackLocationToNext(Irp);

            status = Cyclomy_IncIoCount (Data);
            ASSERT (STATUS_SUCCESS == status);
            IoSetCompletionRoutine (Irp,
                                    Cyclomy_FDOSystemPowerComplete,
                                    NULL,
                                    TRUE,
                                    TRUE,
                                    TRUE);

            PoCallDriver (Data->TopOfStack, Irp);
            Cyclomy_DecIoCount (Data);

            return STATUS_PENDING;
               
        }
        break;

    case IRP_MN_QUERY_POWER:
        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    default:
        //
        // status should be STATUS_SUCCESS
        //
        break;
    }
    
    if (hookit) {
        IoMarkIrpPending(Irp);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        status = Cyclomy_IncIoCount (Data);
        ASSERT (STATUS_SUCCESS == status);
        IoSetCompletionRoutine (Irp,
                                Cyclomy_FDOPowerComplete,
                                NULL,
                                TRUE,
                                TRUE,
                                TRUE);

        PoCallDriver (Data->TopOfStack, Irp);
        Cyclomy_KdPrint(Data,SER_DBG_POWER_TRACE, ("SET_POWER Device status %x\n",status));
        Cyclomy_DecIoCount (Data);
        return STATUS_PENDING;

    }
    
    PoStartNextPowerIrp (Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    status =  PoCallDriver (Data->TopOfStack, Irp);    
    Cyclomy_DecIoCount (Data);
    return status;

}

NTSTATUS
Cyclomy_PDO_Power (
    PPDO_DEVICE_DATA    PdoData,
    PIRP                Irp
    )
/*++
--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  stack;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        switch (powerType) {
        case DevicePowerState:
            if (PdoData->DeviceState > powerState.DeviceState) {
                //DbgPrint("Up\n");
                PoSetPowerState (PdoData->Self, powerType, powerState);
                PdoData->DeviceState = powerState.DeviceState;
            } else if (PdoData->DeviceState < powerState.DeviceState) {
                //
                // Powering down.
                //
                //DbgPrint("Down\n");
                PoSetPowerState (PdoData->Self, powerType, powerState);
                PdoData->DeviceState = powerState.DeviceState;
            }
            break;

        case SystemPowerState:
            //
            // Default to STATUS_SUCCESS
            //
            break;

        default:
            status = STATUS_NOT_IMPLEMENTED;
            break;
        }
        break;

    case IRP_MN_QUERY_POWER:
        //
        // Default to STATUS_SUCCESS
        //
        break;

    case IRP_MN_WAIT_WAKE:
    case IRP_MN_POWER_SEQUENCE:
        status = STATUS_NOT_IMPLEMENTED;
        break;

    default:
       status = Irp->IoStatus.Status;
    }

    Irp->IoStatus.Status = status;
    PoStartNextPowerIrp (Irp);
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
Cyclomy_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    PCOMMON_DEVICE_DATA commonData;

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_POWER == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    if (commonData->IsFDO) {
        status = 
            Cyclomy_FDO_Power ((PFDO_DEVICE_DATA) DeviceObject->DeviceExtension,
                Irp);
    } else {
        status = 
            Cyclomy_PDO_Power ((PPDO_DEVICE_DATA) DeviceObject->DeviceExtension,
                Irp);
    }

    return status;
}     


NTSTATUS
Cyclomy_GotoPowerState(IN PDEVICE_OBJECT PDevObj,
                   IN PFDO_DEVICE_DATA PDevExt,
                   IN DEVICE_POWER_STATE DevPowerState)
/*++

Routine Description:

    This routine causes the driver to request the stack go to a particular
    power state.

Arguments:

    PDevObj - Pointer to the device object for this device

    PDevExt - Pointer to the device extension we are working from

    DevPowerState - the power state we wish to go to

Return Value:

    The function value is the final status of the call


--*/
{
   KEVENT gotoPowEvent;
   NTSTATUS status;
   POWER_STATE powerState;

   UNREFERENCED_PARAMETER (PDevExt);   

   PAGED_CODE();

   Cyclomy_KdPrint(PDevExt,SER_DBG_CYCLADES, ("In Cyclomy_GotoPowerState\n"));

   powerState.DeviceState = DevPowerState;

   KeInitializeEvent(&gotoPowEvent, SynchronizationEvent, FALSE);

   status = PoRequestPowerIrp(PDevObj, IRP_MN_SET_POWER, powerState,
                              Cyclomy_SystemPowerCompletion, &gotoPowEvent,
                              NULL);

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject(&gotoPowEvent, Executive, KernelMode, FALSE, NULL);
      status = STATUS_SUCCESS;
   }

#if DBG
   if (!NT_SUCCESS(status)) {
      Cyclomy_KdPrint(PDevExt,SER_DBG_CYCLADES, ("Cyclomy_GotoPowerState FAILED\n"));
   }
#endif

   Cyclomy_KdPrint(PDevExt,SER_DBG_CYCLADES, ("Leaving Cyclomy_GotoPowerState\n"));

   return status;
}



NTSTATUS
Cyclomy_SystemPowerCompletion(IN PDEVICE_OBJECT PDevObj, UCHAR MinorFunction,
                              IN POWER_STATE PowerState, IN PVOID Context,
                              PIO_STATUS_BLOCK IoStatus)
/*++

Routine Description:

    This routine is the completion routine for PoRequestPowerIrp calls
    in this module.

Arguments:

    PDevObj - Pointer to the device object the irp is completing for

    MinorFunction - IRP_MN_XXXX value requested

    PowerState - Power state request was made of

    Context - Event to set or NULL if no setting required

    IoStatus - Status block from request

Return Value:

    VOID


--*/
{

   UNREFERENCED_PARAMETER (PDevObj);   
   UNREFERENCED_PARAMETER (MinorFunction);
   UNREFERENCED_PARAMETER (PowerState);
   UNREFERENCED_PARAMETER (IoStatus);
   
   if (Context != NULL) {
      KeSetEvent((PKEVENT)Context, IO_NO_INCREMENT, 0);
   }

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyycoins\cyfriend.h ===
/** FILE: cyfriend.h ********* Module Header ********************************
 *
 *
 * History:
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/
//==========================================================================
//                            Include Files
//==========================================================================

#ifndef CYFRIEND_H
#define CYFRIEND_H


//==========================================================================
//                            Function Prototypes
//==========================================================================

//
//  cyfriend.c
//
extern
BOOL
ReplaceFriendlyName(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PTCHAR           NewComName
);



#endif // CYFRIEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyclom-y\pnp.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      pnp.c
*	
*   Description:    This module contains contains the plugplay calls
*                   PNP / WDM BUS driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "pch.h"

static const PHYSICAL_ADDRESS CyyPhysicalZero = {0};

// FANNY_ADDPAGABLE_LATER
//#ifdef ALLOC_PRAGMA
//#pragma alloc_text (PAGE, Cyclomy_AddDevice)
//#pragma alloc_text (PAGE, Cyclomy_PnP)
//#pragma alloc_text (PAGE, Cyclomy_FDO_PnP)
//#pragma alloc_text (PAGE, Cyclomy_PDO_PnP)
//#pragma alloc_text (PAGE, Cyclomy_PnPRemove)
//#pragma alloc_text (PAGE, Cyclomy_StartDevice)
////#pragma alloc_text (PAGE, Cyclomy_Remove)
//#endif


NTSTATUS
Cyclomy_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusPhysicalDeviceObject
    )
/*++
Routine Description.
    A bus has been found.  Attach our FDO to it.
    Allocate any required resources.  Set things up.  And be prepared for the
    first ``start device.''

Arguments:
    DriverObject - This very self referenced driver.

    BusPhysicalDeviceObject - Device object representing the bus.  That to which
        we attach a new FDO.

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PFDO_DEVICE_DATA    DeviceData;
    ULONG               nameLength;
    ULONG               i;
    INTERFACE_TYPE      interfaceType;
    ULONG               interfaceTypeLength;
    ULONG               uiNumber,uiNumberLength;
    
    PAGED_CODE ();

    Cyclomy_KdPrint_Def (SER_DBG_PNP_TRACE, ("Add Device: 0x%x\n",
                                              BusPhysicalDeviceObject));
    //
    // Create our FDO
    //

    status = IoCreateDevice(DriverObject, sizeof(FDO_DEVICE_DATA), NULL,
                           FILE_DEVICE_BUS_EXTENDER, 0, TRUE, &deviceObject);

    if (NT_SUCCESS (status)) {
        DeviceData = (PFDO_DEVICE_DATA) deviceObject->DeviceExtension;
        RtlFillMemory (DeviceData, sizeof (FDO_DEVICE_DATA), 0);

        DeviceData->IsFDO = TRUE;
        DeviceData->DebugLevel = SER_DEFAULT_DEBUG_OUTPUT_LEVEL;
        DeviceData->Self = deviceObject;
        DeviceData->DriverObject = DriverObject;
        for (i=0; i<CYY_MAX_PORTS; i++) {
           DeviceData->AttachedPDO[i] = NULL;
        }
        DeviceData->NumPDOs = 0;

        DeviceData->DeviceState = PowerDeviceD0;
        DeviceData->SystemState = PowerSystemWorking; // FANNY: This seems to be not needed

        DeviceData->SystemWake=PowerSystemUnspecified;
        DeviceData->DeviceWake=PowerDeviceUnspecified;

        INITIALIZE_PNP_STATE(DeviceData);

        // Set the PDO for use with PlugPlay functions
        DeviceData->UnderlyingPDO = BusPhysicalDeviceObject;


        //
        // Attach our filter driver to the device stack.
        // the return value of IoAttachDeviceToDeviceStack is the top of the
        // attachment chain.  This is where all the IRPs should be routed.
        //
        // Our filter will send IRPs to the top of the stack and use the PDO
        // for all PlugPlay functions.
        //
        DeviceData->TopOfStack 
            = IoAttachDeviceToDeviceStack(deviceObject, BusPhysicalDeviceObject);

        deviceObject->Flags |= DO_BUFFERED_IO;

        // Bias outstanding request to 1 so that we can look for a
        // transition to zero when processing the remove device PlugPlay IRP.
        DeviceData->OutstandingIO = 1;

        KeInitializeEvent(&DeviceData->RemoveEvent, SynchronizationEvent,
                        FALSE);

        //
        // Tell the PlugPlay system that this device will need an interface
        // device class shingle.
        //
        // It may be that the driver cannot hang the shingle until it starts
        // the device itself, so that it can query some of its properties.
        // (Aka the shingles guid (or ref string) is based on the properties
        // of the device.)
        //
        status = IoRegisterDeviceInterface (BusPhysicalDeviceObject,
                                            (LPGUID) &GUID_CYCLOMY_BUS_ENUMERATOR,
                                            NULL,
                                            &DeviceData->DevClassAssocName);

        if (!NT_SUCCESS (status)) {
            CyyLogError(DriverObject, NULL, CyyPhysicalZero, CyyPhysicalZero,
                        0, 0, 0, 0, status, CYY_REGISTER_INTERFACE_FAILURE,
                        0, NULL, 0, NULL);
            Cyclomy_KdPrint_Def (SER_DBG_PNP_ERROR,
                                ("AddDevice: IoRegisterDCA failed (%x)", status));
            goto CyclomyAddDevice_Error;
        }

        //
        // If for any reason you need to save values in a safe location that
        // clients of this DeviceClassAssociate might be interested in reading
        // here is the time to do so, with the function
        // IoOpenDeviceClassRegistryKey
        // the symbolic link name used is was returned in
        // DeviceData->DevClassAssocName (the same name which is returned by
        // IoGetDeviceClassAssociations and the SetupAPI equivs.
        //

#if DBG
      {
         PWCHAR deviceName = NULL;

         status = IoGetDeviceProperty (BusPhysicalDeviceObject,
                                       DevicePropertyPhysicalDeviceObjectName,0,
                                       NULL,&nameLength);

         if ((nameLength != 0) && (status == STATUS_BUFFER_TOO_SMALL)) {
            deviceName = ExAllocatePool (NonPagedPool, nameLength);

            if (NULL == deviceName) {
               goto someDebugStuffExit;
            }

            IoGetDeviceProperty (BusPhysicalDeviceObject,
                                 DevicePropertyPhysicalDeviceObjectName,
                                 nameLength, deviceName, &nameLength);

            Cyclomy_KdPrint_Def (SER_DBG_PNP_TRACE,
                                 ("AddDevice: %x to %x->%x (%ws) \n",
                                 deviceObject, DeviceData->TopOfStack,
                                 BusPhysicalDeviceObject, deviceName));
         }

someDebugStuffExit:;
         if (deviceName != NULL) {
            ExFreePool(deviceName);
         }
      }
#endif

        status = IoGetDeviceProperty (BusPhysicalDeviceObject,
                                      DevicePropertyLegacyBusType,
                                      sizeof(interfaceType),
                                      &interfaceType,
                                      &interfaceTypeLength);

        if (!NT_SUCCESS (status)) {
			if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
				interfaceType = Isa;
			} else {
                CyyLogError(DriverObject, NULL, CyyPhysicalZero, CyyPhysicalZero,
                        0, 0, 0, 0, status, CYY_GET_BUS_TYPE_FAILURE,
                        0, NULL, 0, NULL);
                Cyclomy_KdPrint_Def ( SER_DBG_PNP_ERROR,
                                      ("AddDevice: IoGetDeviceProperty LegacyBusType failed (%x)", 
                                      status));
                goto CyclomyAddDevice_Error;
            }
        }
        if (interfaceType == PCIBus) {
            DeviceData->IsPci = 1;

            status = IoGetDeviceProperty (BusPhysicalDeviceObject,
                                          DevicePropertyUINumber ,
                                          sizeof(uiNumber),
                                          &uiNumber,
                                          &uiNumberLength);

            if (!NT_SUCCESS (status)) {

                uiNumber = 0xFFFFFFFF;
                Cyclomy_KdPrint_Def (SER_DBG_PNP_ERROR,
                                     ("AddDevice: IoGetDeviceProperty DevicePropertyUINumber failed (%x)", 
                                     status));
            }
        } else {
            // ISA board
            uiNumber = 0xFFFFFFFF; // What does DevicePropertyUINumber return for ISA board?
        }
        DeviceData->UINumber = uiNumber;

        //
        // Turn on the shingle and point it to the given device object.
        //
        status = IoSetDeviceInterfaceState (
                        &DeviceData->DevClassAssocName,
                        TRUE);

        if (!NT_SUCCESS (status)) {
            CyyLogError(DriverObject, NULL, CyyPhysicalZero, CyyPhysicalZero,
                        0, 0, 0, 0, status, CYY_SET_INTERFACE_STATE_FAILURE,
                        0, NULL, 0, NULL);
            Cyclomy_KdPrint_Def (SER_DBG_PNP_ERROR,
                                ("AddDevice: IoSetDeviceClass failed (%x)", status));
            //return status;
            goto CyclomyAddDevice_Error;
        }

        deviceObject->Flags |= DO_POWER_PAGABLE;
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    } else {
      CyyLogError(DriverObject, NULL, CyyPhysicalZero, CyyPhysicalZero,
                  0, 0, 0, 0, status, CYY_DEVICE_CREATION_FAILURE,
                  0, NULL, 0, NULL);
    }

    return status;


CyclomyAddDevice_Error:

    if (DeviceData->DevClassAssocName.Buffer) {
       RtlFreeUnicodeString(&DeviceData->DevClassAssocName);
    }

    if (DeviceData->TopOfStack) {
       IoDetachDevice (DeviceData->TopOfStack);
    }
    if (deviceObject) {
       IoDeleteDevice (deviceObject);
    }
 
    return status;
}

NTSTATUS
Cyclomy_PnP (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++
Routine Description:
    Answer the plethora of Irp Major PnP IRPS.
--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    PCOMMON_DEVICE_DATA     commonData;
    KIRQL                   oldIrq;
#if DBG
    UCHAR                   MinorFunction;
#endif

    PAGED_CODE ();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (irpStack->MajorFunction == IRP_MJ_PNP);
#if DBG
    MinorFunction = irpStack->MinorFunction;
#endif

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    //
    // If removed, fail the request and get out
    //

    if (commonData->DevicePnPState == Deleted) {   // if (commonData->Removed) added in build 2072.

        Cyclomy_KdPrint(commonData, SER_DBG_PNP_TRACE,
                        ("PNP: removed DO: %x got IRP: %x\n", DeviceObject, 
                         Irp));

        Irp->IoStatus.Status = status = STATUS_NO_SUCH_DEVICE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        goto PnPDone;
    }

    //
    // Call either the FDO or PDO Pnp code
    //

    if (commonData->IsFDO) {
        Cyclomy_KdPrint(commonData, SER_DBG_PNP_TRACE,
                        ("FDO(%x):%s IRP:%x\n", DeviceObject, 
                        PnPMinorFunctionString(irpStack->MinorFunction),Irp));

        status = Cyclomy_FDO_PnP(DeviceObject, Irp, irpStack,
                    (PFDO_DEVICE_DATA) commonData);
        goto PnPDone;

    }

    //
    // PDO
    //

    Cyclomy_KdPrint(commonData, SER_DBG_PNP_TRACE,
                    ("PDO(%x):%s IRP:%x\n", DeviceObject, 
                    PnPMinorFunctionString(irpStack->MinorFunction),Irp));

    status = Cyclomy_PDO_PnP(DeviceObject, Irp, irpStack,
                             (PPDO_DEVICE_DATA) commonData);

PnPDone:;
    return status;
}

NTSTATUS
Cyclomy_FDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the BUS itself

    NB: the various Minor functions of the PlugPlay system will not be
    overlapped and do not have to be reentrant

--*/
{
    NTSTATUS    status;
    KIRQL       oldIrq;
    KEVENT      event;
    ULONG       length;
    ULONG       i;
    PLIST_ENTRY entry;
    PPDO_DEVICE_DATA    pdoData;
    PDEVICE_RELATIONS   relations;
    PIO_STACK_LOCATION  stack;
    PRTL_QUERY_REGISTRY_TABLE QueryTable = NULL;
    ULONG DebugLevelDefault = SER_DEFAULT_DEBUG_OUTPUT_LEVEL;
    HANDLE      instanceKey;
    UNICODE_STRING  keyName;
    ULONG       numOfPorts;
       
    PAGED_CODE ();

    status = Cyclomy_IncIoCount (DeviceData);
    if (!NT_SUCCESS (status)) {
        //Irp->IoStatus.Information = 0; Removed in build 2072
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    stack = IoGetCurrentIrpStackLocation (Irp);

    switch (IrpStack->MinorFunction) {

       case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: {

         PIO_RESOURCE_REQUIREMENTS_LIST pReqList;
         PIO_RESOURCE_LIST pResList;
         PIO_RESOURCE_DESCRIPTOR pResDesc;
         ULONG i, j;
         ULONG reqCnt;
         ULONG gotPLX;
         ULONG gotMemory;
         ULONG gotInt;
         ULONG listNum;


         // FANNY: The serial driver had it as SynchronizationEvent.
         KeInitializeEvent(&event, NotificationEvent, FALSE);

         IoCopyCurrentIrpStackLocationToNext(Irp);
         IoSetCompletionRoutine(Irp, 
                                CyclomySyncCompletion, 
                                &event,
                                TRUE, 
                                TRUE, 
                                TRUE);

         status = IoCallDriver(DeviceData->TopOfStack, Irp);

         if (status == STATUS_PENDING) {
            KeWaitForSingleObject (&event, Executive, KernelMode, FALSE,
                                   NULL);
         }

         if (Irp->IoStatus.Information == 0) {
            if (stack->Parameters.FilterResourceRequirements
                .IoResourceRequirementList == 0) {
               Cyclomy_KdPrint(DeviceData, SER_DBG_CYCLADES, ("Can't filter NULL resources!"
                                                       "\n"));
               status = Irp->IoStatus.Status;
               IoCompleteRequest (Irp, IO_NO_INCREMENT);
               Cyclomy_DecIoCount (DeviceData);
               return status;
            }

            Irp->IoStatus.Information = (ULONG_PTR)stack->Parameters
                                        .FilterResourceRequirements
                                        .IoResourceRequirementList;

         }


         //
         // Force ISR ports in IO_RES_REQ_LIST to shared status
         // Force interrupts to shared status
         //

         //
         // We will only process the first list -- multiport boards
         // should not have alternative resources
         //

         pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information;
         pResList = &pReqList->List[0];

         Cyclomy_KdPrint(DeviceData, SER_DBG_CYCLADES, ("------- List has %x lists "
                                                        "(including alternatives)\n",
                                                        pReqList->AlternativeLists));

         for (listNum = 0; listNum < (pReqList->AlternativeLists);
              listNum++) {
            gotPLX = 0;
            gotMemory = 0;
            gotInt = 0;

            Cyclomy_KdPrint(DeviceData, SER_DBG_CYCLADES, ("------- List has %x resources in it\n",
                                                           pResList->Count));

            for (j = 0; (j < pResList->Count); j++) {
               pResDesc = &pResList->Descriptors[j];

               switch (pResDesc->Type) {
               case CmResourceTypeMemory:
                  if (pResDesc->u.Memory.Length == CYY_RUNTIME_LENGTH) {
                      gotPLX = 1;
                      //wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
                      //pResDesc->ShareDisposition = CmResourceShareShared; 
                      //wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
                      //TODO FANNY: Which should be the ShareDisposition for Y?
                      //pResDesc->ShareDisposition = CmResourceShareDriverExclusive; 
                      //Cyclomy_KdPrint(DeviceData,SER_DBG_CYCLADES,("------- Sharing PLX Memory for "
                      //                               "device %x\n", DeviceData->TopOfStack));

                  } else {
                      gotMemory = 1;
                      //wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
                      //pResDesc->ShareDisposition = CmResourceShareShared; 
                      //wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
                      //TODO FANNY: Which should be the ShareDisposition for Y?
                      //pResDesc->ShareDisposition = CmResourceShareDriverExclusive; 
                      //Cyclomy_KdPrint(DeviceData,SER_DBG_CYCLADES,("------- Sharing Board Memory for "
                      //                               "device %x\n", DeviceData->TopOfStack));
                  }
                  break;

               case CmResourceTypePort:
                  Cyclomy_KdPrint(DeviceData,SER_DBG_CYCLADES,
                                         ("------- We should not have Port resource\n"));
                  break;

               case CmResourceTypeInterrupt:
                  gotInt = 1;
                  if (DeviceData->IsPci) {
                      pResDesc->ShareDisposition = CmResourceShareShared;
                  } 
                  Cyclomy_KdPrint(DeviceData,SER_DBG_CYCLADES,("------- Sharing interrupt for "
                                                 "device %x\n", DeviceData->TopOfStack));
                  break;

               default:
                  break;
               }

               //
               // If we found what we need, we can break out of the loop
               //

               // FANNY: STRANGE, THERE ARE TWICE FOR EACH TYPE. IT SEEMS THAT 
               // BOTH RAW AND TRANSLATED ARE LISTED.
               // (gotPLX && gotMemory && gotInt) 
               // break;
               //
            }

            pResList = (PIO_RESOURCE_LIST)((PUCHAR)pResList
                                           + sizeof(IO_RESOURCE_LIST)
                                           + sizeof(IO_RESOURCE_DESCRIPTOR)
                                           * (pResList->Count - 1));
         }

         status = STATUS_SUCCESS;
		 break;
    }

    case IRP_MN_START_DEVICE:
        //
        // BEFORE you are allowed to ``touch'' the device object to which
        // the FDO is attached (that send an irp from the bus to the Device
        // object to which the bus is attached).   You must first pass down
        // the start IRP.  It might not be powered on, or able to access or
        // something.
        //


        // FANNY_TODO
        // SHOULD I CALL MmLockPagableCodeSection as the serial driver?


//        if (DeviceData->Started) {
//            Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
//                ("Device already started\n"));
//            status = STATUS_SUCCESS;
//            break;
//        }

        KeInitializeEvent (&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine (Irp,
                                CyclomySyncCompletion,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            // wait for it...

            status = KeWaitForSingleObject (&event,
                                            Executive,
                                            KernelMode,
                                            FALSE, // Not allertable
                                            NULL); // No timeout structure

            ASSERT (STATUS_SUCCESS == status);

            status = Irp->IoStatus.Status;
        }

        if (NT_SUCCESS(status)) {

            //
            // Get the debug level from the registry
            //

            if (NULL == (QueryTable = ExAllocatePool(
                                        PagedPool,
                                        sizeof(RTL_QUERY_REGISTRY_TABLE)*2
                                        ))) {
                Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_ERROR,
                                ("Failed to allocate memory to query registy\n"));
                DeviceData->DebugLevel = DebugLevelDefault;
            } else {
                RtlZeroMemory(
                           QueryTable,
                           sizeof(RTL_QUERY_REGISTRY_TABLE)*2
                           );

                QueryTable[0].QueryRoutine = NULL;
                QueryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
                QueryTable[0].EntryContext = &DeviceData->DebugLevel;
                QueryTable[0].Name      = L"DebugLevel";
                QueryTable[0].DefaultType   = REG_DWORD;
                QueryTable[0].DefaultData   = &DebugLevelDefault;
                QueryTable[0].DefaultLength= sizeof(ULONG);

                // CIMEXCIMEX: The rest of the table isn't filled in!  Comment changed bld 2128

                if (!NT_SUCCESS(RtlQueryRegistryValues(
                    RTL_REGISTRY_SERVICES,
                    L"cyclom-y",
                    QueryTable,
                    NULL,
                    NULL))) {
                    Cyclomy_KdPrint (DeviceData,SER_DBG_PNP_ERROR,
                        ("Failed to get debug level from registry.  "
                         "Using default\n"));
                    DeviceData->DebugLevel = DebugLevelDefault;
                }

                ExFreePool( QueryTable );
            }

            status = Cyclomy_GetResourceInfo(DeviceObject,
                        IrpStack->Parameters.StartDevice.AllocatedResources,
                        IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated);

            if (NT_SUCCESS(status)) {

                ULONG numberOfResources = CYY_NUMBER_OF_RESOURCES;
                if (!DeviceData->IsPci) {
                    numberOfResources--;
                }
                status = Cyclomy_BuildResourceList(&DeviceData->PChildResourceList,
                                    &DeviceData->PChildResourceListSize,
                                    IrpStack->Parameters.StartDevice.AllocatedResources,
                                    numberOfResources);

                if (!NT_SUCCESS(status)) {
                    goto CaseSTART_end;
                }

                status = Cyclomy_BuildResourceList(&DeviceData->PChildResourceListTr,
                                    &DeviceData->PChildResourceListSizeTr,
                                    IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated,
                                    numberOfResources);

                if (!NT_SUCCESS(status)) {
                    goto CaseSTART_end;
                }
              
                status = Cyclomy_BuildRequirementsList(&DeviceData->PChildRequiredList,
                                    IrpStack->Parameters.StartDevice.AllocatedResources,
                                    numberOfResources);

                if (!NT_SUCCESS(status)) {
                    goto CaseSTART_end;
                }

                //
                // See if we are in the proper power state.
                //

                if (DeviceData->DeviceState != PowerDeviceD0) {

                    status = Cyclomy_GotoPowerState(DeviceData->UnderlyingPDO, DeviceData, 
                                              PowerDeviceD0);

                    if (!NT_SUCCESS(status)) {
                        goto CaseSTART_end;
                    }
                }

                numOfPorts=Cyclomy_DoesBoardExist(DeviceData);
                if (!numOfPorts){
                    Cyclomy_KdPrint_Def(SER_DBG_CYCLADES,("Does Port exist test failed\n"));
                    status = STATUS_SERIAL_NO_DEVICE_INITED;
                    goto CaseSTART_end;
                }
                Cyclomy_KdPrint(DeviceData,SER_DBG_CYCLADES,("Board found!\n"));

                Cyclomy_EnableInterruptInPLX(DeviceData); // Enable interrupt in the PLX

                // Save number of ports to the Registry, so that Property Page
                // code can retrieve it.
    
                IoOpenDeviceRegistryKey(DeviceData->UnderlyingPDO,PLUGPLAY_REGKEY_DEVICE,
                    STANDARD_RIGHTS_WRITE,&instanceKey);

                RtlInitUnicodeString(&keyName,L"NumOfPorts");
                ZwSetValueKey(instanceKey,&keyName,0,REG_DWORD,&numOfPorts,sizeof(ULONG));

                ZwFlushKey(instanceKey);
                ZwClose(instanceKey);

                Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
                                ("Start Device: Device started successfully\n"));
                SET_NEW_PNP_STATE(DeviceData, Started);

                // TODO: FOR NOW, LET'S KEEP THIS DEVICE IN POWER D0. 
                // THE SERIAL DRIVER SEEMS TO POWER DOWN TO D3, AND BECOME D0 DURING OPEN.
                // BUT NOT SURE IF THE BOARD NEED TO BE IN D0 WHILE THE CHILD DEVICES
                // ARE ENUMARATED.

            }                                
        }

CaseSTART_end:
        if (!NT_SUCCESS(status)) {
            Cyclomy_ReleaseResources(DeviceData);
        }
        
        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //

        //Irp->IoStatus.Information = 0;  Removed in build 2072
        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        //
        // Test to see if there are any PDO created as children of this FDO
        // If there are then conclude the device is busy and fail the
        // query stop.
        //
        // CIMEXCIMEX   (BUGBUG replaced by CIMEXCIMEX on build 2128 - Fanny)
        // We could do better, by seing if the children PDOs are actually
        // currently open.  If they are not then we could stop, get new
        // resouces, fill in the new resouce values, and then when a new client
        // opens the PDO use the new resources.  But this works for now.
        //
//TODO FANNY: FOR NOW WE WILL ALWAYS ACCEPT TO STOP DEVICE. REVIEW THIS LATER...
//        if (DeviceData->AttachedPDO) {
//            status = STATUS_UNSUCCESSFUL;
//        } else {
//            status = STATUS_SUCCESS;
//        }

        status = STATUS_SUCCESS;

        Irp->IoStatus.Status = status;

        if (NT_SUCCESS(status)) {
           SET_NEW_PNP_STATE(DeviceData, StopPending);
           IoSkipCurrentIrpStackLocation (Irp);
           status = IoCallDriver (DeviceData->TopOfStack, Irp);
        } else {
           IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

        Cyclomy_DecIoCount (DeviceData);
        return status;

    case IRP_MN_CANCEL_STOP_DEVICE:

        KeInitializeEvent (&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine (Irp,
                                CyclomySyncCompletion,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            // wait for it...

            status = KeWaitForSingleObject (&event,
                                            Executive,
                                            KernelMode,
                                            FALSE, // Not allertable
                                            NULL); // No timeout structure

            ASSERT (STATUS_SUCCESS == status);

            status = Irp->IoStatus.Status;
        }

        if(StopPending == DeviceData->DevicePnPState)
        {
            //
            // We did receive a query-stop, so restore.
            //             
            RESTORE_PREVIOUS_PNP_STATE(DeviceData);
            ASSERT(DeviceData->DevicePnPState == Started);
        }        

        break;

    case IRP_MN_STOP_DEVICE:

        //
        // After the start IRP has been sent to the lower driver object, the
        // bus may NOT send any more IRPS down ``touch'' until another START
        // has occured.
        // What ever access is required must be done before the Irp is passed
        // on.
        //
        // Stop device means that the resources given durring Start device
        // are no revoked.  So we need to stop using them
        //
        Cyclomy_ReleaseResources(DeviceData);

        SET_NEW_PNP_STATE(DeviceData, Stopped);

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        Cyclomy_DecIoCount (DeviceData);
        return status;

    case IRP_MN_QUERY_REMOVE_DEVICE:
        //
        // If we were to fail this call then we would need to complete the
        // IRP here.  Since we are not, set the status to SUCCESS and
        // call the next driver.
        //
        SET_NEW_PNP_STATE(DeviceData, RemovePending);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        Cyclomy_DecIoCount (DeviceData);
        return status;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        //
        // If we were to fail this call then we would need to complete the
        // IRP here.  Since we are not, set the status to SUCCESS and
        // call the next driver.
        //
        
        //
        // First check to see whether you have received cancel-remove
        // without first receiving a query-remove. This could happen if 
        // someone above us fails a query-remove and passes down the 
        // subsequent cancel-remove.
        //
        
        if(RemovePending == DeviceData->DevicePnPState)
        {
            //
            // We did receive a query-remove, so restore.
            //             
            RESTORE_PREVIOUS_PNP_STATE(DeviceData);
        }
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        Cyclomy_DecIoCount (DeviceData);
        return status;
        
    case IRP_MN_SURPRISE_REMOVAL:

        SET_NEW_PNP_STATE(DeviceData, SurpriseRemovePending);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        Cyclomy_DecIoCount (DeviceData);
        return status;

    case IRP_MN_REMOVE_DEVICE:

        //
        // The PlugPlay system has detected the removal of this device.  We
        // have no choice but to detach and delete the device object.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        // ASSERT (!DeviceData->Removed);

        // We will accept no new requests
        //
//        DeviceData->Removed = TRUE;
        SET_NEW_PNP_STATE(DeviceData, Deleted);

        //
        // Complete any outstanding IRPs queued by the driver here.
        //

        //
        // Make the DCA go away.  Some drivers may choose to remove the DCA
        // when they receive a stop or even a query stop.  We just don't care.
        //
        IoSetDeviceInterfaceState (&DeviceData->DevClassAssocName, FALSE);

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device is guarenteed stopped, so we cannot send it any non-
        // PNP IRPS.
        //

        //
        // Fire and forget
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        //
        // Wait for all outstanding requests to complete
        //
        Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
            ("Waiting for outstanding requests\n"));
        i = InterlockedDecrement (&DeviceData->OutstandingIO);

        ASSERT (0 < i);

        if (0 != InterlockedDecrement (&DeviceData->OutstandingIO)) {
            Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_INFO,
                          ("Remove Device waiting for request to complete\n"));

            KeWaitForSingleObject (&DeviceData->RemoveEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE, // Not Alertable
                                   NULL); // No timeout
        }
        //
        // Free the associated resources
        //

        //
        // Detach from the underlying devices.
        //
        Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_INFO,
                        ("IoDetachDevice: 0x%x\n", DeviceData->TopOfStack));
        IoDetachDevice (DeviceData->TopOfStack);

        //
        // Clean up any resources here
        //
        Cyclomy_ReleaseResources(DeviceData);

        ExFreePool (DeviceData->DevClassAssocName.Buffer);
        Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_INFO,
                        ("IoDeleteDevice: 0x%x\n", DeviceObject));

        //
        // Remove any PDO's we ejected
        //
//FANNY: CHANGED TO SUPPORT MORE THAN ONE CHILD DEVICE
//        if (DeviceData->AttachedPDO != NULL) {
//           ASSERT(DeviceData->NumPDOs == 1);
//
//           Cyclomy_PnPRemove(DeviceData->AttachedPDO, DeviceData->PdoData);
//           DeviceData->PdoData = NULL;
//           DeviceData->AttachedPDO = NULL;
//           DeviceData->NumPDOs = 0;
//        }

        i=DeviceData->NumPDOs;
        while(i--) {
           if (DeviceData->AttachedPDO[i] != NULL) {
              (DeviceData->PdoData[i])->Attached = FALSE;
              if(SurpriseRemovePending != (DeviceData->PdoData[i])->DevicePnPState) {
                  Cyclomy_PnPRemove(DeviceData->AttachedPDO[i], DeviceData->PdoData[i]);
              }
              DeviceData->PdoData[i] = NULL;
              DeviceData->AttachedPDO[i] = NULL;
           }
        }
        DeviceData->NumPDOs = 0;

        IoDeleteDevice(DeviceObject);

        return status;


    case IRP_MN_QUERY_DEVICE_RELATIONS:
        Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE, 
                    ("\tQueryDeviceRelation Type: %d\n", 
                    IrpStack->Parameters.QueryDeviceRelations.Type));

        if (BusRelations != IrpStack->Parameters.QueryDeviceRelations.Type) {
            //
            // We don't support this
            //
            Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
                ("Query Device Relations - Non bus\n"));
            goto CYY_FDO_PNP_DEFAULT;
        }

        Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
            ("\tQuery Bus Relations\n"));

        // Check for new devices or if old devices still there.
        status = Cyclomy_ReenumerateDevices(Irp, DeviceData );

        //
        // Tell the plug and play system about all the PDOs.
        //
        // There might also be device relations below and above this FDO,
        // so, be sure to propagate the relations from the upper drivers.
        //
        // No Completion routine is needed so long as the status is preset
        // to success.  (PDOs complete plug and play irps with the current
        // IoStatus.Status and IoStatus.Information as the default.)
        //

        //KeAcquireSpinLock (&DeviceData->Spin, &oldIrq);

        i = (0 == Irp->IoStatus.Information) ? 0 :
            ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Count;
        // The current number of PDOs in the device relations structure

        Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
                           ("#PDOS = %d + %d\n", i, DeviceData->NumPDOs));

        length = sizeof(DEVICE_RELATIONS) +
                ((DeviceData->NumPDOs + i) * sizeof (PDEVICE_OBJECT));

        relations = (PDEVICE_RELATIONS) ExAllocatePool (NonPagedPool, length);

        if (NULL == relations) {
           Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
           IoCompleteRequest(Irp, IO_NO_INCREMENT);
           Cyclomy_DecIoCount(DeviceData);
           return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Copy in the device objects so far
        //
        if (i) {
            RtlCopyMemory (
                  relations->Objects,
                  ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Objects,
                  i * sizeof (PDEVICE_OBJECT));
        }

        relations->Count = DeviceData->NumPDOs + i;


        //
        // For each PDO on this bus add a pointer to the device relations
        // buffer, being sure to take out a reference to that object.
        // The PlugPlay system will dereference the object when it is done with
        // it and free the device relations buffer.
        //

        //FANNY: CHANGED TO SUPPORT ADDITIONAL CHILD DEVICES
//        if (DeviceData->NumPDOs) {
//            relations->Objects[relations->Count-1] = DeviceData->AttachedPDO;
//            ObReferenceObject (DeviceData->AttachedPDO);
//        }

        for (i=0; i< DeviceData->NumPDOs; i++) {
           relations->Objects[relations->Count - DeviceData->NumPDOs + i] = 
                                                               DeviceData->AttachedPDO[i];
           ObReferenceObject (DeviceData->AttachedPDO[i]);

           Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
                           ("Child PDOS: %x\n", DeviceData->AttachedPDO[i]));
        }

        //
        // Set up and pass the IRP further down the stack
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        if (0 != Irp->IoStatus.Information) {
            ExFreePool ((PVOID) Irp->IoStatus.Information);
        }
        Irp->IoStatus.Information = (ULONG_PTR)relations;

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        Cyclomy_DecIoCount (DeviceData);

        return status;

    case IRP_MN_QUERY_CAPABILITIES: {

        PIO_STACK_LOCATION  irpSp;

        //
        // Send this down to the PDO first
        //

        KeInitializeEvent (&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine (Irp,
                                CyclomySyncCompletion,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            // wait for it...

            status = KeWaitForSingleObject (&event,
                                            Executive,
                                            KernelMode,
                                            FALSE, // Not allertable
                                            NULL); // No timeout structure

            ASSERT (STATUS_SUCCESS == status);

            status = Irp->IoStatus.Status;
        }

        if (NT_SUCCESS(status)) {

            irpSp = IoGetCurrentIrpStackLocation(Irp);

            DeviceData->SystemWake=irpSp->Parameters.DeviceCapabilities.Capabilities->SystemWake;
            DeviceData->DeviceWake=irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceWake;
//#if DBG
//            DbgPrint("PowerSystemSleeping1 %d\n",
//                irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[PowerSystemSleeping1]);
//            DbgPrint("PowerSystemSleeping2 %d\n",
//                irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[PowerSystemSleeping2]);
//            DbgPrint("PowerSystemSleeping3 %d\n",
//                irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[PowerSystemSleeping3]);
//            DbgPrint("PowerSystemHibernate %d\n",
//                irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[PowerSystemHibernate]);
//            DbgPrint("PowerSystemShutdown %d\n",
//                irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[PowerSystemShutdown]);
//            In the test with a system that supports standby, the result was:
//            D1, Unspecified, Unspecified, D3, D3.
//#endif

            Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_INFO, ("SystemWake %d\n",DeviceData->SystemWake)); 
            Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_INFO, ("DeviceWake %d\n",DeviceData->DeviceWake)); 
        }

        break;
    }

    default:
        //
        // In the default case we merely call the next driver since
        // we don't know what to do.
        //
        Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_TRACE, 
                 ("FDO(%x):%s not handled\n", DeviceObject,
                        PnPMinorFunctionString(IrpStack->MinorFunction)));
CYY_FDO_PNP_DEFAULT:

        //
        // Fire and Forget
        //
        IoSkipCurrentIrpStackLocation (Irp);

        //
        // Done, do NOT complete the IRP, it will be processed by the lower
        // device object, which will complete the IRP
        //

        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        Cyclomy_DecIoCount (DeviceData);
        return status;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    Cyclomy_DecIoCount (DeviceData);
    return status;
}


NTSTATUS
Cyclomy_PDO_PnP (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                 IN PIO_STACK_LOCATION IrpStack, IN PPDO_DEVICE_DATA DeviceData)
/*++
Routine Description:
    Handle requests from the PlugPlay system for the devices on the BUS

--*/
{
   PDEVICE_CAPABILITIES    deviceCapabilities;
   ULONG                   information;
   PWCHAR                  buffer;
   ULONG                   length, i, j;
   NTSTATUS                status;
   KIRQL                   oldIrq;
   HANDLE                  keyHandle;
   UNICODE_STRING          keyName;
   PWCHAR returnBuffer = NULL;

   PAGED_CODE();

   status = Irp->IoStatus.Status;

   //
   // NB: since we are a bus enumerator, we have no one to whom we could
   // defer these irps.  Therefore we do not pass them down but merely
   // return them.
   //

   switch (IrpStack->MinorFunction) {
   case IRP_MN_QUERY_CAPABILITIES:

      //
      // Get the packet.
      //

      deviceCapabilities=IrpStack->Parameters.DeviceCapabilities.Capabilities;

      //
      // Set the capabilities.
      //

      deviceCapabilities->Version = 1;
      deviceCapabilities->Size = sizeof (DEVICE_CAPABILITIES);

      //
      // We cannot wake the system.
      //

      deviceCapabilities->SystemWake 
          = ((PFDO_DEVICE_DATA)DeviceData->ParentFdo->DeviceExtension)
            ->SystemWake;
      deviceCapabilities->DeviceWake 
          = ((PFDO_DEVICE_DATA)DeviceData->ParentFdo->DeviceExtension)
            ->DeviceWake;

      //
      // We have no latencies
      //

      deviceCapabilities->D1Latency = 0;
      deviceCapabilities->D2Latency = 0;
      deviceCapabilities->D3Latency = 0;

      deviceCapabilities->UniqueID = FALSE;

      // 
      // Initialize supported DeviceState
      //

      deviceCapabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;
      deviceCapabilities->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
      deviceCapabilities->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
      deviceCapabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
      deviceCapabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
      deviceCapabilities->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

      status = STATUS_SUCCESS;
      break;

   case IRP_MN_QUERY_DEVICE_TEXT: {
      if ((IrpStack->Parameters.QueryDeviceText.DeviceTextType
          != DeviceTextDescription) || DeviceData->DevDesc.Buffer == NULL) {
         break;
      }

// FANNY - CHANGE TO MaximumLength
//      returnBuffer = ExAllocatePool(PagedPool, DeviceData->DevDesc.Length);
      returnBuffer = ExAllocatePool(PagedPool, DeviceData->DevDesc.MaximumLength);

      if (returnBuffer == NULL) {
         status = STATUS_INSUFFICIENT_RESOURCES;
         break;
      }

      status = STATUS_SUCCESS;

// FANNY - CHANGE TO MaximumLength
//      RtlCopyMemory(returnBuffer, DeviceData->DevDesc.Buffer,
//                    DeviceData->DevDesc.Length);
      RtlCopyMemory(returnBuffer, DeviceData->DevDesc.Buffer,
                    DeviceData->DevDesc.MaximumLength);

      Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_TRACE,
                            ("TextID: buf %ws\n", returnBuffer));

      Irp->IoStatus.Information = (ULONG_PTR)returnBuffer;
      break;
   }


   case IRP_MN_QUERY_ID:
      //
      // Query the IDs of the device
      //

      switch (IrpStack->Parameters.QueryId.IdType) {

      //
      // The other ID's we just copy from the buffers and are done.
      //

      case BusQueryDeviceID:
      case BusQueryHardwareIDs:
      case BusQueryCompatibleIDs:
      case BusQueryInstanceID:
         {
            PUNICODE_STRING pId;
            status = STATUS_SUCCESS;

            switch (IrpStack->Parameters.QueryId.IdType) {
            case BusQueryDeviceID:
               pId = &DeviceData->DeviceIDs;
               break;

            case BusQueryHardwareIDs:
               pId = &DeviceData->HardwareIDs;
               break;

            case BusQueryCompatibleIDs:
               pId = &DeviceData->CompIDs;
               break;

            case BusQueryInstanceID:
            // Build an instance ID.  This is what PnP uses to tell if it has
            // seen this thing before or not.  Build it from the first hardware
            // id and the port number.
               pId = &DeviceData->InstanceIDs;
               break;
            }

            buffer = pId->Buffer;

            if (buffer != NULL) {
               // FANNY CHANGED
               //length = pId->Length;
               length = pId->MaximumLength;
               returnBuffer = ExAllocatePool(PagedPool, length);
               if (returnBuffer != NULL) {
#if DBG
                  RtlFillMemory(returnBuffer, length, 0xff);
#endif
                  // FANNY CHANGED
                  //RtlCopyMemory(returnBuffer, buffer, pId->Length);
                  RtlCopyMemory(returnBuffer, buffer, length);
               } else {
                  status = STATUS_INSUFFICIENT_RESOURCES;
               }
            } else {
               // FANNY ADDED
               status = STATUS_NOT_FOUND;
            }

            Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_TRACE,
                            ("ID: Unicode 0x%x\n", pId));
            Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_TRACE,
                            ("ID: buf 0x%x\n", returnBuffer));

            Irp->IoStatus.Information = (ULONG_PTR)returnBuffer;
         }
         break;

      }
      break;

      case IRP_MN_QUERY_BUS_INFORMATION: {
       PPNP_BUS_INFORMATION pBusInfo;
       PFDO_DEVICE_DATA parentExtension;
       parentExtension = (DeviceData->ParentFdo)->DeviceExtension;

       ASSERTMSG("Cyclomy appears not to be the sole bus?!?",
                 Irp->IoStatus.Information == (ULONG_PTR)NULL);

       pBusInfo = ExAllocatePool(PagedPool, sizeof(PNP_BUS_INFORMATION));

       if (pBusInfo == NULL) {
          status = STATUS_INSUFFICIENT_RESOURCES;
          break;
       }

       pBusInfo->BusTypeGuid = GUID_BUS_TYPE_CYCLOMY;
       if (parentExtension->IsPci) {
         pBusInfo->LegacyBusType = PCIBus;
       } else {
         pBusInfo->LegacyBusType = Isa;
       }

       //
       // We really can't track our bus number since we can be torn
       // down with our bus
       //

       //pBusInfo->BusNumber = 0;
       pBusInfo->BusNumber = parentExtension->UINumber;

       Irp->IoStatus.Information = (ULONG_PTR)pBusInfo;
       status = STATUS_SUCCESS;
       break;
       }

   case IRP_MN_QUERY_DEVICE_RELATIONS:
      Cyclomy_KdPrint (DeviceData, SER_DBG_PNP_TRACE, 
                    ("\tQueryDeviceRelation Type: %d\n", 
                    IrpStack->Parameters.QueryDeviceRelations.Type));

      switch (IrpStack->Parameters.QueryDeviceRelations.Type) {
      case TargetDeviceRelation: {
         PDEVICE_RELATIONS pDevRel;

         //
         // No one else should respond to this since we are the PDO
         //

         ASSERT(Irp->IoStatus.Information == 0);

         if (Irp->IoStatus.Information != 0) {
            break;
         }


         pDevRel = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));

         if (pDevRel == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
         }

         pDevRel->Count = 1;
         pDevRel->Objects[0] = DeviceObject;
         ObReferenceObject(DeviceObject);

         status = STATUS_SUCCESS;
         Irp->IoStatus.Information = (ULONG_PTR)pDevRel;
         break;
      }


      default:
         break;
      }

      break;

   case IRP_MN_START_DEVICE:

      //
      // Set the hw resources in the registry for this device.
      //

      status = IoOpenDeviceRegistryKey(DeviceObject, PLUGPLAY_REGKEY_DEVICE,
                                       STANDARD_RIGHTS_WRITE, &keyHandle);

      if (!NT_SUCCESS(status)) {
         //
         // This is a fatal error.  If we can't get to our registry key,
         // we are sunk.
         //
         Cyclomy_KdPrint(DeviceData, SER_DBG_SS_ERROR,
                          ("IoOpenDeviceRegistryKey failed - %x\n", status));
      } else {

         ULONG portIndex;
         PFDO_DEVICE_DATA parentExtension;

         // Set the Port Index in the Registry
         
         RtlInitUnicodeString(&keyName, L"PortIndex");

         portIndex = DeviceData->PortIndex;

         //
         // Doesn't matter whether this works or not.
         //

         ZwSetValueKey(keyHandle, &keyName, 0, REG_DWORD, &portIndex,
                       sizeof(ULONG));

         parentExtension = (DeviceData->ParentFdo)->DeviceExtension;

         RtlInitUnicodeString(&keyName, L"PortResources");

         status = ZwSetValueKey(keyHandle, &keyName, 0, REG_RESOURCE_LIST, 
                       parentExtension->PChildResourceList,
                       parentExtension->PChildResourceListSize);

         RtlInitUnicodeString(&keyName, L"PortResourcesTr");

         status = ZwSetValueKey(keyHandle, &keyName, 0, REG_RESOURCE_LIST, 
                       parentExtension->PChildResourceListTr,
                       parentExtension->PChildResourceListSizeTr);
         
         ZwFlushKey(keyHandle);
         ZwClose(keyHandle);
      }

      SET_NEW_PNP_STATE(DeviceData, Started);
      status = STATUS_SUCCESS;
      break;

   case IRP_MN_QUERY_STOP_DEVICE:

      //
      // No reason here why we can't stop the device.
      // If there were a reason we should speak now for answering success
      // here may result in a stop device irp.
      //

      SET_NEW_PNP_STATE(DeviceData, StopPending);
      status = STATUS_SUCCESS;
      break;

   case IRP_MN_CANCEL_STOP_DEVICE:
      //
      // The stop was canceled.  Whatever state we set, or resources we put
      // on hold in anticipation of the forcoming STOP device IRP should be
      // put back to normal.  Someone, in the long list of concerned parties,
      // has failed the stop device query.
      //

      //
      // First check to see whether you have received cancel-stop
      // without first receiving a query-stop. This could happen if someone
      // above us fails a query-stop and passes down the subsequent
      // cancel-stop.
      //
        
      if(StopPending == DeviceData->DevicePnPState)
      {
          //
          // We did receive a query-stop, so restore.
          //             
          RESTORE_PREVIOUS_PNP_STATE(DeviceData);
      }
      status = STATUS_SUCCESS;
      break;

   case IRP_MN_STOP_DEVICE:

      //
      // Here we shut down the device.  The opposite of start.
      //

      SET_NEW_PNP_STATE(DeviceData, Stopped);
      status = STATUS_SUCCESS;
      break;

   case IRP_MN_QUERY_REMOVE_DEVICE:
      //
      // Just like Query Stop only now the impending doom is the remove irp
      //
      SET_NEW_PNP_STATE(DeviceData, RemovePending);
      status = STATUS_SUCCESS;
      break;

   case IRP_MN_CANCEL_REMOVE_DEVICE:
      //
      // Clean up a remove that did not go through, just like cancel STOP.
      //

      //
      // First check to see whether you have received cancel-remove
      // without first receiving a query-remove. This could happen if 
      // someone above us fails a query-remove and passes down the 
      // subsequent cancel-remove.
      //
       
      if(RemovePending == DeviceData->DevicePnPState)
      {
          //
          // We did receive a query-remove, so restore.
          //             
          RESTORE_PREVIOUS_PNP_STATE(DeviceData);
      }
      status = STATUS_SUCCESS;
      break;

   case IRP_MN_SURPRISE_REMOVAL:

        //
        // We should stop all access to the device and relinquish all the
        // resources. Let's just mark that it happened and we will do 
        // the cleanup later in IRP_MN_REMOVE_DEVICE.
        //

        SET_NEW_PNP_STATE(DeviceData, SurpriseRemovePending);
        status = STATUS_SUCCESS;
        break;

   case IRP_MN_REMOVE_DEVICE:

      //
      // Attached is only set to FALSE by the enumeration process.
      //
      if (!DeviceData->Attached) {

          SET_NEW_PNP_STATE(DeviceData, Deleted);
          status = Cyclomy_PnPRemove(DeviceObject, DeviceData);
      }
      else {    // else added in build 2128 - Fanny
          //
          // Succeed the remove
          ///
          SET_NEW_PNP_STATE(DeviceData, NotStarted);
          status = STATUS_SUCCESS;
      }

// Changed in build 2072
//      status = STATUS_SUCCESS;

      break;

   case IRP_MN_QUERY_RESOURCES: {
#if 0
      PCM_RESOURCE_LIST pChildRes, pQueryRes;
      PFDO_DEVICE_DATA parentExtension;
      ULONG listSize;

      parentExtension = (DeviceData->ParentFdo)->DeviceExtension;
      pChildRes = parentExtension->PChildResourceList;
      listSize = parentExtension->PChildResourceListSize;

      if (pChildRes) {
         pQueryRes = ExAllocatePool(PagedPool, listSize);
         if (pQueryRes == NULL) {
            Irp->IoStatus.Information = (ULONG_PTR) NULL;
            status = STATUS_INSUFFICIENT_RESOURCES;
         } else {
            RtlCopyMemory(pQueryRes,pChildRes,listSize);
            Irp->IoStatus.Information = (ULONG_PTR)pQueryRes;
            status = STATUS_SUCCESS;
         }
      }
#endif
      break;

   }

   case IRP_MN_QUERY_RESOURCE_REQUIREMENTS: {
#if 0      
      PIO_RESOURCE_REQUIREMENTS_LIST pChildReq, pQueryReq;
      PFDO_DEVICE_DATA parentExtension;

      parentExtension = (DeviceData->ParentFdo)->DeviceExtension;
      pChildReq = parentExtension->PChildRequiredList;
      if (pChildReq) {
         pQueryReq = ExAllocatePool(PagedPool, pChildReq->ListSize);
         if (pQueryReq == NULL) {
            Irp->IoStatus.Information = (ULONG_PTR) NULL;
            status = STATUS_INSUFFICIENT_RESOURCES;
         } else {
            RtlCopyMemory(pQueryReq,pChildReq,pChildReq->ListSize);
            Irp->IoStatus.Information = (ULONG_PTR)pQueryReq;
            status = STATUS_SUCCESS;
         }
      }
#endif
      break;
   }

   case IRP_MN_READ_CONFIG:
   case IRP_MN_WRITE_CONFIG: // we have no config space
   case IRP_MN_EJECT:
   case IRP_MN_SET_LOCK:
   case IRP_MN_QUERY_INTERFACE: // We do not have any non IRP based interfaces.
   default:
      Cyclomy_KdPrint(DeviceData, SER_DBG_PNP_TRACE, 
                 ("PDO(%x):%s not handled\n", DeviceObject,
                        PnPMinorFunctionString(IrpStack->MinorFunction)));

      // For PnP requests to the PDO that we do not understand we should
      // return the IRP WITHOUT setting the status or information fields.
      // They may have already been set by a filter (eg acpi).
      break;
   }

   Irp->IoStatus.Status = status;
   IoCompleteRequest (Irp, IO_NO_INCREMENT);

   return status;
}

NTSTATUS
Cyclomy_PnPRemove (PDEVICE_OBJECT Device, PPDO_DEVICE_DATA PdoData)
/*++
Routine Description:
    The PlugPlay subsystem has instructed that this PDO should be removed.

    We should therefore
    - Complete any requests queued in the driver
    - If the device is still attached to the system,
      then complete the request and return.
    - Otherwise, cleanup device specific allocations, memory, events...
    - Call IoDeleteDevice
    - Return from the dispatch routine.

    Note that if the device is still connected to the bus (IE in this case
    the control panel has not yet told us that the serial device has
    disappeared) then the PDO must remain around, and must be returned during
    any query Device relaions IRPS.

--*/

{
   Cyclomy_KdPrint(PdoData, SER_DBG_PNP_TRACE,
                        ("Cyclomy_PnPRemove: 0x%x\n", Device));
    //
    // Complete any outstanding requests with STATUS_DELETE_PENDING.
    //
    // Serenum does not queue any irps at this time so we have nothing to do.
    //

    //REMOVED BY FANNY. THIS CHECK IS ALREADY DONE AT IRP_MN_REMOVE_DEVICE PDO.
    //if (PdoData->Attached) {
    //    return STATUS_SUCCESS;
    //}
    //PdoData->Removed = TRUE;
    
    //
    // Free any resources.
    //

    CyclomyFreeUnicodeString(&PdoData->HardwareIDs);
    //CyclomyFreeUnicodeString(&PdoData->CompIDs); We never allocate CompIDs.
    RtlFreeUnicodeString(&PdoData->DeviceIDs);
    RtlFreeUnicodeString(&PdoData->InstanceIDs);
    RtlFreeUnicodeString(&PdoData->DevDesc);

    Cyclomy_KdPrint(PdoData, SER_DBG_PNP_INFO,
                        ("IoDeleteDevice: 0x%x\n", Device));

    IoDeleteDevice(Device);


    return STATUS_SUCCESS;
}


NTSTATUS
Cyclomy_GetResourceInfo(IN PDEVICE_OBJECT PDevObj,
                    IN PCM_RESOURCE_LIST PResList,
                    IN PCM_RESOURCE_LIST PTrResList)
/*++

Routine Description:

    This routine gets the resources that PnP allocated to this device.


Arguments:

   PDevObj    -  Pointer to the devobj that is starting

   PResList   -  Pointer to the untranslated resources needed by this device

   PTrResList -  Pointer to the translated resources needed by this device


  Return Value:

    STATUS_SUCCESS on success, something else appropriate on failure


--*/

{
   PFDO_DEVICE_DATA pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;

   ULONG count;
   ULONG i;
   PCM_PARTIAL_RESOURCE_LIST pPartialResourceList, pPartialTrResourceList;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialResourceDesc, pPartialTrResourceDesc;
   PCM_FULL_RESOURCE_DESCRIPTOR pFullResourceDesc = NULL,
                                pFullTrResourceDesc = NULL;
   KAFFINITY Affinity;
   KINTERRUPT_MODE InterruptMode;
   ULONG zero = 0;
   
   PAGED_CODE();

   // Let's get our resources
   pFullResourceDesc   = &PResList->List[0];
   pFullTrResourceDesc = &PTrResList->List[0];

   if (pFullResourceDesc) {
      pPartialResourceList    = &pFullResourceDesc->PartialResourceList;
      pPartialResourceDesc    = pPartialResourceList->PartialDescriptors;
      count                   = pPartialResourceList->Count;

      pDevExt->InterfaceType  = pFullResourceDesc->InterfaceType;
      pDevExt->BusNumber      = pFullResourceDesc->BusNumber;

      for (i = 0;     i < count;     i++, pPartialResourceDesc++) {

         switch (pPartialResourceDesc->Type) {
         case CmResourceTypeMemory: {

            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceTypeMemory\n"));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Memory.Start = %x\n",
                                           pPartialResourceDesc->u.Memory.Start));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Memory.Length = %x\n",
                                           pPartialResourceDesc->u.Memory.Length));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Flags = %x\n",
                                           pPartialResourceDesc->Flags));
            
            if (pPartialResourceDesc->u.Memory.Length == CYY_RUNTIME_LENGTH) {
               pDevExt->PhysicalRuntime = pPartialResourceDesc->u.Memory.Start;
               pDevExt->RuntimeLength = pPartialResourceDesc->u.Memory.Length;
            } else {
               pDevExt->PhysicalBoardMemory = pPartialResourceDesc->u.Memory.Start;
               pDevExt->BoardMemoryLength = pPartialResourceDesc->u.Memory.Length;
            }
            break;
         }
         case CmResourceTypePort: {

            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceTypePort\n"));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Port.Start = %x\n",
                                           pPartialResourceDesc->u.Port.Start));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Port.Length = %x\n",
                                           pPartialResourceDesc->u.Port.Length));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Flags = %x\n",
                                           pPartialResourceDesc->Flags));

            break;
         }

         case CmResourceTypeInterrupt: {

            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceTypeInterrupt\n"));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Interrupt.Level = %x\n",
                                           pPartialResourceDesc->u.Interrupt.Level));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Interrupt.Vector = %x\n",
                                           pPartialResourceDesc->u.Interrupt.Vector));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Interrupt.Affinity = %x\n",
                                           pPartialResourceDesc->u.Interrupt.Affinity));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("Flags = %x\n",
                                           pPartialResourceDesc->Flags));

            pDevExt->OriginalIrql = pPartialResourceDesc->u.Interrupt.Level;
            pDevExt->OriginalVector =pPartialResourceDesc->u.Interrupt.Vector;
            Affinity = pPartialResourceDesc->u.Interrupt.Affinity;

            if (pPartialResourceDesc->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {
               InterruptMode = Latched;
            } else {
               InterruptMode = LevelSensitive;
            }

            break;
         }

         case CmResourceTypeDeviceSpecific: {
            PCM_SERIAL_DEVICE_DATA sDeviceData;

            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceTypeDeviceSpecific\n"));

            break;
         }


         default: {
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceType = %x\n",
                                                      pPartialResourceDesc->Type));
            break;
         }
         }   // switch (pPartialResourceDesc->Type)
      }       // for (i = 0;     i < count;     i++, pPartialResourceDesc++)
   }           // if (pFullResourceDesc)



//SEE_LATER_IF_IT_SHOULD_BE_ADDED
//   //
//   // Do the same for the translated resources
//   //
//
//   gotInt = 0;
//   gotISR = 0;
//   gotIO = 0;
//   curIoIndex = 0;
//
   if (pFullTrResourceDesc) {
      pPartialTrResourceList = &pFullTrResourceDesc->PartialResourceList;
      pPartialTrResourceDesc = pPartialTrResourceList->PartialDescriptors;
      count = pPartialTrResourceList->Count;

      //
      // Reload PConfig with the translated values for later use
      //

      pDevExt->InterfaceType  = pFullTrResourceDesc->InterfaceType;
      pDevExt->BusNumber      = pFullTrResourceDesc->BusNumber;

//FANNY
//      pDevExt->TrInterruptStatus = SerialPhysicalZero;

      for (i = 0;     i < count;     i++, pPartialTrResourceDesc++) {

         switch (pPartialTrResourceDesc->Type) {
         case CmResourceTypeMemory: {

            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceTypeMemory translated\n"));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Memory.Start = %x\n",
                                           pPartialTrResourceDesc->u.Memory.Start));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Memory.Length = %x\n",
                                           pPartialTrResourceDesc->u.Memory.Length));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Flags = %x\n",
                                           pPartialTrResourceDesc->Flags));

            if (pPartialTrResourceDesc->u.Memory.Length == CYY_RUNTIME_LENGTH) {
               pDevExt->TranslatedRuntime = pPartialTrResourceDesc->u.Memory.Start;
               pDevExt->RuntimeLength = pPartialTrResourceDesc->u.Memory.Length;
            } else {
               pDevExt->TranslatedBoardMemory = pPartialTrResourceDesc->u.Memory.Start;
               pDevExt->BoardMemoryLength = pPartialTrResourceDesc->u.Memory.Length;
            }
            break;
         }
         case CmResourceTypePort: {

            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceTypePort translated\n"));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Port.Start = %x\n",
                                           pPartialTrResourceDesc->u.Port.Start));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Port.Length = %x\n",
                                           pPartialTrResourceDesc->u.Port.Length));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Flags = %x\n",
                                           pPartialTrResourceDesc->Flags));

            break;
         }

         case CmResourceTypeInterrupt: {

            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("CmResourceTypeInterrupt translated\n"));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Interrupt.Level = %x\n",
                                           pPartialTrResourceDesc->u.Interrupt.Level));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Interrupt.Vector = %x\n",
                                           pPartialTrResourceDesc->u.Interrupt.Vector));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("u.Interrupt.Affinity = %x\n",
                                           pPartialTrResourceDesc->u.Interrupt.Affinity));
            Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("Flags = %x\n",
                                           pPartialTrResourceDesc->Flags));

            pDevExt->Vector = pPartialTrResourceDesc->u.Interrupt.Vector;
            pDevExt->Irql = (KIRQL) pPartialTrResourceDesc->u.Interrupt.Level;
            Affinity = pPartialTrResourceDesc->u.Interrupt.Affinity;

            break;
         }

         default: {
               break;
         }
         }   // switch (pPartialTrResourceDesc->Type)
      }       // for (i = 0;     i < count;     i++, pPartialTrResourceDesc++)
   }           // if (pFullTrResourceDesc)


   //
   // Do some error checking on the configuration info we have.
   //
   // Make sure that the interrupt is non zero (which we defaulted
   // it to).
   //
   // Make sure that the portaddress is non zero (which we defaulted
   // it to).
   //
   // Make sure that the DosDevices is not NULL (which we defaulted
   // it to).
   //
   // We need to make sure that if an interrupt status
   // was specified, that a port index was also specfied,
   // and if so that the port index is <= maximum ports
   // on a board.
   //
   // We should also validate that the bus type and number
   // are correct.
   //
   // We will also validate that the interrupt mode makes
   // sense for the bus.
   //

   if (!pDevExt->TranslatedRuntime.LowPart && pDevExt->IsPci) {

      CyyLogError(
                    pDevExt->DriverObject,
                    NULL,
                    pDevExt->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    0,
                    STATUS_SUCCESS,
                    CYY_INVALID_RUNTIME_REGISTERS,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      Cyclomy_KdPrint (pDevExt,SER_DBG_CYCLADES,
                  ("Bogus PLX address %x\n",
                   pDevExt->TranslatedRuntime.LowPart));

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto GetResourceInfo_Cleanup;
   }


   if (!pDevExt->TranslatedBoardMemory.LowPart) {

      CyyLogError(
                    pDevExt->DriverObject,
                    NULL,
                    pDevExt->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    0,
                    STATUS_SUCCESS,
                    CYY_INVALID_BOARD_MEMORY,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      Cyclomy_KdPrint (pDevExt,SER_DBG_CYCLADES,
                  ("Bogus TranslatedBoardMemory address %x\n",
                   pDevExt->TranslatedBoardMemory.LowPart));

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto GetResourceInfo_Cleanup;
   }


   if (!pDevExt->OriginalVector) {

      CyyLogError(
                    pDevExt->DriverObject,
                    NULL,
                    pDevExt->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    0,
                    STATUS_SUCCESS,
                    CYY_INVALID_INTERRUPT,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      Cyclomy_KdPrint (pDevExt,SER_DBG_CYCLADES,("Bogus vector %x\n",
                             pDevExt->OriginalVector));

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto GetResourceInfo_Cleanup;
   }


   //
   // We don't want to cause the hal to have a bad day,
   // so let's check the interface type and bus number.
   //
   // We only need to check the registry if they aren't
   // equal to the defaults.
   //

   if (pDevExt->BusNumber != 0) {

      BOOLEAN foundIt = 0;

      if (pDevExt->InterfaceType >= MaximumInterfaceType) {

         CyyLogError(
                       pDevExt->DriverObject,
                       NULL,
                       pDevExt->PhysicalBoardMemory,
                       CyyPhysicalZero,
                       0,
                       0,
                       0,
                       pDevExt->InterfaceType,
                       STATUS_SUCCESS,
                       CYY_UNKNOWN_BUS,
                       0,
                       NULL,
                       0,
                       NULL
                       );
         Cyclomy_KdPrint (pDevExt,SER_DBG_CYCLADES,
                  ("Invalid Bus type %x\n", pDevExt->BusNumber));

         //status = SERIAL_UNKNOWN_BUS;
         status = STATUS_INSUFFICIENT_RESOURCES;
         goto GetResourceInfo_Cleanup;
      }    

      IoQueryDeviceDescription(
                              (INTERFACE_TYPE *)&pDevExt->InterfaceType,
                              &zero,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              Cyclomy_ItemCallBack,
                              &foundIt
                              );

      if (!foundIt) {

         CyyLogError(
                       pDevExt->DriverObject,
                       NULL,
                       pDevExt->PhysicalBoardMemory,
                       CyyPhysicalZero,
                       0,
                       0,
                       0,
                       pDevExt->InterfaceType,
                       STATUS_SUCCESS,
                       CYY_BUS_NOT_PRESENT,
                       0,
                       NULL,
                       0,
                       NULL
                       );
         Cyclomy_KdPrint(
                   pDevExt,
                   SER_DBG_CYCLADES,
                   ("There aren't that many of those\n"
                    "------- busses on this system,%x\n",
                    pDevExt->BusNumber)
                   );

         //status = SERIAL_BUS_NOT_PRESENT;
         status = STATUS_INSUFFICIENT_RESOURCES;
         goto GetResourceInfo_Cleanup;
      }
   }


   //
   // Dump out the board configuration.
   //

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES, ("PhysicalRuntime: %x\n",
                          pDevExt->PhysicalRuntime.LowPart));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES, ("TranslatedRuntime: %x\n",
                          pDevExt->TranslatedRuntime.LowPart));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES, ("RuntimeLength: %x\n",
                          pDevExt->RuntimeLength));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES, ("PhysicalBoardMemory: %x\n",
                          pDevExt->PhysicalBoardMemory.LowPart));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES, ("TranslatedBoardMemory: %x\n",
                          pDevExt->TranslatedBoardMemory.LowPart));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES, ("BoardMemoryLength: %x\n",
                          pDevExt->BoardMemoryLength));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("OriginalIrql = %x\n",
                          pDevExt->OriginalIrql));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("OriginalVector = %x\n",
                          pDevExt->OriginalVector));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("Irql = %x\n",
                          pDevExt->Irql));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("Vector = %x\n",
                          pDevExt->Vector));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("Affinity = %x\n",
                          Affinity));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("InterfaceType = %x\n",
                          pDevExt->InterfaceType));

   Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("BusNumber = %x\n",
                          pDevExt->BusNumber));

   // ABOVE: COPIED FROM SerialGetPortInfo
   // ------------------------------------

   // BELOW: COPIED FROM SerialInitController
   if (pDevExt->IsPci) {
      pDevExt->Runtime = MmMapIoSpace(pDevExt->TranslatedRuntime,
                                      pDevExt->RuntimeLength,
                                      FALSE);

      if (!pDevExt->Runtime){

         CyyLogError(
                       pDevExt->DriverObject,
                       NULL,
                       pDevExt->PhysicalBoardMemory,
                       CyyPhysicalZero,
                       0,
                       0,
                       0,
                       0,
                       STATUS_SUCCESS,
                       CYY_RUNTIME_NOT_MAPPED,
                       0,
                       NULL,
                       0,
                       NULL
                       );
         Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("Could not map memory for PLX\n"));
         status = STATUS_NONE_MAPPED;
         goto GetResourceInfo_Cleanup;
      }
   }
   pDevExt->BoardMemory = MmMapIoSpace(pDevExt->TranslatedBoardMemory,
                                       pDevExt->BoardMemoryLength,
                                       FALSE);

   if (!pDevExt->BoardMemory){

      CyyLogError(
                    pDevExt->DriverObject,
                    NULL,
                    pDevExt->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    0,
                    STATUS_SUCCESS,
                    CYY_BOARD_NOT_MAPPED,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      Cyclomy_KdPrint(pDevExt,SER_DBG_CYCLADES,("Could not map memory for CD1400\n"));
      status = STATUS_NONE_MAPPED;
      goto GetResourceInfo_Cleanup;
   }


GetResourceInfo_Cleanup:
   if (!NT_SUCCESS(status)) {
      
      if (pDevExt->Runtime) {
         MmUnmapIoSpace(pDevExt->Runtime, pDevExt->RuntimeLength);
	      pDevExt->Runtime = NULL;
      }

      if (pDevExt->BoardMemory) {
         MmUnmapIoSpace(pDevExt->BoardMemory, pDevExt->BoardMemoryLength);
 		   pDevExt->BoardMemory = NULL;
      }
   }

   Cyclomy_KdPrint (pDevExt,SER_DBG_CYCLADES, ("leaving Cyclomy_GetResourceInfo\n"));
   return status;
}

VOID
Cyclomy_ReleaseResources(IN PFDO_DEVICE_DATA PDevExt)
{   
   Cyclomy_KdPrint (PDevExt,SER_DBG_CYCLADES, ("entering Cyclomy_ReleaseResources\n"));

   if (PDevExt->PChildRequiredList) {
      ExFreePool(PDevExt->PChildRequiredList);
      PDevExt->PChildRequiredList = NULL;
   }

   if (PDevExt->PChildResourceList) {
      ExFreePool(PDevExt->PChildResourceList);
      PDevExt->PChildResourceList = NULL;
   }

   if (PDevExt->PChildResourceListTr) {
      ExFreePool(PDevExt->PChildResourceListTr);
      PDevExt->PChildResourceListTr = NULL;
   }

   if (PDevExt->Runtime) {
      MmUnmapIoSpace(PDevExt->Runtime, PDevExt->RuntimeLength);
      PDevExt->Runtime = NULL;
   }

   if (PDevExt->BoardMemory) {
      MmUnmapIoSpace(PDevExt->BoardMemory, PDevExt->BoardMemoryLength);
      PDevExt->BoardMemory = NULL;
   }
   Cyclomy_KdPrint (PDevExt,SER_DBG_CYCLADES, ("leaving Cyclomy_ReleaseResources\n"));   
}


NTSTATUS
Cyclomy_ItemCallBack(
                  IN PVOID Context,
                  IN PUNICODE_STRING PathName,
                  IN INTERFACE_TYPE BusType,
                  IN ULONG BusNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
                  IN CONFIGURATION_TYPE ControllerType,
                  IN ULONG ControllerNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
                  IN CONFIGURATION_TYPE PeripheralType,
                  IN ULONG PeripheralNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
                  )

/*++

Routine Description:

    This routine is called to check if a particular item
    is present in the registry.

Arguments:

    Context - Pointer to a boolean.

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Controller type.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should be a peripheral.

    PeripheralNumber - Which peripheral - not used..

    PeripheralInformation - Configuration information. Not Used.

Return Value:

    STATUS_SUCCESS

--*/

{
   UNREFERENCED_PARAMETER (PathName);
   UNREFERENCED_PARAMETER (BusType);
   UNREFERENCED_PARAMETER (BusNumber);
   UNREFERENCED_PARAMETER (BusInformation);
   UNREFERENCED_PARAMETER (ControllerType);
   UNREFERENCED_PARAMETER (ControllerNumber);
   UNREFERENCED_PARAMETER (ControllerInformation);
   UNREFERENCED_PARAMETER (PeripheralType);
   UNREFERENCED_PARAMETER (PeripheralNumber);
   UNREFERENCED_PARAMETER (PeripheralInformation);

   PAGED_CODE();


   *((BOOLEAN *)Context) = TRUE;
   return STATUS_SUCCESS;
}


NTSTATUS
Cyclomy_BuildRequirementsList(
                          OUT PIO_RESOURCE_REQUIREMENTS_LIST *PChildRequiredList_Pointer,
                          IN PCM_RESOURCE_LIST PResourceList, IN ULONG NumberOfResources
                          )
{

   NTSTATUS status = STATUS_SUCCESS;
   ULONG count;
   ULONG i,j;   
   PCM_FULL_RESOURCE_DESCRIPTOR    pFullResourceDesc = NULL;
   PCM_PARTIAL_RESOURCE_LIST       pPartialResourceList;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialResourceDesc;

   ULONG requiredLength;
   PIO_RESOURCE_REQUIREMENTS_LIST requiredList;
   PIO_RESOURCE_LIST       requiredResList;
   PIO_RESOURCE_DESCRIPTOR requiredResDesc;

   *PChildRequiredList_Pointer = NULL;

   // Validate input parameter

   if (PResourceList == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyclomyBuildRequirementList_Error;
   }

   ASSERT(PResourceList->Count == 1);

   // Initialize requiredList

   requiredLength = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) 
                + sizeof(IO_RESOURCE_DESCRIPTOR) * (NumberOfResources - 1);
 
   requiredList = ExAllocatePool(PagedPool, requiredLength);
   
   if (requiredList == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyclomyBuildRequirementList_Error;
   }

   RtlZeroMemory(requiredList, requiredLength);

   // Get information from PResourceList and build requiredList

   pFullResourceDesc = &PResourceList->List[0];

   if (pFullResourceDesc) {
      pPartialResourceList = &pFullResourceDesc->PartialResourceList;
      pPartialResourceDesc = pPartialResourceList->PartialDescriptors;
      count                = pPartialResourceList->Count;

      if (count < NumberOfResources) {
         ExFreePool(requiredList);
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      requiredList->ListSize = requiredLength;
      requiredList->InterfaceType = pFullResourceDesc->InterfaceType;
      requiredList->BusNumber     = pFullResourceDesc->BusNumber;
      requiredList->SlotNumber    = 0; //?????? There's no SlotNumber in the Resource List
      requiredList->AlternativeLists = 1;

      requiredResList = &requiredList->List[0];
      requiredResList->Count = NumberOfResources;

      requiredResDesc = &requiredResList->Descriptors[0];

      for (i=0,j=0; i<count && j<NumberOfResources;  i++,pPartialResourceDesc++) {
         
         switch (pPartialResourceDesc->Type) {
         case CmResourceTypeMemory: {
            requiredResDesc->Type = pPartialResourceDesc->Type;
            //requiredResDesc->ShareDisposition = pPartialResourceDesc->ShareDisposition;
            requiredResDesc->ShareDisposition = CmResourceShareShared;
            requiredResDesc->Flags = pPartialResourceDesc->Flags;
            requiredResDesc->u.Memory.Length = pPartialResourceDesc->u.Memory.Length;
            requiredResDesc->u.Memory.Alignment = 4;
            requiredResDesc->u.Memory.MinimumAddress = pPartialResourceDesc->u.Memory.Start;
            requiredResDesc->u.Memory.MaximumAddress.QuadPart 
                        = pPartialResourceDesc->u.Memory.Start.QuadPart 
                        + pPartialResourceDesc->u.Memory.Length - 1;
            requiredResDesc++;
            j++;
            break;
         }
         case CmResourceTypePort: {
            break;
         }
         case CmResourceTypeInterrupt: {
            requiredResDesc->Type = pPartialResourceDesc->Type;
            requiredResDesc->ShareDisposition = CmResourceShareShared;
            requiredResDesc->Flags = pPartialResourceDesc->Flags;
            requiredResDesc->u.Interrupt.MinimumVector 
                                             = pPartialResourceDesc->u.Interrupt.Vector;
            requiredResDesc->u.Interrupt.MaximumVector 
                                             = pPartialResourceDesc->u.Interrupt.Vector;
            requiredResDesc++;
            j++;
            break;
         }
         default: 
            break;
         } // end switch
         
      } // end for

   } // end if (pFullResourceDesc)

   *PChildRequiredList_Pointer = requiredList;


CyclomyBuildRequirementList_Error:
   return status;

}

NTSTATUS
Cyclomy_BuildResourceList(
                      OUT PCM_RESOURCE_LIST *POutList_Pointer,
                      OUT ULONG *ListSize_Pointer,
                      IN PCM_RESOURCE_LIST PInList,
                      IN ULONG NumberOfResources
                      )
{

   NTSTATUS status = STATUS_SUCCESS;
   ULONG i,j;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialInDesc;

   ULONG length;
   PCM_RESOURCE_LIST pOutList;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR  pPartialOutDesc;

   *POutList_Pointer = NULL;
   *ListSize_Pointer =0;

   // Validate input parameter

   if (PInList == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyclomyBuildResourceList_Error;
   }

   ASSERT(PInList->Count == 1);


   if (PInList->List[0].PartialResourceList.Count < NumberOfResources) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyclomyBuildResourceList_Error;
   }
   
   // Initialize pOutList

   length = sizeof(CM_RESOURCE_LIST) 
            + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * (NumberOfResources - 1);
 
   pOutList = ExAllocatePool(PagedPool, length);
   
   if (pOutList == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyclomyBuildResourceList_Error;
   }

   RtlZeroMemory(pOutList, length);
   
   // Get information from PInList and build pOutList

   pOutList->Count = 1; // not sure if we have to report Translated information too.
   pOutList->List[0].InterfaceType = PInList->List[0].InterfaceType;
   pOutList->List[0].BusNumber     = PInList->List[0].BusNumber;
   pOutList->List[0].PartialResourceList.Count = NumberOfResources;

   pPartialOutDesc = &pOutList->List[0].PartialResourceList.PartialDescriptors[0];
   pPartialInDesc  = &PInList->List[0].PartialResourceList.PartialDescriptors[0];

   for (i=0,j=0; i < PInList->List[0].PartialResourceList.Count; i++,pPartialInDesc++) {
      if (j==NumberOfResources) {
         break;
      }
      switch(pPartialInDesc->Type) {
      case CmResourceTypeMemory:
         pPartialOutDesc->ShareDisposition = CmResourceShareShared;
         pPartialOutDesc->Type             = pPartialInDesc->Type;
         pPartialOutDesc->Flags            = pPartialInDesc->Flags;
         pPartialOutDesc->u.Memory.Start   = pPartialInDesc->u.Memory.Start;
         pPartialOutDesc->u.Memory.Length  = pPartialInDesc->u.Memory.Length;
         pPartialOutDesc++;
         j++;
         break;
      case CmResourceTypeInterrupt:
         pPartialOutDesc->ShareDisposition = CmResourceShareShared;
         pPartialOutDesc->Type             = pPartialInDesc->Type;
         pPartialOutDesc->Flags            = pPartialInDesc->Flags;
         pPartialOutDesc->u.Interrupt.Level    = pPartialInDesc->u.Interrupt.Level;
         pPartialOutDesc->u.Interrupt.Vector   = pPartialInDesc->u.Interrupt.Vector;
         pPartialOutDesc->u.Interrupt.Affinity = pPartialInDesc->u.Interrupt.Affinity;
         pPartialOutDesc++;
         j++;
         break;
      default:
         break;
      } // end switch
   } // end for
   
   *POutList_Pointer = pOutList;
   *ListSize_Pointer = length;

CyclomyBuildResourceList_Error:
   return status;

}


VOID
Cyclomy_Delay(
	ULONG NumberOfMilliseconds
    )
/*--------------------------------------------------------------------------
    Cyclomy_Delay()
    
    Routine Description: Delay routine.
    
    Arguments:
    
    NumberOfMilliseconds - Number of milliseconds to be delayed.
    
    Return Value: none.
--------------------------------------------------------------------------*/
{
    LARGE_INTEGER startOfSpin, nextQuery, difference, delayTime;

    delayTime.QuadPart = NumberOfMilliseconds*10*1000; // unit is 100ns
    KeQueryTickCount(&startOfSpin);

    do {			
        KeQueryTickCount(&nextQuery);
        difference.QuadPart = nextQuery.QuadPart - startOfSpin.QuadPart;
        ASSERT(KeQueryTimeIncrement() <= MAXLONG);
        if (difference.QuadPart * KeQueryTimeIncrement() >= 
                                        delayTime.QuadPart) {
            break;															
        }
    } while (1);

}


ULONG
Cyclomy_DoesBoardExist(
                   IN PFDO_DEVICE_DATA Extension
                   )

/*++

Routine Description:

    This routine examines if the board is present.


Arguments:

    Extension - A pointer to a serial device extension.

Return Value:

    Will return number of ports.

--*/

{
   ULONG numPorts = 0;
   const ULONG CyyCDOffset[] = {	// CD1400 offsets within the board
   0x00000000,0x00000400,0x00000800,0x00000C00,
   0x00000200,0x00000600,0x00000A00,0x00000E00
   };
   ULONG i;
   UCHAR dataread;
   ULONG isPci = Extension->IsPci;

   // Reset the board
   CYY_RESET_BOARD(Extension->BoardMemory, isPci);
   Cyclomy_Delay(1);
   CYY_CLEAR_INTERRUPT(Extension->BoardMemory, isPci);
   Cyclomy_Delay(1);
   
   for (i=0; i < CYY_MAX_CHIPS; i++) {
      Extension->Cd1400Base[i] = Extension->BoardMemory +
                                  (CyyCDOffset[i] << isPci);      
   }

   // Clear all GFRCR's
   for (i=0; i < CYY_MAX_CHIPS; i++) {
      CD1400_WRITE(Extension->Cd1400Base[i],isPci,GFRCR,0x00);      
   }

   // Test CD1400 presence
   for (i=0; i < CYY_MAX_CHIPS; i++) {
      dataread = CD1400_READ(Extension->Cd1400Base[i],isPci,GFRCR);
      //**************************
      // Error Injection
      //dataread = 0xff;
      //**************************
      if (dataread != 0x00) {
         if (i==0) {
            CyyLogError(
                    Extension->DriverObject,
                    Extension->Self,
                    Extension->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    dataread,
                    STATUS_SUCCESS,
                    CYY_GFRCR_FAILURE,
                    0,
                    NULL,
                    0,
                    NULL
                    );
         }
         break;
      }

      dataread = CD1400_READ(Extension->Cd1400Base[i],isPci,CCR);
      //**************************
      // Error Injection
      //dataread = 0xff;
      //**************************
      if (dataread != 0) {
         if (i==0) {
            CyyLogError(
                    Extension->DriverObject,
                    Extension->Self,
                    Extension->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    dataread,
                    STATUS_SUCCESS,
                    CYY_CCR_FAILURE,
                    0,
                    NULL,
                    0,
                    NULL
                    );
         }
         break;
      }

      CD1400_WRITE(Extension->Cd1400Base[i],isPci,CCR,CCR_RESET_CD1400);
      Cyclomy_Delay(1); //KeDelayExecutionThread(KernelMode,FALSE,&d1ms);

      dataread = CD1400_READ(Extension->Cd1400Base[i],isPci,GFRCR);
      if (dataread == 0) {
         Cyclomy_Delay(1); //KeDelayExecutionThread(KernelMode,FALSE,&d1ms);
         dataread = CD1400_READ(Extension->Cd1400Base[i],isPci,GFRCR);
      }

      //**************************
      // Error Injection
      //dataread = 0x55;
      //**************************
      if ((dataread & 0xf0) != 0x40) {

        if (i==0) {
            CyyLogError(
                    Extension->DriverObject,
                    Extension->Self,
                    Extension->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    dataread,
                    STATUS_SUCCESS,
                    CYY_BAD_CD1400_REVISION,
                    0,
                    NULL,
                    0,
                    NULL
                    );
        }
        break;
      }

      // Configure channel 0 serial
      CD1400_WRITE(Extension->Cd1400Base[i],isPci,GCR,GCR_CH0_IS_SERIAL);

      // Configure internal clock to 1ms
      if (dataread > REV_G) {
         CD1400_WRITE(Extension->Cd1400Base[i],isPci,PPR,CLOCK_60_1MS);
      } else {
         CD1400_WRITE(Extension->Cd1400Base[i],isPci,PPR,CLOCK_25_1MS);
      }
   }
   
   numPorts = i*4;

   for (;i < CYY_MAX_CHIPS; i++) {
      Extension->Cd1400Base[i] = NULL;
   }

   return numPorts;

}

VOID
Cyclomy_EnableInterruptInPLX(
      IN PFDO_DEVICE_DATA PDevExt
      )
{
      // Enable PLX interrupts
      if (PDevExt->IsPci){

         UCHAR plx_ver;
         ULONG original;

         plx_ver = CYY_READ_PCI_TYPE(PDevExt->BoardMemory);
         plx_ver &= 0x0f;

         switch(plx_ver) {
         case CYY_PLX9050:
            original = PLX9050_READ_INTERRUPT_CONTROL(PDevExt->Runtime);
            PLX9050_WRITE_INTERRUPT_CONTROL(PDevExt->Runtime,
                                            original|PLX9050_INT_ENABLE);
            break;
         case CYY_PLX9060:
         case CYY_PLX9080:
         default:
            original = PLX9060_READ_INTERRUPT_CONTROL(PDevExt->Runtime);
            PLX9060_WRITE_INTERRUPT_CONTROL(PDevExt->Runtime,
                                            original|PLX9060_INT_ENABLE);
            break;				
         }
	    
      }

}

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
            return "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";
        default:
            return "IRP_MN_?????";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyclom-y\string.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Enumerator Driver
*	
*   This file:      string.c
*	
*   Description:    This module contains the functions used to parse 
*                   the PNP COM ID and save it in the appropriate 
*                   UNICODE STRINGS.  The main function that is called 
*                   is Cyclomy_ParseData.  All other functions are called
*                   by this main function.
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "pch.h"


#define MAX_DEVNODE_NAME        256 // Total size of Device ID

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Cyclomy_InitMultiString)
#endif

NTSTATUS
Cyclomy_InitMultiString(PFDO_DEVICE_DATA FdoData, PUNICODE_STRING MultiString,
                        ...)
/*++

    This routine will take a null terminated list of ascii strings and combine
    them together to generate a unicode multi-string block

Arguments:

    MultiString - a unicode structure in which a multi-string will be built
    ...         - a null terminated list of narrow strings which will be
             combined together. This list must contain at least a
        trailing NULL

Return Value:

    NTSTATUS

--*/
{
   ANSI_STRING ansiString;
   NTSTATUS status;
   PCSTR rawString;
   PWSTR unicodeLocation;
   ULONG multiLength = 0;
   UNICODE_STRING unicodeString;
   va_list ap;
   ULONG i;

   PAGED_CODE();

#if !DBG
   UNREFERENCED_PARAMETER(FdoData);
#endif


   Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE,
                   ("Entering Cyclomy_InitMultiString\n"));

   va_start(ap,MultiString);

   //
   // Make sure that we won't leak memory
   //

   ASSERT(MultiString->Buffer == NULL);

   rawString = va_arg(ap, PCSTR);

   while (rawString != NULL) {
      RtlInitAnsiString(&ansiString, rawString);
      multiLength += RtlAnsiStringToUnicodeSize(&(ansiString));
      rawString = va_arg(ap, PCSTR);
   }

   va_end( ap );

   if (multiLength == 0) {
      //
      // Done
      //
      RtlInitUnicodeString(MultiString, NULL);
      Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE,
                      ("Leaving Cyclomy_InitMultiString (1)\n"));

      return STATUS_SUCCESS;
   }

   //
   // We need an extra null
   //
   multiLength += sizeof(WCHAR);

   MultiString->MaximumLength = (USHORT)multiLength;
   MultiString->Buffer = ExAllocatePool(PagedPool, multiLength);
   MultiString->Length = 0;

   if (MultiString->Buffer == NULL) {
      Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE,
                      ("Leaving Cyclomy_InitMultiString (2)\n"));

      return STATUS_INSUFFICIENT_RESOURCES;
   }

   Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE,
                   ("Allocated %lu bytes for buffer\n", multiLength));

#if DBG
   RtlFillMemory(MultiString->Buffer, multiLength, 0xff);
#endif

   unicodeString.Buffer = MultiString->Buffer;
   unicodeString.MaximumLength = (USHORT) multiLength;

   va_start(ap, MultiString);
   rawString = va_arg(ap, PCSTR);

   while (rawString != NULL) {

      RtlInitAnsiString(&ansiString,rawString);
      status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);

      //
      // We don't allocate memory, so if something goes wrong here,
      // its the function that's at fault
      //
      ASSERT(NT_SUCCESS(status));

      //
      // Check for any commas and replace them with NULLs
      //

      ASSERT(unicodeString.Length % sizeof(WCHAR) == 0);

      for (i = 0; i < (unicodeString.Length / sizeof(WCHAR)); i++) {
         if (unicodeString.Buffer[i] == L'\x2C' ||
             unicodeString.Buffer[i] == L'\x0C' ) {
            unicodeString.Buffer[i] = L'\0';
         }
      }

      Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE, ("unicode buffer: %ws\n",
                                                  unicodeString.Buffer));

      //
      // Move the buffers along
      //
      unicodeString.Buffer += ((unicodeString.Length / sizeof(WCHAR)) + 1);
      unicodeString.MaximumLength -= (unicodeString.Length + sizeof(WCHAR));
      unicodeString.Length = 0;

      //
      // Next
      //

      rawString = va_arg(ap, PCSTR);
   } // while

   va_end(ap);

   ASSERT(unicodeString.MaximumLength == sizeof(WCHAR));

   //
   // Stick the final null there
   //

   Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE, ("unicode buffer last addr: "
                                               "%x\n", unicodeString.Buffer));

   unicodeString.Buffer[0] = L'\0';

   //
   // Include the nulls in the length of the string
   //

   MultiString->Length = (USHORT)multiLength;
   MultiString->MaximumLength = MultiString->Length;

   Cyclomy_KdPrint(FdoData, SER_DBG_SS_TRACE,
                   ("Leaving Cyclomy_InitMultiString (3)\n"));

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyycoins\cyfriend.c ===
/** FILE: cyfriend.c ********** Module Header ********************************
 *
 *
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/

#include "cyyports.h"

//
//  For Cyyport
//
TCHAR y_szCyyPort[] = TEXT("Cyclom-Y Port ");
TCHAR y_szPortIndex[] = TEXT("PortIndex");



BOOL
ReplaceFriendlyName(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PTCHAR           NewComName
)
{

    DEVINST         parentInst;
    HDEVINFO        parentInfo;
    SP_DEVINFO_DATA parentData;
    TCHAR           parentId[MAX_DEVICE_ID_LEN];
    TCHAR           charBuffer[MAX_PATH],
                    deviceDesc[LINE_LEN];
    HKEY            hDeviceKey;
    TCHAR           PortName[20];
    DWORD           PortNameSize,PortIndexSize,PortIndex;
    DWORD           dwErr;
    PTCHAR          comName = NULL;
    DWORD           portNumber = 0;

    //DbgOut(TEXT("ReplaceFriendlyName\n"));

    if((hDeviceKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                          DeviceInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DEV,
                                          KEY_READ)) == INVALID_HANDLE_VALUE) {
        DbgOut(TEXT("SetupDiOpenDevRegKey failed\n"));
        return FALSE;
    }

    PortNameSize = sizeof(PortName);
    dwErr = RegQueryValueEx(hDeviceKey,
                          m_szPortName,
                          NULL,
                          NULL,
                          (PBYTE)PortName,
                          &PortNameSize
                          );

    if (dwErr == ERROR_SUCCESS) {
    PortIndexSize = sizeof(PortIndex);
    dwErr = RegQueryValueEx(hDeviceKey,
                          y_szPortIndex,
                          NULL,
                          NULL,
                          (PBYTE)&PortIndex,
                          &PortIndexSize
                          );
    }

    RegCloseKey(hDeviceKey);

    if(dwErr != ERROR_SUCCESS) {
        DbgOut(TEXT("RegQueryValueEx failed\n"));
        return FALSE;
    }
    if (NewComName == NULL) {
        comName = PortName;
    } else {
        comName = NewComName;
    }
    if (comName == NULL) {
        DbgOut(TEXT("comName NULL\n"));
        return FALSE;
    }

    portNumber = PortIndex+1;

    if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                          DeviceInfoData,
                                          SPDRP_DEVICEDESC,
                                          NULL,
                                          (PBYTE)deviceDesc,
                                          sizeof(deviceDesc),
                                          NULL)) {
        DbgOut(TEXT("Couldn't get Device Description\n"));
        return FALSE;
    }

    if (_tcsnicmp (deviceDesc,y_szCyyPort,_tcslen(y_szCyyPort)) != 0){
        DbgOut(TEXT("Device Description is different of Cyclom-Y Port \n"));
        return FALSE;
    }
    
    if (portNumber == 0) {
        DbgOut(TEXT("Invalid portNumber\n"));
        return FALSE;
    }

    if (CM_Get_Parent(&parentInst,DeviceInfoData->DevInst,0) != CR_SUCCESS) {
        DbgOut(TEXT("CM_Get_Parent failed.\n"));
        return FALSE;
    }

    if (CM_Get_Device_ID(parentInst,parentId,CharSizeOf(parentId),0) != CR_SUCCESS) {
        DbgOut(TEXT("CM_Get_Device_ID failed.\n"));
        return FALSE;
    }

    parentInfo = SetupDiCreateDeviceInfoList(NULL,NULL);

    if (parentInfo == INVALID_HANDLE_VALUE) {
        DbgOut(TEXT("SetupDiCreateDeviceInfoList failed\n"));
        return FALSE;
    }
    
    parentData.cbSize = sizeof(SP_DEVINFO_DATA);

    if (SetupDiOpenDeviceInfo(parentInfo,parentId,NULL,0,&parentData)) {

        if (SetupDiGetDeviceRegistryProperty(parentInfo,
                                             &parentData,
                                             SPDRP_FRIENDLYNAME,
                                             NULL,
                                             (PBYTE)deviceDesc,
                                             sizeof(deviceDesc),
                                             NULL) ||  
            SetupDiGetDeviceRegistryProperty(parentInfo,
                                             &parentData,
                                             SPDRP_DEVICEDESC,
                                             NULL,
                                             (PBYTE)deviceDesc,
                                             sizeof(deviceDesc),
                                             NULL)) {
            wsprintf(charBuffer,TEXT("%s Port %2u (%s)"),deviceDesc,portNumber,comName);
//          #if DBG
//          {
//           TCHAR buf[500];
//           wsprintf(buf, TEXT("%s\n"), charBuffer);
//           DbgOut(buf);
//          }
//          #endif

            SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                             DeviceInfoData,
                                             SPDRP_FRIENDLYNAME,
                                             (PBYTE)charBuffer,
                                              ByteCountOf(_tcslen(charBuffer) + 1)
                                             );

        }

    } else {
        #if DBG
        {
         TCHAR buf[500];
         wsprintf(buf, TEXT("SetupDiOpenDeviceInfo failed with error %x\n"), GetLastError());
         DbgOut(buf);
        }
        #endif
    }
    
    SetupDiDestroyDeviceInfoList(parentInfo);    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyycoins\cyycoins.c ===
/** FILE: cyycoins.c ********** Module Header ********************************
 *
 *  Cyclom-Y device co-installer.
 *
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/
//==========================================================================
//                                Include files
//==========================================================================
// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

// Device Class GUID
#include <initguid.h>
#include <devguid.h>


// Application specific
#include "cyyports.h"
#include <msports.h>
#include "cyydel.h"


//==========================================================================
//                                Globals
//==========================================================================

HANDLE  g_hInst  = NULL;

TCHAR g_szErrMem[ 200 ];            //  Low memory message
TCHAR g_szPortsApplet[ 30 ];        //  "Ports Control Panel Applet" title
TCHAR g_szNull[]  = TEXT("");       //  Null string

TCHAR  m_szColon[]      = TEXT( ":" );
TCHAR  m_szPorts[]      = TEXT( "Ports" );
TCHAR  m_szCOM[]        = TEXT( "COM" );

//
//  NT Registry keys to find COM port to Serial Device mapping
//
TCHAR m_szRegSerialMap[]    = TEXT( "Hardware\\DeviceMap\\SerialComm" );

//
//  Registry Serial Port Advanced I/O settings key and valuenames
//
TCHAR m_szPortName[]        = REGSTR_VAL_PORTNAME;

TCHAR m_szDefParams[]       = TEXT( "9600,n,8,1" );



//==========================================================================
//                            Local Function Prototypes
//==========================================================================

LPTSTR GetDIFString(IN DI_FUNCTION Func);

DWORD
CreateFriendlyName(
    IN     HDEVINFO          DeviceInfoSet,
    IN     PSP_DEVINFO_DATA  DeviceInfoData
);

//==========================================================================
//                                Dll Entry Point
//==========================================================================

BOOL APIENTRY LibMain( HANDLE hDll, DWORD dwReason, LPVOID lpReserved )
{

//#if DBG
//        OutputDebugString(TEXT("cyycoins LibMain entry\n"));
//#endif
   
    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
//#if DBG
//        OutputDebugString(TEXT("cyycoins DLL_PROCESS_ATTACH\n"));
//#endif
        g_hInst = hDll;
        DisableThreadLibraryCalls(hDll);
        InitStrings();

        break;

    case DLL_PROCESS_DETACH:
//#if DBG
//        OutputDebugString(TEXT("cyycoins DLL_PROCESS_DETACH\n"));
//#endif
        break;

    default:
//#if DBG
//        OutputDebugString(TEXT("cyycoins default\n"));
//#endif
        break;
    }

//#if DBG
//        OutputDebugString(TEXT("cyycoins LibMain exit\n"));
//#endif
    return TRUE;
}


void InitStrings(void)
{
    DWORD  dwClass, dwShare;
    TCHAR  szClass[ 40 ];

    LoadString(g_hInst, 
               INITS,
               g_szErrMem,
               CharSizeOf(g_szErrMem));
    LoadString(g_hInst, 
               IDS_CYCLOMY,
               g_szPortsApplet,
               CharSizeOf(g_szPortsApplet));
}


//==========================================================================
//                                Functions
//==========================================================================


HRESULT
CyclomyCoInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA    Context
)
/*++

Routine Description:

    This routine is a Co-Installer for the Cyclom-Y device.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

    Context - Points to a coinstaller-specific context structure for this 
        installation request. 

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/
{
    DWORD   Status = NO_ERROR;

//    #if DBG
//    {
//     TCHAR buf[500];
//     wsprintf(buf, TEXT("CyclomyCoInstaller:InstallFunction(%s) PostProcessing:%d\n"), GetDIFString(InstallFunction), Context->PostProcessing);
//     DbgOut(buf);
//    }
//    #endif

    switch(InstallFunction) {
        case DIF_INSTALLDEVICE :

            //
            // We should not copy any INF files until the install has completed
            // like the primary INF, all secondary INF's must exist on each disk
            // of a multi-disk install.
            //

            if(!Context->PostProcessing){

                DeleteNonPresentDevices();

                Status = ERROR_DI_POSTPROCESSING_REQUIRED;
            } else { 
                // post processing

                //
                // if driver installation failed, we're not interested
                // in processing CopyINF entries.
                //
                if (Context->InstallResult != NO_ERROR) {
                    DbgOut(TEXT("DIF_INSTALLDEVICE PostProcessing on failure"));
                    Status = Context->InstallResult;
                    break;
                }

                CreateFriendlyName(DeviceInfoSet,DeviceInfoData);
            }
            break;

        case DIF_REMOVE:    

            GetParentIdAndRemoveChildren(DeviceInfoData);
            
            break;

        default :
            break;
    }
    return Status;
}


LPTSTR GetDIFString(IN DI_FUNCTION Func)
/*++

Routine Description:

    Given a DI_FUNCTION value, returns a text representation.

Arguments:

    Func - DI_FUNCTON value

Return Value:

    Text string if value is known.  Hex representation if not.

--*/
{
    static TCHAR buf[32];
#define MakeCase(d)  case d: return TEXT(#d)
    switch (Func)
    {
        MakeCase(DIF_SELECTDEVICE);
        MakeCase(DIF_INSTALLDEVICE);
        MakeCase(DIF_ASSIGNRESOURCES);
        MakeCase(DIF_PROPERTIES);
        MakeCase(DIF_REMOVE);
        MakeCase(DIF_FIRSTTIMESETUP);
        MakeCase(DIF_FOUNDDEVICE);
        MakeCase(DIF_SELECTCLASSDRIVERS);
        MakeCase(DIF_VALIDATECLASSDRIVERS);
        MakeCase(DIF_INSTALLCLASSDRIVERS);
        MakeCase(DIF_CALCDISKSPACE);
        MakeCase(DIF_DESTROYPRIVATEDATA);
        MakeCase(DIF_VALIDATEDRIVER);
        MakeCase(DIF_MOVEDEVICE);
        MakeCase(DIF_DETECT);
        MakeCase(DIF_INSTALLWIZARD);
        MakeCase(DIF_DESTROYWIZARDDATA);
        MakeCase(DIF_PROPERTYCHANGE);
        MakeCase(DIF_ENABLECLASS);
        MakeCase(DIF_DETECTVERIFY);
        MakeCase(DIF_INSTALLDEVICEFILES);
        MakeCase(DIF_UNREMOVE);
        MakeCase(DIF_SELECTBESTCOMPATDRV);
        MakeCase(DIF_ALLOW_INSTALL);
        MakeCase(DIF_REGISTERDEVICE);
        MakeCase(DIF_INSTALLINTERFACES);
        MakeCase(DIF_DETECTCANCEL);
        MakeCase(DIF_REGISTER_COINSTALLERS);
        MakeCase(DIF_NEWDEVICEWIZARD_FINISHINSTALL);
        MakeCase(DIF_ADDPROPERTYPAGE_ADVANCED);
        MakeCase(DIF_TROUBLESHOOTER);
        default:
            wsprintf(buf, TEXT("%x"), Func);
            return buf;
    }
}


DWORD
CreateFriendlyName(
    IN     HDEVINFO          DeviceInfoSet,
    IN     PSP_DEVINFO_DATA  DeviceInfoData
)
{   
    HDEVINFO multportInfoSet;
    SP_DEVINFO_DATA multportInfoData;
    TCHAR   charBuffer[MAX_PATH],
            friendlyName[LINE_LEN],
            deviceDesc[LINE_LEN],
            myDeviceDesc[LINE_LEN];
    TCHAR * pBoardNumber;
#define MAX_BOARDS 10
    BYTE    used[MAX_BOARDS];
    DWORD i;
    DWORD retStatus = NO_ERROR;
    DWORD tmpBoardNumber = 0;

    //DbgOut(TEXT("CreateFriendlyName\n"));

    for (i=0; i<MAX_BOARDS; i++) {
        used[i]=FALSE;
    }

    if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                          DeviceInfoData,
                                          SPDRP_DEVICEDESC,
                                          NULL,
                                          (PBYTE)myDeviceDesc,
                                          sizeof(myDeviceDesc),
                                          NULL)) {
        #if DBG
        {
         TCHAR buf[500];
         wsprintf(buf, TEXT("Device Description failed with %x\n"), GetLastError());
         DbgOut(buf);
        }
        #endif
        return retStatus;
    }

    //#if DBG
    //{
    // TCHAR buf[500];
    // wsprintf(buf, TEXT("myDeviceDesc %s\n"), myDeviceDesc);
    // DbgOut(buf);
    //}
    //#endif

    multportInfoSet = SetupDiGetClassDevs(&GUID_DEVCLASS_MULTIPORTSERIAL,NULL,0,0);
    if (multportInfoSet == INVALID_HANDLE_VALUE) {
        // If failure, we will continue installation without creating Friendly Name.
        return retStatus;
    }
    multportInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    for (i=0; SetupDiEnumDeviceInfo(multportInfoSet,i,&multportInfoData);i++) {
        if (SetupDiGetDeviceRegistryProperty(multportInfoSet,
                                             &multportInfoData,
                                             SPDRP_DEVICEDESC,
                                             NULL,
                                             (PBYTE)deviceDesc,
                                             sizeof(deviceDesc),
                                             NULL)) {
            
            if ((multportInfoData.DevInst != DeviceInfoData->DevInst) &&
                _tcscmp (deviceDesc,myDeviceDesc) == 0){

                // Another board with same device description found.

                if (SetupDiGetDeviceRegistryProperty(multportInfoSet,
                                                     &multportInfoData,
                                                     SPDRP_FRIENDLYNAME,
                                                     NULL,
                                                     (PBYTE)friendlyName,
                                                     sizeof(friendlyName),
                                                     NULL)) {
                    
                    pBoardNumber = _tcschr(friendlyName,'#');
                    if (pBoardNumber == NULL) {
                        used[0] = TRUE;
                        continue;
                    }
                    if ((pBoardNumber +1) == NULL) {
                        continue;
                    }
                    tmpBoardNumber = MyAtoi(pBoardNumber+1);
                    if ((tmpBoardNumber > 0) && (tmpBoardNumber < MAX_BOARDS)) {
                        used[tmpBoardNumber] = TRUE;
                    }
                } 
            }
            
        }

        multportInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    }

    SetupDiDestroyDeviceInfoList(multportInfoSet);

    if (used[0]==TRUE) {
        for (i=2; i<MAX_BOARDS; i++) {
            if (used[i] == FALSE) {
                break;
            }
        }
        if (i<MAX_BOARDS) {
            wsprintf(charBuffer, TEXT("%s #%d "), myDeviceDesc, i);
            // Write the string friendly name string out
            SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                             DeviceInfoData,
                                             SPDRP_FRIENDLYNAME,
                                             (PBYTE)charBuffer,
                                             ByteCountOf(lstrlen(charBuffer) + 1)
                                             );

        }
    } else {
        wsprintf(charBuffer, TEXT("%s "), myDeviceDesc);
        // Write the string friendly name string out
        SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_FRIENDLYNAME,
                                         (PBYTE)charBuffer,
                                         ByteCountOf(lstrlen(charBuffer) + 1)
                                         );
    }

    return retStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyycoins\portstr.h ===
#ifndef PORTSTR_H
#define PORTSTR_H

//
//  exported from cyycoins.c
//
extern TCHAR  m_szColon[];
extern TCHAR  m_szComma[];
extern TCHAR  m_szPorts[];
extern TCHAR  m_szCOM[];

extern TCHAR m_szRegSerialMap[];

extern TCHAR m_szPortName[];
extern TCHAR m_szDefParams[];

#endif // PORTSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyycoins\cyyhelp.h ===
// Used by cyycoins.dll and cyycoins.chm

#define IDH_CYYCOINS_NOHELP             1
#define IDH_CYYCOINS_NUM_PORTS          2
#define IDH_CYYCOINS_START_COM          3
#define IDH_CYYCOINS_RESTORE_DEFAULTS   4
#define IDH_CYYCOINS_BUS_TYPE           5
#define IDH_CYYCOINS_CONFIGURATION      6
#define IDH_CYYCOINS_MODEL              7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyycoins\cyydel.c ===
/** FILE: cyydel.c *******************************************************
 *
 *  This module is used by cyycoins.dll and yinfdelete.exe.
 *  Please re-generate both files when cyydel.c is changed.
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/

//==========================================================================
//                                Include files
//==========================================================================
// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
//#include <stdio.h> Used with .exe

// Device Class GUID
#include <initguid.h>
#include <devguid.h>


// Application specific
#include <windows.h>  
#include <tchar.h> // Make all functions UNICODE safe.
#include <cfgmgr32.h>
#include <setupapi.h> // for SetupDiXxx functions.
#include <regstr.h>
#include "cyydel.h"
//#include "yinfdelete.h" Used with .exe


//==========================================================================
//                              Macros
//==========================================================================

#define CharSizeOf(x)   (sizeof(x) / sizeof(*x))
#define ByteCountOf(x)  ((x) * sizeof(TCHAR))

#if DBG
#define DbgOut(Text) OutputDebugString(Text)
#else
#define DbgOut(Text) 
#endif 

//==========================================================================
//                                Globals
//==========================================================================

TCHAR y_szCyclomyEnumerator[] = TEXT("Cyclom-Y");
TCHAR y_szParentIdPrefix[]  = TEXT("ParentIdPrefix");

//==========================================================================
//                            Local Function Prototypes
//==========================================================================

BOOL
IsItCyclomy(
    PTCHAR ptrChar
);

DWORD
RemoveMyChildren(
    PTCHAR ParentIdPrefix
);


//==========================================================================
//                                Functions
//==========================================================================

void
DeleteNonPresentDevices(
)
{
    HDEVINFO MultiportInfoSet, PresentInfoSet;
    SP_DEVINFO_DATA MultiportInfoData, PresentInfoData;
    DWORD i,j;
    DWORD bufType,bufSize;
    DWORD present;
    TCHAR bufChar[256];

    MultiportInfoSet = SetupDiGetClassDevs(&GUID_DEVCLASS_MULTIPORTSERIAL,
                                           0,
                                           0, 
                                           0 ); // All devices, even non present
    if (MultiportInfoSet == INVALID_HANDLE_VALUE) {
        return;
    }

    MultiportInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    for (i=0;SetupDiEnumDeviceInfo(MultiportInfoSet,i,&MultiportInfoData);i++){
        if (SetupDiGetDeviceRegistryProperty(MultiportInfoSet,
                                             &MultiportInfoData,
                                             SPDRP_HARDWAREID, //SPDRP_SERVICE,
                                             &bufType,
                                             (PBYTE) bufChar,
                                             sizeof(bufChar),
                                             NULL)) {
            if (bufType != REG_MULTI_SZ) {
                continue;
            }

            if (!IsItCyclomy(bufChar)) {
                continue;
            }

            // Verify if this cyclom-y is present.
            PresentInfoSet = SetupDiGetClassDevs(&GUID_DEVCLASS_MULTIPORTSERIAL,
                                                 0,
                                                 0, 
                                                 DIGCF_PRESENT ); 
            if (PresentInfoSet == INVALID_HANDLE_VALUE) {
                continue;
            }

            present = FALSE;
            PresentInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            for (j=0;SetupDiEnumDeviceInfo(PresentInfoSet,j,&PresentInfoData);j++) {
                if (MultiportInfoData.DevInst == PresentInfoData.DevInst) {
                    present = TRUE;
                    break;
                }
            }
            if (GetLastError() == ERROR_NO_MORE_ITEMS) {
                if (!present) {
                    //#if DBG
                    //TCHAR   myDevInstId[200];
                    //DWORD   err;
                    //err = CM_Get_Device_ID(MultiportInfoData.DevInst,myDevInstId,
                    //                       sizeof(myDevInstId),0);
                    //if (err==CR_SUCCESS) {
                    //    TCHAR buf[500];
                    //    wsprintf(buf, TEXT("Delete %s\n"), myDevInstId);    
                    //    DbgOut(buf);
                    //}
                    //#endif
                    GetParentIdAndRemoveChildren(&MultiportInfoData);
                    SetupDiCallClassInstaller(DIF_REMOVE,MultiportInfoSet,&MultiportInfoData);
                }
            }

            SetupDiDestroyDeviceInfoList(PresentInfoSet);

        }

    }
    SetupDiDestroyDeviceInfoList(MultiportInfoSet);
}

BOOL
IsItCyclomy(
    PTCHAR ptrChar
)
{

    while (*ptrChar) {
        //_tprintf("%s\n", ptrChar);
        if (_tcsnicmp(ptrChar,
                      TEXT("PCI\\VEN_120E&DEV_010"),
                      _tcslen(TEXT("PCI\\VEN_120E&DEV_010")))
             == 0) {
            return TRUE;
        }
        if (_tcsnicmp(ptrChar,
                      TEXT("YISA"),
                      _tcslen(TEXT("YISA")))
            == 0) {
            return TRUE;
        }
        ptrChar = ptrChar + _tcslen(ptrChar) + 1;
    }
    return FALSE;
}

DWORD
GetParentIdAndRemoveChildren(
    IN PSP_DEVINFO_DATA DeviceInfoData
)
{
    DWORD   dwSize;
    TCHAR   instanceId[MAX_DEVICE_ID_LEN];
    TCHAR   parentIdPrefix[50];
    HKEY    enumKey,instKey;
    BOOL    gotParentIdPrefix;
    DWORD   Status = NO_ERROR;

    if (CM_Get_Device_ID(DeviceInfoData->DevInst,instanceId,CharSizeOf(instanceId),0) ==
        CR_SUCCESS) {

        gotParentIdPrefix = FALSE;
        // Open Registry and retrieve ParentIdPrefix value
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_SYSTEMENUM,0,KEY_READ, 
            &enumKey) == ERROR_SUCCESS) {

            if (RegOpenKeyEx(enumKey,instanceId,0,KEY_READ,&instKey) == ERROR_SUCCESS) {
                
                dwSize = sizeof(parentIdPrefix);
                if (RegQueryValueEx(instKey,y_szParentIdPrefix,NULL,NULL,
                    (PBYTE)parentIdPrefix,&dwSize) == ERROR_SUCCESS) {
                    _tcsupr(parentIdPrefix);
                    gotParentIdPrefix = TRUE;
                            
                }
                RegCloseKey(instKey);
            }
            RegCloseKey(enumKey);
        }
        if (gotParentIdPrefix) {
            Status = RemoveMyChildren(parentIdPrefix);
        }
    }
    return Status;
}


DWORD
RemoveMyChildren(
    PTCHAR ParentIdPrefix
)
{
    HDEVINFO DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD i,err;
    TCHAR portId[MAX_DEVICE_ID_LEN];
    PTCHAR ptrParent;

    DeviceInfoSet = SetupDiGetClassDevs( &GUID_DEVCLASS_PORTS,y_szCyclomyEnumerator,0,0 ); 
    if (DeviceInfoSet == INVALID_HANDLE_VALUE)
    {
        return GetLastError();
    }

    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    for (i=0;SetupDiEnumDeviceInfo(DeviceInfoSet,i,&DeviceInfoData);i++)
    {
        if (CM_Get_Device_ID(DeviceInfoData.DevInst,portId,CharSizeOf(portId),0)
            == CR_SUCCESS) {

            // BUG? For ParentIdPrefix "3&2b41c2e&1f" (12 characters), _tcscspn 
            // always returns 0!! Using _tcsstr instead.
            //position = _tcscspn(portId,ParentIdPrefix);

            ptrParent = _tcsstr(portId,ParentIdPrefix);
            if (ptrParent) {

                if (_tcsnicmp (ptrParent,ParentIdPrefix,_tcslen(ParentIdPrefix))
                    == 0){
                    //
                    // Worker function to remove device.
                    //
                    //#if DBG
                    //{
                    // TCHAR buf[500];
                    // wsprintf(buf, TEXT("Delete %s\n"), portId);    
                    // DbgOut(buf);
                    //}
                    //#endif

                    SetupDiCallClassInstaller(DIF_REMOVE,DeviceInfoSet,&DeviceInfoData);
                }

            }

        }
        DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    }
    SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyycoins\cyydel.h ===
/** FILE: cyydel.h********* Module Header ********************************
 *
 *  Header for cyydel module.
 * 
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/

#ifndef CYYDEL_H
#define CYYDEL_H


//==========================================================================
//                            Function Prototypes
//==========================================================================


void
DeleteNonPresentDevices(
);

DWORD
GetParentIdAndRemoveChildren(
    IN PSP_DEVINFO_DATA DeviceInfoData
);


#endif // CYYDEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyycoins\cyyports.h ===
/** FILE: cyyports.h ********* Module Header ********************************
 *
 *  Control Panel System applet common definitions, resource ids, typedefs,
 *  external declarations and library routine function prototypes.
 *
 * History:
 *
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/
//==========================================================================
//                            Include Files
//==========================================================================

#ifndef PORTS_H
#define PORTS_H

#include <windows.h>
#include <tchar.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <regstr.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include "resource.h"

#include "portstr.h"

#define PORTS        4
#define MAXPORTS    32
#define KEYBZ       4096
#define BUFFER_SIZE 81

#define DEF_BAUD    3       //  1200
#define DEF_WORD    4       //  8 bits
#define DEF_PARITY  2       //  None
#define DEF_STOP    0       //  1
#define DEF_PORT    0       //  Null Port
#define DEF_SHAKE   2       //  None
#define PAR_EVEN    0
#define PAR_ODD     1
#define PAR_NONE    2
#define PAR_MARK    3
#define PAR_SPACE   4
#define STOP_1      0
#define STOP_15     1
#define STOP_2      2
#define FLOW_XON    0
#define FLOW_HARD   1
#define FLOW_NONE   2

//#define MAX_COM_PORT  COMDB_MIN_PORTS_ARBITRATED   // Maximum number of COM ports NT supports
#define MAX_COM_PORT  2048                         // We should support at least 1024 ports.
#define MIN_COM       1                            // Minimum new COM port number

#define POLL_PERIOD_DEFAULT_IDX 1 

//==========================================================================
//                        Definitions
//==========================================================================

//
//  General definitions
//

#define PATHMAX             MAX_PATH


//
//  Help IDs -- for the Ports applet
//
//
#define IDH_HELPFIRST        5000
#define IDH_SYSMENU     (IDH_HELPFIRST + 2000)
#define IDH_MBFIRST     (IDH_HELPFIRST + 2001)
#define IDH_MBLAST      (IDH_HELPFIRST + 2099)
#define IDH_DLGFIRST    (IDH_HELPFIRST + 3000)

#define IDH_MENU_SCHHELP    (IDH_HELPFIRST + MENU_SCHHELP)
#define IDH_MENU_INDHELP    (IDH_HELPFIRST + MENU_INDHELP)
#define IDH_MENU_USEHELP    (IDH_HELPFIRST + MENU_USEHELP)
#define IDH_MENU_ABOUT      (IDH_HELPFIRST + MENU_ABOUT )
#define IDH_MENU_EXIT       (IDH_HELPFIRST + MENU_EXIT)
#define IDH_CHILD_PORTS     (IDH_HELPFIRST + 4 /* CHILD_PORTS */ )
#define IDH_DLG_PORTS2      (IDH_DLGFIRST + DLG_PORTS2)
#define IDH_DLG_PORTS3      (IDH_DLGFIRST + DLG_PORTS3)

//==========================================================================
//                           Typedefs
//==========================================================================
typedef struct {
    SP_DEVINFO_DATA  DeviceInfoData;

    TCHAR ComName[20];
    TCHAR Settings[20];
    
    ULONG BaseAddress;
} PORT_INFO, *PPORT_INFO;

typedef struct _PORTS_WIZARD_DATA {

    HDEVINFO          DeviceInfoSet;
    PSP_DEVINFO_DATA  pDeviceInfoData;

    ULONG BaseAddress;
    ULONG FirstComNumber;

    ULONG PortsCount;
    PPORT_INFO Ports;

    PUINT UsedComNumbers;
    UINT UsedComNumbersCount;

    BOOL IsMulti;
} PORTS_WIZARD_DATA, *PPORTS_WIZARD_DATA;


//==========================================================================
//                              Macros
//==========================================================================

#define CharSizeOf(x)   (sizeof(x) / sizeof(*x))
#define ByteCountOf(x)  ((x) * sizeof(TCHAR))

#if DBG
#define DbgOut(Text) OutputDebugString(Text)
#else
#define DbgOut(Text) 
#endif 

//==========================================================================
//                         External Declarations
//==========================================================================
//
//  DATA


//
//  exported from cpl.c
//

extern HANDLE g_hInst;
extern TCHAR  g_szErrMem[ ];        //  Low memory message
extern TCHAR  g_szPortsApplet[ ];   //  "Ports Control Panel Applet" title
extern TCHAR  g_szNull[];           //  Null string

extern DWORD PollingPeriods[];

extern TCHAR  m_szPorts[];
extern TCHAR  m_szPortName[];

//==========================================================================
//                            Function Prototypes
//==========================================================================

//
//  LibMain module
//

extern 
VOID
InitStrings(void);


//
//  cyfriend.c
//

extern
BOOL
ReplaceFriendlyName(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PTCHAR           NewComName
);


//
//  util.c
//

extern 
LPTSTR 
BackslashTerm(LPTSTR pszPath);

extern 
VOID 
ErrMemDlg(HWND hParent);

extern 
int    
MyAtoi(LPTSTR  string);

extern 
int    
myatoi(LPTSTR pszInt);

extern 
int    
MyMessageBox(HWND hWnd, 
                         DWORD wText, 
                         DWORD wCaption, 
                         DWORD wType, 
                         ...);

extern
int
MyMessageBoxWithErr(
    HWND hWnd, 
	DWORD wText, 
	DWORD wCaption, 
	DWORD wType,
    DWORD wError
    );

extern 
LPTSTR 
MyItoa(INT value, 
           LPTSTR  string, 
           INT  radix);

extern 
LPTSTR 
MyUltoa(unsigned long  value, 
                LPTSTR  string, 
                INT  radix);

extern 
VOID   
SendWinIniChange(LPTSTR szSection);

extern 
LPTSTR 
strscan(LPTSTR pszString, 
                LPTSTR pszTarget);

extern 
VOID
StripBlanks(LPTSTR pszString);


#endif // PORTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyycoins\pp.h ===
#ifndef PP_H
#define PP_H

#define SERIAL_ADVANCED_SETTINGS
#include "msports.h"

#ifdef USE_P_TRACE_ERR
#define P_TRACE_ERR(_x) MessageBox( GetFocus(), TEXT(_x), TEXT("ports traceerr"), MB_OK | MB_ICONINFORMATION );
#define W_TRACE_ERR(_x) MessageBox( GetFocus(), _x, TEXT("ports traceerr"), MB_OK | MB_ICONINFORMATION );
#else
#define P_TRACE_ERR(_x)
#define W_TRACE_ERR(_x)
#endif

#define DO_COM_PORT_RENAMES

#define RX_MIN 1
#define RX_MAX 14
#define TX_MIN 1
#define TX_MAX 16

TCHAR m_szDevMgrHelp[];


//
// Structures
//

typedef struct _PORT_PARAMS
{
   HDEVINFO             DeviceInfoSet;
   PSP_DEVINFO_DATA     DeviceInfoData;
   HCOMDB               hComDB;     
   PBYTE                PortUsage;  
   DWORD                PortUsageSize; 
   BOOL                 ShowStartCom;  
   DWORD                NumChildren;   
   TCHAR                szComName[20]; 
} PORT_PARAMS, *PPORT_PARAMS;

typedef struct
{
   TCHAR            szComName[20];
   HDEVINFO         DeviceInfoSet;
   SP_DEVINFO_DATA  DeviceInfoData;
   HKEY             hDeviceKey;
   DWORD            NewComNum;
} CHILD_DATA, *PCHILD_DATA;

///////////////////////////////////////////////////////////////////////////////////
// Cyclom-Y Property Page Prototypes
///////////////////////////////////////////////////////////////////////////////////

void
InitOurPropParams(
    IN OUT PPORT_PARAMS     Params,
    IN HDEVINFO             DeviceInfoSet,
    IN PSP_DEVINFO_DATA     DeviceInfoData,
    IN PTCHAR               StrSettings
    );

HPROPSHEETPAGE
InitSettingsPage(
    PROPSHEETPAGE *      Psp,
    OUT PPORT_PARAMS    Params
    );

UINT CALLBACK
PortSettingsDlgCallback(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
    );

INT_PTR APIENTRY
PortSettingsDlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
SavePortSettings(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    );

BOOL
SavePortSettingsDlg(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    );

//Cyclom-y
void
RestoreDefaults(
    HWND            DialogHwnd,
    PPORT_PARAMS    Params
    );

ULONG
FillModelAndBusTypeText(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    );

ULONG
FillNumberOfPortsText(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    );

BOOL
FillStartComCb(
    HWND            ParentHwnd,
    PPORT_PARAMS    Params
    );

ULONG
GetPortName(
    IN  DEVINST PortInst,
    IN  OUT TCHAR *ComName,
    IN  ULONG   ComNameSize
    );

DWORD
CheckComRange(
    HWND            ParentHwnd,
    PPORT_PARAMS    Params,
    DWORD           nCom
    );
// Return codes for CheckComRange:
#define COM_RANGE_OK      0
#define COM_RANGE_TOO_BIG 1
#define COM_RANGE_MEM_ERR 2

BOOL
TryToOpen(
    IN PTCHAR szCom
    );

BOOL
NewComAvailable(
    IN PPORT_PARAMS Params,
    IN DWORD        NewComNum
    );

ULONG
GetPortData(
    IN  DEVINST PortInst,
    OUT PCHILD_DATA ChildPtr
    );

void
ClosePortData(
    IN PCHILD_DATA ChildPtr
    );

void
EnactComNameChanges(
    IN HWND             ParentHwnd,
    IN PPORT_PARAMS     Params,
    IN PCHILD_DATA      ChildPtr
    );


// Context help header file and arrays for devmgr ports tab
// Created 2/21/98 by WGruber NTUA and DoronH NTDEV

//
// "Port Settings" Dialog Box
//
#if 0
#define IDH_NOHELP      ((DWORD)-1)

#define IDH_DEVMGR_PORTSET_ADVANCED     15840   // "&Advanced" (Button)
#define IDH_DEVMGR_PORTSET_BPS      15841       // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_DATABITS     15842   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_PARITY       15843   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_STOPBITS     15844   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_FLOW     15845       // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_DEFAULTS     15892   // "&Restore Defaults" (Button)

//
// "Advanced Communications Port Properties" Dialog Box
//
#define IDH_DEVMGR_PORTSET_ADV_USEFIFO  16885   // "&Use FIFO buffers (requires 16550 compatible UART)" (Button)
#define IDH_DEVMGR_PORTSET_ADV_TRANS    16842   // "" (msctls_trackbar32)
#define IDH_DEVMGR_PORTSET_ADV_DEVICES  161027  // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_ADV_RECV         16821       // "" (msctls_trackbar32)
#define IDH_DEVMGR_PORTSET_ADV_NUMBER   16846   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_ADV_DEFAULTS 16844

#endif

#include "cyyhelp.h"

#endif // PP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyycoins\pp.c ===
/*----------------------------------------------------------------------
 file: pp.c - property page

----------------------------------------------------------------------*/
#include "cyyports.h"
#include "pp.h"
#include <htmlhelp.h>

#include <windowsx.h>

//TCHAR m_szDevMgrHelp[]   = _T("devmgr.hlp");
TCHAR m_szCyycoinsHelp[] = _T("cyycoins.chm");
TCHAR y_szNumOfPorts[]   = TEXT("NumOfPorts");

const DWORD HelpIDs[]=
{
    IDC_STATIC,               IDH_CYYCOINS_NOHELP,
    IDC_STATIC_BOARD_DETAILS, IDH_CYYCOINS_NOHELP,
    IDC_STATIC_SETTINGS,      IDH_CYYCOINS_NOHELP,
    IDC_NUM_PORTS,            IDH_CYYCOINS_NUM_PORTS,
    PP_NUM_PORTS,             IDH_CYYCOINS_NUM_PORTS,
    IDC_START_COM,            IDH_CYYCOINS_START_COM,
    PP_START_COM,             IDH_CYYCOINS_START_COM,
    IDC_RESTORE_DEFAULTS,     IDH_CYYCOINS_RESTORE_DEFAULTS,
    IDC_BUS_TYPE,             IDH_CYYCOINS_BUS_TYPE,
    PP_BUS_TYPE,              IDH_CYYCOINS_BUS_TYPE,
    IDC_CONFIGURATION,        IDH_CYYCOINS_CONFIGURATION,
    PP_CONFIGURATION,         IDH_CYYCOINS_CONFIGURATION,
    IDC_MODEL,                IDH_CYYCOINS_MODEL,
    PP_MODEL,                 IDH_CYYCOINS_MODEL,
    0, 0
};

void InitPortParams(
    IN OUT PPORT_PARAMS      Params,
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData
    )
{
    SP_DEVINFO_LIST_DETAIL_DATA detailData;
    HCOMDB                      hComDB;
    DWORD                       maxPortsReported;

    //DbgOut(TEXT("InitPortParams\n"));

    ZeroMemory(Params, sizeof(PORT_PARAMS));

    Params->DeviceInfoSet = DeviceInfoSet;
    Params->DeviceInfoData = DeviceInfoData;

    // Allocate and initialize PortUsage matrix
    ComDBOpen(&hComDB);
    if (hComDB != INVALID_HANDLE_VALUE) {
        ComDBGetCurrentPortUsage(hComDB,
                                 NULL,
                                 0,
                                 CDB_REPORT_BYTES,
                                 &maxPortsReported);

        //#if DBG
        //{
        // TCHAR buf[500];
        // wsprintf(buf, TEXT("maxPortsReported %d\n"),maxPortsReported);
        // DbgOut(buf);
        //}
        //#endif

        if (maxPortsReported != 0) {
            Params->ShowStartCom = TRUE;
            //Params->PortUsage = (PBYTE) LocalAlloc(LPTR,maxPortsReported/8);
            if (maxPortsReported > MAX_COM_PORT) {
                Params->PortUsageSize = maxPortsReported;
            } else {
                Params->PortUsageSize = MAX_COM_PORT;
            }
            Params->PortUsage = (PBYTE) LocalAlloc(LPTR,Params->PortUsageSize/8);
            if (Params->PortUsage != NULL) {
                Params->PortUsageSize = maxPortsReported/8;
                ComDBGetCurrentPortUsage(hComDB,
                                         Params->PortUsage,
                                         Params->PortUsageSize,
                                         CDB_REPORT_BITS,
                                         &maxPortsReported
                                         );
            }
        }

        ComDBClose(hComDB);
    } else {
        // This happens if we don't have sufficient security privileges.
        // GetLastError returns 0 here!!! Some bug in ComDBOpen.
        DbgOut(TEXT("cyycoins ComDBOpen failed.\n"));
    }

    //
    // See if we are being invoked locally or over the network.  If over the net,
    // then disable all possible changes.
    //
    detailData.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
    if (SetupDiGetDeviceInfoListDetail(DeviceInfoSet, &detailData) &&
        detailData.RemoteMachineHandle != NULL) {
        Params->ShowStartCom = FALSE;
    }

}

HPROPSHEETPAGE InitSettingsPage(PROPSHEETPAGE *     psp,
                                OUT PPORT_PARAMS    Params)
{
    //
    // Add the Port Settings property page
    //
    psp->dwSize      = sizeof(PROPSHEETPAGE);
    psp->dwFlags     = PSP_USECALLBACK; // | PSP_HASHELP;
    psp->hInstance   = g_hInst;
    psp->pszTemplate = MAKEINTRESOURCE(DLG_PP_PORTSETTINGS);

    //
    // following points to the dlg window proc
    //
    psp->pfnDlgProc = PortSettingsDlgProc;
    psp->lParam     = (LPARAM) Params;

    //
    // following points to some control callback of the dlg window proc
    //
    psp->pfnCallback = PortSettingsDlgCallback;

    //
    // allocate our "Ports Setting" sheet
    //
    return CreatePropertySheetPage(psp);
}

/*++

Routine Description: CyclomyPropPageProvider

    Entry-point for adding additional device manager property
    sheet pages.  Registry specifies this routine under
    Control\Class\PortNode::EnumPropPage32="msports.dll,thisproc"
    entry.  This entry-point gets called only when the Device
    Manager asks for additional property pages.

Arguments:

    Info  - points to PROPSHEETPAGE_REQUEST, see setupapi.h
    AddFunc - function ptr to call to add sheet.
    Lparam - add sheet functions private data handle.

Return Value:

    BOOL: FALSE if pages could not be added, TRUE on success

--*/
BOOL APIENTRY CyclomyPropPageProvider(LPVOID               Info,
                                      LPFNADDPROPSHEETPAGE AddFunc,
                                      LPARAM               Lparam
                                      )
{
   PSP_PROPSHEETPAGE_REQUEST pprPropPageRequest;
   PROPSHEETPAGE             psp;
   HPROPSHEETPAGE            hpsp;
   PPORT_PARAMS              params = NULL; 

   //DbgOut(TEXT("cyycoins CyclomyPropPageProvider entry\n"));

   pprPropPageRequest = (PSP_PROPSHEETPAGE_REQUEST) Info;


   //
   // Allocate and zero out memory for the struct that will contain
   // page specific data
   //
   params = (PPORT_PARAMS) LocalAlloc(LPTR, sizeof(PORT_PARAMS));

//******************************************************************
// TEST ERROR
//   if (params)
//        LocalFree(params);
//   params = NULL;
//   
//******************************************************************

   if (!params) {
       ErrMemDlg(GetFocus());
       return FALSE;
   }

   if (pprPropPageRequest->PageRequested == SPPSR_ENUM_ADV_DEVICE_PROPERTIES) {

        InitPortParams(params,
                       pprPropPageRequest->DeviceInfoSet,
                       pprPropPageRequest->DeviceInfoData);

        hpsp = InitSettingsPage(&psp, params);
      
        if (!hpsp) {
            return FALSE;
        }
        
        if (!(*AddFunc)(hpsp, Lparam)) {
            DestroyPropertySheetPage(hpsp);
            return FALSE;
        }
   }

   return TRUE;
} /* CyclomyPropPageProvider */


UINT CALLBACK
PortSettingsDlgCallback(HWND hwnd,
                        UINT uMsg,
                        LPPROPSHEETPAGE ppsp)
{
    PPORT_PARAMS params;

    switch (uMsg) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        //DbgOut(TEXT("PortSettingsDlgCallBack PSPCB_RELEASE\n"));
        params = (PPORT_PARAMS) ppsp->lParam;
        if (params->PortUsage) {
            LocalFree(params->PortUsage);
        }
        LocalFree(params);

        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}

void
Port_OnCommand(
    HWND DialogHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    );

BOOL
Port_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    );

void
Port_OnHelp(
    HWND       DialogHwnd,
    LPHELPINFO HelpInfo
    );

BOOL
Port_OnInitDialog(
    HWND    DialogHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    );

BOOL
Port_OnNotify(
    HWND    DialogHwnd,
    LPNMHDR NmHdr
    );

/*++

Routine Description: PortSettingsDlgProc

    The windows control function for the Port Settings properties window

Arguments:

    hDlg, uMessage, wParam, lParam: standard windows DlgProc parameters

Return Value:

    BOOL: FALSE if function fails, TRUE if function passes

--*/
INT_PTR APIENTRY
PortSettingsDlgProc(IN HWND   hDlg,
                    IN UINT   uMessage,
                    IN WPARAM wParam,
                    IN LPARAM lParam)
{
    switch(uMessage) {
    case WM_COMMAND:
        Port_OnCommand(hDlg, (int) LOWORD(wParam), (HWND)lParam, (UINT)HIWORD(wParam));
        break;

    case WM_CONTEXTMENU:
        return Port_OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP: 
        Port_OnHelp(hDlg, (LPHELPINFO) lParam);
        break;
    
    case WM_INITDIALOG:
        return Port_OnInitDialog(hDlg, (HWND)wParam, lParam); 

    case WM_NOTIFY:
        return Port_OnNotify(hDlg,  (NMHDR *)lParam);
    }

    return FALSE;
} /* PortSettingsDialogProc */

void
Port_OnRestoreDefaultsClicked(
    HWND            DialogHwnd,
    PPORT_PARAMS    Params
    )
{
    RestoreDefaults(DialogHwnd, Params);
    PropSheet_Changed(GetParent(DialogHwnd), DialogHwnd);
}

void
Port_OnCommand(
    HWND DialogHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    )
{
    PPORT_PARAMS params = (PPORT_PARAMS)GetWindowLongPtr(DialogHwnd, DWLP_USER);

    if (NotifyCode == CBN_SELCHANGE) {
        PropSheet_Changed(GetParent(DialogHwnd), DialogHwnd);
    }
    else {
        switch (ControlId) {
        //case IDC_ADVANCED:
        //    Port_OnAdvancedClicked(DialogHwnd, params);
        //    break; 
        //
        case IDC_RESTORE_DEFAULTS:
            Port_OnRestoreDefaultsClicked(DialogHwnd, params);
            break; 
        
        //
        // Because this is a prop sheet, we should never get this.
        // All notifications for ctrols outside of the sheet come through
        // WM_NOTIFY
        //
        case IDCANCEL:
            EndDialog(DialogHwnd, 0); 
            return;
        }
    }
}

BOOL
Port_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
//  WinHelp(HwndControl,
//          m_szCyycoinsHelp, //m_szDevMgrHelp,
//          HELP_CONTEXTMENU,
//          (ULONG_PTR) HelpIDs);
    HtmlHelp(HwndControl,
            m_szCyycoinsHelp,
            HH_TP_HELP_CONTEXTMENU,
            (ULONG_PTR) HelpIDs);

    return FALSE;
}

void
Port_OnHelp(
    HWND       DialogHwnd,
    LPHELPINFO HelpInfo
    )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
//      WinHelp((HWND) HelpInfo->hItemHandle,
//              m_szCyycoinsHelp, //m_szDevMgrHelp,
//              HELP_WM_HELP, 
//              (ULONG_PTR) HelpIDs);
        HtmlHelp((HWND) HelpInfo->hItemHandle,
                m_szCyycoinsHelp,
                HH_TP_HELP_WM_HELP, 
                (ULONG_PTR) HelpIDs);
    }
}

BOOL
Port_OnInitDialog(
    HWND    DialogHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    )
{
    PPORT_PARAMS params;
    DWORD dwError;

    //DbgOut(TEXT("Port_OnInitDialog\n"));

    //
    // on WM_INITDIALOG call, lParam points to the property
    // sheet page.
    //
    // The lParam field in the property sheet page struct is set by the
    // caller. When I created the property sheet, I passed in a pointer
    // to a struct containing information about the device. Save this in
    // the user window long so I can access it on later messages.
    //
    params = (PPORT_PARAMS) ((LPPROPSHEETPAGE)Lparam)->lParam;
    SetWindowLongPtr(DialogHwnd, DWLP_USER, (ULONG_PTR) params);
    

    // Display board details
    FillNumberOfPortsText(DialogHwnd,params);
    FillModelAndBusTypeText(DialogHwnd,params);

    //
    // Set up the combo box with choices
    //
    if (params->ShowStartCom) {
        ComDBOpen(&params->hComDB);
        params->ShowStartCom = FillStartComCb(DialogHwnd, params);
        if (params->hComDB != HCOMDB_INVALID_HANDLE_VALUE) {
            ComDBClose(params->hComDB);
        }
    } else {
        EnableWindow(GetDlgItem(DialogHwnd, PP_START_COM), FALSE);
        EnableWindow(GetDlgItem(DialogHwnd, IDC_START_COM), FALSE);
    }

    return TRUE;  // No need for us to set the focus.
}

BOOL
Port_OnNotify(
    HWND    DialogHwnd,
    LPNMHDR NmHdr
    )
{
    PPORT_PARAMS params = (PPORT_PARAMS)GetWindowLongPtr(DialogHwnd, DWLP_USER);

    switch (NmHdr->code) {
    //
    // Sent when the user clicks on Apply OR OK !!
    //
    case PSN_APPLY:

        //DbgOut(TEXT("Port_OnNotify PSN_APPLY\n"));

        //
        // Write out the com port options to the registry
        //
        if (SavePortSettingsDlg(DialogHwnd, params)) {
            SetWindowLongPtr(DialogHwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
        } else {
            SetWindowLongPtr(DialogHwnd, DWLP_MSGRESULT, PSNRET_INVALID);
        }
        return TRUE;
        
    default:
        //DbgOut(TEXT("Port_OnNotify default\n"));
        return FALSE;
    }
}


ULONG
FillModelAndBusTypeText(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    )
{

    TCHAR szHardwareId[LINE_LEN];
    PTCHAR szCharPtr;
    HWND  detailHwnd;
    TCHAR szBusType[10];
    TCHAR szConfiguration[10];
    TCHAR szModel[10];
    DWORD dataType;

    ZeroMemory(szBusType,sizeof(szBusType));
    ZeroMemory(szConfiguration,sizeof(szConfiguration));
    ZeroMemory(szModel,sizeof(szModel));
    
    if (SetupDiGetDeviceRegistryProperty(Params->DeviceInfoSet,
                                         Params->DeviceInfoData,
                                         SPDRP_HARDWAREID,
                                         &dataType,
                                         (PBYTE) szHardwareId,
                                         sizeof(szHardwareId),
                                         NULL)) {

        szCharPtr = szHardwareId;
        while (*szCharPtr) {
            if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0100&SUBSYS_0100120E"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0100&SUBSYS_0100120E")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));            
                wsprintf(szConfiguration, TEXT("Below 1MB"));
                wsprintf(szModel, TEXT("YeP"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0101&SUBSYS_0100120E"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0101&SUBSYS_0100120E")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));            
                wsprintf(szConfiguration, TEXT("Above 1MB"));
                wsprintf(szModel, TEXT("YeP"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0100"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0100")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));            
                wsprintf(szConfiguration, TEXT("Below 1MB"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0101"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0101")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));            
                wsprintf(szConfiguration, TEXT("Above 1MB"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0102"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0102")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));
                wsprintf(szConfiguration, TEXT("Below 1MB"));
                wsprintf(szModel, TEXT("4YP"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0103"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0103")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));
                wsprintf(szConfiguration, TEXT("Above 1MB"));
                wsprintf(szModel, TEXT("4YP"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0104"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0104")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));
                wsprintf(szConfiguration, TEXT("Below 1MB"));
                wsprintf(szModel, TEXT("8YP"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("PCI\\VEN_120E&DEV_0105"),
                          _tcslen(TEXT("PCI\\VEN_120E&DEV_0105")))
                 == 0) {
                wsprintf(szBusType, TEXT("PCI"));
                wsprintf(szConfiguration, TEXT("Above 1MB"));
                wsprintf(szModel, TEXT("8YP"));
                break;
            } else if (_tcsnicmp(szCharPtr,
                          TEXT("YISA"),
                          _tcslen(TEXT("YISA")))
                == 0) {
                wsprintf(szBusType, TEXT("ISA"));
            }   break;
            szCharPtr = szCharPtr + _tcslen(szCharPtr) + 1;
        }

        if (*szBusType) {
            detailHwnd = GetDlgItem(DialogHwnd, PP_BUS_TYPE);
            SetWindowText(detailHwnd,szBusType);
        }
        if (*szConfiguration) {
            detailHwnd = GetDlgItem(DialogHwnd, IDC_CONFIGURATION);
            SetWindowText(detailHwnd,TEXT("Configuration:"));
            detailHwnd = GetDlgItem(DialogHwnd, PP_CONFIGURATION);
            SetWindowText(detailHwnd,szConfiguration);
        }
        if (*szModel) {
            detailHwnd = GetDlgItem(DialogHwnd, IDC_MODEL);
            SetWindowText(detailHwnd,TEXT("Model:"));
            detailHwnd = GetDlgItem(DialogHwnd, PP_MODEL);
            SetWindowText(detailHwnd,szModel);
        }
    }

    return ERROR_SUCCESS;
    
}

ULONG
FillNumberOfPortsText(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    )
{
    HKEY  hDeviceKey;
    DWORD err,numOfPortsSize,numOfPorts;
    HWND  numportHwnd;
    TCHAR szText[10];

    err = ERROR_SUCCESS;

    if((hDeviceKey = SetupDiOpenDevRegKey(Params->DeviceInfoSet,
                                          Params->DeviceInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DEV,
                                          KEY_READ)) == INVALID_HANDLE_VALUE) {
        err = GetLastError();
        goto FillNPortsExit;
    }

    numOfPortsSize = sizeof(numOfPorts);
    err = RegQueryValueEx(hDeviceKey,
                          y_szNumOfPorts,
                          NULL,
                          NULL,
                          (PBYTE)&numOfPorts,
                          &numOfPortsSize
                         );
//********************************************************
// TEST ERROR
//    err=ERROR_REGISTRY_CORRUPT;
//********************************************************

    RegCloseKey(hDeviceKey);

    if(err != ERROR_SUCCESS) {
        goto FillNPortsExit;
    }

    numportHwnd = GetDlgItem(DialogHwnd, PP_NUM_PORTS);
    wsprintf(szText, TEXT("%d"),numOfPorts);
    SetWindowText(numportHwnd,szText);


FillNPortsExit:

    //if (err != ERROR_SUCCESS) {
    //    MyMessageBoxWithErr(DialogHwnd,IDS_NUM_PORTS_DISABLED,IDS_CYCLOMY,MB_ICONWARNING,err);
    //}

    return err;
}


/*++

Routine Description: FillStartComCb

    fill in the Port Name combo box selection with a list
    of possible un-used portnames

Arguments:

    poppOurPropParams: where to save the data to
    hDlg:              address of the window

Return Value:

    BOOL: TRUE if StartCom CB displayed with no errors

--*/
BOOL
FillStartComCb(
    HWND            ParentHwnd,
    PPORT_PARAMS    Params
    )
{
    int   i, j, nEntries;
    DWORD   nCurPortNum = 0;
    DWORD   nCom; // Changed from int to DWORD (Fanny)
    DWORD dwError;
    TCHAR szCom[40];
    TCHAR szInUse[40];
    char  mask, *current;
    HWND  portHwnd;
    DEVINST devInst,newInst;

    //DbgOut(TEXT("FillStartComCb\n"));

    portHwnd = GetDlgItem(ParentHwnd, PP_START_COM);

    if (Params->hComDB == HCOMDB_INVALID_HANDLE_VALUE) {
        // This happens if we don't have sufficient security privileges.
        EnableWindow(portHwnd, FALSE);
        EnableWindow(GetDlgItem(ParentHwnd, IDC_START_COM), FALSE);
        return 0;
    }

    if (Params->PortUsage == NULL || Params->PortUsageSize == 0) {
        MyMessageBox(ParentHwnd,
                     IDS_MEM_ALLOC_WRN,
                     IDS_CYCLOMY,
                     MB_ICONWARNING);
        EnableWindow(portHwnd, FALSE);
        EnableWindow(GetDlgItem(ParentHwnd, IDC_START_COM), FALSE);
        return 0;
    }

    if (!LoadString(g_hInst, IDS_IN_USE, szInUse, CharSizeOf(szInUse))) {
        wcscpy(szInUse, _T(" (in use)"));
    }

    //
    // first tally up which ports NOT to offer in list box, ie, 
    // my ports should not appear as In Use.
    //
    if (CM_Get_Child(&devInst,(Params->DeviceInfoData)->DevInst,0) == CR_SUCCESS) {
        if ((dwError=GetPortName(devInst,Params->szComName,sizeof(Params->szComName))) != ERROR_SUCCESS) {
            MyMessageBoxWithErr(ParentHwnd,IDS_START_COM_DISABLED,IDS_CYCLOMY,MB_ICONWARNING,dwError);
            EnableWindow(portHwnd, FALSE);
            EnableWindow(GetDlgItem(ParentHwnd, IDC_START_COM), FALSE);
            return 0;
        }

        nCurPortNum = myatoi(&Params->szComName[3]);
        //nCom = myatoi(&szCom[3]);

        if ((dwError=CheckComRange(ParentHwnd,Params,nCurPortNum)) != COM_RANGE_OK) {
            if (dwError == COM_RANGE_TOO_BIG) {
                MyMessageBox(ParentHwnd,IDS_COM_TOO_BIG_WRN,IDS_CYCLOMY,MB_ICONWARNING);
            } else {
                MyMessageBox(ParentHwnd,IDS_MEM_ALLOC_WRN,IDS_CYCLOMY,MB_ICONWARNING);
            }
            EnableWindow(portHwnd, FALSE);
            EnableWindow(GetDlgItem(ParentHwnd, IDC_START_COM), FALSE);
            return 0;
        }

        current = Params->PortUsage + (nCurPortNum-1) / 8;
        if ((i = nCurPortNum % 8))
            *current &= ~(1 << (i-1));
        else
            *current &= ~(0x80);

        Params->NumChildren = 1;

        while (CM_Get_Sibling(&newInst,devInst,0) == CR_SUCCESS) {
            if ((dwError=GetPortName(newInst,szCom,sizeof(szCom))) != ERROR_SUCCESS) {
                MyMessageBoxWithErr(ParentHwnd,IDS_START_COM_DISABLED,IDS_CYCLOMY,MB_ICONWARNING,dwError);
                EnableWindow(portHwnd, FALSE);
                EnableWindow(GetDlgItem(ParentHwnd, IDC_START_COM), FALSE);
                return 0;
            }
            nCom = myatoi(&szCom[3]);

            if ((dwError=CheckComRange(ParentHwnd,Params,nCom)) != COM_RANGE_OK) {
                if (dwError == COM_RANGE_TOO_BIG) {
                    MyMessageBox(ParentHwnd,IDS_COM_TOO_BIG_WRN,IDS_CYCLOMY,MB_ICONWARNING);
                } else {
                    MyMessageBox(ParentHwnd,IDS_MEM_ALLOC_WRN,IDS_CYCLOMY,MB_ICONWARNING);
                }
                EnableWindow(portHwnd, FALSE);
                EnableWindow(GetDlgItem(ParentHwnd, IDC_START_COM), FALSE);
                return 0;
            }
            
            current = Params->PortUsage + (nCom-1) / 8;
            if ((i = nCom % 8))
                *current &= ~(1 << (i-1));
            else
                *current &= ~(0x80);

            Params->NumChildren++;

            devInst = newInst;
        }
    }

    // Fill Start COM Combo Box

    current = Params->PortUsage;
    mask = 0x1;
    for(nEntries = j = 0, i = MIN_COM-1; i < MAX_COM_PORT; i++) {

       wsprintf(szCom, TEXT("COM%d"), i+1);
       if (*current & mask) {
           wcscat(szCom, szInUse);
       }

       if (mask == (char) 0x80) {
           mask = 0x01;
           current++;
       }
       else {
           mask <<= 1;
       }

       ComboBox_AddString(portHwnd, szCom);
   }

   ComboBox_SetCurSel(portHwnd, nCurPortNum-1);

   return 1;
} /* FillStartComCb */



/*++

Routine Description: SavePortSettingsDlg

    save changes in the Cyclom-Y Settings dlg sheet

Arguments:

    Params: where to save the data to
    ParentHwnd:              address of the window

Return Value:

    BOOL: FALSE if function fails, TRUE if function passes

--*/
BOOL
SavePortSettingsDlg(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    )
{
    BOOL retValue = TRUE;

    //
    //  store changes to win.ini; broadcast changes to apps
    //
    if (Params->ShowStartCom) {

        ComDBOpen(&Params->hComDB);

        retValue = SavePortSettings(DialogHwnd, Params);

        if (Params->hComDB != HCOMDB_INVALID_HANDLE_VALUE) {
            ComDBClose(Params->hComDB);
        }
    }
 
    return retValue;
} /* SavePortSettingsDlg */




/*++

Routine Description: SavePortSettings

    Read the dlg screen selections for baudrate, parity, etc.
    If changed from what we started with, then save them

Arguments:

    hDlg:      address of the window
    szComName: which comport we're dealing with
    Params:      contains, baudrate, parity, etc

Return Value:

    BOOL: FALSE if function fails, TRUE if function passes

--*/
BOOL
SavePortSettings(
    IN HWND            DialogHwnd,
    IN PPORT_PARAMS    Params
    )
{

    UINT    startComNum, curComNum, newComNum = CB_ERR;
    DEVINST devInst,newInst;
    TCHAR   buffer[BUFFER_SIZE];
    PCHILD_DATA ChildPtr,VarChildPtr;
    DWORD   numChild=0;
    DWORD   i;
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    retValue = FALSE; // FALSE = failure

    //DbgOut(TEXT("SavePortSettings\n"));

    curComNum = myatoi(Params->szComName + wcslen(m_szCOM));
    newComNum = ComboBox_GetCurSel(GetDlgItem(DialogHwnd, PP_START_COM));

    if (newComNum == CB_ERR) {
        newComNum = curComNum;
    }
    else {
        newComNum++;
    }

    if (newComNum == curComNum) {
        return TRUE;    // No change, so just accept it.
    }

    startComNum = newComNum;

    if (Params->hComDB == HCOMDB_INVALID_HANDLE_VALUE) {
        MyMessageBox(DialogHwnd,IDS_INVALID_HCOMDB,IDS_CYCLOMY,MB_ICONERROR);
        return retValue;
    }

    ChildPtr = (PCHILD_DATA) LocalAlloc(LPTR,Params->NumChildren * sizeof(CHILD_DATA));
    if (ChildPtr == NULL) {
        MyMessageBox(DialogHwnd, IDS_MEM_ALLOC_ERR, IDS_CYCLOMY, MB_ICONERROR);
        return retValue;
    }

    VarChildPtr = ChildPtr;

    if (CM_Get_Child(&devInst,(Params->DeviceInfoData)->DevInst,0) == CR_SUCCESS) {
        if ((dwError = GetPortData(devInst,VarChildPtr)) != ERROR_SUCCESS) {
            MyMessageBoxWithErr(DialogHwnd,IDS_START_COM_NOT_CHANGED,IDS_CYCLOMY,
                                MB_ICONERROR,dwError);
            //ComboBox_SetCurSel(GetDlgItem(DialogHwnd,PP_START_COM), curComNum-1);
            goto Return;
        }

        numChild++;
        if (!QueryDosDevice(VarChildPtr->szComName, buffer, BUFFER_SIZE-1)) {
            dwError = GetLastError();
            MyMessageBoxWithErr(DialogHwnd, IDS_START_COM_NOT_CHANGED, IDS_CYCLOMY,
                         MB_ICONERROR,dwError);
            //ComboBox_SetCurSel(GetDlgItem(DialogHwnd,PP_START_COM), curComNum-1);
            goto Return;
        }
        //#if DBG
        //{
        //TCHAR buf[500];
        //wsprintf(buf, TEXT("QueryDosDevice(%s,buffer,%d) returned %s\n"),VarChildPtr->szComName,BUFFER_SIZE-1,buffer);
        //DbgOut(buf);
        //}
        //#endif
        
        if (TryToOpen(VarChildPtr->szComName) == FALSE) {
            dwError = GetLastError();
            MyMessageBox(DialogHwnd, IDS_PORT_OPEN_ERROR,IDS_CYCLOMY,MB_ICONERROR,
                         VarChildPtr->szComName);
            //ComboBox_SetCurSel(GetDlgItem(DialogHwnd,PP_START_COM), curComNum-1);
            goto Return;
        }

        if ((dwError = CheckComRange(DialogHwnd,Params,newComNum)) != COM_RANGE_OK) {
            if (dwError == COM_RANGE_TOO_BIG) {
                MyMessageBox(DialogHwnd, IDS_COM_TOO_BIG_ERR,IDS_CYCLOMY,MB_ICONERROR);
            } else {
                MyMessageBox(DialogHwnd, IDS_MEM_ALLOC_ERR,IDS_CYCLOMY,MB_ICONERROR);
            }
            //ComboBox_SetCurSel(GetDlgItem(DialogHwnd,PP_START_COM), curComNum-1);
            goto Return;
        }

        if (!NewComAvailable(Params,newComNum)) {
            MyMessageBox(DialogHwnd, IDS_PORT_IN_USE_ERROR, IDS_CYCLOMY,MB_ICONERROR);
            //ComboBox_SetCurSel(GetDlgItem(DialogHwnd,PP_START_COM), curComNum-1);
            goto Return;
        }
        VarChildPtr->NewComNum = newComNum;

        while (CM_Get_Sibling(&newInst,devInst,0) == CR_SUCCESS) {
            if (numChild >= Params->NumChildren) {
                // We should never reach here.
                DbgOut(TEXT("cyycoins Somehow I'm getting different number of children this time!\n"));
                break;
            }

            VarChildPtr++;
            if ((dwError=GetPortData(newInst,VarChildPtr)) != ERROR_SUCCESS) {
                MyMessageBoxWithErr(DialogHwnd, IDS_START_COM_NOT_CHANGED, IDS_CYCLOMY,
                                    MB_ICONERROR,dwError);
                goto Return;
            }
            numChild++;

            if (!QueryDosDevice(VarChildPtr->szComName, buffer, BUFFER_SIZE-1)) {
                dwError = GetLastError();
                MyMessageBoxWithErr(DialogHwnd, IDS_START_COM_NOT_CHANGED, IDS_CYCLOMY,
                                    MB_ICONERROR,dwError);
                goto Return;
            }
        
            if (TryToOpen(VarChildPtr->szComName) == FALSE) {
                dwError = GetLastError();
                MyMessageBox(DialogHwnd, IDS_PORT_OPEN_ERROR,IDS_CYCLOMY,
                             MB_ICONERROR,VarChildPtr->szComName);
                goto Return;
            }

            while (1) {
                newComNum++;

                if ((dwError=CheckComRange(DialogHwnd,Params,newComNum)) != COM_RANGE_OK) {
                    if (dwError == COM_RANGE_TOO_BIG) {
                        MyMessageBox(DialogHwnd, IDS_COM_TOO_BIG_ERR,IDS_CYCLOMY,MB_ICONERROR);
                    } else {
                        MyMessageBox(DialogHwnd, IDS_MEM_ALLOC_ERR,IDS_CYCLOMY,MB_ICONERROR);
                    }
                    //ComboBox_SetCurSel(GetDlgItem(DialogHwnd,PP_START_COM), curComNum-1);
                    goto Return;
                }

                if (NewComAvailable(Params,newComNum)) {
                    break;
                }
            }
            VarChildPtr->NewComNum = newComNum;

            devInst = newInst;
        }
    }
    
    if (startComNum < curComNum) {
        VarChildPtr = ChildPtr;
    }
    for (i=0; i<numChild; i++) {

        EnactComNameChanges(DialogHwnd,Params,VarChildPtr);

        if (startComNum < curComNum) {
            VarChildPtr++;
        } else {
            VarChildPtr--;
        }
    }

    retValue = TRUE;    // TRUE = SUCCESS

Return:
    if (ChildPtr) {
        VarChildPtr = ChildPtr;
        for (i=0; i<numChild; i++) {
            ClosePortData(VarChildPtr);
            VarChildPtr++;
        }
        LocalFree(ChildPtr);
    }
    
    return retValue;

} /* SavePortSettings */


void
RestoreDefaults(
    HWND            DialogHwnd,
    PPORT_PARAMS    Params
    )
{
    USHORT ushIndex;

    ushIndex =
        (USHORT) ComboBox_FindString(GetDlgItem(DialogHwnd, PP_START_COM),
                                     -1,
                                     Params->szComName);

    ushIndex = (ushIndex == CB_ERR) ? 0 : ushIndex;

    ComboBox_SetCurSel(GetDlgItem(DialogHwnd, PP_START_COM), ushIndex);
}


void
MigratePortSettings(
    LPCTSTR OldComName,
    LPCTSTR NewComName
    )
{
    TCHAR settings[BUFFER_SIZE];
    TCHAR szNew[20], szOld[20];

    lstrcpy(szOld, OldComName);
    wcscat(szOld, m_szColon);

    lstrcpy(szNew, NewComName);
    wcscat(szNew, m_szColon);

    settings[0] = TEXT('\0');
    GetProfileString(m_szPorts,
                     szOld,
                     TEXT(""),
                     settings,
                     sizeof(settings) / sizeof(TCHAR) );

    //
    // Insert the new key based on the old one
    //
    if (settings[0] == TEXT('\0')) {
        WriteProfileString(m_szPorts, szNew, m_szDefParams);
    }
    else {
        WriteProfileString(m_szPorts, szNew, settings);
    }

    //
    // Notify everybody of the changes and blow away the old key
    //
    SendWinIniChange((LPTSTR)m_szPorts);
    WriteProfileString(m_szPorts, szOld, NULL);
}


void
EnactComNameChanges(
    IN HWND             ParentHwnd,
    IN PPORT_PARAMS     Params,
    IN PCHILD_DATA      ChildPtr)
{
    DWORD  dwNewComNameLen;
    TCHAR  buffer[BUFFER_SIZE];
    TCHAR  szFriendlyNameFormat[LINE_LEN];
    TCHAR  szDeviceDesc[LINE_LEN];
    TCHAR  szNewComName[20];
    UINT   i;
    UINT   curComNum,NewComNum;
 
    SP_DEVINSTALL_PARAMS spDevInstall;

    //DbgOut(TEXT("EnactComNameChanges\n"));

    NewComNum = ChildPtr->NewComNum;
    curComNum = myatoi(ChildPtr->szComName + wcslen(m_szCOM));

    wsprintf(szNewComName, _T("COM%d"), NewComNum);
    dwNewComNameLen = ByteCountOf(wcslen(szNewComName) + 1);


    //
    // Change the name in the symbolic namespace.
    // First try to get what device the old com name mapped to
    // (ie something like \Device\Serial0).  Then remove the mapping.  If
    // the user isn't an admin, then this will fail and the dialog will popup.
    // Finally, map the new name to the old device retrieved from the
    // QueryDosDevice
    //
    //if (updateMapping) 
    {
        BOOL removed;
        HKEY hSerialMap;

        if (!QueryDosDevice(ChildPtr->szComName, buffer, BUFFER_SIZE-1)) {
            //
            // This shouldn't happen because the previous QueryDosDevice call
            // succeeded
            //
            MyMessageBox(ParentHwnd, IDS_PORT_RENAME_ERROR, IDS_CYCLOMY,
                         MB_ICONERROR, curComNum);
            return;
        }


        //
        // If this fails, then the following define will just replace the current
        // mapping.
        //
        removed = DefineDosDevice(DDD_REMOVE_DEFINITION, ChildPtr->szComName, NULL);

        if (!DefineDosDevice(DDD_RAW_TARGET_PATH, szNewComName, buffer)) {


            //
            // error, first fix up the remove definition and restore the old
            // mapping
            //
            if (removed) {
                DefineDosDevice(DDD_RAW_TARGET_PATH, ChildPtr->szComName, buffer);
            }

            MyMessageBox(ParentHwnd, IDS_PORT_RENAME_ERROR, IDS_CYCLOMY,
                         MB_ICONERROR, curComNum);

            return;
        }

        //
        // Set the \\HARDWARE\DEVICEMAP\SERIALCOMM field
        //
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         m_szRegSerialMap,
                         0,
                         KEY_ALL_ACCESS,
                         &hSerialMap) == ERROR_SUCCESS) {

            TCHAR  szSerial[BUFFER_SIZE];
            DWORD  dwSerialSize, dwEnum, dwType, dwComSize;
            TCHAR  szCom[BUFFER_SIZE];

            i = 0;
            do {
                dwSerialSize = CharSizeOf(szSerial);
                dwComSize = sizeof(szCom);
                dwEnum = RegEnumValue(hSerialMap,
                                      i++,
                                      szSerial,
                                      &dwSerialSize,
                                      NULL,
                                      &dwType,
                                      (LPBYTE)szCom,
                                      &dwComSize);

                if (dwEnum == ERROR_SUCCESS) {
                    if(dwType != REG_SZ)
                        continue;

                    if (wcscmp(szCom, ChildPtr->szComName) == 0) {
                        RegSetValueEx(hSerialMap,
                                        szSerial,
                                        0,
                                        REG_SZ,
                                        (PBYTE) szNewComName,
                                        dwNewComNameLen);
                                        break;
                    }
                }

            } while (dwEnum == ERROR_SUCCESS);
        }

        RegCloseKey(hSerialMap);
    }

    //
    // Update the com db
    //
    if (Params->hComDB != HCOMDB_INVALID_HANDLE_VALUE) {

        ComDBReleasePort(Params->hComDB, (DWORD) curComNum);

        ComDBClaimPort(Params->hComDB, (DWORD) NewComNum, TRUE, NULL);
    }

    //
    // Set the friendly name in the form of DeviceDesc (COM#)
    //
    if (ReplaceFriendlyName(ChildPtr->DeviceInfoSet,
                            &ChildPtr->DeviceInfoData,
                            szNewComName) == FALSE) {
        // ReplaceFriendlyName failed. Use original code.
        if (LoadString(g_hInst,
                       IDS_FRIENDLY_FORMAT,
                       szFriendlyNameFormat,
                       CharSizeOf(szFriendlyNameFormat)) &&
            SetupDiGetDeviceRegistryProperty(ChildPtr->DeviceInfoSet,
                                             &ChildPtr->DeviceInfoData,
                                             SPDRP_DEVICEDESC,
                                             NULL,
                                             (PBYTE) szDeviceDesc,
                                             sizeof(szDeviceDesc),
                                             NULL)) {
            wsprintf(buffer, szFriendlyNameFormat, szDeviceDesc, szNewComName);

        }
        else {
            //
            // Use the COM port name straight out
            //
            lstrcpy(buffer, szNewComName);
        }

        SetupDiSetDeviceRegistryProperty(ChildPtr->DeviceInfoSet,
                                         &ChildPtr->DeviceInfoData,
                                         SPDRP_FRIENDLYNAME,
                                         (PBYTE) buffer,
                                         ByteCountOf(wcslen(buffer)+1));
    }

    //
    // Set the parent dialog's title to reflect the change in the com port's name
    //
    //ChangeParentTitle(GetParent(ParentHwnd), AdvancedData->szComName, szNewComName);
    MigratePortSettings(ChildPtr->szComName, szNewComName);

    //
    // Update the PortName value in the devnode
    //
    RegSetValueEx(ChildPtr->hDeviceKey,
                  m_szPortName,
                  0,
                  REG_SZ,
                  (PBYTE)szNewComName,
                  dwNewComNameLen);
    //
    // Now broadcast this change to the device manager
    //

    ZeroMemory(&spDevInstall, sizeof(SP_DEVINSTALL_PARAMS));
    spDevInstall.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if (SetupDiGetDeviceInstallParams(Params->DeviceInfoSet,
                                      Params->DeviceInfoData,
                                      &spDevInstall)) {

        spDevInstall.Flags |= DI_PROPERTIES_CHANGE;
        SetupDiSetDeviceInstallParams(Params->DeviceInfoSet,
                                      Params->DeviceInfoData,
                                      &spDevInstall);
    }
}


BOOL
NewComAvailable(
    IN PPORT_PARAMS Params,
    IN DWORD        NewComNum
)
{
    DWORD i;
    UCHAR mask;

    if ((i = NewComNum % 8))
        mask = 1 << (i-1);
    else
        mask = (char) 0x80;

    if (Params->PortUsage[(NewComNum-1)/8] & mask) {
        //
        // Port has been previously claimed
        //
        return FALSE;
    }

    return TRUE;
}

BOOL
TryToOpen(
    IN PTCHAR szCom
)
{
    TCHAR   szComFileName[20]; // more than enough for "\\.\COMXxxx"
    HANDLE  hCom;

    lstrcpy(szComFileName, L"\\\\.\\");
    lstrcat(szComFileName, szCom);

    //
    // Make sure that the port has not been opened by another application
    //
    hCom = CreateFile(szComFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL, NULL);

    //
    // If the file handle is invalid, then the com port is open, warn the user
    //
    if (hCom == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    CloseHandle(hCom);

    return TRUE;
}

ULONG
GetPortName(
    IN  DEVINST PortInst,
    IN  OUT TCHAR *ComName,
    IN  ULONG   ComNameSize
)
{

    HDEVINFO        portInfo;
    SP_DEVINFO_DATA portData;
    TCHAR           portId[MAX_DEVICE_ID_LEN];
    DWORD           dwPortNameSize, dwError;
    HKEY            hDeviceKey;

    dwError = ERROR_SUCCESS;

    if (CM_Get_Device_ID(PortInst,portId,CharSizeOf(portId),0) == CR_SUCCESS) {
        portInfo = SetupDiCreateDeviceInfoList(NULL,NULL);
        if (portInfo != INVALID_HANDLE_VALUE) {

            portData.cbSize = sizeof(SP_DEVINFO_DATA);
            if (SetupDiOpenDeviceInfo(portInfo,portId,NULL,0,&portData)) {

                hDeviceKey = SetupDiOpenDevRegKey(portInfo,&portData,
                                                  DICS_FLAG_GLOBAL,0,
                                                  DIREG_DEV,KEY_READ);
                if (hDeviceKey == INVALID_HANDLE_VALUE) {
                    dwError = GetLastError();
                }
                    
                dwPortNameSize = ComNameSize;

                dwError = RegQueryValueEx(hDeviceKey,
                                          m_szPortName,  // "PortName"
                                          NULL,
                                          NULL,
                                          (PBYTE)ComName,
                                          &dwPortNameSize);
                if (dwError == ERROR_SUCCESS) {
//                    #if DBG
//                    {
//                     TCHAR buf[500];
//                     wsprintf(buf, TEXT("cyycoins PortName %s\n"),ComName);
//                     DbgOut(buf);
//                    }
//                    #endif
                }

                RegCloseKey(hDeviceKey);

            } else {
                dwError = GetLastError();
            }
            SetupDiDestroyDeviceInfoList(portInfo);

        } else {
            dwError = GetLastError();
        }

    }

    return dwError;
}


ULONG
GetPortData(
    IN  DEVINST PortInst,
    OUT PCHILD_DATA ChildPtr
)
{

    HDEVINFO        portInfo;
    HKEY            hDeviceKey;
    TCHAR           portId[MAX_DEVICE_ID_LEN];
    DWORD           dwPortNameSize,dwError;

    dwError     = ERROR_SUCCESS;
    portInfo    = INVALID_HANDLE_VALUE;
    hDeviceKey  = INVALID_HANDLE_VALUE;

    if (CM_Get_Device_ID(PortInst,portId,CharSizeOf(portId),0) == CR_SUCCESS) {
        portInfo = SetupDiCreateDeviceInfoList(NULL,NULL);
        if (portInfo != INVALID_HANDLE_VALUE) {

            ChildPtr->DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            if (SetupDiOpenDeviceInfo(portInfo,
                                      portId,
                                      NULL,
                                      0,
                                      &ChildPtr->DeviceInfoData)) {

                hDeviceKey = SetupDiOpenDevRegKey(portInfo,&ChildPtr->DeviceInfoData,
                                                  DICS_FLAG_GLOBAL,0,
                                                  DIREG_DEV,KEY_ALL_ACCESS);
                if (hDeviceKey == INVALID_HANDLE_VALUE) {
                    dwError = GetLastError();
                } else {
                    
                    dwPortNameSize = sizeof(ChildPtr->szComName);

                    dwError = RegQueryValueEx(hDeviceKey,
                                              m_szPortName,  // "PortName"
                                              NULL,
                                              NULL,
                                              (PBYTE)ChildPtr->szComName,
                                              &dwPortNameSize);
                    if (dwError != ERROR_SUCCESS) {
                        RegCloseKey(hDeviceKey);
                        hDeviceKey = INVALID_HANDLE_VALUE;
                    }
                }

            } else {
                dwError = GetLastError();
            }
            if (dwError != ERROR_SUCCESS) {
                SetupDiDestroyDeviceInfoList(portInfo);
                portInfo = INVALID_HANDLE_VALUE;
            }

        } else {
            dwError = GetLastError();
        }

    }
    ChildPtr->DeviceInfoSet = portInfo;
    ChildPtr->hDeviceKey = hDeviceKey;
    return dwError;
}


void
ClosePortData(
    IN PCHILD_DATA ChildPtr
)
{
    if (ChildPtr->hDeviceKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(ChildPtr->hDeviceKey);
    }
    if (ChildPtr->DeviceInfoSet != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(ChildPtr->DeviceInfoSet);
    }
}


/*++

Routine Description: CheckComRange

    Returns TRUE if Com port is in the PortUsage range.

Arguments:

    ParentHwnd:         address of the window
    Params:             where to save the data to
    ComPort:            com port to be checked

Return Value:

    COM_RANGE_OK
    COM_RANGE_TOO_BIG
    COM_RANGE_MEM_ERR

--*/
DWORD
CheckComRange(
    HWND            ParentHwnd,
    PPORT_PARAMS    Params,
    DWORD           nCom
)
{
    PBYTE   newPortUsage;
    DWORD   portsReported;
    HCOMDB  hComDB;
    DWORD   comUsageSize = Params->PortUsageSize*8;
    
    if (nCom > MAX_COM_PORT) {
        return COM_RANGE_TOO_BIG;
    }

    if (nCom > comUsageSize) {

        if (comUsageSize < 256) {
            comUsageSize = 256;
        } else if (comUsageSize < 1024) {
            comUsageSize = 1024;
        } else if (comUsageSize < 2048) {
            comUsageSize = 2048;
        } else {
            return COM_RANGE_TOO_BIG;
        }
                
        // Re-alloc to COMDB_MAX_PORTS_ARBITRATED
        newPortUsage = (PBYTE) LocalAlloc(LPTR,comUsageSize/8);
        if (newPortUsage == NULL) {
            return COM_RANGE_MEM_ERR;
                     
        } else {
            //DbgOut(TEXT("Params->PortUsage replaced\n"));
            LocalFree(Params->PortUsage);
            Params->PortUsage = newPortUsage;
            Params->PortUsageSize = comUsageSize/8;
            ComDBGetCurrentPortUsage(Params->hComDB,
                                     NULL,
                                     0,
                                     0,
                                     &portsReported
                                     );
            if (comUsageSize > portsReported) {

                if (ComDBResizeDatabase(Params->hComDB, comUsageSize) != ERROR_SUCCESS){
                    //return COM_RANGE_TOO_BIG; // TODO: Replace by a better message.
                }

            }

            ComDBGetCurrentPortUsage(Params->hComDB,
                                     Params->PortUsage,
                                     Params->PortUsageSize,
                                     CDB_REPORT_BITS,
                                     &portsReported
                                     );
        }
    }

    return COM_RANGE_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyycoins\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cyycoins.rc
//
#define INITS                           0
#define PORTS_ICON                      2
#define DLG_PP_PORTSETTINGS             15
#define IDS_FRIENDLY_FORMAT             29
#define IDS_IN_USE                      61
#define IDS_CYCLOMY                     80
#define IDS_NUM_PORTS_DISABLED          81
#define IDS_START_COM_DISABLED          82
#define IDS_COM_TOO_BIG_WRN             83
#define IDS_MEM_ALLOC_WRN               84
#define IDS_COM_TOO_BIG_ERR             85
#define IDS_MEM_ALLOC_ERR               86
#define IDS_INVALID_HCOMDB              87
#define IDS_START_COM_NOT_CHANGED       88
#define IDS_PORT_OPEN_ERROR             89
#define IDS_PORT_IN_USE_ERROR           90
#define IDS_PORT_RENAME_ERROR           91
#define PP_START_COM                    1038
#define IDC_START_COM                   1040
#define PP_NUM_PORTS                    1044
#define IDC_NUM_PORTS                   1045
#define IDC_RESTORE_DEFAULTS            1046
#define PP_BUS_TYPE                     1047
#define IDC_MODEL                       1052
#define PP_MODEL                        1053
#define IDC_CONFIGURATION               1054
#define PP_CONFIGURATION                1055
#define IDC_BUS_TYPE                    1056
#define IDC_STATIC_BOARD_DETAILS        1057
#define IDC_STATIC_SETTINGS             1058
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1058
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cd1400.h ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Bus/Port Driver
*	
*   This file:      cd1400.h
*	
*   Description:    This file contains the Cirrus CD1400 serial
*                   controller related contants, macros, addresses,
*                   etc.
*
*   Notes:			This code supports Windows 2000 and x86 processor.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/


#ifndef CD1400
#define CD1400 1


/* max number of chars in the FIFO */

#define MAX_CHAR_FIFO   (12)

/* Firmware Revision Code */

#define REV_G		0x46


/* CD1400 registers */

/* Global Registers */

#define GFRCR  (2 * 0x40)
#define CAR    (2 * 0x68)
#define GCR    (2 * 0x4b)
#define SVRR   (2 * 0x67)
#define RICR   (2 * 0x44)
#define TICR   (2 * 0x45)
#define MICR   (2 * 0x46)
#define RIR    (2 * 0x6b)
#define TIR    (2 * 0x6a)
#define MIR    (2 * 0x69)
#define PPR    (2 * 0x7e)

/* Virtual Registers */

#define RIVR   (2 * 0x43)
#define TIVR   (2 * 0x42)
#define MIVR   (2 * 0x41)
#define TDR    (2 * 0x63)
#define RDSR   (2 * 0x62)
#define MISR   (2 * 0x4c)
#define EOSRR  (2 * 0x60)

/* Channel Registers */

#define LIVR   (2 * 0x18)
#define CCR    (2 * 0x05)
#define SRER   (2 * 0x06)
#define COR1   (2 * 0x08)
#define COR2   (2 * 0x09)
#define COR3   (2 * 0x0a)
#define COR4   (2 * 0x1e)
#define COR5   (2 * 0x1f)
#define CCSR   (2 * 0x0b)
#define RDCR   (2 * 0x0e)
#define SCHR1  (2 * 0x1a)
#define SCHR2  (2 * 0x1b)
#define SCHR3  (2 * 0x1c)
#define SCHR4  (2 * 0x1d)
#define SCRL   (2 * 0x22)
#define SCRH   (2 * 0x23)
#define LNC    (2 * 0x24)
#define MCOR1  (2 * 0x15)
#define MCOR2  (2 * 0x16)
#define RTPR   (2 * 0x21)
#define MSVR1  (2 * 0x6c)
#define MSVR2  (2 * 0x6d)
#define PVSR   (2 * 0x6f)
#define RBPR   (2 * 0x78)
#define RCOR   (2 * 0x7c)
#define TBPR   (2 * 0x72)
#define TCOR   (2 * 0x76)


/* Register Settings */

/* Channel Access Register  (CAR) */

#define CHAN0	0x00
#define CHAN1 	0x01
#define CHAN2	0x02
#define CHAN3	0x03
 
/* Channel Option Register 1 (COR1)  */

#define  COR1_NONE_PARITY     0x10
#define  COR1_ODD_PARITY      0xc0
#define  COR1_EVEN_PARITY     0x40
#define  COR1_MARK_PARITY     0xb0
#define  COR1_SPACE_PARITY    0x30
#define  COR1_PARITY_MASK     0xf0
#define  COR1_PARITY_ENABLE_MASK 0x60

#define  COR1_1_STOP    0x00
#define  COR1_1_5_STOP  0x04
#define  COR1_2_STOP    0x08
#define  COR1_STOP_MASK 0x0c

#define  COR1_5_DATA		0x00
#define  COR1_6_DATA		0x01
#define  COR1_7_DATA		0x02
#define  COR1_8_DATA		0x03
#define  COR1_DATA_MASK	0x03

/* Channel Option Register 2  (COR2) */

#define IMPL_XON	0x80
#define AUTO_TXFL	0x40
#define EMBED_TX_ENABLE 0x20
#define LOCAL_LOOP_BCK 	0x10
#define REMOTE_LOOP_BCK 0x08
#define RTS_AUT_OUTPUT	0x04
#define CTS_AUT_ENABLE	0x02

/* Channel Option Register 3  (COR3) */

#define SPL_CH_DRANGE	0x80  /* special character detect range */
#define SPL_CH_DET1	0x40  /* enable special char. detect on SCHR4-SCHR3 */
#define FL_CTRL_TRNSP	0x20  /* Flow Control Transparency */
#define SPL_CH_DET2	0x10  /* Enable spl char. detect on SCHR2-SCHR1 */
#define REC_FIFO_12CH	0x0c  /* Receive FIFO threshold= 12 chars */


/* Global Configuration Register (GCR) values */

#define GCR_CH0_IS_SERIAL	0x00

/* Prescaler Period Register (PPR) values */

#define CLOCK_20_1MS	0x27
#define CLOCK_25_1MS	0x31
#define CLOCK_60_1MS	0x75

/* Channel Command Register (CCR) values */

#define CCR_RESET_CHANNEL           0x80
#define CCR_RESET_CD1400            0x81
#define CCR_FLUSH_TXFIFO            0x82
#define CCR_CORCHG_COR1             0x42
#define CCR_CORCHG_COR2             0x44
#define CCR_CORCHG_COR1_COR2        0x46
#define CCR_CORCHG_COR3             0x48
#define CCR_CORCHG_COR3_COR1        0x4a
#define CCR_CORCHG_COR3_COR2        0x4c
#define CCR_CORCHG_COR1_COR2_COR3   0x4e
#define CCR_SENDSC_SCHR1            0x21
#define CCR_SENDSC_SCHR2            0x22
#define CCR_SENDSC_SCHR3            0x23
#define CCR_SENDSC_SCHR4            0x24
#define CCR_DIS_RX                  0x11
#define CCR_ENA_RX                  0x12
#define CCR_DIS_TX                  0x14
#define CCR_ENA_TX                  0x18
#define CCR_DIS_TX_RX               0x15
#define CCR_DIS_TX_ENA_RX           0x16
#define CCR_ENA_TX_DIS_RX           0x19
#define CCR_ENA_TX_RX               0x1a

/* Service Request Enable Register (SRER) values */

#define SRER_TXRDY         0x04
#define SRER_TXMPTY        0x02


// Read from CD1400 registers

#define CD1400_READ(ChipAddress,IsPci,Register)             \
   (READ_REGISTER_UCHAR((ChipAddress)+((Register)<<(IsPci))))

// Write to CD1400 registers

#define CD1400_WRITE(ChipAddress,IsPci,Register,Value)      \
do                                                          \
{                                                           \
   WRITE_REGISTER_UCHAR(                                    \
      (ChipAddress)+ ((Register) << (IsPci)),               \
      (UCHAR)(Value)                                        \
      );                                                    \
} while (0);

#define CD1400_DISABLE_ALL_INTERRUPTS(ChipAddress,IsPci,CdChannel)  \
do                                                                  \
{                                                                   \
    CD1400_WRITE((ChipAddress),(IsPci),CAR,(CdChannel & 0x03));     \
    CD1400_WRITE((ChipAddress),(IsPci),SRER,0x00);                  \
                                                                    \
} while (0);


#endif /* CD1400 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\com3tst.c ===
#include <windows.h>
#include <stdio.h>

#define NUM     128

DWORD main(int argc, char *argv[], char *envp[])
{
CHAR chBuffer[128];
CHAR RdBuffer[128];
DWORD UseBaud = 9600;
WORD i;
HANDLE hCommPort;
DCB    dcb;
BOOL   bRc;
DWORD  dwNumWritten,dwNumRead,dwErrors;

envp;

if (argc > 1)
    {
    sscanf(argv[1],"%d",&UseBaud);
    }


printf("\n\n *** COMM TEST START ***\n\n");

printf("Opening the comm port for read write\n");

hCommPort = CreateFile(
                       "COM3",
                       GENERIC_READ|GENERIC_WRITE,
                       0, // exclusive
                       NULL, // sec attr
                       OPEN_EXISTING,
                       0,             // no attributes
                       NULL);         // no template

if (hCommPort == (HANDLE)-1)
    {
    printf("FAIL: OpenComm failed rc: %lx\n",hCommPort);
    return -1;
    }


printf("Opening the comm port for read write: SUCCESS hCommPort=%lx\n",hCommPort);

printf("Setting the line characteristics 9600,8,N,1 on comm \n");

dcb.DCBlength   = sizeof(DCB);
// dcb.DCBversion  = 0x0002; in spec not in header


if (!GetCommState(hCommPort,&dcb))
    {
    printf("FAIL: Couldn't get the dcb: %d\n",GetLastError());
    return FALSE;
    }

dcb.BaudRate = UseBaud;

dcb.ByteSize = 8;
dcb.Parity   = NOPARITY;
dcb.StopBits = ONESTOPBIT;

bRc = SetCommState(hCommPort,&dcb);

if (!bRc)
    {
    printf("FAIL: cannot set the comm state rc:%lx\n",bRc);
    return -1;
    }

printf("Setting the line characteristics 9600,8,N,1 on comm: SUCCESS\n");


printf("Filling the buffer with the known chars \n");

for (i=0; i< NUM; i++)
    {
    //chBuffer[i] = 'a';
    chBuffer[i] = (CHAR)i;

    }

printf("Filling the buffer with the known chars : SUCCESS\n");

printf("Dumping the buffer before sending it to comm\n");

for (i=0; i< NUM; i++)
    {
    //printf("%c",RdBuffer[i]);
    printf(" %d ",chBuffer[i]);

    }

printf("\nDumping the buffer before sending it to comm SUCCESS\n");



printf("Filling the Rdbuffer with the known chars (0xFF) to makeit dirty\n");

for (i=0; i< NUM; i++)
    {
    RdBuffer[i] = 0xFF;
    }

printf("Filling the Rdbuffer with the known chars (0xFF): SUCCESS\n");

printf("Writting this buffer to the comm port\n");

bRc = WriteFile( hCommPort,
                 chBuffer,
                 NUM,
                &dwNumWritten,
                 NULL);

if (!bRc)
        {
        printf("FAIL: cannot Write To the comm port:%lx\n",bRc);
        return -1;
        }

printf("Writting this buffer to the comm port: SUCCESS rc:%lx, byteswritten:%lx\n",
                                                     bRc,dwNumWritten);


printf("Reading this buffer from the comm port\n");

bRc = ReadFile( hCommPort,
                RdBuffer,
                NUM,
               &dwNumRead,
                NULL);

if (!bRc)
        {
        printf("FAIL: cannot Read From the comm port:%lx\n",bRc);
        return -1;
        }

printf("Reading this buffer from the comm port: SUCCESS rc:%lx, bytesread:%lx\n",
                                                     bRc,dwNumRead);


printf("Dumping the Rdbuffer with the comm data\n");

for (i=0; i< NUM; i++)
    {
    //printf("%c",RdBuffer[i]);
    printf(" %d ",RdBuffer[i]);

    }

printf("\nDumping the Rdbuffer with the comm data: SUCCESS\n");


printf("Closing the comm port\n");


bRc = ClearCommError(hCommPort,&dwErrors,NULL);

printf("ClearCommError: rc= %lx and dwErrors=%lx\n",bRc,dwErrors);


bRc = CloseHandle(hCommPort);

if (!bRc)
    {
        printf("FAIL: cannot close the comm port:%lx\n",bRc);
        return -1;
    }


printf("\n\n*** COMM TEST OVER*** \n\n");
return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyycoins\util.c ===
/** FILE: util.c *********** Module Header ********************************
 *
 *  Ports applet utility library routines. This file contains string,
 *  cursor, SendWinIniChange() routines.
 *
 * History:
 *  15:30 on Thur  25 Apr 1991  -by-  Steve Cathcart   [stevecat]
 *        Took base code from Win 3.1 source
 *  10:30 on Tues  04 Feb 1992  -by-  Steve Cathcart   [stevecat]
 *        Updated code to latest Win 3.1 sources
 *  15:30 on Thur  03 May 1994  -by-  Steve Cathcart   [stevecat]
 *        Increased  MyMessageBox buffers, Restart dialog changes
 *  17:00 on Mon   18 Sep 1995  -by-  Steve Cathcart   [stevecat]
 *        Changes for product update - SUR release NT v4.0
 *  Nov 1997					-by-  Doron Holan	   [stevecat]
 *        Removed obsolete cpl code
 *
 *  Copyright (C) 1990-1995 Microsoft Corporation
 *
 *************************************************************************/
/* Notes -

    Global Functions:

      U T I L I T Y

        BackslashTerm () - add backslash char to path
        ErrMemDlg () - display Memory Error message box
        MyAtoi () - To convert from Unicode to ANSI string before calling atoi
        myatoi () - local implementation of atoi for Unicode strings
        MyItoa () - To convert from ANSI to Unicode string after calling itoa
        MyMessageBox () - display message to user, with parameters
        MyUltoa () - To convert from Unicode to ANSI string before calling ultoa
        SendWinIniChange () - broadcast system change message via USER
        strscan () - Find a string within another string
        StripBlanks () - Strip leading and trailing blanks from a string


    Local Functions:

 */

//==========================================================================
//                                Include files
//==========================================================================

// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

// Application specific
#include "cyyports.h"


#define INT_SIZE_LENGTH   20
#define LONG_SIZE_LENGTH  40


LPTSTR 
BackslashTerm(LPTSTR pszPath)
{
    LPTSTR pszEnd;

    pszEnd = pszPath + lstrlen(pszPath);

    //
    //  Get the end of the source directory
    //
    switch(*CharPrev(pszPath, pszEnd)) {
    case TEXT('\\'):
    case TEXT(':'):
        break;

    default:
        *pszEnd++ = TEXT('\\');
        *pszEnd = TEXT('\0');
    }

    return pszEnd;
}

void 
ErrMemDlg(HWND hParent)
{
    MessageBox(hParent, g_szErrMem, g_szPortsApplet,
               MB_OK | MB_ICONHAND | MB_SYSTEMMODAL );
}

///////////////////////////////////////////////////////////////////////////////
//
//   MyAtoi
//
//   Desc:  To convert from Unicode to ANSI string before
//          calling CRT atoi and atol functions.
//
///////////////////////////////////////////////////////////////////////////////

int 
MyAtoi(LPTSTR  string)
{
   CHAR   szAnsi[ INT_SIZE_LENGTH ];
   BOOL   fDefCharUsed;

#ifdef UNICODE
   WideCharToMultiByte(CP_ACP, 0, string, INT_SIZE_LENGTH,
                       szAnsi, INT_SIZE_LENGTH, NULL, &fDefCharUsed);

   return atoi(szAnsi);
#else
   return atoi(string);
#endif

}


int 
myatoi(LPTSTR pszInt)
{
    int   retval;
    TCHAR cSave;

    for (retval = 0; *pszInt; ++pszInt) {
        if ((cSave = (TCHAR) (*pszInt - TEXT('0'))) > (TCHAR) 9)
            break;

        retval = (int) (retval * 10 + (int) cSave);
    }
    return (retval);
}



///////////////////////////////////////////////////////////////////////////////
//
//   MyItoa
//
//   Desc:  To convert from ANSI to Unicode string after calling
//          CRT itoa function.
//
///////////////////////////////////////////////////////////////////////////////

LPTSTR 
MyItoa(INT value, LPTSTR string, INT radix)
{
   CHAR   szAnsi[INT_SIZE_LENGTH];

#ifdef UNICODE

   _itoa(value, szAnsi, radix);
   MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szAnsi, -1,
                       string, INT_SIZE_LENGTH );
#else

   _itoa(value, string, radix);

#endif

   return (string);
 
} // end of MyItoa()


LPTSTR 
MyUltoa(unsigned long value, 
		LPTSTR  string, 
		INT  radix)
{
   CHAR   szAnsi[ LONG_SIZE_LENGTH ];

#ifdef UNICODE

   _ultoa(value, szAnsi, radix);
   MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szAnsi, -1,
                       string, LONG_SIZE_LENGTH );
#else

   _ultoa(value, string, radix);

#endif

   return( string );

} // end of MyUltoa()


int 
MyMessageBox(HWND hWnd, 
			 DWORD wText, 
			 DWORD wCaption, 
			 DWORD wType, 
			 ...)
{
    TCHAR   szText[4 * PATHMAX], 
			szCaption[2 * PATHMAX];
    int     ival;
    va_list parg;

    va_start(parg, wType);

    if (wText == INITS)
        goto NoMem;

    if (!LoadString(g_hInst, wText, szCaption, CharSizeOf(szCaption)))
        goto NoMem;

    wvsprintf(szText, szCaption, parg);

    if (!LoadString(g_hInst, wCaption, szCaption, CharSizeOf(szCaption)))
        goto NoMem;

    if ((ival = MessageBox(hWnd, szText, szCaption, wType)) == 0)
        goto NoMem;

    va_end(parg);

    return ival;

NoMem:
    va_end(parg);
    ErrMemDlg(hWnd);

    return 0;
}

int
MyMessageBoxWithErr(
    HWND hWnd, 
	DWORD wText, 
	DWORD wCaption, 
	DWORD wType,
    DWORD wError
    )
{   
    int    ival;
    LPVOID lpMessageBuffer;

    FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL, 
        wError,  
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) &lpMessageBuffer,  
        0,  
        NULL );

    ival = MyMessageBox(hWnd,wText,wCaption,wType,lpMessageBuffer);

    LocalFree( lpMessageBuffer ); // Free the buffer allocated by the system

    return ival;
}

void 
SendWinIniChange(LPTSTR lpSection)
{
// NOTE: We have (are) gone through several iterations of which USER
//       api is the correct one to use.  The main problem for the Control
//       Panel is to avoid being HUNG if another app (top-level window)
//       is HUNG.  Another problem is that we pass a pointer to a message
//       string in our address space.  SendMessage will 'thunk' this properly
//       for each window, but PostMessage and SendNotifyMessage will not.
//       That finally brings us to try to use SendMessageTimeout(). 9/21/92
//
// Try SendNotifyMessage in build 260 or later - kills earlier builds
//    SendNotifyMessage ((HWND)-1, WM_WININICHANGE, 0L, (LONG)lpSection);
//    PostMessage ((HWND)-1, WM_WININICHANGE, 0L, (LONG)lpSection);
//  [stevecat] 4/4/92
//
//    SendMessage ((HWND)-1, WM_WININICHANGE, 0L, (LPARAM)lpSection);
//
    //  NOTE: The final parameter (LPDWORD lpdwResult) must be NULL

    SendMessageTimeout((HWND)-1, 
					   WM_WININICHANGE, 
					   0L, 
					   (WPARAM) lpSection,
					   SMTO_ABORTIFHUNG,
					   1000, 
					   NULL);
}

LPTSTR 
strscan(LPTSTR pszString, 
		LPTSTR pszTarget)
{
    LPTSTR psz;

    if (psz = _tcsstr( pszString, pszTarget))
        return (psz);
    else
        return (pszString + lstrlen(pszString));
}


///////////////////////////////////////////////////////////////////////////////
//
//  StripBlanks()
//
//   Strips leading and trailing blanks from a string.
//   Alters the memory where the string sits.
//
///////////////////////////////////////////////////////////////////////////////

void 
StripBlanks(LPTSTR pszString)
{
    LPTSTR  pszPosn;

    //
    //  strip leading blanks
    //

    pszPosn = pszString;

    while (*pszPosn == TEXT(' '))
        pszPosn++;

    if (pszPosn != pszString)
        lstrcpy(pszString, pszPosn);

    //
    //  strip trailing blanks
    //

    if ((pszPosn = pszString + lstrlen(pszString)) != pszString) {
       pszPosn = CharPrev(pszString, pszPosn);

       while (*pszPosn == TEXT(' '))
           pszPosn = CharPrev(pszString, pszPosn);

       pszPosn = CharNext(pszPosn);

       *pszPosn = TEXT('\0');
    }
}

BOOL ReadRegistryByte(HKEY       hKey,
                      PTCHAR     valueName,
                      PBYTE      regData)
{
    DWORD       regDataType = 0;
    DWORD       regDataSize = 0;

    regDataSize = sizeof(*regData);
    if ((ERROR_SUCCESS != RegQueryValueEx(hKey,
                                          valueName,
                                          NULL,
                                          &regDataType,
                                          regData,
                                          &regDataSize))
        || (regDataSize != sizeof(BYTE))
        || (regDataType != REG_BINARY))
    {
        //
        // Read was unsuccessful  or not a binary value, regData is not set
        //
        return FALSE;
    }

    //
    // Read was a success, regData contains the value read in
    //
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyserial.h ===
/*++

Copyright (c) 1990, 1991, 1992, 1993 - 1997 Microsoft Corporation

Module Name :

    cyserial.h  

Abstract:

    Type definitions and data for the serial port driver
    Modified to contain only 8250 bit definitions. - Fanny

Author:


--*/



//
// Bitmask definitions for accessing the 8250 device registers.
//

//
// These bits define the number of data bits trasmitted in
// the Serial Data Unit (SDU - Start,data, parity, and stop bits)
//
#define SERIAL_DATA_LENGTH_5 0x00
#define SERIAL_DATA_LENGTH_6 0x01
#define SERIAL_DATA_LENGTH_7 0x02
#define SERIAL_DATA_LENGTH_8 0x03


//
// These masks define the interrupts that can be enabled or disabled.
//
//
// This interrupt is used to notify that there is new incomming
// data available.  The SERIAL_RDA interrupt is enabled by this bit.
//
#define SERIAL_IER_RDA   0x01

//
// This interrupt is used to notify that there is space available
// in the transmitter for another character.  The SERIAL_THR
// interrupt is enabled by this bit.
//
#define SERIAL_IER_THR   0x02

//
// This interrupt is used to notify that some sort of error occured
// with the incomming data.  The SERIAL_RLS interrupt is enabled by
// this bit.
#define SERIAL_IER_RLS   0x04

//
// This interrupt is used to notify that some sort of change has
// taken place in the modem control line.  The SERIAL_MS interrupt is
// enabled by this bit.
//
#define SERIAL_IER_MS    0x08


//
// These masks define the values of the interrupt identification
// register.  The low bit must be clear in the interrupt identification
// register for any of these interrupts to be valid.  The interrupts
// are defined in priority order, with the highest value being most
// important.  See above for a description of what each interrupt
// implies.
//
#define SERIAL_IIR_RLS      0x06
#define SERIAL_IIR_RDA      0x04
#define SERIAL_IIR_CTI      0x0c
#define SERIAL_IIR_THR      0x02
#define SERIAL_IIR_MS       0x00

//
// This bit mask get the value of the high two bits of the
// interrupt id register.  If this is a 16550 class chip
// these bits will be a one if the fifo's are enbled, otherwise
// they will always be zero.
//
#define SERIAL_IIR_FIFOS_ENABLED 0xc0

//
// If the low bit is logic one in the interrupt identification register
// this implies that *NO* interrupts are pending on the device.
//
#define SERIAL_IIR_NO_INTERRUPT_PENDING 0x01



//
// These masks define access to the fifo control register.
//

//
// Enabling this bit in the fifo control register will turn
// on the fifos.  If the fifos are enabled then the high two
// bits of the interrupt id register will be set to one.  Note
// that this only occurs on a 16550 class chip.  If the high
// two bits in the interrupt id register are not one then
// we know we have a lower model chip.
//
//
#define SERIAL_FCR_ENABLE     ((UCHAR)0x01)
#define SERIAL_FCR_RCVR_RESET ((UCHAR)0x02)
#define SERIAL_FCR_TXMT_RESET ((UCHAR)0x04)

//
// This set of values define the high water marks (when the
// interrupts trip) for the receive fifo.
//
#define SERIAL_1_BYTE_HIGH_WATER   ((UCHAR)0x00)
#define SERIAL_4_BYTE_HIGH_WATER   ((UCHAR)0x40)
#define SERIAL_8_BYTE_HIGH_WATER   ((UCHAR)0x80)
#define SERIAL_14_BYTE_HIGH_WATER  ((UCHAR)0xc0)

//
// These masks define access to the line control register.
//

//
// This defines the bit used to control the definition of the "first"
// two registers for the 8250.  These registers are the input/output
// register and the interrupt enable register.  When the DLAB bit is
// enabled these registers become the least significant and most
// significant bytes of the divisor value.
//
#define SERIAL_LCR_DLAB     0x80

//
// This defines the bit used to control whether the device is sending
// a break.  When this bit is set the device is sending a space (logic 0).
//
// Most protocols will assume that this is a hangup.
//
#define SERIAL_LCR_BREAK    0x40

//
// These defines are used to set the line control register.
//
#define SERIAL_5_DATA       ((UCHAR)0x00)
#define SERIAL_6_DATA       ((UCHAR)0x01)
#define SERIAL_7_DATA       ((UCHAR)0x02)
#define SERIAL_8_DATA       ((UCHAR)0x03)
#define SERIAL_DATA_MASK    ((UCHAR)0x03)

#define SERIAL_1_STOP       ((UCHAR)0x00)
#define SERIAL_1_5_STOP     ((UCHAR)0x04) // Only valid for 5 data bits
#define SERIAL_2_STOP       ((UCHAR)0x04) // Not valid for 5 data bits
#define SERIAL_STOP_MASK    ((UCHAR)0x04)

#define SERIAL_NONE_PARITY  ((UCHAR)0x00)
#define SERIAL_ODD_PARITY   ((UCHAR)0x08)
#define SERIAL_EVEN_PARITY  ((UCHAR)0x18)
#define SERIAL_MARK_PARITY  ((UCHAR)0x28)
#define SERIAL_SPACE_PARITY ((UCHAR)0x38)
#define SERIAL_PARITY_MASK  ((UCHAR)0x38)

//
// These masks define access the modem control register.
//

//
// This bit controls the data terminal ready (DTR) line.  When
// this bit is set the line goes to logic 0 (which is then inverted
// by normal hardware).  This is normally used to indicate that
// the device is available to be used.  Some odd hardware
// protocols (like the kernel debugger) use this for handshaking
// purposes.
//
#define SERIAL_MCR_DTR      0x01

//
// This bit controls the ready to send (RTS) line.  When this bit
// is set the line goes to logic 0 (which is then inverted by the normal
// hardware).  This is used for hardware handshaking.  It indicates that
// the hardware is ready to send data and it is waiting for the
// receiving end to set clear to send (CTS).
//
#define SERIAL_MCR_RTS      0x02

//
// This bit is used for general purpose output.
//
#define SERIAL_MCR_OUT1     0x04

//
// This bit is used for general purpose output.
//
#define SERIAL_MCR_OUT2     0x08

//
// This bit controls the loopback testing mode of the device.  Basically
// the outputs are connected to the inputs (and vice versa).
//
#define SERIAL_MCR_LOOP     0x10


//
// These masks define access to the line status register.  The line
// status register contains information about the status of data
// transfer.  The first five bits deal with receive data and the
// last two bits deal with transmission.  An interrupt is generated
// whenever bits 1 through 4 in this register are set.
//

//
// This bit is the data ready indicator.  It is set to indicate that
// a complete character has been received.  This bit is cleared whenever
// the receive buffer register has been read.
//
#define SERIAL_LSR_DR       0x01

//
// This is the overrun indicator.  It is set to indicate that the receive
// buffer register was not read befor a new character was transferred
// into the buffer.  This bit is cleared when this register is read.
//
#define SERIAL_LSR_OE       0x02

//
// This is the parity error indicator.  It is set whenever the hardware
// detects that the incoming serial data unit does not have the correct
// parity as defined by the parity select in the line control register.
// This bit is cleared by reading this register.
//
#define SERIAL_LSR_PE       0x04

//
// This is the framing error indicator.  It is set whenever the hardware
// detects that the incoming serial data unit does not have a valid
// stop bit.  This bit is cleared by reading this register.
//
#define SERIAL_LSR_FE       0x08

//
// This is the break interrupt indicator.  It is set whenever the data
// line is held to logic 0 for more than the amount of time it takes
// to send one serial data unit.  This bit is cleared whenever the
// this register is read.
//
#define SERIAL_LSR_BI       0x10

//
// This is the transmit holding register empty indicator.  It is set
// to indicate that the hardware is ready to accept another character
// for transmission.  This bit is cleared whenever a character is
// written to the transmit holding register.
//
#define SERIAL_LSR_THRE     0x20

//
// This bit is the transmitter empty indicator.  It is set whenever the
// transmit holding buffer is empty and the transmit shift register
// (a non-software accessable register that is used to actually put
// the data out on the wire) is empty.  Basically this means that all
// data has been sent.  It is cleared whenever the transmit holding or
// the shift registers contain data.
//
#define SERIAL_LSR_TEMT     0x40

//
// This bit indicates that there is at least one error in the fifo.
// The bit will not be turned off until there are no more errors
// in the fifo.
//
#define SERIAL_LSR_FIFOERR  0x80


//
// These masks are used to access the modem status register.
// Whenever one of the first four bits in the modem status
// register changes state a modem status interrupt is generated.
//

//
// This bit is the delta clear to send.  It is used to indicate
// that the clear to send bit (in this register) has *changed*
// since this register was last read by the CPU.
//
#define SERIAL_MSR_DCTS     0x01

//
// This bit is the delta data set ready.  It is used to indicate
// that the data set ready bit (in this register) has *changed*
// since this register was last read by the CPU.
//
#define SERIAL_MSR_DDSR     0x02

//
// This is the trailing edge ring indicator.  It is used to indicate
// that the ring indicator input has changed from a low to high state.
//
#define SERIAL_MSR_TERI     0x04

//
// This bit is the delta data carrier detect.  It is used to indicate
// that the data carrier bit (in this register) has *changed*
// since this register was last read by the CPU.
//
#define SERIAL_MSR_DDCD     0x08

//
// This bit contains the (complemented) state of the clear to send
// (CTS) line.
//
#define SERIAL_MSR_CTS      0x10

//
// This bit contains the (complemented) state of the data set ready
// (DSR) line.
//
#define SERIAL_MSR_DSR      0x20

//
// This bit contains the (complemented) state of the ring indicator
// (RI) line.
//
#define SERIAL_MSR_RI       0x40

//
// This bit contains the (complemented) state of the data carrier detect
// (DCD) line.
//
#define SERIAL_MSR_DCD      0x80
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyyimmed.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyyimmed.c
*	
*   Description:    This module contains the code related to transmit
*                   immediate character operations in the Cyclom-Y Port
*                   driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#include "precomp.h"

VOID
CyyGetNextImmediate(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    IN PCYY_DEVICE_EXTENSION Extension
    );

VOID
CyyCancelImmediate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
CyyGiveImmediateToIsr(
    IN PVOID Context
    );

BOOLEAN
CyyGrabImmediateFromIsr(
    IN PVOID Context
    );

BOOLEAN
CyyGiveImmediateToIsr(
    IN PVOID Context
    );

BOOLEAN
CyyGrabImmediateFromIsr(
    IN PVOID Context
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,CyyStartImmediate)
#pragma alloc_text(PAGESER,CyyGetNextImmediate)
#pragma alloc_text(PAGESER,CyyCancelImmediate)
#pragma alloc_text(PAGESER,CyyGiveImmediateToIsr)
#pragma alloc_text(PAGESER,CyyGrabImmediateFromIsr)
#endif


VOID
CyyStartImmediate(
    IN PCYY_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine will calculate the timeouts needed for the
    write.  It will then hand the irp off to the isr.  It
    will need to be careful incase the irp has been canceled.

Arguments:

    Extension - A pointer to the serial device extension.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;

    CYY_LOCKED_PAGED_CODE();

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyStartImmediate(%X)\n",
                  Extension);

    UseATimer = FALSE;
    Extension->CurrentImmediateIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(Extension->CurrentImmediateIrp);

    //
    // Calculate the timeout value needed for the
    // request.  Note that the values stored in the
    // timeout record are in milliseconds.  Note that
    // if the timeout values are zero then we won't start
    // the timer.
    //

    KeAcquireSpinLock(
        &Extension->ControlLock,
        &OldIrql
        );

    Timeouts = Extension->Timeouts;

    KeReleaseSpinLock(
        &Extension->ControlLock,
        OldIrql
        );

    if (Timeouts.WriteTotalTimeoutConstant ||
        Timeouts.WriteTotalTimeoutMultiplier) {

        UseATimer = TRUE;

        //
        // We have some timer values to calculate.
        //

        TotalTime.QuadPart 
           = (LONGLONG)((ULONG)Timeouts.WriteTotalTimeoutMultiplier);

        TotalTime.QuadPart += Timeouts.WriteTotalTimeoutConstant;

        TotalTime.QuadPart *= -10000;

    }

    //
    // As the irp might be going to the isr, this is a good time
    // to initialize the reference count.
    //

    SERIAL_INIT_REFERENCE(Extension->CurrentImmediateIrp);

    //
    // We need to see if this irp should be canceled.
    //

    IoAcquireCancelSpinLock(&OldIrql);

    if (Extension->CurrentImmediateIrp->Cancel) {

        PIRP OldIrp = Extension->CurrentImmediateIrp;

        Extension->CurrentImmediateIrp = NULL;
        IoReleaseCancelSpinLock(OldIrql);

        OldIrp->IoStatus.Status = STATUS_CANCELLED;
        OldIrp->IoStatus.Information = 0;

        CyyCompleteRequest(Extension, OldIrp, 0);

    } else {

        //
        // We give the irp to to the isr to write out.
        // We set a cancel routine that knows how to
        // grab the current write away from the isr.
        //

        IoSetCancelRoutine(
            Extension->CurrentImmediateIrp,
            CyyCancelImmediate
            );

        //
        // Since the cancel routine knows about the irp we
        // increment the reference count.
        //

        SERIAL_SET_REFERENCE(
            Extension->CurrentImmediateIrp,
            SERIAL_REF_CANCEL
            );

        if (UseATimer) {

            CyySetTimer(
                &Extension->ImmediateTotalTimer,
                TotalTime,
                &Extension->TotalImmediateTimeoutDpc,
                Extension
                );

            //
            // Since the timer knows about the irp we increment
            // the reference count.
            //

            SERIAL_SET_REFERENCE(
                Extension->CurrentImmediateIrp,
                SERIAL_REF_TOTAL_TIMER
                );

        }

        KeSynchronizeExecution(
            Extension->Interrupt,
            CyyGiveImmediateToIsr,
            Extension
            );

        IoReleaseCancelSpinLock(OldIrql);

    }

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyStartImmediate\n");

}

VOID
CyyCompleteImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PCYY_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyCompleteImmediate(%X)\n",
                  Extension);

    IoAcquireCancelSpinLock(&OldIrql);

    CyyTryToCompleteCurrent(
        Extension,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &Extension->CurrentImmediateIrp,
        NULL,
        NULL,
        &Extension->ImmediateTotalTimer,
        NULL,
        CyyGetNextImmediate,
        SERIAL_REF_ISR
        );

    CyyDpcEpilogue(Extension, Dpc);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyCompleteImmediate\n");

}

VOID
CyyTimeoutImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PCYY_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyTimeoutImmediate(%X)\n",
                  Extension);

    IoAcquireCancelSpinLock(&OldIrql);

    CyyTryToCompleteCurrent(
        Extension,
        CyyGrabImmediateFromIsr,
        OldIrql,
        STATUS_TIMEOUT,
        &Extension->CurrentImmediateIrp,
        NULL,
        NULL,
        &Extension->ImmediateTotalTimer,
        NULL,
        CyyGetNextImmediate,
        SERIAL_REF_TOTAL_TIMER
        );

    CyyDpcEpilogue(Extension, Dpc);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyTimeoutImmediate\n");
}

VOID
CyyGetNextImmediate(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    IN PCYY_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine is used to complete the current immediate
    irp.  Even though the current immediate will always
    be completed and there is no queue associated with it,
    we use this routine so that we can try to satisfy
    a wait for transmit queue empty event.

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.  This should point
                   to CurrentImmediateIrp.

    QueueToProcess - Always NULL.

    NewIrp - Always NULL on exit to this routine.

    CompleteCurrent - Should always be true for this routine.


Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PIRP OldIrp = *CurrentOpIrp;

    UNREFERENCED_PARAMETER(QueueToProcess);
    UNREFERENCED_PARAMETER(CompleteCurrent);
    CYY_LOCKED_PAGED_CODE();

    IoAcquireCancelSpinLock(&OldIrql);

    ASSERT(Extension->TotalCharsQueued >= 1);
    Extension->TotalCharsQueued--;

    *CurrentOpIrp = NULL;
    *NewIrp = NULL;
    KeSynchronizeExecution(
        Extension->Interrupt,
        CyyProcessEmptyTransmit,
        Extension
        );
    IoReleaseCancelSpinLock(OldIrql);

    CyyCompleteRequest(Extension, OldIrp, IO_SERIAL_INCREMENT);
}

VOID
CyyCancelImmediate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel a irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    CYY_LOCKED_PAGED_CODE();

    CyyTryToCompleteCurrent(
        Extension,
        CyyGrabImmediateFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &Extension->CurrentImmediateIrp,
        NULL,
        NULL,
        &Extension->ImmediateTotalTimer,
        NULL,
        CyyGetNextImmediate,
        SERIAL_REF_CANCEL
        );

}

BOOLEAN
CyyGiveImmediateToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    Try to start off the write by slipping it in behind
    a transmit immediate char, or if that isn't available
    and the transmit holding register is empty, "tickle"
    the UART into interrupting with a transmit buffer
    empty.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = Context;
    CYY_LOCKED_PAGED_CODE();

    Extension->TransmitImmediate = TRUE;
    Extension->ImmediateChar =
        *((UCHAR *)
         (Extension->CurrentImmediateIrp->AssociatedIrp.SystemBuffer));
	
    //
    // The isr now has a reference to the irp.
    //

    SERIAL_SET_REFERENCE(
        Extension->CurrentImmediateIrp,
        SERIAL_REF_ISR
        );

    //
    // Check first to see if a write is going on.  If
    // there is then we'll just slip in during the write.
    //

    if (!Extension->WriteLength) {

        //
        // If there is no normal write transmitting then we
        // will "re-enable" the transmit holding register empty
        // interrupt.  The 8250 family of devices will always
        // signal a transmit holding register empty interrupt
        // *ANY* time this bit is set to one.  By doing things
        // this way we can simply use the normal interrupt code
        // to start off this write.
        //
        // We've been keeping track of whether the transmit holding
        // register is empty so it we only need to do this
        // if the register is empty.
        //

        if (Extension->HoldingEmpty) {
            CyyTxStart(Extension);
        }

    }

    return FALSE;

}

BOOLEAN
CyyGrabImmediateFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or canceling, from the ISR

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = Context;
    CYY_LOCKED_PAGED_CODE();

    if (Extension->TransmitImmediate) {

        Extension->TransmitImmediate = FALSE;

        //
        // Since the isr no longer references this irp, we can
        // decrement it's reference count.
        //

        SERIAL_CLEAR_REFERENCE(
            Extension->CurrentImmediateIrp,
            SERIAL_REF_ISR
            );

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyyflush.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyyflush.c
*	
*   Description:    This module contains the code related to flush
*                   operations in the Cyclom-Y Port driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/


#include "precomp.h"



NTSTATUS
CyyStartFlush(
    IN PCYY_DEVICE_EXTENSION Extension
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESRP0,CyyFlush)
#pragma alloc_text(PAGESRP0,CyyStartFlush)
#endif


NTSTATUS
CyyFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*--------------------------------------------------------------------------
    CyyFlush()
    
    Routine Description: This is the dispatch routine for flush.  Flushing
    works by placing this request in the write queue.  When this request
    reaches the front of the write queue we simply complete it since this
    implies that all previous writes have completed.

    Arguments:

    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request

    Return Value: Could return status success, cancelled, or pending.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    PAGED_CODE();

    CyyDbgPrintEx(CYYIRPPATH, "Dispatch entry for: %x\n", Irp);


    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyFlush(%X, %X)\n",
                  DeviceObject, Irp);
    
    Irp->IoStatus.Information = 0L;

    if ((status = CyyIRPPrologue(Irp, Extension)) == STATUS_SUCCESS) {

        if (CyyCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS) {
            CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyFlush (1) %X\n",
                          STATUS_CANCELLED);
            return STATUS_CANCELLED;
        }

        status = CyyStartOrQueue(Extension, Irp, &Extension->WriteQueue,
                                 &Extension->CurrentWriteIrp,
                                 CyyStartFlush);

        CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyFlush (2) %X\n", status);

        return status;

    } else {
        Irp->IoStatus.Status = status;

        if (!NT_SUCCESS(status)) {
            CyyCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
        }

        CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyFlush (3) %X\n", status);
        return status;
    }
    
}

NTSTATUS
CyyStartFlush(
    IN PCYY_DEVICE_EXTENSION Extension
    )
/*--------------------------------------------------------------------------
    CyyStartFlush()
    
    Routine Description: This routine is called if there were no writes in
    the queue. The flush became the current write because there was nothing
    in the queue.  Note however that does not mean there is nothing in the
    queue now!  So, we will start off the write that might follow us.

    Arguments:

    Extension - Points to the serial device extension

    Return Value: This will always return STATUS_SUCCESS.
--------------------------------------------------------------------------*/
{
    PIRP NewIrp;
    PAGED_CODE();

    Extension->CurrentWriteIrp->IoStatus.Status = STATUS_SUCCESS;

    // The following call will actually complete the flush.

    CyyGetNextWrite(
        &Extension->CurrentWriteIrp,
        &Extension->WriteQueue,
        &NewIrp,
        TRUE,
        Extension
        );

    if (NewIrp) {
        ASSERT(NewIrp == Extension->CurrentWriteIrp);
        CyyStartWrite(Extension);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyyhw.h ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Bus/Port Driver
*	
*   This file:      cyyhw.h
*	
*   Description:    This module contains the common hardware declarations 
*                   for the parent driver (cyclom-y) and child driver
*                   (cyyport).
*
*   Notes:          This code supports Windows 2000 and x86 processor.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#ifndef CYYHW_H
#define CYYHW_H


#define MAX_DEVICE_ID_LEN     200	// This definition was copied from NTDDK\inc\cfgmgr32.h
									// Always check if this value was changed. 
									// This is the maximum length for the Hardware ID.

#define CYYPORT_PNP_ID_WSTR         L"Cyclom-Y\\Port"
#define CYYPORT_PNP_ID_STR          "Cyclom-Y\\Port"
#define CYYPORT_DEV_ID_STR          "Cyclom-Y\\Port"

#define CYY_NUMBER_OF_RESOURCES     3     // Memory, PLX Memory, Interrupt


// Cyclom-Y hardware
#define CYY_RUNTIME_LENGTH          0x00000080
#define CYY_MAX_CHIPS 	            8
#define CYY_CHANNELS_PER_CHIP       4
#define CYY_MAX_PORTS	            (CYY_CHANNELS_PER_CHIP*CYY_MAX_CHIPS)

// Custom register offsets
#define CYY_CLEAR_INTR	            0x1800	//Isa; for PCI, multiply by 2
#define CYY_RESET_16	               0x1400	//Isa; for PCI, multiply by 2
#define CYY_PCI_TYPE	               0x3400	//PCI (no need to multiply by 2)

// Values in CYY_PCI_TYPE register
#define CYY_PLX9050		(0x0b)
#define CYY_PLX9060		(0x0c)
#define CYY_PLX9080		(0x0d)

// Runtime registers (or Local Configuration registers)
#define PLX9050_INT_OFFSET	(0x4c)
#define PLX9060_INT_OFFSET	(0x68)
#define PLX9050_INT_ENABLE (0x00000043UL)
#define PLX9060_INT_ENABLE (0x00000900UL)


// Write to Custom registers

#define CYY_RESET_BOARD(BaseBoardAddress,IsPci)             \
do                                                          \
{                                                           \
   WRITE_REGISTER_UCHAR(                                    \
      (BaseBoardAddress)+(CYY_RESET_16 << IsPci),           \
      0x00                                                  \
      );                                                    \
} while (0);


#define CYY_CLEAR_INTERRUPT(BaseBoardAddress,IsPci)         \
do                                                          \
{                                                           \
   WRITE_REGISTER_UCHAR(                                    \
      (BaseBoardAddress)+(CYY_CLEAR_INTR << IsPci),         \
      0x00                                                  \
      );                                                    \
} while (0);

#define CYY_READ_PCI_TYPE(BaseBoardAddress)                 \
   (READ_REGISTER_UCHAR((BaseBoardAddress)+CYY_PCI_TYPE))

#define PLX9050_READ_INTERRUPT_CONTROL(BaseBoardAddress)       \
   (READ_REGISTER_ULONG((PULONG)((BaseBoardAddress)+PLX9050_INT_OFFSET)))

#define PLX9050_WRITE_INTERRUPT_CONTROL(BaseBoardAddress,Value)   \
do {                                                              \
   WRITE_REGISTER_ULONG(                                          \
      (PULONG)((BaseBoardAddress)+PLX9050_INT_OFFSET),            \
      Value                                                       \
      );                                                          \
} while (0);

#define PLX9060_READ_INTERRUPT_CONTROL(BaseBoardAddress)          \
   (READ_REGISTER_ULONG((PULONG)((BaseBoardAddress)+PLX9060_INT_OFFSET)))

#define PLX9060_WRITE_INTERRUPT_CONTROL(BaseBoardAddress,Value)   \
do {                                                              \
   WRITE_REGISTER_ULONG(                                          \
      (PULONG)((BaseBoardAddress)+PLX9060_INT_OFFSET),            \
      Value                                                       \
      );                                                          \
} while (0);

#endif // ndef CYCOMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyymask.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyymask.c
*	
*   Description:    This module contains the code related to get/set/wait
*                   on event mask operations in the Cyclom-Y Port driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/


#include "precomp.h"


BOOLEAN
CyyGrabWaitFromIsr(
    IN PVOID Context
    );

BOOLEAN
CyyGiveWaitToIsr(
    IN PVOID Context
    );

BOOLEAN
CyyFinishOldWait(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,CyyStartMask)
#pragma alloc_text(PAGESER,CyyCancelWait)
#pragma alloc_text(PAGESER,CyyGrabWaitFromIsr)
#pragma alloc_text(PAGESER,CyyGiveWaitToIsr)
#pragma alloc_text(PAGESER,CyyFinishOldWait)
#endif


NTSTATUS
CyyStartMask(
    IN PCYY_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine is used to process the set mask and wait
    mask ioctls.  Calls to this routine are serialized by
    placing irps in the list under the protection of the
    cancel spin lock.

Arguments:

    Extension - A pointer to the serial device extension.

Return Value:

    Will return pending for everything put the first
    request that we actually process.  Even in that
    case it will return pending unless it can complete
    it right away.


--*/

{

    //
    // The current stack location.  This contains much of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    PIRP NewIrp;

    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    CYY_LOCKED_PAGED_CODE();

    CyyDbgPrintEx(CYYDIAG3, "In CyyStartMask\n");

    ASSERT(Extension->CurrentMaskIrp);

    do {

        CyyDbgPrintEx(CYYDIAG4, "STARTMASK - CurrentMaskIrp: %x\n",
                         Extension->CurrentMaskIrp);
        IrpSp = IoGetCurrentIrpStackLocation(Extension->CurrentMaskIrp);

        ASSERT((IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_SERIAL_WAIT_ON_MASK) ||
               (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_SERIAL_SET_WAIT_MASK));

        if (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_SERIAL_SET_WAIT_MASK) {

            CyyDbgPrintEx(CYYDIAG4, "%x is a SETMASK irp\n",
                          Extension->CurrentMaskIrp);

            //
            // Complete the old wait if there is one.
            //

            KeSynchronizeExecution(
                Extension->Interrupt,
                CyyFinishOldWait,
                Extension
                );

            //
            // Any current waits should be on its way to completion
            // at this point.  There certainly shouldn't be any
            // irp mask location.
            //

            ASSERT(!Extension->IrpMaskLocation);

            Extension->CurrentMaskIrp->IoStatus.Status = STATUS_SUCCESS;

            if (!SetFirstStatus) {

                CyyDbgPrintEx(CYYDIAG4, "%x was the first irp processed by "
                              "this\n"
                              "------- invocation of startmask\n",
                              Extension->CurrentMaskIrp);

                FirstStatus = STATUS_SUCCESS;
                SetFirstStatus = TRUE;

            }

            //
            // The following call will also cause the current
            // call to be completed.
            //

            CyyGetNextIrp(
                &Extension->CurrentMaskIrp,
                &Extension->MaskQueue,
                &NewIrp,
                TRUE,
                Extension
                );
            CyyDbgPrintEx(CYYDIAG4, "Perhaps another mask irp was found in "
                          "the queue\n"
                          "------- %x/%x <- values should be the same\n",
                          Extension->CurrentMaskIrp,NewIrp);

        } else {

            //
            // First make sure that we have a non-zero mask.
            // If the app queues a wait on a zero mask it can't
            // be statisfied so it makes no sense to start it.
            //

            if ((!Extension->IsrWaitMask) || (Extension->CurrentWaitIrp)) {

                CyyDbgPrintEx(CYYDIAG4, "WaitIrp is invalid\n"
                              "------- IsrWaitMask: %x\n"
                              "------- CurrentWaitIrp: %x\n",
                              Extension->IsrWaitMask,
                              Extension->CurrentWaitIrp);

                Extension->CurrentMaskIrp->IoStatus.Status 
                   = STATUS_INVALID_PARAMETER;

                if (!SetFirstStatus) {

                    CyyDbgPrintEx(CYYDIAG4, "%x was the first irp processed "
                                  "by this\n"
                                  "------- invocation of startmask\n",
                                  Extension->CurrentMaskIrp);

                    FirstStatus = STATUS_INVALID_PARAMETER;
                    SetFirstStatus = TRUE;

                }

                CyyGetNextIrp(&Extension->CurrentMaskIrp,
                              &Extension->MaskQueue, &NewIrp, TRUE,
                              Extension);

                CyyDbgPrintEx(CYYDIAG4, "Perhaps another mask irp was found "
                              "in the queue\n"
                              "------- %x/%x <- values should be the same\n",
                              Extension->CurrentMaskIrp,NewIrp);

            } else {

                KIRQL OldIrql;

                //
                // Make the current mask irp the current wait irp and
                // get a new current mask irp.  Note that when we get
                // the new current mask irp we DO NOT complete the
                // old current mask irp (which is now the current wait
                // irp.
                //
                // Then under the protection of the cancel spin lock
                // we check to see if the current wait irp needs to
                // be canceled
                //

                IoAcquireCancelSpinLock(&OldIrql);

                if (Extension->CurrentMaskIrp->Cancel) {

                    CyyDbgPrintEx(CYYDIAG4, "%x irp was already marked as "
                                  "cancelled\n", Extension->CurrentMaskIrp);

                    IoReleaseCancelSpinLock(OldIrql);
                    Extension->CurrentMaskIrp->IoStatus.Status = STATUS_CANCELLED;

                    if (!SetFirstStatus) {

                        CyyDbgPrintEx(CYYDIAG4, "%x was the first irp "
                                      "processed by this\n"
                                      "------- invocation of startmask\n",
                                      Extension->CurrentMaskIrp);

                        FirstStatus = STATUS_CANCELLED;
                        SetFirstStatus = TRUE;

                    }

                    CyyGetNextIrp(&Extension->CurrentMaskIrp,
                                  &Extension->MaskQueue, &NewIrp, TRUE,
                                  Extension);

                    CyyDbgPrintEx(CYYDIAG4, "Perhaps another mask irp was "
                                  "found in the queue\n"
                                  "------- %x/%x <- values should be the "
                                  "same\n", Extension->CurrentMaskIrp,
                                  NewIrp);

                } else {

                    CyyDbgPrintEx(CYYDIAG4, "%x will become the current "
                                  "wait irp\n", Extension->CurrentMaskIrp);
                    if (!SetFirstStatus) {

                        CyyDbgPrintEx(CYYDIAG4, "%x was the first irp "
                                      "processed by this\n"
                                      "------- invocation of startmask\n",
                                      Extension->CurrentMaskIrp);

                        FirstStatus = STATUS_PENDING;
                        SetFirstStatus = TRUE;

                        //
                        // If we haven't already set a first status
                        // then there is a chance that this packet
                        // was never on the queue.  We should mark
                        // it as pending.
                        //

                        IoMarkIrpPending(Extension->CurrentMaskIrp);

                    }

                    //
                    // There should never be a mask location when
                    // there isn't a current wait irp.  At this point
                    // there shouldn't be a current wait irp also.
                    //

                    ASSERT(!Extension->IrpMaskLocation);
                    ASSERT(!Extension->CurrentWaitIrp);

                    Extension->CurrentWaitIrp = Extension->CurrentMaskIrp;
                    SERIAL_INIT_REFERENCE(Extension->CurrentWaitIrp);
                    IoSetCancelRoutine(
                        Extension->CurrentWaitIrp,
                        CyyCancelWait
                        );

                    //
                    // Since the cancel routine has a reference to
                    // the irp we need to update the reference
                    // count.
                    //

                    SERIAL_SET_REFERENCE(
                        Extension->CurrentWaitIrp,
                        SERIAL_REF_CANCEL
                        );

                    KeSynchronizeExecution(
                        Extension->Interrupt,
                        CyyGiveWaitToIsr,
                        Extension
                        );

// Code removed because it was causing blue-screen in the Modem Share 
// test case 77. When CurrentMaskIrp is set to NULL, we remove the 
// protection that avoid Starter to be called in CyyStartOrQueue.
// We will let CyyGetNextIrp null out that pointer. Fanny.
//
//                    //
//                    // Since it isn't really the mask irp anymore,
//                    // null out that pointer.
//                    //
//
//                    Extension->CurrentMaskIrp = NULL;

                    Extension->CurrentMaskIrp = NULL; // back in Windows 2000. Fanny

                    //
                    // This will release the cancel spinlock for us
                    //

                    CyyGetNextIrpLocked(&Extension->CurrentMaskIrp,
                                        &Extension->MaskQueue, &NewIrp,
                                        FALSE, Extension, OldIrql);

                    CyyDbgPrintEx(CYYDIAG4, "Perhaps another mask irp was "
                                  "found in the queue\n"
                                  "------- %x/%x <- values should be the "
                                  "same\n", Extension->CurrentMaskIrp,
                                  NewIrp);

                }

            }

        }

    } while (NewIrp);

    return FirstStatus;

}

BOOLEAN
CyyGrabWaitFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the IrpMaskLocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = Context;
    CYY_LOCKED_PAGED_CODE();

    CyyDbgPrintEx(CYYDIAG3, "In CyyGrabWaitFromIsr\n");

    if (Extension->IrpMaskLocation) {

        CyyDbgPrintEx(CYYDIAG4, "The isr still owns the irp %x, mask "
                      "location is %x\n"
                      "------- and system buffer is %x\n",
                      Extension->CurrentWaitIrp,Extension->IrpMaskLocation,
                      Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer);

        //
        // The isr still "owns" the irp.
        //

        *Extension->IrpMaskLocation = 0;
        Extension->IrpMaskLocation = NULL;

        Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // Since the isr no longer references the irp we need to
        // decrement the reference count.
        //

        SERIAL_CLEAR_REFERENCE(
            Extension->CurrentWaitIrp,
            SERIAL_REF_ISR
            );

    }

    return FALSE;
}

BOOLEAN
CyyGiveWaitToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine simply sets a variable in the device extension
    so that the isr knows that we have a wait irp.

    NOTE: This is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spinlock held.

Arguments:

    Context - Simply a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = Context;
    CYY_LOCKED_PAGED_CODE();

    CyyDbgPrintEx(CYYDIAG3, "In CyyGiveWaitToIsr\n");
    //
    // There certainly shouldn't be a current mask location at
    // this point since we have a new current wait irp.
    //

    ASSERT(!Extension->IrpMaskLocation);

    //
    // The isr may or may not actually reference this irp.  It
    // won't if the wait can be satisfied immediately.  However,
    // since it will then go through the normal completion sequence,
    // we need to have an incremented reference count anyway.
    //

    SERIAL_SET_REFERENCE(
        Extension->CurrentWaitIrp,
        SERIAL_REF_ISR
        );

    if (!Extension->HistoryMask) {

        CyyDbgPrintEx(CYYDIAG4, "No events occured prior to the wait call"
                      "\n");

        //
        // Although this wait might not be for empty transmit
        // queue, it doesn't hurt anything to set it to false.
        //

        Extension->EmptiedTransmit = FALSE;

        //
        // Record where the "completion mask" should be set.
        //

        Extension->IrpMaskLocation =
            Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer;
        CyyDbgPrintEx( CYYDIAG4, "The isr owns the irp %x, mask location is "
                       "%x\n"
                       "------- and system buffer is %x\n",
                       Extension->CurrentWaitIrp,Extension->IrpMaskLocation,
                       Extension->CurrentWaitIrp->AssociatedIrp
                       .SystemBuffer);

    } else {

        CyyDbgPrintEx(CYYDIAG4, "%x occurred prior to the wait - starting "
                      "the\n"
                      "------- completion code for %x\n",
                      Extension->HistoryMask,Extension->CurrentWaitIrp);

        *((ULONG *)Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer) =
            Extension->HistoryMask;
        Extension->HistoryMask = 0;
        Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
        Extension->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;

        CyyInsertQueueDpc(&Extension->CommWaitDpc, NULL, NULL, Extension);

    }

    return FALSE;
}

BOOLEAN
CyyFinishOldWait(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the Irpmasklocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = Context;
    CYY_LOCKED_PAGED_CODE();

    CyyDbgPrintEx(CYYDIAG3, "In CyyFinishOldWait\n");

    if (Extension->IrpMaskLocation) {

        CyyDbgPrintEx(CYYDIAG4, "The isr still owns the irp %x, mask "
                      "location is %x\n"
                      "------- and system buffer is %x\n",
                      Extension->CurrentWaitIrp,Extension->IrpMaskLocation,
                      Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer);
        //
        // The isr still "owns" the irp.
        //

        *Extension->IrpMaskLocation = 0;
        Extension->IrpMaskLocation = NULL;

        Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // We don't decrement the reference since the completion routine
        // will do that.
        //

        CyyInsertQueueDpc(&Extension->CommWaitDpc, NULL, NULL, Extension);

    }

    //
    // Don't wipe out any historical data we are still interested in.
    //

    Extension->HistoryMask &= *((ULONG *)Extension->CurrentMaskIrp->
                                            AssociatedIrp.SystemBuffer);

    Extension->IsrWaitMask = *((ULONG *)Extension->CurrentMaskIrp->
                                            AssociatedIrp.SystemBuffer);
    CyyDbgPrintEx( CYYDIAG4, "Set mask location of %x, in irp %x, with "
                   "system buffer of %x\n",
                   Extension->IrpMaskLocation, Extension->CurrentMaskIrp,
                   Extension->CurrentMaskIrp->AssociatedIrp.SystemBuffer);
    return FALSE;
}

VOID
CyyCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel a irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    CYY_LOCKED_PAGED_CODE();

    CyyDbgPrintEx(CYYDIAG3, "In CyyCancelWait\n");

    CyyDbgPrintEx(CYYDIAG4, "Canceling wait for irp %x\n",
                  Extension->CurrentWaitIrp);

    CyyTryToCompleteCurrent(Extension, CyyGrabWaitFromIsr,
                            Irp->CancelIrql, STATUS_CANCELLED,
                            &Extension->CurrentWaitIrp, NULL, NULL, NULL,
                            NULL, NULL, SERIAL_REF_CANCEL);

}

VOID
CyyCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{
    PCYY_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;


    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyCompleteWait(%X)\n",
                  Extension);

    CyyDbgPrintEx(CYYDIAG3, "In CyyCompleteWait\n");

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    CyyDbgPrintEx(CYYDIAG4, "Completing wait for irp %x\n",
                  Extension->CurrentWaitIrp);

    CyyTryToCompleteCurrent(Extension, NULL, OldIrql, STATUS_SUCCESS,
                            &Extension->CurrentWaitIrp, NULL, NULL, NULL,
                            NULL, NULL, SERIAL_REF_ISR);

    CyyDpcEpilogue(Extension, Dpc);


    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyCompleteWait\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyyioctl.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*
*   Cyclom-Y Port Driver
*	
*   This file :     cyyioctl.c
*	
*   Description:    This module contains the code related to ioctl calls
*                   in the Cyclom-Y Port driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*--------------------------------------------------------------------------*/
#include "precomp.h"


BOOLEAN
CyyGetModemUpdate(
    IN PVOID Context
    );

BOOLEAN
CyyGetCommStatus(
    IN PVOID Context
    );

BOOLEAN
CyySetEscapeChar(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,CyySetBaud)
#pragma alloc_text(PAGESER,CyySetLineControl)
#pragma alloc_text(PAGESER,CyyIoControl)
#pragma alloc_text(PAGESER,CyySetChars)
#pragma alloc_text(PAGESER,CyyGetModemUpdate)
#pragma alloc_text(PAGESER,CyyGetCommStatus)
#pragma alloc_text(PAGESER,CyyGetProperties)
#pragma alloc_text(PAGESER,CyySetEscapeChar)
//#pragma alloc_text(PAGESER,CyyCDCmd)
#pragma alloc_text(PAGESER,CyyGetStats)
#pragma alloc_text(PAGESER,CyyClearStats)
#pragma alloc_text(PAGESER, CyySetMCRContents)
#pragma alloc_text(PAGESER, CyyGetMCRContents)
#pragma alloc_text(PAGESER, CyySetFCRContents)
#pragma alloc_text(PAGESER, CyyInternalIoControl)
#endif

static const PHYSICAL_ADDRESS CyyPhysicalZero = {0};


BOOLEAN
CyyGetStats(
    IN PVOID Context
    )

/*++

Routine Description:

    In sync with the interrpt service routine (which sets the perf stats)
    return the perf stats to the caller.


Arguments:

    Context - Pointer to a the irp.

Return Value:

    This routine always returns FALSE.

--*/

{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation((PIRP)Context);
    PCYY_DEVICE_EXTENSION extension = irpSp->DeviceObject->DeviceExtension;
    PSERIALPERF_STATS sp = ((PIRP)Context)->AssociatedIrp.SystemBuffer;

    CYY_LOCKED_PAGED_CODE();

    *sp = extension->PerfStats;
    return FALSE;

}

BOOLEAN
CyyClearStats(
    IN PVOID Context
    )

/*++

Routine Description:

    In sync with the interrpt service routine (which sets the perf stats)
    clear the perf stats.


Arguments:

    Context - Pointer to a the extension.

Return Value:

    This routine always returns FALSE.

--*/

{
    CYY_LOCKED_PAGED_CODE();

    RtlZeroMemory(
        &((PCYY_DEVICE_EXTENSION)Context)->PerfStats,
        sizeof(SERIALPERF_STATS)
        );

    RtlZeroMemory(&((PCYY_DEVICE_EXTENSION)Context)->WmiPerfData,
                 sizeof(SERIAL_WMI_PERF_DATA));
    return FALSE;

}


BOOLEAN
CyySetChars(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyySetChars()
    
    Routine Description: set special characters for the driver.

    Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a special characters
              structure.

    Return Value: This routine always returns FALSE.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = ((PCYY_IOCTL_SYNC)Context)->Extension;
    PUCHAR chip = Extension->Cd1400;
    ULONG bus = Extension->IsPci;

    CYY_LOCKED_PAGED_CODE();
    
    Extension->SpecialChars =
        *((PSERIAL_CHARS)(((PCYY_IOCTL_SYNC)Context)->Data));

    CD1400_WRITE(chip,bus,CAR,Extension->CdChannel & 0x03);
    CD1400_WRITE(chip,bus,SCHR1,Extension->SpecialChars.XonChar);
    CD1400_WRITE(chip,bus,SCHR2,Extension->SpecialChars.XoffChar);
		
    return FALSE;
}

BOOLEAN
CyySetBaud(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyySetBaud()
    
    Routine Description: set the baud rate of the device.

    Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension.

    Return Value: This routine always returns FALSE if error; 
	               TRUE if successful.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = ((PCYY_IOCTL_BAUD)Context)->Extension;
    ULONG baud = ((PCYY_IOCTL_BAUD)Context)->Baud;
    PUCHAR chip = Extension->Cd1400;
    ULONG bus = Extension->IsPci;
    ULONG baud_period,i;
    UCHAR cor3value;
    static ULONG cor_values[] = {8, 32, 128, 512, 2048, 0};
 
    CYY_LOCKED_PAGED_CODE();
    
    for(i = 0 ; cor_values[i] > 0 ; i++) {
    	baud_period = (10 * Extension->CDClock)/baud;
		baud_period = baud_period/cor_values[i];
		baud_period = (baud_period + 5)/10;
		if(baud_period <= 0xff && baud_period > 0)	break;
    }
    if(cor_values[i] == 0)	return(FALSE);


    CD1400_WRITE(chip,bus,CAR, Extension->CdChannel & 0x03);
    CD1400_WRITE(chip,bus,TCOR, (UCHAR)i);
    CD1400_WRITE(chip,bus,RCOR, (UCHAR)i);
    CD1400_WRITE(chip,bus,TBPR, (UCHAR)baud_period);
    CD1400_WRITE(chip,bus,RBPR, (UCHAR)baud_period);
    CD1400_WRITE(chip,bus,RTPR, (UCHAR)Extension->Rtpr); // Receive Time-out Period 
					                  							   // Register (value in ms)
    
    // set the threshold
    if (Extension->RxFifoTriggerUsed == FALSE) {

       cor3value = CD1400_READ(chip,bus,COR3);
       cor3value &= 0xf0;
      if(baud <= 9600) {
   	   CD1400_WRITE(chip,bus,COR3, cor3value | 0x0a);
      } else if (baud <= 38400) {
	      CD1400_WRITE(chip,bus,COR3, cor3value | 0x06);
      } else {
	      CD1400_WRITE(chip,bus,COR3, cor3value | 0x04);
      }
      CyyCDCmd(Extension,CCR_CORCHG_COR3);
    }    
	
    return TRUE;
}

VOID
CyyCDCmd(
	PCYY_DEVICE_EXTENSION Extension,
    UCHAR cmd
    )
/*--------------------------------------------------------------------------
    CyyCDCmd()
    
    Routine Description: Send a command to a CD1400.
    
    Arguments:
    
    Extension - pointer to the serial device extension.
    cmd - command to be sent.
    
    Return Value: none.
--------------------------------------------------------------------------*/
{
    KIRQL irql;
    UCHAR value;
    LARGE_INTEGER startOfSpin, nextQuery, difference, oneSecond;
    PUCHAR chip = Extension->Cd1400;
    ULONG bus = Extension->IsPci;

    oneSecond.QuadPart = 10*1000*1000; // unit is 100ns
    KeQueryTickCount(&startOfSpin);

    do {			
        KeQueryTickCount(&nextQuery);
        difference.QuadPart = nextQuery.QuadPart - startOfSpin.QuadPart;
        ASSERT(KeQueryTimeIncrement() <= MAXLONG);
        //*************************
        // Error Injection
        //if (difference.QuadPart * KeQueryTimeIncrement() <
        //                           oneSecond.QuadPart)
        //*************************
        if (difference.QuadPart * KeQueryTimeIncrement() >= 
                                        oneSecond.QuadPart) {
            #if DBG
            DbgPrint("\n ***** CCR not zero! *****\n");
            #endif
            if (Extension->CmdFailureLog == FALSE) {
                irql = KeGetCurrentIrql();
                if (irql <= DISPATCH_LEVEL) {
                    CyyLogError(Extension->DeviceObject->DriverObject,
                                NULL,CyyPhysicalZero,CyyPhysicalZero,
                                0,0,0,Extension->PortIndex+1,STATUS_SUCCESS,CYY_CCR_NOT_ZERO,
                                0,NULL,0,NULL);
                    Extension->CmdFailureLog = TRUE;
                }
            }
            break;															
        }
        value = CD1400_READ(chip,bus,CCR);
    } while (value != 0);

    if (value == 0) {
        CD1400_WRITE(chip,bus,CCR,cmd);
    }
}

BOOLEAN
CyySetLineControl(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyySetLineControl()
    
    Routine Description: set the COR1 (DATA,PARITY,STOP)

    Arguments:

    Context - Pointer to the device extension.

    Return Value: This routine always returns FALSE.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = Context;
    PUCHAR chip = Extension->Cd1400;
    ULONG bus = Extension->IsPci;

    CYY_LOCKED_PAGED_CODE();
    
    CD1400_WRITE(chip,bus,CAR, Extension->CdChannel & 0x03);
    CD1400_WRITE(chip,bus,COR1, Extension->cor1);
    CyyCDCmd(Extension,CCR_CORCHG_COR1);
    
    return FALSE;
}

BOOLEAN
CyyGetModemUpdate(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyyGetModemUpdate()
    
    Routine Description: this routine is simply used to call the interrupt
    level routine that handles modem status update.

    Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a ulong.

    Return Value: This routine always returns FALSE. 
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = ((PCYY_IOCTL_SYNC)Context)->Extension;
    ULONG *Result = (ULONG *)(((PCYY_IOCTL_SYNC)Context)->Data);

    CYY_LOCKED_PAGED_CODE();

    *Result = CyyHandleModemUpdate(Extension,FALSE);
    return FALSE;
}


BOOLEAN
CyySetMCRContents(IN PVOID Context)
/*++

Routine Description:

    This routine is simply used to set the contents of the MCR

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a ulong.

Return Value:

    This routine always returns FALSE.

--*/
{
   PCYY_DEVICE_EXTENSION Extension = ((PCYY_IOCTL_SYNC)Context)->Extension;
   ULONG *Result = (ULONG *)(((PCYY_IOCTL_SYNC)Context)->Data);

   PUCHAR chip = Extension->Cd1400;
   ULONG bus = Extension->IsPci;

   CYY_LOCKED_PAGED_CODE();

   // Let's convert the UART modem control to our hw

   CD1400_WRITE(chip,bus, CAR, Extension->CdChannel & 0x03);
   if (*Result & SERIAL_MCR_DTR) {
      CD1400_WRITE(chip,bus, Extension->MSVR_DTR, Extension->DTRset);
   } else {
      CD1400_WRITE(chip,bus, Extension->MSVR_DTR, 0x00);
   }
   if (*Result & SERIAL_MCR_RTS) {
      CD1400_WRITE(chip,bus, Extension->MSVR_RTS, Extension->RTSset);
   } else {
      CD1400_WRITE(chip,bus, Extension->MSVR_RTS, 0x00);
   }
   if (*Result & SERIAL_MCR_OUT2) {
      // Enable IRQ
      CD1400_WRITE(chip,bus,SRER,0x90); // Enable MdmCh, RxData.
   } else {
      CD1400_WRITE(chip,bus,SRER,0x00); // Disable MdmCh, RxData, TxRdy
   }

// Fanny: Strange, Result is being used instead of *Result.
//   //
//   // This is severe casting abuse!!!
//   //
//
//    WRITE_MODEM_CONTROL(Extension->Controller, (UCHAR)PtrToUlong(Result));

   return FALSE;
}



BOOLEAN
CyyGetMCRContents(IN PVOID Context)

/*++

Routine Description:

    This routine is simply used to get the contents of the MCR

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a ulong.

Return Value:

    This routine always returns FALSE.

--*/

{

   PCYY_DEVICE_EXTENSION Extension = ((PCYY_IOCTL_SYNC)Context)->Extension;
   ULONG *Result = (ULONG *)(((PCYY_IOCTL_SYNC)Context)->Data);

   PUCHAR chip = Extension->Cd1400;
   ULONG bus = Extension->IsPci;
   UCHAR var;
   *Result = 0;

   CYY_LOCKED_PAGED_CODE();

   CD1400_WRITE(chip,bus, CAR, Extension->CdChannel & 0x03);
   var = CD1400_READ(chip,bus,Extension->MSVR_DTR);
   if (var & Extension->DTRset) {
      *Result |= SERIAL_MCR_DTR;
   }
   var = CD1400_READ(chip,bus,Extension->MSVR_RTS);
   if (var & Extension->RTSset) {
      *Result |= SERIAL_MCR_RTS;
   }
   var = CD1400_READ(chip,bus,SRER);
   if (var & 0x90) {
      *Result |= SERIAL_MCR_OUT2;
   }


//   *Result = READ_MODEM_CONTROL(Extension->Controller);

   return FALSE;

}


BOOLEAN
CyySetFCRContents(IN PVOID Context)
/*++

Routine Description:

    This routine is simply used to set the contents of the FCR

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a ulong.

Return Value:

    This routine always returns FALSE.

--*/
{
   PCYY_DEVICE_EXTENSION Extension = ((PCYY_IOCTL_SYNC)Context)->Extension;
   ULONG *Result = (ULONG *)(((PCYY_IOCTL_SYNC)Context)->Data);
   PUCHAR chip = Extension->Cd1400;
   ULONG bus = Extension->IsPci;
   UCHAR cor3value;

   CYY_LOCKED_PAGED_CODE();

   CD1400_WRITE(chip,bus,CAR, Extension->CdChannel & 0x03);

   if (*Result & SERIAL_FCR_TXMT_RESET) {
      CyyCDCmd(Extension,CCR_FLUSH_TXFIFO);
   }
   if (*Result & SERIAL_FCR_RCVR_RESET) {
      CyyDbgPrintEx(DPFLTR_WARNING_LEVEL, "SERIAL_FCR_RCVR_RESET received. "
                    "CD1400 rx fifo can't be reset.\n");
   }
   
   Extension->RxFifoTrigger = (UCHAR)*Result & 0xc0;
   cor3value = CD1400_READ(chip,bus,COR3);
   cor3value &= 0xf0;
   switch (Extension->RxFifoTrigger) {
   case SERIAL_1_BYTE_HIGH_WATER:
      cor3value |= 0x01;
      break;
   case SERIAL_4_BYTE_HIGH_WATER:
      cor3value |= 0x04;
      break;
   case SERIAL_8_BYTE_HIGH_WATER:
      cor3value |= 0x08;
      break;
   case SERIAL_14_BYTE_HIGH_WATER:
      cor3value |= MAX_CHAR_FIFO;
      break;
   }
   CD1400_WRITE(chip,bus,COR3, cor3value);
   CyyCDCmd(Extension,CCR_CORCHG_COR3);
   Extension->RxFifoTriggerUsed = TRUE;

//   //
//   // This is severe casting abuse!!!
//   //
//
//    WRITE_FIFO_CONTROL(Extension->Controller, (UCHAR)*Result);  Bld 2128: PtrToUlong replaced by *

    return FALSE;
}


BOOLEAN
CyyGetCommStatus(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyyGetCommStatus()
    
    Routine Description: get the current state of the serial driver.

    Arguments:

    Context - Pointer to a structure that contains a pointer to the
    	      device extension and a pointer to a serial status record.

    Return Value: This routine always returns FALSE.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = ((PCYY_IOCTL_SYNC)Context)->Extension;
    PSERIAL_STATUS Stat = ((PCYY_IOCTL_SYNC)Context)->Data;

    CYY_LOCKED_PAGED_CODE();

    Stat->Errors = Extension->ErrorWord;
    Extension->ErrorWord = 0;

    //
    // Eof isn't supported in binary mode
    //
    Stat->EofReceived = FALSE;

    Stat->AmountInInQueue = Extension->CharsInInterruptBuffer;
    Stat->AmountInOutQueue = Extension->TotalCharsQueued;

    if (Extension->WriteLength) {
        // By definition if we have a writelength the we have
        // a current write irp.
        ASSERT(Extension->CurrentWriteIrp);
        ASSERT(Stat->AmountInOutQueue >= Extension->WriteLength);

        Stat->AmountInOutQueue -=
            IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp)
            ->Parameters.Write.Length - (Extension->WriteLength);
    }

    Stat->WaitForImmediate = Extension->TransmitImmediate;

    Stat->HoldReasons = 0;
    if (Extension->TXHolding) {
        if (Extension->TXHolding & CYY_TX_CTS) {
            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_CTS;
        }

        if (Extension->TXHolding & CYY_TX_DSR) {
            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DSR;
        }

        if (Extension->TXHolding & CYY_TX_DCD) {
            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DCD;
        }

        if (Extension->TXHolding & CYY_TX_XOFF) {
            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_XON;
        }

        if (Extension->TXHolding & CYY_TX_BREAK) {
            Stat->HoldReasons |= SERIAL_TX_WAITING_ON_BREAK;
        }
    }

    if (Extension->RXHolding & CYY_RX_DSR) {
        Stat->HoldReasons |= SERIAL_RX_WAITING_FOR_DSR;
    }

    if (Extension->RXHolding & CYY_RX_XOFF) {
        Stat->HoldReasons |= SERIAL_TX_WAITING_XOFF_SENT;
    }

    return FALSE;

}

BOOLEAN
CyySetEscapeChar(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyySetEscapeChar()
    
    Routine Description: This is used to set the character that will be
    used to escape line status and modem status information when the
    application has set up that line status and modem status should be
    passed back in the data stream.

    Arguments:

    Context - Pointer to the irp that is to specify the escape character.
              Implicitly - An escape character of 0 means no escaping.

    Return Value: This routine always returns FALSE.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION extension =
        IoGetCurrentIrpStackLocation((PIRP)Context)
            ->DeviceObject->DeviceExtension;

    extension->EscapeChar =
        *(PUCHAR)((PIRP)Context)->AssociatedIrp.SystemBuffer;

    return FALSE;
}

NTSTATUS
CyyIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*--------------------------------------------------------------------------
    CyyIoControl()

    Description: This routine provides the initial processing for
    all of the Ioctls for the serial device.

    Arguments:
    
    DeviceObject - Pointer to the device object for this device
    
    Irp - Pointer to the IRP for the current request

    Return Value:

    The function value is the final status of the call
--------------------------------------------------------------------------*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PCYY_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    KIRQL OldIrql;

    #if DBG
	 ULONG debugdtr = 0;
	 ULONG debugrts = 0;
	 #endif

    NTSTATUS prologueStatus;

    CYY_LOCKED_PAGED_CODE();

    //
    // We expect to be open so all our pages are locked down.  This is, after
    // all, an IO operation, so the device should be open first.
    //

    if (Extension->DeviceIsOpened != TRUE) {
       Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
       IoCompleteRequest(Irp, IO_NO_INCREMENT);
       return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ((prologueStatus = CyyIRPPrologue(Irp, Extension))
        != STATUS_SUCCESS) {
       Irp->IoStatus.Status = prologueStatus;
       CyyCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
       return prologueStatus;
    }

    CyyDbgPrintEx(CYYIRPPATH, "Dispatch entry for: %x\n", Irp);

    if (CyyCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS) {
        return STATUS_CANCELLED;
    }
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;
    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
	
        case IOCTL_SERIAL_SET_BAUD_RATE : {

            ULONG BaudRate;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_BAUD_RATE)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            } else {
                BaudRate = ((PSERIAL_BAUD_RATE)
				(Irp->AssociatedIrp.SystemBuffer))->BaudRate;
            }

            if ((BaudRate == 0) || (BaudRate > 230400)) {
               Status = STATUS_INVALID_PARAMETER;
               break;
            }
            if ((Extension->CDClock == 25000000) && (BaudRate > 115200)) {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Make sure we are at power D0
            //

            if (NT_SUCCESS(Status)) {
               if (Extension->PowerState != PowerDeviceD0) {
                  Status = CyyGotoPowerState(Extension->Pdo, Extension,
                                                PowerDeviceD0);
                  if (!NT_SUCCESS(Status)) {
                     break;
                  }
               }
            }

            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);
			
            if (NT_SUCCESS(Status)) {
               CYY_IOCTL_BAUD S;
               BOOLEAN result;

               Extension->CurrentBaud = BaudRate;
               Extension->WmiCommData.BaudRate = BaudRate;
               S.Extension = Extension;
               S.Baud = BaudRate;
               result = KeSynchronizeExecution(Extension->Interrupt,CyySetBaud,&S);
               if (result == 0) {
                  Status = STATUS_INVALID_PARAMETER;
               }
            }

            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
            break;
        }
        case IOCTL_SERIAL_GET_BAUD_RATE: {

            PSERIAL_BAUD_RATE Br = (PSERIAL_BAUD_RATE)Irp->AssociatedIrp.SystemBuffer;
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_BAUD_RATE)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

            Br->BaudRate = Extension->CurrentBaud;

            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
        
            Irp->IoStatus.Information = sizeof(SERIAL_BAUD_RATE);			
            break;

        }
        case IOCTL_SERIAL_GET_MODEM_CONTROL: {
            CYY_IOCTL_SYNC S;

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            Irp->IoStatus.Information = sizeof(ULONG);

            S.Extension = Extension;
            S.Data = Irp->AssociatedIrp.SystemBuffer;

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            KeSynchronizeExecution(
                Extension->Interrupt,
                CyyGetMCRContents,
                &S
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;
        }
        case IOCTL_SERIAL_SET_MODEM_CONTROL: {
            CYY_IOCTL_SYNC S;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(ULONG)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            S.Extension = Extension;
            S.Data = Irp->AssociatedIrp.SystemBuffer;

            //
            // Make sure we are at power D0
            //

            if (Extension->PowerState != PowerDeviceD0) {
               Status = CyyGotoPowerState(Extension->Pdo, Extension,
                                             PowerDeviceD0);
               if (!NT_SUCCESS(Status)) {
                  break;
               }
            }

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            KeSynchronizeExecution(
                Extension->Interrupt,
                CyySetMCRContents,
                &S
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;
        }
        case IOCTL_SERIAL_SET_FIFO_CONTROL: {
            CYY_IOCTL_SYNC S;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(ULONG)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            S.Extension = Extension;
            S.Data = Irp->AssociatedIrp.SystemBuffer;

            //
            // Make sure we are at power D0
            //

            if (Extension->PowerState != PowerDeviceD0) {
               Status = CyyGotoPowerState(Extension->Pdo, Extension,
                                             PowerDeviceD0);
               if (!NT_SUCCESS(Status)) {
                  break;
               }
            }

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            KeSynchronizeExecution(
                Extension->Interrupt,
                CyySetFCRContents,
                &S
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;
        }
        case IOCTL_SERIAL_SET_LINE_CONTROL: {

            PSERIAL_LINE_CONTROL Lc =
                ((PSERIAL_LINE_CONTROL)(Irp->AssociatedIrp.SystemBuffer));
            UCHAR LData;
            UCHAR LStop;
            UCHAR LParity;
            UCHAR Mask = 0xff;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_LINE_CONTROL)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Make sure we are at power D0
            //

            if (Extension->PowerState != PowerDeviceD0) {
               Status = CyyGotoPowerState(Extension->Pdo, Extension,
                                             PowerDeviceD0);
               if (!NT_SUCCESS(Status)) {
                  break;
               }
            }

            switch (Lc->WordLength) {
                case 5:		LData = COR1_5_DATA; Mask = 0x1f;
                break;

                case 6:		LData = COR1_6_DATA; Mask = 0x3f;
                break;

                case 7:		LData = COR1_7_DATA; Mask = 0x7f;
                break;

                case 8:		LData = COR1_8_DATA; Mask = 0xff;
                break;

                default:	Status = STATUS_INVALID_PARAMETER;
                goto DoneWithIoctl;
            }

            Extension->WmiCommData.BitsPerByte = Lc->WordLength;

            switch (Lc->Parity) {
                case NO_PARITY:	{	
                    Extension->WmiCommData.Parity = SERIAL_WMI_PARITY_NONE;
                    LParity = COR1_NONE_PARITY;
                    break;
                }
                case EVEN_PARITY: {
                    Extension->WmiCommData.Parity = SERIAL_WMI_PARITY_EVEN;
                    LParity = COR1_EVEN_PARITY;
                    break;
                }    
                case ODD_PARITY: {
                    Extension->WmiCommData.Parity = SERIAL_WMI_PARITY_ODD;
                    LParity = COR1_ODD_PARITY;
                    break;
                }
                case SPACE_PARITY: {
                    Extension->WmiCommData.Parity = SERIAL_WMI_PARITY_SPACE;
                    LParity = COR1_SPACE_PARITY;
                    break;
                }
                case MARK_PARITY: {
                    Extension->WmiCommData.Parity = SERIAL_WMI_PARITY_MARK;
                    LParity = COR1_MARK_PARITY;
                    break;
                }
                default: {
                    Status = STATUS_INVALID_PARAMETER;
                    goto DoneWithIoctl;
                    break;
                }
            }

            switch (Lc->StopBits) {
                case STOP_BIT_1: {
                    Extension->WmiCommData.StopBits = SERIAL_WMI_STOP_1;
                    LStop = COR1_1_STOP;
                    break;
                }
                case STOP_BITS_1_5:	{
                    Extension->WmiCommData.StopBits = SERIAL_WMI_STOP_1_5;
                    LStop = COR1_1_5_STOP;
                    break;
                }
                case STOP_BITS_2: {
                    Extension->WmiCommData.StopBits = SERIAL_WMI_STOP_2;
                    LStop = COR1_2_STOP;
                    break;
                }
                default: {
                    Status = STATUS_INVALID_PARAMETER;
                    goto DoneWithIoctl;
                }
            }


            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

            Extension->cor1 = (UCHAR)(LData | LParity | LStop);
            Extension->ValidDataMask = (UCHAR) Mask;

            KeSynchronizeExecution(
                Extension->Interrupt,
                CyySetLineControl,
                Extension
                );

            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
            break;
        }
        case IOCTL_SERIAL_GET_LINE_CONTROL: {

            PSERIAL_LINE_CONTROL Lc = (PSERIAL_LINE_CONTROL)Irp->AssociatedIrp.SystemBuffer;

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_LINE_CONTROL)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);
			
            if ((Extension->cor1 & COR1_DATA_MASK) == COR1_5_DATA) {
                Lc->WordLength = 5;
            } else if ((Extension->cor1 & COR1_DATA_MASK) == COR1_6_DATA) {
                Lc->WordLength = 6;
            } else if ((Extension->cor1 & COR1_DATA_MASK) == COR1_7_DATA) {
                Lc->WordLength = 7;
            } else if ((Extension->cor1 & COR1_DATA_MASK) == COR1_8_DATA) {
                Lc->WordLength = 8;
            }

            if ((Extension->cor1 & COR1_PARITY_MASK) == COR1_NONE_PARITY) {
                Lc->Parity = NO_PARITY;
            } else if ((Extension->cor1 & COR1_PARITY_MASK) == COR1_ODD_PARITY) {
                Lc->Parity = ODD_PARITY;
            } else if ((Extension->cor1 & COR1_PARITY_MASK) == COR1_EVEN_PARITY) {
                Lc->Parity = EVEN_PARITY;
            } else if ((Extension->cor1 & COR1_PARITY_MASK) == COR1_MARK_PARITY) {
                Lc->Parity = MARK_PARITY;
            } else if ((Extension->cor1 & COR1_PARITY_MASK) == COR1_SPACE_PARITY) {
                Lc->Parity = SPACE_PARITY;
            }

            if ((Extension->cor1 & COR1_STOP_MASK) == COR1_2_STOP) {
                if (Lc->WordLength == 5) {
                    Lc->StopBits = STOP_BITS_1_5;
                } else {
                    Lc->StopBits = STOP_BITS_2;
                }
            } else {
                Lc->StopBits = STOP_BIT_1;
            }

            Irp->IoStatus.Information = sizeof(SERIAL_LINE_CONTROL);
            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
            break;
        }
        case IOCTL_SERIAL_SET_TIMEOUTS: {
            PSERIAL_TIMEOUTS NewTimeouts =
                ((PSERIAL_TIMEOUTS)(Irp->AssociatedIrp.SystemBuffer));

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_TIMEOUTS)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            if ((NewTimeouts->ReadIntervalTimeout == MAXULONG) &&
                (NewTimeouts->ReadTotalTimeoutMultiplier == MAXULONG) &&
                (NewTimeouts->ReadTotalTimeoutConstant == MAXULONG)) {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);
	    
            Extension->Timeouts.ReadIntervalTimeout =
                NewTimeouts->ReadIntervalTimeout;
            Extension->Timeouts.ReadTotalTimeoutMultiplier =
                NewTimeouts->ReadTotalTimeoutMultiplier;
            Extension->Timeouts.ReadTotalTimeoutConstant =
                NewTimeouts->ReadTotalTimeoutConstant;
            Extension->Timeouts.WriteTotalTimeoutMultiplier =
                NewTimeouts->WriteTotalTimeoutMultiplier;
            Extension->Timeouts.WriteTotalTimeoutConstant =
                NewTimeouts->WriteTotalTimeoutConstant;

            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
            break;
        }
        case IOCTL_SERIAL_GET_TIMEOUTS: {
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_TIMEOUTS)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }
			
            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

            *((PSERIAL_TIMEOUTS)Irp->AssociatedIrp.SystemBuffer) =
	    						Extension->Timeouts;
	    
            Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);

            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
            break;
        }
        case IOCTL_SERIAL_SET_CHARS: {
            CYY_IOCTL_SYNC S;
	    
            PSERIAL_CHARS NewChars =
                ((PSERIAL_CHARS)(Irp->AssociatedIrp.SystemBuffer));
				
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_CHARS)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }
#if 0
            if (NewChars->XonChar == NewChars->XoffChar) {			

                Status = STATUS_INVALID_PARAMETER;
   	            break;					
				
            }
#endif
            // We acquire the control lock so that only
            // one request can GET or SET the characters
            // at a time.  The sets could be synchronized
            // by the interrupt spinlock, but that wouldn't
            // prevent multiple gets at the same time.

            S.Extension = Extension;
            S.Data = NewChars;

            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

            // Under the protection of the lock, make sure that
            // the xon and xoff characters aren't the same as
            // the escape character.

            if (Extension->EscapeChar) {
                if ((Extension->EscapeChar == NewChars->XonChar) ||
                    (Extension->EscapeChar == NewChars->XoffChar)) {
                    Status = STATUS_INVALID_PARAMETER;
                    KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
                    break;
                }
            }

            Extension->WmiCommData.XonCharacter = NewChars->XonChar;
            Extension->WmiCommData.XoffCharacter = NewChars->XoffChar;

            KeSynchronizeExecution(Extension->Interrupt,CyySetChars,&S);

            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
            break;
        }
        case IOCTL_SERIAL_GET_CHARS: {
				
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_CHARS)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }
            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

            *((PSERIAL_CHARS)Irp->AssociatedIrp.SystemBuffer) =
	    					Extension->SpecialChars;
            Irp->IoStatus.Information = sizeof(SERIAL_CHARS);

            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
            break;
        }
        case IOCTL_SERIAL_SET_DTR:
		  case IOCTL_SERIAL_CLR_DTR: {
						
            //
            // Make sure we are at power D0
            //

            if (Extension->PowerState != PowerDeviceD0) {
               Status = CyyGotoPowerState(Extension->Pdo, Extension,
                                             PowerDeviceD0);
               if (!NT_SUCCESS(Status)) {
                      break;
               }
            }
		
            // We acquire the lock so that we can check whether
            // automatic dtr flow control is enabled.  If it is
            // then we return an error since the app is not allowed
            // to touch this if it is automatic.

            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

            if ((Extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK)
                == SERIAL_DTR_HANDSHAKE) {
                // this is a bug from the sample driver.
                //Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                Status = STATUS_INVALID_PARAMETER;
            } else {
                KeSynchronizeExecution(
                    Extension->Interrupt,
                    ((IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                     IOCTL_SERIAL_SET_DTR)?
                     (CyySetDTR):(CyyClrDTR)),
                    Extension
                    );
            }

            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
            break;
        }
        case IOCTL_SERIAL_RESET_DEVICE: {

            break;
        }
        case IOCTL_SERIAL_SET_RTS:
        case IOCTL_SERIAL_CLR_RTS: {

            //
            // Make sure we are at power D0
            //

            if (Extension->PowerState != PowerDeviceD0) {
               Status = CyyGotoPowerState(Extension->Pdo, Extension,
                                             PowerDeviceD0);
               if (!NT_SUCCESS(Status)) {
                  break;
               }
            }

            // We acquire the lock so that we can check whether
            // automatic rts flow control or transmit toggleing
            // is enabled.  If it is then we return an error since
            // the app is not allowed to touch this if it is automatic
            // or toggling.

            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

            if (((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK)
                 == SERIAL_RTS_HANDSHAKE) ||
                ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK)
                 == SERIAL_TRANSMIT_TOGGLE)) {

				// this is a bug from the sample driver.
        	    //Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

				Status = STATUS_INVALID_PARAMETER;
            } else {
                KeSynchronizeExecution(
                    Extension->Interrupt,
                    ((IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                     IOCTL_SERIAL_SET_RTS)?
                     (CyySetRTS):(CyyClrRTS)),
                    Extension
                    );
            }
            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
            break;
        }
        case IOCTL_SERIAL_SET_XOFF: {
		
            KeSynchronizeExecution(
                Extension->Interrupt,
                CyyPretendXoff,
                Extension
                );
            break;

        }
        case IOCTL_SERIAL_SET_XON: {
					
            KeSynchronizeExecution(
                Extension->Interrupt,
                CyyPretendXon,
                Extension
                );
            break;

        }
        case IOCTL_SERIAL_SET_BREAK_ON: {
		
            //
            // Make sure we are at power D0
            //

            if (Extension->PowerState != PowerDeviceD0) {
               Status = CyyGotoPowerState(Extension->Pdo, Extension,
                                             PowerDeviceD0);
               if (!NT_SUCCESS(Status)) {
                  break;
               }
            }
            
            KeSynchronizeExecution(
                Extension->Interrupt,
                CyyTurnOnBreak,
                Extension
                );

            break;
        }
        case IOCTL_SERIAL_SET_BREAK_OFF: {

            //
            // Make sure we are at power D0
            //

            if (Extension->PowerState != PowerDeviceD0) {
               Status = CyyGotoPowerState(Extension->Pdo, Extension,
                                             PowerDeviceD0);
               if (!NT_SUCCESS(Status)) {
                  break;
               }
            }

            KeSynchronizeExecution(
                Extension->Interrupt,
                CyyTurnOffBreak,
                Extension
                );				
							
            break;
        }
        case IOCTL_SERIAL_SET_QUEUE_SIZE: {
		
            // Type ahead buffer is fixed, so we just validate
            // that the users request is not bigger that our
            // own internal buffer size.

            PSERIAL_QUEUE_SIZE Rs =
                ((PSERIAL_QUEUE_SIZE)(Irp->AssociatedIrp.SystemBuffer));

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_QUEUE_SIZE)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }
						
            //
            // We have to allocate the memory for the new
            // buffer while we're still in the context of the
            // caller.  We don't even try to protect this
            // with a lock because the value could be stale
            // as soon as we release the lock - The only time
            // we will know for sure is when we actually try
            // to do the resize.
            //

            if (Rs->InSize <= Extension->BufferSize) {
                Status = STATUS_SUCCESS;
                break;
            }

            try {
                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer =
                    ExAllocatePoolWithQuota(
                        NonPagedPool,
                        Rs->InSize
                        );

            } except (EXCEPTION_EXECUTE_HANDLER) {
                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
                Status = GetExceptionCode();
            }

            if (!IrpSp->Parameters.DeviceIoControl.Type3InputBuffer) {
                break;
            }

            //
            // Well the data passed was big enough.  Do the request.
            //
            // There are two reason we place it in the read queue:
            //
            // 1) We want to serialize these resize requests so that
            //    they don't contend with each other.
            //
            // 2) We want to serialize these requests with reads since
            //    we don't want reads and resizes contending over the
            //    read buffer.
            //

            return CyyStartOrQueue(
                       Extension,
                       Irp,
                       &Extension->ReadQueue,
                       &Extension->CurrentReadIrp,
                       CyyStartRead
                       );
            break;
        }
        case IOCTL_SERIAL_GET_WAIT_MASK: {
		
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            // Simple scalar read.  No reason to acquire a lock.
            Irp->IoStatus.Information = sizeof(ULONG);
            *((ULONG *)Irp->AssociatedIrp.SystemBuffer) = Extension->IsrWaitMask;
            break;
        }
        case IOCTL_SERIAL_SET_WAIT_MASK: {

            ULONG NewMask;

            CyyDbgPrintEx(CYYIRPPATH, "In Ioctl processing for set mask\n");

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(ULONG)) {

                CyyDbgPrintEx(CYYDIAG3, "Invalid size fo the buffer %d\n",
                              IrpSp->Parameters
                              .DeviceIoControl.InputBufferLength);

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            } else {
                NewMask = *((ULONG *)Irp->AssociatedIrp.SystemBuffer);
            }

            // Make sure that the mask only contains valid waitable events.
            if (NewMask & ~(SERIAL_EV_RXCHAR   |
                            SERIAL_EV_RXFLAG   |
                            SERIAL_EV_TXEMPTY  |
                            SERIAL_EV_CTS      |
                            SERIAL_EV_DSR      |
                            SERIAL_EV_RLSD     |
                            SERIAL_EV_BREAK    |
                            SERIAL_EV_ERR      |
                            SERIAL_EV_RING     |
                            SERIAL_EV_PERR     |
                            SERIAL_EV_RX80FULL |
                            SERIAL_EV_EVENT1   |
                            SERIAL_EV_EVENT2)) {

                CyyDbgPrintEx(CYYDIAG3, "Unknown mask %x\n", NewMask);

                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            // Either start this irp or put it on the queue.

            CyyDbgPrintEx(CYYIRPPATH, "Starting or queuing set mask irp %x"
                          "\n", Irp);

            return CyyStartOrQueue(Extension,Irp,&Extension->MaskQueue,
                                   &Extension->CurrentMaskIrp,
                                   CyyStartMask);

        }
        case IOCTL_SERIAL_WAIT_ON_MASK: {
		
            CyyDbgPrintEx(CYYIRPPATH, "In Ioctl processing for wait mask\n");
			
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG)) {

                CyyDbgPrintEx(CYYDIAG3, "Invalid size for the buffer %d\n",
                              IrpSp->Parameters
                              .DeviceIoControl.OutputBufferLength);

                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            // Either start this irp or put it on the queue.

            CyyDbgPrintEx(CYYIRPPATH, "Starting or queuing wait mask irp"
                          "%x\n", Irp);

            return CyyStartOrQueue(
                       Extension,
                       Irp,
                       &Extension->MaskQueue,
                       &Extension->CurrentMaskIrp,
                       CyyStartMask
                       );

        }	
        case IOCTL_SERIAL_IMMEDIATE_CHAR: {

            KIRQL OldIrql;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(UCHAR)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            IoAcquireCancelSpinLock(&OldIrql);
            if (Extension->CurrentImmediateIrp) {
                Status = STATUS_INVALID_PARAMETER;
                IoReleaseCancelSpinLock(OldIrql);
            } else {
                // We can queue the char.  We need to set
                // a cancel routine because flow control could
                // keep the char from transmitting.  Make sure
                // that the irp hasn't already been canceled.

                if (Irp->Cancel) {
                    IoReleaseCancelSpinLock(OldIrql);
                    Status = STATUS_CANCELLED;
                } else {
                    Extension->CurrentImmediateIrp = Irp;
                    Extension->TotalCharsQueued++;
                    IoReleaseCancelSpinLock(OldIrql);
                    CyyStartImmediate(Extension);

                    return STATUS_PENDING;
                }
            }
            break;

        }
        case IOCTL_SERIAL_PURGE: {
            ULONG Mask;
			
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(ULONG)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            // Check to make sure that the mask is valid

            Mask = *((ULONG *)(Irp->AssociatedIrp.SystemBuffer));

            if ((!Mask) || (Mask & (~(SERIAL_PURGE_TXABORT |
                                      SERIAL_PURGE_RXABORT |
                                      SERIAL_PURGE_TXCLEAR |
                                      SERIAL_PURGE_RXCLEAR )))) {

                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            // Either start this irp or put it on the queue.

            return CyyStartOrQueue(
                       Extension,
                       Irp,
                       &Extension->PurgeQueue,
                       &Extension->CurrentPurgeIrp,
                       CyyStartPurge
                       );
        }
        case IOCTL_SERIAL_GET_HANDFLOW: {
				
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                				sizeof(SERIAL_HANDFLOW)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(SERIAL_HANDFLOW);

            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

            *((PSERIAL_HANDFLOW)Irp->AssociatedIrp.SystemBuffer) =
                					Extension->HandFlow;
            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);

            break;

        }
        case IOCTL_SERIAL_SET_HANDFLOW: {
            CYY_IOCTL_SYNC S;
            PSERIAL_HANDFLOW HandFlow = Irp->AssociatedIrp.SystemBuffer;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_HANDFLOW)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }
            // Make sure that there are no invalid bits set.
            if (HandFlow->ControlHandShake & SERIAL_CONTROL_INVALID) {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            if (HandFlow->FlowReplace & SERIAL_FLOW_INVALID) {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            // Make sure that the app hasn't set an invlid DTR mode.
            if((HandFlow->ControlHandShake&SERIAL_DTR_MASK)==SERIAL_DTR_MASK) {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            // Make sure that haven't set totally invalid xon/xoff limits.
            if ((HandFlow->XonLimit < 0) ||
	                ((ULONG)HandFlow->XonLimit > Extension->BufferSize)) {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            if ((HandFlow->XoffLimit < 0) || 
                    ((ULONG)HandFlow->XoffLimit > Extension->BufferSize)) {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            S.Extension = Extension;
            S.Data = HandFlow;


            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

            // Under the protection of the lock, make sure that
            // we aren't turning on error replacement when we
            // are doing line status/modem status insertion.

            if (Extension->EscapeChar) {
                if (HandFlow->FlowReplace & SERIAL_ERROR_CHAR) {
                    Status = STATUS_INVALID_PARAMETER;
                    KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
                    break;
                }
            }

            KeSynchronizeExecution(Extension->Interrupt,CyySetHandFlow,&S);

            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
            break;
        }
        case IOCTL_SERIAL_GET_MODEMSTATUS: {
            CYY_IOCTL_SYNC S;

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
	    						sizeof(ULONG)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(ULONG);

            S.Extension = Extension;
            S.Data = Irp->AssociatedIrp.SystemBuffer;

            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);
            KeSynchronizeExecution(Extension->Interrupt,CyyGetModemUpdate,&S);
            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
            break;
        }
        case IOCTL_SERIAL_GET_DTRRTS: {
            CYY_IOCTL_SYNC S;
            ULONG ModemControl;

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
					                sizeof(ULONG)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(ULONG);
            Irp->IoStatus.Status = STATUS_SUCCESS;

            // Reading this hardware has no effect on the device.
#if 0 
            ModemControl = READ_MODEM_CONTROL(Extension->Controller);

            ModemControl &= SERIAL_DTR_STATE | SERIAL_RTS_STATE;

            *(PULONG)Irp->AssociatedIrp.SystemBuffer = ModemControl;
#endif

            S.Extension = Extension;
            S.Data = &ModemControl;

            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);
            KeSynchronizeExecution(Extension->Interrupt,CyyGetDTRRTS,&S);	        
            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);

            *(PULONG)Irp->AssociatedIrp.SystemBuffer = ModemControl;

            break;

        }
        case IOCTL_SERIAL_GET_COMMSTATUS: {
            CYY_IOCTL_SYNC S;

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
				                sizeof(SERIAL_STATUS)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(SERIAL_STATUS);

            S.Extension = Extension;
            S.Data =  Irp->AssociatedIrp.SystemBuffer;

            // Acquire the cancel spin lock so nothing changes.

            IoAcquireCancelSpinLock(&OldIrql);

            KeSynchronizeExecution(Extension->Interrupt,CyyGetCommStatus,&S);

            IoReleaseCancelSpinLock(OldIrql);
            break;
        }
        case IOCTL_SERIAL_GET_PROPERTIES: {
		
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
				                sizeof(SERIAL_COMMPROP)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }
            // No synchronization is required since information is "static".

            CyyGetProperties(Extension,Irp->AssociatedIrp.SystemBuffer);

            Irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);
            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }
	
        case IOCTL_SERIAL_XOFF_COUNTER: {
            PSERIAL_XOFF_COUNTER Xc = Irp->AssociatedIrp.SystemBuffer;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
				                sizeof(SERIAL_XOFF_COUNTER)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            if (Xc->Counter <= 0) {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // There is no output, so make that clear now
            //

            Irp->IoStatus.Information = 0;  // Added in build 2128

            //
            // So far so good.  Put the irp onto the write queue.
            //

            return CyyStartOrQueue(
                       Extension,
                       Irp,
                       &Extension->WriteQueue,
                       &Extension->CurrentWriteIrp,
                       CyyStartWrite
                       );
        }	
        case IOCTL_SERIAL_LSRMST_INSERT: {
            PUCHAR escapeChar = Irp->AssociatedIrp.SystemBuffer;
            //FANNY: DECLARATION OF S WAS ADDED FOLLOWING NEW SERIAL SOURCE, BUT 
            // S IS NOT USED!!!!
            CYY_IOCTL_SYNC S;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
					                sizeof(UCHAR)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

            if (*escapeChar) {
                // We've got some escape work to do.  We will make sure that
                // the character is not the same as the Xon or Xoff character,
                // or that we are already doing error replacement.

                if ((*escapeChar == Extension->SpecialChars.XoffChar) ||
                    (*escapeChar == Extension->SpecialChars.XonChar) ||
                    (Extension->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)) {

                    Status = STATUS_INVALID_PARAMETER;
                    KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
                    break;
                }
            }

            S.Extension = Extension;
            S.Data = Irp->AssociatedIrp.SystemBuffer;

            KeSynchronizeExecution(Extension->Interrupt,CyySetEscapeChar,Irp);

            KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
            break;
        }
        case IOCTL_SERIAL_CONFIG_SIZE: {
		
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
					                sizeof(ULONG)) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(ULONG);
            Irp->IoStatus.Status = STATUS_SUCCESS;

            *(PULONG)Irp->AssociatedIrp.SystemBuffer = 0;

            break;
        }
        case IOCTL_SERIAL_GET_STATS: {
		
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIALPERF_STATS)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }
            Irp->IoStatus.Information = sizeof(SERIALPERF_STATS);
            Irp->IoStatus.Status = STATUS_SUCCESS;

            KeSynchronizeExecution(
                Extension->Interrupt,
                CyyGetStats,
                Irp
                );			
				
            break;
		  }
        case IOCTL_SERIAL_CLEAR_STATS: {
			
            KeSynchronizeExecution(
                Extension->Interrupt,
                CyyClearStats,
                Extension
                );
            break;
        }
        default: {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

DoneWithIoctl:;

    Irp->IoStatus.Status = Status;

    CyyCompleteRequest(Extension, Irp, 0);

    return Status;
}

VOID
CyyGetProperties(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN PSERIAL_COMMPROP Properties
    )
/*--------------------------------------------------------------------------
    CyyGetProperties()
    
    Routine Description: This function returns the capabilities of this
    particular serial device.

    Arguments:

    Extension - The serial device extension.
    Properties - The structure used to return the properties

    Return Value:

    None.
--------------------------------------------------------------------------*/
{
    CYY_LOCKED_PAGED_CODE();

    RtlZeroMemory(Properties,sizeof(SERIAL_COMMPROP));

    Properties->PacketLength = sizeof(SERIAL_COMMPROP);
    Properties->PacketVersion = 2;
    Properties->ServiceMask = SERIAL_SP_SERIALCOMM;
    Properties->MaxTxQueue = 0;
    Properties->MaxRxQueue = 0;

    Properties->MaxBaud = SERIAL_BAUD_USER;
    Properties->SettableBaud = Extension->SupportedBauds;

    Properties->ProvSubType = SERIAL_SP_RS232;
    
    Properties->ProvCapabilities = SERIAL_PCF_DTRDSR |
                                   SERIAL_PCF_RTSCTS |
                                   SERIAL_PCF_CD     |
                                   SERIAL_PCF_PARITY_CHECK |
                                   SERIAL_PCF_XONXOFF |
                                   SERIAL_PCF_SETXCHAR |
                                   SERIAL_PCF_TOTALTIMEOUTS |
                                   SERIAL_PCF_INTTIMEOUTS;
    Properties->SettableParams = SERIAL_SP_PARITY |
                                 SERIAL_SP_BAUD |
                                 SERIAL_SP_DATABITS |
                                 SERIAL_SP_STOPBITS |
                                 SERIAL_SP_HANDSHAKING |
                                 SERIAL_SP_PARITY_CHECK |
                                 SERIAL_SP_CARRIER_DETECT;


    Properties->SettableData = SERIAL_DATABITS_5 |
                               SERIAL_DATABITS_6 |
                               SERIAL_DATABITS_7 |
                               SERIAL_DATABITS_8;
    Properties->SettableStopParity = SERIAL_STOPBITS_10 |
                                     SERIAL_STOPBITS_15 |
                                     SERIAL_STOPBITS_20 |
                                     SERIAL_PARITY_NONE |
                                     SERIAL_PARITY_ODD  |
                                     SERIAL_PARITY_EVEN |
                                     SERIAL_PARITY_MARK |
                                     SERIAL_PARITY_SPACE;
    Properties->CurrentTxQueue = 0;
    Properties->CurrentRxQueue = Extension->BufferSize;

}


BOOLEAN
CyySetRxFifoThresholdUsingRxFifoTrigger(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyySetRxFifoThresholdUsingRxFifoTrigger()
    
    Routine Description: set the baud rate of the device.

    Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension.

    Return Value: This routine always returns FALSE if error; 
	               TRUE if successful.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION pDevExt = Context;
    PUCHAR chip = pDevExt->Cd1400;
    ULONG bus = pDevExt->IsPci;
    UCHAR cor3value;
 
    CYY_LOCKED_PAGED_CODE();
    
    CD1400_WRITE(chip,bus,CAR, pDevExt->CdChannel & 0x03);
    cor3value = CD1400_READ(chip,bus,COR3);
    cor3value &= 0xf0;
    switch (pDevExt->RxFifoTrigger & 0xc0) {
    case SERIAL_1_BYTE_HIGH_WATER:
        cor3value |= 0x01;
        break;
    case SERIAL_4_BYTE_HIGH_WATER:
        cor3value |= 0x04;
        break;
    case SERIAL_8_BYTE_HIGH_WATER:
        cor3value |= 0x08;
        break;
    case SERIAL_14_BYTE_HIGH_WATER:
        cor3value |= MAX_CHAR_FIFO;
        break;
    }
    CD1400_WRITE(chip,bus,COR3, cor3value);
    CyyCDCmd(pDevExt,CCR_CORCHG_COR3);
    pDevExt->RxFifoTriggerUsed = TRUE;

    return TRUE;
}


BOOLEAN
CyySetRxFifoThresholdUsingBaudRate(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyySetRxFifoThresholdUsingBaudRate()
    
    Routine Description: set the baud rate of the device.

    Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension.

    Return Value: This routine always returns FALSE if error; 
	               TRUE if successful.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION pDevExt = Context;
    PUCHAR chip = pDevExt->Cd1400;
    ULONG bus = pDevExt->IsPci;
    ULONG baud = pDevExt->CurrentBaud;
    UCHAR cor3value;
 
    CYY_LOCKED_PAGED_CODE();

    // Restore COR3 accordingly to baud rate
    cor3value = CD1400_READ(chip,bus,COR3);
    cor3value &= 0xf0;
    if(baud <= 9600) {
        CD1400_WRITE(chip,bus,COR3, cor3value | 0x0a);
    } else if (baud <= 38400) {
        CD1400_WRITE(chip,bus,COR3, cor3value | 0x06);
          } else {
        CD1400_WRITE(chip,bus,COR3, cor3value | 0x04);
    }
    CyyCDCmd(pDevExt,CCR_CORCHG_COR3);
    pDevExt->RxFifoTriggerUsed = FALSE;
    
    return TRUE;
}


NTSTATUS
CyyInternalIoControl(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)

/*++

Routine Description:

    This routine provides the initial processing for all of the
    internal Ioctrls for the serial device.

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS status;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION pIrpStack;

    //
    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    //
    PCYY_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

    //
    // A temporary to hold the old IRQL so that it can be
    // restored once we complete/validate this request.
    //
    KIRQL OldIrql;

    NTSTATUS prologueStatus;

    SYSTEM_POWER_STATE cap; // Added in build 2128

    CYY_LOCKED_PAGED_CODE();


    if ((prologueStatus = CyyIRPPrologue(PIrp, pDevExt))
        != STATUS_SUCCESS) {
       CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
       return prologueStatus;
    }

    CyyDbgPrintEx(CYYIRPPATH, "Dispatch entry for: %x\n", PIrp);

    if (CyyCompleteIfError(PDevObj, PIrp) != STATUS_SUCCESS) {
        return STATUS_CANCELLED;
    }

    pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
    PIrp->IoStatus.Information = 0L;
    status = STATUS_SUCCESS;

    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Send a wait-wake IRP
    //

    case IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE:
       //
       // Make sure we can do wait-wake based on what the device reported
       //

       for (cap = PowerSystemSleeping1; cap < PowerSystemMaximum; cap++) { // Added in bld 2128
          if ((pDevExt->DeviceStateMap[cap] >= PowerDeviceD0)
              && (pDevExt->DeviceStateMap[cap] <= pDevExt->DeviceWake)) {
             break;
          }
       }

       if (cap < PowerSystemMaximum) {
          pDevExt->SendWaitWake = TRUE;
          status = STATUS_SUCCESS;
       } else {
          status = STATUS_NOT_SUPPORTED;
       }
       break;

    case IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE:
       pDevExt->SendWaitWake = FALSE;

       if (pDevExt->PendingWakeIrp != NULL) {
          IoCancelIrp(pDevExt->PendingWakeIrp);
       }

       status = STATUS_SUCCESS;
       break;


    //
    // Put the serial port in a "filter-driver" appropriate state
    //
    // WARNING: This code assumes it is being called by a trusted kernel
    // entity and no checking is done on the validity of the settings
    // passed to IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS
    //
    // If validity checking is desired, the regular ioctl's should be used
    //

    case IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS:
    case IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS: {
       SERIAL_BASIC_SETTINGS basic;
       PSERIAL_BASIC_SETTINGS pBasic;
       SHORT AppropriateDivisor;
       CYY_IOCTL_SYNC S;

       if (pIrpStack->Parameters.DeviceIoControl.IoControlCode
           == IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS) {


          //
          // Check the buffer size
          //

          if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(SERIAL_BASIC_SETTINGS)) {
             status = STATUS_BUFFER_TOO_SMALL;
             break;
          }

          //
          // Everything is 0 -- timeouts and flow control and fifos.  If
          // We add additional features, this zero memory method
          // may not work.
          //

          RtlZeroMemory(&basic, sizeof(SERIAL_BASIC_SETTINGS));

          basic.TxFifo = 1;
          basic.RxFifo = SERIAL_1_BYTE_HIGH_WATER;

          PIrp->IoStatus.Information = sizeof(SERIAL_BASIC_SETTINGS);
          pBasic = (PSERIAL_BASIC_SETTINGS)PIrp->AssociatedIrp.SystemBuffer;

          //
          // Save off the old settings
          //

          RtlCopyMemory(&pBasic->Timeouts, &pDevExt->Timeouts,
                        sizeof(SERIAL_TIMEOUTS));

          RtlCopyMemory(&pBasic->HandFlow, &pDevExt->HandFlow,
                        sizeof(SERIAL_HANDFLOW));

          pBasic->RxFifo = pDevExt->RxFifoTrigger;
          pBasic->TxFifo = pDevExt->TxFifoAmount;

          //
          // Point to our new settings
          //

          pBasic = &basic;

          pDevExt->RxFifoTrigger = (UCHAR)pBasic->RxFifo;

          // Set COR3 accordingly to RxFifoTrigger
          KeSynchronizeExecution(pDevExt->Interrupt, 
                                 CyySetRxFifoThresholdUsingRxFifoTrigger, pDevExt);

       } else { // restoring settings
          if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength
              < sizeof(SERIAL_BASIC_SETTINGS)) {
             status = STATUS_BUFFER_TOO_SMALL;
             break;
          }


          pBasic = (PSERIAL_BASIC_SETTINGS)PIrp->AssociatedIrp.SystemBuffer;

          // Restore COR3 accordingly to baud rate
          KeSynchronizeExecution(pDevExt->Interrupt, 
                                 CyySetRxFifoThresholdUsingBaudRate, pDevExt);

       }

       KeAcquireSpinLock(&pDevExt->ControlLock, &OldIrql);

       //
       // Set the timeouts
       //

       RtlCopyMemory(&pDevExt->Timeouts, &pBasic->Timeouts,
                     sizeof(SERIAL_TIMEOUTS));

       //
       // Set flowcontrol
       //

       S.Extension = pDevExt;
       S.Data = &pBasic->HandFlow;
       KeSynchronizeExecution(pDevExt->Interrupt, CyySetHandFlow, &S);


// CHANGED FANNY
//       if (pDevExt->FifoPresent) {
//          pDevExt->TxFifoAmount = pBasic->TxFifo;
//          pDevExt->RxFifoTrigger = (UCHAR)pBasic->RxFifo;
//
//          WRITE_FIFO_CONTROL(pDevExt->Controller, (UCHAR)0);
//          READ_RECEIVE_BUFFER(pDevExt->Controller);
//          WRITE_FIFO_CONTROL(pDevExt->Controller,
//                             (UCHAR)(SERIAL_FCR_ENABLE | pDevExt->RxFifoTrigger
//                                     | SERIAL_FCR_RCVR_RESET
//                                     | SERIAL_FCR_TXMT_RESET));
//       } else {
//          pDevExt->TxFifoAmount = pDevExt->RxFifoTrigger = 0;
//          WRITE_FIFO_CONTROL(pDevExt->Controller, (UCHAR)0);
//       }

       if ((pBasic->TxFifo > MAX_CHAR_FIFO) || (pBasic->TxFifo < 1)) {
          pDevExt->TxFifoAmount = MAX_CHAR_FIFO;
       } else {
          pDevExt->TxFifoAmount = pBasic->TxFifo;
       }

       KeReleaseSpinLock(&pDevExt->ControlLock, OldIrql);


       break;
    }

    default:
       status = STATUS_INVALID_PARAMETER;
       break;

    }

    PIrp->IoStatus.Status = status;

    CyyCompleteRequest(pDevExt, PIrp, 0);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyyintr.c ===
/*--------------------------------------------------------------------------
*
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*
*   Cyclom-Y Port Driver
*	
*   This file:      cyyintr.c
*
*   Description:    This module contains the code related to interrupt
*                   handling in the Cyclom-Y Port driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*
*   Complies with Cyclades SW Coding Standard rev 1.3.
*
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/
#include "precomp.h"

// FANNY: THIS WAS IN CYINIT.C. IT WILL PROBABLY DESAPPEAR FROM HERE TOO.
//extern const unsigned long CyyCDOffset[];
const unsigned long CyyCDOffset[] = {	// CD1400 offsets within the board
    0x00000000,0x00000400,0x00000800,0x00000C00,
    0x00000200,0x00000600,0x00000A00,0x00000E00
    };
 


//ADDED TO DEBUG_RTPR
extern PDRIVER_OBJECT CyyDO;
//END DEBUG_RTPR

#ifdef ALLOC_PRAGMA
//#pragma alloc_text(PAGESER,CyyIsr)
//#pragma alloc_text(PAGESER,CyyPutChar)
//#pragma alloc_text(PAGESER,CyyProcessLSR)
//#pragma alloc_text(PAGESER,CyyTxStart)
//#pragma alloc_text(PAGESER,CyySendXon)
//#pragma alloc_text(PAGESER,CyySendXoff)
#endif


BOOLEAN
CyyIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyyIsr()
    
    Routine Description: This is the interrupt service routine for the
    Cyclom-Y Port driver.

    Arguments:

    InterruptObject - Pointer to interrupt object (not used).

    Context - Pointer to the device extension for this device.

    Return Value: This function will return TRUE if the serial port is
    the source of this interrupt, FALSE otherwise.
--------------------------------------------------------------------------*/
{
   PCYY_DISPATCH Dispatch = Context;
   PCYY_DEVICE_EXTENSION Extension;

   BOOLEAN ServicedAnInterrupt = FALSE;

   PUCHAR chip;
   PUCHAR mappedboard = NULL;
   ULONG bus = Dispatch->IsPci;
   unsigned char status, save_xir, save_car, x, rxchar=0;
   ULONG i,channel,chipindex,portindex;
   UCHAR misr;

   BOOLEAN thisChipInterrupted;
   PCYY_DEVICE_EXTENSION interlockedExtension[CYY_CHANNELS_PER_CHIP];

   UNREFERENCED_PARAMETER(InterruptObject);	

   //DbgPrint("Isr>\n");
   
   // Loop polling all chips in the board
   for(portindex = 0 ; portindex < CYY_MAX_PORTS ;) {

      if (!(Extension=Dispatch->Extensions[portindex]) || 
          !(chip=Dispatch->Cd1400[portindex])) {
         portindex++;
         continue;
      }
      chipindex = portindex/4;
      mappedboard = Extension->BoardMemory;
      thisChipInterrupted = FALSE;
      interlockedExtension[0] = interlockedExtension[1]
         = interlockedExtension[2] = interlockedExtension[3] = 0;
      

      while ((status = CD1400_READ(chip,bus,SVRR)) != 0x00) {
         ServicedAnInterrupt = TRUE;
         thisChipInterrupted = TRUE;

         if (status & 0x01) {
            //Reception
            save_xir = CD1400_READ(chip,bus,RIR);
            channel = (ULONG) (save_xir & 0x03);
            save_car = CD1400_READ(chip,bus,CAR);
            CD1400_WRITE(chip,bus,CAR,save_xir);
            Extension = Dispatch->Extensions[channel + CYY_CHANNELS_PER_CHIP*chipindex];
            x = CD1400_READ(chip,bus,RIVR) & 0x07;
            if (Extension) {
               //
               // Apply lock so if close happens concurrently we don't miss the DPC
               // queueing
               //
               if (interlockedExtension[channel] == NULL) {
                  interlockedExtension[channel] = Extension;
                  InterlockedIncrement(&Extension->DpcCount);
                  LOGENTRY(LOG_CNT, 'DpI3', 0, Extension->DpcCount, 0); // Added in bld 2128
               }
               if (x == 0x07) { // exception
                  x = CD1400_READ(chip,bus,RDSR);	// status
                  CyyDbgPrintEx(DPFLTR_WARNING_LEVEL, "exception %x\n",x);

                  if (Extension->DeviceIsOpened && 
                      (Extension->PowerState == PowerDeviceD0)) {
			
                     if (x & CYY_LSR_ERROR){
                        BOOLEAN ProcessRxChar;
					
                        if (!(x & CYY_LSR_OE)) {
                           rxchar = CD1400_READ(chip,bus,RDSR);	// error data
                        }

                        // TODO: SERIAL SAMPLE FOR W2000 HAS ADDED 
                        // CHECKING FOR EscapeChar TO BREAK TO RX LOOP
                        // IN CASE OF ERROR.
                        ProcessRxChar = CyyProcessLSR(Extension,x,rxchar);

                        if (ProcessRxChar) {
                           x = 1;	// 1 character
                           i = 0;	// prepare for for(;;) 
                           goto Handle_rxchar;
                        }
                     } // end error handling
                  } // end if DeviceIsOpened..
               
               } else { // good reception
                  x = CD1400_READ(chip,bus,RDCR);
                  if (Extension->DeviceIsOpened &&
                      (Extension->PowerState == PowerDeviceD0)) {
                     for(i = 0 ; i < x ; i++) {	// read from FIFO

                        rxchar = CD1400_READ(chip,bus,RDSR);
         Handle_rxchar:
                        Extension->PerfStats.ReceivedCount++;
                        Extension->WmiPerfData.ReceivedCount++;
                        rxchar &= Extension->ValidDataMask;
    
                        if (!rxchar &&	// NULL stripping
                            (Extension->HandFlow.FlowReplace &
                             SERIAL_NULL_STRIPPING)) {				   
                           continue;
                        }
    
                        if((Extension->HandFlow.FlowReplace &
                            SERIAL_AUTO_TRANSMIT) &&
                           ((rxchar == Extension->SpecialChars.XonChar) ||
                           (rxchar == Extension->SpecialChars.XoffChar))) {
                           if (rxchar == Extension->SpecialChars.XoffChar) {
                              Extension->TXHolding |= CYY_TX_XOFF;
                              if ((Extension->HandFlow.FlowReplace &
                                 SERIAL_RTS_MASK) ==
                                   SERIAL_TRANSMIT_TOGGLE) {
    
                                 CyyInsertQueueDpc(
                                    &Extension->StartTimerLowerRTSDpc,
                                    NULL,
                                    NULL,
                                    Extension
                                 )?Extension->CountOfTryingToLowerRTS++:0;
                              }
                           } else {
                              if (Extension->TXHolding & CYY_TX_XOFF) {
                                 Extension->TXHolding &= ~CYY_TX_XOFF;
                              }
                           }
                           continue;
                        }
                        // Check to see if we should note the receive
                        // character or special character event.
                        if (Extension->IsrWaitMask) {
                           if (Extension->IsrWaitMask & SERIAL_EV_RXCHAR) {
                              Extension->HistoryMask |= SERIAL_EV_RXCHAR;
                           }
                           if ((Extension->IsrWaitMask & SERIAL_EV_RXFLAG) &&
                               (Extension->SpecialChars.EventChar == rxchar)) {
    
                              Extension->HistoryMask |= SERIAL_EV_RXFLAG;
                           }
    
                           if (Extension->IrpMaskLocation && Extension->HistoryMask) {
                             *Extension->IrpMaskLocation = Extension->HistoryMask;
                              Extension->IrpMaskLocation = NULL;
                              Extension->HistoryMask = 0;
    
                              Extension->CurrentWaitIrp->IoStatus.Information = 
                              sizeof(ULONG);
                              CyyInsertQueueDpc(&Extension->CommWaitDpc,NULL,NULL,Extension);
                           }
                        }
                        CyyPutChar(Extension,rxchar);
    
                        // If we're doing line status and modem
                        // status insertion then we need to insert
                        // a zero following the character we just
                        // placed into the buffer to mark that this
                        // was reception of what we are using to
                        // escape.
    
                        if (Extension->EscapeChar &&
                            (Extension->EscapeChar == rxchar)) {
                           CyyPutChar(Extension,SERIAL_LSRMST_ESCAPE);
                        }
                     } // end for
                  } else {	// device is being closed, discard rx chars
                     for(i = 0 ; i < x ; i++)    rxchar = CD1400_READ(chip,bus,RDSR);
                  } // end if device is opened else closed
               }
            } else { 
               // No Extension
               if (x == 0x07) { // exception
                  x = CD1400_READ(chip,bus,RDSR);	// status
               } else { // good char
                  x = CD1400_READ(chip,bus,RDCR);  // number of chars
                  for(i = 0 ; i < x ; i++)    rxchar = CD1400_READ(chip,bus,RDSR);
               }
            }		
            CD1400_WRITE(chip,bus,RIR,(save_xir & 0x3f));	// end service
            CD1400_WRITE(chip,bus,CAR,save_car);

         } // end reception

         if (status & 0x02) {
            //Transmission
            save_xir = CD1400_READ(chip,bus,TIR);
            channel = (ULONG) (save_xir & 0x03);
            save_car = CD1400_READ(chip,bus,CAR);
            CD1400_WRITE(chip,bus,CAR,save_xir);
            Extension = Dispatch->Extensions[channel + CYY_CHANNELS_PER_CHIP*chipindex];
            if (Extension) {
               //
               // Apply lock so if close happens concurrently we don't miss the DPC
               // queueing
               //
               if (interlockedExtension[channel] == NULL) {
                  interlockedExtension[channel] = Extension;
                  InterlockedIncrement(&Extension->DpcCount);
                  LOGENTRY(LOG_CNT, 'DpI3', 0, Extension->DpcCount, 0); // Added in build 2128
               }
               Extension->HoldingEmpty = TRUE;
               if( Extension->DeviceIsOpened &&
                  (Extension->PowerState == PowerDeviceD0)) {

                  if (Extension->BreakCmd != NO_BREAK) {

                     if (Extension->BreakCmd == SEND_BREAK) {
                        if ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
    			                  SERIAL_TRANSMIT_TOGGLE) {
			                  CyySetRTS(Extension);
                        }										
                        CD1400_WRITE(chip,bus,TDR,(unsigned char) 0x00); // escape sequence
                        CD1400_WRITE(chip,bus,TDR,(unsigned char) 0x81); // Send Break
                        Extension->TXHolding |= CYY_TX_BREAK;
                        Extension->HoldingEmpty = FALSE;
                        Extension->BreakCmd = DISABLE_ETC;		
                     } else if (Extension->BreakCmd == STOP_BREAK){
                        if (Extension->TXHolding & CYY_TX_BREAK) {					
                           CD1400_WRITE(chip,bus,TDR,(unsigned char) 0x00); // escape sequence
                           CD1400_WRITE(chip,bus,TDR,(unsigned char) 0x83); // Stop Break
                           Extension->HoldingEmpty = FALSE;
                           Extension->TXHolding &= ~CYY_TX_BREAK;
                        }
                        Extension->BreakCmd = DISABLE_ETC;
                     } else if (Extension->BreakCmd == DISABLE_ETC) {
                        UCHAR cor2;
                        cor2 = CD1400_READ(chip,bus,COR2);
                        CD1400_WRITE(chip,bus, COR2,cor2 & ~EMBED_TX_ENABLE); // disable ETC bit
                        CyyCDCmd(Extension,CCR_CORCHG_COR2);  // COR2 changed
                        Extension->BreakCmd = NO_BREAK;

                        if (!Extension->TXHolding &&
                           (Extension->TransmitImmediate ||
                           Extension->WriteLength) &&
                           Extension->HoldingEmpty) {

                           //CyyTxStart(Extension);  no need for CyyTxStart from here.

                        } else {
                           UCHAR srer = CD1400_READ(chip,bus,SRER);
                           CD1400_WRITE(chip,bus,SRER,srer & (~SRER_TXRDY));

                           //
                           // The following routine will lower the rts if we
                           // are doing transmit toggleing and there is no
                           // reason to keep it up.
                           //

                           Extension->CountOfTryingToLowerRTS++;
                           CyyPerhapsLowerRTS(Extension);
                        }

                     }

                  } else {

                     // This is not a Send Break. 
                     // Check if there are bytes to be transmitted

                     if (Extension->WriteLength || Extension->TransmitImmediate) {
		     
                        Extension->EmptiedTransmit = TRUE;
                        if (Extension->HandFlow.ControlHandShake &
                           SERIAL_OUT_HANDSHAKEMASK) {
                           CyyHandleModemUpdate(Extension,TRUE);
                        }
			
                        if (Extension->TransmitImmediate&&(!Extension->TXHolding ||
                            (Extension->TXHolding == CYY_TX_XOFF) )) {

                           Extension->TransmitImmediate = FALSE;

                           if ((Extension->HandFlow.FlowReplace &
                                SERIAL_RTS_MASK) == SERIAL_TRANSMIT_TOGGLE) {

                              CyySetRTS(Extension);
                              Extension->PerfStats.TransmittedCount++;
                              Extension->WmiPerfData.TransmittedCount++;
                              CD1400_WRITE(chip,bus,TDR,(unsigned char)(Extension->ImmediateChar));
				
                              CyyInsertQueueDpc(
                                 &Extension->StartTimerLowerRTSDpc,NULL,NULL,
                                 Extension)? Extension->CountOfTryingToLowerRTS++:0;
                           } else {
                              Extension->PerfStats.TransmittedCount++;
                              Extension->WmiPerfData.TransmittedCount++;
                              CD1400_WRITE(chip,bus,TDR,(unsigned char)(Extension->ImmediateChar));
                           }
   
                           Extension->HoldingEmpty = FALSE;

                           CyyInsertQueueDpc(
                              &Extension->CompleteImmediateDpc,
                              NULL,
                              NULL,
                              Extension
                              );
                        } else if (!Extension->TXHolding) {

                           ULONG amountToWrite;

                           amountToWrite = 
                              (Extension->TxFifoAmount < Extension->WriteLength)?
                              Extension->TxFifoAmount:Extension->WriteLength;

                           if ((Extension->HandFlow.FlowReplace &
                              SERIAL_RTS_MASK) ==
                              SERIAL_TRANSMIT_TOGGLE) {

                              // We have to raise if we're sending
                              // this character.

                              CyySetRTS(Extension);

                              for(i = 0 ; i < amountToWrite ; i++) { // write to FIFO
                                 CD1400_WRITE(chip,bus,TDR,((unsigned char *)
                                                            (Extension->WriteCurrentChar))[i]);
                              }
                              Extension->PerfStats.TransmittedCount += amountToWrite;
                              Extension->WmiPerfData.TransmittedCount += amountToWrite;

                              CyyInsertQueueDpc(
                                 &Extension->StartTimerLowerRTSDpc,
                                 NULL,
                                 NULL,
                                 Extension
                                 )?Extension->CountOfTryingToLowerRTS++:0;

                           } else {

                              for(i = 0 ; i < amountToWrite ; i++) { // write to FIFO
                                 CD1400_WRITE(chip,bus,TDR,((unsigned char *)
                                                            (Extension->WriteCurrentChar))[i]);
                              }
                              Extension->PerfStats.TransmittedCount += amountToWrite;
                              Extension->WmiPerfData.TransmittedCount += amountToWrite;
                          }

                           Extension->HoldingEmpty = FALSE;
                           Extension->WriteCurrentChar += amountToWrite;
                           Extension->WriteLength -= amountToWrite;

                           if (!Extension->WriteLength) {

                              PIO_STACK_LOCATION IrpSp;
                              //
                              // No More characters left.  This
                              // write is complete.  Take care
                              // when updating the information field,
                              // we could have an xoff counter masquerading
                              // as a write irp.
                              //

                              IrpSp = IoGetCurrentIrpStackLocation(
                                          Extension->CurrentWriteIrp
                                      );

                              Extension->CurrentWriteIrp->IoStatus.Information =
                                       (IrpSp->MajorFunction == IRP_MJ_WRITE)?
                                       (IrpSp->Parameters.Write.Length):
                                       (1);

                              CyyInsertQueueDpc(
                                       &Extension->CompleteWriteDpc,
                                       NULL,
                                       NULL,
                                       Extension
                                       );
                           } // end write complete
                        } // end of if(!TXHolding)
						
                     } else { // nothing to be transmitted - disable interrupts.
                        UCHAR srer;
                        Extension->EmptiedTransmit = TRUE;
                        srer = CD1400_READ(chip,bus,SRER);
                        CD1400_WRITE(chip,bus,SRER,srer & (~SRER_TXRDY));
                     } 
		 
                  } // end of if(break)		 
		
               } else {	// Device is closed. Disable interrupts
                  UCHAR srer = CD1400_READ(chip,bus,SRER);
                  CD1400_WRITE(chip,bus,SRER,srer & (~SRER_TXRDY));
                  Extension->EmptiedTransmit = TRUE;
               }
            } else {
               // Device was not created, no extension attached.
               UCHAR srer = CD1400_READ(chip,bus,SRER);
               CD1400_WRITE(chip,bus,SRER,srer & (~SRER_TXRDY));
            } // end if Extension
            CD1400_WRITE(chip,bus,TIR,(save_xir & 0x3f));	// end service
            CD1400_WRITE(chip,bus,CAR,save_car);

         } // end transmission

         if (status & 0x04) {
            //Modem
            save_xir = CD1400_READ(chip,bus,MIR);
            channel = (ULONG) (save_xir & 0x03);
            save_car = CD1400_READ(chip,bus,CAR);
            CD1400_WRITE(chip,bus,CAR,save_xir);
				
            //CyyDump(CYYDIAG5,("modem\n"));
				
            Extension = Dispatch->Extensions[channel + CYY_CHANNELS_PER_CHIP*chipindex];
            if (Extension) {
               //
               // Apply lock so if close happens concurrently we don't miss the DPC
               // queueing
               //
               if (interlockedExtension[channel] == NULL) {
                  interlockedExtension[channel] = Extension;
                  InterlockedIncrement(&Extension->DpcCount);
                  LOGENTRY(LOG_CNT, 'DpI3', 0, Extension->DpcCount, 0); // Added in build 2128
               }
               if (Extension->DeviceIsOpened &&
                  (Extension->PowerState == PowerDeviceD0)) {
                  misr = CD1400_READ(chip,bus,MISR);
                  CyyHandleModemUpdateForModem(Extension,FALSE,misr);
               }
            }
            CD1400_WRITE(chip,bus,MIR,(save_xir & 0x3f));	// end service
            CD1400_WRITE(chip,bus,CAR,save_car);

         } // end modem
      } // end READ SVRR
      if (thisChipInterrupted) {
         for (channel=0; channel<CYY_CHANNELS_PER_CHIP; channel++) {
            if (Extension = interlockedExtension[channel]) {
               LONG pendingCnt;

               //
               // Increment once more.  This is just a quick test to see if we
               // have a chance of causing the event to fire... we don't want
               // to run a DPC on every ISR if we don't have to....
               //

retryDPCFiring:;

               InterlockedIncrement(&Extension->DpcCount);
               LOGENTRY(LOG_CNT, 'DpI4', 0, Extension->DpcCount, 0); // Added in build 2128

               //
               // Decrement and see if the lock above looks like the only one left.
               //

               pendingCnt = InterlockedDecrement(&Extension->DpcCount);
//             LOGENTRY(LOG_CNT, 'DpD5', 0, Extension->DpcCount, 0); // Added in build 2128

               if (pendingCnt == 1) {
                  KeInsertQueueDpc(&Extension->IsrUnlockPagesDpc, NULL, NULL);
               } else {
                  if (InterlockedDecrement(&Extension->DpcCount) == 0) {

//                     LOGENTRY(LOG_CNT, 'DpD6', &Extension->IsrUnlockPagesDpc, // Added in bld 2128
//                                Extension->DpcCount, 0);

                     //
                     // We missed it.  Retry...
                     //
   
                     InterlockedIncrement(&Extension->DpcCount);
                     goto retryDPCFiring;
                  }
               } 

            } // if (Extension = interlockedExtension[]) 
         } // for (;channel<CYY_CHANNELS_PER_CHIP;)

         portindex = (chipindex+1)*4;
         continue;

      } // if (thisChipInterrupted)

      portindex++;

   } // for(;portindex<CYY_MAX_PORTS;);

   if (mappedboard) {
      CYY_CLEAR_INTERRUPT(mappedboard,Dispatch->IsPci); 
   }

   //DbgPrint("<Isr\n");

   return ServicedAnInterrupt;
}



VOID
CyyPutChar(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN UCHAR CharToPut
    )
/*--------------------------------------------------------------------------
    CyyPutChar()
    
    Routine Description: This routine, which only runs at device level,
    takes care of placing a character into the typeahead (receive) buffer.

    Arguments:

    Extension - The serial device extension.

    Return Value: None.
--------------------------------------------------------------------------*/
{

   CYY_LOCKED_PAGED_CODE();

    // If we have dsr sensitivity enabled then
    // we need to check the modem status register
    // to see if it has changed.

    if (Extension->HandFlow.ControlHandShake & SERIAL_DSR_SENSITIVITY) {
        CyyHandleModemUpdate(Extension,FALSE);

        if (Extension->RXHolding & CYY_RX_DSR) {
            // We simply act as if we haven't seen the character if
            // dsr line is low.
            return;
        }
    }

    // If the xoff counter is non-zero then decrement it.
    // If the counter then goes to zero, complete that irp.

    if (Extension->CountSinceXoff) {
        Extension->CountSinceXoff--;
        if (!Extension->CountSinceXoff) {
            Extension->CurrentXoffIrp->IoStatus.Status = STATUS_SUCCESS;
            Extension->CurrentXoffIrp->IoStatus.Information = 0;
            CyyInsertQueueDpc(&Extension->XoffCountCompleteDpc,NULL,NULL,Extension);
        }
    }
    
    // Check to see if we are copying into the
    // users buffer or into the interrupt buffer.
    //
    // If we are copying into the user buffer
    // then we know there is always room for one more.
    // (We know this because if there wasn't room
    // then that read would have completed and we
    // would be using the interrupt buffer.)
    //
    // If we are copying into the interrupt buffer
    // then we will need to check if we have enough
    // room.

    if (Extension->ReadBufferBase != Extension->InterruptReadBuffer) {

        // Increment the following value so
        // that the interval timer (if one exists
        // for this read) can know that a character
        // has been read.

        Extension->ReadByIsr++;

        // We are in the user buffer.  Place the character into the buffer.
		// See if the read is complete.

        *Extension->CurrentCharSlot = CharToPut;

        if (Extension->CurrentCharSlot == Extension->LastCharSlot) {
	    
            // We've filled up the users buffer.
            // Switch back to the interrupt buffer
            // and send off a DPC to Complete the read.
            //
            // It is inherent that when we were using
            // a user buffer that the interrupt buffer
            // was empty.

            Extension->ReadBufferBase = Extension->InterruptReadBuffer;
            Extension->CurrentCharSlot = Extension->InterruptReadBuffer;
            Extension->FirstReadableChar = Extension->InterruptReadBuffer;
            Extension->LastCharSlot = Extension->InterruptReadBuffer +
						(Extension->BufferSize - 1);
            Extension->CharsInInterruptBuffer = 0;

            Extension->CurrentReadIrp->IoStatus.Information =
                IoGetCurrentIrpStackLocation(
                    Extension->CurrentReadIrp
                    )->Parameters.Read.Length;

            CyyInsertQueueDpc(&Extension->CompleteReadDpc,NULL,NULL,Extension);
        } else {
            // Not done with the users read.
            Extension->CurrentCharSlot++;
        }
    } else {
        // We need to see if we reached our flow
        // control threshold.  If we have then
        // we turn on whatever flow control the
        // owner has specified.  If no flow
        // control was specified, well..., we keep
        // trying to receive characters and hope that
        // we have enough room.  Note that no matter
        // what flow control protocol we are using, it
        // will not prevent us from reading whatever
        // characters are available.

        if ((Extension->HandFlow.ControlHandShake
             & SERIAL_DTR_MASK) ==
            SERIAL_DTR_HANDSHAKE) {

            // If we are already doing a
            // dtr hold then we don't have
            // to do anything else.

            if (!(Extension->RXHolding &
                  CYY_RX_DTR)) {

                if ((Extension->BufferSize -
                     Extension->HandFlow.XoffLimit)
                    <= (Extension->CharsInInterruptBuffer+1)) {

                    Extension->RXHolding |= CYY_RX_DTR;

                    CyyClrDTR(Extension);
                }
            }
        }

        if ((Extension->HandFlow.FlowReplace
             & SERIAL_RTS_MASK) ==
            SERIAL_RTS_HANDSHAKE) {

            // If we are already doing a
            // rts hold then we don't have
            // to do anything else.

            if (!(Extension->RXHolding & CYY_RX_RTS)) {

                if ((Extension->BufferSize -
                     Extension->HandFlow.XoffLimit)
                    <= (Extension->CharsInInterruptBuffer+1)) {

                    Extension->RXHolding |= CYY_RX_RTS;

                    CyyClrRTS(Extension);
                }
            }
        }

        if (Extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) {
            // If we are already doing a
            // xoff hold then we don't have
            // to do anything else.

            if (!(Extension->RXHolding & CYY_RX_XOFF)) {

                if ((Extension->BufferSize -
                     Extension->HandFlow.XoffLimit)
                    <= (Extension->CharsInInterruptBuffer+1)) {

                    Extension->RXHolding |= CYY_RX_XOFF;

                    // If necessary cause an
                    // off to be sent.

                    CyyProdXonXoff(Extension,FALSE);
                }
            }
        }

        if (Extension->CharsInInterruptBuffer < Extension->BufferSize) {

            *Extension->CurrentCharSlot = CharToPut;
            Extension->CharsInInterruptBuffer++;

            // If we've become 80% full on this character
            // and this is an interesting event, note it.

            if (Extension->CharsInInterruptBuffer == Extension->BufferSizePt8) {

                if (Extension->IsrWaitMask & SERIAL_EV_RX80FULL) {

                    Extension->HistoryMask |= SERIAL_EV_RX80FULL;

                    if (Extension->IrpMaskLocation) {

                        *Extension->IrpMaskLocation = Extension->HistoryMask;
                        Extension->IrpMaskLocation = NULL;
                        Extension->HistoryMask = 0;

                        Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
                        CyyInsertQueueDpc(&Extension->CommWaitDpc,NULL,NULL,Extension);
                    }
                }
            }

            // Point to the next available space
            // for a received character.  Make sure
            // that we wrap around to the beginning
            // of the buffer if this last character
            // received was placed at the last slot
            // in the buffer.

            if (Extension->CurrentCharSlot == Extension->LastCharSlot) {
                Extension->CurrentCharSlot = Extension->InterruptReadBuffer;
            } else {
                Extension->CurrentCharSlot++;
            }
        } else {
            // We have a new character but no room for it.

            Extension->PerfStats.BufferOverrunErrorCount++;
            Extension->WmiPerfData.BufferOverrunErrorCount++;
            Extension->ErrorWord |= SERIAL_ERROR_QUEUEOVERRUN;

            if (Extension->HandFlow.FlowReplace & SERIAL_ERROR_CHAR) {

                // Place the error character into the last
                // valid place for a character.  Be careful!,
                // that place might not be the previous location!

                if (Extension->CurrentCharSlot == Extension->InterruptReadBuffer) {
                    *(Extension->InterruptReadBuffer+
                      (Extension->BufferSize-1)) =
                      Extension->SpecialChars.ErrorChar;
                } else {
                    *(Extension->CurrentCharSlot-1) =
                     Extension->SpecialChars.ErrorChar;
                }
            }
            // If the application has requested it, abort all reads
            // and writes on an error.

            if (Extension->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) {
                CyyInsertQueueDpc(&Extension->CommErrorDpc,NULL,NULL,Extension);
            }
        }
    }
}

BOOLEAN
CyyProcessLSR(
    IN PCYY_DEVICE_EXTENSION Extension,
	IN UCHAR Rdsr,
	IN UCHAR RxChar
	)

/*++

Routine Description:

    This routine, which only runs at device level, reads the
    ISR and totally processes everything that might have
    changed.

Arguments:

    Extension - The serial device extension.

Return Value:

    TRUE if RxChar still needs to be processed.

--*/

{

	BOOLEAN StillProcessRxChar=TRUE;
	UCHAR LineStatus=0;

   CYY_LOCKED_PAGED_CODE();

	if (Rdsr & CYY_LSR_OE)
		LineStatus |= SERIAL_LSR_OE;
	if (Rdsr & CYY_LSR_FE)
		LineStatus |= SERIAL_LSR_FE;
	if (Rdsr & CYY_LSR_PE)
		LineStatus |= SERIAL_LSR_PE;
	if (Rdsr & CYY_LSR_BI)
		LineStatus |= SERIAL_LSR_BI;
			
			
    if (Extension->EscapeChar) {

        CyyPutChar(
            Extension,
            Extension->EscapeChar
            );

        CyyPutChar(
            Extension,
            (UCHAR)((LineStatus & SERIAL_LSR_OE)?
             (SERIAL_LSRMST_LSR_NODATA):(SERIAL_LSRMST_LSR_DATA))
            );

        CyyPutChar(
            Extension,
            LineStatus
            );

        if (!(LineStatus & SERIAL_LSR_OE)) {
             Extension->PerfStats.ReceivedCount++;
             Extension->WmiPerfData.ReceivedCount++;
             CyyPutChar(
                Extension,
                RxChar
                );					
			StillProcessRxChar = FALSE;
        }

    }
		

    if (LineStatus & SERIAL_LSR_OE) {

        Extension->PerfStats.SerialOverrunErrorCount++;
        Extension->WmiPerfData.SerialOverrunErrorCount++;
        Extension->ErrorWord |= SERIAL_ERROR_OVERRUN;

        if (Extension->HandFlow.FlowReplace &
            SERIAL_ERROR_CHAR) {

            CyyPutChar(
                Extension,
                Extension->SpecialChars.ErrorChar
                );
        }
		StillProcessRxChar = FALSE;
    }

    if (LineStatus & SERIAL_LSR_BI) {

        Extension->ErrorWord |= SERIAL_ERROR_BREAK;

        if (Extension->HandFlow.FlowReplace &
            SERIAL_BREAK_CHAR) {

            CyyPutChar(
                Extension,
                Extension->SpecialChars.BreakChar
                );

        }

    } else {

        //
        // Framing errors only count if they
        // occur exclusive of a break being
        // received.
        //

        if (LineStatus & SERIAL_LSR_PE) {
             Extension->PerfStats.ParityErrorCount++;
             Extension->WmiPerfData.ParityErrorCount++;
             Extension->ErrorWord |= SERIAL_ERROR_PARITY;
             if (Extension->HandFlow.FlowReplace &
                 SERIAL_ERROR_CHAR) {

                CyyPutChar(
                    Extension,
                    Extension->SpecialChars.ErrorChar
                    );
				StillProcessRxChar = FALSE;					                
            }

        }

        if (LineStatus & SERIAL_LSR_FE) {

            Extension->PerfStats.FrameErrorCount++;
            Extension->WmiPerfData.FrameErrorCount++;
            Extension->ErrorWord |= SERIAL_ERROR_FRAMING;

            if (Extension->HandFlow.FlowReplace &
                SERIAL_ERROR_CHAR) {

                CyyPutChar(
                    Extension,
                    Extension->SpecialChars.ErrorChar
                    );
				StillProcessRxChar = FALSE;
            }

        }

    }


    //
    // If the application has requested it,
    // abort all the reads and writes
    // on an error.
    //

    if (Extension->HandFlow.ControlHandShake &
        SERIAL_ERROR_ABORT) {

        CyyInsertQueueDpc(
            &Extension->CommErrorDpc,
            NULL,
            NULL,
            Extension
            );

    }

    //
    // Check to see if we have a wait
    // pending on the comm error events.  If we
    // do then we schedule a dpc to satisfy
    // that wait.
    //

    if (Extension->IsrWaitMask) {

        if ((Extension->IsrWaitMask & SERIAL_EV_ERR) &&
            (LineStatus & (SERIAL_LSR_OE |
                           SERIAL_LSR_PE |
                           SERIAL_LSR_FE))) {
             Extension->HistoryMask |= SERIAL_EV_ERR;

        }

        if ((Extension->IsrWaitMask & SERIAL_EV_BREAK) &&
            (LineStatus & SERIAL_LSR_BI)) {

             Extension->HistoryMask |= SERIAL_EV_BREAK;

        }

        if (Extension->IrpMaskLocation &&
            Extension->HistoryMask) {

            *Extension->IrpMaskLocation =
             Extension->HistoryMask;
            Extension->IrpMaskLocation = NULL;
            Extension->HistoryMask = 0;

            Extension->CurrentWaitIrp->IoStatus.Information =
                sizeof(ULONG);
            CyyInsertQueueDpc(
                &Extension->CommWaitDpc,
                NULL,
                NULL,
                Extension
                );

        }

    }
	
	return StillProcessRxChar;

}

BOOLEAN
CyyTxStart(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyyTxStart()
    
    Description: Enable Tx interrupt.
    
    Parameters:
    
    Exetnsion: Pointer to device extension.
    
    Return Value: None
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = Context;
    PUCHAR chip = Extension->Cd1400;
    ULONG bus = Extension->IsPci;
    UCHAR srer;

    if (Extension->PowerState == PowerDeviceD0) {
        CD1400_WRITE(chip,bus,CAR,Extension->CdChannel & 0x03);
        srer = CD1400_READ (chip,bus,SRER);
        CD1400_WRITE(chip,bus,SRER,srer | SRER_TXRDY);
    }
    return(FALSE);    
}


BOOLEAN
CyySendXon(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyySendXon()
    
    Description: Send a Xon.
    
    Parameters:
    
    Exetension: Pointer to device extension.
    
    Return Value: Always FALSE.
--------------------------------------------------------------------------*/
{
   PCYY_DEVICE_EXTENSION Extension = Context;
   PUCHAR chip = Extension->Cd1400;
   ULONG bus = Extension->IsPci;    
    
   if(!(Extension->TXHolding & ~CYY_TX_XOFF)) {
   	if ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
                                 SERIAL_TRANSMIT_TOGGLE) {

	      CyySetRTS(Extension);

         Extension->PerfStats.TransmittedCount++;
         Extension->WmiPerfData.TransmittedCount++;
	      CD1400_WRITE(chip,bus,CAR,Extension->CdChannel & 0x03);
	      CyyCDCmd(Extension,CCR_SENDSC_SCHR1);
	    
	      CyyInsertQueueDpc(&Extension->StartTimerLowerRTSDpc,NULL,
			       NULL,Extension)?Extension->CountOfTryingToLowerRTS++:0;
   	} else {
          Extension->PerfStats.TransmittedCount++;
          Extension->WmiPerfData.TransmittedCount++;
	       CD1400_WRITE(chip,bus,CAR,Extension->CdChannel & 0x03);
   	    CyyCDCmd(Extension,CCR_SENDSC_SCHR1);
	   }

   	// If we send an xon, by definition we can't be holding by Xoff.

   	Extension->TXHolding &= ~CYY_TX_XOFF;
	   Extension->RXHolding &= ~CYY_RX_XOFF;
   }
   return(FALSE);    
}



BOOLEAN
CyySendXoff(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyySendXoff()
    
    Description: Send a Xoff.
    
    Parameters:
    
    Extension: Pointer to device extension.
    
    Return Value: Always FALSE.
--------------------------------------------------------------------------*/
{
   PCYY_DEVICE_EXTENSION Extension = Context;
   PUCHAR chip = Extension->Cd1400;
   ULONG bus = Extension->IsPci;    
    
   if(!Extension->TXHolding) {
      if ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
                                 SERIAL_TRANSMIT_TOGGLE) {

         CyySetRTS(Extension);
	    
         Extension->PerfStats.TransmittedCount++;
         Extension->WmiPerfData.TransmittedCount++;
         CD1400_WRITE(chip,bus,CAR,Extension->CdChannel & 0x03);
         CyyCDCmd(Extension,CCR_SENDSC_SCHR2);
	    
         CyyInsertQueueDpc(&Extension->StartTimerLowerRTSDpc,NULL,
                          NULL,Extension)?Extension->CountOfTryingToLowerRTS++:0;
      } else {
         Extension->PerfStats.TransmittedCount++;
         Extension->WmiPerfData.TransmittedCount++;
         CD1400_WRITE(chip,bus,CAR,Extension->CdChannel & 0x03);
         CyyCDCmd(Extension,CCR_SENDSC_SCHR2);
      }

      // no xoff is sent if the transmission is already held up.
      // If xoff continue mode is set, we don't actually stop sending

      if (!(Extension->HandFlow.FlowReplace & SERIAL_XOFF_CONTINUE)) {
         Extension->TXHolding |= CYY_TX_XOFF;

         if ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
                                     SERIAL_TRANSMIT_TOGGLE) {

            CyyInsertQueueDpc(&Extension->StartTimerLowerRTSDpc,NULL,
                  NULL,Extension)?Extension->CountOfTryingToLowerRTS++:0;
         }
      }
   }
   return(FALSE);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyylog.h ===
/*--------------------------------------------------------------------------
*
*   Copyright (C) Cyclades Corporation, 1996-2000.
*   All rights reserved.
*
*   Cyclom-Y Port Driver
*	
*   This file:      cyylog.mc
*
*   Description:    Messages that goes to the eventlog.
*
*   Notes:          This code supports Windows 2000 and i386 processor.
*
*   Complies with Cyclades SW Coding Standard rev 1.3.
*
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#ifndef _CYYLOG_
#define _CYYLOG_

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: CYY_CCR_NOT_ZERO
//
// MessageText:
//
//  CCR not zero.
//
#define CYY_CCR_NOT_ZERO                 ((NTSTATUS)0x80041000L)

//
// MessageId: CYY_UNABLE_TO_GET_BUS_TYPE
//
// MessageText:
//
//  Unable to know if the Cyclom-Y card is ISA or PCI.
//
#define CYY_UNABLE_TO_GET_BUS_TYPE       ((NTSTATUS)0xC0041001L)

//
// MessageId: CYY_UNABLE_TO_GET_BUS_NUMBER
//
// MessageText:
//
//  Unable to get Cyclom-Y card PCI slot information.
//
#define CYY_UNABLE_TO_GET_BUS_NUMBER     ((NTSTATUS)0xC0041002L)

//
// MessageId: CYY_UNABLE_TO_GET_HW_ID
//
// MessageText:
//
//  Unable to get Hardware ID information.
//
#define CYY_UNABLE_TO_GET_HW_ID          ((NTSTATUS)0xC0041003L)

//
// MessageId: CYY_NO_SYMLINK_CREATED
//
// MessageText:
//
//  Unable to create the symbolic link for %2.
//
#define CYY_NO_SYMLINK_CREATED           ((NTSTATUS)0x80041004L)

//
// MessageId: CYY_NO_DEVICE_MAP_CREATED
//
// MessageText:
//
//  Unable to create the device map entry for %2.
//
#define CYY_NO_DEVICE_MAP_CREATED        ((NTSTATUS)0x80041005L)

//
// MessageId: CYY_NO_DEVICE_MAP_DELETED
//
// MessageText:
//
//  Unable to delete the device map entry for %2.
//
#define CYY_NO_DEVICE_MAP_DELETED        ((NTSTATUS)0x80041006L)

//
// MessageId: CYY_UNREPORTED_IRQL_CONFLICT
//
// MessageText:
//
//  Another driver on the system, which did not report its resources, has already claimed the interrupt used by %2.
//
#define CYY_UNREPORTED_IRQL_CONFLICT     ((NTSTATUS)0xC0041007L)

//
// MessageId: CYY_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Not enough resources were available for the driver.
//
#define CYY_INSUFFICIENT_RESOURCES       ((NTSTATUS)0xC0041008L)

//
// MessageId: CYY_BOARD_NOT_MAPPED
//
// MessageText:
//
//  The Board Memory for %2 could not be translated to something the memory management system could understand.
//
#define CYY_BOARD_NOT_MAPPED             ((NTSTATUS)0xC004100AL)

//
// MessageId: CYY_RUNTIME_NOT_MAPPED
//
// MessageText:
//
//  The Runtime Registers for %2 could not be translated to something the memory management system could understand.
//
#define CYY_RUNTIME_NOT_MAPPED           ((NTSTATUS)0xC004100BL)

//
// MessageId: CYY_INVALID_RUNTIME_REGISTERS
//
// MessageText:
//
//  Invalid Runtime Registers base address for %2.
//
#define CYY_INVALID_RUNTIME_REGISTERS    ((NTSTATUS)0xC0041010L)

//
// MessageId: CYY_INVALID_BOARD_MEMORY
//
// MessageText:
//
//  Invalid Board Memory address for %2.
//
#define CYY_INVALID_BOARD_MEMORY         ((NTSTATUS)0xC0041011L)

//
// MessageId: CYY_INVALID_INTERRUPT
//
// MessageText:
//
//  Invalid Interrupt Vector for %2.
//
#define CYY_INVALID_INTERRUPT            ((NTSTATUS)0xC0041012L)

//
// MessageId: CYY_PORT_INDEX_TOO_HIGH
//
// MessageText:
//
//  Port Number for %2 is larger than the maximum number of ports in a cyclom-y card.
//
#define CYY_PORT_INDEX_TOO_HIGH          ((NTSTATUS)0xC0041015L)

//
// MessageId: CYY_UNKNOWN_BUS
//
// MessageText:
//
//  The bus type for %2 is not recognizable.
//
#define CYY_UNKNOWN_BUS                  ((NTSTATUS)0xC0041016L)

//
// MessageId: CYY_BUS_NOT_PRESENT
//
// MessageText:
//
//  The bus type for %2 is not available on this computer.
//
#define CYY_BUS_NOT_PRESENT              ((NTSTATUS)0xC0041017L)

//
// MessageId: CYY_RUNTIME_MEMORY_TOO_HIGH
//
// MessageText:
//
//  The Runtime Registers for %2 is way too high in physical memory.
//
#define CYY_RUNTIME_MEMORY_TOO_HIGH      ((NTSTATUS)0xC004101AL)

//
// MessageId: CYY_BOARD_MEMORY_TOO_HIGH
//
// MessageText:
//
//  The Board Memory for %2 is way too high in physical memory.
//
#define CYY_BOARD_MEMORY_TOO_HIGH        ((NTSTATUS)0xC004101BL)

//
// MessageId: CYY_BOTH_MEMORY_CONFLICT
//
// MessageText:
//
//  The Runtime Registers for %2 overlaps the Board Memory for the device.
//
#define CYY_BOTH_MEMORY_CONFLICT         ((NTSTATUS)0xC004101CL)

//
// MessageId: CYY_MULTI_INTERRUPT_CONFLICT
//
// MessageText:
//
//  Two ports, %2 and %3, on a single cyclom-y card can't have two different interrupts.
//
#define CYY_MULTI_INTERRUPT_CONFLICT     ((NTSTATUS)0xC0041021L)

//
// MessageId: CYY_MULTI_RUNTIME_CONFLICT
//
// MessageText:
//
//  Two ports, %2 and %3, on a single cyclom-y card can't have two different Runtime Registers memory range.
//
#define CYY_MULTI_RUNTIME_CONFLICT       ((NTSTATUS)0xC0041022L)

//
// MessageId: CYY_HARDWARE_FAILURE
//
// MessageText:
//
//  The cyyport driver detected a hardware failure on device %2 and will disable this device.
//
#define CYY_HARDWARE_FAILURE             ((NTSTATUS)0xC004102DL)

//
// MessageId: CYY_GFRCR_FAILURE
//
// MessageText:
//
//  CD1400 not present or failure to read GFRCR register for %2.
//
#define CYY_GFRCR_FAILURE                ((NTSTATUS)0xC0041030L)

//
// MessageId: CYY_CCR_FAILURE
//
// MessageText:
//
//  Failure to read CCR register in the CD1400 for %2.
//
#define CYY_CCR_FAILURE                  ((NTSTATUS)0xC0041031L)

//
// MessageId: CYY_BAD_CD1400_REVISION
//
// MessageText:
//
//  Invalid CD1400 revision number for %2.
//
#define CYY_BAD_CD1400_REVISION          ((NTSTATUS)0xC0041032L)

//
// MessageId: CYY_DEVICE_CREATION_FAILURE
//
// MessageText:
//
//  Failure to create new device object.
//
#define CYY_DEVICE_CREATION_FAILURE      ((NTSTATUS)0xC0041033L)

//
// MessageId: CYY_NO_PHYSICAL_DEVICE_OBJECT
//
// MessageText:
//
//  No physical device object.
//
#define CYY_NO_PHYSICAL_DEVICE_OBJECT    ((NTSTATUS)0xC0041034L)

//
// MessageId: CYY_BAD_HW_ID
//
// MessageText:
//
//  Invalid Hardware ID.
//
#define CYY_BAD_HW_ID                    ((NTSTATUS)0xC0041035L)

//
// MessageId: CYY_LOWER_DRIVERS_FAILED_START
//
// MessageText:
//
//  Lower drivers failed to start.
//
#define CYY_LOWER_DRIVERS_FAILED_START   ((NTSTATUS)0xC0041036L)


#endif /* _CYYLOG_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyyinit.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyyinit.c
*	
*   Description:    This module contains the code related to initialization 
*                   and unload operations in the Cyclom-Y Port driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*
*--------------------------------------------------------------------------
*/

#include "precomp.h"

//
// This is the actual definition of CyyDebugLevel.
// Note that it is only defined if this is a "debug"
// build.
//
#if DBG
extern ULONG CyyDebugLevel = CYYDBGALL;
#endif

//
// All our global variables except DebugLevel stashed in one
// little package
//
CYY_GLOBALS CyyGlobals;

static const PHYSICAL_ADDRESS CyyPhysicalZero = {0};

//
// We use this to query into the registry as to whether we
// should break at driver entry.
//

CYY_REGISTRY_DATA    driverDefaults;

//
// INIT - only needed during init and then can be disposed
// PAGESRP0 - always paged / never locked
// PAGESER - must be locked when a device is open, else paged
//
//
// INIT is used for DriverEntry() specific code
//
// PAGESRP0 is used for code that is not often called and has nothing
// to do with I/O performance.  An example, IRP_MJ_PNP/IRP_MN_START_DEVICE
// support functions
//
// PAGESER is used for code that needs to be locked after an open for both
// performance and IRQL reasons.
//
      
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)

#pragma alloc_text(PAGESRP0, CyyRemoveDevObj)
#pragma alloc_text(PAGESRP0, CyyUnload)


//
// PAGESER handled is keyed off of CyyReset, so CyyReset
// must remain in PAGESER for things to work properly
//

#pragma alloc_text(PAGESER, CyyReset)
#pragma alloc_text(PAGESER, CyyCommError)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*--------------------------------------------------------------------------

    The entry point that the system point calls to initialize
    any driver.

    This routine will gather the configuration information,
    report resource usage, attempt to initialize all serial
    devices, connect to interrupts for ports.  If the above
    goes reasonably well it will fill in the dispatch points,
    reset the serial devices and then return to the system.

Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    PathToRegistry - points to the entry for this driver
    in the current control set of the registry.

Return Value:

    Always STATUS_SUCCESS

--------------------------------------------------------------------------*/
{
   //
   // Lock the paged code in their frames
   //

   PVOID lockPtr = MmLockPagableCodeSection(CyyReset);

   PAGED_CODE();


   ASSERT(CyyGlobals.PAGESER_Handle == NULL);
#if DBG
   CyyGlobals.PAGESER_Count = 0;
   SerialLogInit();
#endif
   CyyGlobals.PAGESER_Handle = lockPtr;

   CyyGlobals.RegistryPath.MaximumLength = RegistryPath->MaximumLength;
   CyyGlobals.RegistryPath.Length = RegistryPath->Length;
   CyyGlobals.RegistryPath.Buffer
      = ExAllocatePool(PagedPool, CyyGlobals.RegistryPath.MaximumLength);

   if (CyyGlobals.RegistryPath.Buffer == NULL) {
      MmUnlockPagableImageSection(lockPtr);
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(CyyGlobals.RegistryPath.Buffer,
                 CyyGlobals.RegistryPath.MaximumLength);
   RtlMoveMemory(CyyGlobals.RegistryPath.Buffer,
                 RegistryPath->Buffer, RegistryPath->Length);
 
   KeInitializeSpinLock(&CyyGlobals.GlobalsSpinLock);

   //
   // Initialize all our globals
   //

   InitializeListHead(&CyyGlobals.AllDevObjs);
   
   //
   // Call to find out default values to use for all the devices that the
   // driver controls, including whether or not to break on entry.
   //

   CyyGetConfigDefaults(&driverDefaults, RegistryPath);

#if DBG
   //
   // Set global debug output level
   //
   CyyDebugLevel = driverDefaults.DebugLevel;
#endif

   //
   // Break on entry if requested via registry
   //

   if (driverDefaults.ShouldBreakOnEntry) {
      DbgBreakPoint();
   }


   //
   // Just dump out how big the extension is.
   //

   CyyDbgPrintEx(DPFLTR_INFO_LEVEL, "The number of bytes in the extension "
                 "is: %d\n", sizeof(CYY_DEVICE_EXTENSION));


   //
   // Initialize the Driver Object with driver's entry points
   //

   DriverObject->DriverUnload                          = CyyUnload;
   DriverObject->DriverExtension->AddDevice            = CyyAddDevice;

   DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]   = CyyFlush;
   DriverObject->MajorFunction[IRP_MJ_WRITE]           = CyyWrite;
   DriverObject->MajorFunction[IRP_MJ_READ]            = CyyRead;
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = CyyIoControl;
   DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]
      = CyyInternalIoControl;
   DriverObject->MajorFunction[IRP_MJ_CREATE]          = CyyCreateOpen;
   DriverObject->MajorFunction[IRP_MJ_CLOSE]           = CyyClose;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP]         = CyyCleanup;
   DriverObject->MajorFunction[IRP_MJ_PNP]             = CyyPnpDispatch;
   DriverObject->MajorFunction[IRP_MJ_POWER]           = CyyPowerDispatch;

   DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]
      = CyyQueryInformationFile;
   DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]
      = CyySetInformationFile;

   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]
      = CyySystemControlDispatch;


   //
   // Unlock pageable text
   //
   MmUnlockPagableImageSection(lockPtr);

   return STATUS_SUCCESS;
}




BOOLEAN
CyyCleanLists(IN PVOID Context)
/*++

Routine Description:

    Removes a device object from any of the serial linked lists it may
    appear on.

Arguments:

    Context - Actually a PCYY_DEVICE_EXTENSION (for the devobj being
              removed).

Return Value:

    Always TRUE

--*/
{
   PCYY_DEVICE_EXTENSION pDevExt = (PCYY_DEVICE_EXTENSION)Context;
   PCYY_DISPATCH pDispatch;
   ULONG i;

   //
   // Remove our entry from the dispatch context
   //

   pDispatch = (PCYY_DISPATCH)pDevExt->OurIsrContext;

   CyyDbgPrintEx(CYYPNPPOWER, "CLEAN: removing multiport isr "
                 "ext\n");

   pDispatch->Extensions[pDevExt->PortIndex] = NULL;

   for (i = 0; i < CYY_MAX_PORTS; i++) {
      if (((PCYY_DISPATCH)pDevExt->OurIsrContext)
           ->Extensions[i] != NULL) {
          break;
      }
   }

   if (i < CYY_MAX_PORTS) {
      // Others are chained on this interrupt, so we don't want to
      // disconnect it.
      pDevExt->Interrupt = NULL;
   }

   return TRUE;
}



VOID
CyyReleaseResources(IN PCYY_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    Releases resources (not pool) stored in the device extension.

Arguments:

    PDevExt - Pointer to the device extension to release resources from.

Return Value:

    VOID

--*/
{
   KIRQL oldIrql;

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyReleaseResources(%X)\n",
                 PDevExt);

   //
   // AllDevObjs should never be empty since we have a sentinal
   // Note: serial removes device from AllDevObjs list after calling 
   //       SerialCleanLists. We do it before to make sure no other port will 
   //       be added to share the polling routine or PDevExt->Interrut that is 
   //       on the way to be disconnected.
   //

   KeAcquireSpinLock(&CyyGlobals.GlobalsSpinLock, &oldIrql);

   ASSERT(!IsListEmpty(&PDevExt->AllDevObjs));

   RemoveEntryList(&PDevExt->AllDevObjs);

   KeReleaseSpinLock(&CyyGlobals.GlobalsSpinLock, oldIrql);

   InitializeListHead(&PDevExt->AllDevObjs);

   //
   // Remove us from any lists we may be on
   //

   KeSynchronizeExecution(PDevExt->Interrupt, CyyCleanLists, PDevExt);

   //
   // Stop servicing interrupts if we are the last device
   //

   if (PDevExt->Interrupt != NULL) {

      // Disable interrupts in the PLX
      if (PDevExt->IsPci) {

         UCHAR plx_ver;
         ULONG value;

         plx_ver = CYY_READ_PCI_TYPE(PDevExt->BoardMemory);
         plx_ver &= 0x0f;

			switch(plx_ver) {
			case CYY_PLX9050:
            value = PLX9050_READ_INTERRUPT_CONTROL(PDevExt->Runtime);
            value &= ~PLX9050_INT_ENABLE;
            PLX9050_WRITE_INTERRUPT_CONTROL(PDevExt->Runtime,value);
				break;
			case CYY_PLX9060:
			case CYY_PLX9080:
			default:
            value = PLX9060_READ_INTERRUPT_CONTROL(PDevExt->Runtime);
            value &= ~PLX9060_INT_ENABLE;
            PLX9060_WRITE_INTERRUPT_CONTROL(PDevExt->Runtime,value);
				break;				
			}
      
      }

      CyyDbgPrintEx(CYYPNPPOWER, "Release - disconnecting interrupt %X\n",
                    PDevExt->Interrupt);

      IoDisconnectInterrupt(PDevExt->Interrupt);
      PDevExt->Interrupt = NULL;

      // If we are the last device, free this memory

      CyyDbgPrintEx(CYYPNPPOWER, "Release - freeing multi context\n");
      if (PDevExt->OurIsrContext != NULL) {     // added in DDK build 2072, but 
          ExFreePool(PDevExt->OurIsrContext);   // we already had the free of OurIsrContext.
          PDevExt->OurIsrContext = NULL;        // 
      }   
   }

   
   //
   // Stop handling timers
   //

   CyyCancelTimer(&PDevExt->ReadRequestTotalTimer, PDevExt);
   CyyCancelTimer(&PDevExt->ReadRequestIntervalTimer, PDevExt);
   CyyCancelTimer(&PDevExt->WriteRequestTotalTimer, PDevExt);
   CyyCancelTimer(&PDevExt->ImmediateTotalTimer, PDevExt);
   CyyCancelTimer(&PDevExt->XoffCountTimer, PDevExt);
   CyyCancelTimer(&PDevExt->LowerRTSTimer, PDevExt);

   //
   // Stop servicing DPC's
   //

   CyyRemoveQueueDpc(&PDevExt->CompleteWriteDpc, PDevExt);
   CyyRemoveQueueDpc(&PDevExt->CompleteReadDpc, PDevExt);
   CyyRemoveQueueDpc(&PDevExt->TotalReadTimeoutDpc, PDevExt);
   CyyRemoveQueueDpc(&PDevExt->IntervalReadTimeoutDpc, PDevExt);
   CyyRemoveQueueDpc(&PDevExt->TotalWriteTimeoutDpc, PDevExt);
   CyyRemoveQueueDpc(&PDevExt->CommErrorDpc, PDevExt);
   CyyRemoveQueueDpc(&PDevExt->CompleteImmediateDpc, PDevExt);
   CyyRemoveQueueDpc(&PDevExt->TotalImmediateTimeoutDpc, PDevExt);
   CyyRemoveQueueDpc(&PDevExt->CommWaitDpc, PDevExt);
   CyyRemoveQueueDpc(&PDevExt->XoffCountTimeoutDpc, PDevExt);
   CyyRemoveQueueDpc(&PDevExt->XoffCountCompleteDpc, PDevExt);
   CyyRemoveQueueDpc(&PDevExt->StartTimerLowerRTSDpc, PDevExt);
   CyyRemoveQueueDpc(&PDevExt->PerhapsLowerRTSDpc, PDevExt);



   //
   // If necessary, unmap the device registers.
   //

   if (PDevExt->BoardMemory) {
      MmUnmapIoSpace(PDevExt->BoardMemory, PDevExt->BoardMemoryLength);
      PDevExt->BoardMemory = NULL;
   }

   if (PDevExt->Runtime) {
      MmUnmapIoSpace(PDevExt->Runtime,
                     PDevExt->RuntimeLength);
      PDevExt->Runtime = NULL;
   }

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyReleaseResources\n");
}


VOID
CyyDisableInterfacesResources(IN PDEVICE_OBJECT PDevObj,
                              BOOLEAN DisableCD1400)
{
   PCYY_DEVICE_EXTENSION pDevExt
      = (PCYY_DEVICE_EXTENSION)PDevObj->DeviceExtension;

   PAGED_CODE();

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyDisableInterfaces(%X, %s)\n",
                 PDevObj, DisableCD1400 ? "TRUE" : "FALSE");

   //
   // Only do these many things if the device has started and still
   // has resources allocated
   //

   if (pDevExt->Flags & CYY_FLAGS_STARTED) {

       if (!(pDevExt->Flags & CYY_FLAGS_STOPPED)) {

         if (DisableCD1400) {
            //
            // Mask off interrupts
            //
            CD1400_DISABLE_ALL_INTERRUPTS(pDevExt->Cd1400,pDevExt->IsPci,
                                          pDevExt->CdChannel);
         }

         CyyReleaseResources(pDevExt);

      }

      //
      // Remove us from WMI consideration
      //

      IoWMIRegistrationControl(PDevObj, WMIREG_ACTION_DEREGISTER);
   }

   //
   // Undo external names
   //

   CyyUndoExternalNaming(pDevExt);

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyDisableInterfaces\n");
}


NTSTATUS
CyyRemoveDevObj(IN PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

    Removes a serial device object from the system.

Arguments:

    PDevObj - A pointer to the Device Object we want removed.

Return Value:

    Always TRUE

--*/
{
   PCYY_DEVICE_EXTENSION pDevExt
      = (PCYY_DEVICE_EXTENSION)PDevObj->DeviceExtension;

   PAGED_CODE();

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyRemoveDevObj(%X)\n", PDevObj);

// Removed by Fanny. These code is called directly from IRP_MN_REMOVE_DEVICE.
//   if (!(pDevExt->DevicePNPAccept & CYY_PNPACCEPT_SURPRISE_REMOVING)) {
//      //
//      // Disable all external interfaces and release resources
//      //
//
//      CyyDisableInterfacesResources(PDevObj, TRUE);
//   }

   IoDetachDevice(pDevExt->LowerDeviceObject);

   //
   // Free memory allocated in the extension
   //

   if (pDevExt->NtNameForPort.Buffer != NULL) {
      ExFreePool(pDevExt->NtNameForPort.Buffer);
   }

   if (pDevExt->DeviceName.Buffer != NULL) {
      ExFreePool(pDevExt->DeviceName.Buffer);
   }

   if (pDevExt->SymbolicLinkName.Buffer != NULL) {
      ExFreePool(pDevExt->SymbolicLinkName.Buffer);
   }

   if (pDevExt->DosName.Buffer != NULL) {
      ExFreePool(pDevExt->DosName.Buffer);
   }

   if (pDevExt->ObjectDirectory.Buffer) {
      ExFreePool(pDevExt->ObjectDirectory.Buffer);
   }

   //
   // Delete the devobj
   //

   IoDeleteDevice(PDevObj);

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyRemoveDevObj %X\n",
                 STATUS_SUCCESS);

   return STATUS_SUCCESS;
}


VOID
CyyKillPendingIrps(PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

   This routine kills any irps pending for the passed device object.

Arguments:

    PDevObj - Pointer to the device object whose irps must die.

Return Value:

    VOID

--*/
{
   PCYY_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   KIRQL oldIrql;

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyKillPendingIrps(%X)\n",
                 PDevObj);

   //
   // First kill all the reads and writes.
   //

    CyyKillAllReadsOrWrites(PDevObj, &pDevExt->WriteQueue,
                               &pDevExt->CurrentWriteIrp);

    CyyKillAllReadsOrWrites(PDevObj, &pDevExt->ReadQueue,
                               &pDevExt->CurrentReadIrp);

    //
    // Next get rid of purges.
    //

    CyyKillAllReadsOrWrites(PDevObj, &pDevExt->PurgeQueue,
                               &pDevExt->CurrentPurgeIrp);

    //
    // Get rid of any mask operations.
    //

    CyyKillAllReadsOrWrites(PDevObj, &pDevExt->MaskQueue,
                               &pDevExt->CurrentMaskIrp);

    //
    // Now get rid a pending wait mask irp.
    //

    IoAcquireCancelSpinLock(&oldIrql);

    if (pDevExt->CurrentWaitIrp) {

        PDRIVER_CANCEL cancelRoutine;

        cancelRoutine = pDevExt->CurrentWaitIrp->CancelRoutine;
        pDevExt->CurrentWaitIrp->Cancel = TRUE;

        if (cancelRoutine) {

            pDevExt->CurrentWaitIrp->CancelIrql = oldIrql;
            pDevExt->CurrentWaitIrp->CancelRoutine = NULL;

            cancelRoutine(PDevObj, pDevExt->CurrentWaitIrp);

        } else {
            IoReleaseCancelSpinLock(oldIrql);
        }

    } else {

        IoReleaseCancelSpinLock(oldIrql);

    }

    //
    // Cancel any pending wait-wake irps
    //

    if (pDevExt->PendingWakeIrp != NULL) {
       IoCancelIrp(pDevExt->PendingWakeIrp);
       pDevExt->PendingWakeIrp = NULL;
    }

    //
    // Finally, dump any stalled IRPS
    //

    CyyKillAllStalled(PDevObj);


    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyKillPendingIrps\n");
}


NTSTATUS
CyyInitMultiPort(IN PCYY_DEVICE_EXTENSION PDevExt,
                 IN PCONFIG_DATA PConfigData, IN PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

    This routine initializes a multiport device by adding a port to an existing
    one.

Arguments:

    PDevExt - pointer to the device extension of the root of the multiport
              device.

    PConfigData - pointer to the config data for the new port

    PDevObj - pointer to the devobj for the new port

Return Value:

    STATUS_SUCCESS on success, appropriate error on failure.

--*/
{
   PCYY_DEVICE_EXTENSION pNewExt
      = (PCYY_DEVICE_EXTENSION)PDevObj->DeviceExtension;
   NTSTATUS status;

   PAGED_CODE();


   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyInitMultiPort(%X, %X, %X)\n",
                 PDevExt, PConfigData, PDevObj);

   //
   // Allow him to share OurIsrContext and interrupt object
   //

   pNewExt->OurIsrContext = PDevExt->OurIsrContext;
   pNewExt->Interrupt = PDevExt->Interrupt;

   //
   // First, see if we can initialize the one we have found
   //

   status = CyyInitController(PDevObj, PConfigData);

   if (!NT_SUCCESS(status)) {
      CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyInitMultiPort (1) %X\n",
                    status);
      return status;
   }

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyInitMultiPort (3) %X\n",
                 STATUS_SUCCESS);

   return STATUS_SUCCESS;
}



NTSTATUS
CyyInitController(IN PDEVICE_OBJECT PDevObj, IN PCONFIG_DATA PConfigData)
/*++

Routine Description:

    Really too many things to mention here.  In general initializes
    kernel synchronization structures, allocates the typeahead buffer,
    sets up defaults, etc.

Arguments:

    PDevObj       - Device object for the device to be started

    PConfigData   - Pointer to a record for a single port.

Return Value:

    STATUS_SUCCCESS if everything went ok.  A !NT_SUCCESS status
    otherwise.

--*/

{

   PCYY_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

   //
   // Holds the NT Status that is returned from each call to the
   // kernel and executive.
   //

   NTSTATUS status = STATUS_SUCCESS;

   BOOLEAN allocedDispatch = FALSE;
   PCYY_DISPATCH pDispatch = NULL;

   PAGED_CODE();


   CyyDbgPrintEx(CYYDIAG1, "Initializing for configuration record of %wZ\n",
                 &pDevExt->DeviceName);
   
   if (pDevExt->OurIsrContext == NULL) {

      if ((pDevExt->OurIsrContext
            = ExAllocatePool(NonPagedPool,sizeof(CYY_DISPATCH))) == NULL) {         
         status = STATUS_INSUFFICIENT_RESOURCES;
         goto ExtensionCleanup;
      }
      RtlZeroMemory(pDevExt->OurIsrContext,sizeof(CYY_DISPATCH));
      
      allocedDispatch = TRUE;
   }
   

   //
   // Initialize the timers used to timeout operations.
   //

   KeInitializeTimer(&pDevExt->ReadRequestTotalTimer);
   KeInitializeTimer(&pDevExt->ReadRequestIntervalTimer);
   KeInitializeTimer(&pDevExt->WriteRequestTotalTimer);
   KeInitializeTimer(&pDevExt->ImmediateTotalTimer);
   KeInitializeTimer(&pDevExt->XoffCountTimer);
   KeInitializeTimer(&pDevExt->LowerRTSTimer);


   //
   // Intialialize the dpcs that will be used to complete
   // or timeout various IO operations.
   //

   KeInitializeDpc(&pDevExt->CompleteWriteDpc, CyyCompleteWrite, pDevExt);
   KeInitializeDpc(&pDevExt->CompleteReadDpc, CyyCompleteRead, pDevExt);
   KeInitializeDpc(&pDevExt->TotalReadTimeoutDpc, CyyReadTimeout, pDevExt);
   KeInitializeDpc(&pDevExt->IntervalReadTimeoutDpc, CyyIntervalReadTimeout,
                   pDevExt);
   KeInitializeDpc(&pDevExt->TotalWriteTimeoutDpc, CyyWriteTimeout, pDevExt);
   KeInitializeDpc(&pDevExt->CommErrorDpc, CyyCommError, pDevExt);
   KeInitializeDpc(&pDevExt->CompleteImmediateDpc, CyyCompleteImmediate,
                   pDevExt);
   KeInitializeDpc(&pDevExt->TotalImmediateTimeoutDpc, CyyTimeoutImmediate,
                   pDevExt);
   KeInitializeDpc(&pDevExt->CommWaitDpc, CyyCompleteWait, pDevExt);
   KeInitializeDpc(&pDevExt->XoffCountTimeoutDpc, CyyTimeoutXoff, pDevExt);
   KeInitializeDpc(&pDevExt->XoffCountCompleteDpc, CyyCompleteXoff, pDevExt);
   KeInitializeDpc(&pDevExt->StartTimerLowerRTSDpc, CyyStartTimerLowerRTS,
                   pDevExt);
   KeInitializeDpc(&pDevExt->PerhapsLowerRTSDpc, CyyInvokePerhapsLowerRTS,
                   pDevExt);
   KeInitializeDpc(&pDevExt->IsrUnlockPagesDpc, CyyUnlockPages, pDevExt);

#if 0 // DBG
   //
   // Init debug stuff
   //

   pDevExt->DpcQueued[0].Dpc = &pDevExt->CompleteWriteDpc;
   pDevExt->DpcQueued[1].Dpc = &pDevExt->CompleteReadDpc;
   pDevExt->DpcQueued[2].Dpc = &pDevExt->TotalReadTimeoutDpc;
   pDevExt->DpcQueued[3].Dpc = &pDevExt->IntervalReadTimeoutDpc;
   pDevExt->DpcQueued[4].Dpc = &pDevExt->TotalWriteTimeoutDpc;
   pDevExt->DpcQueued[5].Dpc = &pDevExt->CommErrorDpc;
   pDevExt->DpcQueued[6].Dpc = &pDevExt->CompleteImmediateDpc;
   pDevExt->DpcQueued[7].Dpc = &pDevExt->TotalImmediateTimeoutDpc;
   pDevExt->DpcQueued[8].Dpc = &pDevExt->CommWaitDpc;
   pDevExt->DpcQueued[9].Dpc = &pDevExt->XoffCountTimeoutDpc;
   pDevExt->DpcQueued[10].Dpc = &pDevExt->XoffCountCompleteDpc;
   pDevExt->DpcQueued[11].Dpc = &pDevExt->StartTimerLowerRTSDpc;
   pDevExt->DpcQueued[12].Dpc = &pDevExt->PerhapsLowerRTSDpc;
   pDevExt->DpcQueued[13].Dpc = &pDevExt->IsrUnlockPagesDpc;

#endif


   //
   // Map the memory for the control registers for the serial device
   // into virtual memory.
   //
   if (pDevExt->IsPci) {
      pDevExt->Runtime = MmMapIoSpace(PConfigData->TranslatedRuntime,
                                      PConfigData->RuntimeLength,
                                      FALSE);
      //******************************
      // Error injection
      //if (pDevExt->Runtime) {
      //   MmUnmapIoSpace(pDevExt->Runtime, PConfigData->RuntimeLength);
      //   pDevExt->Runtime = NULL;
      //}
      //******************************
      
      
      if (!pDevExt->Runtime) {

         CyyLogError(
                       PDevObj->DriverObject,
                       pDevExt->DeviceObject,
                       PConfigData->PhysicalBoardMemory,
                       CyyPhysicalZero,
                       0,
                       0,
                       0,
                       PConfigData->PortIndex+1,
                       STATUS_SUCCESS,
                       CYY_RUNTIME_NOT_MAPPED,
                       pDevExt->DeviceName.Length+sizeof(WCHAR),
                       pDevExt->DeviceName.Buffer,
                       0,
                       NULL
                       );

         CyyDbgPrintEx(DPFLTR_WARNING_LEVEL, "Could not map Runtime memory for device "
                       "registers for %wZ\n", &pDevExt->DeviceName);

         status = STATUS_NONE_MAPPED;
         goto ExtensionCleanup;

      }
   
   }

   pDevExt->BoardMemory = MmMapIoSpace(PConfigData->TranslatedBoardMemory,
                                       PConfigData->BoardMemoryLength,
                                       FALSE);

      //******************************
      // Error injection
      //if (pDevExt->BoardMemory) {
      //   MmUnmapIoSpace(pDevExt->BoardMemory, PConfigData->BoardMemoryLength);
      //   pDevExt->BoardMemory = NULL;
      //}
      //******************************

   if (!pDevExt->BoardMemory) {

      CyyLogError(
                    PDevObj->DriverObject,
                    pDevExt->DeviceObject,
                    PConfigData->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    PConfigData->PortIndex+1,
                    STATUS_SUCCESS,
                    CYY_BOARD_NOT_MAPPED,
                    pDevExt->DeviceName.Length+sizeof(WCHAR),
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL
                    );

      CyyDbgPrintEx(DPFLTR_WARNING_LEVEL, "Could not map Board memory for device "
                    "registers for %wZ\n", &pDevExt->DeviceName);

      status = STATUS_NONE_MAPPED;
      goto ExtensionCleanup;

   }
   
   pDevExt->RuntimeAddressSpace     = PConfigData->RuntimeAddressSpace;
   pDevExt->OriginalRuntimeMemory   = PConfigData->PhysicalRuntime;
   pDevExt->RuntimeLength           = PConfigData->RuntimeLength;

   pDevExt->BoardMemoryAddressSpace = PConfigData->BoardMemoryAddressSpace;
   pDevExt->OriginalBoardMemory     = PConfigData->PhysicalBoardMemory;
   pDevExt->BoardMemoryLength       = PConfigData->BoardMemoryLength;

   //
   // Shareable interrupt?
   //

   pDevExt->InterruptShareable = TRUE;


   //
   // Save off the interface type and the bus number.
   //

   pDevExt->InterfaceType = PConfigData->InterfaceType;
   pDevExt->BusNumber     = PConfigData->BusNumber;
   pDevExt->PortIndex     = PConfigData->PortIndex;

   //
   // Get the translated interrupt vector, level, and affinity
   //

   pDevExt->OriginalIrql      = PConfigData->OriginalIrql;
   pDevExt->OriginalVector    = PConfigData->OriginalVector;


   //
   // PnP uses the passed translated values rather than calling
   // HalGetInterruptVector()
   //

   pDevExt->Vector = PConfigData->TrVector;
   pDevExt->Irql = (UCHAR)PConfigData->TrIrql;

   //
   // Set up the Isr.
   //

   pDevExt->OurIsr = CyyIsr;


   //
   // Before we test whether the port exists (which will enable the FIFO)
   // convert the rx trigger value to what should be used in the register.
   //
   // If a bogus value was given - crank them down to 1.
   //

   switch (PConfigData->RxFIFO) {

   case 1:

      pDevExt->RxFifoTrigger = SERIAL_1_BYTE_HIGH_WATER;
      break;

   case 4:

      pDevExt->RxFifoTrigger = SERIAL_4_BYTE_HIGH_WATER;
      break;

   case 8:

      pDevExt->RxFifoTrigger = SERIAL_8_BYTE_HIGH_WATER;
      break;

   case 14:

      pDevExt->RxFifoTrigger = SERIAL_14_BYTE_HIGH_WATER;
      break;

   default:

      pDevExt->RxFifoTrigger = SERIAL_1_BYTE_HIGH_WATER;
      break;

   }


   if ((PConfigData->TxFIFO > MAX_CHAR_FIFO) ||
       (PConfigData->TxFIFO < 1)) {

      pDevExt->TxFifoAmount = MAX_CHAR_FIFO;

   } else {

      // Fanny: For now, do not use value from Registry.
      //pDevExt->TxFifoAmount = PConfigData->TxFIFO;
      pDevExt->TxFifoAmount = MAX_CHAR_FIFO;      

   }


   // Get CD1400 address of current port
   
   pDevExt->OriginalCd1400 = GetMyPhysicalCD1400Address(pDevExt->OriginalBoardMemory,
                                        pDevExt->PortIndex, pDevExt->IsPci);

   pDevExt->Cd1400 = GetMyMappedCD1400Address(pDevExt->BoardMemory, 
                                        pDevExt->PortIndex, pDevExt->IsPci);

   pDevExt->CdChannel = (UCHAR)(pDevExt->PortIndex % 4);


   //
   // Set up the default device control fields.
   // Note that if the values are changed after
   // the file is open, they do NOT revert back
   // to the old value at file close.
   //

   pDevExt->SpecialChars.XonChar      = CYY_DEF_XON;
   pDevExt->SpecialChars.XoffChar     = CYY_DEF_XOFF;
   pDevExt->HandFlow.ControlHandShake = SERIAL_DTR_CONTROL;
   pDevExt->HandFlow.FlowReplace      = SERIAL_RTS_CONTROL;


   //
   // Default Line control protocol. 7E1
   //
   // Seven data bits.
   // Even parity.
   // 1 Stop bits.
   //

   pDevExt->cor1 = COR1_7_DATA | COR1_EVEN_PARITY |
                   COR1_1_STOP;

   pDevExt->ValidDataMask = 0x7f;
   pDevExt->CurrentBaud   = 1200;


   //
   // We set up the default xon/xoff limits.
   //
   // This may be a bogus value.  It looks like the BufferSize
   // is not set up until the device is actually opened.
   //

   pDevExt->HandFlow.XoffLimit    = pDevExt->BufferSize >> 3;
   pDevExt->HandFlow.XonLimit     = pDevExt->BufferSize >> 1;

   pDevExt->BufferSizePt8 = ((3*(pDevExt->BufferSize>>2))+
                                  (pDevExt->BufferSize>>4));

   CyyDbgPrintEx(CYYDIAG1, " The default interrupt read buffer size is: %d\n"
                 "------  The XoffLimit is                         : %d\n"
                 "------  The XonLimit is                          : %d\n"
                 "------  The pt 8 size is                         : %d\n",
                 pDevExt->BufferSize, pDevExt->HandFlow.XoffLimit,
                 pDevExt->HandFlow.XonLimit, pDevExt->BufferSizePt8);

   //
   // Find out which baud rates are supported by this port.
   //

   if (CD1400_READ( pDevExt->Cd1400, pDevExt->IsPci, GFRCR ) > REV_G) {
      pDevExt->CDClock = 60000000;
		pDevExt->MSVR_RTS = MSVR2;
		pDevExt->MSVR_DTR = MSVR1;
		pDevExt->DTRset = 0x01;
		pDevExt->RTSset = 0x02;
		pDevExt->SupportedBauds = 
				SERIAL_BAUD_134_5 |	SERIAL_BAUD_150 | SERIAL_BAUD_300 |	
				SERIAL_BAUD_600 | SERIAL_BAUD_1200 | SERIAL_BAUD_1800 | 
				SERIAL_BAUD_2400 | SERIAL_BAUD_4800 | SERIAL_BAUD_7200 | 
				SERIAL_BAUD_9600 | SERIAL_BAUD_14400 | SERIAL_BAUD_19200 | 
				SERIAL_BAUD_38400 | SERIAL_BAUD_56K	 | SERIAL_BAUD_57600 | 
				SERIAL_BAUD_115200 | SERIAL_BAUD_128K | SERIAL_BAUD_USER;
	} else {
		pDevExt->CDClock = 25000000;
		pDevExt->MSVR_RTS = MSVR1;
		pDevExt->MSVR_DTR = MSVR2;
		pDevExt->DTRset = 0x02;
		pDevExt->RTSset = 0x01;
		pDevExt->SupportedBauds = SERIAL_BAUD_075 | SERIAL_BAUD_110 |	
	   		SERIAL_BAUD_134_5 |	SERIAL_BAUD_150 | SERIAL_BAUD_300 |	
				SERIAL_BAUD_600 | SERIAL_BAUD_1200 | SERIAL_BAUD_1800 | 
				SERIAL_BAUD_2400 | SERIAL_BAUD_4800 | SERIAL_BAUD_7200 | 
				SERIAL_BAUD_9600 | SERIAL_BAUD_14400 | SERIAL_BAUD_19200 | 
				SERIAL_BAUD_38400 | SERIAL_BAUD_56K	 | SERIAL_BAUD_57600 | 
				SERIAL_BAUD_115200 | SERIAL_BAUD_128K | SERIAL_BAUD_USER;
	}

   //
   // Mark this device as not being opened by anyone.  We keep a
   // variable around so that spurious interrupts are easily
   // dismissed by the ISR.
   //

   pDevExt->DeviceIsOpened = FALSE;

   //
   // Store values into the extension for interval timing.
   //

   //
   // If the interval timer is less than a second then come
   // in with a short "polling" loop.
   //
   // For large (> then 2 seconds) use a 1 second poller.
   //

   pDevExt->ShortIntervalAmount.QuadPart  = -1;
   pDevExt->LongIntervalAmount.QuadPart   = -10000000;
   pDevExt->CutOverAmount.QuadPart        = 200000000;

   // Initialize for the Isr Dispatch

   pDispatch = pDevExt->OurIsrContext;
   pDispatch->IsPci = pDevExt->IsPci;
   pDispatch->Extensions[pDevExt->PortIndex] = pDevExt;
   pDispatch->Cd1400[pDevExt->PortIndex] = pDevExt->Cd1400;


   //
   // Common error path cleanup.  If the status is
   // bad, get rid of the device extension, device object
   // and any memory associated with it.
   //

ExtensionCleanup: ;
   if (!NT_SUCCESS(status)) {

      if (pDispatch) {
         pDispatch->Extensions[pDevExt->PortIndex] = NULL;
         pDispatch->Cd1400[pDevExt->PortIndex] = NULL;
      }

      if (allocedDispatch) {
         ExFreePool(pDevExt->OurIsrContext);
         pDevExt->OurIsrContext = NULL;
      }

      if (pDevExt->Runtime) {
         MmUnmapIoSpace(pDevExt->Runtime, PConfigData->RuntimeLength);
         pDevExt->Runtime = NULL;
      }

      if (pDevExt->BoardMemory) {
         MmUnmapIoSpace(pDevExt->BoardMemory, PConfigData->BoardMemoryLength);
         pDevExt->BoardMemory = NULL;
      }

   }

   return status;

}


BOOLEAN
CyyReset(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyyReset()
    
    Routine Description: This places the hardware in a standard
    configuration. This assumes that it is called at interrupt level.

    Arguments:

    Context - The device extension for serial device being managed.

    Return Value: Always FALSE.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION extension = Context;
    PUCHAR chip = extension->Cd1400;
    ULONG bus = extension->IsPci;
    CYY_IOCTL_BAUD s;

    extension->RxFifoTriggerUsed = FALSE;

    // Disable channel
    CD1400_WRITE(chip,bus,CAR,extension->CdChannel & 0x03);
    CyyCDCmd(extension,CCR_DIS_TX_RX);

    // set the line control, modem control, and the baud to what they should be.

    CyySetLineControl(extension);

    CyySetupNewHandFlow(extension,&extension->HandFlow);

    CyyHandleModemUpdate(extension,FALSE);

    s.Extension = extension;
    s.Baud = extension->CurrentBaud;
    CyySetBaud(&s);

    // Enable port
    CD1400_WRITE(chip,bus,CAR,extension->CdChannel & 0x03);
    CyyCDCmd(extension,CCR_ENA_TX_RX);
    
    // Enable reception and modem interrupts

    CD1400_WRITE(chip,bus,MCOR1,0xf0); // Transitions of DSR,CTS,RI and CD cause IRQ.
                    							// Automatic DTR Mode disabled.

    CD1400_WRITE(chip,bus,MCOR2,0xf0);

	#if 0
    cy_wreg(SRER,0x91);		// Enable MdmCh, RxData, NNDT.
	#endif
    CD1400_WRITE(chip,bus,SRER,0x90); // Enable MdmCh, RxData.

    extension->HoldingEmpty = TRUE;
		
    return FALSE;
}

VOID
CyyUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*--------------------------------------------------------------------------
	CyyUnload()

   Description: This routine is defunct since all device objects 
   are removed before the driver is unloaded.
	
	Arguments:

	DriverObject - A pointer to the driver object.

	Return Value: None. 
--------------------------------------------------------------------------*/
{
   PVOID lockPtr;

   PAGED_CODE();

   lockPtr = MmLockPagableCodeSection(CyyUnload);

   //
   // Unnecessary since our BSS is going away, but do it anyhow to be safe
   //

   CyyGlobals.PAGESER_Handle = NULL;

   if (CyyGlobals.RegistryPath.Buffer != NULL) {
      ExFreePool(CyyGlobals.RegistryPath.Buffer);
      CyyGlobals.RegistryPath.Buffer = NULL;
   }

#if DBG
   SerialLogFree();
#endif

   CyyDbgPrintEx(CYYDIAG3, "In CyyUnload\n");

   MmUnlockPagableImageSection(lockPtr);

}

	
CYY_MEM_COMPARES
CyyMemCompare(
                IN PHYSICAL_ADDRESS A,
                IN ULONG SpanOfA,
                IN PHYSICAL_ADDRESS B,
                IN ULONG SpanOfB
                )

/*++

Routine Description:

    Compare two phsical address.

Arguments:

    A - One half of the comparison.

    SpanOfA - In units of bytes, the span of A.

    B - One half of the comparison.

    SpanOfB - In units of bytes, the span of B.


Return Value:

    The result of the comparison.

--*/

{

   LARGE_INTEGER a;
   LARGE_INTEGER b;

   LARGE_INTEGER lower;
   ULONG lowerSpan;
   LARGE_INTEGER higher;

   //PAGED_CODE(); Non paged because it can be called during CyyLogError, which is non paged now.

   a = A;
   b = B;

   if (a.QuadPart == b.QuadPart) {

      return AddressesAreEqual;

   }

   if (a.QuadPart > b.QuadPart) {

      higher = a;
      lower = b;
      lowerSpan = SpanOfB;

   } else {

      higher = b;
      lower = a;
      lowerSpan = SpanOfA;

   }

   if ((higher.QuadPart - lower.QuadPart) >= lowerSpan) {

      return AddressesAreDisjoint;

   }

   return AddressesOverlap;

}

NTSTATUS
CyyFindInitController(IN PDEVICE_OBJECT PDevObj, IN PCONFIG_DATA PConfig)
/*++

Routine Description:

    This function discovers what type of controller is responsible for
    the given port and initializes the controller and port.

Arguments:

    PDevObj - Pointer to the devobj for the port we are about to init.

    PConfig - Pointer to configuration data for the port we are about to init.

Return Value:

    STATUS_SUCCESS on success, appropriate error value on failure.

--*/

{

   PCYY_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PDEVICE_OBJECT pDeviceObject;
   PCYY_DEVICE_EXTENSION pExtension;
   PHYSICAL_ADDRESS serialPhysicalMax;
   PLIST_ENTRY pCurDevObj;
   NTSTATUS status;
   KIRQL oldIrql;

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyFindInitController(%X, %X)\n",
                 PDevObj, PConfig);

   serialPhysicalMax.LowPart = (ULONG)~0;
   serialPhysicalMax.HighPart = ~0;

   CyyDbgPrintEx(CYYDIAG1, "Attempting to init %wZ\n"
                 "------- Runtime Memory is %x\n"
                 "------- Board Memory is %x\n"
                 "------- BusNumber is %d\n"
                 "------- BusType is %d\n"
                 "------- Runtime AddressSpace is %d\n"
                 "------- Board AddressSpace is %d\n"
                 "------- Interrupt Mode is %d\n",
                 &pDevExt->DeviceName,
                 PConfig->PhysicalRuntime.LowPart,
                 PConfig->PhysicalBoardMemory.LowPart,
                 PConfig->BusNumber,
                 PConfig->InterfaceType,
                 PConfig->RuntimeAddressSpace,
                 PConfig->BoardMemoryAddressSpace,
                 PConfig->InterruptMode);

   //
   // We don't support any boards whose memory wraps around
   // the physical address space.
   //

   if (pDevExt->IsPci) {
//*****************************************************
// error injection
//      if (CyyMemCompare(
//                          PConfig->PhysicalRuntime,
//                          PConfig->RuntimeLength,
//                          serialPhysicalMax,
//                          (ULONG)0
//                          ) == AddressesAreDisjoint) 
//*****************************************************
      if (CyyMemCompare(
                          PConfig->PhysicalRuntime,
                          PConfig->RuntimeLength,
                          serialPhysicalMax,
                          (ULONG)0
                          ) != AddressesAreDisjoint) {
         CyyLogError(
                       PDevObj->DriverObject,
                       NULL,
                       PConfig->PhysicalBoardMemory,
                       CyyPhysicalZero,
                       0,
                       0,
                       0,
                       PConfig->PortIndex+1,
                       STATUS_SUCCESS,
                       CYY_RUNTIME_MEMORY_TOO_HIGH,
                       pDevExt->DeviceName.Length+sizeof(WCHAR),
                       pDevExt->DeviceName.Buffer,
                       0,
                       NULL
                       );

         CyyDbgPrintEx(DPFLTR_WARNING_LEVEL, "Error in config record for %wZ\n"
                       "------  Runtime memory wraps around physical memory\n",
                       &pDevExt->DeviceName);

         return STATUS_NO_SUCH_DEVICE;

      }
   }

//*****************************************************
// error injection
//   if (CyyMemCompare(
//                       PConfig->PhysicalBoardMemory,
//                       PConfig->BoardMemoryLength,
//                       serialPhysicalMax,
//                       (ULONG)0
//                       ) == AddressesAreDisjoint) 
//*****************************************************
   if (CyyMemCompare(
                       PConfig->PhysicalBoardMemory,
                       PConfig->BoardMemoryLength,
                       serialPhysicalMax,
                       (ULONG)0
                       ) != AddressesAreDisjoint) {

      CyyLogError(
                    PDevObj->DriverObject,
                    NULL,
                    PConfig->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    PConfig->PortIndex+1,
                    STATUS_SUCCESS,
                    CYY_BOARD_MEMORY_TOO_HIGH,
                    pDevExt->DeviceName.Length+sizeof(WCHAR),
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL
                    );

      CyyDbgPrintEx(DPFLTR_WARNING_LEVEL, "Error in config record for %wZ\n"
                    "------  board memory wraps around physical memory\n",
                    &pDevExt->DeviceName);

      return STATUS_NO_SUCH_DEVICE;

   }


   //
   // Make sure that the Runtime memory addresses don't
   // overlap the controller registers for PCI cards
   //

   if (pDevExt->IsPci) {
      if (CyyMemCompare(
                          PConfig->PhysicalRuntime,
                          PConfig->RuntimeLength,
                          CyyPhysicalZero,
                          (ULONG)0
                          ) != AddressesAreEqual) {
//*****************************************************
// error injection
//         if (CyyMemCompare(
//                             PConfig->PhysicalRuntime,
//                             PConfig->RuntimeLength,
//                             PConfig->PhysicalBoardMemory,
//                             PConfig->BoardMemoryLength
//                             ) == AddressesAreDisjoint) 
//*****************************************************
         if (CyyMemCompare(
                             PConfig->PhysicalRuntime,
                             PConfig->RuntimeLength,
                             PConfig->PhysicalBoardMemory,
                             PConfig->BoardMemoryLength
                             ) != AddressesAreDisjoint) {

            CyyLogError(
                          PDevObj->DriverObject,
                          NULL,
                          PConfig->PhysicalBoardMemory,
                          PConfig->PhysicalRuntime,
                          0,
                          0,
                          0,
                          PConfig->PortIndex+1,
                          STATUS_SUCCESS,
                          CYY_BOTH_MEMORY_CONFLICT,
                          pDevExt->DeviceName.Length+sizeof(WCHAR),
                          pDevExt->DeviceName.Buffer,
                          0,
                          NULL
                          );

            CyyDbgPrintEx(DPFLTR_WARNING_LEVEL, "Error in config record for %wZ\n"
                          "------  Runtime memory wraps around CD1400 registers\n",
                          &pDevExt->DeviceName);

            return STATUS_NO_SUCH_DEVICE;
         }
      }
   }



   //
   // Now, we will check if this is a port on a multiport card.
   // The conditions are same ISR set and same IRQL/Vector
   //

   //
   // Loop through all previously attached devices
   //

   KeAcquireSpinLock(&CyyGlobals.GlobalsSpinLock, &oldIrql);

   if (!IsListEmpty(&CyyGlobals.AllDevObjs)) {
      pCurDevObj = CyyGlobals.AllDevObjs.Flink;
      pExtension = CONTAINING_RECORD(pCurDevObj, CYY_DEVICE_EXTENSION,
                                     AllDevObjs);
   } else {
      pCurDevObj = NULL;
      pExtension = NULL;
   }

   KeReleaseSpinLock(&CyyGlobals.GlobalsSpinLock, oldIrql);

   //
   // If there is an interrupt status then we
   // loop through the config list again to look
   // for a config record with the same interrupt
   // status (on the same bus).
   //

   if (pCurDevObj != NULL) {

      ASSERT(pExtension != NULL);

      //
      // We have an interrupt status.  Loop through all
      // previous records, look for an existing interrupt status
      // the same as the current interrupt status.
      //
      do {

         //
         // We only care about this list if the elements are on the
         // same bus as this new entry.  (Their interrupts must therefore
         // also be the on the same bus.  We will check that momentarily).
         //
         // We don't check here for the dissimilar interrupts since that
         // could cause us to miss the error of having the same interrupt
         // status but different interrupts - which is bizzare.
         //

         if ((pExtension->InterfaceType == PConfig->InterfaceType) &&
             (pExtension->BoardMemoryAddressSpace == PConfig->BoardMemoryAddressSpace) &&
             (pExtension->BusNumber == PConfig->BusNumber)) {

            //
            // If the board memory is the same, then same card.
            //

            if (CyyMemCompare(
                                pExtension->OriginalBoardMemory,
                                pExtension->BoardMemoryLength,
                                PConfig->PhysicalBoardMemory,
                                PConfig->BoardMemoryLength
                                ) == AddressesAreEqual) {

               //
               // Same card.  Now make sure that they
               // are using the same interrupt parameters.
               //

               // BUILD 2128: OriginalIrql replaced by TrIrql and Irql; same for OriginalVector
               if ((PConfig->TrIrql != pExtension->Irql) ||
                   (PConfig->TrVector != pExtension->Vector)) {

//*************************************************************
// Error Injection
//               if ((PConfig->TrIrql == pExtension->Irql) ||
//                   (PConfig->TrVector != pExtension->Vector)) 
//*************************************************************

                  //
                  // We won't put this into the configuration
                  // list.
                  //
                  CyyLogError(
                                PDevObj->DriverObject,
                                NULL,
                                PConfig->PhysicalBoardMemory,
                                pExtension->OriginalBoardMemory,
                                0,
                                0,
                                0,
                                PConfig->PortIndex+1,
                                STATUS_SUCCESS,
                                CYY_MULTI_INTERRUPT_CONFLICT,
                                pDevExt->DeviceName.Length+sizeof(WCHAR),
                                pDevExt->DeviceName.Buffer,
                                pExtension->DeviceName.Length
                                + sizeof(WCHAR),
                                pExtension->DeviceName.Buffer
                                );

                  CyyDbgPrintEx(DPFLTR_WARNING_LEVEL, "Configuration error "
                                "for %wZ\n"
                                "------- Same multiport - different "
                                "interrupts\n", &pDevExt->DeviceName);

                  return STATUS_NO_SUCH_DEVICE;

               }

               if (pDevExt->IsPci) {
                  //
                  // PCI board. Make sure the PCI memory addresses are equal.
                  //
                  if (CyyMemCompare(
                                      pExtension->OriginalRuntimeMemory,
                                      pExtension->RuntimeLength,
                                      PConfig->PhysicalRuntime,
                                      PConfig->RuntimeLength
                                      ) != AddressesAreEqual) {
//*****************************************************
// error injection
//                  if (CyyMemCompare(
//                                     pExtension->OriginalRuntimeMemory,
//                                      pExtension->RuntimeLength,
//                                      PConfig->PhysicalRuntime,
//                                      PConfig->RuntimeLength
//                                      ) == AddressesAreEqual) 
//*****************************************************

                     CyyLogError(
                                   PDevObj->DriverObject,
                                   NULL,
                                   PConfig->PhysicalRuntime,
                                   pExtension->OriginalRuntimeMemory,
                                   0,
                                   0,
                                   0,
                                   PConfig->PortIndex+1,
                                   STATUS_SUCCESS,
                                   CYY_MULTI_RUNTIME_CONFLICT,
                                   pDevExt->DeviceName.Length+sizeof(WCHAR),
                                   pDevExt->DeviceName.Buffer,
                                   pExtension->DeviceName.Length
                                   + sizeof(WCHAR),
                                   pExtension->DeviceName.Buffer
                                   );

                     CyyDbgPrintEx(DPFLTR_WARNING_LEVEL, "Configuration error "
                                   "for %wZ\n"
                                   "------- Same multiport - different "
                                   "Runtime addresses\n", &pDevExt->DeviceName);

                     return STATUS_NO_SUCH_DEVICE;
                  }
               }

               //
               // We should never get this far on a restart since we don't
               // support stop on ISA multiport devices!
               //

               ASSERT(pDevExt->PNPState == CYY_PNP_ADDED);

               //
               //
               // Initialize the device as part of a multiport board
               //

               CyyDbgPrintEx(CYYDIAG1, "Aha! It is a multiport node\n");
               CyyDbgPrintEx(CYYDIAG1, "Matched to %x\n", pExtension);

               status = CyyInitMultiPort(pExtension, PConfig, PDevObj);

               //
               // A port can be one of two things:
               //    A non-root on a multiport
               //    A root on a multiport
               //
               // It can only share an interrupt if it is a root.
               // Since this was a non-root we don't need to check 
               // if it shares an interrupt and we can return.
               //
               return status;
            }
         }

         //
         // No match, check some more
         //

         KeAcquireSpinLock(&CyyGlobals.GlobalsSpinLock, &oldIrql);

         pCurDevObj = pCurDevObj->Flink;
         if (pCurDevObj != NULL) {
            pExtension = CONTAINING_RECORD(pCurDevObj,CYY_DEVICE_EXTENSION,
                                           AllDevObjs);
         }

         KeReleaseSpinLock(&CyyGlobals.GlobalsSpinLock, oldIrql);

      } while (pCurDevObj != NULL && pCurDevObj != &CyyGlobals.AllDevObjs);
   }


   CyyDbgPrintEx(CYYDIAG1, "Aha! It is a first multi\n");

   status = CyyInitController(PDevObj, PConfig);

   if (!NT_SUCCESS(status)) {
      return status;
   }

   return STATUS_SUCCESS;
}


PUCHAR
GetMyMappedCD1400Address(IN PUCHAR BoardMemory, IN ULONG PortIndex, IN ULONG IsPci)
{

   const ULONG CyyCDOffset[] = {	// CD1400 offsets within the board
   0x00000000,0x00000400,0x00000800,0x00000C00,
   0x00000200,0x00000600,0x00000A00,0x00000E00
   };
   ULONG chipIndex = PortIndex/4;

   return(BoardMemory + (CyyCDOffset[chipIndex] << IsPci));      

}

PHYSICAL_ADDRESS
GetMyPhysicalCD1400Address(IN PHYSICAL_ADDRESS BoardMemory, IN ULONG PortIndex, IN ULONG IsPci)
{

   const ULONG CyyCDOffset[] = {	// CD1400 offsets within the board
   0x00000000,0x00000400,0x00000800,0x00000C00,
   0x00000200,0x00000600,0x00000A00,0x00000E00
   };
   ULONG chipIndex = PortIndex/CYY_CHANNELS_PER_CHIP;

   BoardMemory.QuadPart += (CyyCDOffset[chipIndex] << IsPci);

   return(BoardMemory);      

}


VOID
CyyCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
/*--------------------------------------------------------------------------
    CyyComError()
    
    Routine Description: This routine is invoked at dpc level in response
    to a comm error.  All comm errors kill all read and writes

    Arguments:

    Dpc - Not Used.
    DeferredContext - points to the device object.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.

    Return Value: None.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = DeferredContext;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyCommError(%X)\n", Extension);

    CyyKillAllReadsOrWrites(
        Extension->DeviceObject,
        &Extension->WriteQueue,
        &Extension->CurrentWriteIrp
        );

    CyyKillAllReadsOrWrites(
        Extension->DeviceObject,
        &Extension->ReadQueue,
        &Extension->CurrentReadIrp
        );
    CyyDpcEpilogue(Extension, Dpc);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyCommError\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyymodem.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file :     cyymodem.c
*	
*   Description:    This module contains the code related to modem control 
*                   in the Cyclom-Y Port driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/


#include "precomp.h"

BOOLEAN
CyyDecrementRTSCounter(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#if 0
#pragma alloc_text(PAGESER,CyyHandleReducedIntBuffer)
#pragma alloc_text(PAGESER,CyyProdXonXoff)
#pragma alloc_text(PAGESER,CyyHandleModemUpdate)
#pragma alloc_text(PAGESER,CyyHandleModemUpdateForModem)
#pragma alloc_text(PAGESER,CyyPerhapsLowerRTS)
#pragma alloc_text(PAGESER,CyyStartTimerLowerRTS)
#pragma alloc_text(PAGESER,CyyInvokePerhapsLowerRTS)
#pragma alloc_text(PAGESER,CyySetDTR)
//#pragma alloc_text(PAGESER,CyyClrDTR)
#pragma alloc_text(PAGESER,CyySetRTS)
//#pragma alloc_text(PAGESER,CyyClrRTS)
#pragma alloc_text(PAGESER,CyyGetDTRRTS)
//#pragma alloc_text(PAGESER,CyySetupNewHandFlow)
#pragma alloc_text(PAGESER,CyySetHandFlow)
#pragma alloc_text(PAGESER,CyyTurnOnBreak)
#pragma alloc_text(PAGESER,CyyTurnOffBreak)
#pragma alloc_text(PAGESER,CyyPretendXoff)
#pragma alloc_text(PAGESER,CyyPretendXon)
#pragma alloc_text(PAGESER,CyyDecrementRTSCounter)
#endif
#endif

BOOLEAN
CyySetDTR(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyySetDTR()
    
    Routine Description: This routine which is only called at interrupt
    level is used to set the DTR in the modem control register.

    Arguments:

    Context - Really a pointer to the device extension.

    Return Value: This routine always returns FALSE.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = Context;
    PUCHAR chip = Extension->Cd1400;
    ULONG bus = Extension->IsPci;

    CyyDbgPrintEx(CYYFLOW, "Setting DTR for Port%d Pci%d\n", 
                  Extension->PortIndex+1,Extension->PciSlot);

    CD1400_WRITE(chip,bus, CAR, Extension->CdChannel & 0x03);
    CD1400_WRITE(chip,bus, Extension->MSVR_DTR, Extension->DTRset);

    return FALSE;
}

BOOLEAN
CyyClrDTR(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyyClrDTR()
    
    Routine Description: Clear DTR.

    Arguments:

    Context - Really a pointer to the device extension.

    Return Value: This routine always returns FALSE.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = Context;

    PUCHAR chip = Extension->Cd1400;
    ULONG bus = Extension->IsPci;

    CyyDbgPrintEx(CYYFLOW, "Clearing DTR for Port%d Pci%d\n", 
                  Extension->PortIndex+1,Extension->PciSlot);

    CD1400_WRITE(chip,bus, CAR, Extension->CdChannel & 0x03);
    CD1400_WRITE(chip,bus, Extension->MSVR_DTR, 0x00);

    return FALSE;
}

BOOLEAN
CyySetRTS(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyySetRTS()
    
    Routine Description: Set RTS.

    Arguments:

    Context - Really a pointer to the device extension.

    Return Value: This routine always returns FALSE.
--------------------------------------------------------------------------*/
{
   PCYY_DEVICE_EXTENSION Extension = Context;
   PUCHAR chip = Extension->Cd1400;
   ULONG bus = Extension->IsPci;

   CyyDbgPrintEx(CYYFLOW, "Setting RTS for Port%d Pci%d\n", 
                           Extension->PortIndex+1,Extension->PciSlot);

   CD1400_WRITE(chip,bus, CAR, Extension->CdChannel & 0x03);
   CD1400_WRITE(chip,bus, Extension->MSVR_RTS, Extension->RTSset);

   return FALSE;
}

BOOLEAN
CyyClrRTS(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyyClrRTS()
    
    Routine Description: Clears RTS. 

    Arguments:

    Context - Really a pointer to the device extension.

    Return Value: This routine always returns FALSE.
--------------------------------------------------------------------------*/
{
   PCYY_DEVICE_EXTENSION Extension = Context;
   PUCHAR chip = Extension->Cd1400;
   ULONG bus = Extension->IsPci;

   CyyDbgPrintEx(CYYFLOW, "Clearing RTS for Port%d Pci%d\n", 
                           Extension->PortIndex+1,Extension->PciSlot);

   CD1400_WRITE(chip,bus, CAR, Extension->CdChannel & 0x03);
   CD1400_WRITE(chip,bus, Extension->MSVR_RTS, 0x00);

   return FALSE;
}

BOOLEAN
CyyGetDTRRTS(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyyGetDTRRTS()
    
    Routine Description: Get DTR and RTS states.

    Arguments:

    Context - Pointer to a structure that contains a pointer to 
    	      the device extension and a pointer to a ulong.

    Return Value: This routine always returns FALSE.
--------------------------------------------------------------------------*/
{

   UCHAR dtr,rts;
   PCYY_DEVICE_EXTENSION Extension = ((PCYY_IOCTL_SYNC)Context)->Extension;
   PULONG Result = (PULONG)(((PCYY_IOCTL_SYNC)Context)->Data);

   PUCHAR chip = Extension->Cd1400;
   ULONG bus = Extension->IsPci;
   ULONG ModemControl=0;
   
   CD1400_WRITE(chip,bus, CAR, Extension->CdChannel & 0x03);
   dtr = CD1400_READ(chip,bus,Extension->MSVR_DTR);
   rts = CD1400_READ(chip,bus,Extension->MSVR_RTS);

   if (dtr & Extension->DTRset) {
      ModemControl |= SERIAL_DTR_STATE;
   }
   if (rts & Extension->RTSset) {
      ModemControl |= SERIAL_RTS_STATE;
   }
   *Result = ModemControl;

   return FALSE;
}

BOOLEAN
CyySetupNewHandFlow(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN PSERIAL_HANDFLOW NewHandFlow
    )
/*--------------------------------------------------------------------------
    CyySetupNewHandFlow()
    
    Routine Description: This routine adjusts the flow control based on new
    control flow.

    Arguments:

    Extension - A pointer to the serial device extension.

    NewHandFlow - A pointer to a serial handflow structure.

    Return Value: This routine always returns FALSE.
--------------------------------------------------------------------------*/
{
    SERIAL_HANDFLOW New = *NewHandFlow;

    // --- DTR signal
    
    if((!Extension->DeviceIsOpened) ||
       ((Extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK) !=
         (New.ControlHandShake & SERIAL_DTR_MASK))) {

        // It is an open or DTR has changed.

        CyyDbgPrintEx(CYYFLOW, "Processing DTR flow for Port%d Pci%d\n",
                      Extension->PortIndex+1,Extension->PciSlot);

        if (New.ControlHandShake & SERIAL_DTR_MASK) { // set DTR.
	    
            if((New.ControlHandShake&SERIAL_DTR_MASK) == SERIAL_DTR_HANDSHAKE) {
		    	// but we are doing DTR handshake.
                if ((Extension->BufferSize - New.XoffLimit) >
                    Extension->CharsInInterruptBuffer) {

                    if (Extension->RXHolding & CYY_RX_DTR) {
				    	// DTR is low due to flow control
//#ifdef CHANGED_TO_DEBUG_RTPR
//Original code
                        if(Extension->CharsInInterruptBuffer >
//#endif						
//Changed code
//                      if(Extension->CharsInInterruptBuffer <
                            (ULONG)New.XonLimit) {

                            CyyDbgPrintEx(CYYFLOW, "Removing DTR block on "
                                          "reception for Port%d Pci%d\n",
                                          Extension->PortIndex+1,Extension->PciSlot);

                            Extension->RXHolding &= ~CYY_RX_DTR;
                            CyySetDTR(Extension);
                        }
                    } else {
                        CyySetDTR(Extension);
                    }
                } else {
		   			  // DTR should go low because of handshake

                    CyyDbgPrintEx(CYYFLOW, "Setting DTR block on reception "
                                  "for Port%d Pci%d\n", 
                                  Extension->PortIndex+1,Extension->PciSlot);
                    Extension->RXHolding |= CYY_RX_DTR;
                    CyyClrDTR(Extension);
                }
            } else {
				    // no DTR handshake, check if it was active before.
                if (Extension->RXHolding & CYY_RX_DTR) {
                    CyyDbgPrintEx(CYYFLOW, "Removing dtr block of reception "
                                        "for Port%d Pci%d\n", 
                                        Extension->PortIndex+1,Extension->PciSlot);
                    Extension->RXHolding &= ~CYY_RX_DTR;
                }
                CyySetDTR(Extension);
            }
        } else {	// reset DTR
            if (Extension->RXHolding & CYY_RX_DTR) {
               CyyDbgPrintEx(CYYFLOW, "removing dtr block of reception for"
                                      " Port%d Pci%d\n", 
                                      Extension->PortIndex+1,Extension->PciSlot);
               Extension->RXHolding &= ~CYY_RX_DTR;
            }
            CyyClrDTR(Extension);
        }
    }
    
    // --- RTS signal

    if ((!Extension->DeviceIsOpened) ||
        ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) !=
         (New.FlowReplace & SERIAL_RTS_MASK))) {

        // It is an open or RTS has changed.

        CyyDbgPrintEx(CYYFLOW, "Processing RTS flow\n",
                      Extension->PortIndex+1,Extension->PciSlot);

        if((New.FlowReplace&SERIAL_RTS_MASK) == SERIAL_RTS_HANDSHAKE) {//set RTS

            if ((Extension->BufferSize - New.XoffLimit) >
                Extension->CharsInInterruptBuffer) {

                // However if we are already holding we don't want
                // to turn it back on unless we exceed the Xon
                // limit.

                if (Extension->RXHolding & CYY_RX_RTS) {
                    // We can assume that its RTS line is already low.
//#ifdef CHANGED_TO_DEBUG_RTPR
//Original code
                    if (Extension->CharsInInterruptBuffer >
//#endif					
//Changed code
//                  if (Extension->CharsInInterruptBuffer <
                        (ULONG)New.XonLimit) {

                        CyyDbgPrintEx(CYYFLOW, "Removing rts block of "
                                      "reception for Port%d Pci%d\n",
                                      Extension->PortIndex+1,Extension->PciSlot);
                        Extension->RXHolding &= ~CYY_RX_RTS;
                        CyySetRTS(Extension);
                    }
                } else {
                    CyySetRTS(Extension);
                }

            } else {
                CyyDbgPrintEx(CYYFLOW, "Setting rts block of reception for "
                              "Port%d Pci%d\n", 
                              Extension->PortIndex+1,Extension->PciSlot);
                Extension->RXHolding |= CYY_RX_RTS;
                CyyClrRTS(Extension);
            }
        } else if ((New.FlowReplace & SERIAL_RTS_MASK) == SERIAL_RTS_CONTROL) {

            // Note that if we aren't currently doing rts flow control then
            // we MIGHT have been.  So even if we aren't currently doing
            // RTS flow control, we should still check if RX is holding
            // because of RTS.  If it is, then we should clear the holding
            // of this bit.

            if (Extension->RXHolding & CYY_RX_RTS) {

                CyyDbgPrintEx(CYYFLOW, "Clearing rts block of reception for "
                              "Port%d Pci%d\n", 
                              Extension->PortIndex+1,Extension->PciSlot);
                Extension->RXHolding &= ~CYY_RX_RTS;
            }
            CyySetRTS(Extension);
        } else if((New.FlowReplace & SERIAL_RTS_MASK) == SERIAL_TRANSMIT_TOGGLE) {

            // We first need to check whether reception is being held
            // up because of previous RTS flow control.  If it is then
            // we should clear that reason in the RXHolding mask.

            if (Extension->RXHolding & CYY_RX_RTS) {

                CyyDbgPrintEx(CYYFLOW, "TOGGLE Clearing rts block of "
                              "reception for Port%d Pci%d\n", 
                              Extension->PortIndex+1,Extension->PciSlot);
                Extension->RXHolding &= ~CYY_RX_RTS;
            }

            // We have to place the rts value into the Extension
            // now so that the code that tests whether the
            // rts line should be lowered will find that we
            // are "still" doing transmit toggling.  The code
            // for lowering can be invoked later by a timer so
            // it has to test whether it still needs to do its
            // work.

            Extension->HandFlow.FlowReplace &= ~SERIAL_RTS_MASK;
            Extension->HandFlow.FlowReplace |= SERIAL_TRANSMIT_TOGGLE;

            // The order of the tests is very important below.
            // If there is a break then we should turn on the RTS.
            // If there isn't a break but there are characters in
            // the hardware, then turn on the RTS.
            // If there are writes pending that aren't being held
            // up, then turn on the RTS.

            if ((!Extension->HoldingEmpty) ||
                (Extension->CurrentWriteIrp || Extension->TransmitImmediate ||
                 (!IsListEmpty(&Extension->WriteQueue)) &&
                 (!Extension->TXHolding))) {
		
                CyySetRTS(Extension);
            } else {
                // This routine will check to see if it is time
                // to lower the RTS because of transmit toggle
                // being on.  If it is ok to lower it, it will,
                // if it isn't ok, it will schedule things so
                // that it will get lowered later.

                Extension->CountOfTryingToLowerRTS++;
                CyyPerhapsLowerRTS(Extension);

            }
        } else {
            // The end result here will be that RTS is cleared.
            //
            // We first need to check whether reception is being held
            // up because of previous RTS flow control.  If it is then
            // we should clear that reason in the RXHolding mask.

            if (Extension->RXHolding & CYY_RX_RTS) {

                CyyDbgPrintEx(CYYFLOW, "Clearing rts block of reception for"
                              " Port%d Pci%d\n", 
                              Extension->PortIndex+1,Extension->PciSlot);
                Extension->RXHolding &= ~CYY_RX_RTS;
            }
            CyyClrRTS(Extension);
        }
    }
    
    // We now take care of automatic receive flow control.
    // We only do work if things have changed.

    if ((!Extension->DeviceIsOpened) ||
        ((Extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) !=
         (New.FlowReplace & SERIAL_AUTO_RECEIVE))) {

        if (New.FlowReplace & SERIAL_AUTO_RECEIVE) {

            // We wouldn't be here if it had been on before.
            //
            // We should check to see whether we exceed the turn
            // off limits.
            //
            // Note that since we are following the OS/2 flow
            // control rules we will never send an xon if
            // when enabling xon/xoff flow control we discover that
            // we could receive characters but we are held up do
            // to a previous Xoff.

            if ((Extension->BufferSize - New.XoffLimit) <=
                Extension->CharsInInterruptBuffer) {
                // Cause the Xoff to be sent.
		
                Extension->RXHolding |= CYY_RX_XOFF;
                CyyProdXonXoff(Extension,FALSE);
            }
        } else {
            // The app has disabled automatic receive flow control.
            //
            // If transmission was being held up because of
            // an automatic receive Xoff, then we should
            // cause an Xon to be sent.

            if (Extension->RXHolding & CYY_RX_XOFF) {
                Extension->RXHolding &= ~CYY_RX_XOFF;

                // Cause the Xon to be sent.
                CyyProdXonXoff(Extension,TRUE);
            }
        }
    }

    // We now take care of automatic transmit flow control.
    // We only do work if things have changed.

    if ((!Extension->DeviceIsOpened) ||
        ((Extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) !=
         (New.FlowReplace & SERIAL_AUTO_TRANSMIT))) {

        if (New.FlowReplace & SERIAL_AUTO_TRANSMIT) {

            // We wouldn't be here if it had been on before.
            //
            // There is some belief that if autotransmit
            // was just enabled, I should go look in what we
            // already received, and if we find the xoff character
            // then we should stop transmitting.  I think this
            // is an application bug.  For now we just care about
            // what we see in the future.

            ;
        } else {
            // The app has disabled automatic transmit flow control.
            //
            // If transmission was being held up because of
            // an automatic transmit Xoff, then we should
            // cause an Xon to be sent.

            if (Extension->TXHolding & CYY_TX_XOFF) {
                Extension->TXHolding &= ~CYY_TX_XOFF;

                // Cause the Xon to be sent.
                CyyProdXonXoff(Extension,TRUE);
            }
        }
    }

    // At this point we can simply make sure that entire
    // handflow structure in the extension is updated.

    Extension->HandFlow = New;
    return FALSE;
}

BOOLEAN
CyySetHandFlow(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyySetHandFlow()
    
    Routine Description: This routine is used to set the handshake and
    control flow in the device extension.

    Arguments:

    Context - Pointer to a structure that contains a pointer to the device
    	      extension and a pointer to a handflow structure.

    Return Value: This routine always returns FALSE.
--------------------------------------------------------------------------*/
{
    PCYY_IOCTL_SYNC S = Context;
    PCYY_DEVICE_EXTENSION Extension = S->Extension;
    PSERIAL_HANDFLOW HandFlow = S->Data;

    CyySetupNewHandFlow(Extension,HandFlow);
    CyyHandleModemUpdate(Extension,FALSE);
    return FALSE;
}

BOOLEAN
CyyTurnOnBreak(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyyTurnOnBreak()
    
    Routine Description: Send a Break.

    Arguments:

    Context - Really a pointer to the device extension.

    Return Value: This routine always returns FALSE.
--------------------------------------------------------------------------*/
{

    PCYY_DEVICE_EXTENSION Extension = Context;
    PUCHAR chip = Extension->Cd1400;
    ULONG bus = Extension->IsPci;
    UCHAR cor2;

    // Enable ETC mode
    CD1400_WRITE(chip,bus, CAR, Extension->CdChannel);
    cor2 = CD1400_READ(chip,bus,COR2);
    CD1400_WRITE(chip,bus, COR2,cor2 | EMBED_TX_ENABLE); // enable ETC bit
    CyyCDCmd(Extension,CCR_CORCHG_COR2); // COR2 changed

    Extension->BreakCmd = SEND_BREAK;

    if (Extension->HoldingEmpty) {
        CyyTxStart(Extension);
    }

    return FALSE;
}

BOOLEAN
CyyTurnOffBreak(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyyTurnOffBreak()
    
    Routine Description: Do nothing.

    Arguments:

    Context - Really a pointer to the device extension.

    Return Value: This routine always returns FALSE.
--------------------------------------------------------------------------*/
{

    PCYY_DEVICE_EXTENSION Extension = Context;
    PUCHAR chip = Extension->Cd1400;
    ULONG bus = Extension->IsPci;
    UCHAR cor2;

    if (Extension->TXHolding & CYY_TX_BREAK) {
	
        // Enable ETC mode
        CD1400_WRITE(chip,bus, CAR, Extension->CdChannel);
        cor2 = CD1400_READ(chip,bus,COR2);
        CD1400_WRITE(chip,bus, COR2,cor2 | EMBED_TX_ENABLE); // enable ETC bit
        CyyCDCmd(Extension,CCR_CORCHG_COR2);	// COR2 changed

        Extension->BreakCmd = STOP_BREAK;

        if (Extension->HoldingEmpty) {
            CyyTxStart(Extension);
        }

    }
    return FALSE;
}

BOOLEAN
CyyPretendXoff(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyyPretendXoff()
    
    Routine Description: This routine is used to process the Ioctl that
    request the driver to act as if an Xoff was received.  Even if the
    driver does not have automatic Xoff/Xon flowcontrol - This still will
    stop the transmission.  This is the OS/2 behavior and is not well
    specified for Windows.  Therefore we adopt the OS/2 behavior.

    Note: If the driver does not have automatic Xoff/Xon enabled
    then the only way to restart transmission is for the
    application to request we "act" as if we saw the xon.

    Arguments:

    Context - pointer to the device extension.

    Return Value: This routine always returns FALSE.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = Context;

    Extension->TXHolding |= CYY_TX_XOFF;

    if((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
      						  SERIAL_TRANSMIT_TOGGLE) {
        CyyInsertQueueDpc(
            &Extension->StartTimerLowerRTSDpc,
            NULL,
            NULL,
            Extension
            )?Extension->CountOfTryingToLowerRTS++:0;
    }
    return FALSE;
}

BOOLEAN
CyyPretendXon(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyyPretendXon()
    Routine Description: This routine is used to process the Ioctl that
    request the driver to act as if an Xon was received.

    Note: If the driver does not have automatic Xoff/Xon enabled
    then the only way to restart transmission is for the
    application to request we "act" as if we saw the xon.

    Arguments:

    Context - pointer to the device extension.

    Return Value:

    This routine always returns FALSE.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = Context;

    if (Extension->TXHolding) {
        // We actually have a good reason for testing if transmission
        // is holding instead of blindly clearing the bit.
        //
        // If transmission actually was holding and the result of
        // clearing the bit is that we should restart transmission
        // then we will poke the interrupt enable bit, which will
        // cause an actual interrupt and transmission will then
        // restart on its own.
        //
        // If transmission wasn't holding and we poked the bit
        // then we would interrupt before a character actually made
        // it out and we could end up over writing a character in
        // the transmission hardware.

        Extension->TXHolding &= ~CYY_TX_XOFF;

        if (!Extension->TXHolding &&
            (Extension->TransmitImmediate ||
             Extension->WriteLength) &&
             Extension->HoldingEmpty) {

	    CyyTxStart(Extension);
        }
    }
    return FALSE;
}

VOID
CyyHandleReducedIntBuffer(
    IN PCYY_DEVICE_EXTENSION Extension
    )
/*--------------------------------------------------------------------------
    CyyHandleReducedIntBuffer()
    
    Routine Description: This routine is called to handle a reduction in
    the number of characters in the interrupt (typeahead) buffer.  It
    will check the current output flow control and re-enable transmission
    as needed.

    NOTE: This routine assumes that it is working at interrupt level.

    Arguments:

    Extension - A pointer to the device extension.

    Return Value: None.
--------------------------------------------------------------------------*/
{
    // If we are doing receive side flow control and we are
    // currently "holding" then because we've emptied out
    // some characters from the interrupt buffer we need to
    // see if we can "re-enable" reception.

    if (Extension->RXHolding) {
        if (Extension->CharsInInterruptBuffer <=
		            (ULONG)Extension->HandFlow.XonLimit) {
            if (Extension->RXHolding & CYY_RX_DTR) {
                Extension->RXHolding &= ~CYY_RX_DTR;
                CyySetDTR(Extension);
            }

            if (Extension->RXHolding & CYY_RX_RTS) {
                Extension->RXHolding &= ~CYY_RX_RTS;
                CyySetRTS(Extension);
            }

            if (Extension->RXHolding & CYY_RX_XOFF) {
                CyyProdXonXoff(Extension,TRUE );
            }
        }
    }
}

VOID
CyyProdXonXoff(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN BOOLEAN SendXon
    )
/*--------------------------------------------------------------------------
    CyyProdXonXoff()
    
    Routine Description: This routine will set up the SendXxxxChar
    variables if necessary and determine if we are going to be interrupting
    because of current transmission state.  It will cause an
    interrupt to occur if neccessary, to send the xon/xoff char.
    NOTE: This routine assumes that it is called at interrupt level.

    Arguments:

    Extension - A pointer to the serial device extension.
    SendXon - If a character is to be send, this indicates whether
              it should be an Xon or an Xoff.

    Return Value: None.
--------------------------------------------------------------------------*/
{
    if (SendXon) {
        CyySendXon(Extension);
    } else {
        CyySendXoff(Extension);
    }
}

ULONG
CyyHandleModemUpdate(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN BOOLEAN DoingTX
    )
/*--------------------------------------------------------------------------
    CyyHandleModemUpdate()
    
    Routine Description: check on the modem status, and handle any
    appropriate event notification as well as any flow control appropriate
    to modem status lines.
    
    Arguments:

    Extension - A pointer to the serial device extension.
    DoingTX - This boolean is used to indicate that this call
              came from the transmit processing code.  If this
              is true then there is no need to cause a new interrupt
              since the code will be trying to send the next
              character as soon as this call finishes.

    Return Value: This returns the old value of the modem status register
--------------------------------------------------------------------------*/
{
    ULONG OldTXHolding = Extension->TXHolding;
    UCHAR ModemStatus = 0;
    unsigned char msvr;
    PUCHAR chip = Extension->Cd1400;
    ULONG bus = Extension->IsPci;

    CD1400_WRITE(chip,bus, CAR, Extension->CdChannel);
    msvr = CD1400_READ(chip,bus,MSVR1);
	
    if(msvr & 0x40)	ModemStatus |= SERIAL_MSR_CTS;
    if(msvr & 0x80)	ModemStatus |= SERIAL_MSR_DSR;
    if(msvr & 0x20)	ModemStatus |= SERIAL_MSR_RI;
    if(msvr & 0x10)	ModemStatus |= SERIAL_MSR_DCD;

#if 0
    if(Extension->LieRIDSR == TRUE) {			// we have to lie...
        ModemStatus |= SERIAL_MSR_DSR;			// DSR always on
        ModemStatus &= ~(SERIAL_MSR_RI);		// RI always off
        ModemStatus &= ~(SERIAL_MSR_DDSR | SERIAL_MSR_TERI);
    }
#endif
    
    // If we are placing the modem status into the data stream
    // on every change, we should do it now.

    if (Extension->EscapeChar) {
        if (ModemStatus & (SERIAL_MSR_DCTS |
                           SERIAL_MSR_DDSR |
                           SERIAL_MSR_TERI |
                           SERIAL_MSR_DDCD)) {
            CyyPutChar(Extension,Extension->EscapeChar);
            CyyPutChar(Extension,SERIAL_LSRMST_MST);
            CyyPutChar(Extension,ModemStatus);
        }
    }

    // Take care of input flow control based on sensitivity
    // to the DSR.  This is done so that the application won't
    // see spurious data generated by odd devices.
    //
    // Basically, if we are doing dsr sensitivity then the
    // driver should only accept data when the dsr bit is set.

    if (Extension->HandFlow.ControlHandShake & SERIAL_DSR_SENSITIVITY) {
        if (ModemStatus & SERIAL_MSR_DSR) {
            Extension->RXHolding &= ~CYY_RX_DSR;
        } else {
            Extension->RXHolding |= CYY_RX_DSR;
        }
    } else {
        Extension->RXHolding &= ~CYY_RX_DSR;
    }

    // Check to see if we have a wait pending on the modem status events.
    // If we do then we schedule a dpc to satisfy that wait.

    if (Extension->IsrWaitMask) {
        if((Extension->IsrWaitMask&SERIAL_EV_CTS)&&(ModemStatus&SERIAL_MSR_DCTS)) {
            Extension->HistoryMask |= SERIAL_EV_CTS;
        }
        if((Extension->IsrWaitMask&SERIAL_EV_DSR)&&(ModemStatus&SERIAL_MSR_DDSR)) {
            Extension->HistoryMask |= SERIAL_EV_DSR;
        }
        if((Extension->IsrWaitMask&SERIAL_EV_RING)&&(ModemStatus&SERIAL_MSR_TERI)) {
            Extension->HistoryMask |= SERIAL_EV_RING;
        }
        if((Extension->IsrWaitMask&SERIAL_EV_RLSD)&&(ModemStatus&SERIAL_MSR_DDCD)) {
            Extension->HistoryMask |= SERIAL_EV_RLSD;
        }
        if(Extension->IrpMaskLocation && Extension->HistoryMask) {
            *Extension->IrpMaskLocation = Extension->HistoryMask;
            Extension->IrpMaskLocation = NULL;
            Extension->HistoryMask = 0;
            Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
            CyyInsertQueueDpc(&Extension->CommWaitDpc,NULL,NULL,Extension);
        }
    }

    // If the app has modem line flow control then
    // we check to see if we have to hold up transmission.

    if (Extension->HandFlow.ControlHandShake & SERIAL_OUT_HANDSHAKEMASK) {
        if (Extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE) {
            if (ModemStatus & SERIAL_MSR_CTS) {
                Extension->TXHolding &= ~CYY_TX_CTS;
            } else {
                Extension->TXHolding |= CYY_TX_CTS;
            }
        } else {
            Extension->TXHolding &= ~CYY_TX_CTS;
        }
        if (Extension->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE) {
            if (ModemStatus & SERIAL_MSR_DSR) {
                Extension->TXHolding &= ~CYY_TX_DSR;
            } else {
                Extension->TXHolding |= CYY_TX_DSR;
            }
        } else {
            Extension->TXHolding &= ~CYY_TX_DSR;
        }
        if (Extension->HandFlow.ControlHandShake & SERIAL_DCD_HANDSHAKE) {
            if (ModemStatus & SERIAL_MSR_DCD) {
                Extension->TXHolding &= ~CYY_TX_DCD;
            } else {
                Extension->TXHolding |= CYY_TX_DCD;
            }
        } else {
            Extension->TXHolding &= ~CYY_TX_DCD;
        }

        // If we hadn't been holding, and now we are then
        // queue off a dpc that will lower the RTS line
        // if we are doing transmit toggling.

        if (!OldTXHolding && Extension->TXHolding  &&
            ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
              SERIAL_TRANSMIT_TOGGLE)) {

            CyyInsertQueueDpc(
                &Extension->StartTimerLowerRTSDpc,
                NULL,
                NULL,
                Extension
                )?Extension->CountOfTryingToLowerRTS++:0;
        }

        // We've done any adjusting that needed to be
        // done to the holding mask given updates
        // to the modem status.  If the Holding mask
        // is clear (and it wasn't clear to start)
        // and we have "write" work to do set things
        // up so that the transmission code gets invoked.

        if (!DoingTX && OldTXHolding && !Extension->TXHolding) {
            if (!Extension->TXHolding &&
                (Extension->TransmitImmediate ||
                 Extension->WriteLength) &&
                 Extension->HoldingEmpty) {
		
                CyyTxStart(Extension);
            }
        }
    } else {
        // We need to check if transmission is holding
        // up because of modem status lines.  What
        // could have occured is that for some strange
        // reason, the app has asked that we no longer
        // stop doing output flow control based on
        // the modem status lines.  If however, we
        // *had* been held up because of the status lines
        // then we need to clear up those reasons.

        if (Extension->TXHolding & (CYY_TX_DCD | CYY_TX_DSR | CYY_TX_CTS)) {
            Extension->TXHolding &= ~(CYY_TX_DCD | CYY_TX_DSR | CYY_TX_CTS);

            if (!DoingTX && OldTXHolding && !Extension->TXHolding) {
                if (!Extension->TXHolding &&
                    (Extension->TransmitImmediate ||
                     Extension->WriteLength) &&
                     Extension->HoldingEmpty) {

                    CyyTxStart(Extension);
                }
            }
        }
    }
    return ((ULONG)ModemStatus);
}

ULONG
CyyHandleModemUpdateForModem(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN BOOLEAN DoingTX,
	IN UCHAR misr
    )
/*--------------------------------------------------------------------------
    CyyHandleModemUpdateForModem()
    
    Routine Description: check on the modem status, and handle any
    appropriate event notification as well as any flow control appropriate
    to modem status lines.
    
    Arguments:

    Extension - A pointer to the serial device extension.
    DoingTX - This boolean is used to indicate that this call
              came from the transmit processing code.  If this
              is true then there is no need to cause a new interrupt
              since the code will be trying to send the next
              character as soon as this call finishes.
	misr - Modem Interrupt Status Register value.			  

    Return Value: This returns the old value of the modem status register
--------------------------------------------------------------------------*/
{
   ULONG OldTXHolding = Extension->TXHolding;
   UCHAR ModemStatus = 0;
   unsigned char msvr;
   PUCHAR chip = Extension->Cd1400;
   ULONG bus = Extension->IsPci;

   CD1400_WRITE(chip,bus,CAR, Extension->CdChannel);
   msvr = CD1400_READ(chip,bus,MSVR1);

   if(msvr & 0x40)   ModemStatus |= SERIAL_MSR_CTS;
   if(msvr & 0x80)   ModemStatus |= SERIAL_MSR_DSR;
   if(msvr & 0x20)   ModemStatus |= SERIAL_MSR_RI;
   if(msvr & 0x10)   ModemStatus |= SERIAL_MSR_DCD;
   if(misr & 0x40)   ModemStatus |= SERIAL_MSR_DCTS;
   if(misr & 0x80)   ModemStatus |= SERIAL_MSR_DDSR;
   if(misr & 0x20)   ModemStatus |= SERIAL_MSR_TERI;
   if(misr & 0x10)   ModemStatus |= SERIAL_MSR_DDCD;
	

#if 0
   if(Extension->LieRIDSR == TRUE) {			// we have to lie...
 	ModemStatus |= SERIAL_MSR_DSR;			// DSR always on
 	ModemStatus &= ~(SERIAL_MSR_RI);		// RI always off
 	ModemStatus &= ~(SERIAL_MSR_DDSR | SERIAL_MSR_TERI);
    }
#endif
    
    // If we are placing the modem status into the data stream
    // on every change, we should do it now.

    if (Extension->EscapeChar) {
        if (ModemStatus & (SERIAL_MSR_DCTS |
                           SERIAL_MSR_DDSR |
                           SERIAL_MSR_TERI |
                           SERIAL_MSR_DDCD)) {
            CyyPutChar(Extension,Extension->EscapeChar);
            CyyPutChar(Extension,SERIAL_LSRMST_MST);
            CyyPutChar(Extension,ModemStatus);
        }
    }

    // Take care of input flow control based on sensitivity
    // to the DSR.  This is done so that the application won't
    // see spurious data generated by odd devices.
    //
    // Basically, if we are doing dsr sensitivity then the
    // driver should only accept data when the dsr bit is set.

    if (Extension->HandFlow.ControlHandShake & SERIAL_DSR_SENSITIVITY) {
        if (ModemStatus & SERIAL_MSR_DSR) {
            Extension->RXHolding &= ~CYY_RX_DSR;
        } else {
            Extension->RXHolding |= CYY_RX_DSR;
        }
    } else {
        Extension->RXHolding &= ~CYY_RX_DSR;
    }

    // Check to see if we have a wait pending on the modem status events.
    // If we do then we schedule a dpc to satisfy that wait.

    if (Extension->IsrWaitMask) {
        if((Extension->IsrWaitMask&SERIAL_EV_CTS)&&(ModemStatus&SERIAL_MSR_DCTS)) {
            Extension->HistoryMask |= SERIAL_EV_CTS;
        }
        if((Extension->IsrWaitMask&SERIAL_EV_DSR)&&(ModemStatus&SERIAL_MSR_DDSR)) {
            Extension->HistoryMask |= SERIAL_EV_DSR;
        }
        if((Extension->IsrWaitMask&SERIAL_EV_RING)&&(ModemStatus&SERIAL_MSR_TERI)) {
            Extension->HistoryMask |= SERIAL_EV_RING;
        }
        if((Extension->IsrWaitMask&SERIAL_EV_RLSD)&&(ModemStatus&SERIAL_MSR_DDCD)) {
            Extension->HistoryMask |= SERIAL_EV_RLSD;
        }
        if(Extension->IrpMaskLocation && Extension->HistoryMask) {
            *Extension->IrpMaskLocation = Extension->HistoryMask;
            Extension->IrpMaskLocation = NULL;
            Extension->HistoryMask = 0;
            Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
            CyyInsertQueueDpc(&Extension->CommWaitDpc,NULL,NULL,Extension);
        }
    }

    // If the app has modem line flow control then
    // we check to see if we have to hold up transmission.

    if (Extension->HandFlow.ControlHandShake & SERIAL_OUT_HANDSHAKEMASK) {
        if (Extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE) {
            if (ModemStatus & SERIAL_MSR_CTS) {
                Extension->TXHolding &= ~CYY_TX_CTS;
            } else {
                Extension->TXHolding |= CYY_TX_CTS;
            }
        } else {
            Extension->TXHolding &= ~CYY_TX_CTS;
        }
        if (Extension->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE) {
            if (ModemStatus & SERIAL_MSR_DSR) {
                Extension->TXHolding &= ~CYY_TX_DSR;
            } else {
                Extension->TXHolding |= CYY_TX_DSR;
            }
        } else {
            Extension->TXHolding &= ~CYY_TX_DSR;
        }
        if (Extension->HandFlow.ControlHandShake & SERIAL_DCD_HANDSHAKE) {
            if (ModemStatus & SERIAL_MSR_DCD) {
                Extension->TXHolding &= ~CYY_TX_DCD;
            } else {
                Extension->TXHolding |= CYY_TX_DCD;
            }
        } else {
            Extension->TXHolding &= ~CYY_TX_DCD;
        }

        // If we hadn't been holding, and now we are then
        // queue off a dpc that will lower the RTS line
        // if we are doing transmit toggling.

        if (!OldTXHolding && Extension->TXHolding  &&
            ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
              SERIAL_TRANSMIT_TOGGLE)) {

            CyyInsertQueueDpc(
                &Extension->StartTimerLowerRTSDpc,
                NULL,
                NULL,
                Extension
                )?Extension->CountOfTryingToLowerRTS++:0;
        }

        // We've done any adjusting that needed to be
        // done to the holding mask given updates
        // to the modem status.  If the Holding mask
        // is clear (and it wasn't clear to start)
        // and we have "write" work to do set things
        // up so that the transmission code gets invoked.

        if (!DoingTX && OldTXHolding && !Extension->TXHolding) {
            if (!Extension->TXHolding &&
                (Extension->TransmitImmediate ||
                 Extension->WriteLength) &&
                 Extension->HoldingEmpty) {
		
                CyyTxStart(Extension);
            }
        }
    } else {
        // We need to check if transmission is holding
        // up because of modem status lines.  What
        // could have occured is that for some strange
        // reason, the app has asked that we no longer
        // stop doing output flow control based on
        // the modem status lines.  If however, we
        // *had* been held up because of the status lines
        // then we need to clear up those reasons.

        if (Extension->TXHolding & (CYY_TX_DCD | CYY_TX_DSR | CYY_TX_CTS)) {
            Extension->TXHolding &= ~(CYY_TX_DCD | CYY_TX_DSR | CYY_TX_CTS);

            if (!DoingTX && OldTXHolding && !Extension->TXHolding) {
                if (!Extension->TXHolding &&
                    (Extension->TransmitImmediate ||
                     Extension->WriteLength) &&
                     Extension->HoldingEmpty) {

                    CyyTxStart(Extension);
                }
            }
        }
    }
    return ((ULONG)ModemStatus);
}

BOOLEAN
CyyPerhapsLowerRTS(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyyPerhapsLowerRTS()
    
    Routine Description: This routine checks that the software reasons for
    lowering the RTS lines are present.  If so, it will then cause the
    line status register to be read (and any needed processing
    implied by the status register to be done), and if the shift register
    is empty it will lower the line.  If the shift register isn't empty,
    this routine will queue off a dpc that will start a timer, that will
    basically call us back to try again.
    NOTE: This routine assumes that it is called at interrupt level.

    Arguments:

    Context - pointer to the device extension.

    Return Value: Always FALSE.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = Context;

    // We first need to test if we are actually still doing
    // transmit toggle flow control.  If we aren't then
    // we have no reason to try be here.

    if ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
					        SERIAL_TRANSMIT_TOGGLE) {
        // The order of the tests is very important below.
        // If there is a break then we should leave on the RTS,
        // because when the break is turned off, it will submit
        // the code to shut down the RTS.
        // If there are writes pending that aren't being held
        // up, then leave on the RTS, because the end of the write
        // code will cause this code to be reinvoked.  If the writes
        // are being held up, its ok to lower the RTS because the
        // upon trying to write the first character after transmission
        // is restarted, we will raise the RTS line.

        if ((Extension->TXHolding & CYY_TX_BREAK) ||
            (Extension->CurrentWriteIrp || Extension->TransmitImmediate ||
             (!IsListEmpty(&Extension->WriteQueue)) &&
             (!Extension->TXHolding))) {

            NOTHING;
        } else {
            // Looks good so far.  Call the line status check and processing
            // code, it will return the "current" line status value.  If
            // the holding and shift register are clear, lower the RTS line,
            // if they aren't clear, queue of a dpc that will cause a timer
            // to reinvoke us later.  We do this code here because no one
            // but this routine cares about the characters in the hardware,
            // so no routine by this routine will bother invoking to test
            // if the hardware is empty.
#if 0
            if ((CyyProcessLSR(Extension) & (CYY_LSR_THRE | CYY_LSR_TEMT)) !=
                 			(CYY_LSR_THRE | CYY_LSR_TEMT)) {
                // Well it's not empty, try again later.
                CyyInsertQueueDpc(
                    &Extension->StartTimerLowerRTSDpc,
                    NULL,
                    NULL,
                    Extension
                    )?Extension->CountOfTryingToLowerRTS++:0;
            } else {
                // Nothing in the hardware, Lower the RTS.
                CyyClrRTS(Extension);
            }
#endif
            CyyClrRTS(Extension);
            //remove later
        }
    }
    
    // We decement the counter to indicate that we've reached
    // the end of the execution path that is trying to push
    // down the RTS line.

    Extension->CountOfTryingToLowerRTS--;
    return FALSE;
}

VOID
CyyStartTimerLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
/*--------------------------------------------------------------------------
    CyyStartTimerLowerRTS()
    
    Routine Description: This routine starts a timer that when it expires
    will start a dpc that will check if it can lower the rts line because
    there are no characters in the hardware.

    Arguments:

    Dpc - Not Used.
    DeferredContext - points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.

    Return Value: None.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = DeferredContext;
    LARGE_INTEGER CharTime;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);


    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyStartTimerLowerRTS(%X)\n",
                  Extension);


    // Take out the lock to prevent the line control
    // from changing out from under us while we calculate
    // a character time.
    KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);
    CharTime = CyyGetCharTime(Extension);
    KeReleaseSpinLock(&Extension->ControlLock,OldIrql);

    CharTime.QuadPart = -CharTime.QuadPart;

    if (CyySetTimer(
            &Extension->LowerRTSTimer,
            CharTime,
            &Extension->PerhapsLowerRTSDpc,
            Extension
            )) {

        // The timer was already in the timer queue.  This implies
        // that one path of execution that was trying to lower
        // the RTS has "died".  Synchronize with the ISR so that
        // we can lower the count.

#if 0
        KeSynchronizeExecution(
            Extension->Interrupt,
            CyyDecrementRTSCounter,
            Extension
            );
#endif
        CyyDecrementRTSCounter(Extension);
        //remove later
    }

    CyyDpcEpilogue(Extension, Dpc);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyStartTimerLowerRTS\n");

}

VOID
CyyInvokePerhapsLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
/*--------------------------------------------------------------------------
    CyyInvokePerhapsLowerRTS()
    
    Routine Description: This dpc routine exists solely to call the code
    that tests if the rts line should be lowered when TRANSMIT TOGGLE
    flow control is being used.

    Arguments:

    Dpc - Not Used.
    DeferredContext - points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.

    Return Value: None.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = DeferredContext;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

#if 0
    KeSynchronizeExecution(
        Extension->Interrupt,
        CyyPerhapsLowerRTS,
        Extension
        );
#endif
//remove later
    CyyPerhapsLowerRTS(Extension);

    CyyDpcEpilogue(Extension, Dpc);

}

BOOLEAN
CyyDecrementRTSCounter(
    IN PVOID Context
    )
/*--------------------------------------------------------------------------
    CyyDecrementRTSCounter()
    
    Routine Description: This routine checks that the software reasons for
    lowering the RTS lines are present.  If so, it will then cause the
    line status register to be read (and any needed processing implied by
    the status register to be done), and if the shift register is empty it
    will lower the line.  If the shift register isn't empty, this routine
    will queue off a dpc that will start a timer, that will basically call
    us back to try again.
    NOTE: This routine assumes that it is called at interrupt level.

    Arguments:

    Context - pointer to the device extension.

    Return Value: Always FALSE.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION Extension = Context;

    Extension->CountOfTryingToLowerRTS--;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyypnp.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyypnp.c
*	
*   Description:    This module contains the code that handles the 
*                   plug and play IRPs for the Cyclom-Y Port driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "precomp.h"


#define ALLF    0xffffffff

static const PHYSICAL_ADDRESS CyyPhysicalZero = {0};



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESRP0, CyyCreateDevObj)
#pragma alloc_text(PAGESRP0, CyyAddDevice)
#pragma alloc_text(PAGESRP0, CyyPnpDispatch)
#pragma alloc_text(PAGESRP0, CyyStartDevice)
// REMOVED FANNY #pragma alloc_text(PAGESRP0, CyyFinishStartDevice)
// REMOVED FANNY #pragma alloc_text(PAGESRP0, CyyGetPortInfo)
#pragma alloc_text(PAGESRP0, CyyDoExternalNaming)
#pragma alloc_text(PAGESRP0, CyyReportMaxBaudRate)
// REMOVED FANNY. NOT CALLED.#pragma alloc_text(PAGESRP0, CyyControllerCallBack)
// REMOVED FANNY #pragma alloc_text(PAGESRP0, CyyItemCallBack)
#pragma alloc_text(PAGESRP0, CyyUndoExternalNaming)
#endif // ALLOC_PRAGMA

//
// Instantiate the GUID
//

#if !defined(FAR)
#define FAR
#endif // !defined(FAR)

#include <initguid.h>

DEFINE_GUID(GUID_CLASS_COMPORT, 0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08,
            0x00, 0x3e, 0x30, 0x1f, 0x73);


#if DBG

UCHAR *CyySystemCapString[] = {
   "PowerSystemUnspecified",
   "PowerSystemWorking",
   "PowerSystemSleeping1",
   "PowerSystemSleeping2",
   "PowerSystemSleeping3",
   "PowerSystemHibernate",
   "PowerSystemShutdown",
   "PowerSystemMaximum"
};

UCHAR *CyyDeviceCapString[] = {
   "PowerDeviceUnspecified",
   "PowerDeviceD0",
   "PowerDeviceD1",
   "PowerDeviceD2",
   "PowerDeviceD3",
   "PowerDeviceMaximum"
};

#endif // DBG


NTSTATUS
CyySyncCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                  IN PKEVENT CyySyncEvent)
{
   KeSetEvent(CyySyncEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}

#if 0
ULONG 
myatoi(PWCHAR pszInt)
{
    int   retval;
    TCHAR cSave;

    for (retval = 0; *pszInt; ++pszInt) {
        if ((cSave = (TCHAR) (*pszInt - TEXT('0'))) > (TCHAR) 9)
            break;

        retval = (int) (retval * 10 + (int) cSave);
    }
    return (retval);
}
#endif

ULONG 
CyyCompareString(PWCHAR PString1, PWCHAR PString2, ULONG Count)
{
    do {
        if (*PString1 || *PString2) {
            if (*PString1 != *PString2) {
                break;
            }
            PString1++;
            PString2++;
            Count--;
        } else {
            break;
        }
    } while (Count);
    return (Count);
}


NTSTATUS
CyyCreateDevObj(IN PDRIVER_OBJECT DriverObject,
                IN PDEVICE_OBJECT PPdo,
                OUT PDEVICE_OBJECT *NewDeviceObject)

/*++

Routine Description:

    This routine will create and initialize a functional device object to
    be attached to a Cyclom-Y controller PDO.

Arguments:

    DriverObject - a pointer to the driver object this is created under
    NewDeviceObject - a location to store the pointer to the new device object

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{
   UNICODE_STRING deviceObjName;
   PDEVICE_OBJECT deviceObject = NULL;
   PCYY_DEVICE_EXTENSION pDevExt;
   NTSTATUS status = STATUS_SUCCESS;
   static ULONG currentInstance = 0;
   UNICODE_STRING instanceStr;
   WCHAR instanceNumberBuffer[20];
   ULONG busNumber = 0xFFFFFFFF;
   ULONG resultLength;
   WCHAR hwID[100];
   PWCHAR portNumberPtr;
   INTERFACE_TYPE interfaceType;
   ULONG numberToAppend;
   //ULONG portNumber;


   PAGED_CODE();

   CyyDbgPrintEx(CYYTRACECALLS, "Enter CyyCreateDevObj\n");

   // Find out if parent board is ISA or PCI

   status = IoGetDeviceProperty (PPdo,
                                 DevicePropertyLegacyBusType,
                                 sizeof(interfaceType),
                                 &interfaceType,
                                 &resultLength);

   if (!NT_SUCCESS (status)) {

      CyyLogError( DriverObject,NULL,CyyPhysicalZero,CyyPhysicalZero,0,0,0,0,
                   status,CYY_UNABLE_TO_GET_BUS_TYPE,0,NULL,0,NULL);

      CyyDbgPrintEx(CYYERRORS,"CyyCreateDevObj: IoGetDeviceProperty LegacyBusType "
                    "failed (%x)\n",status);

      return status;
   }

   if (interfaceType == PCIBus) {

      // Get PCI slot number and port number to generate device name.

      status = IoGetDeviceProperty (PPdo,
                                    DevicePropertyBusNumber,
                                    sizeof(busNumber),
                                    &busNumber,
                                    &resultLength);

      if (!NT_SUCCESS (status)) {
         busNumber = 0xFFFFFFFF; // Just to make sure set it again
         //CyyLogError( DriverObject,NULL,CyyPhysicalZero,CyyPhysicalZero,0,0,0,0,
         //             status,CYY_UNABLE_TO_GET_BUS_NUMBER,0,NULL,0,NULL);

         CyyDbgPrintEx(CYYERRORS,"CyyCreateDevObj: IoGetDeviceProperty BusNumber "
                       "failed (%x)\n",status);

         goto NoBusNumber;
      }

      status = IoGetDeviceProperty (PPdo,
                                    DevicePropertyHardwareID,
                                    sizeof(hwID),
                                    hwID,
                                    &resultLength);

      if (!NT_SUCCESS (status)) {
         CyyLogError( DriverObject,NULL,CyyPhysicalZero,CyyPhysicalZero,0,0,0,0,
                      status,CYY_UNABLE_TO_GET_HW_ID,0,NULL,0,NULL);

         CyyDbgPrintEx(CYYERRORS,"CyyCreateDevObj: IoGetDeviceProperty HardwareID "
                       "failed (%x)\n",status);


         return status;
      }

      if (CyyCompareString(hwID,CYYPORT_PNP_ID_WSTR,sizeof(CYYPORT_PNP_ID_WSTR)/sizeof(WCHAR)-1)!=0) {

         CyyLogError( DriverObject,NULL,CyyPhysicalZero,CyyPhysicalZero,0,0,0,0,
                      status,CYY_BAD_HW_ID,0,NULL,0,NULL);

         CyyDbgPrintEx(CYYERRORS,"CyyCreateDevObj: Bad HardwareID: %ws\n",hwID);
         
         return STATUS_UNSUCCESSFUL;
      }

      portNumberPtr = hwID+sizeof(CYYPORT_PNP_ID_WSTR)/sizeof(WCHAR)-1;

      //portNumber = myatoi(portNumberPtr);
      //if ((portNumber < 1) || (portNumber > CYY_MAX_PORTS)){
      //
      //   CyyLogError( DriverObject,NULL,CyyPhysicalZero,CyyPhysicalZero,0,0,0,0,
      //                status,CYY_BAD_HW_ID,0,NULL,0,NULL);
      //
      //   CyyDbgPrintEx (CYYERRORS,"CyyCreateDevObj: Bad HardwareID: %ws\n",hwID);
      //   
      //   return STATUS_UNSUCCESSFUL;
      //}

NoBusNumber:;

   }


   //
   // Zero out allocated memory pointers so we know if they must be freed
   //

   RtlZeroMemory(&deviceObjName, sizeof(UNICODE_STRING));

   deviceObjName.MaximumLength = DEVICE_OBJECT_NAME_LENGTH * sizeof(WCHAR);
   deviceObjName.Buffer = ExAllocatePool(PagedPool, deviceObjName.MaximumLength
                                     + sizeof(WCHAR));

//********************************************
// Error Injection
//  if (deviceObjName.Buffer != NULL) {
//      ExFreePool(deviceObjName.Buffer);
//   }
//   deviceObjName.Buffer = NULL;
//********************************************
   if (deviceObjName.Buffer == NULL) {
      CyyLogError(DriverObject, NULL, CyyPhysicalZero, CyyPhysicalZero,
                     0, 0, 0, 11, STATUS_SUCCESS, CYY_INSUFFICIENT_RESOURCES,
                     0, NULL, 0, NULL);
      CyyDbgPrintEx(CYYERRORS,
                    "Couldn't allocate memory for device name\n");

      return STATUS_INSUFFICIENT_RESOURCES; //STATUS_SUCCESS replaced in build 2128

   }

   RtlZeroMemory(deviceObjName.Buffer, deviceObjName.MaximumLength
                 + sizeof(WCHAR));

   RtlAppendUnicodeToString(&deviceObjName, L"\\Device\\");

   if (busNumber == 0xFFFFFFFF) {
      numberToAppend = currentInstance++;
   } else {
      numberToAppend = busNumber;
   }      

   RtlInitUnicodeString(&instanceStr, NULL);
   instanceStr.MaximumLength = sizeof(instanceNumberBuffer);
   instanceStr.Buffer = instanceNumberBuffer;
   RtlIntegerToUnicodeString(numberToAppend, 10, &instanceStr);

   if (busNumber == 0xFFFFFFFF) {
      // The device name is something like \Device\Cyyport1
      RtlAppendUnicodeToString(&deviceObjName, L"CyyPort");
      RtlAppendUnicodeStringToString(&deviceObjName, &instanceStr);
   } else {
      // The device name is something like \Device\Pci5Cyyport1
      RtlAppendUnicodeToString(&deviceObjName, L"Pci");
      RtlAppendUnicodeStringToString(&deviceObjName, &instanceStr);
      RtlAppendUnicodeToString(&deviceObjName, L"CyyPort");
      RtlAppendUnicodeToString(&deviceObjName,portNumberPtr);
   }


   //
   // Create the device object
   //

   status = IoCreateDevice(DriverObject, sizeof(CYY_DEVICE_EXTENSION),
                           &deviceObjName, FILE_DEVICE_SERIAL_PORT, 
                           FILE_DEVICE_SECURE_OPEN, TRUE, &deviceObject);


   if (!NT_SUCCESS(status)) {
      CyyLogError(DriverObject, NULL, CyyPhysicalZero, CyyPhysicalZero,
                  0, 0, 0, 0, STATUS_SUCCESS, CYY_DEVICE_CREATION_FAILURE,
                  0, NULL, 0, NULL);
      CyyDbgPrintEx(CYYERRORS, "CyyAddDevice: Create device failed - %x "
                    "\n", status);
      goto CyyCreateDevObjError;
   }

   ASSERT(deviceObject != NULL);


   //
   // The device object has a pointer to an area of non-paged
   // pool allocated for this device.  This will be the device
   // extension. Zero it out.
   //

   pDevExt = deviceObject->DeviceExtension;
   RtlZeroMemory(pDevExt, sizeof(CYY_DEVICE_EXTENSION));

   //
   // Initialize the count of IRP's pending
   //

   pDevExt->PendingIRPCnt = 1;


   //
   // Initialize the count of DPC's pending
   //

   pDevExt->DpcCount = 1;

   //
   // Allocate Pool and save the nt device name in the device extension.
   //

   pDevExt->DeviceName.Buffer =
      ExAllocatePool(PagedPool, deviceObjName.Length + sizeof(WCHAR));

//******************************************
// Error Injection
//   if (pDevExt->DeviceName.Buffer != NULL) {
//         ExFreePool(pDevExt->DeviceName.Buffer);
//   }
//   pDevExt->DeviceName.Buffer = NULL;
//******************************************
   if (!pDevExt->DeviceName.Buffer) {

      CyyLogError(
                    DriverObject,
                    NULL,
                    CyyPhysicalZero,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    12,
                    STATUS_SUCCESS,
                    CYY_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      CyyDbgPrintEx(CYYERRORS, "Couldn't allocate memory for DeviceName\n");

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyyCreateDevObjError;
   }

   pDevExt->DeviceName.MaximumLength = deviceObjName.Length
      + sizeof(WCHAR);

   //
   // Zero fill it.
   //

   RtlZeroMemory(pDevExt->DeviceName.Buffer,
                 pDevExt->DeviceName.MaximumLength);

   RtlAppendUnicodeStringToString(&pDevExt->DeviceName, &deviceObjName);

   pDevExt->NtNameForPort.Buffer = ExAllocatePool(PagedPool,
                                                  deviceObjName.MaximumLength);

   if (pDevExt->NtNameForPort.Buffer == NULL) {
      CyyLogError(
                    DriverObject,
                    NULL,
                    CyyPhysicalZero,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    13,
                    STATUS_SUCCESS,
                    CYY_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      CyyDbgPrintEx(CYYERRORS, "CyyAddDevice: Cannot allocate memory for "
                    "NtName\n");
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyyCreateDevObjError;
   }

   pDevExt->NtNameForPort.MaximumLength = deviceObjName.MaximumLength;
   RtlAppendUnicodeStringToString(&pDevExt->NtNameForPort,
                                  &deviceObjName);



   //
   // Set up the device extension.
   //

   pDevExt->DeviceIsOpened = FALSE;
   pDevExt->DeviceObject   = deviceObject;
   pDevExt->DriverObject   = DriverObject;
   pDevExt->PowerState     = PowerDeviceD0;

   //TODO FANNY: ADD TxFifoAmount?
   pDevExt->TxFifoAmount           = driverDefaults.TxFIFODefault;
   //pDevExt->CreatedSymbolicLink    = TRUE;  Removed by Fanny
   pDevExt->OwnsPowerPolicy = TRUE;
   if (interfaceType == PCIBus) {

      pDevExt->IsPci = 1;
      pDevExt->PciSlot = busNumber;
   }
   //pDevExt->PortIndex = portNumber-1; 

//TODO FANNY: SEE LATER IF WE NEED THE LISTS TO HANDLE INTERRUPT
//   InitializeListHead(&pDevExt->CommonInterruptObject);
//   InitializeListHead(&pDevExt->TopLevelSharers);
//   InitializeListHead(&pDevExt->MultiportSiblings);
   InitializeListHead(&pDevExt->AllDevObjs);
   InitializeListHead(&pDevExt->ReadQueue);
   InitializeListHead(&pDevExt->WriteQueue);
   InitializeListHead(&pDevExt->MaskQueue);
   InitializeListHead(&pDevExt->PurgeQueue);
   InitializeListHead(&pDevExt->StalledIrpQueue);

   ExInitializeFastMutex(&pDevExt->OpenMutex);
   ExInitializeFastMutex(&pDevExt->CloseMutex);

   //
   // Initialize the spinlock associated with fields read (& set)
   // by IO Control functions and the flags spinlock.
   //

   KeInitializeSpinLock(&pDevExt->ControlLock);
   KeInitializeSpinLock(&pDevExt->FlagsLock);

   KeInitializeEvent(&pDevExt->PendingIRPEvent, SynchronizationEvent, FALSE);
   KeInitializeEvent(&pDevExt->PendingDpcEvent, SynchronizationEvent, FALSE);
   KeInitializeEvent(&pDevExt->PowerD0Event, SynchronizationEvent, FALSE);


   deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

   *NewDeviceObject = deviceObject;

   ExFreePool(deviceObjName.Buffer);

   CyyDbgPrintEx(CYYTRACECALLS, "Leave CyyCreateDevObj\n");
   return STATUS_SUCCESS;


   CyyCreateDevObjError:

   CyyDbgPrintEx(CYYERRORS, "CyyCreateDevObj Error, Cleaning up\n");

   //
   // Free the allocated strings for the NT and symbolic names if they exist.
   //

   if (deviceObjName.Buffer != NULL) {
      ExFreePool(deviceObjName.Buffer);
   }

   if (deviceObject) {

      if (pDevExt->NtNameForPort.Buffer != NULL) {
         ExFreePool(pDevExt->NtNameForPort.Buffer);
      }

      if (pDevExt->DeviceName.Buffer != NULL) {
         ExFreePool(pDevExt->DeviceName.Buffer);
      }

      IoDeleteDevice(deviceObject);
   }

   *NewDeviceObject = NULL;

   CyyDbgPrintEx(CYYTRACECALLS, "Leave CyyCreateDevObj\n");
   return status;
}


NTSTATUS
CyyAddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT PPdo)

/*++

Routine Description:

    This routine creates a functional device object for com ports in the
    system and attaches them to the physical device objects for the ports


Arguments:

    DriverObject - a pointer to the object for this driver

    PPdo - a pointer to the PDO in the stack we need to attach to

Return Value:

    status from device creation and initialization

--*/

{
   PDEVICE_OBJECT pNewDevObj = NULL;
   PDEVICE_OBJECT pLowerDevObj = NULL;
   NTSTATUS status;
   PCYY_DEVICE_EXTENSION pDevExt;

   PAGED_CODE();

   CyyDbgPrintEx(CYYTRACECALLS, "Enter CyyAddDevice with PPdo 0x%x\n",
                 PPdo);

   if (PPdo == NULL) {
      //
      // Return no more devices
      //
      CyyLogError(DriverObject, NULL, CyyPhysicalZero, CyyPhysicalZero,
                  0, 0, 0, 0, STATUS_SUCCESS, CYY_NO_PHYSICAL_DEVICE_OBJECT,
                  0, NULL, 0, NULL);
      CyyDbgPrintEx(CYYERRORS, "CyyAddDevice: Enumeration request, "
                    "returning NO_MORE_ENTRIES\n");

      return (STATUS_NO_MORE_ENTRIES);
   }

   //
   // create and initialize the new device object
   //

   status = CyyCreateDevObj(DriverObject, PPdo, &pNewDevObj);

   if (!NT_SUCCESS(status)) {

      CyyDbgPrintEx(CYYERRORS,
                    "CyyAddDevice - error creating new devobj [%#08lx]\n",
                    status);
      return status;
   }


   //
   // Layer our DO on top of the lower device object
   // The return value is a pointer to the device object to which the
   // DO is actually attached.
   //

   pLowerDevObj = IoAttachDeviceToDeviceStack(pNewDevObj, PPdo);


   //
   // No status. Do the best we can.
   //
   ASSERT(pLowerDevObj != NULL);


   pDevExt = pNewDevObj->DeviceExtension;
   pDevExt->LowerDeviceObject = pLowerDevObj;
   pDevExt->Pdo = PPdo;


   //
   // Specify that this driver only supports buffered IO.  This basically
   // means that the IO system copies the users data to and from
   // system supplied buffers.
   //
   // Also specify that we are power pagable.
   //

   pNewDevObj->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;

   CyyDbgPrintEx(CYYTRACECALLS, "Leave CyyAddDevice\n");

   return status;
}


NTSTATUS
CyyPnpDispatch(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)

/*++

Routine Description:

    This is a dispatch routine for the IRPs that come to the driver with the
    IRP_MJ_PNP major code (plug-and-play IRPs).

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/

{
   PCYY_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   NTSTATUS status;
   PDEVICE_CAPABILITIES pDevCaps;

   PAGED_CODE();

   if ((status = CyyIRPPrologue(PIrp, pDevExt)) != STATUS_SUCCESS) {
      CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
      return status;
   }

   switch (pIrpStack->MinorFunction) {
   case IRP_MN_QUERY_CAPABILITIES: {
      PKEVENT pQueryCapsEvent;
      SYSTEM_POWER_STATE cap;

      CyyDbgPrintEx(CYYPNPPOWER,
                    "Got IRP_MN_QUERY_DEVICE_CAPABILITIES IRP\n");

      pQueryCapsEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT));

      if (pQueryCapsEvent == NULL) {
         PIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
         CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      KeInitializeEvent(pQueryCapsEvent, SynchronizationEvent, FALSE);

      IoCopyCurrentIrpStackLocationToNext(PIrp);
      IoSetCompletionRoutine(PIrp, CyySyncCompletion, pQueryCapsEvent,
                             TRUE, TRUE, TRUE);

      status = IoCallDriver(pLowerDevObj, PIrp);


      //
      // Wait for lower drivers to be done with the Irp
      //

      if (status == STATUS_PENDING) {
         KeWaitForSingleObject(pQueryCapsEvent, Executive, KernelMode, FALSE,
                               NULL);
      }

      ExFreePool(pQueryCapsEvent);

      status = PIrp->IoStatus.Status;

      if (pIrpStack->Parameters.DeviceCapabilities.Capabilities == NULL) {
         goto errQueryCaps;
      }

      //
      // Save off their power capabilities
      //

      CyyDbgPrintEx(CYYPNPPOWER, "Mapping power capabilities\n");

      pIrpStack = IoGetCurrentIrpStackLocation(PIrp);

      pDevCaps = pIrpStack->Parameters.DeviceCapabilities.Capabilities;

      for (cap = PowerSystemSleeping1; cap < PowerSystemMaximum;
           cap++) {
#if DBG
         CyyDbgPrintEx(CYYPNPPOWER, "  %d: %s <--> %s\n",
                       cap, CyySystemCapString[cap],
                       CyyDeviceCapString[pDevCaps->DeviceState[cap]]);
#endif

         pDevExt->DeviceStateMap[cap] = pDevCaps->DeviceState[cap];
      }

      pDevExt->DeviceStateMap[PowerSystemUnspecified]
         = PowerDeviceUnspecified;

      pDevExt->DeviceStateMap[PowerSystemWorking]
        = PowerDeviceD0;

      pDevExt->SystemWake = pDevCaps->SystemWake;
      pDevExt->DeviceWake = pDevCaps->DeviceWake;

      errQueryCaps:;

      CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
      return status;
   }

   case IRP_MN_QUERY_DEVICE_RELATIONS:
      //
      // We just pass this down -- serenum enumerates our bus for us.
      //

      CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_QUERY_DEVICE_RELATIONS Irp\n");

      switch (pIrpStack->Parameters.QueryDeviceRelations.Type) {
      case BusRelations:
         CyyDbgPrintEx(CYYPNPPOWER, "------- BusRelations Query\n");
         break;

      case EjectionRelations:
         CyyDbgPrintEx(CYYPNPPOWER, "------- EjectionRelations Query\n");
         break;

      case PowerRelations:
         CyyDbgPrintEx(CYYPNPPOWER, "------- PowerRelations Query\n");
         break;

      case RemovalRelations:
         CyyDbgPrintEx(CYYPNPPOWER, "------- RemovalRelations Query\n");
         break;

      case TargetDeviceRelation:
         CyyDbgPrintEx(CYYPNPPOWER, "------- TargetDeviceRelation Query\n");
         break;

      default:
         CyyDbgPrintEx(CYYPNPPOWER, "------- Unknown Query\n");
         break;
      }

      IoSkipCurrentIrpStackLocation(PIrp);
      status = CyyIoCallDriver(pDevExt, pLowerDevObj, PIrp);
      return status;


   case IRP_MN_QUERY_INTERFACE:
      CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_QUERY_INTERFACE Irp\n");
      break;


   case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
      CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_QUERY_RESOURCE_REQUIREMENTS Irp"
                    "\n");
      break;


   case IRP_MN_START_DEVICE: {
      PVOID startLockPtr;

      CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_START_DEVICE Irp\n");

      //
      // CyyStartDevice will pass this Irp to the next driver,
      // and process it as completion so just complete it here.
      //

      CyyLockPagableSectionByHandle(CyyGlobals.PAGESER_Handle);

      //
      // We used to make sure the stack was powered up, but now it
      // is supposed to be done implicitly by start_device.
      // If that wasn't the case we would just make this call:
      //
      status = CyyGotoPowerState(PDevObj, pDevExt, PowerDeviceD0);
      

      //pDevExt->PowerState = PowerDeviceD0;

      status = CyyStartDevice(PDevObj, PIrp);

      (void)CyyGotoPowerState(PDevObj, pDevExt, PowerDeviceD3);
      
      CyyUnlockPagableImageSection(CyyGlobals.PAGESER_Handle);


      PIrp->IoStatus.Status = status;

      CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
      return status;
   }


   case IRP_MN_READ_CONFIG:
      CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_READ_CONFIG Irp\n");
      break;


   case IRP_MN_WRITE_CONFIG:
      CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_WRITE_CONFIG Irp\n");
      break;


   case IRP_MN_EJECT:
      CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_EJECT Irp\n");
      break;


   case IRP_MN_SET_LOCK:
      CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_SET_LOCK Irp\n");
      break;


   case IRP_MN_QUERY_ID: {
         UNICODE_STRING pIdBuf;
         PWCHAR pPnpIdStr;
         ULONG pnpIdStrLen;
         ULONG portIndex = 0;
         HANDLE pnpKey;
         WCHAR WideString[MAX_DEVICE_ID_LEN];

         CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_QUERY_ID Irp\n");

         // change from build 1946 to 2000.
         if (pIrpStack->Parameters.QueryId.IdType != BusQueryHardwareIDs
             && pIrpStack->Parameters.QueryId.IdType != BusQueryCompatibleIDs) {
            IoSkipCurrentIrpStackLocation(PIrp);
            return CyyIoCallDriver(pDevExt, pLowerDevObj, PIrp);
         }

         if (pIrpStack->Parameters.QueryId.IdType == BusQueryCompatibleIDs) {
            PIrp->IoStatus.Status = STATUS_SUCCESS;
            IoSkipCurrentIrpStackLocation(PIrp);
            return CyyIoCallDriver(pDevExt, pLowerDevObj, PIrp);
         }

         status = IoOpenDeviceRegistryKey(pDevExt->Pdo, PLUGPLAY_REGKEY_DEVICE,
                                          STANDARD_RIGHTS_WRITE, &pnpKey);

         if (!NT_SUCCESS(status)) {
            PIrp->IoStatus.Status = status;

            CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return status;

         }

         status = CyyGetRegistryKeyValue (pnpKey, L"PortIndex",
                                             sizeof(L"PortIndex"),
                                             &portIndex,
                                             sizeof (ULONG));

         ZwClose(pnpKey);

         if (!NT_SUCCESS(status)) {
            PIrp->IoStatus.Status = status;
            CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return status;
         }

//         pPnpIdStr = isMulti ? SERIAL_PNP_MULTI_ID_STR : SERIAL_PNP_ID_STR;
//         pnpIdStrLen = isMulti ? sizeof(SERIAL_PNP_MULTI_ID_STR)
//            : sizeof(SERIAL_PNP_ID_STR);


         pnpIdStrLen = swprintf(WideString,L"%s%u",CYYPORT_PNP_ID_WSTR,portIndex+1);
         pnpIdStrLen = pnpIdStrLen * sizeof(WCHAR) + sizeof(UNICODE_NULL); 
         pPnpIdStr = WideString;

         if (PIrp->IoStatus.Information != 0) {
            ULONG curStrLen;
            ULONG allocLen = 0;
            PWSTR curStr = (PWSTR)PIrp->IoStatus.Information;

            //
            // We have to walk the strings to count the amount of space to
            // reallocate
            //

            while ((curStrLen = wcslen(curStr)) != 0) {
               allocLen += curStrLen * sizeof(WCHAR) + sizeof(UNICODE_NULL);
               curStr += curStrLen + 1;
            }

            allocLen += sizeof(UNICODE_NULL);

            pIdBuf.Buffer = ExAllocatePool(PagedPool, allocLen
                                           + pnpIdStrLen
                                           + sizeof(WCHAR));

            if (pIdBuf.Buffer == NULL) {
               //
               // Clean up after other drivers since we are
               // sending the irp back up.
               //

               ExFreePool((PWSTR)PIrp->IoStatus.Information);


               PIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
               PIrp->IoStatus.Information = 0;
               CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
               return STATUS_INSUFFICIENT_RESOURCES;
            }

            pIdBuf.MaximumLength = (USHORT)(allocLen + pnpIdStrLen);
            pIdBuf.Length = (USHORT)allocLen - sizeof(UNICODE_NULL);

            RtlZeroMemory(pIdBuf.Buffer, pIdBuf.MaximumLength + sizeof(WCHAR));
            RtlCopyMemory(pIdBuf.Buffer, (PWSTR)PIrp->IoStatus.Information,
                          allocLen);
            RtlAppendUnicodeToString(&pIdBuf, pPnpIdStr);

            //
            // Free what the previous driver allocated
            //

            ExFreePool((PWSTR)PIrp->IoStatus.Information);


         } else {

            CyyDbgPrintEx(CYYPNPPOWER, "ID is sole ID\n");

            pIdBuf.Buffer = ExAllocatePool(PagedPool, pnpIdStrLen
                                           + sizeof(WCHAR) * 2);

            if (pIdBuf.Buffer == NULL) {
               PIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
               PIrp->IoStatus.Information = 0;
               CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
               return STATUS_INSUFFICIENT_RESOURCES;
            }

            pIdBuf.MaximumLength  = (USHORT)pnpIdStrLen;
            pIdBuf.Length = 0;

            RtlZeroMemory(pIdBuf.Buffer, pIdBuf.MaximumLength + sizeof(WCHAR)
                          * 2);

            RtlAppendUnicodeToString(&pIdBuf, pPnpIdStr);
         }

         PIrp->IoStatus.Information = (ULONG_PTR)pIdBuf.Buffer;
         PIrp->IoStatus.Status = STATUS_SUCCESS;

         IoCopyCurrentIrpStackLocationToNext(PIrp);
         return CyyIoCallDriver(pDevExt, pLowerDevObj, PIrp);
      }

      case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: {
         HANDLE pnpKey;
         PKEVENT pResFiltEvent;
         ULONG isMulti = 0;
         PIO_RESOURCE_REQUIREMENTS_LIST pReqList;
         PIO_RESOURCE_LIST pResList;
         PIO_RESOURCE_DESCRIPTOR pResDesc;
         ULONG i, j;
         ULONG reqCnt;
         ULONG gotRuntime;
         ULONG gotMemory;
         ULONG gotInt;
         ULONG listNum;

         CyyDbgPrintEx(CYYPNPPOWER, "Got "
                       "IRP_MN_FILTER_RESOURCE_REQUIREMENTS Irp\n");
         CyyDbgPrintEx(CYYPNPPOWER, "for device %x\n", pLowerDevObj);


         pResFiltEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT));

         if (pResFiltEvent == NULL) {
            PIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return STATUS_INSUFFICIENT_RESOURCES;
         }

         KeInitializeEvent(pResFiltEvent, SynchronizationEvent, FALSE);

         IoCopyCurrentIrpStackLocationToNext(PIrp);
         IoSetCompletionRoutine(PIrp, CyySyncCompletion, pResFiltEvent,
                                TRUE, TRUE, TRUE);

         status = IoCallDriver(pLowerDevObj, PIrp);


         //
         // Wait for lower drivers to be done with the Irp
         //

         if (status == STATUS_PENDING) {
            KeWaitForSingleObject (pResFiltEvent, Executive, KernelMode, FALSE,
                                   NULL);
         }

         ExFreePool(pResFiltEvent);

         if (PIrp->IoStatus.Information == 0) {
            if (pIrpStack->Parameters.FilterResourceRequirements
                .IoResourceRequirementList == 0) {
               CyyDbgPrintEx(CYYPNPPOWER, "Can't filter NULL resources!\n");
               status = PIrp->IoStatus.Status;
               CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
               return status;
            }

            PIrp->IoStatus.Information = (ULONG_PTR)pIrpStack->Parameters
                                        .FilterResourceRequirements
                                        .IoResourceRequirementList;

         }

// REMOVED FANNY
//         status = IoOpenDeviceRegistryKey(pDevExt->Pdo, PLUGPLAY_REGKEY_DEVICE,
//                                          STANDARD_RIGHTS_WRITE, &pnpKey);
//
//         if (!NT_SUCCESS(status)) {
//            PIrp->IoStatus.Status = status;
//
//            CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
//            return status;
//
//         }
//
//         //
//         // No matter what we add our filter if we can and return success.
//         //
//
//         status = CyyGetRegistryKeyValue (pnpKey, L"MultiportDevice",
//                                             sizeof(L"MultiportDevice"),
//                                             &isMulti,
//                                             sizeof (ULONG));
//
//         ZwClose(pnpKey);

         //
         // Force ISR ports in IO_RES_REQ_LIST to shared status
         // Force interrupts to shared status
         //

         //
         // We will only process the first list -- multiport boards
         // should not have alternative resources
         //

         pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)PIrp->IoStatus.Information;
         pResList = &pReqList->List[0];

         CyyDbgPrintEx(CYYPNPPOWER, "List has %x lists (including "
                       "alternatives)\n", pReqList->AlternativeLists);

         for (listNum = 0; listNum < (pReqList->AlternativeLists);
              listNum++) {
            gotRuntime = 0;
            gotMemory = 0;
            gotInt = 0;

            CyyDbgPrintEx(CYYPNPPOWER, "List has %x resources in it\n",
                          pResList->Count);

            for (j = 0; (j < pResList->Count); j++) {
               pResDesc = &pResList->Descriptors[j];

               switch (pResDesc->Type) {
               case CmResourceTypeMemory:
                  if (pResDesc->u.Memory.Length == CYY_RUNTIME_LENGTH) {
                      gotRuntime = 1;
                      pResDesc->ShareDisposition = CmResourceShareShared; 
                      //TODO FANNY: Which should be the ShareDisposition for Y?
                      //pResDesc->ShareDisposition = CmResourceShareDriverExclusive; 
                      CyyDbgPrintEx(CYYPNPPOWER, "Sharing Runtime Memory for "
                                    "device %x\n", pLowerDevObj);
                  } else {
                      gotMemory = 1;
                      pResDesc->ShareDisposition = CmResourceShareShared; 
                      //TODO FANNY: Which should be the ShareDisposition for Y?
                      //pResDesc->ShareDisposition = CmResourceShareDriverExclusive; 
                      CyyDbgPrintEx(CYYPNPPOWER, "Sharing Board Memory for "
                                    "device %x\n", pLowerDevObj);
                  }
                  break;

               case CmResourceTypePort:
                  CyyDbgPrintEx(CYYPNPPOWER, "------- We should not have Port resource\n");
                  break;

               case CmResourceTypeInterrupt:
                  gotInt = 1;
                  if (pDevExt->IsPci) {
                      pResDesc->ShareDisposition = CmResourceShareShared;
                      CyyDbgPrintEx(CYYPNPPOWER, "------- Sharing interrupt "
                                    "for device %x\n",
                                    pLowerDevObj);                  
                  }
                  break;

               default:
                  break;
               }

               //
               // If we found what we need, we can break out of the loop
               //

               if (gotRuntime && gotMemory && gotInt) {
                  break;
               }
            }

            pResList = (PIO_RESOURCE_LIST)((PUCHAR)pResList
                                           + sizeof(IO_RESOURCE_LIST)
                                           + sizeof(IO_RESOURCE_DESCRIPTOR)
                                           * (pResList->Count - 1));
         }



         PIrp->IoStatus.Status = STATUS_SUCCESS;
         CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
         return STATUS_SUCCESS;
      }

   case IRP_MN_QUERY_PNP_DEVICE_STATE:
      {
         if (pDevExt->Flags & CYY_FLAGS_BROKENHW) {
            (PNP_DEVICE_STATE)PIrp->IoStatus.Information |= PNP_DEVICE_FAILED;

            PIrp->IoStatus.Status = STATUS_SUCCESS;
         }

         IoCopyCurrentIrpStackLocationToNext(PIrp);
         return CyyIoCallDriver(pDevExt, pLowerDevObj, PIrp);
      }

   case IRP_MN_STOP_DEVICE:
      {
         ULONG pendingIRPs;
         KIRQL oldIrql;

         CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_STOP_DEVICE Irp ");
         CyyDbgPrintEx(CYYPNPPOWER, "for device %x\n", pLowerDevObj);


//REMOVED FANNY FOR NOW
//         ASSERT(!pDevExt->PortOnAMultiportCard);


         CyySetFlags(pDevExt, CYY_FLAGS_STOPPED);
         CyySetAccept(pDevExt,CYY_PNPACCEPT_STOPPED);
         CyyClearAccept(pDevExt, CYY_PNPACCEPT_STOPPING);

         pDevExt->PNPState = CYY_PNP_STOPPING;

         //
         // From this point on all non-PNP IRP's will be queued
         //

         //
         // Decrement for entry here
         //

         InterlockedDecrement(&pDevExt->PendingIRPCnt);

         //
         // Decrement for stopping
         //

         pendingIRPs = InterlockedDecrement(&pDevExt->PendingIRPCnt);

         if (pendingIRPs) {
            KeWaitForSingleObject(&pDevExt->PendingIRPEvent, Executive,
                                  KernelMode, FALSE, NULL);
         }

         //
         // Re-increment the count for later
         //

         InterlockedIncrement(&pDevExt->PendingIRPCnt);

         //
         // We need to free resources...basically this is a remove
         // without the detach from the stack.
         //

         if (pDevExt->Flags & CYY_FLAGS_STARTED) {
            CyyReleaseResources(pDevExt);
         }

         //
         // Pass the irp down
         //

         PIrp->IoStatus.Status = STATUS_SUCCESS;
         IoSkipCurrentIrpStackLocation(PIrp);

         return IoCallDriver(pLowerDevObj, PIrp);
      }

   case IRP_MN_QUERY_STOP_DEVICE:
      {
         KIRQL oldIrql;

         CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_QUERY_STOP_DEVICE Irp ");
         CyyDbgPrintEx(CYYPNPPOWER, "for device %x\n", pLowerDevObj);

         //
         // See if we should succeed a stop query
         //

// REMOVED FANNY FOR NOW
//         if (pDevExt->PortOnAMultiportCard) {
//            PIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
//            CyyDbgPrintEx(CYYPNPPOWER, "------- failing; multiport node\n");
//            CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
//            return STATUS_NOT_SUPPORTED;
//         }

         //
         // If the device hasn't started yet, we ignore this request
         // and just pass it down.
         //

         if (pDevExt->PNPState != CYY_PNP_STARTED) {
            IoSkipCurrentIrpStackLocation(PIrp);
            return CyyIoCallDriver(pDevExt, pLowerDevObj, PIrp);
         }

         //
         // Lock around the open status
         //

         ExAcquireFastMutex(&pDevExt->OpenMutex);

         if (pDevExt->DeviceIsOpened) {
            ExReleaseFastMutex(&pDevExt->OpenMutex);
            PIrp->IoStatus.Status = STATUS_DEVICE_BUSY;
            CyyDbgPrintEx(CYYPNPPOWER, "failing; device open\n");
            CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return STATUS_DEVICE_BUSY;
         }

         pDevExt->PNPState = CYY_PNP_QSTOP;

         CyySetAccept(pDevExt, CYY_PNPACCEPT_STOPPING);
         //
         // Unlock around the open status
         //

         ExReleaseFastMutex(&pDevExt->OpenMutex);

         PIrp->IoStatus.Status = STATUS_SUCCESS;
         IoCopyCurrentIrpStackLocationToNext(PIrp);
         return CyyIoCallDriver(pDevExt, pLowerDevObj, PIrp);
      }

   case IRP_MN_CANCEL_STOP_DEVICE:
      CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_CANCEL_STOP_DEVICE Irp ");
      CyyDbgPrintEx(CYYPNPPOWER, "for device %x\n", pLowerDevObj);

      if (pDevExt->PNPState == CYY_PNP_QSTOP) {
         //
         // Restore the device state
         //

         pDevExt->PNPState = CYY_PNP_STARTED;
         CyyClearAccept(pDevExt, CYY_PNPACCEPT_STOPPING);
      }

      PIrp->IoStatus.Status = STATUS_SUCCESS;
      IoCopyCurrentIrpStackLocationToNext(PIrp);
      return CyyIoCallDriver(pDevExt, pLowerDevObj, PIrp);

   case IRP_MN_CANCEL_REMOVE_DEVICE:

      CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_CANCEL_REMOVE_DEVICE Irp ");
      CyyDbgPrintEx(CYYPNPPOWER, "for device %x\n", pLowerDevObj);

      //
      // Restore the device state
      //

      pDevExt->PNPState = CYY_PNP_STARTED;
      CyyClearAccept(pDevExt, CYY_PNPACCEPT_REMOVING);

      PIrp->IoStatus.Status = STATUS_SUCCESS;
      IoCopyCurrentIrpStackLocationToNext(PIrp);
      return CyyIoCallDriver(pDevExt, pLowerDevObj, PIrp);

   case IRP_MN_QUERY_REMOVE_DEVICE:
      {
         KIRQL oldIrql;
         CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_QUERY_REMOVE_DEVICE Irp ");
         CyyDbgPrintEx(CYYPNPPOWER, "for device %x\n", pLowerDevObj);

         ExAcquireFastMutex(&pDevExt->OpenMutex);

         //
         // See if we should succeed a remove query
         //

         if (pDevExt->DeviceIsOpened) {
            ExReleaseFastMutex(&pDevExt->OpenMutex);
            PIrp->IoStatus.Status = STATUS_DEVICE_BUSY;
            CyyDbgPrintEx(CYYPNPPOWER, "failing; device open\n");
            CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return STATUS_DEVICE_BUSY;
         }

         pDevExt->PNPState = CYY_PNP_QREMOVE;
         CyySetAccept(pDevExt, CYY_PNPACCEPT_REMOVING);
         ExReleaseFastMutex(&pDevExt->OpenMutex);

         PIrp->IoStatus.Status = STATUS_SUCCESS;
         IoCopyCurrentIrpStackLocationToNext(PIrp);
         return CyyIoCallDriver(pDevExt, pLowerDevObj, PIrp);
      }

   case IRP_MN_SURPRISE_REMOVAL:
      {
         ULONG pendingIRPs;
         KIRQL oldIrql;

         CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_SURPRISE_REMOVAL Irp ");
         CyyDbgPrintEx(CYYPNPPOWER, "for device %x\n", pLowerDevObj);

         //
         // Prevent any new I/O to the device
         //

         CyySetAccept(pDevExt, CYY_PNPACCEPT_SURPRISE_REMOVING);

         //
         // Dismiss all pending requests
         //

         CyyKillPendingIrps(PDevObj);

         //
         // Wait for any pending requests we raced on.
         //

         //
         // Decrement once for ourselves
         //

         InterlockedDecrement(&pDevExt->PendingIRPCnt);

         //
         // Decrement for the remove
         //

         pendingIRPs = InterlockedDecrement(&pDevExt->PendingIRPCnt);

         if (pendingIRPs) {
            KeWaitForSingleObject(&pDevExt->PendingIRPEvent, Executive,
                                  KernelMode, FALSE, NULL);
         }

         //
         // Reset for subsequent remove
         //

         InterlockedIncrement(&pDevExt->PendingIRPCnt);

         //
         // Remove any external interfaces and release resources
         //

         CyyDisableInterfacesResources(PDevObj, FALSE);

         PIrp->IoStatus.Status = STATUS_SUCCESS;
         IoSkipCurrentIrpStackLocation(PIrp);

         return CyyIoCallDriver(pDevExt, pLowerDevObj, PIrp);
      }

   case IRP_MN_REMOVE_DEVICE:

      {
         ULONG pendingIRPs;
         KIRQL oldIrql;

         CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_REMOVE_DEVICE Irp ");
         CyyDbgPrintEx(CYYPNPPOWER, "for device %x\n", pLowerDevObj);

         //
         // If we get this, we have to remove
         //

         //
         // Mark as not accepting requests
         //

         CyySetAccept(pDevExt, CYY_PNPACCEPT_REMOVING);

         //
         // Complete all pending requests
         //

         CyyKillPendingIrps(PDevObj);

         //
         // Decrement for this Irp itself
         //

         InterlockedDecrement(&pDevExt->PendingIRPCnt);

         //
         // Wait for any pending requests we raced on -- this decrement
         // is for our "placeholder".
         //

         pendingIRPs = InterlockedDecrement(&pDevExt->PendingIRPCnt);

         if (pendingIRPs) {
            KeWaitForSingleObject(&pDevExt->PendingIRPEvent, Executive,
                                  KernelMode, FALSE, NULL);
         }

         if (!(pDevExt->DevicePNPAccept & CYY_PNPACCEPT_SURPRISE_REMOVING)) { //Moved from CyyRemoveDevice. Fanny
            //
            // Disable all external interfaces and release resources
            //

            CyyDisableInterfacesResources(PDevObj, TRUE);
         }

         //
         // Pass the irp down
         //

         PIrp->IoStatus.Status = STATUS_SUCCESS;

         IoSkipCurrentIrpStackLocation(PIrp); // It was IoCopyCurrentIrpStackLocationToNext (Fanny)

         //
         // We do decrement here because we incremented on entry here.
         //

         status = IoCallDriver(pLowerDevObj, PIrp);


         //
         // Remove us (Note from Fanny: This call is before IoCallDriver in serial driver).
         //

         CyyRemoveDevObj(PDevObj);

         return status;
      }

   default:
      break;



   }   // switch (pIrpStack->MinorFunction)

   //
   // Pass to driver beneath us
   //

   IoSkipCurrentIrpStackLocation(PIrp);
   status = CyyIoCallDriver(pDevExt, pLowerDevObj, PIrp);
   return status;


}


UINT32
CyyReportMaxBaudRate(ULONG Bauds)
/*++

Routine Description:

    This routine returns the max baud rate given a selection of rates

Arguments:

   Bauds  -  Bit-encoded list of supported bauds


  Return Value:

   The max baud rate listed in Bauds

--*/
{
   PAGED_CODE();

   if (Bauds & SERIAL_BAUD_128K) {
      return (128U * 1024U);
   }

   if (Bauds & SERIAL_BAUD_115200) {
      return 115200U;
   }

   if (Bauds & SERIAL_BAUD_56K) {
      return (56U * 1024U);
   }

   if (Bauds & SERIAL_BAUD_57600) {
      return 57600U;
   }

   if (Bauds & SERIAL_BAUD_38400) {
      return 38400U;
   }

   if (Bauds & SERIAL_BAUD_19200) {
      return 19200U;
   }

   if (Bauds & SERIAL_BAUD_14400) {
      return 14400U;
   }

   if (Bauds & SERIAL_BAUD_9600) {
      return 9600U;
   }

   if (Bauds & SERIAL_BAUD_7200) {
      return 7200U;
   }

   if (Bauds & SERIAL_BAUD_4800) {
      return 4800U;
   }

   if (Bauds & SERIAL_BAUD_2400) {
      return 2400U;
   }

   if (Bauds & SERIAL_BAUD_1800) {
      return 1800U;
   }

   if (Bauds & SERIAL_BAUD_1200) {
      return 1200U;
   }

   if (Bauds & SERIAL_BAUD_600) {
      return 600U;
   }

   if (Bauds & SERIAL_BAUD_300) {
      return 300U;
   }

   if (Bauds & SERIAL_BAUD_150) {
      return 150U;
   }

   if (Bauds & SERIAL_BAUD_134_5) {
      return 135U; // Close enough
   }

   if (Bauds & SERIAL_BAUD_110) {
      return 110U;
   }

   if (Bauds & SERIAL_BAUD_075) {
      return 75U;
   }

   //
   // We're in bad shape
   //

   return 0;
}

VOID
CyyAddToAllDevs(PLIST_ENTRY PListEntry)
{
   KIRQL oldIrql;

   KeAcquireSpinLock(&CyyGlobals.GlobalsSpinLock, &oldIrql);

   InsertTailList(&CyyGlobals.AllDevObjs, PListEntry);

   KeReleaseSpinLock(&CyyGlobals.GlobalsSpinLock, oldIrql);
}



NTSTATUS
CyyFinishStartDevice(IN PDEVICE_OBJECT PDevObj,
                     IN PCM_RESOURCE_LIST PResList,
                     IN PCM_RESOURCE_LIST PTrResList)
/*++

Routine Description:

    This routine does serial-specific procedures to start a device.  It
    does this either for a legacy device detected by its registry entries,
    or for a PnP device after the start IRP has been sent down the stack.


Arguments:

   PDevObj    -  Pointer to the devobj that is starting

   PResList   -  Pointer to the untranslated resources needed by this device

   PTrResList -  Pointer to the translated resources needed by this device


  Return Value:

    STATUS_SUCCESS on success, something else appropriate on failure


--*/

{

   PCYY_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status;
   PCONFIG_DATA pConfig;
   HANDLE pnpKey;
   ULONG one = 1;
   BOOLEAN allocedUserData = FALSE; // Added in build 2128
   KIRQL oldIrql;

   PAGED_CODE();

   //
   // See if this is a restart, and if so don't reallocate the world
   //

   if ((pDevExt->Flags & CYY_FLAGS_STOPPED) 
       && (pDevExt->Flags & CYY_FLAGS_STARTED)) {      // change from 1946 to 2000
      CyyClearFlags(pDevExt, CYY_FLAGS_STOPPED);

      pDevExt->PNPState = CYY_PNP_RESTARTING;

      //
      // Re-init resource-related things in the extension
      //

      pDevExt->OurIsr = NULL;
      pDevExt->OurIsrContext = NULL;
      pDevExt->Interrupt = NULL;
      pDevExt->Vector = 0;
      pDevExt->Irql = 0;
      pDevExt->OriginalVector = 0;
      pDevExt->OriginalIrql = 0;
      pDevExt->BusNumber = 0;
      pDevExt->InterfaceType = 0;

#if 0
// removed for now - fanny
//      pDevExt->TopLevelOurIsr = NULL;
//      pDevExt->TopLevelOurIsrContext = NULL;
//
//      pDevExt->OriginalController = CyyPhysicalZero;
//      pDevExt->OriginalInterruptStatus = CyyPhysicalZero;
//
//
//      pDevExt->Controller = NULL;
//      pDevExt->InterruptStatus = NULL;
//
//      pDevExt->SpanOfController = 0;
//      pDevExt->SpanOfInterruptStatus = 0;
//
//      pDevExt->Vector = 0;
//      pDevExt->Irql = 0;
//      pDevExt->OriginalVector = 0;
//      pDevExt->OriginalIrql = 0;
//      pDevExt->AddressSpace = 0;
//      pDevExt->BusNumber = 0;
//      pDevExt->InterfaceType = 0;
//
//      pDevExt->CIsrSw = NULL;
//
//      ASSERT(PUserData == NULL);
//
//      PUserData = ExAllocatePool(PagedPool, sizeof(CYY_USER_DATA));
//
//      if (PUserData == NULL) {
//         return STATUS_INSUFFICIENT_RESOURCES;
//      }
//
//      allocedUserData = TRUE;   // Added in build 2128
//
//      RtlZeroMemory(PUserData, sizeof(CYY_USER_DATA));
//
//      PUserData->DisablePort = FALSE;
//      PUserData->UserClockRate = pDevExt->ClockRate;
//      PUserData->TxFIFO = pDevExt->TxFifoAmount;
//      PUserData->PermitShareDefault = pDevExt->PermitShare;
//
//
//      //
//      // Map betweeen trigger and amount
//      //
//
//      switch (pDevExt->RxFifoTrigger) {
//      case CYY_1_BYTE_HIGH_WATER:
//         PUserData->RxFIFO = 1;
//         break;
//
//      case CYY_4_BYTE_HIGH_WATER:
//         PUserData->RxFIFO = 4;
//         break;
//
//      case CYY_8_BYTE_HIGH_WATER:
//         PUserData->RxFIFO = 8;
//         break;
//
//      case CYY_14_BYTE_HIGH_WATER:
//         PUserData->RxFIFO = 14;
//         break;
//
//      default:
//         PUserData->RxFIFO = 1;
//      }
#endif // end removal of code
   } else {
      //
      // Mark as serenumerable -- toss status because we can
      // still start without this key.
      //

      status = IoOpenDeviceRegistryKey(pDevExt->Pdo,
                                       PLUGPLAY_REGKEY_DEVICE,
                                       STANDARD_RIGHTS_WRITE, &pnpKey);

      if (NT_SUCCESS(status)) {
         ULONG powerPolicy = 0;

         //
         // Find out if we own power policy
         //

         CyyGetRegistryKeyValue(pnpKey, L"CyyRelinquishPowerPolicy",
                                   sizeof(L"CyyRelinquishPowerPolicy"),
                                   &powerPolicy, sizeof(ULONG));

         pDevExt->OwnsPowerPolicy = powerPolicy ? FALSE : TRUE;


         ZwClose(pnpKey);
      }
   }

   //
   // Allocate the config record.
   //

   pConfig = ExAllocatePool (PagedPool, sizeof(CONFIG_DATA));

   //************************************
   // Error Injection
   //if (pConfig) {
   //   ExFreePool (pConfig);
   //}
   //pConfig = NULL;
   //************************************
   if (pConfig == NULL) {

      CyyLogError(pDevExt->DriverObject, NULL, CyyPhysicalZero,
                     CyyPhysicalZero, 0, 0, 0, 31, STATUS_SUCCESS,
                     CYY_INSUFFICIENT_RESOURCES, 0, NULL, 0, NULL);

      CyyDbgPrintEx(CYYERRORS, "Couldn't allocate memory for the\n"
                             "------  user configuration record\n");

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyyFinishStartDeviceError;
   }

   RtlZeroMemory(pConfig, sizeof(CONFIG_DATA));


   //
   // Get the configuration info for the device.
   //

   status = CyyGetPortInfo(PDevObj, PResList, PTrResList, pConfig);
                              

   if (!NT_SUCCESS(status)) {
      goto CyyFinishStartDeviceError;
   }

   //
   // See if we are in the proper power state.
   //



   if (pDevExt->PowerState != PowerDeviceD0) {

      status = CyyGotoPowerState(pDevExt->Pdo, pDevExt, PowerDeviceD0);

      if (!NT_SUCCESS(status)) {
         goto CyyFinishStartDeviceError;
      }
   }

   //
   // Find and initialize the controller
   //

   status = CyyFindInitController(PDevObj, pConfig);

   if (!NT_SUCCESS(status)) {
      goto CyyFinishStartDeviceError;
   }


   //
   // The hardware that is set up to NOT interrupt, connect an interrupt.
   //

   //
   // If a device doesn't already have an interrupt and it has an isr then
   // we attempt to connect to the interrupt if it is not shareing with other
   // serial devices.  If we fail to connect to an  interrupt we will delete
   // this device.
   //

   if (pDevExt != NULL) {
      CyyDbgPrintEx(CYYDIAG5, "pDevExt: Interrupt %x\n"
                       "-------               OurIsr %x\n", pDevExt->Interrupt,
                       pDevExt->OurIsr);
   } else {
      CyyDbgPrintEx(CYYERRORS, "CyyFinishStartDevice got NULL "
                       "pDevExt\n");
   }

   if ((!pDevExt->Interrupt) && (pDevExt->OurIsr)) {

      CyyDbgPrintEx(CYYDIAG5,
                    "About to connect to interrupt for port %wZ\n"
                    "------- address of extension is %x\n",
                    &pDevExt->DeviceName, pDevExt);

      CyyDbgPrintEx(CYYDIAG5, "IoConnectInterrupt Args:\n"
                              "Interrupt           %x\n"
                              "OurIsr              %x\n"
                              "OurIsrContext       %x\n"
                              "NULL\n"
                              "Vector              %x\n"
                              "Irql                %x\n"
                              "InterruptMode       %x\n"
                              "InterruptShareable  %x\n"
                              "ProcessorAffinity   %x\n"
                              "FALSE\n",
                              &pDevExt->Interrupt,
                              CyyIsr,
                              pDevExt->OurIsrContext,
                              pDevExt->Vector,
                              pDevExt->Irql,
                              pConfig->InterruptMode,
                              pDevExt->InterruptShareable,
                              pConfig->Affinity
                             );

      //
      // Do a just in time construction of the ISR switch.
      //
//removed fanny
//      pDevExt->CIsrSw->IsrFunc = pDevExt->OurIsr;
//      pDevExt->CIsrSw->Context = pDevExt->OurIsrContext;

      status = IoConnectInterrupt(&pDevExt->Interrupt, pDevExt->OurIsr,
                                  pDevExt->OurIsrContext, NULL,
                                  pDevExt->Vector, pDevExt->Irql,
                                  pDevExt->Irql,
                                  pConfig->InterruptMode,
                                  pDevExt->InterruptShareable,
                                  pConfig->Affinity, FALSE);
//****************************************
// Error Injection
//    if (pDevExt->Interrupt != NULL) {
//       IoDisconnectInterrupt(pDevExt->Interrupt);
//       pDevExt->Interrupt = NULL;
//    }
//    status = STATUS_INSUFFICIENT_RESOURCES;
//****************************************

      if (!NT_SUCCESS(status)) {

         //
         // Hmmm, how'd that happen?  Somebody either
         // didn't report their resources, or they
         // sneaked in since the last time I looked.
         //
         // Oh well,  delete this device.
         //

         CyyDbgPrintEx(CYYERRORS, "Couldn't connect to interrupt for %wZ\n",
                          &pDevExt->DeviceName);

         CyyDbgPrintEx(CYYERRORS, "IoConnectInterrupt Args:\n"
                                  "Interrupt           %x\n"
                                  "OurIsr              %x\n"
                                  "OurIsrContext       %x\n"
                                  "NULL\n"
                                  "Vector              %x\n"
                                  "Irql                %x\n"
                                  "InterruptMode       %x\n"
                                  "InterruptShareable  %x\n"
                                  "ProcessorAffinity   %x\n"
                                  "FALSE\n",
                                  &pDevExt->Interrupt,
                                  CyyIsr,
                                  pDevExt->OurIsrContext,
                                  pDevExt->Vector,
                                  pDevExt->Irql,
                                  pConfig->InterruptMode,
                                  pDevExt->InterruptShareable,
                                  pConfig->Affinity);



         CyyLogError(PDevObj->DriverObject, PDevObj,
                        pDevExt->OriginalBoardMemory,
                        CyyPhysicalZero, 0, 0, 0, pDevExt->Vector, status,
                        CYY_UNREPORTED_IRQL_CONFLICT,
                        pDevExt->DeviceName.Length + sizeof(WCHAR),
                        pDevExt->DeviceName.Buffer, 0, NULL);

         //status = CYY_UNREPORTED_IRQL_CONFLICT; Originally, it was SERIAL_UNREPORTED_IRQL_CONFLICT.
         goto CyyFinishStartDeviceError;

      }

      CyyDbgPrintEx(CYYDIAG5, "Connected interrupt %08X\n", pDevExt->Interrupt);

   }


   //
   // Add the PDevObj to the master list
   //

   CyyAddToAllDevs(&pDevExt->AllDevObjs);


   //
   // Reset the device.
   //

   //
   // While the device isn't open, disable all interrupts.
   //
   CD1400_DISABLE_ALL_INTERRUPTS(pDevExt->Cd1400,pDevExt->IsPci,pDevExt->CdChannel);

   //
   // This should set up everything as it should be when
   // a device is to be opened.  We do need to lower the
   // modem lines, and disable the recalcitrant fifo
   // so that it will show up if the user boots to dos.
   //

   KeSynchronizeExecution(
                         pDevExt->Interrupt,
                         CyyReset,
                         pDevExt
                         );

   KeSynchronizeExecution( //Disables the fifo.
                           pDevExt->Interrupt,
                           CyyMarkClose,
                           pDevExt
                         );

   KeSynchronizeExecution(
                         pDevExt->Interrupt,
                         CyyClrRTS,
                         pDevExt
                         );

   KeSynchronizeExecution(
                         pDevExt->Interrupt,
                         CyyClrDTR,
                         pDevExt
                         );

   if (pDevExt->PNPState == CYY_PNP_ADDED ) {
      //
      // Do the external naming now that the device is accessible.
      //

      status = CyyDoExternalNaming(pDevExt, pDevExt->DeviceObject->
                                      DriverObject);


      if (!NT_SUCCESS(status)) {
         CyyDbgPrintEx(CYYERRORS, "External Naming Failed - Status %x\n",
                       status);

         //
         // Allow the device to start anyhow
         //

         status = STATUS_SUCCESS;
      }
   } else {
      CyyDbgPrintEx(CYYPNPPOWER, "Not doing external naming -- state is %x"
                    "\n", pDevExt->PNPState);
   }

CyyFinishStartDeviceError:;

   if (!NT_SUCCESS (status)) {

      CyyDbgPrintEx(CYYDIAG1, "Cleaning up failed start\n");

      //
      // Resources created by this routine will be cleaned up by the remove
      //

      if (pDevExt->PNPState == CYY_PNP_RESTARTING) {
         //
         // Kill all that lives and breathes -- we'll clean up the
         // rest on the impending remove
         //

         CyyKillPendingIrps(PDevObj);

         //
         // In fact, pretend we're removing so we don't take any
         // more irps
         //

         CyySetAccept(pDevExt, CYY_PNPACCEPT_REMOVING);
         CyyClearFlags(pDevExt, CYY_FLAGS_STARTED);
      }
   } else { // SUCCESS

      //
      // Fill in WMI hardware data
      //

      pDevExt->WmiHwData.IrqNumber = pDevExt->Irql;
      pDevExt->WmiHwData.IrqLevel = pDevExt->Irql;
      pDevExt->WmiHwData.IrqVector = pDevExt->Vector;
      pDevExt->WmiHwData.IrqAffinityMask = pConfig->Affinity;
      pDevExt->WmiHwData.InterruptType = pConfig->InterruptMode == Latched
         ? SERIAL_WMI_INTTYPE_LATCHED : SERIAL_WMI_INTTYPE_LEVEL;
      pDevExt->WmiHwData.BaseIOAddress = (ULONG_PTR)pDevExt->BoardMemory;

      //
      // Fill in WMI device state data (as defaults)
      //

      pDevExt->WmiCommData.BaudRate = pDevExt->CurrentBaud;
      pDevExt->WmiCommData.BitsPerByte = (pDevExt->cor1 & COR1_DATA_MASK) + 5;
      pDevExt->WmiCommData.ParityCheckEnable = (pDevExt->cor1 & COR1_PARITY_ENABLE_MASK)
         ? TRUE : FALSE;

      switch (pDevExt->cor1 & COR1_PARITY_MASK) {
      case COR1_NONE_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_NONE;
         break;

      case COR1_ODD_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_ODD;
         break;

      case COR1_EVEN_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_EVEN;
         break;

      case COR1_MARK_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_MARK;
         break;

      case COR1_SPACE_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_SPACE;
         break;

      default:
         ASSERTMSG(0, "CYYPORT: Illegal Parity setting for WMI");
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_NONE;
         break;
      }

      switch(pDevExt->cor1 & COR1_STOP_MASK) {
      case COR1_1_STOP:
         pDevExt->WmiCommData.StopBits = SERIAL_WMI_STOP_1;
         break;
      case COR1_1_5_STOP:
         pDevExt->WmiCommData.StopBits = SERIAL_WMI_STOP_1_5;
         break;
      case COR1_2_STOP:
         pDevExt->WmiCommData.StopBits = SERIAL_WMI_STOP_2;
         break;
      default:
         ASSERTMSG(0, "CYYPORT: Illegal Stop Bit setting for WMI");
         pDevExt->WmiCommData.Parity = SERIAL_WMI_STOP_1;
         break;
      }

      pDevExt->WmiCommData.XoffCharacter = pDevExt->SpecialChars.XoffChar;
      pDevExt->WmiCommData.XoffXmitThreshold = pDevExt->HandFlow.XoffLimit;
      pDevExt->WmiCommData.XonCharacter = pDevExt->SpecialChars.XonChar;
      pDevExt->WmiCommData.XonXmitThreshold = pDevExt->HandFlow.XonLimit;
      pDevExt->WmiCommData.MaximumBaudRate
         = CyyReportMaxBaudRate(pDevExt->SupportedBauds);
      pDevExt->WmiCommData.MaximumOutputBufferSize = (UINT32)((ULONG)-1);
      pDevExt->WmiCommData.MaximumInputBufferSize = (UINT32)((ULONG)-1);
      pDevExt->WmiCommData.Support16BitMode = FALSE;
      pDevExt->WmiCommData.SupportDTRDSR = TRUE;
      pDevExt->WmiCommData.SupportIntervalTimeouts = TRUE;
      pDevExt->WmiCommData.SupportParityCheck = TRUE;
      pDevExt->WmiCommData.SupportRTSCTS = TRUE;
      pDevExt->WmiCommData.SupportXonXoff = TRUE;
      pDevExt->WmiCommData.SettableBaudRate = TRUE;
      pDevExt->WmiCommData.SettableDataBits = TRUE;
      pDevExt->WmiCommData.SettableFlowControl = TRUE;
      pDevExt->WmiCommData.SettableParity = TRUE;
      pDevExt->WmiCommData.SettableParityCheck = TRUE;
      pDevExt->WmiCommData.SettableStopBits = TRUE;
      pDevExt->WmiCommData.IsBusy = FALSE;

      //
      // Fill in wmi perf data (all zero's)
      //

      RtlZeroMemory(&pDevExt->WmiPerfData, sizeof(pDevExt->WmiPerfData));


      if (pDevExt->PNPState == CYY_PNP_ADDED) {
         PULONG countSoFar = &IoGetConfigurationInformation()->SerialCount;
         (*countSoFar)++;

         //
         // Register for WMI
         //

         pDevExt->WmiLibInfo.GuidCount = sizeof(SerialWmiGuidList) /
                                              sizeof(WMIGUIDREGINFO);
         pDevExt->WmiLibInfo.GuidList = SerialWmiGuidList;
         ASSERT (pDevExt->WmiLibInfo.GuidCount == SERIAL_WMI_GUID_LIST_SIZE);

         pDevExt->WmiLibInfo.QueryWmiRegInfo = CyyQueryWmiRegInfo;
         pDevExt->WmiLibInfo.QueryWmiDataBlock = CyyQueryWmiDataBlock;
         pDevExt->WmiLibInfo.SetWmiDataBlock = CyySetWmiDataBlock;
         pDevExt->WmiLibInfo.SetWmiDataItem = CyySetWmiDataItem;
         pDevExt->WmiLibInfo.ExecuteWmiMethod = NULL;
         pDevExt->WmiLibInfo.WmiFunctionControl = NULL;

         IoWMIRegistrationControl(PDevObj, WMIREG_ACTION_REGISTER);

      }

      if (pDevExt->PNPState == CYY_PNP_RESTARTING) {
         //
         // Release the stalled IRP's
         //

         CyyUnstallIrps(pDevExt);
      }

      pDevExt->PNPState = CYY_PNP_STARTED;
      CyyClearAccept(pDevExt, ~CYY_PNPACCEPT_OK);
      CyySetFlags(pDevExt, CYY_FLAGS_STARTED);

   }

   if (pConfig) {
      ExFreePool (pConfig);
   }
// REMOVED BY FANNY
//   if ((PUserData != NULL)
//       && (pDevExt->PNPState == CYY_PNP_RESTARTING)) {
//      ExFreePool(PUserData);
//   }
#if 0
   if ((PUserData != NULL) && allocedUserData) {    // Added in build 2128
      ExFreePool(PUserData);
   }
#endif

   CyyDbgPrintEx (CYYTRACECALLS, "leaving CyyFinishStartDevice\n");

   return status;
}


NTSTATUS
CyyStartDevice(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)

/*++

Routine Description:

    This routine first passes the start device Irp down the stack then
    it picks up the resources for the device, ititializes, puts it on any
    appropriate lists (i.e shared interrupt or interrupt status) and
    connects the interrupt.

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    Return status


--*/

{
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   NTSTATUS status = STATUS_NOT_IMPLEMENTED;
   PCYY_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;
   // Next: variables to get resources from the Registry
   HANDLE keyHandle;
   ULONG dataLength;
   PCM_RESOURCE_LIST portResources = NULL;
   PCM_RESOURCE_LIST portResourcesTr = NULL;

   PAGED_CODE();

   CyyDbgPrintEx(CYYTRACECALLS, "entering CyyStartDevice\n");


   //
   // Pass this down to the next device object
   //

   KeInitializeEvent(&pDevExt->CyyStartEvent, SynchronizationEvent,
                     FALSE);

   IoCopyCurrentIrpStackLocationToNext(PIrp);
   IoSetCompletionRoutine(PIrp, CyySyncCompletion,
                          &pDevExt->CyyStartEvent, TRUE, TRUE, TRUE);

   status = IoCallDriver(pLowerDevObj, PIrp);


   //
   // Wait for lower drivers to be done with the Irp
   //

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject (&pDevExt->CyyStartEvent, Executive, KernelMode,
                             FALSE, NULL);

      status = PIrp->IoStatus.Status;
   }

   //*********************************
   // Error Injection
   // status = STATUS_UNSUCCESSFUL;
   //*********************************

   if (!NT_SUCCESS(status)) {
      CyyDbgPrintEx(CYYERRORS, "error with IoCallDriver %x\n", status);
      CyyLogError( pDevExt->DriverObject,NULL,
                   CyyPhysicalZero,CyyPhysicalZero,
                   0,0,0,0,status,CYY_LOWER_DRIVERS_FAILED_START,
                   0,NULL,0,NULL);
      return status;
   }


   // Get resources from the registry

   status = IoOpenDeviceRegistryKey (pDevExt->Pdo,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_READ,
                                     &keyHandle);

   if (!NT_SUCCESS(status)) {
      CyyDbgPrintEx(CYYERRORS, "IoOpenDeviceRegistryKey failed - %x "
                                "\n", status);

   } else {

      dataLength = CyyGetRegistryKeyValueLength (keyHandle,
                                                 L"PortResources",
                                                 sizeof(L"PortResources"));

      portResources = ExAllocatePool(PagedPool, dataLength);
      
      if (portResources) {
         status = CyyGetRegistryKeyValue (keyHandle, L"PortResources",
                                          sizeof(L"PortResources"),
                                          portResources,
                                          dataLength);
         if (!NT_SUCCESS(status)) {
            CyyDbgPrintEx(CYYERRORS, "CyyGetRegistryKeyValue PortResources "
                                     "failed - %x\n", status);
            goto CyyStartDevice_End;
         }

      }
      dataLength = CyyGetRegistryKeyValueLength (keyHandle,
                                                 L"PortResourcesTr",
                                                 sizeof(L"PortResourcesTr"));

      portResourcesTr = ExAllocatePool(PagedPool, dataLength);
      
      if (portResourcesTr) {
         status = CyyGetRegistryKeyValue (keyHandle, L"PortResourcesTr",
                                          sizeof(L"PortResourcesTr"),
                                          portResourcesTr,
                                          dataLength);
         if (!NT_SUCCESS(status)) {
            CyyDbgPrintEx(CYYERRORS, "CyyGetRegistryKeyValue PortResourcesTr "
                                     "failed - %x\n", status);
            goto CyyStartDevice_End;
         }
      }

      //
      // Do the serial specific items to start the device
      //
      status = CyyFinishStartDevice(PDevObj, portResources, portResourcesTr);

CyyStartDevice_End:

      if (portResources) {
         ExFreePool(portResources);
      }
      if (portResourcesTr) {
         ExFreePool(portResourcesTr);
      }

      ZwClose (keyHandle);

   }


#if 0
   //
   // Do the serial specific items to start the device
   //
   status = CyyFinishStartDevice(PDevObj, pIrpStack->Parameters.StartDevice
                                    .AllocatedResources,
                                    pIrpStack->Parameters.StartDevice
                                    .AllocatedResourcesTranslated);
#endif
   

   
   return status;
}


NTSTATUS
CyyItemCallBack(
                  IN PVOID Context,
                  IN PUNICODE_STRING PathName,
                  IN INTERFACE_TYPE BusType,
                  IN ULONG BusNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
                  IN CONFIGURATION_TYPE ControllerType,
                  IN ULONG ControllerNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
                  IN CONFIGURATION_TYPE PeripheralType,
                  IN ULONG PeripheralNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
                  )

/*++

Routine Description:

    This routine is called to check if a particular item
    is present in the registry.

Arguments:

    Context - Pointer to a boolean.

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Controller type.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should be a peripheral.

    PeripheralNumber - Which peripheral - not used..

    PeripheralInformation - Configuration information. Not Used.

Return Value:

    STATUS_SUCCESS

--*/

{
   PAGED_CODE();

   *((BOOLEAN *)Context) = TRUE;
   return STATUS_SUCCESS;
}


NTSTATUS
CyyControllerCallBack(
                  IN PVOID Context,
                  IN PUNICODE_STRING PathName,
                  IN INTERFACE_TYPE BusType,
                  IN ULONG BusNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
                  IN CONFIGURATION_TYPE ControllerType,
                  IN ULONG ControllerNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
                  IN CONFIGURATION_TYPE PeripheralType,
                  IN ULONG PeripheralNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
                  )

/*++

Routine Description:

    This routine is called to check if a particular item
    is present in the registry.

Arguments:

    Context - Pointer to a boolean.

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Controller type.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should be a peripheral.

    PeripheralNumber - Which peripheral - not used..

    PeripheralInformation - Configuration information. Not Used.

Return Value:

    STATUS_SUCCESS

--*/

{
   PCM_FULL_RESOURCE_DESCRIPTOR controllerData;
   PSERIAL_PTR_CTX pContext = (PSERIAL_PTR_CTX)Context;
   ULONG i;

   PAGED_CODE();

   if (ControllerInformation[IoQueryDeviceConfigurationData]->DataLength == 0) {
      pContext->isPointer = FALSE;
      return STATUS_SUCCESS;
   }

   controllerData =
      (PCM_FULL_RESOURCE_DESCRIPTOR)
      (((PUCHAR)ControllerInformation[IoQueryDeviceConfigurationData])
        + ControllerInformation[IoQueryDeviceConfigurationData]->DataOffset);

   //
   // See if this is the exact port we are testing
   //
   for (i = 0; i < controllerData->PartialResourceList.Count; i++) {

      PCM_PARTIAL_RESOURCE_DESCRIPTOR partial
         = &controllerData->PartialResourceList.PartialDescriptors[i];

      switch (partial->Type) {
      case CmResourceTypePort:
         if (partial->u.Port.Start.QuadPart == pContext->Port.QuadPart) {
            //
            // Pointer on same controller. Bail out.
            //
            pContext->isPointer = SERIAL_FOUNDPOINTER_PORT;
            return STATUS_SUCCESS;
         }

      case CmResourceTypeInterrupt:
         if (partial->u.Interrupt.Vector == pContext->Vector) {
            //
            // Pointer sharing this interrupt.  Bail out.
            //
            pContext->isPointer = SERIAL_FOUNDPOINTER_VECTOR;
            return STATUS_SUCCESS;
         }

      default:
         break;
      }
   }

   pContext->isPointer = FALSE;
   return STATUS_SUCCESS;
}


                  
NTSTATUS
CyyGetPortInfo(IN PDEVICE_OBJECT PDevObj, IN PCM_RESOURCE_LIST PResList,
               IN PCM_RESOURCE_LIST PTrResList, OUT PCONFIG_DATA PConfig)

/*++

Routine Description:

    This routine will get the configuration information and put
    it and the translated values into CONFIG_DATA structures.
    It first sets up with  defaults and then queries the registry
    to see if the user has overridden these defaults; if this is a legacy
    multiport card, it uses the info in PUserData instead of groping the
    registry again.

Arguments:

    PDevObj - Pointer to the device object.

    PResList - Pointer to the untranslated resources requested.

    PTrResList - Pointer to the translated resources requested.

    PConfig - Pointer to configuration info


Return Value:

    STATUS_SUCCESS if consistant configuration was found - otherwise.
    returns STATUS_SERIAL_NO_DEVICE_INITED.

--*/

{
   PCYY_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;
   NTSTATUS status = STATUS_NOT_IMPLEMENTED;
   CONFIGURATION_TYPE pointer = PointerPeripheral;
   CONFIGURATION_TYPE controllerType  = SerialController;

   HANDLE keyHandle;
   ULONG count;
   ULONG i;
   INTERFACE_TYPE interfaceType;

   PCM_PARTIAL_RESOURCE_LIST pPartialResourceList, pPartialTrResourceList;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialResourceDesc, pPartialTrResourceDesc;

   PCM_FULL_RESOURCE_DESCRIPTOR pFullResourceDesc = NULL,
      pFullTrResourceDesc = NULL;

// REMOVED BY FANNY
//   ULONG defaultInterruptMode;
//   ULONG defaultAddressSpace;
//   ULONG defaultInterfaceType;
//   ULONG defaultClockRate;
   ULONG zero = 0;
//   CYY_PTR_CTX foundPointerCtx;
//   ULONG isMulti = 0;
//   ULONG gotInt = 0;
//   ULONG gotISR = 0;
//   ULONG gotIO = 0;
//   ULONG ioResIndex = 0;
//   ULONG curIoIndex = 0;

   PAGED_CODE();

   CyyDbgPrintEx(CYYTRACECALLS, "entering CyyGetPortInfo\n");

   CyyDbgPrintEx(CYYPNPPOWER, "resource pointer is %x\n", PResList);
   CyyDbgPrintEx(CYYPNPPOWER, "TR resource pointer is %x\n", PTrResList);


   if ((PResList == NULL) || (PTrResList == NULL)) {
      //
      // This shouldn't happen in theory
      //

       ASSERT(PResList != NULL);
       ASSERT(PTrResList != NULL);

      //
      // This status is as appropriate as I can think of
      //
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   //
   // Each resource list should have only one set of resources
   //

   ASSERT(PResList->Count == 1);
   ASSERT(PTrResList->Count == 1);

//REMOVED BY FANNY
#if 0
   //
   // See if this is a multiport device.  This way we allow other
   // pseudo-serial devices with extra resources to specify another range
   // of I/O ports.  If this is not a multiport, we only look at the first
   // range.  If it is a multiport, we look at the first two ranges.
   //

   status = IoOpenDeviceRegistryKey(pDevExt->Pdo, PLUGPLAY_REGKEY_DEVICE,
                                    STANDARD_RIGHTS_WRITE, &keyHandle);

   if (!NT_SUCCESS(status)) {
      return status;
   }

   status = CyyGetRegistryKeyValue(keyHandle, L"MultiportDevice",
                                      sizeof(L"MultiportDevice"), &isMulti,
                                      sizeof (ULONG));

   if (!NT_SUCCESS(status)) {
      isMulti = 0;
   }

   status = CyyGetRegistryKeyValue(keyHandle, L"CyyIoResourcesIndex",
                                      sizeof(L"CyyIoResourcesIndex"),
                                      &ioResIndex, sizeof(ULONG));

   if (!NT_SUCCESS(status)) {
      ioResIndex = 0;
   }

   ZwClose(keyHandle);

#endif  // end removal code

   pFullResourceDesc   = &PResList->List[0];
   pFullTrResourceDesc = &PTrResList->List[0];

   //
   // Ok, if we have a full resource descriptor.  Let's take it apart.
   //

   if (pFullResourceDesc) {
      pPartialResourceList    = &pFullResourceDesc->PartialResourceList;
      pPartialResourceDesc    = pPartialResourceList->PartialDescriptors;
      count                   = pPartialResourceList->Count;

      //
      // Pull out the stuff that is in the full descriptor.
      //

      PConfig->InterfaceType  = pFullResourceDesc->InterfaceType;
      PConfig->BusNumber      = pFullResourceDesc->BusNumber;

      //
      // Now run through the partial resource descriptors looking for the Runtime memory,
      // CD1400 memory, and interrupt.
      //

      for (i = 0;     i < count;     i++, pPartialResourceDesc++) {

         switch (pPartialResourceDesc->Type) {
         case CmResourceTypeMemory: {

               if (pPartialResourceDesc->u.Memory.Length == CYY_RUNTIME_LENGTH) {
                  PConfig->PhysicalRuntime = pPartialResourceDesc->u.Memory.Start;
                  PConfig->RuntimeLength = pPartialResourceDesc->u.Memory.Length;
                  PConfig->RuntimeAddressSpace = pPartialResourceDesc->Flags;
               } else {
                  PConfig->PhysicalBoardMemory = pPartialResourceDesc->u.Memory.Start;
                  PConfig->BoardMemoryLength = pPartialResourceDesc->u.Memory.Length;
                  PConfig->BoardMemoryAddressSpace = pPartialResourceDesc->Flags;
               }
               break;
         }

         case CmResourceTypeInterrupt: {
               PConfig->OriginalIrql = pPartialResourceDesc->u.Interrupt.Level;
               PConfig->OriginalVector =pPartialResourceDesc->u.Interrupt.Vector;
               PConfig->Affinity = pPartialResourceDesc->u.Interrupt.Affinity;
               if (pPartialResourceDesc->Flags
                   & CM_RESOURCE_INTERRUPT_LATCHED) {
                  PConfig->InterruptMode  = Latched;
               } else {
                  PConfig->InterruptMode  = LevelSensitive;
               }
            
               break;
         }


         default: {
               break;
            }
         }   // switch (pPartialResourceDesc->Type)
      }       // for (i = 0;     i < count;     i++, pPartialResourceDesc++)
   }           // if (pFullResourceDesc)


   //
   // Do the same for the translated resources
   //


   if (pFullTrResourceDesc) {
      pPartialTrResourceList = &pFullTrResourceDesc->PartialResourceList;
      pPartialTrResourceDesc = pPartialTrResourceList->PartialDescriptors;
      count = pPartialTrResourceList->Count;

      //
      // Reload PConfig with the translated values for later use
      //

      PConfig->InterfaceType  = pFullTrResourceDesc->InterfaceType;
      PConfig->BusNumber      = pFullTrResourceDesc->BusNumber;

      for (i = 0;     i < count;     i++, pPartialTrResourceDesc++) {


         switch (pPartialTrResourceDesc->Type) {
         case CmResourceTypeMemory: {

            // ATTENTION, ATTENTION: FOR NOW, WE WILL USE THE RAW
            // RESOURCES, AS WE HAVE GARBAGE IN THE TRANSLATED 
            // RESOURCES.
            //
            if (pPartialTrResourceDesc->u.Memory.Length == CYY_RUNTIME_LENGTH) {
               PConfig->TranslatedRuntime = pPartialTrResourceDesc->u.Memory.Start;
               PConfig->RuntimeLength = pPartialTrResourceDesc->u.Memory.Length;
            } else {
               PConfig->TranslatedBoardMemory = pPartialTrResourceDesc->u.Memory.Start;
               PConfig->BoardMemoryLength = pPartialTrResourceDesc->u.Memory.Length;
            }

            //TEMP CODE BECAUSE OUR BUS DRIVER IS GIVING WRONG TRANSLATED ADDRESS
            //PConfig->TranslatedRuntime = PConfig->PhysicalRuntime;
            //PConfig->TranslatedBoardMemory = PConfig->PhysicalBoardMemory;
            break;
         }

         case CmResourceTypeInterrupt: {
            PConfig->TrVector = pPartialTrResourceDesc->u.Interrupt.Vector;
            PConfig->TrIrql = pPartialTrResourceDesc->u.Interrupt.Level;
            PConfig->Affinity = pPartialTrResourceDesc->u.Interrupt.Affinity;
            break;
         }

         default: {
               break;
         }
         }   // switch (pPartialTrResourceDesc->Type)
      }       // for (i = 0;     i < count;     i++, pPartialTrResourceDesc++)
   }           // if (pFullTrResourceDesc)


   //
   // Initialize a config data structure with default values for those that
   // may not already be initialized.
   //

   PConfig->PortIndex = 0;
   PConfig->RxFIFO = driverDefaults.RxFIFODefault;
   PConfig->TxFIFO = driverDefaults.TxFIFODefault;


   //
   // Open the "Device Parameters" section of registry for this device object.
   //


   status = IoOpenDeviceRegistryKey (pDevExt->Pdo,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_READ,
                                     &keyHandle);

   if (!NT_SUCCESS(status)) {

      CyyDbgPrintEx(CYYERRORS, "IoOpenDeviceRegistryKey failed - %x \n",
                          status);
      goto PortInfoCleanUp;

   } else {

      status = CyyGetRegistryKeyValue (keyHandle,
                                          L"RxFIFO",
                                          sizeof(L"RxFIFO"),
                                          &PConfig->RxFIFO,
                                          sizeof (ULONG));
      status = CyyGetRegistryKeyValue (keyHandle,
                                          L"TxFIFO",
                                          sizeof(L"TxFIFO"),
                                          &PConfig->TxFIFO,
                                          sizeof (ULONG));
      status = CyyGetRegistryKeyValue (keyHandle,
                                          L"PortIndex",
                                          sizeof(L"PortIndex"),
                                          &PConfig->PortIndex,
                                          sizeof (ULONG));


      if (!NT_SUCCESS(status)) {
         PConfig->PortIndex = MAXULONG; // just some invalid number (fanny)
      }

      ZwClose (keyHandle);
   }

   //
   // Do some error checking on the configuration info we have.
   //
   // Make sure that the interrupt is non zero (which we defaulted
   // it to).
   //
   // Make sure that the portaddress is non zero (which we defaulted
   // it to).
   //
   // Make sure that the DosDevices is not NULL (which we defaulted
   // it to).
   //
   // We need to make sure that if an interrupt status
   // was specified, that a port index was also specfied,
   // and if so that the port index is <= maximum ports
   // on a board.
   //
   // We should also validate that the bus type and number
   // are correct.
   //
   // We will also validate that the interrupt mode makes
   // sense for the bus.
   //

//*****************************************
// Error Injection
//   PConfig->PhysicalRuntime.LowPart = NULL;
//   PConfig->PhysicalBoardMemory.LowPart = NULL;
//   PConfig->OriginalVector = NULL;
//   PConfig->PortIndex = MAXULONG;
//*****************************************

   if (!PConfig->PhysicalRuntime.LowPart && pDevExt->IsPci) {

      //
      // Ehhhh! Lose Game.
      //

      CyyLogError(
                    PDevObj->DriverObject,
                    NULL,
                    PConfig->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    PConfig->PortIndex+1,
                    STATUS_SUCCESS,
                    CYY_INVALID_RUNTIME_REGISTERS,
                    pDevExt->DeviceName.Length,
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL
                    );

      CyyDbgPrintEx(CYYERRORS,"Bogus Runtime address %x\n",
                    PConfig->PhysicalRuntime.LowPart);

      //status = CYY_INVALID_RUNTIME_REGISTERS;
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto PortInfoCleanUp;
   }

   if (!PConfig->PhysicalBoardMemory.LowPart) {

      //
      // Ehhhh! Lose Game.
      //

      CyyLogError(
                    PDevObj->DriverObject,
                    NULL,
                    PConfig->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    PConfig->PortIndex+1,
                    STATUS_SUCCESS,
                    CYY_INVALID_BOARD_MEMORY,
                    pDevExt->DeviceName.Length,
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL
                    );

      CyyDbgPrintEx(CYYERRORS,"Bogus board address %x\n",
                    PConfig->PhysicalBoardMemory.LowPart);

      //status = CYY_INVALID_BOARD_MEMORY;
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto PortInfoCleanUp;
   }

   if (!PConfig->OriginalVector) {

      //
      // Ehhhh! Lose Game.
      //

      CyyLogError(
                    pDevExt->DriverObject,
                    NULL,
                    PConfig->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    PConfig->PortIndex+1,
                    STATUS_SUCCESS,
                    CYY_INVALID_INTERRUPT,
                    pDevExt->DeviceName.Length,
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL
                    );

      CyyDbgPrintEx(CYYERRORS, "Bogus vector %x\n", PConfig->OriginalVector);

      //status = CYY_INVALID_INTERRUPT;
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto PortInfoCleanUp;
   }

   if (PConfig->PortIndex >= CYY_MAX_PORTS) {

      CyyLogError(
                    pDevExt->DriverObject,
                    NULL,
                    PConfig->PhysicalBoardMemory,
                    CyyPhysicalZero,
                    0,
                    0,
                    0,
                    PConfig->PortIndex,
                    STATUS_SUCCESS,
                    CYY_PORT_INDEX_TOO_HIGH,
                    pDevExt->DeviceName.Length,
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL
                    );

      CyyDbgPrintEx(CYYERRORS,"Port index too large %x\n",PConfig->PortIndex);

      //status = CYY_PORT_INDEX_TOO_HIGH;
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto PortInfoCleanUp;
   }

   

   //
   // We don't want to cause the hal to have a bad day,
   // so let's check the interface type and bus number.
   //
   // We only need to check the registry if they aren't
   // equal to the defaults.
   //

   if (PConfig->BusNumber != 0) {

      BOOLEAN foundIt;

      //**************************************************
      // Error Injection
      //    PConfig->InterfaceType = MaximumInterfaceType;
      //**************************************************

      if (PConfig->InterfaceType >= MaximumInterfaceType) {

         //
         // Ehhhh! Lose Game.
         //

         CyyLogError(
                       pDevExt->DriverObject,
                       NULL,
                       PConfig->PhysicalBoardMemory,
                       CyyPhysicalZero,
                       0,
                       0,
                       0,
                       PConfig->PortIndex+1,
                       STATUS_SUCCESS,
                       CYY_UNKNOWN_BUS,
                       pDevExt->DeviceName.Length,
                       pDevExt->DeviceName.Buffer,
                       0,
                       NULL
                       );

         CyyDbgPrintEx(CYYERRORS, "Invalid Bus type %x\n",
                       PConfig->BusNumber);

         //status = CYY_UNKNOWN_BUS;
         status = STATUS_INSUFFICIENT_RESOURCES;
         goto PortInfoCleanUp;
      }

      IoQueryDeviceDescription(
                              (INTERFACE_TYPE *)&PConfig->InterfaceType,
                              &zero,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              CyyItemCallBack,
                              &foundIt
                              );

      //**************************************************
      // Error Injection
      //      foundIt = FALSE;
      //**************************************************

      if (!foundIt) {

         CyyLogError(
                       pDevExt->DriverObject,
                       NULL,
                       PConfig->PhysicalBoardMemory,
                       CyyPhysicalZero,
                       0,
                       0,
                       0,
                       PConfig->PortIndex+1,
                       STATUS_SUCCESS,
                       CYY_BUS_NOT_PRESENT,
                       pDevExt->DeviceName.Length,
                       pDevExt->DeviceName.Buffer,
                       0,
                       NULL
                       );
         CyyDbgPrintEx(CYYERRORS, "There aren't that many of those\n"
                       "busses on this system,%x\n", PConfig->BusNumber);

         //status = CYY_BUS_NOT_PRESENT;
         status = STATUS_INSUFFICIENT_RESOURCES;
         goto PortInfoCleanUp;

      }

   }   // if (PConfig->BusNumber != 0)

   status = STATUS_SUCCESS;

   //
   // Dump out the port configuration.
   //

   CyyDbgPrintEx(CYYDIAG1, "Runtime Memory address: %x\n",
                 PConfig->PhysicalRuntime.LowPart);

   CyyDbgPrintEx(CYYDIAG1, "Board Memory address: %x\n",
                 PConfig->PhysicalBoardMemory.LowPart);

   CyyDbgPrintEx(CYYDIAG1, "Com Port Index: %x\n",
                 PConfig->PortIndex);

   CyyDbgPrintEx(CYYDIAG1, "Com Port BusNumber: %x\n",
                 PConfig->BusNumber);

   CyyDbgPrintEx(CYYDIAG1, "Com Runtime AddressSpace: %x\n",
                 PConfig->RuntimeAddressSpace);

   CyyDbgPrintEx(CYYDIAG1, "Com Board AddressSpace: %x\n",
                 PConfig->BoardMemoryAddressSpace);

   CyyDbgPrintEx(CYYDIAG1, "Com InterruptMode: %x\n",
                 PConfig->InterruptMode);

   CyyDbgPrintEx(CYYDIAG1, "Com InterfaceType: %x\n",
                 PConfig->InterfaceType);

   CyyDbgPrintEx(CYYDIAG1, "Com OriginalVector: %x\n",
                 PConfig->OriginalVector);

   CyyDbgPrintEx(CYYDIAG1, "Com OriginalIrql: %x\n",
                 PConfig->OriginalIrql);

   PortInfoCleanUp:;

   return status;
}


NTSTATUS
CyyReadSymName(IN PCYY_DEVICE_EXTENSION PDevExt, IN HANDLE hRegKey,
               OUT PUNICODE_STRING PSymName, OUT PWCHAR *PpRegName)
{
   NTSTATUS status;
   UNICODE_STRING linkName;
   PDRIVER_OBJECT pDrvObj;
   PDEVICE_OBJECT pDevObj;

   pDevObj = PDevExt->DeviceObject;
   pDrvObj = pDevObj->DriverObject;
   *PpRegName = NULL;

   RtlZeroMemory(&linkName, sizeof(UNICODE_STRING));

   linkName.MaximumLength = SYMBOLIC_NAME_LENGTH*sizeof(WCHAR);
   linkName.Buffer = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, linkName.MaximumLength
                                    + sizeof(WCHAR));

   if (linkName.Buffer == NULL) {
      CyyLogError(pDrvObj, pDevObj, CyyPhysicalZero, CyyPhysicalZero,
                  0, 0, 0, 19, STATUS_SUCCESS, CYY_INSUFFICIENT_RESOURCES,
                  0, NULL, 0, NULL);
      CyyDbgPrintEx(CYYERRORS, "Couldn't allocate memory for device name\n");

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyyReadSymNameError;

   }

   RtlZeroMemory(linkName.Buffer, linkName.MaximumLength + sizeof(WCHAR));


   *PpRegName = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, SYMBOLIC_NAME_LENGTH * sizeof(WCHAR)
                               + sizeof(WCHAR));

   if (*PpRegName == NULL) {
      CyyLogError(pDrvObj, pDevObj, CyyPhysicalZero, CyyPhysicalZero,
                  0, 0, 0, 19, STATUS_SUCCESS, CYY_INSUFFICIENT_RESOURCES,
                  0, NULL, 0, NULL);
      CyyDbgPrintEx(CYYERRORS, "Couldn't allocate memory for buffer\n");

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyyReadSymNameError;

   }

   //
   // Fetch PortName which contains the suggested REG_SZ symbolic name.
   //

   status = CyyGetRegistryKeyValue(hRegKey, L"PortName",
                                   sizeof(L"PortName"), *PpRegName,
                                   SYMBOLIC_NAME_LENGTH * sizeof(WCHAR));

   if (!NT_SUCCESS(status)) {

      //
      // This is for PCMCIA which currently puts the name under Identifier.
      //

      status = CyyGetRegistryKeyValue(hRegKey, L"Identifier",
                                      sizeof(L"Identifier"),
                                      *PpRegName, SYMBOLIC_NAME_LENGTH
                                      * sizeof(WCHAR));

      if (!NT_SUCCESS(status)) {

         //
         // Hmm.  Either we have to pick a name or bail...
         //
         // ...we will bail.
         //

         CyyDbgPrintEx(CYYERRORS, "Getting PortName/Identifier failed - "
                                  "%x\n", status);
         goto CyyReadSymNameError;
      }

   }


   //
   // Create the "\\DosDevices\\<symbolicName>" string
   //

   RtlAppendUnicodeToString(&linkName, L"\\");
   RtlAppendUnicodeToString(&linkName, DEFAULT_DIRECTORY);
   RtlAppendUnicodeToString(&linkName, L"\\");
   RtlAppendUnicodeToString(&linkName, *PpRegName);

   PSymName->MaximumLength = linkName.Length + sizeof(WCHAR);
   PSymName->Buffer = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, PSymName->MaximumLength);

   if (PSymName->Buffer == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyyReadSymNameError;
   }

   RtlZeroMemory(PSymName->Buffer, PSymName->MaximumLength);

   RtlAppendUnicodeStringToString(PSymName, &linkName);

   CyyDbgPrintEx(CYYDIAG1, "Read name %wZ\n", PSymName);

CyyReadSymNameError:

   if (linkName.Buffer != NULL) {
      ExFreePool(linkName.Buffer);
      linkName.Buffer = NULL;
   }

   if (!NT_SUCCESS(status)) {
      if (*PpRegName != NULL) {
         ExFreePool(*PpRegName);
         *PpRegName = NULL;
      }
   }

   return status;

}



NTSTATUS
CyyDoExternalNaming(IN PCYY_DEVICE_EXTENSION PDevExt,
                       IN PDRIVER_OBJECT PDrvObj)

/*++

Routine Description:

    This routine will be used to create a symbolic link
    to the driver name in the given object directory.

    It will also create an entry in the device map for
    this device - IF we could create the symbolic link.

Arguments:

    Extension - Pointer to the device extension.

Return Value:

    None.

--*/

{
   NTSTATUS status = STATUS_SUCCESS;
   HANDLE keyHandle;
   WCHAR *pRegName = NULL;
   UNICODE_STRING linkName;
   PDEVICE_OBJECT pLowerDevObj, pDevObj;
   ULONG bufLen;


   PAGED_CODE();


   pDevObj = PDevExt->DeviceObject;
   pLowerDevObj = PDevExt->LowerDeviceObject;

   status = IoOpenDeviceRegistryKey(PDevExt->Pdo, PLUGPLAY_REGKEY_DEVICE,
                                    STANDARD_RIGHTS_READ, &keyHandle);

   //
   // Check to see if we are allowed to do external naming; if not,
   // then we just return success
   //


   if (status != STATUS_SUCCESS) {
      return status;
   }


   CyyGetRegistryKeyValue(keyHandle, L"CyySkipExternalNaming",
                             sizeof(L"CyySkipExternalNaming"),
                             &PDevExt->SkipNaming, sizeof(ULONG));

   if (PDevExt->SkipNaming) {
      ZwClose(keyHandle);
      return STATUS_SUCCESS;
   }

   RtlZeroMemory(&linkName, sizeof(UNICODE_STRING));

   linkName.MaximumLength = SYMBOLIC_NAME_LENGTH*sizeof(WCHAR);
   linkName.Buffer = ExAllocatePool(PagedPool, linkName.MaximumLength
                                    + sizeof(WCHAR)); //TODO:"| POOL_COLD_ALLOCATION"???

   //************************************
   //Error Injection
   // 
   //if (linkName.Buffer != NULL) {
   //   ExFreePool(linkName.Buffer);
   //}
   //linkName.Buffer = NULL;
   //************************************

   if (linkName.Buffer == NULL) {
      CyyLogError(PDrvObj, pDevObj, CyyPhysicalZero, CyyPhysicalZero,
                     0, 0, 0, 71, STATUS_SUCCESS, CYY_INSUFFICIENT_RESOURCES,
                     0, NULL, 0, NULL);
      CyyDbgPrintEx(CYYERRORS, "Couldn't allocate memory for device name\n");

      status = STATUS_INSUFFICIENT_RESOURCES;
      ZwClose(keyHandle);
      goto CyyDoExternalNamingError;

   }

   RtlZeroMemory(linkName.Buffer, linkName.MaximumLength + sizeof(WCHAR));


   pRegName = ExAllocatePool(PagedPool, SYMBOLIC_NAME_LENGTH * sizeof(WCHAR)
                             + sizeof(WCHAR)); //TODO:"| POOL_COLD_ALLOCATION"???

   //************************************
   //Error Injection
   //
   //if (pRegName != NULL) {
   //   ExFreePool(pRegName);
   //}
   //pRegName = NULL;
   //************************************

   if (pRegName == NULL) {
      CyyLogError(PDrvObj, pDevObj, CyyPhysicalZero, CyyPhysicalZero,
                     0, 0, 0, 72, STATUS_SUCCESS, CYY_INSUFFICIENT_RESOURCES,
                     0, NULL, 0, NULL);
      CyyDbgPrintEx(CYYERRORS, "Couldn't allocate memory for buffer\n");

      status = STATUS_INSUFFICIENT_RESOURCES;
      ZwClose(keyHandle);
      goto CyyDoExternalNamingError;

   }

   //
   // Fetch PortName which contains the suggested REG_SZ symbolic name.
   //

   status = CyyGetRegistryKeyValue(keyHandle, L"PortName",
                                   sizeof(L"PortName"), pRegName,
                                   SYMBOLIC_NAME_LENGTH * sizeof(WCHAR));

   if (!NT_SUCCESS(status)) {

      //
      // This is for PCMCIA which currently puts the name under Identifier.
      //

      status = CyyGetRegistryKeyValue(keyHandle, L"Identifier",
                                         sizeof(L"Identifier"),
                                         pRegName, SYMBOLIC_NAME_LENGTH
                                         * sizeof(WCHAR));

      if (!NT_SUCCESS(status)) {

         //
         // Hmm.  Either we have to pick a name or bail...
         //
         // ...we will bail.
         //

         CyyDbgPrintEx(CYYERRORS, "Getting PortName/Identifier failed - "
                                  "%x\n", status);
         ZwClose (keyHandle);
         goto CyyDoExternalNamingError;
      }

   }

   ZwClose (keyHandle);

   bufLen = wcslen(pRegName) * sizeof(WCHAR) + sizeof(UNICODE_NULL);

   PDevExt->WmiIdentifier.Buffer = ExAllocatePool(PagedPool, bufLen);

   //************************************
   //Error Injection
   //
   //if (PDevExt->WmiIdentifier.Buffer != NULL) {
   //   ExFreePool(PDevExt->WmiIdentifier.Buffer);
   //}
   //PDevExt->WmiIdentifier.Buffer = NULL;
   //************************************

   if (PDevExt->WmiIdentifier.Buffer == NULL) {
      CyyLogError(PDrvObj, pDevObj, CyyPhysicalZero, CyyPhysicalZero,
                    0, 0, 0, 73, STATUS_SUCCESS, CYY_INSUFFICIENT_RESOURCES,
                    0, NULL, 0, NULL);
      CyyDbgPrintEx(CYYERRORS, "Couldn't allocate memory for WMI name\n");

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyyDoExternalNamingError;
   }

   RtlZeroMemory(PDevExt->WmiIdentifier.Buffer, bufLen);

   PDevExt->WmiIdentifier.Length = 0;
   PDevExt->WmiIdentifier.MaximumLength = (USHORT)bufLen - 1;
   RtlAppendUnicodeToString(&PDevExt->WmiIdentifier, pRegName);

   //
   // Create the "\\DosDevices\\<symbolicName>" string
   //
   RtlAppendUnicodeToString(&linkName, L"\\");
   RtlAppendUnicodeToString(&linkName, DEFAULT_DIRECTORY);
   RtlAppendUnicodeToString(&linkName, L"\\");
   RtlAppendUnicodeToString(&linkName, pRegName);

   //
   // Allocate Pool and save the symbolic link name in the device extension.
   //
   PDevExt->SymbolicLinkName.MaximumLength = linkName.Length + sizeof(WCHAR);
   PDevExt->SymbolicLinkName.Buffer
      = ExAllocatePool(PagedPool, PDevExt->SymbolicLinkName.MaximumLength);
                       //TODO:"| POOL_COLD_ALLOCATION"???

   if (!PDevExt->SymbolicLinkName.Buffer) {

      CyyLogError(PDrvObj, pDevObj, CyyPhysicalZero, CyyPhysicalZero,
                    0, 0, 0, 74, STATUS_SUCCESS, CYY_INSUFFICIENT_RESOURCES,
                    0, NULL, 0, NULL);
      CyyDbgPrintEx(CYYERRORS, "Couldn't allocate memory for symbolic link "
                               "name\n");

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto CyyDoExternalNamingError;
   }

   //
   // Zero fill it.
   //

   RtlZeroMemory(PDevExt->SymbolicLinkName.Buffer,
                 PDevExt->SymbolicLinkName.MaximumLength);

   RtlAppendUnicodeStringToString(&PDevExt->SymbolicLinkName,
                                  &linkName);

   PDevExt->DosName.Buffer = ExAllocatePool(PagedPool, 64 + sizeof(WCHAR));

   if (!PDevExt->DosName.Buffer) {

      CyyLogError(PDrvObj, pDevObj, CyyPhysicalZero, CyyPhysicalZero,
                    0, 0, 0, 75, STATUS_SUCCESS, CYY_INSUFFICIENT_RESOURCES,
                    0, NULL, 0, NULL);
      CyyDbgPrintEx(CYYERRORS, "Couldn't allocate memory for Dos name\n");

      status =  STATUS_INSUFFICIENT_RESOURCES;
      goto CyyDoExternalNamingError;
   }


   PDevExt->DosName.MaximumLength = 64 + sizeof(WCHAR);

   //
   // Zero fill it.
   //

   PDevExt->DosName.Length = 0;

   RtlZeroMemory(PDevExt->DosName.Buffer,
                 PDevExt->DosName.MaximumLength);

   RtlAppendUnicodeToString(&PDevExt->DosName, pRegName);
   RtlZeroMemory(((PUCHAR)(&PDevExt->DosName.Buffer[0]))
                 + PDevExt->DosName.Length, sizeof(WCHAR));

   CyyDbgPrintEx(CYYDIAG1, "DosName is %wZ\n", &PDevExt->DosName);

   status = IoCreateSymbolicLink (&PDevExt->SymbolicLinkName,
                                  &PDevExt->DeviceName);

   //************************************
   //Error Injection
   //IoDeleteSymbolicLink(&PDevExt->SymbolicLinkName);
   //status = STATUS_INVALID_PARAMETER;
   //************************************

   if (!NT_SUCCESS(status)) {

      //
      // Oh well, couldn't create the symbolic link.  No point
      // in trying to create the device map entry.
      //

      CyyLogError(PDrvObj, pDevObj, CyyPhysicalZero, CyyPhysicalZero,
                     0, 0, 0, PDevExt->PortIndex+1, status, CYY_NO_SYMLINK_CREATED,
                     PDevExt->DeviceName.Length + sizeof(WCHAR),
                     PDevExt->DeviceName.Buffer, 0, NULL);

      CyyDbgPrintEx(CYYERRORS, "Couldn't create the symbolic link\n"
                               "for port %wZ\n", &PDevExt->DeviceName);

      goto CyyDoExternalNamingError;

   }

   PDevExt->CreatedSymbolicLink = TRUE;

   status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP, L"SERIALCOMM",
                                   PDevExt->DeviceName.Buffer, REG_SZ,
                                   PDevExt->DosName.Buffer,
                                   PDevExt->DosName.Length + sizeof(WCHAR));

   //************************************
   //Error Injection
   //RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, SERIAL_DEVICE_MAP,
   //                                  PDevExt->DeviceName.Buffer);
   //status = STATUS_INVALID_PARAMETER;
   //************************************

   if (!NT_SUCCESS(status)) {

      CyyLogError(PDrvObj, pDevObj, CyyPhysicalZero, CyyPhysicalZero,
                     0, 0, 0, PDevExt->PortIndex+1, status, CYY_NO_DEVICE_MAP_CREATED,
                     PDevExt->DeviceName.Length + sizeof(WCHAR),
                     PDevExt->DeviceName.Buffer, 0, NULL);

      CyyDbgPrintEx(CYYERRORS, "Couldn't create the device map entry\n"
                               "------- for port %wZ\n", &PDevExt->DeviceName);

      goto CyyDoExternalNamingError;
   }

   PDevExt->CreatedSerialCommEntry = TRUE;

   //
   // Make the device visible via a device association as well.
   // The reference string is the eight digit device index
   //

   status = IoRegisterDeviceInterface(PDevExt->Pdo, (LPGUID)&GUID_CLASS_COMPORT,
                                      NULL, &PDevExt->DeviceClassSymbolicName);

   if (!NT_SUCCESS(status)) {
      CyyDbgPrintEx(CYYERRORS, "Couldn't register class association "
                               "for port %wZ\n", &PDevExt->DeviceName);

      PDevExt->DeviceClassSymbolicName.Buffer = NULL;
      goto CyyDoExternalNamingError;
   }


   //
   // Now set the symbolic link for the association
   //

   status = IoSetDeviceInterfaceState(&PDevExt->DeviceClassSymbolicName,
                                         TRUE);

   if (!NT_SUCCESS(status)) {
      CyyDbgPrintEx(CYYERRORS, "Couldn't set class association"
                               " for port %wZ\n", &PDevExt->DeviceName);
   }

   CyyDoExternalNamingError:;

   //
   // Clean up error conditions
   //

   if (!NT_SUCCESS(status)) {
      if (PDevExt->DosName.Buffer != NULL) {
         ExFreePool(PDevExt->DosName.Buffer);
         PDevExt->DosName.Buffer = NULL;
      }

      if (PDevExt->CreatedSymbolicLink ==  TRUE) {
         IoDeleteSymbolicLink(&PDevExt->SymbolicLinkName);
         PDevExt->CreatedSymbolicLink = FALSE;
      }

      if (PDevExt->SymbolicLinkName.Buffer != NULL) {
         ExFreePool(PDevExt->SymbolicLinkName.Buffer);
         PDevExt->SymbolicLinkName.Buffer = NULL;
      }

      if (PDevExt->DeviceName.Buffer != NULL) {
         RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, SERIAL_DEVICE_MAP,
                                PDevExt->DeviceName.Buffer);
      }

      if (PDevExt->DeviceClassSymbolicName.Buffer) {
         IoSetDeviceInterfaceState(&PDevExt->DeviceClassSymbolicName, FALSE);
         ExFreePool(PDevExt->DeviceClassSymbolicName.Buffer); //Added in DDK 2269
         PDevExt->DeviceClassSymbolicName.Buffer = NULL;      //Added in DDK 2269
      }

      if (PDevExt->WmiIdentifier.Buffer != NULL) {
         ExFreePool(PDevExt->WmiIdentifier.Buffer);
         PDevExt->WmiIdentifier.Buffer = NULL;
      }
   }

   //
   // Always clean up our temp buffers.
   //

   if (linkName.Buffer != NULL) {
      ExFreePool(linkName.Buffer);
   }

   if (pRegName != NULL) {
      ExFreePool(pRegName);
   }

   return status;
}





VOID
CyyUndoExternalNaming(IN PCYY_DEVICE_EXTENSION Extension)

/*++

Routine Description:

    This routine will be used to delete a symbolic link
    to the driver name in the given object directory.

    It will also delete an entry in the device map for
    this device if the symbolic link had been created.

Arguments:

    Extension - Pointer to the device extension.

Return Value:

    None.

--*/

{

   NTSTATUS status;
   HANDLE keyHandle;

   PAGED_CODE();

   CyyDbgPrintEx(CYYDIAG3, "In CyyUndoExternalNaming for "
                           "extension: %x of port %wZ\n",
                            Extension,&Extension->DeviceName);

   //
   // Maybe there is nothing for us to do
   //

   if (Extension->SkipNaming) {
      return;
   }

   //
   // We're cleaning up here.  One reason we're cleaning up
   // is that we couldn't allocate space for the directory
   // name or the symbolic link.
   //

   if (Extension->SymbolicLinkName.Buffer && Extension->CreatedSymbolicLink) {

      if (Extension->DeviceClassSymbolicName.Buffer) {
         status = IoSetDeviceInterfaceState(&Extension->DeviceClassSymbolicName,
                                            FALSE);

         //
         // IoRegisterDeviceClassInterface() allocated this string for us,
         // and we no longer need it.
         //

         ExFreePool(Extension->DeviceClassSymbolicName.Buffer);
         Extension->DeviceClassSymbolicName.Buffer = NULL;
      }
            
      //
      // Before we delete the symlink, re-read the PortName
      // from the registry in case we were renamed in user mode.
      //

      status = IoOpenDeviceRegistryKey(Extension->Pdo, PLUGPLAY_REGKEY_DEVICE,
                                       STANDARD_RIGHTS_READ, &keyHandle);

      if (status == STATUS_SUCCESS) {
         UNICODE_STRING symLinkName;
         PWCHAR pRegName;

         RtlInitUnicodeString(&symLinkName, NULL);

         status = CyyReadSymName(Extension, keyHandle, &symLinkName,
                                 &pRegName);

         if (status == STATUS_SUCCESS) {

            CyyDbgPrintEx(CYYDIAG1, "Deleting Link %wZ\n", &symLinkName);
            IoDeleteSymbolicLink(&symLinkName);

            ExFreePool(symLinkName.Buffer);
            ExFreePool(pRegName);
         }

         ZwClose(keyHandle);
      }
   }

   if (Extension->WmiIdentifier.Buffer) {
      ExFreePool(Extension->WmiIdentifier.Buffer);
      Extension->WmiIdentifier.MaximumLength
         = Extension->WmiIdentifier.Length = 0;
      Extension->WmiIdentifier.Buffer = NULL;
   }

   //
   // We're cleaning up here.  One reason we're cleaning up
   // is that we couldn't allocate space for the NtNameOfPort.
   //

   if ((Extension->DeviceName.Buffer != NULL)
        && Extension->CreatedSerialCommEntry) {

      status = RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, SERIAL_DEVICE_MAP,
                                     Extension->DeviceName.Buffer);
      //************************************
      //Error Injection
      //status = STATUS_INVALID_PARAMETER;
      //************************************

      if (!NT_SUCCESS(status)) {

         CyyLogError(
                       Extension->DeviceObject->DriverObject,
                       Extension->DeviceObject,
                       Extension->OriginalBoardMemory,
                       CyyPhysicalZero,
                       0,
                       0,
                       0,
                       Extension->PortIndex+1,
                       status,
                       CYY_NO_DEVICE_MAP_DELETED,
                       Extension->DeviceName.Length+sizeof(WCHAR),
                       Extension->DeviceName.Buffer,
                       0,
                       NULL
                       );
         CyyDbgPrintEx(CYYERRORS, "Couldn't delete value entry %wZ\n",
                       &Extension->DeviceName);

      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyyopcl.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyyopcl.c
*	
*   Description:    This module contains the code related to opening,
*                   closing and cleaning up in the Cyclom-Y Port driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#include "precomp.h"

BOOLEAN
CyyMarkOpen(
    IN PVOID Context
    );

BOOLEAN
CyyNullSynch(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,CyyGetCharTime)
#pragma alloc_text(PAGESER,CyyMarkClose)
#pragma alloc_text(PAGESER,CyyCleanup)
#pragma alloc_text(PAGESER,CyyClose)
#pragma alloc_text(PAGESER,CyyMarkClose)
#pragma alloc_text(PAGESER,CyyMarkOpen)

//
// Always paged
//

#pragma alloc_text(PAGESRP0,CyyCreateOpen)
#endif // ALLOC_PRAGMA


BOOLEAN
CyyNullSynch(
    IN PVOID Context
    ) 
/*------------------------------------------------------------------------
    Just a bogus little routine to synch with the ISR.
------------------------------------------------------------------------*/
{
    UNREFERENCED_PARAMETER(Context);
    return FALSE;
}


NTSTATUS
CyyCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*--------------------------------------------------------------------------
	CyyCreateOpen()

	Description: We connect up to the interrupt for the create/open
	and initialize the structures needed to maintain an open for a
	device.

	Arguments:
	
	DeviceObject - Pointer to the device object for this device
	Irp - Pointer to the IRP for the current request

	Return Value: The function value is the final status of the call
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    NTSTATUS localStatus;

    PAGED_CODE();

    if (extension->PNPState != CYY_PNP_STARTED) {
       Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
       IoCompleteRequest(Irp, IO_NO_INCREMENT);
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Lock out changes to PnP state until we have our open state decided
    //

    ExAcquireFastMutex(&extension->OpenMutex);

    if ((localStatus = CyyIRPPrologue(Irp, extension)) != STATUS_SUCCESS) {
       ExReleaseFastMutex(&extension->OpenMutex);
       CyyCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       return localStatus;
    }

    if (InterlockedIncrement(&extension->OpenCount) != 1) {
       ExReleaseFastMutex(&extension->OpenMutex);
       InterlockedDecrement(&extension->OpenCount);
       Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
       CyyCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       return STATUS_ACCESS_DENIED;
    }

    CyyDbgPrintEx(CYYIRPPATH, "Dispatch entry for: %x\n", Irp);

    CyyDbgPrintEx(CYYDIAG3, "In CyyCreateOpen\n");

    // Before we do anything, let's make sure they aren't trying
    // to create a directory.  This is a silly, but what's a driver to do!?
    
    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Create.Options &
        FILE_DIRECTORY_FILE) {
        ExReleaseFastMutex(&extension->OpenMutex);

        Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;
        Irp->IoStatus.Information = 0;

        InterlockedDecrement(&extension->OpenCount);
        CyyCompleteRequest(extension, Irp, IO_NO_INCREMENT);

        return STATUS_NOT_A_DIRECTORY;
    }

    // Create a buffer for the RX data when no reads are outstanding.
    
    extension->InterruptReadBuffer = NULL;
    extension->BufferSize = 0;
    
    // Try to allocate large buffers, whether the system is MmLargeSystem,
    // MmMediumSystem or MmSmallSystem. 
	
    extension->BufferSize = 4096;
    extension->InterruptReadBuffer =
   	    ExAllocatePool(NonPagedPool,extension->BufferSize);
    if (!extension->InterruptReadBuffer) {
        extension->BufferSize = 2048;
        extension->InterruptReadBuffer =
            ExAllocatePool(NonPagedPool,extension->BufferSize);
        if (!extension->InterruptReadBuffer) {
            extension->BufferSize = 1024;
            extension->InterruptReadBuffer = 
                ExAllocatePool(NonPagedPool,extension->BufferSize);
            if (!extension->InterruptReadBuffer) {
                extension->BufferSize = 128;
                extension->InterruptReadBuffer =
                    ExAllocatePool(NonPagedPool,extension->BufferSize);
            }
        }
    }
	
    #if 0
    switch (MmQuerySystemSize()) {
        case MmLargeSystem: {
            extension->BufferSize = 4096;
            extension->InterruptReadBuffer =
                ExAllocatePool(NonPagedPool,extension->BufferSize);
            if (extension->InterruptReadBuffer)	
                break;
        }
        default: {
            extension->BufferSize = 1024;
            extension->InterruptReadBuffer =
                ExAllocatePool(NonPagedPool,extension->BufferSize);
            if (extension->InterruptReadBuffer)	break;
			
            extension->BufferSize = 128;
            extension->InterruptReadBuffer =
                ExAllocatePool(NonPagedPool,extension->BufferSize);			
        break;
        }
    }
    #endif

    if (!extension->InterruptReadBuffer) {
       ExReleaseFastMutex(&extension->OpenMutex);

        extension->BufferSize = 0;
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;

        InterlockedDecrement(&extension->OpenCount);
        CyyCompleteRequest(extension, Irp, IO_NO_INCREMENT);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Ok, it looks like we really are going to open.  Lock down the
    // driver.
    //
    CyyLockPagableSectionByHandle(CyyGlobals.PAGESER_Handle);

    //
    // Power up the stack
    //

    (void)CyyGotoPowerState(DeviceObject, extension, PowerDeviceD0);

    //
    // Not currently waiting for wake up
    //

    extension->SendWaitWake = FALSE;


    // "flush" the read queue by initializing the count of characters.
    
    extension->CharsInInterruptBuffer = 0;
    extension->LastCharSlot = extension->InterruptReadBuffer +
                              (extension->BufferSize - 1);
    extension->ReadBufferBase = extension->InterruptReadBuffer;
    extension->CurrentCharSlot = extension->InterruptReadBuffer;
    extension->FirstReadableChar = extension->InterruptReadBuffer;
    extension->TotalCharsQueued = 0;

    // set up the default xon/xoff limits.
    
    extension->HandFlow.XoffLimit = extension->BufferSize >> 3;
    extension->HandFlow.XonLimit = extension->BufferSize >> 1;

    extension->WmiCommData.XoffXmitThreshold = extension->HandFlow.XoffLimit;
    extension->WmiCommData.XonXmitThreshold = extension->HandFlow.XonLimit;

    extension->BufferSizePt8 = ((3*(extension->BufferSize>>2))+
                                   (extension->BufferSize>>4));

    //
    // Mark the device as busy for WMI
    //

    extension->WmiCommData.IsBusy = TRUE;

    extension->IrpMaskLocation = NULL;
    extension->HistoryMask = 0;
    extension->IsrWaitMask = 0;

	
#if !DBG
    // Clear out the statistics.

    KeSynchronizeExecution(extension->Interrupt,CyyClearStats,extension);
#endif
    
    extension->EscapeChar = 0;

    // Synchronize with the ISR and mark the device as open
    KeSynchronizeExecution(extension->Interrupt,CyyMarkOpen,extension);

    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // We have been marked open, so now the PnP state can change
    //

    ExReleaseFastMutex(&extension->OpenMutex);

    localStatus = Irp->IoStatus.Status;
    Irp->IoStatus.Information=0L;

    if (!NT_SUCCESS(localStatus)) {
       if (extension->InterruptReadBuffer != NULL) {
          ExFreePool(extension->InterruptReadBuffer);
          extension->InterruptReadBuffer = NULL;
       }

       InterlockedDecrement(&extension->OpenCount);
    }

    CyyCompleteRequest(extension, Irp, IO_NO_INCREMENT);

    return localStatus;
}

//TODO FANNY: DO WE NEED THIS?
#if 0
VOID
SerialDrainUART(IN PSERIAL_DEVICE_EXTENSION PDevExt,
                IN PLARGE_INTEGER PDrainTime)
{
   PAGED_CODE();

   //
   // Wait until all characters have been emptied out of the hardware.
   //

   while ((READ_LINE_STATUS(PDevExt->Controller) &
           (SERIAL_LSR_THRE | SERIAL_LSR_TEMT))
           != (SERIAL_LSR_THRE | SERIAL_LSR_TEMT)) {

        KeDelayExecutionThread(KernelMode, FALSE, PDrainTime);
    }
}
#endif

NTSTATUS
CyyClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*--------------------------------------------------------------------------
	CyyClose()

	Description: We simply disconnect the interrupt for now.

	Arguments:
	
	DeviceObject - Pointer to the device object for this device
	Irp - Pointer to the IRP for the current request

	Return Value: The function value is the final status of the call
--------------------------------------------------------------------------*/
{
    LARGE_INTEGER tenCharDelay;
    LARGE_INTEGER charTime;
    PCYY_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    ULONG i;

    NTSTATUS status;

    //
    // Number of opens still active
    //

    LONG openCount;

    //
    // Number of DPC's still pending
    //

    ULONG pendingDPCs;

    ULONG flushCount;

    //
    // Grab a mutex
    //

    ExAcquireFastMutex(&extension->CloseMutex);


    //
    // We succeed a close on a removing device
    //

    if ((status = CyyIRPPrologue(Irp, extension)) != STATUS_SUCCESS) {
       CyyDbgPrintEx(DPFLTR_INFO_LEVEL, "Close prologue failed for: %x\n",
                     Irp);
       if (status == STATUS_DELETE_PENDING) {
             extension->BufferSize = 0;
             ExFreePool(extension->InterruptReadBuffer);
             extension->InterruptReadBuffer = NULL;
             status = Irp->IoStatus.Status = STATUS_SUCCESS;
       }

       CyyCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       openCount = InterlockedDecrement(&extension->OpenCount);
       ASSERT(openCount == 0);
       ExReleaseFastMutex(&extension->CloseMutex);
       return status;
    }

    ASSERT(extension->OpenCount >= 1);

    if (extension->OpenCount < 1) {
       CyyDbgPrintEx(DPFLTR_ERROR_LEVEL, "Close open count bad for: 0x%x\n",
                     Irp);
       CyyDbgPrintEx(DPFLTR_ERROR_LEVEL, "Count: %x  Addr: 0x%x\n",
                     extension->OpenCount, &extension->OpenCount);
       ExReleaseFastMutex(&extension->CloseMutex);
       Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
       CyyCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       return STATUS_INVALID_DEVICE_REQUEST;
    }

    CyyDbgPrintEx(CYYIRPPATH, "Dispatch entry for: %x\n", Irp);
    CyyDbgPrintEx(CYYDIAG3, "In CyyClose\n");

    charTime.QuadPart = -CyyGetCharTime(extension).QuadPart;

    extension->DeviceIsOpened = FALSE;

    // Turn break off in case it is on

	//Call of CyyTurnOffBreak removed, because as DeviceIsOpened will be
	//FALSE in the ISR, the Stop Break cannot be executed. Anyway, any
	//char (other than Send Break) sent to the FIFO will stop the Break.
    //KeSynchronizeExecution(extension->Interrupt,CyyTurnOffBreak,extension);
			
    // Wait until all characters have been emptied out of the hardware.

    for(i = 0 ; i < MAX_CHAR_FIFO ; i++) {
        KeDelayExecutionThread(KernelMode,FALSE,&charTime);
    }

    // TODO FANNY: SHOULD WE CALL SerialMarkHardwareBroken()? SEE LATER...

    // Synchronize with the ISR to let it know that interrupts are
    // no longer important.

    KeSynchronizeExecution(extension->Interrupt,CyyMarkClose,extension);

    // If the driver has automatically transmitted an Xoff in
    // the context of automatic receive flow control then we
    // should transmit an Xon.

    if (extension->RXHolding & CYY_RX_XOFF) {
      //volatile unsigned char *pt_chip = extension->Controller;
	   //ULONG index = extension->BusIndex;	
      //    
	   //cy_wreg(CAR,extension->CdChannel & 0x03);

      PUCHAR chip = extension->Cd1400;
      ULONG bus = extension->IsPci;

      CD1400_WRITE(chip,bus,CAR,extension->CdChannel & 0x03);
	   CyyCDCmd(extension,CCR_SENDSC_SCHR1);	

      //TODO FANNY: SHOULD WE CALL SerialMarkHardwareBroken()? SEE LATER...
    }
    
    // The hardware is hopefully empty. Delay 10 chars before dropping DTR.
    
    tenCharDelay.QuadPart = charTime.QuadPart * 10;
    KeDelayExecutionThread(KernelMode,TRUE,&tenCharDelay);
    CyyClrDTR(extension);

    // We have to be very careful how we clear the RTS line.
    // Transmit toggling might have been on at some point.
    //
    // We know that there is nothing left that could start
    // out the "polling"  execution path.  We need to
    // check the counter that indicates that the execution
    // path is active.  If it is then we loop delaying one
    // character time.  After each delay we check to see if
    // the counter has gone to zero.  When it has we know that
    // the execution path should be just about finished.  We
    // make sure that we still aren't in the routine that
    // synchronized execution with the ISR by synchronizing
    // ourselve with the ISR.

    if (extension->CountOfTryingToLowerRTS) {
        do {
            KeDelayExecutionThread(KernelMode,FALSE,&charTime);
        } while (extension->CountOfTryingToLowerRTS);

        KeSynchronizeExecution(extension->Interrupt,CyyNullSynch,NULL);
    }

    CyyClrRTS(extension);

    // Clean out the holding reasons (since we are closed).
    
    extension->RXHolding = 0;
    extension->TXHolding = 0;

    //
    // Mark device as not busy for WMI
    //

    extension->WmiCommData.IsBusy = FALSE;

    // Release the buffers.
    
    extension->BufferSize = 0;
    if (extension->InterruptReadBuffer != NULL) { // added in DDK build 2072
       ExFreePool(extension->InterruptReadBuffer);
    }
    extension->InterruptReadBuffer = NULL;

    //
    // Stop waiting for wakeup
    //

    extension->SendWaitWake = FALSE;

    if (extension->PendingWakeIrp != NULL) {
       IoCancelIrp(extension->PendingWakeIrp);
    }

    //
    // Power down our device stack
    //

    (void)CyyGotoPowerState(DeviceObject, extension, PowerDeviceD3);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information=0L;

    CyyCompleteRequest(extension, Irp, IO_NO_INCREMENT);
   
    //
    // Unlock the pages.  If this is the last reference to the section
    // then the driver code will be flushed out.
    //

    //
    // First, we have to let the DPC's drain.  No more should be queued
    // since we aren't taking interrupts now....
    //

    pendingDPCs = InterlockedDecrement(&extension->DpcCount);
    LOGENTRY(LOG_CNT, 'DpD7', 0, extension->DpcCount, 0);   // Added in build 2128

    if (pendingDPCs) {
       CyyDbgPrintEx(CYYDIAG1,"Draining DPC's: %x\n", Irp);
       KeWaitForSingleObject(&extension->PendingDpcEvent, Executive,
                             KernelMode, FALSE, NULL);
    }


    CyyDbgPrintEx(CYYDIAG1, "DPC's drained: %x\n", Irp);



    //
    // Pages must be locked to release the mutex, so don't unlock
    // them until after we release the mutex
    //

    ExReleaseFastMutex(&extension->CloseMutex);

    //
    // Reset for next open
    //

    InterlockedIncrement(&extension->DpcCount);
    LOGENTRY(LOG_CNT, 'DpI6', 0, extension->DpcCount, 0);   // Added in build 2128

    openCount = InterlockedDecrement(&extension->OpenCount);

    ASSERT(openCount == 0);
    CyyUnlockPagableImageSection(CyyGlobals.PAGESER_Handle);

    return STATUS_SUCCESS;
}

BOOLEAN
CyyMarkOpen(
    IN PVOID Context
    )
/*------------------------------------------------------------------------
    CyyMarkOpen()
    
    Routine Description: This routine mark the fact that somebody opened
    the device and its worthwhile to pay attention to interrupts.

    Arguments:

    Context - Really a pointer to the device extension.

    Return Value: This routine always returns FALSE.
------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION extension = Context;

    CyyReset(extension);

    extension->DeviceIsOpened = TRUE;
    extension->ErrorWord = 0;
    return FALSE;
}


VOID
CyyDisableCd1400Channel(IN PVOID Context)

/*++

Routine Description:

    This routine disables the UART and puts it in a "safe" state when
    not in use (like a close or powerdown).

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
   PCYY_DEVICE_EXTENSION extension = Context;
   PCYY_DISPATCH pDispatch;
   PUCHAR chip = extension->Cd1400;
   ULONG bus = extension->IsPci;
   ULONG i;

   //
   // Prepare for the closing by stopping interrupts.
   //
   CD1400_WRITE(chip,bus,CAR,extension->CdChannel & 0x03);
   CD1400_WRITE(chip,bus,SRER,0x00); // Disable MdmCh, RxData, TxRdy

   // Flush TX FIFO
   //CD1400_WRITE(chip,bus,CAR,extension->CdChannel & 0x03);
	CyyCDCmd(extension,CCR_FLUSH_TXFIFO);

   pDispatch = (PCYY_DISPATCH)extension->OurIsrContext;
   pDispatch->Cd1400[extension->PortIndex] = NULL;

   for (i = 0; i < CYY_MAX_PORTS; i++) {
      if (pDispatch->Cd1400[extension->PortIndex] != NULL) {
          break;
      }
   }

   if (i == CYY_MAX_PORTS) {
      // This was the last port, we can clear any pending interrupt.
      CYY_CLEAR_INTERRUPT(extension->BoardMemory,bus); 
   }
}


BOOLEAN
CyyMarkClose(
    IN PVOID Context
    )
/*------------------------------------------------------------------------
    CyyMarkClose()
    
    Routine Description: This routine merely sets a boolean to false to
    mark the fact that somebody closed the device and it's no longer
    worthwhile to pay attention to interrupts.

    Arguments:

    Context - Really a pointer to the device extension.

    Return Value: This routine always returns FALSE.
------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION extension = Context;

    CyyDisableCd1400Channel(Context);

    extension->DeviceIsOpened = FALSE;
    return FALSE;
}

NTSTATUS
CyyCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*------------------------------------------------------------------------
    CyyCleanup()

    Routine Description: This function is used to kill all longstanding
    IO operations.

    Arguments:

    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request

    Return Value: The function value is the final status of the call
------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    NTSTATUS status;


    PAGED_CODE();

    //
    // We succeed a cleanup on a removing device
    //

    if ((status = CyyIRPPrologue(Irp, extension)) != STATUS_SUCCESS) {
       if (status == STATUS_DELETE_PENDING) {
          status = Irp->IoStatus.Status = STATUS_SUCCESS;
       }
       CyyCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       return status;
    }

    CyyDbgPrintEx(CYYIRPPATH, "Dispatch entry for: %x\n", Irp);

    CyyKillPendingIrps(DeviceObject);
    
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information=0L;

    CyyCompleteRequest(extension, Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

LARGE_INTEGER
CyyGetCharTime(
    IN PCYY_DEVICE_EXTENSION Extension
    )
/*------------------------------------------------------------------------
    CyyGetCharTime()
    
    Routine Description: return the number of 100 nanosecond intervals
    there are in one character time.

    Arguments:

    Extension - Just what it says.

    Return Value: 100 nanosecond intervals in a character time.
------------------------------------------------------------------------*/
{
    ULONG dataSize;
    ULONG paritySize;
    ULONG stopSize;
    ULONG charTime;
    ULONG bitTime;
    LARGE_INTEGER tmp;

    if ((Extension->cor1 & COR1_DATA_MASK) == COR1_5_DATA) {
      dataSize = 5;
    } else if ((Extension->cor1 & COR1_DATA_MASK) == COR1_6_DATA) {
      dataSize = 6;
    } else if ((Extension->cor1 & COR1_DATA_MASK) == COR1_7_DATA) {
      dataSize = 7;
    } else {
      dataSize = 8;
    }

    paritySize = 1;
    if ((Extension->cor1 & COR1_PARITY_MASK) == COR1_NONE_PARITY) {
       paritySize = 0;
    }

    if ((Extension->cor1 & COR1_STOP_MASK) == COR1_1_STOP) {

        stopSize = 1;

    } else {

        stopSize = 2;

    }

    //
    // First we calculate the number of 100 nanosecond intervals
    // are in a single bit time (Approximately).
    //

    bitTime = (10000000+(Extension->CurrentBaud-1))/Extension->CurrentBaud;
    charTime = bitTime + ((dataSize+paritySize+stopSize)*bitTime);

    tmp.QuadPart = charTime;
    return tmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyypower.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyypower.c
*	
*   Description:    This module contains the code that handles the power 
*                   IRPs for the Cyclom-Y Port driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESRP0, CyyGotoPowerState)
#pragma alloc_text(PAGESRP0, CyyPowerDispatch)
//#pragma alloc_text(PAGESRP0, CyySetPowerD0)
#pragma alloc_text(PAGESRP0, CyySetPowerD3)
//#pragma alloc_text(PAGESRP0, CyySaveDeviceState)
//#pragma alloc_text(PAGESRP0, CyyRestoreDeviceState)
#pragma alloc_text(PAGESRP0, CyySendWaitWake)
#endif // ALLOC_PRAGMA


typedef struct _POWER_COMPLETION_CONTEXT {

    PDEVICE_OBJECT  DeviceObject;
    PIRP            SIrp;

} POWER_COMPLETION_CONTEXT, *PPOWER_COMPLETION_CONTEXT;



NTSTATUS
CyySetPowerEvent(IN PDEVICE_OBJECT PDevObj, UCHAR MinorFunction,
                 IN POWER_STATE PowerState, IN PVOID Context,
                 PIO_STATUS_BLOCK IoStatus)
/*++

Routine Description:

    This routine is the completion routine for PoRequestPowerIrp calls
    in this module.

Arguments:

    PDevObj - Pointer to the device object the irp is completing for

    MinorFunction - IRP_MN_XXXX value requested

    PowerState - Power state request was made of

    Context - Event to set or NULL if no setting required

    IoStatus - Status block from request

Return Value:

    VOID


--*/
{
   if (Context != NULL) {
      KeSetEvent((PKEVENT)Context, IO_NO_INCREMENT, 0);
   }

   return STATUS_SUCCESS;
}

#if 0
BOOLEAN
CyyDisableInterruptInPLX(
    IN PVOID Context      
    )
/*++

Routine Description:

    This routine disables the PLX interrupts and puts the hw in a "safe" state when
    not in use (like a close or powerdown).

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/
{

   PCYY_DEVICE_EXTENSION PDevExt = Context;
   PUCHAR chip = PDevExt->Cd1400;
   ULONG bus = PDevExt->IsPci;

   if (PDevExt->IsPci){

      ULONG i;
      UCHAR plx_ver;
      ULONG original;
      PCYY_DISPATCH pDispatch;

      pDispatch = (PCYY_DISPATCH)PDevExt->OurIsrContext;
      pDispatch->Cd1400[PDevExt->PortIndex] = NULL;

      for (i = 0; i < CYY_MAX_PORTS; i++) {
         if (pDispatch->Cd1400[PDevExt->PortIndex] != NULL) {
            break;
         }
      }

      if (i == CYY_MAX_PORTS) {
            
         // This was the last port, disable Interrupts.

         CYY_CLEAR_INTERRUPT(PDevExt->BoardMemory,PDevExt->IsPci); 

         plx_ver = CYY_READ_PCI_TYPE(PDevExt->BoardMemory);
         plx_ver &= 0x0f;

         switch(plx_ver) {
         case CYY_PLX9050:
            original = PLX9050_READ_INTERRUPT_CONTROL(PDevExt->Runtime);
            PLX9050_WRITE_INTERRUPT_CONTROL(PDevExt->Runtime,
                                            original&~PLX9050_INT_ENABLE);
            break;
         case CYY_PLX9060:
         case CYY_PLX9080:
         default:
            original = PLX9060_READ_INTERRUPT_CONTROL(PDevExt->Runtime);
            PLX9060_WRITE_INTERRUPT_CONTROL(PDevExt->Runtime,
                                            original&~PLX9060_INT_ENABLE);
            break;				
         }
      }	    
   }

   // Disable interrupt mask in the CD1400
   CD1400_WRITE(chip,bus,CAR,PDevExt->CdChannel & 0x03);
   CD1400_WRITE(chip,bus,SRER,0x00);
   CyyCDCmd(PDevExt,CCR_RESET_CHANNEL); // Disables tx and rx, all FIFOs flushed.
   
   return FALSE;
}


BOOLEAN
CyyFlushCd1400(IN PVOID Context)

/*++

Routine Description:

    This routine flushes the Tx FIFO.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
   PCYY_DEVICE_EXTENSION extension = Context;
   PUCHAR chip = extension->Cd1400;
   ULONG bus = extension->IsPci;

   // Flush TX FIFO
   CD1400_WRITE(chip,bus,CAR,extension->CdChannel & 0x03);
   CyyCDCmd(extension,CCR_FLUSH_TXFIFO);

   return FALSE;

}
#endif

BOOLEAN
CyySaveDeviceState(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine saves the device state of the UART

Arguments:

    PDevExt - Pointer to the device extension for the devobj to save the state
              for.

Return Value:

    VOID


--*/
{
   PCYY_DEVICE_EXTENSION PDevExt = Context;
   PCYY_DEVICE_STATE pDevState = &PDevExt->DeviceState;
   PUCHAR chip = PDevExt->Cd1400;
   ULONG bus = PDevExt->IsPci;

   CyyDbgPrintEx(CYYTRACECALLS, "Entering CyySaveDeviceState\n");

   if (PDevExt->IsPci){

      ULONG i;
      UCHAR plx_ver;
      ULONG original;
      PCYY_DISPATCH pDispatch;

      pDispatch = (PCYY_DISPATCH)PDevExt->OurIsrContext;
      pDispatch->Cd1400[PDevExt->PortIndex] = NULL;

      for (i = 0; i < CYY_MAX_PORTS; i++) {
         if (pDispatch->Cd1400[PDevExt->PortIndex] != NULL) {
            break;
         }
      }

      if (i == CYY_MAX_PORTS) {
            
         // This was the last port, disable Interrupts.

         CYY_CLEAR_INTERRUPT(PDevExt->BoardMemory,PDevExt->IsPci); 

         plx_ver = CYY_READ_PCI_TYPE(PDevExt->BoardMemory);
         plx_ver &= 0x0f;

         switch(plx_ver) {
         case CYY_PLX9050:
            original = PLX9050_READ_INTERRUPT_CONTROL(PDevExt->Runtime);
            PLX9050_WRITE_INTERRUPT_CONTROL(PDevExt->Runtime,
                                            original&~PLX9050_INT_ENABLE);
            break;
         case CYY_PLX9060:
         case CYY_PLX9080:
         default:
            original = PLX9060_READ_INTERRUPT_CONTROL(PDevExt->Runtime);
            PLX9060_WRITE_INTERRUPT_CONTROL(PDevExt->Runtime,
                                            original&~PLX9060_INT_ENABLE);
            break;				
         }
      }	    
   }

   // Flush TX FIFO
   CD1400_WRITE(chip,bus,CAR,PDevExt->CdChannel & 0x03);
   CyyCDCmd(PDevExt,CCR_FLUSH_TXFIFO);

   CD1400_WRITE(chip,bus,CAR,PDevExt->CdChannel & 0x03);
   pDevState->Srer  = CD1400_READ(chip,bus,SRER);
   pDevState->Cor1  = CD1400_READ(chip,bus,COR1);
   pDevState->Cor2  = CD1400_READ(chip,bus,COR2);
   pDevState->Cor3  = CD1400_READ(chip,bus,COR3);
   pDevState->Schr1 = CD1400_READ(chip,bus,SCHR1);
   pDevState->Schr2 = CD1400_READ(chip,bus,SCHR2);
   pDevState->Mcor1 = CD1400_READ(chip,bus,MCOR1);
   pDevState->Mcor2 = CD1400_READ(chip,bus,MCOR2);
   pDevState->Rtpr  = CD1400_READ(chip,bus,RTPR);
   pDevState->Msvr1 = CD1400_READ(chip,bus,MSVR1);
   pDevState->Msvr2 = CD1400_READ(chip,bus,MSVR2);
   pDevState->Rbpr  = CD1400_READ(chip,bus,RBPR);
   pDevState->Tbpr  = CD1400_READ(chip,bus,TBPR);
   pDevState->Rcor  = CD1400_READ(chip,bus,RCOR);
   pDevState->Tcor  = CD1400_READ(chip,bus,TCOR);

   // Disable interrupt mask in the CD1400
   CD1400_WRITE(chip,bus,CAR,PDevExt->CdChannel & 0x03);
   CD1400_WRITE(chip,bus,SRER,0x00);
   CyyCDCmd(PDevExt,CCR_RESET_CHANNEL); // Disables tx and rx, all FIFOs flushed.

   PDevExt->PowerState = PowerDeviceD3;

   CyyDbgPrintEx(CYYTRACECALLS, "Leaving CyySaveDeviceState\n");

   return FALSE;
}

VOID
CyyEnableInterruptInPLX(
    IN PVOID Context      
    )
/*++

Routine Description:

    This routine enables the PLX interrupts and puts the hw in a "safe" state when
    not in use (like a close or powerdown).

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/
{

   PCYY_DEVICE_EXTENSION PDevExt = Context;

   if (PDevExt->IsPci){

      UCHAR plx_ver;
      ULONG original;

      plx_ver = CYY_READ_PCI_TYPE(PDevExt->BoardMemory);
      plx_ver &= 0x0f;

      switch(plx_ver) {
      case CYY_PLX9050:
         original = PLX9050_READ_INTERRUPT_CONTROL(PDevExt->Runtime);
         if ((original & PLX9050_INT_ENABLE) != PLX9050_INT_ENABLE) {
            PLX9050_WRITE_INTERRUPT_CONTROL(PDevExt->Runtime,
                                            original|PLX9050_INT_ENABLE);
         }
         break;
      case CYY_PLX9060:
      case CYY_PLX9080:
      default:
         original = PLX9060_READ_INTERRUPT_CONTROL(PDevExt->Runtime);
         if ((original & PLX9060_INT_ENABLE) != PLX9060_INT_ENABLE) {
            PLX9060_WRITE_INTERRUPT_CONTROL(PDevExt->Runtime,
                                            original|PLX9060_INT_ENABLE);
         }
         break;				
      }
   }

}


BOOLEAN
CyyRestoreDeviceState(
    IN PVOID Context      
    )
/*++

Routine Description:

    This routine restores the device state of the UART

Arguments:

    PDevExt - Pointer to the device PDevExt for the devobj to restore the
    state for.

Return Value:

    VOID


--*/
{
   PCYY_DEVICE_EXTENSION PDevExt = Context;
   PCYY_DEVICE_STATE pDevState = &PDevExt->DeviceState;
   PUCHAR chip = PDevExt->Cd1400;
   ULONG bus = PDevExt->IsPci;
   PCYY_DISPATCH pDispatch = PDevExt->OurIsrContext;

   CyyDbgPrintEx(CYYTRACECALLS, "Enter CyyRestoreDeviceState\n");
   CyyDbgPrintEx(CYYTRACECALLS, "PDevExt: %x\n", PDevExt);

   CD1400_WRITE(chip,bus,CAR,PDevExt->CdChannel & 0x03);
   CD1400_WRITE(chip,bus,SRER,0x00);
   CyyCDCmd(PDevExt,CCR_RESET_CHANNEL);

   CYY_CLEAR_INTERRUPT(PDevExt->BoardMemory,bus); 

   PDevExt->HoldingEmpty = TRUE;

   // Set Cd1400 address for the ISR
   pDispatch->Cd1400[PDevExt->PortIndex] = chip;

   CyyEnableInterruptInPLX(PDevExt);
   
   if (PDevExt->DeviceState.Reopen == TRUE) {
      CyyDbgPrintEx(CYYPNPPOWER, "Reopening device\n");

      PDevExt->DeviceIsOpened = TRUE;
      PDevExt->DeviceState.Reopen = FALSE;

      CD1400_WRITE(chip,bus,CAR,PDevExt->CdChannel & 0x03);
      CD1400_WRITE(chip,bus,COR1, pDevState->Cor1);
      CD1400_WRITE(chip,bus,COR2, pDevState->Cor2);
      CD1400_WRITE(chip,bus,COR3, pDevState->Cor3);
      CD1400_WRITE(chip,bus,SCHR1,pDevState->Schr1);
      CD1400_WRITE(chip,bus,SCHR2,pDevState->Schr2);
      CD1400_WRITE(chip,bus,MCOR1,pDevState->Mcor1);
      CD1400_WRITE(chip,bus,MCOR2,pDevState->Mcor2);
      CD1400_WRITE(chip,bus,RTPR, pDevState->Rtpr);
      CD1400_WRITE(chip,bus,MSVR1,pDevState->Msvr1);
      CD1400_WRITE(chip,bus,MSVR2,pDevState->Msvr2);
      CD1400_WRITE(chip,bus,RBPR, pDevState->Rbpr);
      CD1400_WRITE(chip,bus,TBPR, pDevState->Tbpr);
      CD1400_WRITE(chip,bus,RCOR, pDevState->Rcor);
      CD1400_WRITE(chip,bus,TCOR, pDevState->Tcor);
      CyyCDCmd(PDevExt,CCR_CORCHG_COR1_COR2_COR3);   
      CyyCDCmd(PDevExt,CCR_ENA_TX_RX);

      //
      // This enables interrupts on the device!
      //
      CD1400_WRITE(chip,bus,SRER, pDevState->Srer);
   }
   return FALSE;
}

VOID
CyyPowerRequestComplete(
    PDEVICE_OBJECT DeviceObject,
    UCHAR MinorFunction,
    POWER_STATE state,
    POWER_COMPLETION_CONTEXT* PowerContext,
    PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

   Completion routine for D-IRP.

Arguments:


Return Value:

   NT status code

--*/
{
    PCYY_DEVICE_EXTENSION pDevExt = (PCYY_DEVICE_EXTENSION) PowerContext->DeviceObject->DeviceExtension;
    PIRP sIrp = PowerContext->SIrp;

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (state);

    //DbgPrint(">CyyPowerRequestComplete\n");

    //
    // Cleanup
    //
    ExFreePool(PowerContext);

    //
    // Here we copy the D-IRP status into the S-IRP
    //
    sIrp->IoStatus.Status = IoStatus->Status;

    //
    // Release the IRP
    //
    PoStartNextPowerIrp(sIrp);
    CyyCompleteRequest(pDevExt,sIrp,IO_NO_INCREMENT);

    //DbgPrint("<CyyPowerRequestComplete\n");

}

NTSTATUS
CyySystemPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++
--*/
{
    POWER_COMPLETION_CONTEXT* powerContext;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    PCYY_DEVICE_EXTENSION   data;
    NTSTATUS    status = Irp->IoStatus.Status;

    UNREFERENCED_PARAMETER (Context);

    //DbgPrint(">CyySystemPowerComplete\n");

    data = DeviceObject->DeviceExtension;

    if (!NT_SUCCESS(status)) {

        PoStartNextPowerIrp(Irp);
        CyyIRPEpilogue(data);
        return STATUS_SUCCESS;
    }

    stack = IoGetCurrentIrpStackLocation (Irp);
    powerState = stack->Parameters.Power.State;
                        
    switch (stack->Parameters.Power.State.SystemState) {
    case PowerSystemUnspecified:
        powerState.DeviceState = PowerDeviceUnspecified;
        break;

    case PowerSystemWorking:
        powerState.DeviceState = PowerDeviceD0;
        break;

    case PowerSystemSleeping1:
    case PowerSystemSleeping2:
    case PowerSystemSleeping3:
    case PowerSystemHibernate:
    case PowerSystemShutdown:
    case PowerSystemMaximum:
        powerState.DeviceState = data->DeviceStateMap[stack->Parameters.Power.State.SystemState];
        break;

    default:
        powerState.DeviceState = PowerDeviceD3;
    }

    //
    // Send IRP to change device state
    //
    powerContext = (POWER_COMPLETION_CONTEXT*)
                ExAllocatePool(NonPagedPool, sizeof(POWER_COMPLETION_CONTEXT));

    if (!powerContext) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        powerContext->DeviceObject = DeviceObject;
        powerContext->SIrp = Irp;

        status = PoRequestPowerIrp(DeviceObject, IRP_MN_SET_POWER, powerState, CyyPowerRequestComplete, 
                                   powerContext, NULL);
    }

    if (!NT_SUCCESS(status)) {

        if (powerContext) {
            ExFreePool(powerContext);
        }

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        //CyyCompleteRequest(data,Irp,IO_NO_INCREMENT); Removed by Fanny
        CyyIRPEpilogue(data);  // Added by Fanny
        return status;
    }

    //DbgPrint("<CyySystemPowerComplete\n");
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
CyyDevicePowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++
--*/
{
   POWER_STATE         powerState;
   POWER_STATE_TYPE    powerType;
   PIO_STACK_LOCATION  stack;
   PCYY_DEVICE_EXTENSION   pDevExt;

   UNREFERENCED_PARAMETER (Context);

   //DbgPrint(">CyyDevicePowerComplete\n");

   pDevExt = DeviceObject->DeviceExtension;
   stack = IoGetCurrentIrpStackLocation (Irp);
   powerType = stack->Parameters.Power.Type;
   powerState = stack->Parameters.Power.State;

   //
   // Restore the device
   //

   pDevExt->PowerState = PowerDeviceD0;

   //
   // Theoretically we could change states in the middle of processing
   // the restore which would result in a bad PKINTERRUPT being used
   // in CyyRestoreDeviceState().
   //

   if (pDevExt->PNPState == CYY_PNP_STARTED) {
      KeSynchronizeExecution(
                            pDevExt->Interrupt,
                            CyyRestoreDeviceState,
                            pDevExt
                            );
   }

   //
   // Now that we are powered up, call PoSetPowerState
   //

   PoSetPowerState(DeviceObject, powerType, powerState);
   PoStartNextPowerIrp(Irp);
//   CyyCompleteRequest(pDevExt, Irp, IO_NO_INCREMENT); // Removed Fanny
//   return STATUS_MORE_PROCESSING_REQUIRED;            // Removed Fanny

   //DbgPrint("<CyyDevicePowerComplete\n");

   CyyIRPEpilogue(pDevExt); // Added Fanny
   return STATUS_SUCCESS;   // Added Fanny

}


NTSTATUS
CyyPowerDispatch(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)

/*++

Routine Description:

    This is a dispatch routine for the IRPs that come to the driver with the
    IRP_MJ_POWER major code (power IRPs).

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/

{

   PCYY_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   NTSTATUS status;
   PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;
   PDEVICE_OBJECT pPdo = pDevExt->Pdo;
   BOOLEAN acceptingIRPs;

   PAGED_CODE();

   if ((status = CyyIRPPrologue(PIrp, pDevExt)) != STATUS_SUCCESS) {
      PoStartNextPowerIrp(PIrp);
      CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
      return status;
   }

   status = STATUS_SUCCESS;

   switch (pIrpStack->MinorFunction) {

   case IRP_MN_WAIT_WAKE:
      CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_WAIT_WAKE Irp\n");
      break;


   case IRP_MN_POWER_SEQUENCE:
      CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_POWER_SEQUENCE Irp\n");
      break;

   case IRP_MN_SET_POWER:
      CyyDbgPrintEx(CYYPNPPOWER, "Got IRP_MN_SET_POWER Irp\n");

      switch (pIrpStack->Parameters.Power.Type) {
      case SystemPowerState:

         CyyDbgPrintEx(CYYPNPPOWER, "SystemPowerState\n");
         
         IoMarkIrpPending(PIrp);
         IoCopyCurrentIrpStackLocationToNext (PIrp);
         IoSetCompletionRoutine (PIrp,
                                 CyySystemPowerComplete,
                                 NULL,
                                 TRUE,
                                 TRUE,
                                 TRUE);
         PoCallDriver(pDevExt->LowerDeviceObject, PIrp);
         return STATUS_PENDING;

      case DevicePowerState:
         
         CyyDbgPrintEx(CYYPNPPOWER, "DevicePowerState\n");
         
         status = PIrp->IoStatus.Status = STATUS_SUCCESS;

         if (pDevExt->PowerState == pIrpStack->Parameters.Power.State.DeviceState) {
            // If we are already in the requested state, just pass the IRP down
            CyyDbgPrintEx(CYYPNPPOWER, "Already in requested power state\n");
            break;
         }
         switch (pIrpStack->Parameters.Power.State.DeviceState) {
         case PowerDeviceD0:
            if (pDevExt->OpenCount) {

               CyyDbgPrintEx(CYYPNPPOWER, "Going to power state D0\n");

               IoMarkIrpPending(PIrp);
               IoCopyCurrentIrpStackLocationToNext (PIrp);
               IoSetCompletionRoutine (PIrp,
                                       CyyDevicePowerComplete,
                                       NULL,
                                       TRUE,
                                       TRUE,
                                       TRUE);
               PoCallDriver(pDevExt->LowerDeviceObject, PIrp);
               return STATUS_PENDING;
            }
            //return CyySetPowerD0(PDevObj, PIrp);
            break;
         case PowerDeviceD1:
         case PowerDeviceD2:
         case PowerDeviceD3:

            CyyDbgPrintEx(CYYPNPPOWER, "Going to power state D3\n");

            return CyySetPowerD3(PDevObj, PIrp);
         }
         break;
      default:
         CyyDbgPrintEx(CYYPNPPOWER, "UNKNOWN PowerState\n");
         break;
      }
      break;

   case IRP_MN_QUERY_POWER:

      CyyDbgPrintEx (CYYPNPPOWER, "Got IRP_MN_QUERY_POWER Irp\n");

      //
      // Check if we have a wait-wake pending and if so,
      // ensure we don't power down too far.
      //
      if (pDevExt->PendingWakeIrp != NULL || pDevExt->SendWaitWake) {
         if (pIrpStack->Parameters.Power.Type == DevicePowerState
             && pIrpStack->Parameters.Power.State.DeviceState
             > pDevExt->DeviceWake) {
            status = PIrp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
            PoStartNextPowerIrp(PIrp);
            CyyCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return status;
         }
      }
      //
      // If no wait-wake, always successful
      //
      PIrp->IoStatus.Status = STATUS_SUCCESS;
      status = STATUS_SUCCESS;
      PoStartNextPowerIrp(PIrp);
      IoSkipCurrentIrpStackLocation(PIrp);
      return CyyPoCallDriver(pDevExt, pLowerDevObj, PIrp);

   }   // switch (pIrpStack->MinorFunction)


   PoStartNextPowerIrp(PIrp);
   //
   // Pass to the lower driver
   //
   IoSkipCurrentIrpStackLocation(PIrp);
   status = CyyPoCallDriver(pDevExt, pLowerDevObj, PIrp);

   return status;
}



NTSTATUS
CyyGotoPowerState(IN PDEVICE_OBJECT PDevObj,
                     IN PCYY_DEVICE_EXTENSION PDevExt,
                     IN DEVICE_POWER_STATE DevPowerState)
/*++

Routine Description:

    This routine causes the driver to request the stack go to a particular
    power state.

Arguments:

    PDevObj - Pointer to the device object for this device

    PDevExt - Pointer to the device extension we are working from

    DevPowerState - the power state we wish to go to

Return Value:

    The function value is the final status of the call


--*/
{
   KEVENT gotoPowEvent;
   NTSTATUS status;
   POWER_STATE powerState;

   PAGED_CODE();

   CyyDbgPrintEx(CYYTRACECALLS, "In CyyGotoPowerState\n");

   powerState.DeviceState = DevPowerState;

   KeInitializeEvent(&gotoPowEvent, SynchronizationEvent, FALSE);

   status = PoRequestPowerIrp(PDevObj, IRP_MN_SET_POWER, powerState,
                              CyySetPowerEvent, &gotoPowEvent,
                              NULL);

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject(&gotoPowEvent, Executive, KernelMode, FALSE, NULL);
      status = STATUS_SUCCESS;
   }

#if DBG
   if (!NT_SUCCESS(status)) {
      CyyDbgPrintEx(CYYPNPPOWER, "CyyGotoPowerState FAILED\n");
   }
#endif

   CyyDbgPrintEx(CYYTRACECALLS, "Leaving CyyGotoPowerState\n");

   return status;
}


NTSTATUS
CyySetPowerD3(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)
/*++

Routine Description:

    This routine handles the SET_POWER minor function.

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   PCYY_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);

   PAGED_CODE();

   CyyDbgPrintEx(CYYDIAG3, "In CyySetPowerD3\n");

   //
   // Send the wait wake now, just in time
   //


   if (pDevExt->SendWaitWake) {
      CyySendWaitWake(pDevExt);
   }
   //
   // Before we power down, call PoSetPowerState
   //

   PoSetPowerState(PDevObj, pIrpStack->Parameters.Power.Type,
                   pIrpStack->Parameters.Power.State);

   //
   // If the device is not closed, disable interrupts and allow the fifo's
   // to flush.
   //

   if (pDevExt->DeviceIsOpened == TRUE) {
      LARGE_INTEGER charTime;

      pDevExt->DeviceIsOpened = FALSE;
      pDevExt->DeviceState.Reopen = TRUE;

      //
      // Save the device state
      //
      KeSynchronizeExecution(
                            pDevExt->Interrupt,
                            CyySaveDeviceState,
                            pDevExt
                            );

   } 

   //
   // If the device is not open, we don't need to save the state;
   // we can just reset the device on power-up
   //

   pDevExt->PowerState = PowerDeviceD3;

   //
   // For what we are doing, we don't need a completion routine
   // since we don't race on the power requests.
   //

   PIrp->IoStatus.Status = STATUS_SUCCESS;

   PoStartNextPowerIrp(PIrp);
   IoSkipCurrentIrpStackLocation(PIrp);

   return CyyPoCallDriver(pDevExt, pDevExt->LowerDeviceObject, PIrp);
}


NTSTATUS
CyySendWaitWake(PCYY_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This routine causes a waitwake IRP to be sent

Arguments:

    PDevExt - Pointer to the device extension for this device

Return Value:

    STATUS_INVALID_DEVICE_STATE if one is already pending, else result
    of call to PoRequestPowerIrp.


--*/
{
   NTSTATUS status;
   PIRP pIrp;
   POWER_STATE powerState;

   PAGED_CODE();

   //
   // Make sure one isn't pending already -- serial will only handle one at
   // a time.
   //

   if (PDevExt->PendingWakeIrp != NULL) {
      return STATUS_INVALID_DEVICE_STATE;
   }

   //
   // Make sure we are capable of waking the machine
   //

   if (PDevExt->SystemWake <= PowerSystemWorking) {
      return STATUS_INVALID_DEVICE_STATE;
   }

   if (PDevExt->DeviceWake == PowerDeviceUnspecified) {
      return STATUS_INVALID_DEVICE_STATE;
   }

   //
   // Send IRP to request wait wake and add a pending irp flag
   //
   //

   InterlockedIncrement(&PDevExt->PendingIRPCnt);

   powerState.SystemState = PDevExt->SystemWake;

   status = PoRequestPowerIrp(PDevExt->Pdo, IRP_MN_WAIT_WAKE,
                              powerState, CyyWakeCompletion, PDevExt, &pIrp);

   if (status == STATUS_PENDING) {
      status = STATUS_SUCCESS;
      PDevExt->PendingWakeIrp = pIrp;
   } else if (!NT_SUCCESS(status)) {
      CyyIRPEpilogue(PDevExt);
   }

   return status;
}

NTSTATUS
CyyWakeCompletion(IN PDEVICE_OBJECT PDevObj, IN UCHAR MinorFunction,
                  IN POWER_STATE PowerState, IN PVOID Context,
                  IN PIO_STATUS_BLOCK IoStatus)
/*++

Routine Description:

    This routine handles completion of the waitwake IRP.

Arguments:

    PDevObj - Pointer to the device object for this device

    MinorFunction - Minor function previously supplied to PoRequestPowerIrp

    PowerState - PowerState previously supplied to PoRequestPowerIrp

    Context - a pointer to the device extension

    IoStatus - current/final status of the waitwake IRP

Return Value:

    The function value is the final status of attempting to process the
    waitwake.


--*/
{
   NTSTATUS status;
   PCYY_DEVICE_EXTENSION pDevExt = (PCYY_DEVICE_EXTENSION)Context;
   POWER_STATE powerState;

   status = IoStatus->Status;

   if (NT_SUCCESS(status)) {
      //
      // A wakeup has occurred -- powerup our stack
      //

      powerState.DeviceState = PowerDeviceD0;

      PoRequestPowerIrp(pDevExt->Pdo, IRP_MN_SET_POWER, powerState, NULL,
                        NULL, NULL);

   }

   pDevExt->PendingWakeIrp = NULL;
   CyyIRPEpilogue(pDevExt);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyyport.h ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyyport.h
*	
*   Description:    Type definitions and data for the Cyclom-Y Port 
*                   Driver
*
*   Notes:          This code supports Windows 2000 and x86 processor.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#define POOL_TAGGING    1

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'PyyC')
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'PyyC')
#endif


//
// The following definition is used to include/exclude changes made for power
// support in the driver.  If non-zero the support is included.  If zero the
// support is excluded.
//

#define POWER_SUPPORT   1


#define CYYDIAG1              (DPFLTR_INFO_LEVEL + 1)
#define CYYDIAG2              (DPFLTR_INFO_LEVEL + 2)
#define CYYDIAG3              (DPFLTR_INFO_LEVEL + 3)
#define CYYDIAG4              (DPFLTR_INFO_LEVEL + 4)
#define CYYDIAG5              (DPFLTR_INFO_LEVEL + 5)
#define CYYIRPPATH            (DPFLTR_INFO_LEVEL + 6)
#define CYYINITCODE           (DPFLTR_INFO_LEVEL + 7)
#define CYYTRACECALLS         (DPFLTR_INFO_LEVEL + 8)
#define CYYPNPPOWER           (DPFLTR_INFO_LEVEL + 9)
#define CYYFLOW               (DPFLTR_INFO_LEVEL + 10)
#define CYYERRORS             (DPFLTR_INFO_LEVEL + 11)
#define CYYDBGALL             ((ULONG)0xFFFFFFFF)

#define CYY_DBG_DEFAULT       CYYDBGALL

//
// Some default driver values.  We will check the registry for
// them first.
//
#define CYY_UNINITIALIZED_DEFAULT    1234567
#define CYY_PERMIT_SHARE_DEFAULT     0
#define CYY_RX_FIFO_DEFAULT          8
#define CYY_TX_FIFO_DEFAULT          MAX_CHAR_FIFO

//
// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.
#define DEFAULT_DIRECTORY L"DosDevices"

//
// For the above directory, the serial port will
// use the following name as the suffix of the serial
// ports for that directory.  It will also append
// a number onto the end of the name.  That number
// will start at 1.
#define DEFAULT_SERIAL_NAME L"COM"
//
//
// This define gives the default NT name for
// for serial ports detected by the firmware.
// This name will be appended to Device prefix
// with a number following it.  The number is
// incremented each time encounter a serial
// port detected by the firmware.  Note that
// on a system with multiple busses, this means
// that the first port on a bus is not necessarily
// \Device\Serial0.
//
#define DEFAULT_NT_SUFFIX L"Cyyport"


//#define CYY_VENDOR_ID	0x120e
//#define CYY_LO_DEV_ID	0x100
//#define CYY_HI_DEV_ID	0x101



// Defines for OutputRS232
#define	CYY_LC_RTS		0x01
#define	CYY_LC_DTR		0x02


typedef struct _CONFIG_DATA {
    PHYSICAL_ADDRESS    PhysicalRuntime;
    PHYSICAL_ADDRESS    TranslatedRuntime;
    PHYSICAL_ADDRESS    PhysicalBoardMemory; 
    PHYSICAL_ADDRESS    TranslatedBoardMemory;
    ULONG               RuntimeLength;
    ULONG               BoardMemoryLength;
    ULONG               PortIndex;
    ULONG               BusNumber;
    ULONG               RuntimeAddressSpace;
    ULONG               BoardMemoryAddressSpace;
    ULONG               RxFIFO;
    ULONG               TxFIFO;
    INTERFACE_TYPE      InterfaceType;
    KINTERRUPT_MODE     InterruptMode;
    ULONG               OriginalVector;
    ULONG               OriginalIrql;
    ULONG               TrVector;
    ULONG               TrIrql;
    KAFFINITY           Affinity;
    } CONFIG_DATA,*PCONFIG_DATA;


//
// This structure contains configuration data, much of which
// is read from the registry.
//
typedef struct _CYY_REGISTRY_DATA {
    PDRIVER_OBJECT  DriverObject;
    ULONG           ControllersFound;
    ULONG           DebugLevel;
    ULONG           ShouldBreakOnEntry;
    ULONG           RxFIFODefault;
    ULONG           TxFIFODefault;
    ULONG           PermitShareDefault;
    ULONG           PermitSystemWideShare;
    UNICODE_STRING  Directory;
    UNICODE_STRING  NtNameSuffix;
    UNICODE_STRING  DirectorySymbolicName;
    LIST_ENTRY      ConfigList;
} CYY_REGISTRY_DATA,*PCYY_REGISTRY_DATA;


// To support Break command
#define NO_BREAK	0
#define SEND_BREAK	1
#define STOP_BREAK	2
#define DISABLE_ETC	3

// Default xon/xoff characters.
#define CYY_DEF_XON 0x11
#define CYY_DEF_XOFF 0x13

// Reasons why reception may be held up.
#define CYY_RX_DTR       ((ULONG)0x01)
#define CYY_RX_XOFF      ((ULONG)0x02)
#define CYY_RX_RTS       ((ULONG)0x04)
#define CYY_RX_DSR       ((ULONG)0x08)

// Reasons why transmission may be held up.
#define CYY_TX_CTS       ((ULONG)0x01)
#define CYY_TX_DSR       ((ULONG)0x02)
#define CYY_TX_DCD       ((ULONG)0x04)
#define CYY_TX_XOFF      ((ULONG)0x08)
#define CYY_TX_BREAK     ((ULONG)0x10)

//Line status in RDSR Register
#define CYY_LSR_OE		0x01	//Overrun Error
#define CYY_LSR_FE		0x02	//Framing Error
#define CYY_LSR_PE		0x04	//Parity Error
#define CYY_LSR_BI		0x08	//Break Interrupt
#define CYY_LSR_ERROR	0x0f	//Overrun+Framing+Parity+Break

// These values are used by the routines that can be used
// to complete a read (other than interval timeout) to indicate
//
#define CYY_COMPLETE_READ_CANCEL ((LONG)-1)
#define CYY_COMPLETE_READ_TOTAL ((LONG)-2)
#define CYY_COMPLETE_READ_COMPLETE ((LONG)-3)


typedef struct _CYY_DEVICE_STATE {
   //
   // TRUE if we need to set the state to open
   // on a powerup
   //

   BOOLEAN Reopen;
   UCHAR Srer;
   UCHAR Cor1;
   UCHAR Cor2;
   UCHAR Cor3;
   UCHAR Schr1;
   UCHAR Schr2;
   UCHAR Mcor1;
   UCHAR Mcor2;
   UCHAR Rtpr;
   UCHAR Msvr1;
   UCHAR Msvr2;
   UCHAR Rbpr;
   UCHAR Tbpr;
   UCHAR Rcor;
   UCHAR Tcor;

} CYY_DEVICE_STATE, *PCYY_DEVICE_STATE;


#if DBG
#define CyyLockPagableSectionByHandle(_secHandle) \
{ \
    MmLockPagableSectionByHandle((_secHandle)); \
    InterlockedIncrement(&CyyGlobals.PAGESER_Count); \
}

#define CyyUnlockPagableImageSection(_secHandle) \
{ \
   InterlockedDecrement(&CyyGlobals.PAGESER_Count); \
   MmUnlockPagableImageSection(_secHandle); \
}


#define CYY_LOCKED_PAGED_CODE() \
    if ((KeGetCurrentIrql() > APC_LEVEL)  \
    && (CyyGlobals.PAGESER_Count == 0)) { \
    KdPrint(("CYYPORT: Pageable code called at IRQL %d without lock \n", \
             KeGetCurrentIrql())); \
        ASSERT(FALSE); \
        }

#else
#define CyyLockPagableSectionByHandle(_secHandle) \
{ \
    MmLockPagableSectionByHandle((_secHandle)); \
}

#define CyyUnlockPagableImageSection(_secHandle) \
{ \
   MmUnlockPagableImageSection(_secHandle); \
}

#define CYY_LOCKED_PAGED_CODE()
#endif // DBG


#define CyyRemoveQueueDpc(_dpc, _pExt) \
{ \
  if (KeRemoveQueueDpc((_dpc))) { \
     InterlockedDecrement(&(_pExt)->DpcCount); \
  } \
}


typedef struct _CYY_DEVICE_EXTENSION {
//    PKSERVICE_ROUTINE ptIsr;
//    PVOID ptContext;
//    struct _CYY_DEVICE_EXTENSION *ptExtension[CYY_MAX_PORTS];
//    ULONG nchannel;
    BOOLEAN LieRIDSR;

    //
    // This holds the isr that should be called from our own
    // dispatching isr for "cards" that are trying to share the
    // same interrupt.
    //
//    PKSERVICE_ROUTINE TopLevelOurIsr;

    //
    // This holds the context that should be used when we
    // call the above service routine.
    //
//    PVOID TopLevelOurIsrContext;

    //
    // This links together all of the different "cards" that are
    // trying to share the same interrupt of a non-mca machine.
    //
//    LIST_ENTRY TopLevelSharers;

    //
    // This circular doubly linked list links together all
    // devices that are using the same interrupt object.
    // NOTE: This does not mean that they are using the
    // same interrupt "dispatching" routine.
    //
//    LIST_ENTRY CommonInterruptObject;


    //
    // This links together all devobjs that this driver owns.
    // It is needed to search when starting a new device.
    //
    LIST_ENTRY AllDevObjs;

    // For reporting resource usage, we keep around the physical
    // address we got from the registry.
    //
    PHYSICAL_ADDRESS OriginalRuntimeMemory;

    // For reporting resource usage, we keep around the physical
    // address we got from the registry.
    //
    PHYSICAL_ADDRESS OriginalBoardMemory;

    //
    // This value is set by the read code to hold the time value
    // used for read interval timing.  We keep it in the extension
    // so that the interval timer dpc routine determine if the
    // interval time has passed for the IO.
    //
    LARGE_INTEGER IntervalTime;

    //
    // These two values hold the "constant" time that we should use
    // to delay for the read interval time.
    //
    LARGE_INTEGER ShortIntervalAmount;
    LARGE_INTEGER LongIntervalAmount;

    //
    // This holds the value that we use to determine if we should use
    // the long interval delay or the short interval delay.
    //
    LARGE_INTEGER CutOverAmount;

    //
    // This holds the system time when we last time we had
    // checked that we had actually read characters.  Used
    // for interval timing.
    //
    LARGE_INTEGER LastReadTime;

    //
    // We keep a pointer around to our device name for dumps
    // and for creating "external" symbolic links to this
    // device.
    //
    UNICODE_STRING DeviceName;

    //
    // This points to the object directory that we will place
    // a symbolic link to our device name.
    //
    UNICODE_STRING ObjectDirectory;

    //
    // This points to the device name for this device
    // sans device prefix.
    //
    UNICODE_STRING NtNameForPort;

    //
    // This points to the symbolic link name that will be
    // linked to the actual nt device name.
    //
    UNICODE_STRING SymbolicLinkName;

    //
    // This points to the pure "COMx" name
    //
    UNICODE_STRING DosName;

    //
    // This points the the delta time that we should use to
    // delay for interval timing.
    //
    PLARGE_INTEGER IntervalTimeToUse;

    //
    // Points to the device object that contains
    // this device extension.
    //
    PDEVICE_OBJECT DeviceObject;

    //
    // After initialization of the driver is complete, this
    // will either be NULL or point to the routine that the
    // kernel will call when an interrupt occurs.
    //
    // If the pointer is null then this is part of a list
    // of ports that are sharing an interrupt and this isn't
    // the first port that we configured for this interrupt.
    //
    // If the pointer is non-null then this routine has some
    // kind of structure that will "eventually" get us into
    // the real serial isr with a pointer to this device extension.
    //
    // NOTE: On an MCA bus (except for multiport cards) this
    // is always a pointer to the "real" serial isr.
    PKSERVICE_ROUTINE OurIsr;

    //
    // This will generally point right to this device extension.
    //
    // However, when the port that this device extension is
    // "managing" was the first port initialized on a chain
    // of ports that were trying to share an interrupt, this
    // will point to a structure that will enable dispatching
    // to any port on the chain of sharers of this interrupt.
    //
    PVOID OurIsrContext;

    PUCHAR Runtime;         // Virtual Address Pointer to the PLX Runtime memory
    PUCHAR BoardMemory;     // Virtual Address Pointer to the first CD1400 onboard
    PUCHAR Cd1400;          // Virtual Address Pointer to the CD1400 of this port
    PHYSICAL_ADDRESS OriginalCd1400;   // Physical address to the CD1400 or this port
    
    UCHAR  CdChannel;       // Channel number within the CD1400

    //
    // Points to the interrupt object for used by this device.
    //
    PKINTERRUPT Interrupt;

    //
    // This list head is used to contain the time ordered list
    // of read requests.  Access to this list is protected by
    // the global cancel spinlock.
    //
    LIST_ENTRY ReadQueue;

    //
    // This list head is used to contain the time ordered list
    // of write requests.  Access to this list is protected by
    // the global cancel spinlock.
    //
    LIST_ENTRY WriteQueue;

    //
    // This list head is used to contain the time ordered list
    // of set and wait mask requests.  Access to this list is protected by
    // the global cancel spinlock.
    //
    LIST_ENTRY MaskQueue;

    //
    // Holds the serialized list of purge requests.
    //
    LIST_ENTRY PurgeQueue;

    //
    // This points to the irp that is currently being processed
    // for the read queue.  This field is initialized by the open to
    // NULL.
    //
    // This value is only set at dispatch level.  It may be
    // read at interrupt level.
    //
    PIRP CurrentReadIrp;

    //
    // This points to the irp that is currently being processed
    // for the write queue.
    //
    // This value is only set at dispatch level.  It may be
    // read at interrupt level.
    //
    PIRP CurrentWriteIrp;

    //
    // Points to the irp that is currently being processed to
    // affect the wait mask operations.
    //
    PIRP CurrentMaskIrp;

    //
    // Points to the irp that is currently being processed to
    // purge the read/write queues and buffers.
    //
    PIRP CurrentPurgeIrp;

    //
    // Points to the current irp that is waiting on a comm event.
    //
    PIRP CurrentWaitIrp;

    //
    // Points to the irp that is being used to send an immediate
    // character.
    //
    PIRP CurrentImmediateIrp;

    //
    // Points to the irp that is being used to count the number
    // of characters received after an xoff (as currently defined
    // by the IOCTL_CYY_XOFF_COUNTER ioctl) is sent.
    //
    PIRP CurrentXoffIrp;

    //
    // Holds the number of bytes remaining in the current write
    // irp.
    //
    // This location is only accessed while at interrupt level.
    //
    ULONG WriteLength;

    //
    // Holds a pointer to the current character to be sent in
    // the current write.
    //
    // This location is only accessed while at interrupt level.
    //
    PUCHAR WriteCurrentChar;

    //
    // This is a buffer for the read processing.
    //
    // The buffer works as a ring.  When the character is read from
    // the device it will be place at the end of the ring.
    //
    // Characters are only placed in this buffer at interrupt level
    // although character may be read at any level. The pointers
    // that manage this buffer may not be updated except at interrupt
    // level.
    //
    PUCHAR InterruptReadBuffer;

    //
    // This is a pointer to the first character of the buffer into
    // which the interrupt service routine is copying characters.
    //
    PUCHAR ReadBufferBase;

    //
    // This is a count of the number of characters in the interrupt
    // buffer.  This value is set and read at interrupt level.  Note
    // that this value is only *incremented* at interrupt level so
    // it is safe to read it at any level.  When characters are
    // copied out of the read buffer, this count is decremented by
    // a routine that synchronizes with the ISR.
    //
    ULONG CharsInInterruptBuffer;

    //
    // Points to the first available position for a newly received
    // character.  This variable is only accessed at interrupt level and
    // buffer initialization code.
    //
    PUCHAR CurrentCharSlot;

    //
    // This variable is used to contain the last available position
    // in the read buffer.  It is updated at open and at interrupt
    // level when switching between the users buffer and the interrupt
    // buffer.
    //
    PUCHAR LastCharSlot;

    //
    // This marks the first character that is available to satisfy
    // a read request.  Note that while this always points to valid
    // memory, it may not point to a character that can be sent to
    // the user.  This can occur when the buffer is empty.
    //
    PUCHAR FirstReadableChar;

    //
    // Pointer to the lock variable returned for this extension when
    // locking down the driver
    //
    PVOID LockPtr;
    BOOLEAN LockPtrFlag;


    //
    // This variable holds the size of whatever buffer we are currently
    // using.
    //
    ULONG BufferSize;

    //
    // This variable holds .8 of BufferSize. We don't want to recalculate
    // this real often - It's needed when so that an application can be
    // "notified" that the buffer is getting full.
    //
    ULONG BufferSizePt8;

    //
    // This value holds the number of characters desired for a
    // particular read.  It is initially set by read length in the
    // IRP.  It is decremented each time more characters are placed
    // into the "users" buffer buy the code that reads characters
    // out of the typeahead buffer into the users buffer.  If the
    // typeahead buffer is exhausted by the read, and the reads buffer
    // is given to the isr to fill, this value is becomes meaningless.
    //
    ULONG NumberNeededForRead;

    //
    // This mask will hold the bitmask sent down via the set mask
    // ioctl.  It is used by the interrupt service routine to determine
    // if the occurence of "events" (in the serial drivers understanding
    // of the concept of an event) should be noted.
    //
    ULONG IsrWaitMask;

    //
    // This mask will always be a subset of the IsrWaitMask.  While
    // at device level, if an event occurs that is "marked" as interesting
    // in the IsrWaitMask, the driver will turn on that bit in this
    // history mask.  The driver will then look to see if there is a
    // request waiting for an event to occur.  If there is one, it
    // will copy the value of the history mask into the wait irp, zero
    // the history mask, and complete the wait irp.  If there is no
    // waiting request, the driver will be satisfied with just recording
    // that the event occured.  If a wait request should be queued,
    // the driver will look to see if the history mask is non-zero.  If
    // it is non-zero, the driver will copy the history mask into the
    // irp, zero the history mask, and then complete the irp.
    //
    ULONG HistoryMask;

    //
    // This is a pointer to the where the history mask should be
    // placed when completing a wait.  It is only accessed at
    // device level.
    //
    // We have a pointer here to assist us to synchronize completing a wait.
    // If this is non-zero, then we have wait outstanding, and the isr still
    // knows about it.  We make this pointer null so that the isr won't
    // attempt to complete the wait.
    //
    // We still keep a pointer around to the wait irp, since the actual
    // pointer to the wait irp will be used for the "common" irp completion
    // path.
    //
    ULONG *IrpMaskLocation;

    //
    // This mask holds all of the reason that transmission
    // is not proceeding.  Normal transmission can not occur
    // if this is non-zero.
    //
    // This is only written from interrupt level.
    // This could be (but is not) read at any level.
    //
    ULONG TXHolding;

    //
    // This mask holds all of the reason that reception
    // is not proceeding.  Normal reception can not occur
    // if this is non-zero.
    //
    // This is only written from interrupt level.
    // This could be (but is not) read at any level.
    //
    ULONG RXHolding;

    //
    // This holds the reasons that the driver thinks it is in
    // an error state.
    //
    // This is only written from interrupt level.
    // This could be (but is not) read at any level.
    //
    ULONG ErrorWord;

    //
    // This keeps a total of the number of characters that
    // are in all of the "write" irps that the driver knows
    // about.  It is only accessed with the cancel spinlock
    // held.
    //
    ULONG TotalCharsQueued;

    //
    // This holds a count of the number of characters read
    // the last time the interval timer dpc fired.  It
    // is a long (rather than a ulong) since the other read
    // completion routines use negative values to indicate
    // to the interval timer that it should complete the read
    // if the interval timer DPC was lurking in some DPC queue when
    // some other way to complete occurs.
    //
    LONG CountOnLastRead;

    //
    // This is a count of the number of characters read by the
    // isr routine.  It is *ONLY* written at isr level.  We can
    // read it at dispatch level.
    //
    ULONG ReadByIsr;

    //
    // This holds the current baud rate for the device.
    //
    ULONG CurrentBaud;

    //
    // This is the number of characters read since the XoffCounter
    // was started.  This variable is only accessed at device level.
    // If it is greater than zero, it implies that there is an
    // XoffCounter ioctl in the queue.
    //
    LONG CountSinceXoff;

    //
    // This ulong is incremented each time something trys to start
    // the execution path that tries to lower the RTS line when
    // doing transmit toggling.  If it "bumps" into another path
    // (indicated by a false return value from queueing a dpc
    // and a TRUE return value tring to start a timer) it will
    // decrement the count.  These increments and decrements
    // are all done at device level.  Note that in the case
    // of a bump while trying to start the timer, we have to
    // go up to device level to do the decrement.
    //
    ULONG CountOfTryingToLowerRTS;

    //
    // This ULONG is used to keep track of the "named" (in ntddser.h)
    // baud rates that this particular device supports.
    //
    ULONG SupportedBauds;

    //
    // This value holds the span (in units of bytes) of the register
    // set controlling this port.  This is constant over the life
    // of the port.
    //
    ULONG RuntimeLength;

    //
    // This value holds the span (in units of bytes) of the interrupt
    // status register associated with this port.  This is constant
    // over the life of the port.
    //
    ULONG BoardMemoryLength;

    //
    // The number of characters to push out if a fifo is present.
    //
    ULONG TxFifoAmount;

    //
    // Set to indicate that it is ok to share interrupts within the device.
    //
    ULONG PermitShare;

    //
    // Holds the timeout controls for the device.  This value
    // is set by the Ioctl processing.
    //
    // It should only be accessed under protection of the control
    // lock since more than one request can be in the control dispatch
    // routine at one time.
    //
    SERIAL_TIMEOUTS Timeouts;

    //
    // This holds the various characters that are used
    // for replacement on errors and also for flow control.
    //
    // They are only set at interrupt level.
    //
    SERIAL_CHARS SpecialChars;

    //
    // This structure holds the handshake and control flow
    // settings for the serial driver.
    //
    // It is only set at interrupt level.  It can be
    // be read at any level with the control lock held.
    //
    SERIAL_HANDFLOW HandFlow;

    //
    // Holds performance statistics that applications can query.
    // Reset on each open.  Only set at device level.
    //
    SERIALPERF_STATS PerfStats;

    //
    // This holds what we beleive to be the current value of
    // the line control register.
    //
    // It should only be accessed under protection of the control
    // lock since more than one request can be in the control dispatch
    // routine at one time.
    //
    UCHAR msvr;
    UCHAR cor1;

    //
    // We keep track of whether the somebody has the device currently
    // opened with a simple boolean.  We need to know this so that
    // spurious interrupts from the device (especially during initialization)
    // will be ignored.  This value is only accessed in the ISR and
    // is only set via synchronization routines.  We may be able
    // to get rid of this boolean when the code is more fleshed out.
    //
    BOOLEAN DeviceIsOpened;

    //
    // This is only accessed at interrupt level.  It keeps track
    // of whether the holding register is empty.
    //
    BOOLEAN HoldingEmpty;

    //
    // This variable is only accessed at interrupt level.  It
    // indicates that we want to transmit a character immediately.
    // That is - in front of any characters that could be transmitting
    // from a normal write.
    //
    BOOLEAN TransmitImmediate;

    //
    // This variable is only accessed at interrupt level.  Whenever
    // a wait is initiated this variable is set to false.
    // Whenever any kind of character is written it is set to true.
    // Whenever the write queue is found to be empty the code that
    // is processing that completing irp will synchonize with the interrupt.
    // If this synchronization code finds that the variable is true and that
    // there is a wait on the transmit queue being empty then it is
    // certain that the queue was emptied and that it has happened since
    // the wait was initiated.
    //
    BOOLEAN EmptiedTransmit;

    //
    // This simply indicates that the port associated with this
    // extension is part of a multiport card.
    //
//    BOOLEAN PortOnAMultiportCard;


    //
    // We keep the following values around so that we can connect
    // to the interrupt and report resources after the configuration
    // record is gone.
    //
    ULONG Vector;
    KIRQL Irql;
    ULONG OriginalVector;
    ULONG OriginalIrql;
    KINTERRUPT_MODE InterruptMode;
    KAFFINITY ProcessorAffinity;
    ULONG RuntimeAddressSpace;
    ULONG BoardMemoryAddressSpace;
    ULONG BusNumber;
    INTERFACE_TYPE InterfaceType;

    //
    // Port index no for multiport devices
    //
    ULONG PortIndex;

    //
    // We hold the character that should be transmitted immediately.
    //
    // Note that we can't use this to determine whether there is
    // a character to send because the character to send could be
    // zero.
    //
    UCHAR ImmediateChar;

    //
    // This holds the mask that will be used to mask off unwanted
    // data bits of the received data (valid data bits can be 5,6,7,8)
    // The mask will normally be 0xff.  This is set while the control
    // lock is held since it wouldn't have adverse effects on the
    // isr if it is changed in the middle of reading characters.
    // (What it would do to the app is another question - but then
    // the app asked the driver to do it.)
    //
    UCHAR ValidDataMask;

    //
    // The application can turn on a mode,via the
    // IOCTL_CYY_LSRMST_INSERT ioctl, that will cause the
    // serial driver to insert the line status or the modem
    // status into the RX stream.  The parameter with the ioctl
    // is a pointer to a UCHAR.  If the value of the UCHAR is
    // zero, then no insertion will ever take place.  If the
    // value of the UCHAR is non-zero (and not equal to the
    // xon/xoff characters), then the serial driver will insert.
    //
    UCHAR EscapeChar;

// REMOVED FANNY
//    //
//    // This boolean will be true if a 16550 is present *and* enabled.
//    //
//    BOOLEAN FifoPresent;
//
//    //
//    // This denotes that this particular port is an on the motherboard
//    // port for the Jensen hardware.  On these ports the OUT2 bit
//    // which is used to enable/disable interrupts is always hight.
//    //
//    BOOLEAN Jensen;

    //
    // This is the water mark that the rxfifo should be
    // set to when the fifo is turned on.  This is not the actual
    // value, but the encoded value that goes into the register.
    //
    UCHAR RxFifoTrigger;

    //
    // Says whether this device can share interrupts with devices
    // other than serial devices.
    //
    BOOLEAN InterruptShareable;

    //
    // Records whether we actually created the symbolic link name
    // at driver load time.  If we didn't create it, we won't try
    // to distry it when we unload.
    //
    BOOLEAN CreatedSymbolicLink;

    //
    // Records whether we actually created an entry in SERIALCOMM
    // at driver load time.  If we didn't create it, we won't try
    // to destroy it when the device is removed.
    //
    BOOLEAN CreatedSerialCommEntry;

    //
    // We place all of the kernel and Io subsystem "opaque" structures
    // at the end of the extension.  We don't care about their contents.
    //

    //
    // This lock will be used to protect various fields in
    // the extension that are set (& read) in the extension
    // by the io controls.
    //
    KSPIN_LOCK ControlLock;

    //
    // This lock will be used to protect the accept / reject state
    // transitions and flags of the driver  It must be acquired
    // before a cancel lock
    //

    KSPIN_LOCK FlagsLock;

    //
    // This points to a DPC used to complete read requests.
    //
    KDPC CompleteWriteDpc;

    //
    // This points to a DPC used to complete read requests.
    //
    KDPC CompleteReadDpc;

    //
    // This dpc is fired off if the timer for the total timeout
    // for the read expires.  It will execute a dpc routine that
    // will cause the current read to complete.
    //
    //
    KDPC TotalReadTimeoutDpc;

    //
    // This dpc is fired off if the timer for the interval timeout
    // expires.  If no more characters have been read then the
    // dpc routine will cause the read to complete.  However, if
    // more characters have been read then the dpc routine will
    // resubmit the timer.
    //
    KDPC IntervalReadTimeoutDpc;

    //
    // This dpc is fired off if the timer for the total timeout
    // for the write expires.  It will execute a dpc routine that
    // will cause the current write to complete.
    //
    //
    KDPC TotalWriteTimeoutDpc;

    //
    // This dpc is fired off if a comm error occurs.  It will
    // execute a dpc routine that will cancel all pending reads
    // and writes.
    //
    KDPC CommErrorDpc;

    //
    // This dpc is fired off if an event occurs and there was
    // a irp waiting on that event.  A dpc routine will execute
    // that completes the irp.
    //
    KDPC CommWaitDpc;

    //
    // This dpc is fired off when the transmit immediate char
    // character is given to the hardware.  It will simply complete
    // the irp.
    //
    KDPC CompleteImmediateDpc;

    //
    // This dpc is fired off if the transmit immediate char
    // character times out.  The dpc routine will "grab" the
    // irp from the isr and time it out.
    //
    KDPC TotalImmediateTimeoutDpc;

    //
    // This dpc is fired off if the timer used to "timeout" counting
    // the number of characters received after the Xoff ioctl is started
    // expired.
    //
    KDPC XoffCountTimeoutDpc;

    //
    // This dpc is fired off if the xoff counter actually runs down
    // to zero.
    //
    KDPC XoffCountCompleteDpc;

    //
    // This dpc is fired off only from device level to start off
    // a timer that will queue a dpc to check if the RTS line
    // should be lowered when we are doing transmit toggling.
    //
    KDPC StartTimerLowerRTSDpc;

    //
    // This dpc is fired off when a timer expires (after one
    // character time), so that code can be invoked that will
    // check to see if we should lower the RTS line when
    // doing transmit toggling.
    //
    KDPC PerhapsLowerRTSDpc;

    //
    // This DPC is fired to set an event stating that all other
    // DPC's have been finish for this device extension so that
    // paged code may be unlocked.
    //

    KDPC IsrUnlockPagesDpc;

    //
    // This is the kernal timer structure used to handle
    // total read request timing.
    //
    KTIMER ReadRequestTotalTimer;

    //
    // This is the kernal timer structure used to handle
    // interval read request timing.
    //
    KTIMER ReadRequestIntervalTimer;

    //
    // This is the kernal timer structure used to handle
    // total time request timing.
    //
    KTIMER WriteRequestTotalTimer;

    //
    // This is the kernal timer structure used to handle
    // total time request timing.
    //
    KTIMER ImmediateTotalTimer;

    //
    // This timer is used to timeout the xoff counter
    // io.
    //
    KTIMER XoffCountTimer;

    //
    // This timer is used to invoke a dpc one character time
    // after the timer is set.  That dpc will be used to check
    // whether we should lower the RTS line if we are doing
    // transmit toggling.
    //
    KTIMER LowerRTSTimer;
	
    //
    // This is a pointer to the next lower device in the IRP stack.
    //

    PDEVICE_OBJECT LowerDeviceObject;

    //
    // This is where keep track of the power state the device is in.
    //

    DEVICE_POWER_STATE PowerState;

    //
    // Pointer to the driver object
    //

    PDRIVER_OBJECT DriverObject;


    //
    // Event used to do some synchronization with the devices underneath me
    // (namely ACPI)
    //

    KEVENT SerialSyncEvent;


    //
    // String where we keep the symbolic link that is returned to us when we
    // register our device under the COMM class with the Plug and Play manager.
    //

    UNICODE_STRING DeviceClassSymbolicName;

    //
    // Count of pending IRP's
    //

    ULONG PendingIRPCnt;

    //
    // Accepting requests?
    //

    ULONG DevicePNPAccept;

    //
    // No IRP's pending event
    //

    KEVENT PendingIRPEvent;

    //
    // PNP State
    //

    ULONG PNPState;

    //
    // Misc Flags
    //

    ULONG Flags;

    //
    // Open count
    //

    LONG OpenCount;

    //
    // Start sync event
    //

    KEVENT CyyStartEvent;

    //
    // Current state during powerdown
    //

    CYY_DEVICE_STATE DeviceState;

    //
    // Device stack capabilites
    //

    DEVICE_POWER_STATE DeviceStateMap[PowerSystemMaximum];

    //
    // Event to signal transition to D0 completion
    //

    KEVENT PowerD0Event;

    //
    // List of stalled IRP's
    //

    LIST_ENTRY StalledIrpQueue;

    //
    // Mutex on open status
    //

    FAST_MUTEX OpenMutex;

    //
    // Mutex on close
    //

    FAST_MUTEX CloseMutex;

    //
    // TRUE if we own power policy
    //

    BOOLEAN OwnsPowerPolicy;

    //
    // SystemWake from devcaps
    //

    SYSTEM_POWER_STATE SystemWake;

    //
    // DeviceWake from devcaps
    //

    DEVICE_POWER_STATE DeviceWake;

    //
    // Our PDO
    //

    PDEVICE_OBJECT Pdo;

    //
    // Should we enable wakeup
    //

    BOOLEAN SendWaitWake;

    //
    // Pending wait wake IRP
    //

    PIRP PendingWakeIrp;

    //
    // WMI Information
    //

    WMILIB_CONTEXT WmiLibInfo;

    //
    // Name to use as WMI identifier
    //

    UNICODE_STRING WmiIdentifier;

    //
    // WMI Comm Data
    //

    SERIAL_WMI_COMM_DATA WmiCommData;

    //
    // WMI HW Data
    //

    SERIAL_WMI_HW_DATA WmiHwData;

    //
    // WMI Performance Data
    //

    SERIAL_WMI_PERF_DATA WmiPerfData;

    //
    // Pending DPC count
    //

    ULONG DpcCount;

    //
    // Pending DPC event
    //

    KEVENT PendingDpcEvent;

    //
    // Should we expose external interfaces?
    //

    ULONG SkipNaming;

    
    //
    // CD1400 clock (Revision G runs at 25Mhz, later versions runs at 60Mhz)
    //
    ULONG CDClock;
	
	//
	// MSVR register that controls RTS.
	//
	ULONG MSVR_RTS;
	
	//
	// MSVR register that controls DTR.
	//
	ULONG MSVR_DTR;
	
	//
	// RTS bit in the MSVR register.
	//
	UCHAR RTSset;
	
	//
	// DTR bit in the MSVR register.
	//
	UCHAR DTRset;

	//
	// Receive Time-out Period Register.
	//
	ULONG Rtpr;

	//
	// Com port number.
	//
	//ULONG Com;
		
	//
	// This flag tells how the ISR should handle Break.
	//
	ULONG BreakCmd;
				
	//
	// Flag to indicate if Command Failure error was already logged.
	// Only one log per driver load. Otherwise, the system may crash if 
	// too many logs start happening.
	//
	BOOLEAN CmdFailureLog;

   //
   // It indicates if the board is PCI or ISA.
   //
   ULONG IsPci;

   //
   // PCI slot where the board is inserted.
   //
   ULONG PciSlot;

   //
   // Flag to indicate that COR3 was set using RxFifoTrigger set by application
   //
   BOOLEAN RxFifoTriggerUsed;

    } CYY_DEVICE_EXTENSION,*PCYY_DEVICE_EXTENSION;

#define CYY_PNPACCEPT_OK                 0x0L
#define CYY_PNPACCEPT_REMOVING           0x1L
#define CYY_PNPACCEPT_STOPPING           0x2L
#define CYY_PNPACCEPT_STOPPED            0x4L
#define CYY_PNPACCEPT_SURPRISE_REMOVING  0x8L

#define CYY_PNP_ADDED                    0x0L
#define CYY_PNP_STARTED                  0x1L
#define CYY_PNP_QSTOP                    0x2L
#define CYY_PNP_STOPPING                 0x3L
#define CYY_PNP_QREMOVE                  0x4L
#define CYY_PNP_REMOVING                 0x5L
#define CYY_PNP_RESTARTING               0x6L

#define CYY_FLAGS_CLEAR                  0x0L
#define CYY_FLAGS_STARTED                0x1L
#define CYY_FLAGS_STOPPED                0x2L
#define CYY_FLAGS_BROKENHW               0x4L


//
// When dealing with a multi-port device (that is possibly
// daisy chained with other multi-port device), the interrupt
// service routine will actually be a routine that determines
// which port on which board is actually causing the interrupt.
//
// The following structure is used so that only one device
// extension will actually need to connect to the interrupt.
// The following structure which is passed to the interrupt
// service routine contains the addresses of all of the
// interrupt status registers (there will be multiple
// status registers when multi-port cards are chained).  It
// will contain the addresses of all the extensions whose
// devices are being serviced by this interrupt.
//

typedef struct _CYY_DISPATCH {
    PUCHAR  Cd1400[CYY_MAX_PORTS];
    PCYY_DEVICE_EXTENSION Extensions[CYY_MAX_PORTS];
    ULONG   IsPci;
    } CYY_DISPATCH,*PCYY_DISPATCH;

//
// We use this to query into the registry as to whether we
// should break at driver entry.
//

extern CYY_REGISTRY_DATA    driverDefaults;


//
// This is exported from the kernel.  It is used to point
// to the address that the kernel debugger is using.
//

extern PUCHAR *KdComPortInUse;

typedef enum _CYY_MEM_COMPARES {
    AddressesAreEqual,
    AddressesOverlap,
    AddressesAreDisjoint
    } CYY_MEM_COMPARES,*PCYY_MEM_COMPARES;

typedef struct _CYY_GLOBALS {
   LIST_ENTRY AllDevObjs;
   PVOID PAGESER_Handle;
   UNICODE_STRING RegistryPath;
   KSPIN_LOCK GlobalsSpinLock;
#if DBG
   ULONG PAGESER_Count;
#endif // DBG
} CYY_GLOBALS, *PCYY_GLOBALS;

extern CYY_GLOBALS CyyGlobals;

typedef struct _SERIAL_PTR_CTX {
   ULONG isPointer;
   PHYSICAL_ADDRESS Port;
   ULONG Vector;
} SERIAL_PTR_CTX, *PSERIAL_PTR_CTX;

#define DEVICE_OBJECT_NAME_LENGTH       128
#define SYMBOLIC_NAME_LENGTH            128
#define SERIAL_DEVICE_MAP               L"SERIALCOMM"

//
// Return values for mouse detection callback
//

#define SERIAL_FOUNDPOINTER_PORT   1
#define SERIAL_FOUNDPOINTER_VECTOR 2


#define CyyCompleteRequest(PDevExt, PIrp, PriBoost) \
   { \
      CyyDbgPrintEx(CYYIRPPATH, "Complete Irp: %X\n", (PIrp)); \
      IoCompleteRequest((PIrp), (PriBoost)); \
      CyyIRPEpilogue((PDevExt)); \
   }

#define SERIAL_WMI_GUID_LIST_SIZE 5

extern WMIGUIDREGINFO SerialWmiGuidList[SERIAL_WMI_GUID_LIST_SIZE];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyypurge.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyypurge.c
*	
*   Description:    This module contains the code related to purge
*                   operations in the Cyclom-Y Port driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,CyyStartPurge)
#pragma alloc_text(PAGESER,CyyPurgeInterruptBuff)
#endif


NTSTATUS
CyyStartPurge(
    IN PCYY_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    Depending on the mask in the current irp, purge the interrupt
    buffer, the read queue, or the write queue, or all of the above.

Arguments:

    Extension - Pointer to the device extension.

Return Value:

    Will return STATUS_SUCCESS always.  This is reasonable
    since the DPC completion code that calls this routine doesn't
    care and the purge request always goes through to completion
    once it's started.

--*/

{

    PIRP NewIrp;

    CYY_LOCKED_PAGED_CODE();

    do {

        ULONG Mask;

        Mask = *((ULONG *)
                 (Extension->CurrentPurgeIrp->AssociatedIrp.SystemBuffer));

        if (Mask & SERIAL_PURGE_TXABORT) {

            CyyKillAllReadsOrWrites(
                Extension->DeviceObject,
                &Extension->WriteQueue,
                &Extension->CurrentWriteIrp
                );

            CyyKillAllReadsOrWrites(
                Extension->DeviceObject,
                &Extension->WriteQueue,
                &Extension->CurrentXoffIrp
                );

        }

        if (Mask & SERIAL_PURGE_RXABORT) {

            CyyKillAllReadsOrWrites(
                Extension->DeviceObject,
                &Extension->ReadQueue,
                &Extension->CurrentReadIrp
                );

        }

        if (Mask & SERIAL_PURGE_RXCLEAR) {

            KIRQL OldIrql;

            //
            // Clean out the interrupt buffer.
            //
            // Note that we do this under protection of the
            // the drivers control lock so that we don't hose
            // the pointers if there is currently a read that
            // is reading out of the buffer.
            //

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            KeSynchronizeExecution(
                Extension->Interrupt,
                CyyPurgeInterruptBuff,
                Extension
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

        }


        Extension->CurrentPurgeIrp->IoStatus.Status = STATUS_SUCCESS;
        Extension->CurrentPurgeIrp->IoStatus.Information = 0;

        CyyGetNextIrp(
            &Extension->CurrentPurgeIrp,
            &Extension->PurgeQueue,
            &NewIrp,
            TRUE,
   			Extension
            );

    } while (NewIrp);

    return STATUS_SUCCESS;

}

BOOLEAN
CyyPurgeInterruptBuff(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine simply resets the interrupt (typeahead) buffer.

    NOTE: This routine is being called from KeSynchronizeExecution.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = Context;
    CYY_LOCKED_PAGED_CODE();


    //
    // The typeahead buffer is by definition empty if there
    // currently is a read owned by the isr.
    //


    if (Extension->ReadBufferBase == Extension->InterruptReadBuffer) {

        Extension->CurrentCharSlot = Extension->InterruptReadBuffer;
        Extension->FirstReadableChar = Extension->InterruptReadBuffer;
        Extension->LastCharSlot = Extension->InterruptReadBuffer +
                                      (Extension->BufferSize - 1);
        Extension->CharsInInterruptBuffer = 0;


        CyyHandleReducedIntBuffer(Extension);

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyyqset.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyyqset.c
*	
*   Description:    This module contains the code related to query/set
*                   file operations in the Cyclom-Y Port driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESRP0,CyyQueryInformationFile)
#pragma alloc_text(PAGESRP0,CyySetInformationFile)
#endif


NTSTATUS
CyyQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*--------------------------------------------------------------------------
    CyyQueryInformationFile()
    
    Routine Description: This routine is used to query the end of file
    information on the opened serial port. Any other file information
    request is retured with an invalid parameter.
    This routine always returns an end of file of 0.

    Arguments:

    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request

    Return Value: The function value is the final status of the call
--------------------------------------------------------------------------*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;	// current stack location
    
    NTSTATUS status;

    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE();

    if ((status = CyyIRPPrologue(Irp,
                                    (PCYY_DEVICE_EXTENSION)DeviceObject->
                                    DeviceExtension)) != STATUS_SUCCESS) {
      CyyCompleteRequest((PCYY_DEVICE_EXTENSION)DeviceObject->
                            DeviceExtension, Irp, IO_NO_INCREMENT);
      return status;
    }

    CyyDbgPrintEx(CYYIRPPATH, "Dispatch entry for: %x\n", Irp);

    if (CyyCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS) {

        return STATUS_CANCELLED;
    }
    
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;
    if (IrpSp->Parameters.QueryFile.FileInformationClass ==
        FileStandardInformation) {

        PFILE_STANDARD_INFORMATION Buf = Irp->AssociatedIrp.SystemBuffer;

        Buf->AllocationSize.QuadPart = 0;
        Buf->EndOfFile = Buf->AllocationSize;
        Buf->NumberOfLinks = 0;
        Buf->DeletePending = FALSE;
        Buf->Directory = FALSE;
        Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);

    } else if (IrpSp->Parameters.QueryFile.FileInformationClass ==
               FilePositionInformation) {

        ((PFILE_POSITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->
            CurrentByteOffset.QuadPart = 0;
        Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);

    } else {
        Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
    }

    CyyCompleteRequest((PCYY_DEVICE_EXTENSION)DeviceObject->
                          DeviceExtension, Irp, 0);
    return Status;
}

NTSTATUS
CyySetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*--------------------------------------------------------------------------
    CyySetInformationFile()
    
    Routine Description: This routine is used to set the end of file
    information on the opened serial port. Any other file information
    request is retured with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

    Arguments:

    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request

    Return Value: The function value is the final status of the call
--------------------------------------------------------------------------*/
{
    NTSTATUS Status;
    
    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE();

    if ((Status = CyyIRPPrologue(Irp,
                                 (PCYY_DEVICE_EXTENSION)DeviceObject->
                                 DeviceExtension)) != STATUS_SUCCESS) {
      CyyCompleteRequest((PCYY_DEVICE_EXTENSION)DeviceObject->
                         DeviceExtension, Irp, IO_NO_INCREMENT);
      return Status;
   }

    CyyDbgPrintEx(CYYIRPPATH, "Dispatch entry for: %x\n", Irp);

    if (CyyCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS) {

        return STATUS_CANCELLED;
    }
    
    Irp->IoStatus.Information = 0L;
    if ((IoGetCurrentIrpStackLocation(Irp)->
            Parameters.SetFile.FileInformationClass ==
         FileEndOfFileInformation) ||
        (IoGetCurrentIrpStackLocation(Irp)->
            Parameters.SetFile.FileInformationClass ==
         FileAllocationInformation)) {

        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Status = Status;

    CyyCompleteRequest((PCYY_DEVICE_EXTENSION)DeviceObject->
                        DeviceExtension, Irp, 0);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyyread.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyyread,c
*	
*   Description:    This module contains the code related to read
*                   operations in the Cyclom-Y Port driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#include "precomp.h"


VOID
CyyCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
CyyGrabReadFromIsr(
    IN PVOID Context
    );

BOOLEAN
CyyUpdateReadByIsr(
    IN PVOID Context
    );

ULONG
CyyGetCharsFromIntBuffer(
    PCYY_DEVICE_EXTENSION Extension
    );

BOOLEAN
CyyUpdateInterruptBuffer(
    IN PVOID Context
    );

BOOLEAN
CyyUpdateAndSwitchToUser(
    IN PVOID Context
    );

NTSTATUS
CyyResizeBuffer(
    IN PCYY_DEVICE_EXTENSION Extension
    );

ULONG
CyyMoveToNewIntBuffer(
    PCYY_DEVICE_EXTENSION Extension,
    PUCHAR NewBuffer
    );

BOOLEAN
CyyUpdateAndSwitchToNew(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,CyyRead)
#pragma alloc_text(PAGESER,CyyStartRead)
#pragma alloc_text(PAGESER,CyyCancelCurrentRead)
#pragma alloc_text(PAGESER,CyyGrabReadFromIsr)
#pragma alloc_text(PAGESER,CyyUpdateReadByIsr)
#pragma alloc_text(PAGESER,CyyGetCharsFromIntBuffer)
#pragma alloc_text(PAGESER,CyyUpdateInterruptBuffer)
#pragma alloc_text(PAGESER,CyyUpdateAndSwitchToUser)
#pragma alloc_text(PAGESER,CyyResizeBuffer)
#pragma alloc_text(PAGESER,CyyMoveToNewIntBuffer)
#pragma alloc_text(PAGESER,CyyUpdateAndSwitchToNew)
#endif

//removed in Win2000
//#pragma alloc_text(PAGESER,CyyCompleteRead)
//#pragma alloc_text(PAGESER,CyyReadTimeout)
//#pragma alloc_text(PAGESER,CyyIntervalReadTimeout)


NTSTATUS
CyyRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*--------------------------------------------------------------------------
    CyyRead()
    
    Routine Description: This is the dispatch routine for reading. It
    validates the parameters for the read request and if all is ok then
    it places the request on the work queue.

    Arguments:

    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request

    Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return the status returned by
    the actual start read routine.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    BOOLEAN acceptingIRPs;
    NTSTATUS status;

    CYY_LOCKED_PAGED_CODE();

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyRead(%X, %X)\n", DeviceObject,
                  Irp);

    if ((status = CyyIRPPrologue(Irp, extension)) != STATUS_SUCCESS) {
      CyyCompleteRequest(extension, Irp, IO_NO_INCREMENT);
      CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyRead (1) %X\n", status);
      return status;
    }

    CyyDbgPrintEx(CYYIRPPATH, "Dispatch entry for: %x\n", Irp);

    if (CyyCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS) {

       CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyRead (2) %X\n",
                        STATUS_CANCELLED);
        return STATUS_CANCELLED;
    }

    Irp->IoStatus.Information = 0L;

    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length) {

       //
       // Well it looks like we actually have to do some
       // work.  Put the read on the queue so that we can
       // process it when our previous reads are done.
       //

       status = CyyStartOrQueue(extension, Irp, &extension->ReadQueue,
                                &extension->CurrentReadIrp, CyyStartRead);

       CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyRead (3) %X\n", status);

       return status;

    } else {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        CyyCompleteRequest(extension, Irp, 0);

        CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyRead (4) %X\n",
                      STATUS_SUCCESS);

        return STATUS_SUCCESS;

    }

}

NTSTATUS
CyyStartRead(
    IN PCYY_DEVICE_EXTENSION Extension
    )
/*--------------------------------------------------------------------------
    CyyStartRead()
    
    Routine Description: This routine is used to start off any read.
    It initializes the Iostatus fields of the irp.  It will set up any
    timers that are used to control the read.  It will attempt to
    complete the read from data already in the interrupt buffer.  If the
    read can be completed quickly it will start off another if
    necessary.

    Arguments:

    Extension - Simply a pointer to the serial device extension.

    Return Value: This routine will return the status of the first read
    irp.  This is useful in that if we have a read that can complete
    right away (AND there had been nothing in the queue before it) the
    read could return SUCCESS and the application won't have to do a wait.
--------------------------------------------------------------------------*/
{
    SERIAL_UPDATE_CHAR updateChar;
    PIRP newIrp;
    KIRQL oldIrql;
    KIRQL controlIrql;
    BOOLEAN returnWithWhatsPresent;
    BOOLEAN os2ssreturn;
    BOOLEAN crunchDownToOne;
    BOOLEAN useTotalTimer;
    BOOLEAN useIntervalTimer;
    ULONG multiplierVal;
    ULONG constantVal;
    LARGE_INTEGER totalTime;
    SERIAL_TIMEOUTS timeoutsForIrp;
    BOOLEAN setFirstStatus = FALSE;
    NTSTATUS firstStatus;

    CYY_LOCKED_PAGED_CODE();

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyStartRead(%X)\n", Extension);

    updateChar.Extension = Extension;

    do {
        // Check to see if this is a resize request.  If it is
        // then go to a routine that specializes in that.

        if (IoGetCurrentIrpStackLocation(Extension->CurrentReadIrp)
            ->MajorFunction != IRP_MJ_READ) {

            NTSTATUS localStatus = CyyResizeBuffer(Extension);
            if (!setFirstStatus) {
                firstStatus = localStatus;
                setFirstStatus = TRUE;
            }
        } else {
            Extension->NumberNeededForRead =
                IoGetCurrentIrpStackLocation(Extension->CurrentReadIrp)
                    ->Parameters.Read.Length;

            // Calculate the timeout value needed for the
            // request.  Note that the values stored in the
            // timeout record are in milliseconds.

            useTotalTimer = FALSE;
            returnWithWhatsPresent = FALSE;
            os2ssreturn = FALSE;
            crunchDownToOne = FALSE;
            useIntervalTimer = FALSE;

            //
            // CIMEXCIMEX -- this is a lie
            //
            // Always initialize the timer objects so that the
            // completion code can tell when it attempts to
            // cancel the timers whether the timers had ever
            // been Set.
            //
            // CIMEXCIMEX -- this is a lie
            //
            // What we want to do is just make sure the timers are
            // cancelled to the best of our ability and move on with
            // life.
            //

            CyyCancelTimer(&Extension->ReadRequestTotalTimer, Extension);
            CyyCancelTimer(&Extension->ReadRequestIntervalTimer, Extension);


//            KeInitializeTimer(&Extension->ReadRequestTotalTimer);
//            KeInitializeTimer(&Extension->ReadRequestIntervalTimer);

            // We get the *current* timeout values to use for timing
            // this read.

            KeAcquireSpinLock(&Extension->ControlLock,&controlIrql);

            timeoutsForIrp = Extension->Timeouts;

            KeReleaseSpinLock(&Extension->ControlLock,controlIrql);

            // Calculate the interval timeout for the read.

            if (timeoutsForIrp.ReadIntervalTimeout &&
                (timeoutsForIrp.ReadIntervalTimeout !=
                 MAXULONG)) {

                useIntervalTimer = TRUE;

                Extension->IntervalTime.QuadPart =
                    UInt32x32To64(
                        timeoutsForIrp.ReadIntervalTimeout,
                        10000
                        );

                if (Extension->IntervalTime.QuadPart >=
                    Extension->CutOverAmount.QuadPart) {

                    Extension->IntervalTimeToUse =
                        &Extension->LongIntervalAmount;
                } else {
                    Extension->IntervalTimeToUse =
                        &Extension->ShortIntervalAmount;
                }
            }

            if (timeoutsForIrp.ReadIntervalTimeout == MAXULONG) {

                //
                // We need to do special return quickly stuff here.
                //
                // 1) If both constant and multiplier are
                //    0 then we return immediately with whatever
                //    we've got, even if it was zero.
                //
                // 2) If constant and multiplier are not MAXULONG
                //    then return immediately if any characters
                //    are present, but if nothing is there, then
                //    use the timeouts as specified.
                //
                // 3) If multiplier is MAXULONG then do as in
                //    "2" but return when the first character
                //    arrives.
                //

                if (!timeoutsForIrp.ReadTotalTimeoutConstant &&
                    !timeoutsForIrp.ReadTotalTimeoutMultiplier) {

                    returnWithWhatsPresent = TRUE;

                } else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                            &&
                           (timeoutsForIrp.ReadTotalTimeoutMultiplier
                            != MAXULONG)) {

                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                } else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                            &&
                           (timeoutsForIrp.ReadTotalTimeoutMultiplier
                            == MAXULONG)) {

                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    crunchDownToOne = TRUE;
                    multiplierVal = 0;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                }

            } else {

                //
                // If both the multiplier and the constant are
                // zero then don't do any total timeout processing.
                //

                if (timeoutsForIrp.ReadTotalTimeoutMultiplier ||
                    timeoutsForIrp.ReadTotalTimeoutConstant) {

                    //
                    // We have some timer values to calculate.
                    //

                    useTotalTimer = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                }

            }

            if (useTotalTimer) {

                totalTime.QuadPart = ((LONGLONG)(UInt32x32To64(
                                          Extension->NumberNeededForRead,
                                          multiplierVal
                                          )
                                          + constantVal))
                                      * -10000;

            }


            //
            // We do this copy in the hope of getting most (if not
            // all) of the characters out of the interrupt buffer.
            //
            // Note that we need to protect this operation with a
            // spinlock since we don't want a purge to hose us.
            //

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &controlIrql
                );

            updateChar.CharsCopied = CyyGetCharsFromIntBuffer(Extension);

            //
            // See if we have any cause to return immediately.
            //

            if (returnWithWhatsPresent || (!Extension->NumberNeededForRead) ||
                (os2ssreturn &&
                 Extension->CurrentReadIrp->IoStatus.Information)) {

                //
                // We got all we needed for this read.
                // Update the number of characters in the
                // interrupt read buffer.
                //

                KeSynchronizeExecution(
                    Extension->Interrupt,
                    CyyUpdateInterruptBuffer,
                    &updateChar
                    );

                KeReleaseSpinLock(
                    &Extension->ControlLock,
                    controlIrql
                    );

                Extension->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;
                if (!setFirstStatus) {

                    firstStatus = STATUS_SUCCESS;
                    setFirstStatus = TRUE;

                }

            } else {

                //
                // The irp might go under control of the isr.  It
                // won't hurt to initialize the reference count
                // right now.
                //

                SERIAL_INIT_REFERENCE(Extension->CurrentReadIrp);

                IoAcquireCancelSpinLock(&oldIrql);

                //
                // We need to see if this irp should be canceled.
                //

                if (Extension->CurrentReadIrp->Cancel) {

                    IoReleaseCancelSpinLock(oldIrql);
                    KeReleaseSpinLock(
                        &Extension->ControlLock,
                        controlIrql
                        );
                    Extension->CurrentReadIrp->IoStatus.Status =
                        STATUS_CANCELLED;
                    Extension->CurrentReadIrp->IoStatus.Information = 0;

                    if (!setFirstStatus) {

                        firstStatus = STATUS_CANCELLED;
                        setFirstStatus = TRUE;

                    }

                } else {

                    //
                    // If we are supposed to crunch the read down to
                    // one character, then update the read length
                    // in the irp and truncate the number needed for
                    // read down to one. Note that if we are doing
                    // this crunching, then the information must be
                    // zero (or we would have completed above) and
                    // the number needed for the read must still be
                    // equal to the read length.
                    //

                    if (crunchDownToOne) {

                        ASSERT(
                            (!Extension->CurrentReadIrp->IoStatus.Information)
                            &&
                            (Extension->NumberNeededForRead ==
                                IoGetCurrentIrpStackLocation(
                                    Extension->CurrentReadIrp
                                    )->Parameters.Read.Length)
                            );

                        Extension->NumberNeededForRead = 1;
                        IoGetCurrentIrpStackLocation(
                            Extension->CurrentReadIrp
                            )->Parameters.Read.Length = 1;

                    }

                    //
                    // We still need to get more characters for this read.
                    // synchronize with the isr so that we can update the
                    // number of characters and if necessary it will have the
                    // isr switch to copying into the users buffer.
                    //

                    KeSynchronizeExecution(
                        Extension->Interrupt,
                        CyyUpdateAndSwitchToUser,
                        &updateChar
                        );

                    if (!updateChar.Completed) {

                        //
                        // The irp still isn't complete.  The
                        // completion routines will end up reinvoking
                        // this routine.  So we simply leave.
                        //
                        // First thought we should start off the total
                        // timer for the read and increment the reference
                        // count that the total timer has on the current
                        // irp.  Note that this is safe, because even if
                        // the io has been satisfied by the isr it can't
                        // complete yet because we still own the cancel
                        // spinlock.
                        //

                        if (useTotalTimer) {

                            SERIAL_SET_REFERENCE(
                                Extension->CurrentReadIrp,
                                SERIAL_REF_TOTAL_TIMER
                                );

                            CyySetTimer(
                                &Extension->ReadRequestTotalTimer,
                                totalTime,
                                &Extension->TotalReadTimeoutDpc,
                                Extension
                                );

                        }

                        if (useIntervalTimer) {

                            SERIAL_SET_REFERENCE(
                                Extension->CurrentReadIrp,
                                SERIAL_REF_INT_TIMER
                                );

                            KeQuerySystemTime(
                                &Extension->LastReadTime
                                );
                            CyySetTimer(
                                &Extension->ReadRequestIntervalTimer,
                                *Extension->IntervalTimeToUse,
                                &Extension->IntervalReadTimeoutDpc,
                                Extension
                                );

                        }

                        IoMarkIrpPending(Extension->CurrentReadIrp);
                        IoReleaseCancelSpinLock(oldIrql);
                        KeReleaseSpinLock(
                            &Extension->ControlLock,
                            controlIrql
                            );
                        if (!setFirstStatus) {

                            firstStatus = STATUS_PENDING;

                        }
                        return firstStatus;

                    } else {

                        IoReleaseCancelSpinLock(oldIrql);
                        KeReleaseSpinLock(
                            &Extension->ControlLock,
                            controlIrql
                            );
                        Extension->CurrentReadIrp->IoStatus.Status =
                            STATUS_SUCCESS;

                        if (!setFirstStatus) {

                            firstStatus = STATUS_SUCCESS;
                            setFirstStatus = TRUE;

                        }

                    }

                }

            }

        }

        //
        // Well the operation is complete.
        //

        CyyGetNextIrp(&Extension->CurrentReadIrp, &Extension->ReadQueue,
                         &newIrp, TRUE, Extension);

    } while (newIrp);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyStartRead %X\n", firstStatus);

    return firstStatus;

}

VOID
CyyCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
/*--------------------------------------------------------------------------
    CyyCompleteRead()
    
    Routine Description: This routine is merely used to complete any read
    that ended up being used by the Isr.  It assumes that the status and
    the information fields of the irp are already correctly filled in.

    Arguments:

    Dpc - Not Used.
    DeferredContext - Really points to the device extension.
    SystemContext1 - Not Used.
    SystemContext2 - Not Used.

    Return Value: None.
--------------------------------------------------------------------------*/

{
    PCYY_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyCompleteRead(%X)\n",
                     extension);

    IoAcquireCancelSpinLock(&oldIrql);

    //
    // We set this to indicate to the interval timer
    // that the read has completed.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    extension->CountOnLastRead = CYY_COMPLETE_READ_COMPLETE;

    CyyTryToCompleteCurrent(
        extension,
        NULL,
        oldIrql,
        STATUS_SUCCESS,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        CyyStartRead,
        CyyGetNextIrp,
        SERIAL_REF_ISR
        );

    CyyDpcEpilogue(extension, Dpc);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyCompleteRead(%X)\n");
}

VOID
CyyCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current read.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PCYY_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    CYY_LOCKED_PAGED_CODE();

    //
    // We set this to indicate to the interval timer
    // that the read has encountered a cancel.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    extension->CountOnLastRead = CYY_COMPLETE_READ_CANCEL;

    CyyTryToCompleteCurrent(
        extension,
        CyyGrabReadFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        CyyStartRead,
        CyyGetNextIrp,
        SERIAL_REF_CANCEL
        );

}

BOOLEAN
CyyGrabReadFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to grab (if possible) the irp from the
    isr.  If it finds that the isr still owns the irp it grabs
    the ipr away (updating the number of characters copied into the
    users buffer).  If it grabs it away it also decrements the
    reference count on the irp since it no longer belongs to the
    isr (and the dpc that would complete it).

    NOTE: This routine assumes that if the current buffer that the
          ISR is copying characters into is the interrupt buffer then
          the dpc has already been queued.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel spin
          lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PCYY_DEVICE_EXTENSION extension = Context;
    CYY_LOCKED_PAGED_CODE();

    if (extension->ReadBufferBase !=
        extension->InterruptReadBuffer) {

        //
        // We need to set the information to the number of characters
        // that the read wanted minus the number of characters that
        // didn't get read into the interrupt buffer.
        //

        extension->CurrentReadIrp->IoStatus.Information =
            IoGetCurrentIrpStackLocation(
                extension->CurrentReadIrp
                )->Parameters.Read.Length -
            ((extension->LastCharSlot - extension->CurrentCharSlot) + 1);

        //
        // Switch back to the interrupt buffer.
        //

        extension->ReadBufferBase = extension->InterruptReadBuffer;
        extension->CurrentCharSlot = extension->InterruptReadBuffer;
        extension->FirstReadableChar = extension->InterruptReadBuffer;
        extension->LastCharSlot = extension->InterruptReadBuffer +
                                      (extension->BufferSize - 1);
        extension->CharsInInterruptBuffer = 0;

        SERIAL_CLEAR_REFERENCE(
            extension->CurrentReadIrp,
            SERIAL_REF_ISR
            );

    }

    return FALSE;

}

VOID
CyyReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is used to complete a read because its total
    timer has expired.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PCYY_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyReadTimeout(%X)\n",
                     extension);

    IoAcquireCancelSpinLock(&oldIrql);

    //
    // We set this to indicate to the interval timer
    // that the read has completed due to total timeout.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    extension->CountOnLastRead = CYY_COMPLETE_READ_TOTAL;

    CyyTryToCompleteCurrent(
        extension,
        CyyGrabReadFromIsr,
        oldIrql,
        STATUS_TIMEOUT,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        CyyStartRead,
        CyyGetNextIrp,
        SERIAL_REF_TOTAL_TIMER
        );

    CyyDpcEpilogue(extension, Dpc);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyReadTimeout\n");
}

BOOLEAN
CyyUpdateReadByIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to update the count of characters read
    by the isr since the last interval timer experation.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel spin
          lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PCYY_DEVICE_EXTENSION extension = Context;
    CYY_LOCKED_PAGED_CODE();

    extension->CountOnLastRead = extension->ReadByIsr;
    extension->ReadByIsr = 0;

    return FALSE;

}

VOID
CyyIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is used timeout the request if the time between
    characters exceed the interval time.  A global is kept in
    the device extension that records the count of characters read
    the last the last time this routine was invoked (This dpc
    will resubmit the timer if the count has changed).  If the
    count has not changed then this routine will attempt to complete
    the irp.  Note the special case of the last count being zero.
    The timer isn't really in effect until the first character is
    read.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PCYY_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&oldIrql);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyIntervalReadTimeout(%X)\n",
                     extension);

    if (extension->CountOnLastRead == CYY_COMPLETE_READ_TOTAL) {

        //
        // This value is only set by the total
        // timer to indicate that it has fired.
        // If so, then we should simply try to complete.
        //

        CyyTryToCompleteCurrent(
            extension,
            CyyGrabReadFromIsr,
            oldIrql,
            STATUS_TIMEOUT,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            CyyStartRead,
            CyyGetNextIrp,
            SERIAL_REF_INT_TIMER
            );

    } else if (extension->CountOnLastRead == CYY_COMPLETE_READ_COMPLETE) {

        //
        // This value is only set by the regular
        // completion routine.
        //
        // If so, then we should simply try to complete.
        //

        CyyTryToCompleteCurrent(
            extension,
            CyyGrabReadFromIsr,
            oldIrql,
            STATUS_SUCCESS,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            CyyStartRead,
            CyyGetNextIrp,
            SERIAL_REF_INT_TIMER
            );

    } else if (extension->CountOnLastRead == CYY_COMPLETE_READ_CANCEL) {

        //
        // This value is only set by the cancel
        // read routine.
        //
        // If so, then we should simply try to complete.
        //

        CyyTryToCompleteCurrent(
            extension,
            CyyGrabReadFromIsr,
            oldIrql,
            STATUS_CANCELLED,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            CyyStartRead,
            CyyGetNextIrp,
            SERIAL_REF_INT_TIMER
            );

    } else if (extension->CountOnLastRead || extension->ReadByIsr) {

        //
        // Something has happened since we last came here.  We
        // check to see if the ISR has read in any more characters.
        // If it did then we should update the isr's read count
        // and resubmit the timer.
        //

        if (extension->ReadByIsr) {

            KeSynchronizeExecution(
                extension->Interrupt,
                CyyUpdateReadByIsr,
                extension
                );

            //
            // Save off the "last" time something was read.
            // As we come back to this routine we will compare
            // the current time to the "last" time.  If the
            // difference is ever larger then the interval
            // requested by the user, then time out the request.
            //

            KeQuerySystemTime(
                &extension->LastReadTime
                );

            CyySetTimer(
                &extension->ReadRequestIntervalTimer,
                *extension->IntervalTimeToUse,
                &extension->IntervalReadTimeoutDpc,
                extension
                );

            IoReleaseCancelSpinLock(oldIrql);

        } else {

            //
            // Take the difference between the current time
            // and the last time we had characters and
            // see if it is greater then the interval time.
            // if it is, then time out the request.  Otherwise
            // go away again for a while.
            //

            //
            // No characters read in the interval time.  Kill
            // this read.
            //

            LARGE_INTEGER currentTime;

            KeQuerySystemTime(
                &currentTime
                );

            if ((currentTime.QuadPart - extension->LastReadTime.QuadPart) >=
                extension->IntervalTime.QuadPart) {

                CyyTryToCompleteCurrent(
                    extension,
                    CyyGrabReadFromIsr,
                    oldIrql,
                    STATUS_TIMEOUT,
                    &extension->CurrentReadIrp,
                    &extension->ReadQueue,
                    &extension->ReadRequestIntervalTimer,
                    &extension->ReadRequestTotalTimer,
                    CyyStartRead,
                    CyyGetNextIrp,
                    SERIAL_REF_INT_TIMER
                    );

            } else {

                CyySetTimer(
                    &extension->ReadRequestIntervalTimer,
                    *extension->IntervalTimeToUse,
                    &extension->IntervalReadTimeoutDpc,
                    extension
                    );
                IoReleaseCancelSpinLock(oldIrql);

            }


        }

    } else {

        //
        // Timer doesn't really start until the first character.
        // So we should simply resubmit ourselves.
        //

        CyySetTimer(
            &extension->ReadRequestIntervalTimer,
            *extension->IntervalTimeToUse,
            &extension->IntervalReadTimeoutDpc,
            extension
            );

        IoReleaseCancelSpinLock(oldIrql);

    }

    CyyDpcEpilogue(extension, Dpc);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyIntervalReadTimeout\n");
}

ULONG
CyyGetCharsFromIntBuffer(
    PCYY_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine is used to copy any characters out of the interrupt
    buffer into the users buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.  This routine will
    return the number of characters copied so some other routine
    can call a synchronization routine to update what is seen at
    interrupt level.

Arguments:

    Extension - A pointer to the device extension.

Return Value:

    The number of characters that were copied into the user
    buffer.

--*/

{

    //
    // This value will be the number of characters that this
    // routine returns.  It will be the minimum of the number
    // of characters currently in the buffer or the number of
    // characters required for the read.
    //
    ULONG numberOfCharsToGet;

    //
    // This holds the number of characters between the first
    // readable character and - the last character we will read or
    // the real physical end of the buffer (not the last readable
    // character).
    //
    ULONG firstTryNumberToGet;

    CYY_LOCKED_PAGED_CODE();

    //
    // The minimum of the number of characters we need and
    // the number of characters available
    //

    numberOfCharsToGet = Extension->CharsInInterruptBuffer;

    if (numberOfCharsToGet > Extension->NumberNeededForRead) {

        numberOfCharsToGet = Extension->NumberNeededForRead;

    }

    if (numberOfCharsToGet) {

        //
        // This will hold the number of characters between the
        // first available character and the end of the buffer.
        // Note that the buffer could wrap around but for the
        // purposes of the first copy we don't care about that.
        //

        firstTryNumberToGet = (ULONG)(Extension->LastCharSlot -
                               Extension->FirstReadableChar) + 1;

        if (firstTryNumberToGet > numberOfCharsToGet) {

            //
            // The characters don't wrap. Actually they may wrap but
            // we don't care for the purposes of this read since the
            // characters we need are available before the wrap.
            //

            RtlMoveMemory(
                ((PUCHAR)(Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           Extension->CurrentReadIrp
                           )->Parameters.Read.Length
                       - Extension->NumberNeededForRead
                      ),
                Extension->FirstReadableChar,
                numberOfCharsToGet
                );

            Extension->NumberNeededForRead -= numberOfCharsToGet;

            //
            // We now will move the pointer to the first character after
            // what we just copied into the users buffer.
            //
            // We need to check if the stream of readable characters
            // is wrapping around to the beginning of the buffer.
            //
            // Note that we may have just taken the last characters
            // at the end of the buffer.
            //

            if ((Extension->FirstReadableChar + (numberOfCharsToGet - 1)) ==
                Extension->LastCharSlot) {

                Extension->FirstReadableChar = Extension->InterruptReadBuffer;

            } else {

                Extension->FirstReadableChar += numberOfCharsToGet;

            }

        } else {

            //
            // The characters do wrap.  Get up until the end of the buffer.
            //

            RtlMoveMemory(
                ((PUCHAR)(Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           Extension->CurrentReadIrp
                           )->Parameters.Read.Length
                       - Extension->NumberNeededForRead
                      ),
                Extension->FirstReadableChar,
                firstTryNumberToGet
                );

            Extension->NumberNeededForRead -= firstTryNumberToGet;

            //
            // Now get the rest of the characters from the beginning of the
            // buffer.
            //

            RtlMoveMemory(
                ((PUCHAR)(Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           Extension->CurrentReadIrp
                           )->Parameters.Read.Length
                       - Extension->NumberNeededForRead
                      ),
                Extension->InterruptReadBuffer,
                numberOfCharsToGet - firstTryNumberToGet
                );

            Extension->FirstReadableChar = Extension->InterruptReadBuffer +
                                           (numberOfCharsToGet -
                                            firstTryNumberToGet);

            Extension->NumberNeededForRead -= (numberOfCharsToGet -
                                               firstTryNumberToGet);

        }

    }

    Extension->CurrentReadIrp->IoStatus.Information += numberOfCharsToGet;
    return numberOfCharsToGet;

}

BOOLEAN
CyyUpdateInterruptBuffer(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to update the number of characters that
    remain in the interrupt buffer.  We need to use this routine
    since the count could be updated during the update by execution
    of the ISR.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension and count of the number of characters
              that we previously copied into the users buffer.  The
              structure actually has a third field that we don't
              use in this routine.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_UPDATE_CHAR update = Context;
    PCYY_DEVICE_EXTENSION extension = update->Extension;

    CYY_LOCKED_PAGED_CODE();

    ASSERT(extension->CharsInInterruptBuffer >= update->CharsCopied);
    extension->CharsInInterruptBuffer -= update->CharsCopied;

    //
    // Deal with flow control if necessary.
    //

    CyyHandleReducedIntBuffer(extension);


    return FALSE;

}

BOOLEAN
CyyUpdateAndSwitchToUser(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.  If we still don't have enough characters
    to satisfy the read it will then we set things up so that the
    ISR uses the user buffer copy into.

    This routine is also used to update a count that is maintained
    by the ISR to keep track of the number of characters in its buffer.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a count of the number of characters
              that we previously copied into the users buffer, and
              a boolean that we will set that defines whether we
              switched the ISR to copy into the users buffer.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_UPDATE_CHAR updateChar = Context;
    PCYY_DEVICE_EXTENSION extension = updateChar->Extension;

    CYY_LOCKED_PAGED_CODE();

    CyyUpdateInterruptBuffer(Context);

    //
    // There are more characters to get to satisfy this read.
    // Copy any characters that have arrived since we got
    // the last batch.
    //

    updateChar->CharsCopied = CyyGetCharsFromIntBuffer(extension);

    CyyUpdateInterruptBuffer(Context);

    //
    // No more new characters will be "received" until we exit
    // this routine.  We again check to make sure that we
    // haven't satisfied this read, and if we haven't we set things
    // up so that the ISR copies into the user buffer.
    //

    if (extension->NumberNeededForRead) {

        //
        // We shouldn't be switching unless there are no
        // characters left.
        //

        ASSERT(!extension->CharsInInterruptBuffer);

        //
        // We use the following to values to do inteval timing.
        //
        // CountOnLastRead is mostly used to simply prevent
        // the interval timer from timing out before any characters
        // are read. (Interval timing should only be effective
        // after the first character is read.)
        //
        // After the first time the interval timer fires and
        // characters have be read we will simply update with
        // the value of ReadByIsr and then set ReadByIsr to zero.
        // (We do that in a synchronization routine.
        //
        // If the interval timer dpc routine ever encounters
        // ReadByIsr == 0 when CountOnLastRead is non-zero it
        // will timeout the read.
        //
        // (Note that we have a special case of CountOnLastRead
        // < 0.  This is done by the read completion routines other
        // than the total timeout dpc to indicate that the total
        // timeout has expired.)
        //

        extension->CountOnLastRead =
            (LONG)extension->CurrentReadIrp->IoStatus.Information;

        extension->ReadByIsr = 0;

        //
        // By compareing the read buffer base address to the
        // the base address of the interrupt buffer the ISR
        // can determine whether we are using the interrupt
        // buffer or the user buffer.
        //

        extension->ReadBufferBase =
            extension->CurrentReadIrp->AssociatedIrp.SystemBuffer;

        //
        // The current char slot is after the last copied in
        // character.  We know there is always room since we
        // we wouldn't have gotten here if there wasn't.
        //

        extension->CurrentCharSlot = extension->ReadBufferBase +
            extension->CurrentReadIrp->IoStatus.Information;

        //
        // The last position that a character can go is on the
        // last byte of user buffer.  While the actual allocated
        // buffer space may be bigger, we know that there is at
        // least as much as the read length.
        //

        extension->LastCharSlot = extension->ReadBufferBase +
                                      (IoGetCurrentIrpStackLocation(
                                          extension->CurrentReadIrp
                                          )->Parameters.Read.Length
                                       - 1);

        //
        // Mark the irp as being in a cancelable state.
        //

        IoSetCancelRoutine(
            extension->CurrentReadIrp,
            CyyCancelCurrentRead
            );

        //
        // Increment the reference count twice.
        //
        // Once for the Isr owning the irp and once
        // because the cancel routine has a reference
        // to it.
        //

        SERIAL_SET_REFERENCE(
            extension->CurrentReadIrp,
            SERIAL_REF_ISR
            );
        SERIAL_SET_REFERENCE(
            extension->CurrentReadIrp,
            SERIAL_REF_CANCEL
            );

        updateChar->Completed = FALSE;

    } else {

        updateChar->Completed = TRUE;

    }

    return FALSE;

}
//
// We use this structure only to communicate to the synchronization
// routine when we are switching to the resized buffer.
//
typedef struct _SERIAL_RESIZE_PARAMS {
    PCYY_DEVICE_EXTENSION Extension;
    PUCHAR OldBuffer;
    PUCHAR NewBuffer;
    ULONG NewBufferSize;
    ULONG NumberMoved;
    } SERIAL_RESIZE_PARAMS,*PSERIAL_RESIZE_PARAMS;

NTSTATUS
CyyResizeBuffer(
    IN PCYY_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine will process the resize buffer request.
    If size requested for the RX buffer is smaller than
    the current buffer then we will simply return
    STATUS_SUCCESS.  (We don't want to make buffers smaller.
    If we did that then we all of a sudden have "overrun"
    problems to deal with as well as flow control to deal
    with - very painful.)  We ignore the TX buffer size
    request since we don't use a TX buffer.

Arguments:

    Extension - Pointer to the device extension for the port.

Return Value:

    STATUS_SUCCESS if everything worked out ok.
    STATUS_INSUFFICIENT_RESOURCES if we couldn't allocate the
    memory for the buffer.

--*/

{

    PSERIAL_QUEUE_SIZE rs = Extension->CurrentReadIrp->AssociatedIrp
                                                       .SystemBuffer;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(
                                   Extension->CurrentReadIrp
                                   );
    PVOID newBuffer = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    CYY_LOCKED_PAGED_CODE();

    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    Extension->CurrentReadIrp->IoStatus.Information = 0L;
    Extension->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

    if (rs->InSize <= Extension->BufferSize) {

        //
        // Nothing to do.  We don't make buffers smaller.  Just
        // agree with the user.  We must deallocate the memory
        // that was already allocated in the ioctl dispatch routine.
        //

        ExFreePool(newBuffer);

    } else {

        SERIAL_RESIZE_PARAMS rp;
        KIRQL controlIrql;

        //
        // Hmmm, looks like we actually have to go
        // through with this.  We need to move all the
        // data that is in the current buffer into this
        // new buffer.  We'll do this in two steps.
        //
        // First we go up to dispatch level and try to
        // move as much as we can without stopping the
        // ISR from running.  We go up to dispatch level
        // by acquiring the control lock.  We do it at
        // dispatch using the control lock so that:
        //
        //    1) We can't be context switched in the middle
        //       of the move.  Our pointers into the buffer
        //       could be *VERY* stale by the time we got back.
        //
        //    2) We use the control lock since we don't want
        //       some pesky purge irp to come along while
        //       we are trying to move.
        //
        // After the move, but while we still hold the control
        // lock, we synch with the ISR and get those last
        // (hopefully) few characters that have come in since
        // we started the copy.  We switch all of our pointers,
        // counters, and such to point to this new buffer.  NOTE:
        // we need to be careful.  If the buffer we were using
        // was not the default one created when we initialized
        // the device (i.e. it was created via a previous IRP of
        // this type), we should deallocate it.
        //

        rp.Extension = Extension;
        rp.OldBuffer = Extension->InterruptReadBuffer;
        rp.NewBuffer = newBuffer;
        rp.NewBufferSize = rs->InSize;

        KeAcquireSpinLock(
            &Extension->ControlLock,
            &controlIrql
            );

        rp.NumberMoved = CyyMoveToNewIntBuffer(
                             Extension,
                             newBuffer
                             );

        KeSynchronizeExecution(
            Extension->Interrupt,
            CyyUpdateAndSwitchToNew,
            &rp
            );

        KeReleaseSpinLock(
            &Extension->ControlLock,
            controlIrql
            );

        //
        // Free up the memory that the old buffer consumed.
        //

        ExFreePool(rp.OldBuffer);

    }

    return STATUS_SUCCESS;

}

ULONG
CyyMoveToNewIntBuffer(
    PCYY_DEVICE_EXTENSION Extension,
    PUCHAR NewBuffer
    )

/*++

Routine Description:

    This routine is used to copy any characters out of the interrupt
    buffer into the "new" buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.  This routine will
    return the number of characters copied so some other routine
    can call a synchronization routine to update what is seen at
    interrupt level.

Arguments:

    Extension - A pointer to the device extension.
    NewBuffer - Where the characters are to be move to.

Return Value:

    The number of characters that were copied into the user
    buffer.

--*/

{

    ULONG numberOfCharsMoved = Extension->CharsInInterruptBuffer;
    CYY_LOCKED_PAGED_CODE();

    if (numberOfCharsMoved) {

        //
        // This holds the number of characters between the first
        // readable character and the last character we will read or
        // the real physical end of the buffer (not the last readable
        // character).
        //
        ULONG firstTryNumberToGet = (ULONG)(Extension->LastCharSlot -
                                     Extension->FirstReadableChar) + 1;

        if (firstTryNumberToGet >= numberOfCharsMoved) {

            //
            // The characters don't wrap.
            //

            RtlMoveMemory(
                NewBuffer,
                Extension->FirstReadableChar,
                numberOfCharsMoved
                );

            if ((Extension->FirstReadableChar+(numberOfCharsMoved-1)) ==
                Extension->LastCharSlot) {

                Extension->FirstReadableChar = Extension->InterruptReadBuffer;

            } else {

                Extension->FirstReadableChar += numberOfCharsMoved;

            }

        } else {

            //
            // The characters do wrap.  Get up until the end of the buffer.
            //

            RtlMoveMemory(
                NewBuffer,
                Extension->FirstReadableChar,
                firstTryNumberToGet
                );

            //
            // Now get the rest of the characters from the beginning of the
            // buffer.
            //

            RtlMoveMemory(
                NewBuffer+firstTryNumberToGet,
                Extension->InterruptReadBuffer,
                numberOfCharsMoved - firstTryNumberToGet
                );

            Extension->FirstReadableChar = Extension->InterruptReadBuffer +
                                   numberOfCharsMoved - firstTryNumberToGet;

        }

    }

    return numberOfCharsMoved;

}

BOOLEAN
CyyUpdateAndSwitchToNew(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a pointer to the buffer we are moving
              to, and a count of the number of characters
              that we previously copied into the new buffer, and the
              actual size of the new buffer.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_RESIZE_PARAMS params = Context;
    PCYY_DEVICE_EXTENSION extension = params->Extension;
    ULONG tempCharsInInterruptBuffer = extension->CharsInInterruptBuffer;

    CYY_LOCKED_PAGED_CODE();

    ASSERT(extension->CharsInInterruptBuffer >= params->NumberMoved);

    //
    // We temporarily reduce the chars in interrupt buffer to
    // "fool" the move routine.  We will restore it after the
    // move.
    //

    extension->CharsInInterruptBuffer -= params->NumberMoved;

    if (extension->CharsInInterruptBuffer) {

        CyyMoveToNewIntBuffer(
            extension,
            params->NewBuffer + params->NumberMoved
            );

    }

    extension->CharsInInterruptBuffer = tempCharsInInterruptBuffer;


    extension->LastCharSlot = params->NewBuffer + (params->NewBufferSize - 1);
    extension->FirstReadableChar = params->NewBuffer;
    extension->ReadBufferBase = params->NewBuffer;
    extension->InterruptReadBuffer = params->NewBuffer;
    extension->BufferSize = params->NewBufferSize;

    //
    // We *KNOW* that the new interrupt buffer is larger than the
    // old buffer.  We don't need to worry about it being full.
    //

    extension->CurrentCharSlot = extension->InterruptReadBuffer +
                                 extension->CharsInInterruptBuffer;

    //
    // We set up the default xon/xoff limits.
    //

    extension->HandFlow.XoffLimit = extension->BufferSize >> 3;
    extension->HandFlow.XonLimit = extension->BufferSize >> 1;

    extension->WmiCommData.XoffXmitThreshold = extension->HandFlow.XoffLimit;
    extension->WmiCommData.XonXmitThreshold = extension->HandFlow.XonLimit;

    extension->BufferSizePt8 = ((3*(extension->BufferSize>>2))+
                                   (extension->BufferSize>>4));

    //
    // Since we (essentially) reduced the percentage of the interrupt
    // buffer being full, we need to handle any flow control.
    //

    CyyHandleReducedIntBuffer(extension);

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyyportp.h ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyyportp.h
*	
*   Description:    Prototypes and macros that are used throughout 
*                   the driver.
*
*   Notes:          This code supports Windows 2000 and x86 processor.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

typedef
NTSTATUS
(*PSERIAL_START_ROUTINE) (
    IN PCYY_DEVICE_EXTENSION
    );

typedef
VOID
(*PSERIAL_GET_NEXT_ROUTINE) (
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    PCYY_DEVICE_EXTENSION Extension
    );

// cyyinit.c prototypes
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
CyyDisableInterfacesResources(IN PDEVICE_OBJECT PDevObj,
                                 BOOLEAN DisableUART);

VOID
CyyKillPendingIrps(PDEVICE_OBJECT DeviceObject);

CYY_MEM_COMPARES
CyyMemCompare(
                IN PHYSICAL_ADDRESS A,
                IN ULONG SpanOfA,
                IN PHYSICAL_ADDRESS B,
                IN ULONG SpanOfB
                );

VOID
CyyReleaseResources(IN PCYY_DEVICE_EXTENSION PDevExt);

NTSTATUS
CyyRemoveDevObj(IN PDEVICE_OBJECT PDevObj);

BOOLEAN
CyyDoesPortExist(
                  IN PCYY_DEVICE_EXTENSION Extension,
                  IN PUNICODE_STRING InsertString
                );

BOOLEAN
CyyReset(
    IN PVOID Context
    );

VOID
CyyUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
CyyInitController(IN PDEVICE_OBJECT PDevObj, IN PCONFIG_DATA PConfigData);
 
VOID
CyyResetBoard( PCYY_DEVICE_EXTENSION Extension );

NTSTATUS
CyyFindInitController(IN PDEVICE_OBJECT PDevObj, IN PCONFIG_DATA PConfig);

PUCHAR
GetMyMappedCD1400Address(IN PUCHAR BoardMemory, IN ULONG PortIndex, IN ULONG IsPci);

PHYSICAL_ADDRESS
GetMyPhysicalCD1400Address(IN PHYSICAL_ADDRESS BoardMemory, IN ULONG PortIndex, IN ULONG IsPci);

VOID
CyyCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

// end cyyinit.c

NTSTATUS
CyyRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CyyStartRead(
    IN PCYY_DEVICE_EXTENSION Extension
    );

VOID
CyyCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
CyyReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
CyyIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
CyyFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CyyWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CyyStartWrite(
    IN PCYY_DEVICE_EXTENSION Extension
    );

VOID
CyyGetNextWrite(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    IN PCYY_DEVICE_EXTENSION Extension
    );

VOID
CyyCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );
    
BOOLEAN
CyyTxStart(
    IN PVOID Context
    );

BOOLEAN
CyySendXon(
    IN PVOID Context
    );
    
BOOLEAN
CyySendXoff(
    IN PVOID Context
    );
    
BOOLEAN
CyyProcessEmptyTransmit(
    IN PVOID Context
    );

VOID
CyyWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
CyyCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CyyCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CyyClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
CyyDisableCd1400Channel(IN PVOID Context);

BOOLEAN
CyySetDTR(
    IN PVOID Context
    );

BOOLEAN
CyyClrDTR(
    IN PVOID Context
    );

BOOLEAN
CyySetRTS(
    IN PVOID Context
    );

BOOLEAN
CyyClrRTS(
    IN PVOID Context
    );

BOOLEAN
CyyGetDTRRTS(
    IN PVOID Context
    );

BOOLEAN
CyySetChars(
    IN PVOID Context
    );

BOOLEAN
CyySetBaud(
    IN PVOID Context
    );
    
BOOLEAN
CyySetLineControl(
    IN PVOID Context
    );

BOOLEAN
CyySetupNewHandFlow(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN PSERIAL_HANDFLOW NewHandFlow
    );

BOOLEAN
CyySetHandFlow(
    IN PVOID Context
    );

BOOLEAN
CyyTurnOnBreak(
    IN PVOID Context
    );

BOOLEAN
CyyTurnOffBreak(
    IN PVOID Context
    );

BOOLEAN
CyyPretendXoff(
    IN PVOID Context
    );

BOOLEAN
CyyPretendXon(
    IN PVOID Context
    );

VOID
CyyHandleReducedIntBuffer(
    IN PCYY_DEVICE_EXTENSION Extension
    );

VOID
CyyProdXonXoff(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN BOOLEAN SendXon
    );

NTSTATUS
CyyIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CyyStartMask(
    IN PCYY_DEVICE_EXTENSION Extension
    );

VOID
CyyCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
CyyCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
CyyStartImmediate(
    IN PCYY_DEVICE_EXTENSION Extension
    );

VOID
CyyCompleteImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
CyyTimeoutImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
CyyTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
CyyCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
CyyStartPurge(
    IN PCYY_DEVICE_EXTENSION Extension
    );

BOOLEAN
CyyPurgeInterruptBuff(
    IN PVOID Context
    );

NTSTATUS
CyyQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CyySetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
CyyKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    );

VOID
CyyGetNextIrp(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent,
    IN PCYY_DEVICE_EXTENSION Extension
    );

VOID
CyyTryToCompleteCurrent(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PKTIMER IntervalTimer,
    IN PKTIMER TotalTimer,
    IN PSERIAL_START_ROUTINE Starter,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp,
    IN LONG RefType
    );

NTSTATUS
CyyStartOrQueue(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    );

VOID
CyyCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
CyyCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

ULONG
CyyHandleModemUpdate(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN BOOLEAN DoingTX
    );
    
ULONG
CyyHandleModemUpdateForModem(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN BOOLEAN DoingTX,
	IN UCHAR misr
    );
    
BOOLEAN
CyyIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

BOOLEAN
CyyDispatchISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );


BOOLEAN
CyyPerhapsLowerRTS(
    IN PVOID Context
    );

VOID
CyyStartTimerLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
CyyInvokePerhapsLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
CyyCleanupDevice(
    IN PCYY_DEVICE_EXTENSION Extension
    );

BOOLEAN
CyyProcessLSR(
    IN PCYY_DEVICE_EXTENSION Extension,
	IN UCHAR Rdsr,
	IN UCHAR RxChar
    );

LARGE_INTEGER
CyyGetCharTime(
    IN PCYY_DEVICE_EXTENSION Extension
    );

BOOLEAN
CyySharerIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

BOOLEAN
CyyMarkClose(
    IN PVOID Context
    );

BOOLEAN
CyyIndexedMultiportIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

BOOLEAN
CyyBitMappedMultiportIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

VOID
CyyPutChar(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN UCHAR CharToPut
    );
	
BOOLEAN
CyyGetStats(
    IN PVOID Context
    );

BOOLEAN
CyyClearStats(
    IN PVOID Context
    );    
	
VOID
CyyLog(
    IN PDRIVER_OBJECT DriverObject,
    NTSTATUS msgId
);

VOID
CyyLogData(
    IN PDRIVER_OBJECT DriverObject,
    NTSTATUS msgId,
	ULONG dump1,
	ULONG dump2
);

VOID
CyyILog(
    IN PDRIVER_OBJECT DriverObject,
    NTSTATUS msgId
);

VOID
CyyILogParam(
    IN PDRIVER_OBJECT DriverObject,
    NTSTATUS msgId,
	ULONG dumpParameter,
	ULONG base
);

VOID
CyyCDCmd(
	PCYY_DEVICE_EXTENSION Extension,
	UCHAR cmd
);


// cyreg.c

NTSTATUS
CyyGetConfigDefaults(
    IN PCYY_REGISTRY_DATA DriverDefaultsPtr,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS 
CyyGetRegistryKeyValue (
                       IN HANDLE Handle,
                       IN PWCHAR KeyNameString,
                       IN ULONG KeyNameStringLength,
                       IN PVOID Data,
                       IN ULONG DataLength
                       );
ULONG 
CyyGetRegistryKeyValueLength (
                       IN HANDLE Handle,
                       IN PWCHAR KeyNameString,
                       IN ULONG KeyNameStringLength);

NTSTATUS 
CyyPutRegistryKeyValue(IN HANDLE Handle, IN PWCHAR PKeyNameString,
                       IN ULONG KeyNameStringLength, IN ULONG Dtype,
                       IN PVOID PData, IN ULONG DataLength);

// cyypnp.c

NTSTATUS
CyyAddDevice(
    IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT PLowerDevObj);

//NTSTATUS
//CyyCreateDevObj(IN PDRIVER_OBJECT DriverObject,
//                OUT PDEVICE_OBJECT *NewDeviceObject);
NTSTATUS
CyyCreateDevObj(IN PDRIVER_OBJECT DriverObject,
                IN PDEVICE_OBJECT PPdo,
                OUT PDEVICE_OBJECT *NewDeviceObject);

NTSTATUS
CyyFinishStartDevice(IN PDEVICE_OBJECT PDevObj,
                     IN PCM_RESOURCE_LIST PResList,
                     IN PCM_RESOURCE_LIST PTrResList);

NTSTATUS
CyyGetPortInfo(IN PDEVICE_OBJECT PDevObj, IN PCM_RESOURCE_LIST PResList,
               IN PCM_RESOURCE_LIST PTrResList, OUT PCONFIG_DATA PConfig);

NTSTATUS
CyyStartDevice(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

NTSTATUS
CyySyncCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                  IN PKEVENT CyySyncEvent);

NTSTATUS
CyyPnpDispatch(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

NTSTATUS
CyyDoExternalNaming(IN PCYY_DEVICE_EXTENSION PDevExt,
                    IN PDRIVER_OBJECT PDrvObj);

VOID
CyyUndoExternalNaming(IN PCYY_DEVICE_EXTENSION Extension);

UINT32
CyyReportMaxBaudRate(ULONG Bauds);

// cyyioctl.c

VOID
CyyGetProperties(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN PSERIAL_COMMPROP Properties
    );

NTSTATUS
CyyInternalIoControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

BOOLEAN
CyySetMCRContents(IN PVOID Context);

BOOLEAN
CyyGetMCRContents(IN PVOID Context);

BOOLEAN
CyySetFCRContents(IN PVOID Context);

// cypower.c

NTSTATUS
CyyPowerDispatch(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

NTSTATUS
CyyGotoPowerState(IN PDEVICE_OBJECT PDevObj,
                  IN PCYY_DEVICE_EXTENSION PDevExt,
                  IN DEVICE_POWER_STATE DevPowerState);
NTSTATUS
CyySendWaitWake(PCYY_DEVICE_EXTENSION PDevExt);

//VOID
//CyyRestoreDeviceState(IN PCYY_DEVICE_EXTENSION PDevExt);
BOOLEAN
CyyRestoreDeviceState(
    IN PVOID Context      
    );

NTSTATUS
CyySetPowerD0(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

NTSTATUS
CyySetPowerD3(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

//VOID
//CyySaveDeviceState(IN PCYY_DEVICE_EXTENSION PDevExt);
BOOLEAN
CyySaveDeviceState(
    IN PVOID Context
    );

NTSTATUS
CyyWakeCompletion(IN PDEVICE_OBJECT PDevObj, IN UCHAR MinorFunction,
                  IN POWER_STATE PowerState, IN PVOID Context,
                  IN PIO_STATUS_BLOCK IoStatus);


// cywmi.c

NTSTATUS
CyyQueryWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex, 
                     IN ULONG InstanceIndex,
                     IN ULONG InstanceCount,
                     IN OUT PULONG InstanceLengthArray,
                     IN ULONG OutBufferSize,
                     OUT PUCHAR PBuffer);

NTSTATUS
CyyQueryWmiRegInfo(IN PDEVICE_OBJECT PDevObj, OUT PULONG PRegFlags,
                   OUT PUNICODE_STRING PInstanceName,
                   OUT PUNICODE_STRING *PRegistryPath,
                   OUT PUNICODE_STRING MofResourceName,
                   OUT PDEVICE_OBJECT *Pdo);

NTSTATUS
CyySetWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                   IN ULONG GuidIndex, IN ULONG InstanceIndex,
                   IN ULONG BufferSize,
                   IN PUCHAR PBuffer);
NTSTATUS
CyySetWmiDataItem(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                  IN ULONG GuidIndex, IN ULONG InstanceIndex,
                  IN ULONG DataItemId,
                  IN ULONG BufferSize, IN PUCHAR PBuffer);

NTSTATUS
CyySystemControlDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
CyyTossWMIRequest(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                  IN ULONG GuidIndex);

// cyyutils.c

BOOLEAN
CyyCancelTimer(IN PKTIMER Timer, IN PCYY_DEVICE_EXTENSION PDevExt);

VOID
CyyDpcEpilogue(IN PCYY_DEVICE_EXTENSION PDevExt, PKDPC PDpc);

VOID
CyyGetNextIrpLocked(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent,
    IN PCYY_DEVICE_EXTENSION extension,
    IN KIRQL OldIrql
    );

BOOLEAN
CyyInsertQueueDpc(IN PRKDPC PDpc, IN PVOID Sarg1, IN PVOID Sarg2,
                  IN PCYY_DEVICE_EXTENSION PDevExt);

NTSTATUS
CyyIRPPrologue(IN PIRP PIrp, IN PCYY_DEVICE_EXTENSION PDevExt);

VOID
CyyIRPEpilogue(IN PCYY_DEVICE_EXTENSION PDevExt);

NTSTATUS
CyyIoCallDriver(PCYY_DEVICE_EXTENSION PDevExt, PDEVICE_OBJECT PDevObj,
                PIRP PIrp);
VOID
CyyKillAllStalled(IN PDEVICE_OBJECT PDevObj);

VOID
CyyLogError(
              IN PDRIVER_OBJECT DriverObject,
              IN PDEVICE_OBJECT DeviceObject OPTIONAL,
              IN PHYSICAL_ADDRESS P1,
              IN PHYSICAL_ADDRESS P2,
              IN ULONG SequenceNumber,
              IN UCHAR MajorFunctionCode,
              IN UCHAR RetryCount,
              IN ULONG UniqueErrorValue,
              IN NTSTATUS FinalStatus,
              IN NTSTATUS SpecificIOStatus,
              IN ULONG LengthOfInsert1,
              IN PWCHAR Insert1,
              IN ULONG LengthOfInsert2,
              IN PWCHAR Insert2
              );

VOID
CyyMarkHardwareBroken(IN PCYY_DEVICE_EXTENSION PDevExt);

NTSTATUS
CyyPoCallDriver(PCYY_DEVICE_EXTENSION PDevExt, PDEVICE_OBJECT PDevObj,
                PIRP PIrp);

VOID
CyySetDeviceFlags(IN PCYY_DEVICE_EXTENSION PDevExt, OUT PULONG PFlags, 
                  IN ULONG Value, IN BOOLEAN Set);

BOOLEAN
CyySetTimer(IN PKTIMER Timer, IN LARGE_INTEGER DueTime,
            IN PKDPC Dpc OPTIONAL, IN PCYY_DEVICE_EXTENSION PDevExt);

VOID
CyyUnlockPages(IN PKDPC PDpc, IN PVOID PDeferredContext,
               IN PVOID PSysContext1, IN PVOID PSysContext2);

VOID
CyyUnstallIrps(IN PCYY_DEVICE_EXTENSION PDevExt);



// End of prototypes


typedef struct _SERIAL_UPDATE_CHAR {
    PCYY_DEVICE_EXTENSION Extension;
    ULONG CharsCopied;
    BOOLEAN Completed;
    } SERIAL_UPDATE_CHAR,*PSERIAL_UPDATE_CHAR;

//
// The following simple structure is used to send a pointer
// the device extension and an ioctl specific pointer
// to data.
//
typedef struct _CYY_IOCTL_SYNC {
    PCYY_DEVICE_EXTENSION Extension;
    PVOID Data;
    } CYY_IOCTL_SYNC,*PCYY_IOCTL_SYNC;

typedef struct _CYY_IOCTL_BAUD {
    PCYY_DEVICE_EXTENSION Extension;
    ULONG Baud;
    } CYY_IOCTL_BAUD,*PCYY_IOCTL_BAUD;

#define CyySetFlags(PDevExt, Value) \
   CyySetDeviceFlags((PDevExt), &(PDevExt)->Flags, (Value), TRUE)
#define CyyClearFlags(PDevExt, Value) \
   CyySetDeviceFlags((PDevExt), &(PDevExt)->Flags, (Value), FALSE)
#define CyySetAccept(PDevExt, Value) \
   CyySetDeviceFlags((PDevExt), &(PDevExt)->DevicePNPAccept, (Value), TRUE)
#define CyyClearAccept(PDevExt, Value) \
   CyySetDeviceFlags((PDevExt), &(PDevExt)->DevicePNPAccept, (Value), FALSE)




//
// The following three macros are used to initialize, set
// and clear references in IRPs that are used by
// this driver.  The reference is stored in the fourth
// argument of the irp, which is never used by any operation
// accepted by this driver.
//

#define SERIAL_REF_ISR         (0x00000001)
#define SERIAL_REF_CANCEL      (0x00000002)
#define SERIAL_REF_TOTAL_TIMER (0x00000004)
#define SERIAL_REF_INT_TIMER   (0x00000008)
#define SERIAL_REF_XOFF_REF    (0x00000010)


#define SERIAL_INIT_REFERENCE(Irp) { \
    ASSERT(sizeof(ULONG_PTR) <= sizeof(PVOID)); \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL; \
    }

#define SERIAL_SET_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PULONG_PTR _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       ASSERT(!(*_arg4 & _refType)); \
       *_arg4 |= _refType; \
   } while (0)

#define SERIAL_CLEAR_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PULONG_PTR _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       ASSERT(*_arg4 & _refType); \
       *_arg4 &= ~_refType; \
   } while (0)

#define SERIAL_REFERENCE_COUNT(Irp) \
    ((ULONG_PTR)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyyreg.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyyreg.c
*	
*   Description:    This module contains the code that is used to get 
*                   values from the registry and to manipulate entries 
*                   in the registry.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CyyGetConfigDefaults)

#pragma alloc_text(PAGESRP0,CyyGetRegistryKeyValue)
#pragma alloc_text(PAGESRP0,CyyPutRegistryKeyValue)
#endif // ALLOC_PRAGMA


NTSTATUS
CyyGetConfigDefaults(
    IN PCYY_REGISTRY_DATA    DriverDefaultsPtr,
    IN PUNICODE_STRING          RegistryPath
    )

/*++

Routine Description:

    This routine reads the default configuration data from the
    registry for the serial driver.

    It also builds fields in the registry for several configuration
    options if they don't exist.

Arguments:

    DriverDefaultsPtr - Pointer to a structure that will contain
                        the default configuration values.

    RegistryPath - points to the entry for this driver in the
                   current control set of the registry.

Return Value:

    STATUS_SUCCESS if we got the defaults, otherwise we failed.
    The only way to fail this call is if the  STATUS_INSUFFICIENT_RESOURCES.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;    // return value

    //
    // We use this to query into the registry for defaults
    //

    RTL_QUERY_REGISTRY_TABLE paramTable[8];
    
    PWCHAR  path;
    ULONG   zero            = 0;
    ULONG   DbgDefault      = 0;//SER_DBG_DEFAULT;
    ULONG   notThereDefault = CYY_UNINITIALIZED_DEFAULT;

    PAGED_CODE();

    //
    // Since the registry path parameter is a "counted" UNICODE string, it
    // might not be zero terminated.  For a very short time allocate memory
    // to hold the registry path zero terminated so that we can use it to
    // delve into the registry.
    //
    // NOTE NOTE!!!! This is not an architected way of breaking into
    // a driver.  It happens to work for this driver because the author
    // likes to do things this way.
    //

    path = ExAllocatePool (PagedPool, RegistryPath->Length+sizeof(WCHAR));
    
    if (!path) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return (Status);
    }
    
    RtlZeroMemory (DriverDefaultsPtr, sizeof(CYY_REGISTRY_DATA));
    RtlZeroMemory (&paramTable[0], sizeof(paramTable));
    RtlZeroMemory (path, RegistryPath->Length+sizeof(WCHAR));
    RtlMoveMemory (path, RegistryPath->Buffer, RegistryPath->Length);

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = L"BreakOnEntry";
    paramTable[0].EntryContext  = &DriverDefaultsPtr->ShouldBreakOnEntry;
    paramTable[0].DefaultType   = REG_DWORD;
    paramTable[0].DefaultData   = &zero;
    paramTable[0].DefaultLength = sizeof(ULONG);
    
    paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name          = L"DebugLevel";
    paramTable[1].EntryContext  = &DriverDefaultsPtr->DebugLevel;
    paramTable[1].DefaultType   = REG_DWORD;
    paramTable[1].DefaultData   = &DbgDefault;
    paramTable[1].DefaultLength = sizeof(ULONG);
    
    paramTable[3].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[3].Name          = L"RxFIFO";
    paramTable[3].EntryContext  = &DriverDefaultsPtr->RxFIFODefault;
    paramTable[3].DefaultType   = REG_DWORD;
    paramTable[3].DefaultData   = &notThereDefault;
    paramTable[3].DefaultLength = sizeof(ULONG);
    
    paramTable[4].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[4].Name          = L"TxFIFO";
    paramTable[4].EntryContext  = &DriverDefaultsPtr->TxFIFODefault;
    paramTable[4].DefaultType   = REG_DWORD;
    paramTable[4].DefaultData   = &notThereDefault;
    paramTable[4].DefaultLength = sizeof(ULONG);

    paramTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[2].Name          = L"PermitShare";
    paramTable[2].EntryContext  = &DriverDefaultsPtr->PermitShareDefault;
    paramTable[2].DefaultType   = REG_DWORD;
    paramTable[2].DefaultData   = &notThereDefault;
    paramTable[2].DefaultLength = sizeof(ULONG);
    
    Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                     path,
                                     &paramTable[0],
                                     NULL,
                                     NULL);
       
    if (!NT_SUCCESS(Status)) {
            DriverDefaultsPtr->ShouldBreakOnEntry   = 0;
            DriverDefaultsPtr->DebugLevel           = 0;
    }

    // TODO FANNY: SEE IF WE CAN ADD FIFO SIZE CONFIGURATION, 
    // AS REQUESTED BY PLATFORM IN JAPAN.
    // Check to see if there was a forcefifo or an rxfifo size.
    // If there isn't then write out values so that they could
    // be adjusted later.
    //

    if (DriverDefaultsPtr->RxFIFODefault == notThereDefault) {
        DriverDefaultsPtr->RxFIFODefault = CYY_RX_FIFO_DEFAULT;
        RtlWriteRegistryValue(
            RTL_REGISTRY_ABSOLUTE,
            path,
            L"RxFIFO",
            REG_DWORD,
            &DriverDefaultsPtr->RxFIFODefault,
            sizeof(ULONG)
            );
    }

    if (DriverDefaultsPtr->TxFIFODefault == notThereDefault) {

        DriverDefaultsPtr->TxFIFODefault = CYY_TX_FIFO_DEFAULT;
        RtlWriteRegistryValue(
            RTL_REGISTRY_ABSOLUTE,
            path,
            L"TxFIFO",
            REG_DWORD,
            &DriverDefaultsPtr->TxFIFODefault,
            sizeof(ULONG)
            );
    }

    if (DriverDefaultsPtr->PermitShareDefault == notThereDefault) {

        DriverDefaultsPtr->PermitShareDefault = CYY_PERMIT_SHARE_DEFAULT;
        //
        // Only share if the user actual changes switch.
        //

        RtlWriteRegistryValue(
            RTL_REGISTRY_ABSOLUTE,
            path,
            L"PermitShare",
            REG_DWORD,
            &DriverDefaultsPtr->PermitShareDefault,
            sizeof(ULONG)
            );

    }


    //
    // We don't need that path anymore.
    //

    if (path) {
        ExFreePool(path);
    }

    //
    //  Set the defaults for other values
    //
    DriverDefaultsPtr->PermitSystemWideShare = FALSE;

    return (Status);
}


NTSTATUS 
CyyGetRegistryKeyValue (
                       IN HANDLE Handle,
                       IN PWCHAR KeyNameString,
                       IN ULONG KeyNameStringLength,
                       IN PVOID Data,
                       IN ULONG DataLength
                       )
/*++

Routine Description:

    Reads a registry key value from an already opened registry key.
    
Arguments:

    Handle              Handle to the opened registry key
    
    KeyNameString       ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString

    Data                Buffer to place the key value in

    DataLength          Length of the data buffer

Return Value:

    STATUS_SUCCESS if all works, otherwise status of system call that
    went wrong.

--*/
{
   UNICODE_STRING              keyName;
   ULONG                       length;
   PKEY_VALUE_FULL_INFORMATION fullInfo;

   NTSTATUS                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

   PAGED_CODE();

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyGetRegistryKeyValue(XXX)\n");


   RtlInitUnicodeString (&keyName, KeyNameString);

   length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength
      + DataLength;
   fullInfo = ExAllocatePool(PagedPool, length); 

   if (fullInfo) {
      ntStatus = ZwQueryValueKey (Handle,
                                  &keyName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

      if (NT_SUCCESS(ntStatus)) {
         //
         // If there is enough room in the data buffer, copy the output
         //

         if (DataLength >= fullInfo->DataLength) {
            RtlCopyMemory (Data, 
                           ((PUCHAR) fullInfo) + fullInfo->DataOffset, 
                           fullInfo->DataLength);
         }
      }

      ExFreePool(fullInfo);
   }

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyGetRegistryKeyValue %X\n",
                 ntStatus);

   return ntStatus;
}


ULONG 
CyyGetRegistryKeyValueLength (
                       IN HANDLE Handle,
                       IN PWCHAR KeyNameString,
                       IN ULONG KeyNameStringLength
                       )
/*++

Routine Description:

    Reads a registry key value from an already opened registry key.
    
Arguments:

    Handle              Handle to the opened registry key
    
    KeyNameString       ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString

Return Value:

    ULONG               Length of the key value

--*/
{
   UNICODE_STRING              keyName;
   ULONG                       length;
   PKEY_VALUE_FULL_INFORMATION fullInfo;

   PAGED_CODE();

   RtlInitUnicodeString (&keyName, KeyNameString);

   length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength;

   fullInfo = ExAllocatePool(PagedPool, length); 

   if (fullInfo) {
      ZwQueryValueKey (Handle,
                       &keyName,
                       KeyValueFullInformation,
                       fullInfo,
                       length,
                       &length);

      ExFreePool(fullInfo);
   }

   return length;
}


NTSTATUS 
CyyPutRegistryKeyValue(IN HANDLE Handle, IN PWCHAR PKeyNameString,
                       IN ULONG KeyNameStringLength, IN ULONG Dtype,
                       IN PVOID PData, IN ULONG DataLength)
/*++

Routine Description:

    Writes a registry key value to an already opened registry key.
    
Arguments:

    Handle              Handle to the opened registry key
    
    PKeyNameString      ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString
    
    Dtype		REG_XYZ value type

    PData               Buffer to place the key value in

    DataLength          Length of the data buffer

Return Value:

    STATUS_SUCCESS if all works, otherwise status of system call that
    went wrong.

--*/
{
   NTSTATUS status;
   UNICODE_STRING keyname;

   PAGED_CODE();

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyPutRegistryKeyValue(XXX)\n");

   RtlInitUnicodeString(&keyname, NULL);
   keyname.MaximumLength = (USHORT)(KeyNameStringLength + sizeof(WCHAR));
   keyname.Buffer = ExAllocatePool(PagedPool, keyname.MaximumLength);

   if (keyname.Buffer == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlAppendUnicodeToString(&keyname, PKeyNameString);

   status = ZwSetValueKey(Handle, &keyname, 0, Dtype, PData, DataLength);

   ExFreePool(keyname.Buffer);
   
   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyPutRegistryKeyValue %X\n",
                 status);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyyutils.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-2001.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyyutils.c
*	
*   Description:    This module contains the code related to queueing
*                   and completion manipulation on requests.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/


#include "precomp.h"

VOID
CyyRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer,
    IN PKTIMER TotalTimer,
    IN PCYY_DEVICE_EXTENSION PDevExt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,CyyGetNextIrp)
#pragma alloc_text(PAGESER, CyyGetNextIrpLocked)
#pragma alloc_text(PAGESER,CyyTryToCompleteCurrent)
#pragma alloc_text(PAGESER,CyyStartOrQueue)
#pragma alloc_text(PAGESER,CyyCancelQueued)
#pragma alloc_text(PAGESER,CyyCompleteIfError)
#pragma alloc_text(PAGESER,CyyRundownIrpRefs)

//#pragma alloc_text(PAGESRP0, CyyLogError) //It can be called at raised IRQL 
#pragma alloc_text(PAGESRP0, CyyMarkHardwareBroken)
#endif

static const PHYSICAL_ADDRESS CyyPhysicalZero = {0};


VOID
CyyKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    )
/*--------------------------------------------------------------------------
    CyyKillAllReadsOrWrites()
    
    Routine Description: This function is used to cancel all queued and
    the current irps for reads or for writes.

    Arguments:

    DeviceObject - A pointer to the serial device object.
    QueueToClean - A pointer to the queue which we're going to clean out.
    CurrentOpIrp - Pointer to a pointer to the current irp.

    Return Value: None.
--------------------------------------------------------------------------*/
{
    KIRQL cancelIrql;
    PDRIVER_CANCEL cancelRoutine;

    // Acquire cancel spin lock to prevent irps from moving around.
    IoAcquireCancelSpinLock(&cancelIrql);

    // Clean the list from back to front.

    while (!IsListEmpty(QueueToClean)) {
        PIRP currentLastIrp = CONTAINING_RECORD(QueueToClean->Blink,
                                  IRP,Tail.Overlay.ListEntry);

        RemoveEntryList(QueueToClean->Blink);
        cancelRoutine = currentLastIrp->CancelRoutine;
        currentLastIrp->CancelIrql = cancelIrql;
        currentLastIrp->CancelRoutine = NULL;
        currentLastIrp->Cancel = TRUE;

        cancelRoutine(DeviceObject,currentLastIrp);
        IoAcquireCancelSpinLock(&cancelIrql);
    }

    // The queue is clean.  Now go after the current if it's there.

    if (*CurrentOpIrp) {
        cancelRoutine = (*CurrentOpIrp)->CancelRoutine;
        (*CurrentOpIrp)->Cancel = TRUE;
	
        // If the current irp is not in a cancelable state
        // then it *will* try to enter one and the above
        // assignment will kill it.  If it already is in
        // a cancelable state then the following will kill it.

        if (cancelRoutine) {
            (*CurrentOpIrp)->CancelRoutine = NULL;
            (*CurrentOpIrp)->CancelIrql = cancelIrql;
	    
            // mark it as canceled and call the cancel routine for it
            cancelRoutine(DeviceObject,*CurrentOpIrp);
        } else {
            IoReleaseCancelSpinLock(cancelIrql);
        }
    } else {
        IoReleaseCancelSpinLock(cancelIrql);
    }
}

VOID
CyyGetNextIrp(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent,
    IN PCYY_DEVICE_EXTENSION extension
    )
/*--------------------------------------------------------------------------
    CyyGetNextIrp()
    
    Routine Description: This function is used to make the head of the
    particular queue the current irp.  It also completes the what
    was the old current irp if desired.

    Arguments:

    CurrentOpIrp - Pointer to a pointer to the currently active
                   irp for the particular work list.  Note that
                   this item is not actually part of the list.
    QueueToProcess - The list to pull the new item off of.
    NextIrp - The next Irp to process.  Note that CurrentOpIrp
              will be set to this value under protection of the
              cancel spin lock.  However, if *NextIrp is NULL when
              this routine returns, it is not necessaryly true the
              what is pointed to by CurrentOpIrp will also be NULL.
              The reason for this is that if the queue is empty
              when we hold the cancel spin lock, a new irp may come
              in immediately after we release the lock.

    CompleteCurrent - If TRUE then this routine will complete the
                      irp pointed to by the pointer argument
                      CurrentOpIrp.

    Return Value: None.
--------------------------------------------------------------------------*/
{
    KIRQL oldIrql;
    CYY_LOCKED_PAGED_CODE();

    IoAcquireCancelSpinLock(&oldIrql);
    CyyGetNextIrpLocked(CurrentOpIrp, QueueToProcess, NextIrp,
                        CompleteCurrent, extension, oldIrql);

    //TODO FANNY: CHECK IF REPLACING CODE THAT WAS HERE BY 
    //CyyGetNextIrpLocked MY FIX FOR THE BUG FOUND IN MODEM SHARE
    //WAS OVERWRITTEN.
}


VOID
CyyGetNextIrpLocked(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent,
    IN PCYY_DEVICE_EXTENSION extension,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This function is used to make the head of the particular
    queue the current irp.  It also completes the what
    was the old current irp if desired.  The difference between
    this and CyyGetNextIrp() is that for this we assume the caller
    holds the cancel spinlock and we should release it when we're done.

Arguments:

    CurrentOpIrp - Pointer to a pointer to the currently active
                   irp for the particular work list.  Note that
                   this item is not actually part of the list.

    QueueToProcess - The list to pull the new item off of.

    NextIrp - The next Irp to process.  Note that CurrentOpIrp
              will be set to this value under protection of the
              cancel spin lock.  However, if *NextIrp is NULL when
              this routine returns, it is not necessaryly true the
              what is pointed to by CurrentOpIrp will also be NULL.
              The reason for this is that if the queue is empty
              when we hold the cancel spin lock, a new irp may come
              in immediately after we release the lock.

    CompleteCurrent - If TRUE then this routine will complete the
                      irp pointed to by the pointer argument
                      CurrentOpIrp.

    OldIrql - IRQL which the cancel spinlock was acquired at and what we
              should restore it to.

Return Value:

    None.

--*/

{

    PIRP oldIrp;

    CYY_LOCKED_PAGED_CODE();


    oldIrp = *CurrentOpIrp;

#if DBG
    if (oldIrp) {

        if (CompleteCurrent) {

            ASSERT(!oldIrp->CancelRoutine);

        }

    }
#endif

    //
    // Check to see if there is a new irp to start up.
    //

    if (!IsListEmpty(QueueToProcess)) {

        PLIST_ENTRY headOfList;

        headOfList = RemoveHeadList(QueueToProcess);

        *CurrentOpIrp = CONTAINING_RECORD(
                            headOfList,
                            IRP,
                            Tail.Overlay.ListEntry
                            );

        IoSetCancelRoutine(
            *CurrentOpIrp,
            NULL
            );

    } else {

        *CurrentOpIrp = NULL;

    }

    *NextIrp = *CurrentOpIrp;
    IoReleaseCancelSpinLock(OldIrql);

    if (CompleteCurrent) {

        if (oldIrp) {

            CyyCompleteRequest(extension, oldIrp, IO_SERIAL_INCREMENT);
        }
    }
}


VOID
CyyTryToCompleteCurrent(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess OPTIONAL,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PSERIAL_START_ROUTINE Starter OPTIONAL,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp OPTIONAL,
    IN LONG RefType
    )
/*--------------------------------------------------------------------------
    CyyTryToCompleteCurrent()
    
    Routine Description: This routine attempts to kill all of the reasons
    there are references on the current read/write.  If everything can be
    killed it will complete this read/write and try to start another.
    NOTE: This routine assumes that the cancel spinlock is being held.

    Arguments:

    Extension - Simply a pointer to the device extension.
    SynchRoutine - A routine that will synchronize with the isr
                   and attempt to remove the knowledge of the
                   current irp from the isr.  NOTE: This pointer
                   can be null.
    IrqlForRelease - This routine is called with the cancel spinlock held.
                     This is the irql that was current when the cancel
                     spinlock was acquired.
    StatusToUse - The irp's status field will be set to this value, if
                  this routine can complete the irp.

    Return Value: None.
--------------------------------------------------------------------------*/
{

    CYY_LOCKED_PAGED_CODE();
   
    // We can decrement the reference to "remove" the fact
    // that the caller no longer will be accessing this irp.

    SERIAL_CLEAR_REFERENCE(*CurrentOpIrp,RefType);

    if (SynchRoutine) {
        KeSynchronizeExecution(Extension->Interrupt,SynchRoutine,Extension);
    }

    // Try to run down all other references to this irp.
    CyyRundownIrpRefs(CurrentOpIrp,IntervalTimer,TotalTimer,Extension);

    // See if the ref count is zero after trying to kill everybody else.

    if (!SERIAL_REFERENCE_COUNT(*CurrentOpIrp)) {
        PIRP newIrp;

        // The ref count was zero so we should complete this request.
        // The following call will also cause the current irp to be
        // completed.

        (*CurrentOpIrp)->IoStatus.Status = StatusToUse;

        if (StatusToUse == STATUS_CANCELLED) {
            (*CurrentOpIrp)->IoStatus.Information = 0;
        }

        if (GetNextIrp) {
            IoReleaseCancelSpinLock(IrqlForRelease);
            GetNextIrp(CurrentOpIrp,QueueToProcess,&newIrp,TRUE
                        ,Extension
            );

            if (newIrp) {
                Starter(Extension);

            }
        } else {
            PIRP oldIrp = *CurrentOpIrp;

            // There was no get next routine.  We will simply complete
            // the irp.  We should make sure that we null out the
            // pointer to the pointer to this irp.

            *CurrentOpIrp = NULL;

            IoReleaseCancelSpinLock(IrqlForRelease);
            CyyCompleteRequest(Extension, oldIrp, IO_SERIAL_INCREMENT);
        }
    } else {
        IoReleaseCancelSpinLock(IrqlForRelease);
    }
}

VOID
CyyRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PCYY_DEVICE_EXTENSION PDevExt
    )

/*++

Routine Description:

    This routine runs through the various items that *could*
    have a reference to the current read/write.  It try's to kill
    the reason.  If it does succeed in killing the reason it
    will decrement the reference count on the irp.

    NOTE: This routine assumes that it is called with the cancel
          spin lock held.

Arguments:

    CurrentOpIrp - Pointer to a pointer to current irp for the
                   particular operation.

    IntervalTimer - Pointer to the interval timer for the operation.
                    NOTE: This could be null.

    TotalTimer - Pointer to the total timer for the operation.
                 NOTE: This could be null.

    PDevExt - Pointer to device extension  

Return Value:

    None.

--*/
{

    CYY_LOCKED_PAGED_CODE();

    //
    // This routine is called with the cancel spin lock held
    // so we know only one thread of execution can be in here
    // at one time.
    //

    //
    // First we see if there is still a cancel routine.  If
    // so then we can decrement the count by one.
    //

    if ((*CurrentOpIrp)->CancelRoutine) {

        SERIAL_CLEAR_REFERENCE(
            *CurrentOpIrp,
            SERIAL_REF_CANCEL
            );

        IoSetCancelRoutine(
            *CurrentOpIrp,
            NULL
            );

    }

    if (IntervalTimer) {

        //
        // Try to cancel the operations interval timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an interval timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if (CyyCancelTimer(IntervalTimer, PDevExt)) {

            SERIAL_CLEAR_REFERENCE(
                *CurrentOpIrp,
                SERIAL_REF_INT_TIMER
                );

        }

    }

    if (TotalTimer) {

        //
        // Try to cancel the operations total timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an total timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if (CyyCancelTimer(TotalTimer, PDevExt)) {

            SERIAL_CLEAR_REFERENCE(
                *CurrentOpIrp,
                SERIAL_REF_TOTAL_TIMER
                );

        }

    }

}

NTSTATUS
CyyStartOrQueue(
    IN PCYY_DEVICE_EXTENSION Extension,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    )
/*--------------------------------------------------------------------------
    CyyStartOrQueue()
    
    Routine Description: This routine either starts or queues requests to
    the driver.

    Arguments:

    Extension - Points to the serial device extension.
    Irp - The irp. The irp will be marked pending.
    QueueToExamine - The queue the irp will be placed on.
    CurrentOpIrp - Pointer to a pointer to the irp that is current
	for the queue.  The pointer pointed to will be set with to Irp if
	what CurrentOpIrp points to is NULL.
    Starter - The routine to call if the queue is empty.

    Return Value:

    This routine will return STATUS_PENDING if the queue is
    not empty.  Otherwise, it will return the status returned
    from the starter routine (or cancel, if the cancel bit is
    on in the irp).
--------------------------------------------------------------------------*/
{
    KIRQL oldIrql;

    CYY_LOCKED_PAGED_CODE();

    IoAcquireCancelSpinLock(&oldIrql);

    // If this is a write irp then take the amount of characters
    // to write and add it to the count of characters to write.
    
    if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_WRITE) {
        Extension->TotalCharsQueued += IoGetCurrentIrpStackLocation(Irp)->
						Parameters.Write.Length;
    } else {
    	if ((IoGetCurrentIrpStackLocation(Irp)->MajorFunction
                == IRP_MJ_DEVICE_CONTROL) &&
               ((IoGetCurrentIrpStackLocation(Irp)
                 ->Parameters.DeviceIoControl.IoControlCode ==
                 IOCTL_SERIAL_IMMEDIATE_CHAR) ||
                (IoGetCurrentIrpStackLocation(Irp)
                 ->Parameters.DeviceIoControl.IoControlCode ==
                 IOCTL_SERIAL_XOFF_COUNTER))) {

	    Extension->TotalCharsQueued++;
    	}
    }

    if ((IsListEmpty(QueueToExamine)) && !(*CurrentOpIrp)) {
        // no current operation.  Mark this one as current and start it up.
        *CurrentOpIrp = Irp;
        IoReleaseCancelSpinLock(oldIrql);
        return Starter(Extension);
    } else {
        // We don't know how long the irp will be in the queue.
        if (Irp->Cancel) {
            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
            IoReleaseCancelSpinLock(oldIrql);
            if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                   IOCTL_SERIAL_SET_QUEUE_SIZE) {
               //
               // We shoved the pointer to the memory into the
               // the type 3 buffer pointer which we KNOW we
               // never use.
               //

               ASSERT(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

               ExFreePool(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

               irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
            }

            Irp->IoStatus.Status = STATUS_CANCELLED;

            CyyCompleteRequest(Extension, Irp, 0);

            return STATUS_CANCELLED;
        } else {
            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);
            InsertTailList(QueueToExamine,&Irp->Tail.Overlay.ListEntry);
            IoSetCancelRoutine(Irp,CyyCancelQueued);
            IoReleaseCancelSpinLock(oldIrql);
            return STATUS_PENDING;
        }
    }
}

VOID
CyyCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*--------------------------------------------------------------------------
    CyyCancelQueued()
    
    Routine Description: This routine is used to cancel Irps that currently
    reside on a queue.

    Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

    Return Value: None.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    CYY_LOCKED_PAGED_CODE();

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);


    if (irpSp->MajorFunction == IRP_MJ_WRITE) {
	// write.  subtract from the count of characters to write.
        extension->TotalCharsQueued -= irpSp->Parameters.Write.Length;
    } else if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) {
        if ((irpSp->Parameters.DeviceIoControl.IoControlCode ==
             IOCTL_SERIAL_IMMEDIATE_CHAR) ||
            (irpSp->Parameters.DeviceIoControl.IoControlCode ==
             IOCTL_SERIAL_XOFF_COUNTER)) {

	    // immediate. Decrement the count of chars queued.
            extension->TotalCharsQueued--;
        } else if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                   IOCTL_SERIAL_SET_QUEUE_SIZE) {

	    // resize. Deallocate the pool passed "resizing" routine.
            // We shoved the pointer to the memory into the
            // the type 3 buffer pointer which we KNOW we never use.

            ASSERT(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);
            ExFreePool(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);
            irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
        }
    }
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    CyyCompleteRequest(extension, Irp, IO_SERIAL_INCREMENT);
}

NTSTATUS
CyyCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*--------------------------------------------------------------------------
    CyyCompleteIfError()
    
    Routine Description: If the current irp is not an
    IOCTL_SERIAL_GET_COMMSTATUS request and there is an error and the
    application requested abort on errors, then cancel the irp.

    Arguments:

    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP to test.

    Return Value:

    STATUS_SUCCESS or STATUS_CANCELLED.
--------------------------------------------------------------------------*/
{
    PCYY_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    NTSTATUS status = STATUS_SUCCESS;

    CYY_LOCKED_PAGED_CODE();

    if ((extension->HandFlow.ControlHandShake &
         SERIAL_ERROR_ABORT) && extension->ErrorWord) {

        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

        // There is a current error in the driver.  No requests should
        // come through except for the GET_COMMSTATUS.

        if ((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) ||
            (irpSp->Parameters.DeviceIoControl.IoControlCode !=
             IOCTL_SERIAL_GET_COMMSTATUS)) {

            status = STATUS_CANCELLED;
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            CyyCompleteRequest(extension, Irp, 0);
        }
    }
    return status;
}

VOID
CyyFilterCancelQueued(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)
/*++

Routine Description:

    This routine will be used cancel irps on the stalled queue.
    
Arguments:

    PDevObj - Pointer to the device object.
    
    PIrp - Pointer to the Irp to cancel

Return Value:

    None.

--*/
{
   PCYY_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   PIrp->IoStatus.Status = STATUS_CANCELLED;
   PIrp->IoStatus.Information = 0;

   RemoveEntryList(&PIrp->Tail.Overlay.ListEntry);

   IoReleaseCancelSpinLock(PIrp->CancelIrql);
}


VOID
CyyKillAllStalled(IN PDEVICE_OBJECT PDevObj)
{
   KIRQL cancelIrql;
   PDRIVER_CANCEL cancelRoutine;
   PCYY_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

   IoAcquireCancelSpinLock(&cancelIrql);

   while (!IsListEmpty(&pDevExt->StalledIrpQueue)) {

      PIRP currentLastIrp = CONTAINING_RECORD(pDevExt->StalledIrpQueue.Blink,
                                              IRP, Tail.Overlay.ListEntry);

      RemoveEntryList(pDevExt->StalledIrpQueue.Blink);

      cancelRoutine = currentLastIrp->CancelRoutine;
      currentLastIrp->CancelIrql = cancelIrql;
      currentLastIrp->CancelRoutine = NULL;
      currentLastIrp->Cancel = TRUE;

      cancelRoutine(PDevObj, currentLastIrp);

      IoAcquireCancelSpinLock(&cancelIrql);
   }

   IoReleaseCancelSpinLock(cancelIrql);
}

NTSTATUS
CyyFilterIrps(IN PIRP PIrp, IN PCYY_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This routine will be used to approve irps for processing.
    If an irp is approved, success will be returned.  If not,
    the irp will be queued or rejected outright.  The IoStatus struct
    and return value will appropriately reflect the actions taken.
    
Arguments:

    PIrp - Pointer to the Irp to cancel
    
    PDevExt - Pointer to the device extension

Return Value:

    None.

--*/
{
   PIO_STACK_LOCATION pIrpStack;
   KIRQL oldIrqlFlags;

   pIrpStack = IoGetCurrentIrpStackLocation(PIrp);

   KeAcquireSpinLock(&PDevExt->FlagsLock, &oldIrqlFlags);

   if ((PDevExt->DevicePNPAccept == CYY_PNPACCEPT_OK)
       && ((PDevExt->Flags & CYY_FLAGS_BROKENHW) == 0)) {
      KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrqlFlags);
      return STATUS_SUCCESS;
   }

   if ((PDevExt->DevicePNPAccept & CYY_PNPACCEPT_REMOVING)
       || (PDevExt->Flags & CYY_FLAGS_BROKENHW)
       || (PDevExt->DevicePNPAccept & CYY_PNPACCEPT_SURPRISE_REMOVING)) {

      KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrqlFlags);

      //
      // Accept all PNP IRP's -- we assume PNP can synchronize itself
      //

      if (pIrpStack->MajorFunction == IRP_MJ_PNP) {
         return STATUS_SUCCESS;
      }

      PIrp->IoStatus.Status = STATUS_DELETE_PENDING;
      return STATUS_DELETE_PENDING;
   }

   if (PDevExt->DevicePNPAccept & CYY_PNPACCEPT_STOPPING) {
       KIRQL oldIrql;

       KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrqlFlags);


      //
      // Accept all PNP IRP's -- we assume PNP can synchronize itself
      //

      if (pIrpStack->MajorFunction == IRP_MJ_PNP) {
         return STATUS_SUCCESS;
      }

      IoAcquireCancelSpinLock(&oldIrql);

      if (PIrp->Cancel) {
         IoReleaseCancelSpinLock(oldIrql);
         PIrp->IoStatus.Status = STATUS_CANCELLED;
         return STATUS_CANCELLED;
      } else {
         //
         // Mark the Irp as pending
         //

         PIrp->IoStatus.Status = STATUS_PENDING;
         IoMarkIrpPending(PIrp);

         //
         // Queue up the IRP
         //

         InsertTailList(&PDevExt->StalledIrpQueue,
                        &PIrp->Tail.Overlay.ListEntry);

         IoSetCancelRoutine(PIrp, CyyFilterCancelQueued);
         IoReleaseCancelSpinLock(oldIrql);
         return STATUS_PENDING;
      }
   }

   KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrqlFlags);

   return STATUS_SUCCESS;
}

VOID
CyyUnstallIrps(IN PCYY_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This routine will be used to restart irps temporarily stalled on
    the stall queue due to a stop or some such nonsense.
    
Arguments:

    PDevExt - Pointer to the device extension

Return Value:

    None.

--*/
{
   PLIST_ENTRY pIrpLink;
   PIRP pIrp;
   PIO_STACK_LOCATION pIrpStack;
   PDEVICE_OBJECT pDevObj;
   PDRIVER_OBJECT pDrvObj;
   KIRQL oldIrql;

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyUnstallIrps(%X)\n", PDevExt);
   IoAcquireCancelSpinLock(&oldIrql);

   pIrpLink = PDevExt->StalledIrpQueue.Flink;

   while (pIrpLink != &PDevExt->StalledIrpQueue) {
      pIrp = CONTAINING_RECORD(pIrpLink, IRP, Tail.Overlay.ListEntry);
      RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);

      pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
      pDevObj = pIrpStack->DeviceObject;
      pDrvObj = pDevObj->DriverObject;
      IoSetCancelRoutine(pIrp, NULL);
      IoReleaseCancelSpinLock(oldIrql);

      CyyDbgPrintEx(CYYPNPPOWER, "Unstalling Irp 0x%x with 0x%x\n",
                                     pIrp, pIrpStack->MajorFunction);

      pDrvObj->MajorFunction[pIrpStack->MajorFunction](pDevObj, pIrp);

      IoAcquireCancelSpinLock(&oldIrql);
      pIrpLink = PDevExt->StalledIrpQueue.Flink;
   }

   IoReleaseCancelSpinLock(oldIrql);

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyUnstallIrps\n");
}

NTSTATUS
CyyIRPPrologue(IN PIRP PIrp, IN PCYY_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called at any IRP dispatch entry point.  It,
   with CyyIRPEpilogue(), keeps track of all pending IRP's for the given
   PDevObj.
   
Arguments:

   PDevObj - Pointer to the device object we are tracking pending IRP's for.

Return Value:

    Tentative status of the Irp.

--*/
{
   InterlockedIncrement(&PDevExt->PendingIRPCnt);

   return CyyFilterIrps(PIrp, PDevExt);
}

VOID
CyyIRPEpilogue(IN PCYY_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called at any IRP dispatch entry point.  It,
   with CyyIRPPrologue(), keeps track of all pending IRP's for the given
   PDevObj.
   
Arguments:

   PDevObj - Pointer to the device object we are tracking pending IRP's for.

Return Value:

   None.

--*/
{
   LONG pendingCnt;

   pendingCnt = InterlockedDecrement(&PDevExt->PendingIRPCnt);

   ASSERT(pendingCnt >= 0);

   if (pendingCnt == 0) {
      KeSetEvent(&PDevExt->PendingIRPEvent, IO_NO_INCREMENT, FALSE);
   }
}

BOOLEAN
CyyInsertQueueDpc(IN PRKDPC PDpc, IN PVOID Sarg1, IN PVOID Sarg2,
                  IN PCYY_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called to queue DPC's for the serial driver.
   
Arguments:

   PDpc thru Sarg2  - Standard args to KeInsertQueueDpc()
   
   PDevExt - Pointer to the device extension for the device that needs to
             queue a DPC

Return Value:

   Kicks up return value from KeInsertQueueDpc()

--*/
{
   BOOLEAN queued;

   InterlockedIncrement(&PDevExt->DpcCount);
   LOGENTRY(LOG_CNT, 'DpI1', PDpc, PDevExt->DpcCount, 0);   // Added in build 2128

   queued = KeInsertQueueDpc(PDpc, Sarg1, Sarg2);

   if (!queued) {
      ULONG pendingCnt;

      pendingCnt = InterlockedDecrement(&PDevExt->DpcCount);
//      LOGENTRY(LOG_CNT, 'DpD1', PDpc, PDevExt->DpcCount, 0);  Added in build 2128

      if (pendingCnt == 0) {
         KeSetEvent(&PDevExt->PendingIRPEvent, IO_NO_INCREMENT, FALSE);
         LOGENTRY(LOG_CNT, 'DpF1', PDpc, PDevExt->DpcCount, 0); // Added in build 2128
      }
   }

#if 0 // DBG
   if (queued) {
      int i;

      for (i = 0; i < MAX_DPC_QUEUE; i++) {
                     if (PDevExt->DpcQueued[i].Dpc == PDpc) {
                        PDevExt->DpcQueued[i].QueuedCount++;
                        break;
                     }
      }

      ASSERT(i < MAX_DPC_QUEUE);
   }
#endif

   return queued;
}


BOOLEAN
CyySetTimer(IN PKTIMER Timer, IN LARGE_INTEGER DueTime,
            IN PKDPC Dpc OPTIONAL, IN PCYY_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called to set timers for the serial driver.
   
Arguments:

   Timer - pointer to timer dispatcher object
   
   DueTime - time at which the timer should expire
   
   Dpc - option Dpc
   
   PDevExt - Pointer to the device extension for the device that needs to
             set a timer

Return Value:

   Kicks up return value from KeSetTimer()

--*/
{
   BOOLEAN set;

   InterlockedIncrement(&PDevExt->DpcCount);
   LOGENTRY(LOG_CNT, 'DpI2', Dpc, PDevExt->DpcCount, 0);    // Added in build 2128

   set = KeSetTimer(Timer, DueTime, Dpc);

   if (set) {
      InterlockedDecrement(&PDevExt->DpcCount);
//      LOGENTRY(LOG_CNT, 'DpD2', Dpc, PDevExt->DpcCount, 0);   // Added in build 2128
   }

#if 0 // DBG
   if (set) {
      int i;

      for (i = 0; i < MAX_DPC_QUEUE; i++) {
                     if (PDevExt->DpcQueued[i].Dpc == Dpc) {
                        PDevExt->DpcQueued[i].QueuedCount++;
                        break;
                     }
      }

      ASSERT(i < MAX_DPC_QUEUE);
   }
#endif

   return set;
}


BOOLEAN
CyyCancelTimer(IN PKTIMER Timer, IN PCYY_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called to cancel timers for the serial driver.
   
Arguments:

   Timer - pointer to timer dispatcher object
   
   PDevExt - Pointer to the device extension for the device that needs to
             set a timer

Return Value:

  True if timer was cancelled

--*/
{
   BOOLEAN cancelled;

   cancelled = KeCancelTimer(Timer);

   if (cancelled) {
      CyyDpcEpilogue(PDevExt, Timer->Dpc);
   }

   return cancelled;
}


VOID
CyyDpcEpilogue(IN PCYY_DEVICE_EXTENSION PDevExt, PKDPC PDpc)
/*++

Routine Description:

   This function must be called at the end of every dpc function.
   
Arguments:

   PDevObj - Pointer to the device object we are tracking dpc's for.

Return Value:

   None.

--*/
{
   LONG pendingCnt;
#if 1 // !DBG
   UNREFERENCED_PARAMETER(PDpc);
#endif

   pendingCnt = InterlockedDecrement(&PDevExt->DpcCount);
//   LOGENTRY(LOG_CNT, 'DpD3', PDpc, PDevExt->DpcCount, 0); Added in build 2128

   ASSERT(pendingCnt >= 0);

#if 0 //DBG
{
      int i;

      for (i = 0; i < MAX_DPC_QUEUE; i++) {
                     if (PDevExt->DpcQueued[i].Dpc == PDpc) {
                        PDevExt->DpcQueued[i].FlushCount++;

                        ASSERT(PDevExt->DpcQueued[i].QueuedCount >=
                               PDevExt->DpcQueued[i].FlushCount);
                        break;
                     }
      }

      ASSERT(i < MAX_DPC_QUEUE);
   }
#endif

   if (pendingCnt == 0) {
      KeSetEvent(&PDevExt->PendingDpcEvent, IO_NO_INCREMENT, FALSE);
      LOGENTRY(LOG_CNT, 'DpF2', PDpc, PDevExt->DpcCount, 0);    // Added in build 2128
   }
}



VOID
CyyUnlockPages(IN PKDPC PDpc, IN PVOID PDeferredContext,
               IN PVOID PSysContext1, IN PVOID PSysContext2)
/*++

Routine Description:

   This function is a DPC routine queue from the ISR if he released the
   last lock on pending DPC's.
   
Arguments:

   PDpdc, PSysContext1, PSysContext2 -- not used
   
   PDeferredContext -- Really the device extension

Return Value:

   None.

--*/
{
   PCYY_DEVICE_EXTENSION pDevExt
      = (PCYY_DEVICE_EXTENSION)PDeferredContext;

   UNREFERENCED_PARAMETER(PDpc);
   UNREFERENCED_PARAMETER(PSysContext1);
   UNREFERENCED_PARAMETER(PSysContext2);

   KeSetEvent(&pDevExt->PendingDpcEvent, IO_NO_INCREMENT, FALSE);
}


NTSTATUS
CyyIoCallDriver(PCYY_DEVICE_EXTENSION PDevExt, PDEVICE_OBJECT PDevObj,
                PIRP PIrp)
/*++

Routine Description:

   This function must be called instead of IoCallDriver.  It automatically
   updates Irp tracking for PDevObj.
   
Arguments:
   PDevExt - Device extension attached to PDevObj
   
   PDevObj - Pointer to the device object we are tracking pending IRP's for.
   
   PIrp - Pointer to the Irp we are passing to the next driver.

Return Value:

   None.

--*/
{
   NTSTATUS status;

   status = IoCallDriver(PDevObj, PIrp);
   CyyIRPEpilogue(PDevExt);
   return status;
}



NTSTATUS
CyyPoCallDriver(PCYY_DEVICE_EXTENSION PDevExt, PDEVICE_OBJECT PDevObj,
                PIRP PIrp)
/*++

Routine Description:

   This function must be called instead of PoCallDriver.  It automatically
   updates Irp tracking for PDevObj.
   
Arguments:
   PDevExt - Device extension attached to PDevObj
   
   PDevObj - Pointer to the device object we are tracking pending IRP's for.
   
   PIrp - Pointer to the Irp we are passing to the next driver.

Return Value:

   None.

--*/
{
   NTSTATUS status;

   status = PoCallDriver(PDevObj, PIrp);
   CyyIRPEpilogue(PDevExt);
   return status;
}


VOID
CyyLogError(
              IN PDRIVER_OBJECT DriverObject,
              IN PDEVICE_OBJECT DeviceObject OPTIONAL,
              IN PHYSICAL_ADDRESS P1,
              IN PHYSICAL_ADDRESS P2,
              IN ULONG SequenceNumber,
              IN UCHAR MajorFunctionCode,
              IN UCHAR RetryCount,
              IN ULONG UniqueErrorValue,
              IN NTSTATUS FinalStatus,
              IN NTSTATUS SpecificIOStatus,
              IN ULONG LengthOfInsert1,
              IN PWCHAR Insert1,
              IN ULONG LengthOfInsert2,
              IN PWCHAR Insert2
              )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject - A pointer to the driver object for the device.

    DeviceObject - A pointer to the device object associated with the
    device that had the error, early in initialization, one may not
    yet exist.

    P1,P2 - If phyical addresses for the controller ports involved
    with the error are available, put them through as dump data.

    SequenceNumber - A ulong value that is unique to an IRP over the
    life of the irp in this driver - 0 generally means an error not
    associated with an irp.

    MajorFunctionCode - If there is an error associated with the irp,
    this is the major function code of that irp.

    RetryCount - The number of times a particular operation has been
    retried.

    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.

    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.

    SpecificIOStatus - The IO status for a particular error.

    LengthOfInsert1 - The length in bytes (including the terminating NULL)
                      of the first insertion string.

    Insert1 - The first insertion string.

    LengthOfInsert2 - The length in bytes (including the terminating NULL)
                      of the second insertion string.  NOTE, there must
                      be a first insertion string for their to be
                      a second insertion string.

    Insert2 - The second insertion string.

Return Value:

    None.

--*/

{
   PIO_ERROR_LOG_PACKET errorLogEntry;

   PVOID objectToUse;
   SHORT dumpToAllocate = 0;
   PUCHAR ptrToFirstInsert;
   PUCHAR ptrToSecondInsert;

   //PAGED_CODE(); It can be called at raised IRQL.

   if (Insert1 == NULL) {
      LengthOfInsert1 = 0;
   }

   if (Insert2 == NULL) {
      LengthOfInsert2 = 0;
   }


   if (ARGUMENT_PRESENT(DeviceObject)) {

      objectToUse = DeviceObject;

   } else {

      objectToUse = DriverObject;

   }

   if (CyyMemCompare(
                       P1,
                       (ULONG)1,
                       CyyPhysicalZero,
                       (ULONG)1
                       ) != AddressesAreEqual) {

      dumpToAllocate = (SHORT)sizeof(PHYSICAL_ADDRESS);

   }

   if (CyyMemCompare(
                       P2,
                       (ULONG)1,
                       CyyPhysicalZero,
                       (ULONG)1
                       ) != AddressesAreEqual) {

      dumpToAllocate += (SHORT)sizeof(PHYSICAL_ADDRESS);

   }

   errorLogEntry = IoAllocateErrorLogEntry(
                                          objectToUse,
                                          (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                                  dumpToAllocate
                                                  + LengthOfInsert1 +
                                                  LengthOfInsert2)
                                          );

   if ( errorLogEntry != NULL ) {

      errorLogEntry->ErrorCode = SpecificIOStatus;
      errorLogEntry->SequenceNumber = SequenceNumber;
      errorLogEntry->MajorFunctionCode = MajorFunctionCode;
      errorLogEntry->RetryCount = RetryCount;
      errorLogEntry->UniqueErrorValue = UniqueErrorValue;
      errorLogEntry->FinalStatus = FinalStatus;
      errorLogEntry->DumpDataSize = dumpToAllocate;

      if (dumpToAllocate) {

         RtlCopyMemory(
                      &errorLogEntry->DumpData[0],
                      &P1,
                      sizeof(PHYSICAL_ADDRESS)
                      );

         if (dumpToAllocate > sizeof(PHYSICAL_ADDRESS)) {

            RtlCopyMemory(
                         ((PUCHAR)&errorLogEntry->DumpData[0])
                         +sizeof(PHYSICAL_ADDRESS),
                         &P2,
                         sizeof(PHYSICAL_ADDRESS)
                         );

            ptrToFirstInsert =
            ((PUCHAR)&errorLogEntry->DumpData[0])+(2*sizeof(PHYSICAL_ADDRESS));

         } else {

            ptrToFirstInsert =
            ((PUCHAR)&errorLogEntry->DumpData[0])+sizeof(PHYSICAL_ADDRESS);


         }

      } else {

         ptrToFirstInsert = (PUCHAR)&errorLogEntry->DumpData[0];

      }

      ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

      if (LengthOfInsert1) {

         errorLogEntry->NumberOfStrings = 1;
         errorLogEntry->StringOffset = (USHORT)(ptrToFirstInsert -
                                                (PUCHAR)errorLogEntry);
         RtlCopyMemory(
                      ptrToFirstInsert,
                      Insert1,
                      LengthOfInsert1
                      );

         if (LengthOfInsert2) {

            errorLogEntry->NumberOfStrings = 2;
            RtlCopyMemory(
                         ptrToSecondInsert,
                         Insert2,
                         LengthOfInsert2
                         );

         }

      }

      IoWriteErrorLogEntry(errorLogEntry);

   }

}

VOID
CyyMarkHardwareBroken(IN PCYY_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   Marks a UART as broken.  This causes the driver stack to stop accepting
   requests and eventually be removed.
   
Arguments:
   PDevExt - Device extension attached to PDevObj
   
Return Value:

   None.

--*/
{
   PAGED_CODE();

   //
   // Mark as damaged goods
   //

   CyySetFlags(PDevExt, CYY_FLAGS_BROKENHW);

   //
   // Write a log entry
   //

   CyyLogError(PDevExt->DriverObject, NULL, CyyPhysicalZero,
               CyyPhysicalZero, 0, 0, 0, PDevExt->PortIndex+1, STATUS_SUCCESS,
               CYY_HARDWARE_FAILURE, PDevExt->DeviceName.Length
               + sizeof(WCHAR), PDevExt->DeviceName.Buffer, 0, NULL);

   //
   // Invalidate the device
   //

   IoInvalidateDeviceState(PDevExt->Pdo);
}

VOID
CyySetDeviceFlags(IN PCYY_DEVICE_EXTENSION PDevExt, OUT PULONG PFlags, 
                  IN ULONG Value, IN BOOLEAN Set)
/*++

Routine Description:

   Sets flags in a value protected by the flags spinlock.  This is used
   to set values that would stop IRP's from being accepted.
   
Arguments:
   PDevExt - Device extension attached to PDevObj
   
   PFlags - Pointer to the flags variable that needs changing
   
   Value - Value to modify flags variable with
   
   Set - TRUE if |= , FALSE if &=
   
Return Value:

   None.

--*/
{
   KIRQL oldIrql;

   KeAcquireSpinLock(&PDevExt->FlagsLock, &oldIrql);

   if (Set) {
      *PFlags |= Value;
   } else {
      *PFlags &= ~Value;
   }

   KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyports\cyfriend.c ===
/** FILE: cyfriend.c ********** Module Header ********************************
 *
 *
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/

#include "cyyports.h"

//
//  For Cyyport
//
TCHAR y_szCyyPort[] = TEXT("Cyclom-Y Port ");
TCHAR y_szPortIndex[] = TEXT("PortIndex");



BOOL
ReplaceFriendlyName(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PTCHAR           NewComName
)
{

    DEVINST         parentInst;
    HDEVINFO        parentInfo;
    SP_DEVINFO_DATA parentData;
    TCHAR           parentId[MAX_DEVICE_ID_LEN];
    TCHAR           charBuffer[MAX_PATH],
                    deviceDesc[LINE_LEN];
    HKEY            hDeviceKey;
    TCHAR           PortName[20];
    DWORD           PortNameSize,PortIndexSize,PortIndex;
    DWORD           dwErr;
    PTCHAR          comName = NULL;
    DWORD           portNumber = 0;

    //DbgOut(TEXT("ReplaceFriendlyName\n"));

    if((hDeviceKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                          DeviceInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DEV,
                                          KEY_READ)) == INVALID_HANDLE_VALUE) {
        DbgOut(TEXT("SetupDiOpenDevRegKey failed\n"));
        return FALSE;
    }

    PortNameSize = sizeof(PortName);
    dwErr = RegQueryValueEx(hDeviceKey,
                          m_szPortName,
                          NULL,
                          NULL,
                          (PBYTE)PortName,
                          &PortNameSize
                          );

    if (dwErr == ERROR_SUCCESS) {
    PortIndexSize = sizeof(PortIndex);
    dwErr = RegQueryValueEx(hDeviceKey,
                          y_szPortIndex,
                          NULL,
                          NULL,
                          (PBYTE)&PortIndex,
                          &PortIndexSize
                          );
    }

    RegCloseKey(hDeviceKey);

    if(dwErr != ERROR_SUCCESS) {
        DbgOut(TEXT("RegQueryValueEx failed\n"));
        return FALSE;
    }
    if (NewComName == NULL) {
        comName = PortName;
    } else {
        comName = NewComName;
    }
    if (comName == NULL) {
        DbgOut(TEXT("comName NULL\n"));
        return FALSE;
    }

    portNumber = PortIndex+1;

    if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                          DeviceInfoData,
                                          SPDRP_DEVICEDESC,
                                          NULL,
                                          (PBYTE)deviceDesc,
                                          sizeof(deviceDesc),
                                          NULL)) {
        DbgOut(TEXT("Couldn't get Device Description\n"));
        return FALSE;
    }

    if (_tcsnicmp (deviceDesc,y_szCyyPort,_tcslen(y_szCyyPort)) != 0){
        DbgOut(TEXT("Device Description is different of Cyclom-Y Port \n"));
        return FALSE;
    }
    
    if (portNumber == 0) {
        DbgOut(TEXT("Invalid portNumber\n"));
        return FALSE;
    }

    if (CM_Get_Parent(&parentInst,DeviceInfoData->DevInst,0) != CR_SUCCESS) {
        DbgOut(TEXT("CM_Get_Parent failed.\n"));
        return FALSE;
    }

    if (CM_Get_Device_ID(parentInst,parentId,CharSizeOf(parentId),0) != CR_SUCCESS) {
        DbgOut(TEXT("CM_Get_Device_ID failed.\n"));
        return FALSE;
    }

    parentInfo = SetupDiCreateDeviceInfoList(NULL,NULL);

    if (parentInfo == INVALID_HANDLE_VALUE) {
        DbgOut(TEXT("SetupDiCreateDeviceInfoList failed\n"));
        return FALSE;
    }
    
    parentData.cbSize = sizeof(SP_DEVINFO_DATA);

    if (SetupDiOpenDeviceInfo(parentInfo,parentId,NULL,0,&parentData)) {

        if (SetupDiGetDeviceRegistryProperty(parentInfo,
                                             &parentData,
                                             SPDRP_FRIENDLYNAME,
                                             NULL,
                                             (PBYTE)deviceDesc,
                                             sizeof(deviceDesc),
                                             NULL) ||  
            SetupDiGetDeviceRegistryProperty(parentInfo,
                                             &parentData,
                                             SPDRP_DEVICEDESC,
                                             NULL,
                                             (PBYTE)deviceDesc,
                                             sizeof(deviceDesc),
                                             NULL)) {
            wsprintf(charBuffer,TEXT("%s Port %2u (%s)"),deviceDesc,portNumber,comName);
//          #if DBG
//          {
//           TCHAR buf[500];
//           wsprintf(buf, TEXT("%s\n"), charBuffer);
//           DbgOut(buf);
//          }
//          #endif

            SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                             DeviceInfoData,
                                             SPDRP_FRIENDLYNAME,
                                             (PBYTE)charBuffer,
                                              ByteCountOf(_tcslen(charBuffer) + 1)
                                             );

        }

    } else {
        #if DBG
        {
         TCHAR buf[500];
         wsprintf(buf, TEXT("SetupDiOpenDeviceInfo failed with error %x\n"), GetLastError());
         DbgOut(buf);
        }
        #endif
    }
    
    SetupDiDestroyDeviceInfoList(parentInfo);    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyports\cyfriend.h ===
/** FILE: cyfriend.h ********* Module Header ********************************
 *
 *
 * History:
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/
//==========================================================================
//                            Include Files
//==========================================================================

#ifndef CYFRIEND_H
#define CYFRIEND_H


//==========================================================================
//                            Function Prototypes
//==========================================================================

//
//  cyfriend.c
//
extern
BOOL
ReplaceFriendlyName(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PTCHAR           NewComName
);



#endif // CYFRIEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyywmi.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyywmi.c
*	
*   Description:    This module contains the code related to write 
*                   operations in the Cyclom-Y Port driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "precomp.h"
#include <wmistr.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESRP0, CyySystemControlDispatch)
#pragma alloc_text(PAGESRP0, CyyTossWMIRequest)
#pragma alloc_text(PAGESRP0, CyySetWmiDataItem)
#pragma alloc_text(PAGESRP0, CyySetWmiDataBlock)
#pragma alloc_text(PAGESRP0, CyyQueryWmiDataBlock)
#pragma alloc_text(PAGESRP0, CyyQueryWmiRegInfo)
#endif


NTSTATUS
CyySystemControlDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;
    PCYY_DEVICE_EXTENSION pDevExt
      = (PCYY_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    PAGED_CODE();

    //CyyDump (CYYWMI, ("CYYPORT: entering CyySystemControlDispatch\n"));

    status = WmiSystemControl(   &pDevExt->WmiLibInfo,
                                 DeviceObject, 
                                 Irp,
                                 &disposition);
    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            //CyyDump (CYYWMI, ("WmiSystemControl: IrpProcessed\n"));
            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            //CyyDump (CYYWMI, ("WmiSystemControl: IrpNotCompleted\n"));
            IoCompleteRequest(Irp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            //CyyDump (CYYWMI, ("WmiSystemControl: IrpForward or IrpNotWmi\n"));
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(pDevExt->LowerDeviceObject, Irp);
            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(pDevExt->LowerDeviceObject, Irp);
            break;
        }        
    }

    //CyyDump (CYYWMI, ("CYYPORT: leaving CyySystemControlDispatch\n"));
    
    return(status);

}


#define WMI_SERIAL_PORT_NAME_INFORMATION 0
#define WMI_SERIAL_PORT_COMM_INFORMATION 1
#define WMI_SERIAL_PORT_HW_INFORMATION   2
#define WMI_SERIAL_PORT_PERF_INFORMATION 3
#define WMI_SERIAL_PORT_PROPERTIES       4

GUID SerialPortNameGuid = SERIAL_PORT_WMI_NAME_GUID;
GUID SerialPortCommGuid = SERIAL_PORT_WMI_COMM_GUID;
GUID SerialPortHWGuid = SERIAL_PORT_WMI_HW_GUID;
GUID SerailPortPerfGuid = SERIAL_PORT_WMI_PERF_GUID;
GUID SerialPortPropertiesGuid = SERIAL_PORT_WMI_PROPERTIES_GUID;

WMIGUIDREGINFO SerialWmiGuidList[SERIAL_WMI_GUID_LIST_SIZE] =
{
    { &SerialPortNameGuid, 1, 0 },
    { &SerialPortCommGuid, 1, 0 },
    { &SerialPortHWGuid, 1, 0 },
    { &SerailPortPerfGuid, 1, 0 },
    { &SerialPortPropertiesGuid, 1, 0}
};

//
// WMI System Call back functions
//



NTSTATUS
CyyTossWMIRequest(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                  IN ULONG GuidIndex)
{
   PCYY_DEVICE_EXTENSION pDevExt;
   NTSTATUS status;

   PAGED_CODE();

   pDevExt = (PCYY_DEVICE_EXTENSION)PDevObj->DeviceExtension;

   switch (GuidIndex) {

   case WMI_SERIAL_PORT_NAME_INFORMATION:
   case WMI_SERIAL_PORT_COMM_INFORMATION:
   case WMI_SERIAL_PORT_HW_INFORMATION:
   case WMI_SERIAL_PORT_PERF_INFORMATION:
   case WMI_SERIAL_PORT_PROPERTIES:
      status = STATUS_INVALID_DEVICE_REQUEST;
      break;

   default:
      status = STATUS_WMI_GUID_NOT_FOUND;
      break;
   }

   status = WmiCompleteRequest(PDevObj, PIrp,
                                 status, 0, IO_NO_INCREMENT);

   return status;
}


NTSTATUS
CyySetWmiDataItem(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                  IN ULONG GuidIndex, IN ULONG InstanceIndex,
                  IN ULONG DataItemId,
                  IN ULONG BufferSize, IN PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    PBuffer has the new values for the data item


Return Value:

    status

--*/
{
   PAGED_CODE();

   //
   // Toss this request -- we don't support anything for it
   //

   //CyyDump (CYYWMI, ("CyySetWmiDataItem\n"));
   return CyyTossWMIRequest(PDevObj, PIrp, GuidIndex);
}


NTSTATUS
CyySetWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                   IN ULONG GuidIndex, IN ULONG InstanceIndex,
                   IN ULONG BufferSize,
                   IN PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    PBuffer has the new values for the data block


Return Value:

    status

--*/
{
   PAGED_CODE();

   //
   // Toss this request -- we don't support anything for it
   //

   //CyyDump (CYYWMI, ("CyySetWmiDataBlock\n"));
   return CyyTossWMIRequest(PDevObj, PIrp, GuidIndex);
}


NTSTATUS
CyyQueryWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex, 
                     IN ULONG InstanceIndex,
                     IN ULONG InstanceCount,
                     IN OUT PULONG InstanceLengthArray,
                     IN ULONG OutBufferSize,
                     OUT PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
            
    BufferAvail on has the maximum size available to write the data
        block.

    PBuffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    ULONG size = 0;
    PCYY_DEVICE_EXTENSION pDevExt
       = (PCYY_DEVICE_EXTENSION)PDevObj->DeviceExtension;

    PAGED_CODE();

    //CyyDump (CYYWMI, ("CyyQueryWmiDataBlock GuidIndex=%d InstanceIndex=%d InstanceCount=%d\n",
    //                             GuidIndex,InstanceIndex,InstanceCount));

    switch (GuidIndex) {
    case WMI_SERIAL_PORT_NAME_INFORMATION:
       //CyyDump (CYYWMI, ("CyyQueryWmiDataBlock WMI_SERIAL_PORT_NAME_INFORMATION\n"));
       size = pDevExt->WmiIdentifier.Length;

       if (OutBufferSize < (size + sizeof(USHORT))) {
            size += sizeof(USHORT);
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

       if (pDevExt->WmiIdentifier.Buffer == NULL) {
           status = STATUS_INSUFFICIENT_RESOURCES;
           break;
        }

        //
        // First, copy the string over containing our identifier
        //

        *(USHORT *)PBuffer = (USHORT)size;
        (UCHAR *)PBuffer += sizeof(USHORT);

        RtlCopyMemory(PBuffer, pDevExt->WmiIdentifier.Buffer, size);

        //
        // Increment total size to include the WORD containing our len
        //

        size += sizeof(USHORT);
        *InstanceLengthArray = size;
                
        status = STATUS_SUCCESS;

        break;

    case WMI_SERIAL_PORT_COMM_INFORMATION: 
       //CyyDump (CYYWMI, ("CyyQueryWmiDataBlock WMI_SERIAL_PORT_COMM_INFORMATION\n"));
       size = sizeof(SERIAL_WMI_COMM_DATA);

       if (OutBufferSize < size) {
          status = STATUS_BUFFER_TOO_SMALL;
          break;
        }

        *InstanceLengthArray = size;
        *(PSERIAL_WMI_COMM_DATA)PBuffer = pDevExt->WmiCommData;

        status = STATUS_SUCCESS;

        break;

    case WMI_SERIAL_PORT_HW_INFORMATION:
       //CyyDump (CYYWMI, ("CyyQueryWmiDataBlock WMI_SERIAL_PORT_HW_INFORMATION\n"));
       size = sizeof(SERIAL_WMI_HW_DATA);

       if (OutBufferSize < size) {
          status = STATUS_BUFFER_TOO_SMALL;
          break;
       }

       *InstanceLengthArray = size;
       *(PSERIAL_WMI_HW_DATA)PBuffer = pDevExt->WmiHwData;

       status = STATUS_SUCCESS;

       break;

    case WMI_SERIAL_PORT_PERF_INFORMATION: 
      //CyyDump (CYYWMI, ("CyyQueryWmiDataBlock WMI_SERIAL_PORT_PERF_INFORMATION\n"));
      size = sizeof(SERIAL_WMI_PERF_DATA);

      if (OutBufferSize < size) {
         status = STATUS_BUFFER_TOO_SMALL;
         break;
      }

      *InstanceLengthArray = size;
      *(PSERIAL_WMI_PERF_DATA)PBuffer = pDevExt->WmiPerfData;

      status = STATUS_SUCCESS;

      break;

    case WMI_SERIAL_PORT_PROPERTIES: 
      //CyyDump (CYYWMI, ("CyyQueryWmiDataBlock WMI_SERIAL_PORT_PROPERTIES\n"));
      size = sizeof(SERIAL_COMMPROP) + sizeof(ULONG);

      if (OutBufferSize < size) {
         status = STATUS_BUFFER_TOO_SMALL;
         break;
      }

      *InstanceLengthArray = size;
      CyyGetProperties(
                pDevExt,
                (PSERIAL_COMMPROP)PBuffer
                );
	
      *((PULONG)(((PSERIAL_COMMPROP)PBuffer)->ProvChar)) = 0;

      status = STATUS_SUCCESS;

      break;

    default:
        //CyyDump (CYYWMI, ("CyyQueryWmiDataBlock default\n"));
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest( PDevObj, PIrp,
                                  status, size, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
CyyQueryWmiRegInfo(IN PDEVICE_OBJECT PDevObj, OUT PULONG PRegFlags,
                   OUT PUNICODE_STRING PInstanceName,
                   OUT PUNICODE_STRING *PRegistryPath,
                   OUT PUNICODE_STRING MofResourceName,
                   OUT PDEVICE_OBJECT *Pdo)
                                                  
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered. 
            
    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.               

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is 
        required
                
    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
                
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
   PCYY_DEVICE_EXTENSION pDevExt
       = (PCYY_DEVICE_EXTENSION)PDevObj->DeviceExtension;
   
   PAGED_CODE();

   //CyyDump (CYYWMI, ("CyyQueryWmiRegInfo\n"));
   *PRegFlags = WMIREG_FLAG_INSTANCE_PDO;
   *PRegistryPath = &CyyGlobals.RegistryPath;
   *Pdo = pDevExt->Pdo;

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\cyywrite.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1996-1999.
*   All rights reserved.
*	
*   Cyclom-Y Port Driver
*	
*   This file:      cyywrite.c
*	
*   Description:    This module contains the code related to write 
*                   operations in the Cyclom-Y Port driver.
*
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and IA64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#include "precomp.h"


BOOLEAN
CyyGiveWriteToIsr(
    IN PVOID Context
    );

VOID
CyyCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
CyyGrabWriteFromIsr(
    IN PVOID Context
    );

BOOLEAN
CyyGrabXoffFromIsr(
    IN PVOID Context
    );

VOID
CyyCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
CyyGiveXoffToIsr(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,CyyProcessEmptyTransmit)
#pragma alloc_text(PAGESER,CyyWrite)
#pragma alloc_text(PAGESER,CyyStartWrite)
#pragma alloc_text(PAGESER,CyyGetNextWrite)
#pragma alloc_text(PAGESER,CyyGiveWriteToIsr)
#pragma alloc_text(PAGESER,CyyCancelCurrentWrite)
#pragma alloc_text(PAGESER,CyyGrabWriteFromIsr)
#pragma alloc_text(PAGESER,CyyGrabXoffFromIsr)
#pragma alloc_text(PAGESER,CyyCancelCurrentXoff)
#pragma alloc_text(PAGESER,CyyGiveXoffToIsr)
#endif


NTSTATUS
CyyWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*--------------------------------------------------------------------------
    CyyWrite()
    
    Routine Description: This is the dispatch routine for write. It
    validates the parameters for the write request and if all is ok
    then it places the request on the work queue.

    Arguments:

    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request

    Return Value: If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return STATUS_PENDING.
--------------------------------------------------------------------------*/
{

    PCYY_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    CYY_LOCKED_PAGED_CODE();

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyWrite(%X, %X)\n", DeviceObject,
                  Irp);

    if ((status = CyyIRPPrologue(Irp, Extension)) != STATUS_SUCCESS) {
      CyyCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
      CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyWrite (1) %X\n", status);
      return status;
    }

    CyyDbgPrintEx(CYYIRPPATH, "Dispatch entry for: %x\n", Irp);

    if (CyyCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS) {
       CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyWrite (2) %X\n",
                     STATUS_CANCELLED);
       return STATUS_CANCELLED;
    }

    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length write.  If it is zero length
    // then we are already done!
    //

    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length) {

        //
        // Well it looks like we actually have to do some
        // work.  Put the write on the queue so that we can
        // process it when our previous writes are done.
        //


       status = CyyStartOrQueue(Extension, Irp, &Extension->WriteQueue,
                                &Extension->CurrentWriteIrp,
                                CyyStartWrite);

       CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyWrite (3) %X\n", status);

       return status;

    } else {

        Irp->IoStatus.Status = STATUS_SUCCESS;

        CyyCompleteRequest(Extension, Irp, 0);

        CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyWrite (4) %X\n",
                      STATUS_SUCCESS);

        return STATUS_SUCCESS;

    }

}

NTSTATUS
CyyStartWrite(
    IN PCYY_DEVICE_EXTENSION Extension
    )
/*--------------------------------------------------------------------------
    CyyStartWrite()

    Routine Description: This routine is used to start off any write.
    It initializes the Iostatus fields of the irp.  It will set up any
    timers that are used to control the write.

    Arguments:

    Extension - Points to the serial device extension

    Return Value: This routine will return STATUS_PENDING for all writes
    other than those that we find are cancelled.
--------------------------------------------------------------------------*/
{
    PIRP NewIrp;
    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;
    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    CYY_LOCKED_PAGED_CODE();

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyStartWrite(%X)\n", Extension);

    do {
        // If there is an xoff counter then complete it.
        IoAcquireCancelSpinLock(&OldIrql);

        // We see if there is a actually an Xoff counter irp.
        //
        // If there is, we put the write irp back on the head
        // of the write list.  We then kill the xoff counter.
        // The xoff counter killing code will actually make the
        // xoff counter back into the current write irp, and
        // in the course of completing the xoff (which is now
        // the current write) we will restart this irp.

        if (Extension->CurrentXoffIrp) {
            if (SERIAL_REFERENCE_COUNT(Extension->CurrentXoffIrp)) {
                // The reference count is non-zero.  This implies that
                // the xoff irp has not made it through the completion
                // path yet.  We will increment the reference count
                // and attempt to complete it ourseleves.

                SERIAL_SET_REFERENCE(Extension->CurrentXoffIrp,
						SERIAL_REF_XOFF_REF);

                Extension->CurrentXoffIrp->IoStatus.Information = 0; // Added in build 2128

                // The following call will actually release the
                // cancel spin lock.

                CyyTryToCompleteCurrent(
                    Extension,
                    CyyGrabXoffFromIsr,
                    OldIrql,
                    STATUS_SERIAL_MORE_WRITES,
                    &Extension->CurrentXoffIrp,
                    NULL,
                    NULL,
                    &Extension->XoffCountTimer,
                    NULL,
                    NULL,
                    SERIAL_REF_XOFF_REF
                    );
            } else {
                // The irp is well on its way to being finished.
                // We can let the regular completion code do the
                // work.  Just release the spin lock.
                IoReleaseCancelSpinLock(OldIrql);
            }
        } else {
            IoReleaseCancelSpinLock(OldIrql);
        }

        UseATimer = FALSE;

        // Calculate the timeout value needed for the
        // request.  Note that the values stored in the
        // timeout record are in milliseconds.  Note that
        // if the timeout values are zero then we won't start
        // the timer.

        KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

        Timeouts = Extension->Timeouts;

        KeReleaseSpinLock(&Extension->ControlLock,OldIrql);

        if (Timeouts.WriteTotalTimeoutConstant ||
            Timeouts.WriteTotalTimeoutMultiplier) {

            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(
                                           Extension->CurrentWriteIrp
                                           );
            UseATimer = TRUE;

            // We have some timer values to calculate.
            // Take care, we might have an xoff counter masquerading
            // as a write.
            TotalTime.QuadPart =
                ((LONGLONG)((UInt32x32To64(
                                 (IrpSp->MajorFunction == IRP_MJ_WRITE)?
                                     (IrpSp->Parameters.Write.Length):
                                     (1),
                                 Timeouts.WriteTotalTimeoutMultiplier
                                 )
                                 + Timeouts.WriteTotalTimeoutConstant)))
                * -10000;
        }

        // The irp may be going to the isr shortly.  Now
        // is a good time to initialize its reference counts.

        SERIAL_INIT_REFERENCE(Extension->CurrentWriteIrp);

        // We need to see if this irp should be canceled.

        IoAcquireCancelSpinLock(&OldIrql);
        if (Extension->CurrentWriteIrp->Cancel) {
            IoReleaseCancelSpinLock(OldIrql);
            Extension->CurrentWriteIrp->IoStatus.Status = STATUS_CANCELLED;

            if (!SetFirstStatus) {
                FirstStatus = STATUS_CANCELLED;
                SetFirstStatus = TRUE;
            }
        } else {
            if (!SetFirstStatus) {
                // If we haven't set our first status, then
                // this is the only irp that could have possibly
                // not been on the queue.  (It could have been
                // on the queue if this routine is being invoked
                // from the completion routine.)  Since this
                // irp might never have been on the queue we
                // should mark it as pending.

                IoMarkIrpPending(Extension->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;
            }

            // We give the irp to to the isr to write out.
            // We set a cancel routine that knows how to
            // grab the current write away from the isr.
            //
            // Since the cancel routine has an implicit reference
            // to this irp up the reference count.

            IoSetCancelRoutine(
                Extension->CurrentWriteIrp,
                CyyCancelCurrentWrite
                );

            SERIAL_SET_REFERENCE(Extension->CurrentWriteIrp,SERIAL_REF_CANCEL);

            if (UseATimer) {
                CyySetTimer(
                    &Extension->WriteRequestTotalTimer,
                    TotalTime,
                    &Extension->TotalWriteTimeoutDpc,
                    Extension
                    );

                // This timer now has a reference to the irp.

                SERIAL_SET_REFERENCE(
                    Extension->CurrentWriteIrp,
                    SERIAL_REF_TOTAL_TIMER
                    );
            }

            KeSynchronizeExecution(
                Extension->Interrupt,
                CyyGiveWriteToIsr,
                Extension
                );

            IoReleaseCancelSpinLock(OldIrql);
            break;
        }

        // Well the write was canceled before we could start it up.
        // Try to get another.

        CyyGetNextWrite(&Extension->CurrentWriteIrp, &Extension->WriteQueue,
                        &NewIrp, TRUE, Extension);

    } while (NewIrp);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyStartWrite %X\n", FirstStatus);

    return FirstStatus;
}

VOID
CyyGetNextWrite(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    IN PCYY_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine completes the old write as well as getting
    a pointer to the next write.

    The reason that we have have pointers to the current write
    queue as well as the current write irp is so that this
    routine may be used in the common completion code for
    read and write.

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.

    QueueToProcess - Pointer to the write queue.

    NewIrp - A pointer to a pointer to the irp that will be the
             current irp.  Note that this could end up pointing
             to a null pointer.  This does NOT necessaryly mean
             that there is no current write.  What could occur
             is that while the cancel lock is held the write
             queue ended up being empty, but as soon as we release
             the cancel spin lock a new irp came in from
             CyyStartWrite.

    CompleteCurrent - Flag indicates whether the CurrentOpIrp should
                      be completed.

Return Value:

    None.

--*/

{
   CYY_LOCKED_PAGED_CODE();

   CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyGetNextWrite(XXX)\n");


    do {


        //
        // We could be completing a flush.
        //

        if (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction
            == IRP_MJ_WRITE) {

            KIRQL OldIrql;

            ASSERT(Extension->TotalCharsQueued >=
                   (IoGetCurrentIrpStackLocation(*CurrentOpIrp)
                    ->Parameters.Write.Length));

            IoAcquireCancelSpinLock(&OldIrql);
            Extension->TotalCharsQueued -=
                IoGetCurrentIrpStackLocation(*CurrentOpIrp)
                ->Parameters.Write.Length;
            IoReleaseCancelSpinLock(OldIrql);

        } else if (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction
                   == IRP_MJ_DEVICE_CONTROL) {

            KIRQL OldIrql;
            PIRP Irp;
            PSERIAL_XOFF_COUNTER Xc;

            IoAcquireCancelSpinLock(&OldIrql);

            Irp = *CurrentOpIrp;
            Xc = Irp->AssociatedIrp.SystemBuffer;

            //
            // We should never have a xoff counter when we
            // get to this point.
            //

            ASSERT(!Extension->CurrentXoffIrp);

            //
            // We absolutely shouldn't have a cancel routine
            // at this point.
            //

            ASSERT(!Irp->CancelRoutine);

            //
            // This could only be a xoff counter masquerading as
            // a write irp.
            //

            Extension->TotalCharsQueued--;

            //
            // Check to see of the xoff irp has been set with success.
            // This means that the write completed normally.  If that
            // is the case, and it hasn't been set to cancel in the
            // meanwhile, then go on and make it the CurrentXoffIrp.
            //

            if (Irp->IoStatus.Status != STATUS_SUCCESS) {

                //
                // Oh well, we can just finish it off.
                //
                NOTHING;

            } else if (Irp->Cancel) {

                Irp->IoStatus.Status = STATUS_CANCELLED;

            } else {

                //
                // Give it a new cancel routine, and increment the
                // reference count because the cancel routine has
                // a reference to it.
                //

                IoSetCancelRoutine(
                    Irp,
                    CyyCancelCurrentXoff
                    );

                SERIAL_SET_REFERENCE(
                    Irp,
                    SERIAL_REF_CANCEL
                    );

                //
                // We don't want to complete the current irp now.  This
                // will now get completed by the Xoff counter code.
                //

                CompleteCurrent = FALSE;

                //
                // Give the counter to the isr.
                //

                Extension->CurrentXoffIrp = Irp;
                KeSynchronizeExecution(
                    Extension->Interrupt,
                    CyyGiveXoffToIsr,
                    Extension
                    );

                //
                // Start the timer for the counter and increment
                // the reference count since the timer has a
                // reference to the irp.
                //

                if (Xc->Timeout) {

                    LARGE_INTEGER delta;

                    delta.QuadPart = -((LONGLONG)UInt32x32To64(
                                                     1000,
                                                     Xc->Timeout
                                                     ));

                    CyySetTimer(
                        &Extension->XoffCountTimer,
                        delta,
                        &Extension->XoffCountTimeoutDpc,
                        Extension
                        );

                    SERIAL_SET_REFERENCE(
                        Irp,
                        SERIAL_REF_TOTAL_TIMER
                        );

                }

            }

            IoReleaseCancelSpinLock(OldIrql);

        }

        //
        // Note that the following call will (probably) also cause
        // the current irp to be completed.
        //

        CyyGetNextIrp(
            CurrentOpIrp,
            QueueToProcess,
            NewIrp,
            CompleteCurrent,
            Extension
            );

        if (!*NewIrp) {

            KIRQL OldIrql;

            IoAcquireCancelSpinLock(&OldIrql);
            KeSynchronizeExecution(
                Extension->Interrupt,
                CyyProcessEmptyTransmit,
                Extension
                );
            IoReleaseCancelSpinLock(OldIrql);

            break;

        } else if (IoGetCurrentIrpStackLocation(*NewIrp)->MajorFunction
                   == IRP_MJ_FLUSH_BUFFERS) {

            //
            // If we encounter a flush request we just want to get
            // the next irp and complete the flush.
            //
            // Note that if NewIrp is non-null then it is also
            // equal to CurrentWriteIrp.
            //


            ASSERT((*NewIrp) == (*CurrentOpIrp));
            (*NewIrp)->IoStatus.Status = STATUS_SUCCESS;

        } else {

            break;

        }

    } while (TRUE);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyGetNextWrite\n");
}

VOID
CyyCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to complete any write.  It
    assumes that the status and the information fields of
    the irp are already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);
    
    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyCompleteWrite(%X)\n",
                     Extension);

    IoAcquireCancelSpinLock(&OldIrql);

    CyyTryToCompleteCurrent(Extension, NULL, OldIrql, STATUS_SUCCESS,
                            &Extension->CurrentWriteIrp,
                            &Extension->WriteQueue, NULL,
                            &Extension->WriteRequestTotalTimer,
                            CyyStartWrite, CyyGetNextWrite,
                            SERIAL_REF_ISR);

    CyyDpcEpilogue(Extension, Dpc);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyCompleteWrite\n");

}

BOOLEAN
CyyProcessEmptyTransmit(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to determine if conditions are appropriate
    to satisfy a wait for transmit empty event, and if so to complete
    the irp that is waiting for that event.  It also call the code
    that checks to see if we should lower the RTS line if we are
    doing transmit toggling.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = Context;
    CYY_LOCKED_PAGED_CODE();

    if (Extension->IsrWaitMask && (Extension->IsrWaitMask & SERIAL_EV_TXEMPTY) &&
        Extension->EmptiedTransmit && (!Extension->TransmitImmediate) &&
        (!Extension->CurrentWriteIrp) && IsListEmpty(&Extension->WriteQueue)) {

        Extension->HistoryMask |= SERIAL_EV_TXEMPTY;
        if (Extension->IrpMaskLocation) {

            *Extension->IrpMaskLocation = Extension->HistoryMask;
            Extension->IrpMaskLocation = NULL;
            Extension->HistoryMask = 0;

            Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
            CyyInsertQueueDpc(
                &Extension->CommWaitDpc,
                NULL,
                NULL,
                Extension
                );

        }

        Extension->CountOfTryingToLowerRTS++;
        CyyPerhapsLowerRTS(Extension);

    }

    return FALSE;

}

BOOLEAN
CyyGiveWriteToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    Try to start off the write by slipping it in behind
    a transmit immediate char, or if that isn't available
    and the transmit holding register is empty, "tickle"
    the UART into interrupting with a transmit buffer
    empty.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    CYY_LOCKED_PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp);

    //
    // We might have a xoff counter request masquerading as a
    // write.  The length of these requests will always be one
    // and we can get a pointer to the actual character from
    // the data supplied by the user.
    //

    if (IrpSp->MajorFunction == IRP_MJ_WRITE) {

        Extension->WriteLength = IrpSp->Parameters.Write.Length;
        Extension->WriteCurrentChar =
            Extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer;

    } else {

        Extension->WriteLength = 1;
        Extension->WriteCurrentChar =
            ((PUCHAR)Extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer) +
            FIELD_OFFSET(
                SERIAL_XOFF_COUNTER,
                XoffChar
                );

    }

    //
    // The isr now has a reference to the irp.
    //

    
    SERIAL_SET_REFERENCE(
        Extension->CurrentWriteIrp,
        SERIAL_REF_ISR
        );

    //
    // Check first to see if an immediate char is transmitting.
    // If it is then we'll just slip in behind it when its
    // done.
    //

    if (!Extension->TransmitImmediate) {

        //
        // If there is no immediate char transmitting then we
        // will "re-enable" the transmit holding register empty
        // interrupt.  The 8250 family of devices will always
        // signal a transmit holding register empty interrupt
        // *ANY* time this bit is set to one.  By doing things
        // this way we can simply use the normal interrupt code
        // to start off this write.
        //
        // We've been keeping track of whether the transmit holding
        // register is empty so it we only need to do this
        // if the register is empty.
        //

        if (Extension->HoldingEmpty) {
            // enable transmit intr
            CyyTxStart(Extension);
        }

    }

    //
    // The rts line may already be up from previous writes,
    // however, it won't take much additional time to turn
    // on the RTS line if we are doing transmit toggling.
    //

    if ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        CyySetRTS(Extension);

    }

    return FALSE;

}

VOID
CyyCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    CYY_LOCKED_PAGED_CODE();

    CyyTryToCompleteCurrent(
        Extension,
        CyyGrabWriteFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &Extension->CurrentWriteIrp,
        &Extension->WriteQueue,
        NULL,
        &Extension->WriteRequestTotalTimer,
        CyyStartWrite,
        CyyGetNextWrite,
        SERIAL_REF_CANCEL
        );

}

VOID
CyyWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine will try to timeout the current write.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyWriteTimeout(%X)\n",
                     Extension);

    IoAcquireCancelSpinLock(&OldIrql);

    CyyTryToCompleteCurrent(Extension, CyyGrabWriteFromIsr, OldIrql,
                            STATUS_TIMEOUT, &Extension->CurrentWriteIrp,
                            &Extension->WriteQueue, NULL,
                            &Extension->WriteRequestTotalTimer,
                            CyyStartWrite, CyyGetNextWrite,
                            SERIAL_REF_TOTAL_TIMER);

    CyyDpcEpilogue(Extension, Dpc);


    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyWriteTimeout\n");
}

BOOLEAN
CyyGrabWriteFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or canceling, from the ISR

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = Context;
    CYY_LOCKED_PAGED_CODE();

    //
    // Check if the write length is non-zero.  If it is non-zero
    // then the ISR still owns the irp. We calculate the the number
    // of characters written and update the information field of the
    // irp with the characters written.  We then clear the write length
    // the isr sees.
    //

    if (Extension->WriteLength) {

        //
        // We could have an xoff counter masquerading as a
        // write irp.  If so, don't update the write length.
        //

        if (IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp)
            ->MajorFunction == IRP_MJ_WRITE) {

            Extension->CurrentWriteIrp->IoStatus.Information =
                IoGetCurrentIrpStackLocation(
                    Extension->CurrentWriteIrp
                    )->Parameters.Write.Length -
                Extension->WriteLength;

        } else {

            Extension->CurrentWriteIrp->IoStatus.Information = 0;

        }

        //
        // Since the isr no longer references this irp, we can
        // decrement it's reference count.
        //

        SERIAL_CLEAR_REFERENCE(
            Extension->CurrentWriteIrp,
            SERIAL_REF_ISR
            );

        Extension->WriteLength = 0;

    }

    return FALSE;

}

BOOLEAN
CyyGrabXoffFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to grab an xoff counter irp from the
    isr when it is no longer masquerading as a write irp.  This
    routine is called by the cancel and timeout code for the
    xoff counter ioctl.


    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = Context;
    CYY_LOCKED_PAGED_CODE();

    if (Extension->CountSinceXoff) {

        //
        // This is only non-zero when there actually is a Xoff ioctl
        // counting down.
        //

        Extension->CountSinceXoff = 0;

        //
        // We decrement the count since the isr no longer owns
        // the irp.
        //

        SERIAL_CLEAR_REFERENCE(
            Extension->CurrentXoffIrp,
            SERIAL_REF_ISR
            );

    }

    return FALSE;

}

VOID
CyyCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp.  It
    assumes that the status and the information fields of the irp are
    already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyCompleteXoff(%X)\n",
                     Extension);

    IoAcquireCancelSpinLock(&OldIrql);

    CyyTryToCompleteCurrent(Extension, NULL, OldIrql, STATUS_SUCCESS,
                            &Extension->CurrentXoffIrp, NULL, NULL,
                            &Extension->XoffCountTimer, NULL, NULL,
                            SERIAL_REF_ISR);

    CyyDpcEpilogue(Extension, Dpc);


    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyCompleteXoff\n");

}

VOID
CyyTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp,
    if its timer has run out.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, ">CyyTimeoutXoff(%X)\n", Extension);

    IoAcquireCancelSpinLock(&OldIrql);

    CyyTryToCompleteCurrent(Extension, CyyGrabXoffFromIsr, OldIrql,
                            STATUS_SERIAL_COUNTER_TIMEOUT,
                            &Extension->CurrentXoffIrp, NULL, NULL, NULL,
                            NULL, NULL, SERIAL_REF_TOTAL_TIMER);

    CyyDpcEpilogue(Extension, Dpc);

    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, "<CyyTimeoutXoff\n");
}

VOID
CyyCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    CYY_LOCKED_PAGED_CODE();

    CyyTryToCompleteCurrent(
        Extension,
        CyyGrabXoffFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &Extension->CurrentXoffIrp,
        NULL,
        NULL,
        &Extension->XoffCountTimer,
        NULL,
        NULL,
        SERIAL_REF_CANCEL
        );

}

BOOLEAN
CyyGiveXoffToIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine starts off the xoff counter.  It merely
    has to set the xoff count and increment the reference
    count to denote that the isr has a reference to the irp.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PCYY_DEVICE_EXTENSION Extension = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //

    PSERIAL_XOFF_COUNTER Xc =
        Extension->CurrentXoffIrp->AssociatedIrp.SystemBuffer;

    CYY_LOCKED_PAGED_CODE();

    ASSERT(Extension->CurrentXoffIrp);
    Extension->CountSinceXoff = Xc->Counter;

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_SET_REFERENCE(
        Extension->CurrentXoffIrp,
        SERIAL_REF_ISR
        );

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\precomp.h ===
#include <stddef.h>
#include <stdarg.h>
#include "ntddk.h"
#include "ntddser.h"
#include <wmilib.h>
#include <wmidata.h>
#include "cyserial.h"
#include <stdio.h>
#include "cyyhw.h"
#include "cd1400.h"
#include "cyyport.h"
#include "cyyportp.h"
#include "cyylog.h"
#include "log.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyports\advandlg.h ===
#ifndef PP_H
#define PP_H

#define SERIAL_ADVANCED_SETTINGS
#include "msports.h"

#ifdef USE_P_TRACE_ERR
#define P_TRACE_ERR(_x) MessageBox( GetFocus(), TEXT(_x), TEXT("ports traceerr"), MB_OK | MB_ICONINFORMATION );
#define W_TRACE_ERR(_x) MessageBox( GetFocus(), _x, TEXT("ports traceerr"), MB_OK | MB_ICONINFORMATION );
#else
#define P_TRACE_ERR(_x)
#define W_TRACE_ERR(_x)
#endif

#define DO_COM_PORT_RENAMES

#define RX_MIN 1
#define RX_MAX 14
#define TX_MIN 1
#define TX_MAX 16

TCHAR m_szDevMgrHelp[];

#if defined(_X86_)
//
// For NEC PC98. Following definition comes from user\inc\kbd.h.
// The value must be the same as value in kbd.h.
//
#define NLSKBD_OEM_NEC   0x0D
#endif // FE_SB && _X86_

//
// Structures
//

typedef struct _ADVANCED_DATA
{
    BOOL   HidePolling;
    BOOL   UseFifoBuffersControl;
    BOOL   UseFifoBuffers;
    BOOL   UseRxFIFOControl;
    BOOL   UseTxFIFOControl;
    DWORD  FifoRxMax;
    DWORD  FifoTxMax;
    DWORD  RxFIFO;
    DWORD  TxFIFO;
    DWORD  PollingPeriod;

    TCHAR  szComName[20];
    TCHAR  szNewComName[20];

    HKEY             hDeviceKey;         // (like ROOT\LEGACY_BEEP\0000)
    HCOMDB           hComDB;

    HDEVINFO         DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;

} ADVANCED_DATA, *PADVANCED_DATA;


///////////////////////////////////////////////////////////////////////////////////
// Advanced Dialog Prototypes
///////////////////////////////////////////////////////////////////////////////////

ULONG
FillPortNameCb(
    HWND           ParentHwnd,
    PADVANCED_DATA Params
    );

INT_PTR APIENTRY
AdvancedPortsDlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

ULONG
FillAdvancedDlg(
    IN HWND             DialogHwnd,
    IN PADVANCED_DATA   AdvancedData
    );

BOOL
DisplayAdvancedDialog(
    IN     HWND             DialogHwnd,
    IN OUT PADVANCED_DATA   AdvancedData
);

void
InitializeControls(
    IN HWND             DialogHwnd,
    IN PADVANCED_DATA   AdvancedData
    );

void
RestoreAdvancedDefaultState(
    IN HWND             DialogHwnd,
    IN PADVANCED_DATA   AdvancedData
    );

ULONG
SaveAdvancedSettings(
    IN HWND             DialogHwnd,
    IN PADVANCED_DATA   AdvancedData
    );

void
SetTrackbarTicks(
    IN HWND   TrackbarHwnd,
    IN DWORD  MinVal,
    IN DWORD  MaxVal
    );

void
SetLabelText(
    IN HWND  LabelHwnd, 
    IN DWORD ResId,
    IN ULONG Value
    );

void
HandleTrackbarChange(
    IN HWND DialogHwnd, 
    IN HWND TrackbarHwnd
    );

void
EnableFifoControls(
    HWND DialogHwnd,
    BOOL Enabled
    );

// Context help header file and arrays for devmgr ports tab
// Created 2/21/98 by WGruber NTUA and DoronH NTDEV

//
// "Cyclom-Y Port Advanced Settings" Dialog Box
//

#define IDH_NOHELP      ((DWORD)-1)

#define IDH_DEVMGR_PORTSET_ADVANCED     15840   // "&Advanced" (Button)
#define IDH_DEVMGR_PORTSET_BPS      15841       // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_DATABITS     15842   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_PARITY       15843   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_STOPBITS     15844   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_FLOW     15845       // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_DEFAULTS     15892   // "&Restore Defaults" (Button)

//
// "Advanced Communications Port Properties" Dialog Box
//
#define IDH_DEVMGR_PORTSET_ADV_USEFIFO  16885   // "&Use FIFO buffers (requires 16550 compatible UART)" (Button)
#define IDH_DEVMGR_PORTSET_ADV_TRANS    16842   // "" (msctls_trackbar32)
#define IDH_DEVMGR_PORTSET_ADV_DEVICES  161027  // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_ADV_RECV         16821       // "" (msctls_trackbar32)
#define IDH_DEVMGR_PORTSET_ADV_NUMBER   16846   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_ADV_DEFAULTS 16844

#endif // PP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\log.h ===
/*++

Copyright (c) 1993  Microsoft Corporation
:ts=4

Module Name:

    log.h

Abstract:

    debug macros

Environment:

    Kernel & user mode

Revision History:

    10-27-95 : created

--*/

#ifndef   __LOG_H__
#define   __LOG_H__

//---------------------------
#define ZSIG_SET_DTR                   0x02000000  // STX
#define ZSIG_CLR_DTR                   0x03000000  // ETX
//---------------------------

#define LOG_MISC          0x00000001        //debug log entries
#define LOG_CNT           0x00000002

//
// Assert Macros
//

#if DBG

ULONG
CyyDbgPrintEx(IN ULONG Level, PCHAR Format, ...);

#define LOGENTRY(mask, sig, info1, info2, info3)     \
    SerialDebugLogEntry(mask, sig, (ULONG_PTR)info1, \
                        (ULONG_PTR)info2,            \
                        (ULONG_PTR)info3)

VOID
SerialDebugLogEntry(IN ULONG Mask, IN ULONG Sig, IN ULONG_PTR Info1,
                    IN ULONG_PTR Info2, IN ULONG_PTR Info3);

VOID
SerialLogInit();

VOID
SerialLogFree();

#else
#define LOGENTRY(mask, sig, info1, info2, info3)
__inline ULONG CyyDbgPrintEx(IN ULONG Level, PCHAR Format, ...) { return 0; }
#endif


#endif // __LOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyports\cyyports.h ===
/** FILE: cyyports.h ********* Module Header ********************************
 *
 *  Control Panel System applet common definitions, resource ids, typedefs,
 *  external declarations and library routine function prototypes.
 *
 * History:
 *
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/
//==========================================================================
//                            Include Files
//==========================================================================

#ifndef PORTS_H
#define PORTS_H

#include <windows.h>
#include <tchar.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <regstr.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include "resource.h"

#include "portstr.h"

#define PORTS        4
#define MAXPORTS    32
#define KEYBZ       4096
#define BUFFER_SIZE 81

#define DEF_BAUD    3       //  1200
#define DEF_WORD    4       //  8 bits
#define DEF_PARITY  2       //  None
#define DEF_STOP    0       //  1
#define DEF_PORT    0       //  Null Port
#define DEF_SHAKE   2       //  None
#define PAR_EVEN    0
#define PAR_ODD     1
#define PAR_NONE    2
#define PAR_MARK    3
#define PAR_SPACE   4
#define STOP_1      0
#define STOP_15     1
#define STOP_2      2
#define FLOW_XON    0
#define FLOW_HARD   1
#define FLOW_NONE   2

//#define MAX_COM_PORT  COMDB_MIN_PORTS_ARBITRATED   // Maximum number of COM ports NT supports
#define MAX_COM_PORT  2048                         // We should support at least 1024 ports.
#define MIN_COM       1                            // Minimum new COM port number

#define POLL_PERIOD_DEFAULT_IDX 1 

//==========================================================================
//                        Definitions
//==========================================================================

//
//  General definitions
//

#define PATHMAX             MAX_PATH


//
//  Help IDs -- for the Ports applet
//
//
#define IDH_HELPFIRST        5000
#define IDH_SYSMENU     (IDH_HELPFIRST + 2000)
#define IDH_MBFIRST     (IDH_HELPFIRST + 2001)
#define IDH_MBLAST      (IDH_HELPFIRST + 2099)
#define IDH_DLGFIRST    (IDH_HELPFIRST + 3000)

#define IDH_MENU_SCHHELP    (IDH_HELPFIRST + MENU_SCHHELP)
#define IDH_MENU_INDHELP    (IDH_HELPFIRST + MENU_INDHELP)
#define IDH_MENU_USEHELP    (IDH_HELPFIRST + MENU_USEHELP)
#define IDH_MENU_ABOUT      (IDH_HELPFIRST + MENU_ABOUT )
#define IDH_MENU_EXIT       (IDH_HELPFIRST + MENU_EXIT)
#define IDH_CHILD_PORTS     (IDH_HELPFIRST + 4 /* CHILD_PORTS */ )
#define IDH_DLG_PORTS2      (IDH_DLGFIRST + DLG_PORTS2)
#define IDH_DLG_PORTS3      (IDH_DLGFIRST + DLG_PORTS3)

//==========================================================================
//                           Typedefs
//==========================================================================
typedef struct {
    SP_DEVINFO_DATA  DeviceInfoData;

    TCHAR ComName[20];
    TCHAR Settings[20];
    
    ULONG BaseAddress;
} PORT_INFO, *PPORT_INFO;

typedef struct _PORTS_WIZARD_DATA {

    HDEVINFO          DeviceInfoSet;
    PSP_DEVINFO_DATA  pDeviceInfoData;

    ULONG BaseAddress;
    ULONG FirstComNumber;

    ULONG PortsCount;
    PPORT_INFO Ports;

    PUINT UsedComNumbers;
    UINT UsedComNumbersCount;

    BOOL IsMulti;
} PORTS_WIZARD_DATA, *PPORTS_WIZARD_DATA;


//==========================================================================
//                              Macros
//==========================================================================

#define CharSizeOf(x)   (sizeof(x) / sizeof(*x))
#define ByteCountOf(x)  ((x) * sizeof(TCHAR))

#if DBG
#define DbgOut(Text) OutputDebugString(Text)
#else
#define DbgOut(Text) 
#endif 

//==========================================================================
//                         External Declarations
//==========================================================================
//
//  DATA


//
//  exported from cpl.c
//

extern HANDLE g_hInst;
extern TCHAR  g_szErrMem[ ];        //  Low memory message
extern TCHAR  g_szPortsApplet[ ];   //  "Ports Control Panel Applet" title
extern TCHAR  g_szNull[];           //  Null string

extern DWORD PollingPeriods[];

extern TCHAR  m_szPorts[];
extern TCHAR  m_szPortName[];

//==========================================================================
//                            Function Prototypes
//==========================================================================

//
//  LibMain module
//

extern 
VOID
InitStrings(void);


//
//  cyfriend.c
//

extern
BOOL
ReplaceFriendlyName(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PTCHAR           NewComName
);


//
//  util.c
//

extern 
LPTSTR 
BackslashTerm(LPTSTR pszPath);

extern 
VOID 
ErrMemDlg(HWND hParent);

extern 
int    
MyAtoi(LPTSTR  string);

extern 
int    
myatoi(LPTSTR pszInt);

extern 
int    
MyMessageBox(HWND hWnd, 
                         DWORD wText, 
                         DWORD wCaption, 
                         DWORD wType, 
                         ...);

extern
int
MyMessageBoxWithErr(
    HWND hWnd, 
	DWORD wText, 
	DWORD wCaption, 
	DWORD wType,
    DWORD wError
    );

extern 
LPTSTR 
MyItoa(INT value, 
           LPTSTR  string, 
           INT  radix);

extern 
LPTSTR 
MyUltoa(unsigned long  value, 
                LPTSTR  string, 
                INT  radix);

extern 
VOID   
SendWinIniChange(LPTSTR szSection);

extern 
LPTSTR 
strscan(LPTSTR pszString, 
                LPTSTR pszTarget);

extern 
VOID
StripBlanks(LPTSTR pszString);


#endif // PORTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyport\log.c ===
/*++

Copyright (c) 1995,1996 Microsoft Corporation
:ts=4

Module Name:

    log.c

Abstract:

    Debug log Code for serial.

Environment:

    kernel mode only

Notes:

Revision History:

    10-08-95 : created

--*/

#include "precomp.h"
#include <stdio.h>

#if DBG
extern ULONG CyyDebugLevel;

KSPIN_LOCK LogSpinLock;

struct SERIAL_LOG_ENTRY {
    ULONG        le_sig;          // Identifying string
    ULONG_PTR    le_info1;        // entry specific info
    ULONG_PTR    le_info2;        // entry specific info
    ULONG_PTR    le_info3;        // entry specific info
}; // SERIAL_LOG_ENTRY


struct SERIAL_LOG_ENTRY *SerialLStart = 0;    // No log yet
struct SERIAL_LOG_ENTRY *SerialLPtr;
struct SERIAL_LOG_ENTRY *SerialLEnd;

// LogMask changed to LOG_MISC for debug
ULONG LogMask = 0x0;
//ULONG LogMask = LOG_MISC;

VOID
SerialDebugLogEntry(IN ULONG Mask, IN ULONG Sig, IN ULONG_PTR Info1,
                      IN ULONG_PTR Info2, IN ULONG_PTR Info3)
/*++

Routine Description:

    Adds an Entry to serial log.

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;

typedef union _SIG {
    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    } b;
    ULONG l;
} SIG, *PSIG;

    SIG sig, rsig;


    if (SerialLStart == 0) {
        return;
    }

    if ((Mask & LogMask) == 0) {
        return;
    }

    irql = KeGetCurrentIrql();

    if (irql < DISPATCH_LEVEL) {
        KeAcquireSpinLock(&LogSpinLock, &irql);
    } else {
        KeAcquireSpinLockAtDpcLevel(&LogSpinLock);
    }

    if (SerialLPtr > SerialLStart) {
        SerialLPtr -= 1;    // Decrement to next entry
    } else {
        SerialLPtr = SerialLEnd;
    }

    sig.l = Sig;
    rsig.b.Byte0 = sig.b.Byte3;
    rsig.b.Byte1 = sig.b.Byte2;
    rsig.b.Byte2 = sig.b.Byte1;
    rsig.b.Byte3 = sig.b.Byte0;

    SerialLPtr->le_sig = rsig.l;
    SerialLPtr->le_info1 = Info1;
    SerialLPtr->le_info2 = Info2;
    SerialLPtr->le_info3 = Info3;

    ASSERT(SerialLPtr >= SerialLStart);

    if (irql < DISPATCH_LEVEL) {
        KeReleaseSpinLock(&LogSpinLock, irql);
    } else {
        KeReleaseSpinLockFromDpcLevel(&LogSpinLock);
    }

    return;
}


VOID
SerialLogInit()
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:

Return Value:

    None.

--*/
{
#ifdef MAX_DEBUG
    ULONG logSize = 4096*6;
#else
    ULONG logSize = 4096*3;
#endif


    KeInitializeSpinLock(&LogSpinLock);

    SerialLStart = ExAllocatePoolWithTag(NonPagedPool, logSize, 'PyyC');

    if (SerialLStart) {
        SerialLPtr = SerialLStart;

        // Point the end (and first entry) 1 entry from the end of the segment
        SerialLEnd = SerialLStart + (logSize / sizeof(struct SERIAL_LOG_ENTRY))
            - 1;
    } else {
#if DBG
        DbgBreakPoint ();
#endif
    }

    return;
}

VOID
SerialLogFree(
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    if (SerialLStart) {
        ExFreePool(SerialLStart);
    }

    return;
}

#define SERIAL_DBGPRINT_BUFSIZE 512

ULONG
CyyDbgPrintEx(IN ULONG Level, PCHAR Format, ...)
{
   va_list arglist;
   ULONG rval;
   ULONG Mask;
   ULONG cb;
   UCHAR buffer[SERIAL_DBGPRINT_BUFSIZE];

   if (Level > 31) {
        Mask = Level;

   } else {
      Mask = 1 << Level;
   }

   if ((Mask & CyyDebugLevel) == 0) {
      return STATUS_SUCCESS;
   }

   va_start(arglist, Format);

   DbgPrint("Cyyport: ");

   cb = _vsnprintf(buffer, sizeof(buffer), Format, arglist);

   if (cb == -1) {
      buffer[sizeof(buffer) - 2] = '\n';
   }

   DbgPrint("%s", buffer);

//   rval = vDbgPrintEx(DPFLTR_SERIAL_ID, Level, Format, arglist);

   va_end(arglist);

   rval = STATUS_SUCCESS;

   return rval;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyports\advandlg.c ===
///////////////////////////////////////////////////////////////////////////
// Advanced Dialog Functions
///////////////////////////////////////////////////////////////////////////

#include "cyyports.h"
#include "advandlg.h"

#include <windowsx.h>

TCHAR m_szDevMgrHelp[] = _T("devmgr.hlp");

const DWORD HelpIDs[]=
{
    IDC_STATIC,         IDH_NOHELP,
    IDC_ADVANCED,       IDH_DEVMGR_PORTSET_ADVANCED, // "&Advanced" (Button)
    PP_PORT_BAUDRATE,   IDH_DEVMGR_PORTSET_BPS,      // "" (ComboBox)
    PP_PORT_DATABITS,   IDH_DEVMGR_PORTSET_DATABITS, // "" (ComboBox)
    PP_PORT_PARITY,     IDH_DEVMGR_PORTSET_PARITY,   // "" (ComboBox)
    PP_PORT_STOPBITS,   IDH_DEVMGR_PORTSET_STOPBITS, // "" (ComboBox)
    PP_PORT_FLOWCTL,    IDH_DEVMGR_PORTSET_FLOW,     // "" (ComboBox)
    IDC_RESTORE_PORT,   IDH_DEVMGR_PORTSET_DEFAULTS, // "&Restore Defaults" (Button)
    0, 0
};

//
// write out values in tenths of a sec
//
#define SECONDS_CONVERSION_FACTOR  (10)
#define NUM_POLLING_PERIODS 7

DWORD PollingPeriods[NUM_POLLING_PERIODS] = {
           -1,
            0,
            1 * SECONDS_CONVERSION_FACTOR,
            5 * SECONDS_CONVERSION_FACTOR,
            10 * SECONDS_CONVERSION_FACTOR,
            30 * SECONDS_CONVERSION_FACTOR,
            60 * SECONDS_CONVERSION_FACTOR
            };

TCHAR PeriodDescription[NUM_POLLING_PERIODS+1][40] = {
    { _T("Disabled") },
    { _T("Manually") },
    { _T("Every second") },
    { _T("Every 5 seconds") },
    { _T("Every 10 seconds") },
    { _T("Every 30 seconds") },
    { _T("Every minute") },
    { _T("Other (every %d sec)") }
    };

ULONG RxValues[4] = { 1, 4, 8, 14};

TCHAR m_szRxFIFO[] =        _T("RxFIFO");
TCHAR m_szTxFIFO[] =        _T("TxFIFO");
TCHAR m_szFifoRxMax[] =     _T("FifoRxMax");
TCHAR m_szFifoTxMax[] =     _T("FifoTxMax");

const DWORD AdvanHelpIDs[] =
{
    IDC_DESC_1,             IDH_NOHELP,
    IDC_DESC_2,             IDH_NOHELP,

    IDC_FIFO,               IDH_DEVMGR_PORTSET_ADV_USEFIFO, // "Use FIFO buffers (requires 16550 compatible UART)" (Button)

    IDC_RECEIVE_TEXT,       IDH_NOHELP,                     // "&Receive Buffer:" (Static)
    IDC_RECEIVE_SLIDER,     IDH_DEVMGR_PORTSET_ADV_RECV,    // "" (msctls_trackbar32)
    IDC_RECEIVE_LOW,        IDH_NOHELP,                     // "Low (%d)" (Static)
    IDC_RECEIVE_HIGH,       IDH_NOHELP,                     // "High (%d)" (Static)
    IDC_RXVALUE,            IDH_NOHELP,

    IDC_TRANSMIT_TEXT,      IDH_NOHELP,                     // "&Transmit Buffer:" (Static)
    IDC_TRANSMIT_SLIDER,    IDH_DEVMGR_PORTSET_ADV_TRANS,   // "" (msctls_trackbar32)
    IDC_TRANSMIT_LOW,       IDH_NOHELP,                     // "Low (%d)" (Static)
    IDC_TRANSMIT_HIGH,      IDH_NOHELP,                     // "High (%d)" (Static)
    IDC_TXVALUE,            IDH_NOHELP,

    IDC_POLL_DESC,          IDH_NOHELP,
    IDC_POLL_PERIOD,        IDH_DEVMGR_PORTSET_ADV_DEVICES, // "" (ComboBox)

    PP_PORT_NUMBER,         IDH_DEVMGR_PORTSET_ADV_NUMBER,  // "" (ComboBox)
    IDC_COMNUMTEXT,         IDH_NOHELP,                     // "COM &Port Number:" (Static)

    IDC_RESTORE,            IDH_DEVMGR_PORTSET_ADV_DEFAULTS,// "&Restore Defaults" (Button)
    0, 0
};

#define Trackbar_SetPos(hwndTb, Redraw, Position)\
    (VOID) SendMessage(hwndTb, TBM_SETPOS, (WPARAM) Redraw, (LPARAM) Position)

#define Trackbar_SetRange(hwndTb, Redraw, MinVal, MaxVal)\
    (VOID) SendMessage(hwndTb, TBM_SETRANGE, (WPARAM) Redraw, (LPARAM) MAKELONG(MinVal, MaxVal))

#define Trackbar_SetTic(hwndTb, Tic)\
    (VOID) SendMessage(hwndTb, TBM_SETTIC, (WPARAM) 0, (LPARAM) Tic)

#define Trackbar_GetPos(hwndTb)\
    (DWORD) SendMessage(hwndTb, TBM_GETPOS, (WPARAM) 0, (LPARAM) 0)



BOOL
Advanced_OnCommand(
    HWND ParentHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    );


BOOL
Advanced_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    );

void
Advanced_OnHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    );

BOOL
Advanced_OnInitDialog(
    HWND    ParentHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    );

/*++

Routine Description: AdvancedPortsDlgProc

    The windows proc for the Advanced properties window

Arguments:

    hDlg, uMessage, wParam, lParam: standard windows DlgProc parameters

Return Value:

    BOOL: FALSE if the page could not be created

--*/
INT_PTR APIENTRY
AdvancedPortsDlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch(uMessage) {
    case WM_COMMAND:
        return Advanced_OnCommand(hDlg,
                                  (int) LOWORD(wParam),
                                  (HWND)lParam,
                                  (UINT) HIWORD(wParam));

    case WM_CONTEXTMENU:
        return Advanced_OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        Advanced_OnHelp(hDlg, (LPHELPINFO) lParam);
        break;

    case WM_HSCROLL:
        HandleTrackbarChange(hDlg, (HWND) lParam);
        return TRUE;

    case WM_INITDIALOG:
        return Advanced_OnInitDialog(hDlg, (HWND) wParam, lParam);
    }

    return FALSE;
} /* AdvancedPortsDlgProc */

BOOL
Advanced_OnCommand(
    HWND ParentHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    )
{
    PADVANCED_DATA advancedData =
        (PADVANCED_DATA) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    switch(ControlId) {

    case IDC_FIFO:
        //
        // Disable or enable the sliders
        //
        EnableFifoControls(ParentHwnd, IsDlgButtonChecked(ParentHwnd, IDC_FIFO));
        return TRUE;

    case IDOK:
        SaveAdvancedSettings(ParentHwnd, advancedData);
        // fall through

    case IDCANCEL:
        EndDialog(ParentHwnd, ControlId);
        return TRUE;

    case IDC_RESTORE:
        RestoreAdvancedDefaultState(ParentHwnd, advancedData);
        return TRUE;
    }

    return FALSE;
}

BOOL
Advanced_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    WinHelp(HwndControl,
            m_szDevMgrHelp,
            HELP_CONTEXTMENU,
            (ULONG_PTR) AdvanHelpIDs);

    return FALSE;
}

void
Advanced_OnHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                 m_szDevMgrHelp,
                 HELP_WM_HELP,
                 (ULONG_PTR) AdvanHelpIDs);
    }
}

BOOL
Advanced_OnInitDialog(
    HWND    ParentHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    )
{
    PADVANCED_DATA advancedData;
    TCHAR          szFormat[200];
    TCHAR          szBuffer[200];
    advancedData = (PADVANCED_DATA) Lparam;

    //
    // Initialize the dialog box parameters
    //
    FillAdvancedDlg(ParentHwnd, advancedData);
    SetWindowLongPtr(ParentHwnd, DWLP_USER, (ULONG_PTR) advancedData);

    //
    // Set up the dialog box with these initialized parameters
    //
    InitializeControls(ParentHwnd, advancedData);

    LoadString(g_hInst, IDS_ADVANCED_SETTINGS_FOR, szFormat, CharSizeOf(szFormat));
    wsprintf(szBuffer, szFormat, advancedData->szComName);
    SetWindowText(ParentHwnd, szBuffer);

    return TRUE;
}


BOOL InternalAdvancedDialog(
    IN     HWND           ParentHwnd,
    IN OUT PADVANCED_DATA AdvancedData
    )
{
    AdvancedData->hComDB = HCOMDB_INVALID_HANDLE_VALUE;
    ComDBOpen(&AdvancedData->hComDB);

    DialogBoxParam(g_hInst,
                   MAKEINTRESOURCE(DLG_PP_ADVPORTS),
                   ParentHwnd,
                   AdvancedPortsDlgProc,
                   (DWORD_PTR) AdvancedData);

    ComDBClose(AdvancedData->hComDB);
    AdvancedData->hComDB = HCOMDB_INVALID_HANDLE_VALUE;

    return TRUE;
}


/*++

Routine Description: DisplayAdvancedDialog

    Opens the devices instance and checks to see if it is valid.  If so, then the advanced
    dialog is displayed.  Otherwise a message is displayed to the user stating that the user
    does not have write access to this particular key.

Arguments:

    ParentHwnd - Handle to the parent dialog (Port Settings Property Sheet)
    AdvancedData - hDeviceKey will be set with the device's key in the registry upon success,
                    INVALID_HANDLE_VALUE upon error

Return Value:

    None

--*/
BOOL DisplayAdvancedDialog(
    IN      HWND           ParentHwnd,
    IN OUT  PADVANCED_DATA AdvancedData
    )
{
    AdvancedData->hDeviceKey =
        SetupDiOpenDevRegKey(AdvancedData->DeviceInfoSet,
                             AdvancedData->DeviceInfoData,
                             DICS_FLAG_GLOBAL,
                             0,
                             DIREG_DEV,
                             KEY_ALL_ACCESS);

    if (AdvancedData->hDeviceKey == INVALID_HANDLE_VALUE) {
        MyMessageBox(ParentHwnd,
                     IDS_NO_WRITE_PRVILEGE,
                     IDS_NAME_PROPERTIES,
                     MB_OK | MB_ICONINFORMATION);
        return FALSE;
    }
    else {
            return InternalAdvancedDialog(ParentHwnd, AdvancedData);
    }
}

/*++

Routine Description: EnableFifoControls

    Enables/Disables all of the controls bounded by the rectangle with the Use Fifo
    checkbox.

Arguments:

    hDlg - Handle to the dialog
    enabled - flag to either enable/disable the controls

Return Value:

    None

--*/
void EnableFifoControls(IN HWND hDlg,
                        IN BOOL enabled)
{
   // The actual trackbar/slider
   EnableWindow(GetDlgItem(hDlg, IDC_RECEIVE_SLIDER), enabled);

   // "Low (xxx)" (Receive)
   EnableWindow(GetDlgItem(hDlg, IDC_RECEIVE_LOW), enabled);

   // "High (xxx)" (Receive)
   EnableWindow(GetDlgItem(hDlg, IDC_RECEIVE_HIGH), enabled);

   // "Receive Buffer:  "
   EnableWindow(GetDlgItem(hDlg, IDC_RECEIVE_TEXT), enabled);

   // "(xxx)" (Actual value of trackbar, Receive)
   EnableWindow(GetDlgItem(hDlg, IDC_RXVALUE), enabled);

   // The actual trackbar/slider
   EnableWindow(GetDlgItem(hDlg, IDC_TRANSMIT_SLIDER), enabled);

   // "Low (xxx)" (Transmit)
   EnableWindow(GetDlgItem(hDlg, IDC_TRANSMIT_LOW), enabled);

   // "High (xxx)" (Transmit)
   EnableWindow(GetDlgItem(hDlg, IDC_TRANSMIT_HIGH), enabled);

   // "Transmit Buffer" (Transmit)
   EnableWindow(GetDlgItem(hDlg, IDC_TRANSMIT_TEXT), enabled);

   // "(xxx)" (Actual value of trackbar, Trasmist)
   EnableWindow(GetDlgItem(hDlg, IDC_TXVALUE), enabled);
}

/*++

Routine Description: HandleTrackbarChange

    Whenever the user changes the trackbar thumb position, update the control
    to its right which displays its actual numeric value

Arguments:

    hDlg - Handle to the parent dialog
    hTrackbar - Handle to the trackbar whose thumb has changed

Return Value:

    None

--*/
void HandleTrackbarChange(IN HWND hDlg,
                          IN HWND hTrackbar
                          )
{
    DWORD ctrlID;
    TCHAR szCurrentValue[10];
    ULONG position;

    position = Trackbar_GetPos(hTrackbar);

    if (GetDlgCtrlID(hTrackbar) == IDC_RECEIVE_SLIDER) {
        //
        // Rx we need to translate the tick position from index to value
        //
        wsprintf(szCurrentValue, TEXT("(%d)"), RxValues[position-1]);
        ctrlID = IDC_RXVALUE;
    }
    else {
        //
        // Tx is just a straight translation between value and index
        //
        wsprintf(szCurrentValue, TEXT("(%d)"), position);
        ctrlID = IDC_TXVALUE;
    }
    SetDlgItemText(hDlg, ctrlID, szCurrentValue);
}

DWORD
RxValueToTrackbarPosition(IN OUT PDWORD RxValue
               )
{
    switch (*RxValue) {
    case 1:  return 1;
    case 4:  return 2;
    case 8:  return 3;
    case 14: return 4;
    }

    //
    // busted value
    //
    *RxValue = 14;
    return 4;
}

/*++

Routine Description:   SetTxTrackbarTicks

    Creates a tick at 1/4, half, and 3/4 across the span of the trackbar

Arguments:

    hTrackbar - handle to the trackbar that will receive the ticks
    minVal, maxVal - Range on the trackbar

Return Value:

    None

--*/
void
SetTxTrackbarTics(
    IN HWND   TrackbarHwnd
    )
{
    Trackbar_SetTic(TrackbarHwnd, 6);
    Trackbar_SetTic(TrackbarHwnd, 11);
}

/*++

Routine Description:  SetLabelText

    Sets the label's to the string identified by resID concated with the passed
    in value and closing paren.

    The final string is  [resID string][value])

Arguments:

    hLabel - handle to the control whose text is going to change
    resID  - resource ID for the beginning of the string that will become the
              label's text
    value  - number to be concated into the string


Return Value:

    None

--*/
void
SetLabelText(
    IN HWND     LabelHwnd,
    IN DWORD    ResId,
    IN ULONG    Value
    )
{
    TCHAR szTemp[258], txt[258];

    if (LoadString(g_hInst, ResId, szTemp, CharSizeOf(szTemp))) {
        lstrcpy(txt, szTemp);
        wsprintf(szTemp, _T("%d)"), Value);
        lstrcat(txt, szTemp);
    }
    else {
        lstrcpy(txt, _T("Low"));
    }
    SetWindowText(LabelHwnd, txt);
}

/*++

Routine Description: InitializeControls

    Initializes all of the controls that represent Fifo

Arguments:

    ParentHwnd - handle to the dialog
    AdvancedData - Contains all of the initial values

Return Value:

    None

--*/
void InitializeControls(
    IN HWND           ParentHwnd,
    IN PADVANCED_DATA AdvancedData
    )
{
    TCHAR    szCurrentValue[40];
    HWND     hwnd;
    int      i, periodIdx;

    //---------------------------------------------------------
    // ATTENTION: (Fanny)
    // For now disable FIFO buffers selections. This feature
    // will be enabled when we add support to this in the driver.
    #define CD1400_RXFIFO_MIN 1
    #define CD1400_RXFIFO_MAX 12
    #define CD1400_TXFIFO_MIN 1
    #define CD1400_TXFIFO_MAX 12
    SetLabelText(GetDlgItem(ParentHwnd, IDC_RECEIVE_LOW),IDS_LOW,
                    CD1400_RXFIFO_MIN);
    SetLabelText(GetDlgItem(ParentHwnd, IDC_RECEIVE_HIGH),IDS_HIGH,
                    CD1400_RXFIFO_MAX);
    SetLabelText(GetDlgItem(ParentHwnd, IDC_TRANSMIT_LOW),IDS_LOW,
                    CD1400_TXFIFO_MIN);
    SetLabelText(GetDlgItem(ParentHwnd, IDC_TRANSMIT_HIGH),IDS_HIGH,
                    CD1400_TXFIFO_MAX);
    AdvancedData->UseFifoBuffersControl = FALSE;
    AdvancedData->UseRxFIFOControl = FALSE;
    AdvancedData->UseTxFIFOControl = FALSE;
    EnableWindow(GetDlgItem(ParentHwnd, IDC_DESC_1), FALSE);
    EnableWindow(GetDlgItem(ParentHwnd, IDC_DESC_2), FALSE);
    // END ATTENTION
    //---------------------------------------------------------

    //
    // Set up the Fifo buffers checkbox
    //
    if (!AdvancedData->UseFifoBuffersControl) {
        //
        // Something went wrong with the Fifo buffers control. Disable
        // the checkbox
        //
        CheckDlgButton(ParentHwnd, IDC_FIFO, BST_UNCHECKED);
        EnableWindow(GetDlgItem(ParentHwnd, IDC_FIFO), FALSE);
        EnableFifoControls(ParentHwnd, FALSE);
    }
    else {
        EnableWindow(GetDlgItem(ParentHwnd, IDC_FIFO), TRUE);

        if (!AdvancedData->UseFifoBuffers) {
            EnableFifoControls(ParentHwnd, FALSE);
            CheckDlgButton(ParentHwnd, IDC_FIFO, BST_UNCHECKED);
        }
        else {
            EnableFifoControls(ParentHwnd, TRUE);
            CheckDlgButton(ParentHwnd, IDC_FIFO, BST_CHECKED);
        }
    }

    //
    // Set up the sliders
    //
    if (!AdvancedData->UseRxFIFOControl ||
        !AdvancedData->UseTxFIFOControl) {
        //
        // Something went wrong with the sliders.
        // Disable them
        //
        CheckDlgButton(ParentHwnd, IDC_FIFO, BST_UNCHECKED);
        EnableWindow(GetDlgItem(ParentHwnd, IDC_FIFO), FALSE);
        EnableFifoControls(ParentHwnd, FALSE);
    }
    else {
        //
        // Set up Rx Slider
        //
        hwnd = GetDlgItem(ParentHwnd, IDC_RECEIVE_SLIDER);

        Trackbar_SetRange(hwnd, TRUE, RX_MIN, 4);
        Trackbar_SetPos(hwnd,
                        TRUE,
                        RxValueToTrackbarPosition(&AdvancedData->RxFIFO));

        SetLabelText(GetDlgItem(ParentHwnd, IDC_RECEIVE_LOW),
                     IDS_LOW,
                     RX_MIN);
        SetLabelText(GetDlgItem(ParentHwnd, IDC_RECEIVE_HIGH),
                     IDS_HIGH,
                     AdvancedData->FifoRxMax);

        wsprintf(szCurrentValue, TEXT("(%d)"), AdvancedData->RxFIFO);
        SetDlgItemText(ParentHwnd, IDC_RXVALUE, szCurrentValue);

        //
        // Set up the Tx slider
        //
        hwnd = GetDlgItem(ParentHwnd, IDC_TRANSMIT_SLIDER);
        Trackbar_SetRange(hwnd, TRUE, TX_MIN, AdvancedData->FifoTxMax);
        Trackbar_SetPos(hwnd, TRUE, AdvancedData->TxFIFO);

        SetTxTrackbarTics(hwnd);

        SetLabelText(GetDlgItem(ParentHwnd, IDC_TRANSMIT_LOW),
                     IDS_LOW,
                     TX_MIN);
        SetLabelText(GetDlgItem(ParentHwnd, IDC_TRANSMIT_HIGH),
                     IDS_HIGH,
                     AdvancedData->FifoTxMax);

        wsprintf(szCurrentValue, TEXT("(%d)"), AdvancedData->TxFIFO);
        SetDlgItemText(ParentHwnd, IDC_TXVALUE, szCurrentValue);
    }

    FillPortNameCb(ParentHwnd, AdvancedData);

    if (!AdvancedData->HidePolling) {

        //
        // Add the descriptions for each polling period and select the current
        // setting
        //
        hwnd = GetDlgItem(ParentHwnd, IDC_POLL_PERIOD);
        periodIdx = NUM_POLLING_PERIODS;
        for (i = 0; i < NUM_POLLING_PERIODS; i++) {
            ComboBox_AddString(hwnd, PeriodDescription[i]);
            if (PollingPeriods[i] == AdvancedData->PollingPeriod) {
                periodIdx = i;
            }
        }

        if (periodIdx == NUM_POLLING_PERIODS) {
            wsprintf(szCurrentValue,
                     PeriodDescription[NUM_POLLING_PERIODS],
                     AdvancedData->PollingPeriod / SECONDS_CONVERSION_FACTOR);
            ComboBox_AddString(hwnd, szCurrentValue);
        }

        ComboBox_SetCurSel(hwnd, periodIdx);
    }
    else {
       ShowWindow(GetDlgItem(ParentHwnd, IDC_POLL_PERIOD), SW_HIDE);
       ShowWindow(GetDlgItem(ParentHwnd, IDC_POLL_DESC), SW_HIDE);
    }
} /* InitializeControls */


/*++

Routine Description:  RestoreAdvancedDefaultState

    Restores all values and UI to their default state, specifically:
    o All Fifo related child controls are enabled
    o The Rx trackbar is set to its max value
    o The Tx trackbar is set to its max value
    o The number of the comport is reset to its original value

Return Value:

    None

--*/
void RestoreAdvancedDefaultState(
    IN HWND           ParentHwnd,
    IN PADVANCED_DATA AdvancedData
    )
{
    USHORT ushIndex;
    TCHAR  szCurrentValue[10];
    int    i;

//-------------------------------------------------------------------------
// ATTENTION: For now, don't show anything related to FIFO buffers (Fanny)
#if 0
//-------------------------------------------------------------------------

    //
    // Set up the Fifo buffers checkbox
    //
    EnableWindow(GetDlgItem(ParentHwnd, IDC_FIFO), TRUE);

    EnableFifoControls(ParentHwnd, TRUE);
    CheckDlgButton(ParentHwnd, IDC_FIFO, BST_CHECKED);

    //
    // Set up the sliders and the static control that show their numberic value
    //
    Trackbar_SetPos(GetDlgItem(ParentHwnd, IDC_RECEIVE_SLIDER),
                    TRUE,
                    RxValueToTrackbarPosition(&AdvancedData->FifoRxMax));
    wsprintf(szCurrentValue, TEXT("(%d)"), AdvancedData->FifoRxMax);
    SetDlgItemText(ParentHwnd, IDC_RXVALUE, szCurrentValue);

    Trackbar_SetPos(GetDlgItem(ParentHwnd, IDC_TRANSMIT_SLIDER), TRUE, AdvancedData->FifoTxMax);
    wsprintf(szCurrentValue, TEXT("(%d)"), AdvancedData->FifoTxMax);
    SetDlgItemText(ParentHwnd, IDC_TXVALUE, szCurrentValue);

//-------------------------------------------------------------------------
// END ATTENTION
#endif
//-------------------------------------------------------------------------

    //
    // Set the COM name to whatever it is currently set to in the registry
    //
    ushIndex =
        (USHORT) ComboBox_FindString(GetDlgItem(ParentHwnd, PP_PORT_NUMBER),
                                     -1,
                                     AdvancedData->szComName);

    ushIndex = (ushIndex == CB_ERR) ? 0 : ushIndex;

    ComboBox_SetCurSel(GetDlgItem(ParentHwnd, PP_PORT_NUMBER), ushIndex);
    ComboBox_SetCurSel(GetDlgItem(ParentHwnd, IDC_POLL_PERIOD), POLL_PERIOD_DEFAULT_IDX);
} /* RestoreAdvancedDefaultStates */


/*++

Routine Description: FillPortNameCb

    fill in the Port Name combo box selection with a list
    of possible un-used portnames

Arguments:

    poppOurPropParams: where to save the data to
    hDlg:              address of the window

Return Value:

    ULONG: returns error messages

--*/
ULONG
FillPortNameCb(
    HWND            ParentHwnd,
    PADVANCED_DATA  AdvancedData
    )
{
    BYTE  portUsage[MAX_COM_PORT/8];
    DWORD tmp, portsReported;
    int   i, j, nEntries;
    int   nCurPortNum;
    TCHAR szCom[40];
    TCHAR szInUse[40];
    char  mask, *current;
    HWND  portHwnd;

    portHwnd = GetDlgItem(ParentHwnd, PP_PORT_NUMBER);

    //
    // Check if our ComName is blank. If it is, disable the com port selector
    //
    if (_tcscmp(AdvancedData->szComName, TEXT("")) == 0) {
        EnableWindow(portHwnd, FALSE);
        EnableWindow(GetDlgItem(ParentHwnd, IDC_COMNUMTEXT), FALSE);
        return 0;
    }

    //
    // assumes szComPort filled in...
    //
    nCurPortNum = myatoi(&AdvancedData->szComName[3]);

    if (!LoadString(g_hInst, IDS_IN_USE, szInUse, CharSizeOf(szInUse))) {
        wcscpy(szInUse, _T(" (in use)"));
    }

    //
    // first tally up which ports NOT to offer in list box
    //
    ZeroMemory(portUsage, MAX_COM_PORT/8);

    if (AdvancedData->hComDB != HCOMDB_INVALID_HANDLE_VALUE) {
        ComDBGetCurrentPortUsage(AdvancedData->hComDB,
                                 portUsage,
                                 MAX_COM_PORT / 8,
                                 CDB_REPORT_BITS,
                                 &portsReported);
    }

    //
    // tag the current port as not in use so it shows up in the CB
    //
    current = portUsage + (nCurPortNum-1) / 8;
    if ((i = nCurPortNum % 8))
        *current &= ~(1 << (i-1));
    else
        *current &= ~(0x80);

    current = portUsage;
    mask = 0x1;
    for(nEntries = j = 0, i = MIN_COM-1; i < MAX_COM_PORT; i++) {

       wsprintf(szCom, TEXT("COM%d"), i+1);
       if (*current & mask) {
           wcscat(szCom, szInUse);
       }

       if (mask == (char) 0x80) {
           mask = 0x01;
           current++;
       }
       else {
           mask <<= 1;
       }

       ComboBox_AddString(portHwnd, szCom);
   }

   ComboBox_SetCurSel(portHwnd, nCurPortNum-1);
   return 0;
} /* FillPortNamesCb */

/*++

Routine Description: FillAdvancedDlg

    fill in the advanced dialog window

Arguments:

    poppOurPropParams: the data to fill in
    ParentHwnd:              address of the window

Return Value:

    ULONG: returns error messages

--*/
ULONG
FillAdvancedDlg(
    IN HWND             ParentHwnd,
    IN PADVANCED_DATA   AdvancedData
    )
{
   PSP_DEVINFO_DATA DeviceInfoData = AdvancedData->DeviceInfoData;
   HKEY  hDeviceKey;
   DWORD dwSize, dwData, dwFifo, dwError = ERROR_SUCCESS;

   //
   // Open the device key for the source device instance
   //
   hDeviceKey = AdvancedData->hDeviceKey;

   //
   // Get COM Name
   //
   dwSize = sizeof(AdvancedData->szComName);
   dwError = RegQueryValueEx(hDeviceKey,
                             m_szPortName,
                             NULL,
                             NULL,
                             (PBYTE)AdvancedData->szComName,
                             &dwSize);

   if (dwError != ERROR_SUCCESS) {
      wsprintf(AdvancedData->szComName, TEXT("COMX"));
   }

#if 0
   //
   // Get ForceFifoEnable information
   //
   AdvancedData->UseFifoBuffersControl = TRUE;

   dwSize = sizeof(dwFifo);
   dwError = RegQueryValueEx(hDeviceKey,
                             m_szFIFO,
                             NULL,
                             NULL,
                             (LPBYTE)(&dwFifo),
                             &dwSize);

   if (dwError == ERROR_SUCCESS) {
      //
      // Save this initial value
      //
      AdvancedData->UseFifoBuffersControl = TRUE;
      if (dwFifo == 0) {
         AdvancedData->UseFifoBuffers = FALSE;
      }
      else {
         AdvancedData->UseFifoBuffers = TRUE;
      }
   }
   else {
      //
      // value does not exist. Create our own
      //
      dwData = 1;
      dwSize = sizeof(dwSize);
      dwError = RegSetValueEx(hDeviceKey,
                              m_szFIFO,
                              0,
                              REG_DWORD,
                              (CONST BYTE *)(&dwData),
                              dwSize);

      if (dwError == ERROR_SUCCESS) {
         AdvancedData->UseFifoBuffers = TRUE;
      }
      else {
         AdvancedData->UseFifoBuffers = FALSE;
         AdvancedData->UseFifoBuffersControl = FALSE;
      }
   }

   //
   // Get FifoRxMax information
   //
   dwSize = sizeof(dwFifo);
   dwError = RegQueryValueEx(hDeviceKey,
                             m_szFifoRxMax,
                             NULL,
                             NULL,
                             (LPBYTE)(&dwFifo),
                             &dwFifo);

   if (dwError == ERROR_SUCCESS) {
      //
      // Save this initial value
      //
      AdvancedData->FifoRxMax = dwFifo;
      if (AdvancedData->FifoRxMax > RX_MAX) {
          AdvancedData->FifoRxMax = RX_MAX;
      }
   }
   else {
      //
      // value does not exist. Create our own
      //
      AdvancedData->FifoRxMax = RX_MAX;
   }

   //
   // Get RxFIFO information
   //
   dwSize = sizeof(dwFifo);
   dwError = RegQueryValueEx(hDeviceKey,
                             m_szFifoTxMax,
                             NULL,
                             NULL,
                             (LPBYTE)(&dwFifo),
                             &dwSize);

   if (dwError == ERROR_SUCCESS) {
      //
      // Save this initial value
      //
      AdvancedData->FifoTxMax = dwFifo;
      if (AdvancedData->FifoTxMax > TX_MAX) {
          AdvancedData->FifoTxMax = TX_MAX;
      }
   }
   else {
      //
      // value does not exist. Create our own
      //
      AdvancedData->FifoTxMax = TX_MAX;
   }

   //
   // Get RxFIFO information
   //
   AdvancedData->UseRxFIFOControl = TRUE;

   dwSize = sizeof(dwFifo);
   dwError = RegQueryValueEx(hDeviceKey,
                             m_szRxFIFO,
                             NULL,
                             NULL,
                             (LPBYTE)(&dwFifo),
                             &dwSize);

   if (dwError == ERROR_SUCCESS) {
      //
      // Save this initial value
      //
      AdvancedData->RxFIFO = dwFifo;
      if (AdvancedData->RxFIFO > RX_MAX) {
          goto SetRxFIFO;
      }
   }
   else {
SetRxFIFO:
      //
      // value does not exist. Create our own
      //
      dwData = AdvancedData->FifoRxMax;
      dwSize = sizeof(dwData);
      dwError = RegSetValueEx(hDeviceKey,
                              m_szRxFIFO,
                              0,
                              REG_DWORD,
                              (CONST BYTE *)(&dwData),
                              dwSize);

      if (dwError == ERROR_SUCCESS) {
         AdvancedData->RxFIFO = AdvancedData->FifoRxMax;
      }
      else {
         AdvancedData->RxFIFO = 0;
         AdvancedData->UseRxFIFOControl = FALSE;
      }
   }

   //
   // Get TxFIFO information
   //
   AdvancedData->UseTxFIFOControl = TRUE;

   dwSize = sizeof(dwFifo);
   dwError = RegQueryValueEx(hDeviceKey,
                             m_szTxFIFO,
                             NULL,
                             NULL,
                             (LPBYTE)(&dwFifo),
                             &dwSize);

   if (dwError == ERROR_SUCCESS) {
      //
      // Save this initial value
      //
      AdvancedData->TxFIFO = dwFifo;
      if (AdvancedData->TxFIFO > TX_MAX) {
          goto SetTxFIFO;
      }
   }
   else {
SetTxFIFO:
      //
      // value does not exist. Create our own
      //
      dwData = AdvancedData->FifoTxMax;
      dwSize = sizeof(dwData);
      dwError = RegSetValueEx(hDeviceKey,
                              m_szTxFIFO,
                              0,
                              REG_DWORD,
                              (LPBYTE)(&dwData),
                              dwSize);

      if (dwError == ERROR_SUCCESS) {
         AdvancedData->TxFIFO = AdvancedData->FifoTxMax;
      }
      else {
         AdvancedData->TxFIFO = 0;
         AdvancedData->UseTxFIFOControl = FALSE;
      }
   }
#endif

   //
   // Get Polling Period information
   //
   AdvancedData->PollingPeriod = PollingPeriods[POLL_PERIOD_DEFAULT_IDX];

   dwSize = sizeof(dwFifo);
   dwError = RegQueryValueEx(hDeviceKey,
                             m_szPollingPeriod,
                             NULL,
                             NULL,
                             (LPBYTE)(&dwFifo),
                             &dwSize);

   if (dwError == ERROR_SUCCESS) {
      //
      // Save this initial value
      //
      AdvancedData->PollingPeriod = dwFifo;
   }
   else {
      //
      // value does not exist. Create our own
      //
      dwData = AdvancedData->PollingPeriod;
      dwSize = sizeof(dwData);
      dwError = RegSetValueEx(hDeviceKey,
                              m_szPollingPeriod,
                              0,
                              REG_DWORD,
                              (LPBYTE)(&dwData),
                              dwSize);
   }

   RegCloseKey(hDeviceKey);

   if (ERROR_SUCCESS != dwError) {
      return dwError;
   }
   else {
      return ERROR_SUCCESS;
   }
} /* FillAdvancedDlg*/

void
ChangeParentTitle(
    IN HWND    Hwnd,
    IN LPCTSTR OldComName,
    IN LPCTSTR NewComName
    )
{
    INT    textLength, offset, newNameLen, oldNameLen;
    PTCHAR oldTitle = NULL, newTitle = NULL;
    PTCHAR oldLocation;

    textLength = GetWindowTextLength(Hwnd);
    if (textLength == 0) {
        return;
    }

    //
    // Account for null char and unicode
    //
    textLength++;
    oldTitle = (PTCHAR) LocalAlloc(LPTR, textLength * sizeof(TCHAR));
    if (!oldTitle) {
        return;
    }

    if (!GetWindowText(Hwnd, oldTitle, textLength)) {
        goto exit;
    }

    oldLocation = wcsstr(oldTitle, OldComName);
    if (!oldLocation) {
        goto exit;
    }

    newNameLen = lstrlen(NewComName);
    oldNameLen = lstrlen(OldComName);
    offset = newNameLen - oldNameLen;
    if (offset > 0) {
        textLength += offset;
    }
    newTitle = (PTCHAR) LocalAlloc(LPTR, textLength * sizeof(TCHAR));
    if (!newTitle) {
        goto exit;
    }

    //
    // Find the OldComName in the title and do the following
    // 1)  up to that location in the string
    // 2)  copy the new name
    // 3)  copy the remainder of the string after OldComName
    //
    offset = (INT)(oldLocation - oldTitle);
    CopyMemory(newTitle, oldTitle, offset * sizeof(TCHAR));                 // 1
    CopyMemory(newTitle + offset, NewComName, newNameLen * sizeof(TCHAR));  // 2
    lstrcpy(newTitle + offset + newNameLen, oldLocation + oldNameLen);      // 3

    SetWindowText(Hwnd, newTitle);

exit:
    if (oldTitle) {
        LocalFree(oldTitle);
    }
    if (newTitle) {
        LocalFree(newTitle);
    }
}

void
MigratePortSettings(
    LPCTSTR OldComName,
    LPCTSTR NewComName
    )
{
    TCHAR settings[BUFFER_SIZE];
    TCHAR szNew[20], szOld[20];

    lstrcpy(szOld, OldComName);
    wcscat(szOld, m_szColon);

    lstrcpy(szNew, NewComName);
    wcscat(szNew, m_szColon);

    settings[0] = TEXT('\0');
    GetProfileString(m_szPorts,
                     szOld,
                     TEXT(""),
                     settings,
                     sizeof(settings) / sizeof(TCHAR) );

    //
    // Insert the new key based on the old one
    //
    if (settings[0] == TEXT('\0')) {
        WriteProfileString(m_szPorts, szNew, m_szDefParams);
    }
    else {
        WriteProfileString(m_szPorts, szNew, settings);
    }

    //
    // Notify everybody of the changes and blow away the old key
    //
    SendWinIniChange((LPTSTR)m_szPorts);
    WriteProfileString(m_szPorts, szOld, NULL);
}

void
EnactComNameChanges(
    IN HWND             ParentHwnd,
    IN PADVANCED_DATA   AdvancedData,
    IN HKEY             hDeviceKey,
    IN UINT             NewComNum)
{
    DWORD  dwNewComNameLen;
    TCHAR  buffer[BUFFER_SIZE];
    TCHAR  szFriendlyNameFormat[LINE_LEN];
    TCHAR  szDeviceDesc[LINE_LEN];
    PTCHAR szNewComName;
    UINT   i;
    UINT   curComNum;
    BOOLEAN updateMapping = TRUE;

    SP_DEVINSTALL_PARAMS spDevInstall;

    //DbgOut(TEXT("EnactComNameChanges\n"));

    curComNum = myatoi(AdvancedData->szComName + wcslen(m_szCOM));

    if (AdvancedData->hComDB != HCOMDB_INVALID_HANDLE_VALUE) {
        BYTE   portUsage[MAX_COM_PORT/8];
        DWORD  portsReported;
        char   mask;

        //
        // Check to see if the desired new COM number has been claimed in the
        // com name database.  If so, ask the user if they are *really* sure
        //

        ComDBGetCurrentPortUsage(AdvancedData->hComDB,
                                 portUsage,
                                 MAX_COM_PORT / 8,
                                 CDB_REPORT_BITS,
                                 &portsReported);
        
        if (NewComNum > portsReported) {
            DWORD newsize;
            if (NewComNum > COMDB_MAX_PORTS_ARBITRATED) {
                MyMessageBox(ParentHwnd, IDS_PORT_RENAME_ERROR, IDS_NAME_PROPERTIES,
                             MB_ICONERROR);
                return;
            }
            newsize = NewComNum;
            if (NewComNum % 1024){
                newsize = NewComNum/1024;
                newsize++;
                newsize = newsize*1024;
            }
            if (newsize > COMDB_MAX_PORTS_ARBITRATED) {
                newsize = COMDB_MAX_PORTS_ARBITRATED;
            }
            if (newsize > portsReported) {
                if (ComDBResizeDatabase(AdvancedData->hComDB, newsize) != ERROR_SUCCESS){
                    MyMessageBox(ParentHwnd, IDS_PORT_RENAME_ERROR, IDS_NAME_PROPERTIES,
                                 MB_ICONERROR);
                    return;                    
                }
            }

            // We are assuming that NewComNum is <= MAX_COM_PORT.
            ComDBGetCurrentPortUsage(AdvancedData->hComDB,
                                     portUsage,
                                     MAX_COM_PORT / 8,
                                     CDB_REPORT_BITS,
                                     &portsReported);
        }
        
        if ((i = NewComNum % 8))
            mask = 1 << (i-1);
        else
            mask = (char) 0x80;
        if ((portUsage[(NewComNum-1)/8] & mask) &&
            MyMessageBox(ParentHwnd, IDS_PORT_IN_USE, IDS_NAME_PROPERTIES,
                         MB_YESNO | MB_ICONINFORMATION) == IDNO) {
            //
            // Port has been previously claimed and user doesn't want to override
            //
            return;
        }
    }

    if (!QueryDosDevice(AdvancedData->szComName, buffer, BUFFER_SIZE-1)) {
        //
        // The old com name does not exist in the mapping.  Basically, the symbolic
        // link from COMX => \Device\SerialY has been broken.  Just change the
        // value in the registry and the friendly name for the device; don't
        // change the dos symbolic name b/c one does not exist
        //
        updateMapping = FALSE;
    }
    else {
        TCHAR  szComFileName[20]; // more than enough for "\\.\COMXxxx"
        HANDLE hCom;

        lstrcpy(szComFileName, L"\\\\.\\");
        lstrcat(szComFileName, AdvancedData->szComName);

        //
        // Make sure that the port has not been opened by another application
        //
        hCom = CreateFile(szComFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL, NULL);

        //
        // If the file handle is invalid, then the com port is open, warn the user
        //
        if (hCom == INVALID_HANDLE_VALUE &&
            MyMessageBox(ParentHwnd, IDS_PORT_OPEN, IDS_NAME_PROPERTIES,
                         MB_YESNO | MB_ICONERROR) == IDNO) {
            return;
        }

        if (hCom != INVALID_HANDLE_VALUE) {
            CloseHandle(hCom);
        }
    }

    szNewComName = AdvancedData->szNewComName;
    wsprintf(szNewComName, _T("COM%d"), NewComNum);
    dwNewComNameLen = ByteCountOf(wcslen(szNewComName) + 1);

    //
    // Change the name in the symbolic namespace.
    // First try to get what device the old com name mapped to
    // (ie something like \Device\Serial0).  Then remove the mapping.  If
    // the user isn't an admin, then this will fail and the dialog will popup.
    // Finally, map the new name to the old device retrieved from the
    // QueryDosDevice
    //
    if (updateMapping) {
        BOOL removed;
        HKEY hSerialMap;

        if (!QueryDosDevice(AdvancedData->szComName, buffer, BUFFER_SIZE-1)) {
            //
            // This shouldn't happen because the previous QueryDosDevice call
            // succeeded
            //
            MyMessageBox(ParentHwnd, IDS_PORT_RENAME_ERROR, IDS_NAME_PROPERTIES,
                         MB_ICONERROR);
            return;
        }

        //
        // If this fails, then the following define will just replace the current
        // mapping.
        //
        removed = DefineDosDevice(DDD_REMOVE_DEFINITION, AdvancedData->szComName, NULL);

        if (!DefineDosDevice(DDD_RAW_TARGET_PATH, szNewComName, buffer)) {
            //
            // error, first fix up the remove definition and restore the old
            // mapping
            //
            if (removed) {
                DefineDosDevice(DDD_RAW_TARGET_PATH, AdvancedData->szComName, buffer);
            }

            MyMessageBox(ParentHwnd, IDS_PORT_RENAME_ERROR, IDS_NAME_PROPERTIES,
                         MB_ICONERROR);

            return;
        }

        //
        // Set the \\HARDWARE\DEVICEMAP\SERIALCOMM field
        //
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         m_szRegSerialMap,
                         0,
                         KEY_ALL_ACCESS,
                         &hSerialMap) == ERROR_SUCCESS) {

            TCHAR  szSerial[BUFFER_SIZE];
            DWORD  dwSerialSize, dwEnum, dwType, dwComSize;
            TCHAR  szCom[BUFFER_SIZE];

            i = 0;
            do {
                dwSerialSize = CharSizeOf(szSerial);
                dwComSize = sizeof(szCom);
                dwEnum = RegEnumValue(hSerialMap,
                                      i++,
                                      szSerial,
                                      &dwSerialSize,
                                      NULL,
                                      &dwType,
                                      (LPBYTE)szCom,
                                      &dwComSize);

                if (dwEnum == ERROR_SUCCESS) {
                    if(dwType != REG_SZ)
                        continue;

                    if (wcscmp(szCom, AdvancedData->szComName) == 0) {
                        RegSetValueEx(hSerialMap,
                                        szSerial,
                                        0,
                                        REG_SZ,
                                        (PBYTE) szNewComName,
                                        dwNewComNameLen);
                                        break;
                    }
                }

            } while (dwEnum == ERROR_SUCCESS);
        }

        RegCloseKey(hSerialMap);
    }

    //
    // Update the com db
    //
    if (AdvancedData->hComDB != HCOMDB_INVALID_HANDLE_VALUE) {

        ComDBReleasePort(AdvancedData->hComDB, (DWORD) curComNum);

        ComDBClaimPort(AdvancedData->hComDB, (DWORD) NewComNum, TRUE, NULL);
    }

    //
    // Set the friendly name in the form of DeviceDesc (COM#)
    //
    if (ReplaceFriendlyName(AdvancedData->DeviceInfoSet,
                            AdvancedData->DeviceInfoData,
                            szNewComName) == FALSE) {
        // ReplaceFriendlyName failed. Use original code.
        if (LoadString(g_hInst,
                       IDS_FRIENDLY_FORMAT,
                       szFriendlyNameFormat,
                       CharSizeOf(szFriendlyNameFormat)) &&
            SetupDiGetDeviceRegistryProperty(AdvancedData->DeviceInfoSet,
                                             AdvancedData->DeviceInfoData,
                                             SPDRP_DEVICEDESC,
                                             NULL,
                                             (PBYTE) szDeviceDesc,
                                             sizeof(szDeviceDesc),
                                             NULL)) {
            wsprintf(buffer, szFriendlyNameFormat, szDeviceDesc, szNewComName);

        }
        else {
            //
            // Use the COM port name straight out
            //
            lstrcpy(buffer, szNewComName);
        }

        SetupDiSetDeviceRegistryProperty(AdvancedData->DeviceInfoSet,
                                         AdvancedData->DeviceInfoData,
                                         SPDRP_FRIENDLYNAME,
                                         (PBYTE) buffer,
                                         ByteCountOf(wcslen(buffer)+1));
    }

    //
    // Set the parent dialog's title to reflect the change in the com port's name
    //
    ChangeParentTitle(GetParent(ParentHwnd), AdvancedData->szComName, szNewComName);
    MigratePortSettings(AdvancedData->szComName, szNewComName);

    //
    // Update the PortName value in the devnode
    //
    RegSetValueEx(hDeviceKey,
                  m_szPortName,
                  0,
                  REG_SZ,
                  (PBYTE)szNewComName,
                  dwNewComNameLen);

    //
    // Now broadcast this change to the device manager
    //
    ZeroMemory(&spDevInstall, sizeof(SP_DEVINSTALL_PARAMS));
    spDevInstall.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if (SetupDiGetDeviceInstallParams(AdvancedData->DeviceInfoSet,
                                      AdvancedData->DeviceInfoData,
                                      &spDevInstall)) {
        spDevInstall.Flags |= DI_PROPERTIES_CHANGE;
        SetupDiSetDeviceInstallParams(AdvancedData->DeviceInfoSet,
                                      AdvancedData->DeviceInfoData,
                                      &spDevInstall);
    }
}

/*++

Routine Description: SaveAdvancedSettings

    saves the advanced box settings back to the registry, if any were
    changed

Arguments:

    AdvancedData: holds the current settings and the location of of
                   the device in the registry
    ParentHwnd:          address of the window

Return Value:

    ULONG: returns error messages

--*/
ULONG
SaveAdvancedSettings(
    IN HWND ParentHwnd,
    IN PADVANCED_DATA AdvancedData
    )
{
   HKEY   hDeviceKey;
   DWORD  dwSize, dwData;

   UINT  i = CB_ERR, curComNum, newComNum = CB_ERR;
   //UINT  uiDlgButtonChecked;
   //DWORD dwRxPosition, dwTxPosition;
   DWORD dwPollingPeriod;

   SP_DEVINSTALL_PARAMS spDevInstall;

   //DbgOut(TEXT("SaveAdvancedSettings\n"));

   //
   // Grab all of the new settings
   //

   //uiDlgButtonChecked = IsDlgButtonChecked(ParentHwnd, IDC_FIFO);

   //dwTxPosition = Trackbar_GetPos(GetDlgItem(ParentHwnd, IDC_TRANSMIT_SLIDER));
   //dwRxPosition = Trackbar_GetPos(GetDlgItem(ParentHwnd, IDC_RECEIVE_SLIDER));

   //
   // Index is actually into the array of values
   //
   //dwRxPosition = RxValues[dwRxPosition-1];

   curComNum = myatoi(AdvancedData->szComName + wcslen(m_szCOM));
   newComNum = ComboBox_GetCurSel(GetDlgItem(ParentHwnd, PP_PORT_NUMBER));

   if (newComNum == CB_ERR) {
       newComNum = curComNum;
   }
   else {
       newComNum++;
   }

   i = ComboBox_GetCurSel(GetDlgItem(ParentHwnd, IDC_POLL_PERIOD));

   if (i == CB_ERR || i >= NUM_POLLING_PERIODS) {
       dwPollingPeriod = AdvancedData->PollingPeriod;
   }
   else {
       dwPollingPeriod = PollingPeriods[i];
   }

   //
   // See if they changed anything
   //
   if (//((AdvancedData->UseFifoBuffers  && uiDlgButtonChecked == BST_CHECKED) ||
       // (!AdvancedData->UseFifoBuffers && uiDlgButtonChecked == BST_UNCHECKED)) &&
       //AdvancedData->RxFIFO == dwRxPosition &&
       //AdvancedData->TxFIFO == dwTxPosition &&
       AdvancedData->PollingPeriod == dwPollingPeriod &&
       newComNum == curComNum) {
      //
      // They didn't change anything. Just exit.
      //
      return ERROR_SUCCESS;
   }

   //
   // Open the device key for the source device instance
   //
   hDeviceKey = SetupDiOpenDevRegKey(AdvancedData->DeviceInfoSet,
                                     AdvancedData->DeviceInfoData,
                                     DICS_FLAG_GLOBAL,
                                     0,
                                     DIREG_DEV,
                                     KEY_ALL_ACCESS);

   if (INVALID_HANDLE_VALUE == hDeviceKey) {
      //
      // Not much we can do without a valid key, exit gracefully
      //
      return ERROR_SUCCESS;
   }

   //
   // Check to see if the user changed the COM port name
   //
   if (newComNum != curComNum) {
      EnactComNameChanges(ParentHwnd,
                          AdvancedData,
                          hDeviceKey,
                          newComNum);
   }


//   if ((AdvancedData->UseFifoBuffers  && uiDlgButtonChecked == BST_UNCHECKED) ||
//       (!AdvancedData->UseFifoBuffers && uiDlgButtonChecked == BST_CHECKED)) {
//      //
//      // They changed the Use Fifo checkbox.
//      //
//      dwData = (uiDlgButtonChecked == BST_CHECKED) ? 1 : 0;
//      dwSize = sizeof(dwData);
//      RegSetValueEx(hDeviceKey,
//                    m_szFIFO,
//                    0,
//                    REG_DWORD,
//                    (CONST BYTE *)(&dwData),
//                    dwSize);
//   }
//
//   if (AdvancedData->RxFIFO != dwRxPosition) {
//      //
//      // They changed the RxFIFO setting
//      //
//      dwData = dwRxPosition;
//      dwSize = sizeof(dwData);
//      RegSetValueEx(hDeviceKey,
//                    m_szRxFIFO,
//                    0,
//                    REG_DWORD,
//                    (CONST BYTE *)(&dwData),
//                    dwSize);
//   }
//
//   if (AdvancedData->TxFIFO != dwTxPosition) {
//      //
//      // They changed the TxFIFO setting
//      //
//      dwData = dwTxPosition;
//      dwSize = sizeof(dwData);
//      RegSetValueEx(hDeviceKey,
//                    m_szTxFIFO,
//                    0,
//                    REG_DWORD,
//                    (CONST BYTE *)(&dwData),
//                    dwSize);
//   }

   if (AdvancedData->PollingPeriod != dwPollingPeriod) {
      //
      // They changed the polling period
      //
      dwData = dwPollingPeriod;
      dwSize = sizeof(dwData);
      RegSetValueEx(hDeviceKey,
                    m_szPollingPeriod,
                    0,
                    REG_DWORD,
                    (CONST BYTE *)(&dwData),
                    dwSize);

      //
      // Don't really care if this fails, nothing else we can do
      //
      CM_Reenumerate_DevNode(AdvancedData->DeviceInfoData->DevInst,
                             CM_REENUMERATE_NORMAL);
   }

   RegCloseKey(hDeviceKey);

   SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                             AdvancedData->DeviceInfoSet,
                             AdvancedData->DeviceInfoData);

   return ERROR_SUCCESS;
} /* SaveAdvancedSettings*/



/*++

Routine Description:

    Prototype to allow serial port vendors to override the advanced dialog
    represented by the COM port specified by DeviceInfoSet and DeviceInfoData.

    To override the advanced page, place a value named EnumAdvancedDialog under
    the same key in which you would put your EnumPropPages32 value.  The format
    of the value is exactly the same as Enum...32 as well.

Arguments:

    ParentHwnd  - the parent window of the window to be displayed

    HidePollingUI - If TRUE, hide all UI that deals with polling.

    DeviceInfoSet, DeviceInfoData - SetupDi structures representing the COM port

    Reserved - Unused

Return Value:

    TRUE if the user pressed OK, FALSE if Cancel was pressed
--*/
BOOL
CyyportAdvancedDialog(
    IN HWND             ParentHwnd,
    IN BOOL             HidePollingUI,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PVOID            Reserved
    )
{
    PADVANCED_DATA pAdvancedData = NULL; 

    //DbgOut(TEXT("CyzportAdvancedDialog\n"));
    
    pAdvancedData = (PADVANCED_DATA) LocalAlloc(LPTR, sizeof(ADVANCED_DATA));

//**************************************************************
// TEST Debugger
//    DebugBreak();
//**************************************************************

    if (pAdvancedData == NULL) {

        ErrMemDlg(ParentHwnd);
        return FALSE;
    }

    pAdvancedData->HidePolling = HidePollingUI;
    pAdvancedData->DeviceInfoSet  = DeviceInfoSet;
    pAdvancedData->DeviceInfoData = DeviceInfoData;

    DisplayAdvancedDialog(ParentHwnd, pAdvancedData);
    
    if (pAdvancedData != NULL) {
        LocalFree(pAdvancedData);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyports\portstr.h ===
#ifndef PORTSTR_H
#define PORTSTR_H

//
//  exported from ports.c
//
extern TCHAR  m_szColon[];
extern TCHAR  m_szComma[];
extern TCHAR  m_szCloseParen[];
extern TCHAR  m_szPorts[];
extern TCHAR  m_szCOM[];
extern TCHAR  m_szSERIAL[];

extern TCHAR m_szRegSerialMap[];

extern TCHAR m_szFIFO[];
extern TCHAR m_szDosDev[];
extern TCHAR m_szPollingPeriod[];
extern TCHAR m_szPortName[];


// Strings needed for parallel port installation.
//
extern TCHAR m_szPortSubClass[];
extern TCHAR m_szParallelClassDevName[];
extern TCHAR m_szParallelClassHwId[];

extern int m_nBaudRates[];

extern TCHAR m_sz9600[];

extern TCHAR m_szDefParams[];
extern short m_nDataBits[];
extern TCHAR *m_pszParitySuf[];
extern TCHAR *m_pszLenSuf[];
extern TCHAR *m_pszStopSuf[];
extern TCHAR *m_pszFlowSuf[];

#endif // PORTSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\z\cyclad-z\cyclad-z.h ===
/*--------------------------------------------------------------------------
*
*   Copyright (C) Cyclades Corporation, 2000-2001.
*   All rights reserved.
*
*   Cyclades-Z Enumerator Driver
*	
*   This file:      cyclad-z.h
*
*   Description:    This module contains the common private declarations 
*                   for the cyzport enumerator.
*					
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*
*   Complies with Cyclades SW Coding Standard rev 1.3.
*
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#ifndef CYCLADZ_H
#define CYCLADZ_H

#include "cyzhw.h"

#define DEVICE_OBJECT_NAME_LENGTH   128     // Copied from serial.h

#define CYZ_PDO_NAME_BASE L"\\Cyz\\"


#define CYCLADZ_POOL_TAG (ULONG)'ZcyC'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
   ExAllocatePoolWithTag(type, size, CYCLADZ_POOL_TAG)


#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect


//
// Debugging Output Levels
//

#define SER_DBG_STARTUP_SHUTDOWN_MASK  0x0000000F
#define SER_DBG_SS_NOISE               0x00000001
#define SER_DBG_SS_TRACE               0x00000002
#define SER_DBG_SS_INFO                0x00000004
#define SER_DBG_SS_ERROR               0x00000008

#define SER_DBG_PNP_MASK               0x000000F0
#define SER_DBG_PNP_NOISE              0x00000010
#define SER_DBG_PNP_TRACE              0x00000020
#define SER_DBG_PNP_INFO               0x00000040
#define SER_DBG_PNP_ERROR              0x00000080
#define SER_DBG_PNP_DUMP_PACKET        0x00000100

#define SER_DBG_IOCTL_TRACE            0x00000200
#define SER_DBG_POWER_TRACE            0x00000400
#define SER_DBG_CYCLADES               0x00000800

#define SER_DEFAULT_DEBUG_OUTPUT_LEVEL 0x00000000
//#define SER_DEFAULT_DEBUG_OUTPUT_LEVEL 0xFFFFFFFF


#if DBG
#define Cycladz_KdPrint(_d_,_l_, _x_) \
            if ((_d_)->DebugLevel & (_l_)) { \
               DbgPrint ("Cyclad-z: "); \
               DbgPrint _x_; \
            }

#define Cycladz_KdPrint_Cont(_d_,_l_, _x_) \
            if ((_d_)->DebugLevel & (_l_)) { \
               DbgPrint _x_; \
            }

#define Cycladz_KdPrint_Def(_l_, _x_) \
            if (SER_DEFAULT_DEBUG_OUTPUT_LEVEL & (_l_)) { \
               DbgPrint ("Cyclad-z: "); \
               DbgPrint _x_; \
            }

#define TRAP() DbgBreakPoint()
#define DbgRaiseIrql(_x_,_y_) KeRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_) KeLowerIrql(_x_)
#else

#define Cycladz_KdPrint(_d_, _l_, _x_)
#define Cycladz_KdPrint_Cont(_d_, _l_, _x_)
#define Cycladz_KdPrint_Def(_l_, _x_)
#define TRAP()
#define DbgRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)

#endif

#if !defined(MIN)
#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))
#endif


typedef struct _WORKER_THREAD_CONTEXT
{
    PDEVICE_OBJECT      DeviceObject;
    PIRP                Irp;
    PIO_WORKITEM        WorkItem;
    POWER_STATE         PowerState;
    POWER_STATE_TYPE    PowerType;

} WORKER_THREAD_CONTEXT, *PWORKER_THREAD_CONTEXT;


//
// These are the states a PDO or FDO transition upon
// receiving a specific PnP Irp. Refer to the PnP Device States
// diagram in DDK documentation for better understanding.
//

typedef enum _DEVICE_PNP_STATE {

    NotStarted = 0,         // Not started yet
    Started,                // Device has received the START_DEVICE IRP
    StopPending,            // Device has received the QUERY_STOP IRP
    Stopped,                // Device has received the STOP_DEVICE IRP
    RemovePending,          // Device has received the QUERY_REMOVE IRP
    SurpriseRemovePending,  // Device has received the SURPRISE_REMOVE IRP
    Deleted,                // Device has received the REMOVE_DEVICE IRP
    UnKnown                 // Unknown state

} DEVICE_PNP_STATE;


//
// A common header for the device extensions of the PDOs and FDO
//

typedef struct _COMMON_DEVICE_DATA
{
    PDEVICE_OBJECT  Self;
    // A backpointer to the device object for which this is the extension

    BOOLEAN         IsFDO;

//    BOOLEAN         Removed;   // Added in build 2072
    // Has this device been removed?  Should we fail any requests?

    // We track the state of the device with every PnP Irp
    // that affects the device through these two variables.
    
    DEVICE_PNP_STATE DevicePnPState;
    DEVICE_PNP_STATE PreviousPnPState;

    ULONG           DebugLevel;

    SYSTEM_POWER_STATE  SystemState;
    DEVICE_POWER_STATE  DeviceState;
} COMMON_DEVICE_DATA, *PCOMMON_DEVICE_DATA;

//
// The device extension for the PDOs.
// That is the serial ports of which this bus driver enumerates.
// (IE there is a PDO for the 201 serial port).
//

typedef struct _PDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    PDEVICE_OBJECT  ParentFdo;
    // A back pointer to the bus

    UNICODE_STRING  HardwareIDs;
    // Either in the form of bus\device
    // or *PNPXXXX - meaning root enumerated

    UNICODE_STRING  CompIDs;
    // compatible ids to the hardware id

    UNICODE_STRING  DeviceIDs;
    // Format: bus\device

    UNICODE_STRING  InstanceIDs;

    //
    // Text describing device
    //

    UNICODE_STRING DevDesc;

    BOOLEAN     Attached;
//    BOOLEAN     Removed;  -> Removed in build 2072
    // When a device (PDO) is found on a bus and presented as a device relation
    // to the PlugPlay system, Attached is set to TRUE, and Removed to FALSE.
    // When the bus driver determines that this PDO is no longer valid, because
    // the device has gone away, it informs the PlugPlay system of the new
    // device relastions, but it does not delete the device object at that time.
    // The PDO is deleted only when the PlugPlay system has sent a remove IRP,
    // and there is no longer a device on the bus.
    //
    // If the PlugPlay system sends a remove IRP then the Removed field is set
    // to true, and all client (non PlugPlay system) accesses are failed.
    // If the device is removed from the bus Attached is set to FALSE.
    //
    // During a query relations Irp Minor call, only the PDOs that are
    // attached to the bus (and all that are attached to the bus) are returned
    // (even if they have been removed).
    //
    // During a remove device Irp Minor call, if and only if, attached is set
    // to FALSE, the PDO is deleted.
    //


   // The child devices will have to know which PortIndex they are.   
   ULONG PortIndex;

} PDO_DEVICE_DATA, *PPDO_DEVICE_DATA;


//
// The device extension of the bus itself.  From whence the PDO's are born.
//

typedef struct _FDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    PDRIVER_OBJECT   DriverObject;

    UCHAR            PdoIndex;
    // A number to keep track of the Pdo we're allocating.
    // Increment every time we create a new PDO.  It's ok that it wraps.

    ULONG            NumPDOs;
    // The PDOs currently enumerated.

    PDEVICE_OBJECT   AttachedPDO[CYZ_MAX_PORTS];

    PPDO_DEVICE_DATA PdoData[CYZ_MAX_PORTS];

    PDEVICE_OBJECT  UnderlyingPDO;
    PDEVICE_OBJECT  TopOfStack;
    // the underlying bus PDO and the actual device object to which our
    // FDO is attached

    ULONG           OutstandingIO;
    // the number of IRPs sent from the bus to the underlying device object

    KEVENT          RemoveEvent;
    // On remove device plugplay request we must wait until all outstanding
    // requests have been completed before we can actually delete the device
    // object.

    UNICODE_STRING DevClassAssocName;
    // The name returned from IoRegisterDeviceClass Association,
    // which is used as a handle for IoSetDev... and friends.

    SYSTEM_POWER_STATE  SystemWake;
    DEVICE_POWER_STATE  DeviceWake;

#ifndef POLL
    //
    // We keep the following values around so that we can connect
    // to the interrupt and report resources after the configuration
    // record is gone.
    //

    //
    // Translated vector
    //
    ULONG Vector;

    //
    // Translated Irql
    //
    KIRQL Irql;

    //
    // Untranslated vector
    //
    ULONG OriginalVector;

    //
    // Untranslated irql
    //
    ULONG OriginalIrql;
#endif

    //
    // Bus number
    //
    ULONG BusNumber;

    //
    // Interface type
    //
    INTERFACE_TYPE InterfaceType;

    //
    // Cycladez-Z hardware
    //
    PHYSICAL_ADDRESS PhysicalRuntime;
    PHYSICAL_ADDRESS TranslatedRuntime;
    ULONG            RuntimeLength;
    
    PHYSICAL_ADDRESS PhysicalBoardMemory;
    PHYSICAL_ADDRESS TranslatedBoardMemory;
    ULONG            BoardMemoryLength;
 
    PUCHAR           BoardMemory;
    struct RUNTIME_9060 *Runtime;

    ULONG            IsPci;

    ULONG            NumPorts;

    ULONG            FirmwareVersion;

    // We are passing the resources privatly to our children so that Device Manager will not 
    // complain about resource conflict between children.

    PIO_RESOURCE_REQUIREMENTS_LIST  PChildRequiredList;
    PCM_RESOURCE_LIST  PChildResourceList;
    ULONG              PChildResourceListSize;

    PCM_RESOURCE_LIST  PChildResourceListTr;
    ULONG              PChildResourceListSizeTr;

    ULONG            UINumber;

} FDO_DEVICE_DATA, *PFDO_DEVICE_DATA;

//
// Macros
//

#define INITIALIZE_PNP_STATE(_Data_)    \
        (_Data_)->DevicePnPState =  NotStarted;\
        (_Data_)->PreviousPnPState = NotStarted;

#define SET_NEW_PNP_STATE(_Data_, _state_) \
        (_Data_)->PreviousPnPState =  (_Data_)->DevicePnPState;\
        (_Data_)->DevicePnPState = (_state_);

#define RESTORE_PREVIOUS_PNP_STATE(_Data_)   \
        (_Data_)->DevicePnPState =   (_Data_)->PreviousPnPState;\

//
// Free the buffer associated with a Unicode string
// and re-init it to NULL
//

#define CycladzFreeUnicodeString(PStr) \
{ \
   if ((PStr)->Buffer != NULL) { \
      ExFreePool((PStr)->Buffer); \
   } \
   RtlInitUnicodeString((PStr), NULL); \
}

//
// Prototypes
//

NTSTATUS
Cycladz_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cycladz_IoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cycladz_InternIoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
Cycladz_DriverUnload (
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
Cycladz_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cycladz_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cycladz_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusDeviceObject
    );

NTSTATUS
Cycladz_PnPRemove (
    PDEVICE_OBJECT      Device,
    PPDO_DEVICE_DATA    PdoData
    );

NTSTATUS
Cycladz_FDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
Cycladz_PDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PPDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
Cycladz_IncIoCount (
    PFDO_DEVICE_DATA   Data
    );

VOID
Cycladz_DecIoCount (
    PFDO_DEVICE_DATA   Data
    );

NTSTATUS
Cycladz_DispatchPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Cycladz_ReenumerateDevices(
    IN PIRP                 Irp,
    IN PFDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
Cycladz_InitMultiString(PFDO_DEVICE_DATA FdoData, PUNICODE_STRING MultiString,
                        ...);
void
Cycladz_PDO_EnumMarkMissing(
    PFDO_DEVICE_DATA FdoData,
    PPDO_DEVICE_DATA PdoData);

NTSTATUS
Cycladz_GetRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength,
    OUT PULONG ActualLength);

void
Cycladz_InitPDO (
    ULONG               index,
    PDEVICE_OBJECT      pdoData,
    PFDO_DEVICE_DATA    fdoData
    );

NTSTATUS
CycladzSyncCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                      IN PKEVENT CycladzSyncEvent);

NTSTATUS
Cycladz_GetResourceInfo(IN PDEVICE_OBJECT PDevObj,
                    IN PCM_RESOURCE_LIST PResList,
                    IN PCM_RESOURCE_LIST PTrResList);

VOID
Cycladz_ReleaseResources(IN PFDO_DEVICE_DATA PDevExt);

NTSTATUS
Cycladz_GotoPowerState(IN PDEVICE_OBJECT PDevObj,
                   IN PFDO_DEVICE_DATA PDevExt,
                   IN DEVICE_POWER_STATE DevPowerState);
NTSTATUS
Cycladz_SystemPowerCompletion(IN PDEVICE_OBJECT PDevObj, UCHAR MinorFunction,
                          IN POWER_STATE PowerState, IN PVOID Context,
                          PIO_STATUS_BLOCK IoStatus);

NTSTATUS
Cycladz_ItemCallBack(
                  IN PVOID Context,
                  IN PUNICODE_STRING PathName,
                  IN INTERFACE_TYPE BusType,
                  IN ULONG BusNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
                  IN CONFIGURATION_TYPE ControllerType,
                  IN ULONG ControllerNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
                  IN CONFIGURATION_TYPE PeripheralType,
                  IN ULONG PeripheralNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
                  );

NTSTATUS
Cycladz_BuildRequirementsList(
                          OUT PIO_RESOURCE_REQUIREMENTS_LIST *PChildRequiredList_Pointer,
                          IN PCM_RESOURCE_LIST PResourceList, IN ULONG NumberOfResources
                          );

NTSTATUS
Cycladz_BuildResourceList(
                      OUT PCM_RESOURCE_LIST *POutList_Pointer,
                      OUT ULONG *ListSize_Pointer,
                      IN PCM_RESOURCE_LIST PInList,
                      IN ULONG NumberOfResources
                      );
VOID
Cycladz_Delay(
	ULONG NumberOfMilliseconds
    );

ULONG
Cycladz_DoesBoardExist(
                   IN PFDO_DEVICE_DATA Extension
                   );

VOID
CyzLogError(
              IN PDRIVER_OBJECT DriverObject,
              IN PDEVICE_OBJECT DeviceObject OPTIONAL,
              IN PHYSICAL_ADDRESS P1,
              IN PHYSICAL_ADDRESS P2,
              IN ULONG SequenceNumber,
              IN UCHAR MajorFunctionCode,
              IN UCHAR RetryCount,
              IN ULONG UniqueErrorValue,
              IN NTSTATUS FinalStatus,
              IN NTSTATUS SpecificIOStatus,
              IN ULONG LengthOfInsert1,
              IN PWCHAR Insert1,
              IN ULONG LengthOfInsert2,
              IN PWCHAR Insert2
              );

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
);


#endif // endef CYCLADZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyports\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ports.rc
//
#define INITS                           0
#define IDS_INIT_NAME                   1
#define IDS_INIT_CLOSE                  2
#define PORTS_ICON                      2
#define IDS_PORT_IN_USE                 5
#define ERRORS                          8
#define MYPORT                          10
#define IDS_PARITY                      11
#define IDS_BITS                        12
#define IDS_FLOWCONTROL                 13
#define DLG_PP_PORTSETTINGS             15
#define DLG_PP_ADVPORTS                 16
#define IDS_ADVANCED_SETTINGS_FOR       19
#define IDS_FRIENDLY_FORMAT             29
#define IDS_ADVANCED_SETTINGS           30
#define IDS_SYSSETCHANGE                50
#define IDS_COMCHANGE                   51
#define IDS_LOW                         53
#define IDS_HIGH                        54
#define IDS_NO_WRITE_PRVILEGE           55
#define IDS_NAME_PROPERTIES             56
#define IDS_COM_CONFLICT                59
#define IDS_PORT_OPEN                   59
#define IDS_COM_CONFLICT_RESOLVE        60
#define IDS_PORT_RENAME_ERROR           60
#define IDS_IN_USE                      61
#define IDS_LPT_PROPERTIES              62
#define IDS_LPT_PORT_INUSE              63
#define IDS_LPT_NUM_ERROR               64
#define IDS_LPT_LEGACY_FAILED           65
#define DLG_PP_LPT_PORTSETTINGS         102
#define PORT_BAUDRATE                   800
#define PORT_DATABITS                   801
#define PORT_PARITY                     802
#define PORT_STOPBITS                   803
#define PORT_FLOWCTL                    804
#define PORT_ADVANCED                   805
#define IDC_RECEIVE_SLIDER              821
#define IDC_ADVANCED                    840
#define PP_PORT_BAUDRATE                841
#define IDC_TRANSMIT_SLIDER             842
#define PP_PORT_DATABITS                842
#define PP_PORT_PARITY                  843
#define IDC_RESTORE                     844
#define PP_PORT_STOPBITS                844
#define PP_PORT_FLOWCTL                 845
#define PP_PORT_NUMBER                  846
#define PP_PORT_FIFO                    847
#define PP_PORT_TYPE                    848
#define IDC_FIFO                        885
#define IDC_LOW1                        886
#define IDC_LOW2                        887
#define IDC_HIGH1                       888
#define IDC_HIGH2                       889
#define IDC_RECEIVE_TEXT                890
#define IDC_TRANSMIT_TEXT               891
#define IDC_RESTORE_PORT                892
#define IDC_RXVALUE                     893
#define IDC_TXVALUE                     894
#define IDC_COMNUMTEXT                  895
#define IDC_TRANSMIT_LOW                1000
#define IDC_RECEIVE_LOW                 1001
#define IDC_RECEIVE_HIGH                1002
#define IDC_TRANSMIT_HIGH               1003
#define IDC_POLL_PERIOD                 1027
#define IDC_POLL_DESC                   1029
#define IDC_DESC_1                      1030
#define IDC_DESC_2                      1031
#define IDC_FILTERMETHOD_TRYNOT         1032
#define IDC_FILTERMETHOD_NEVER          1033
#define IDC_FILTERMETHOD_ACCEPTANY      1034
#define PP_LPT_PORT_NUMBER              1035
#define IDC_LPTNUMTEXT                  1036
#define IDC_LPT_ENABLE_LEGACY           1037
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1038
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyports\cyyports.c ===
/** FILE: ports.c ********** Module Header ********************************
 *
 *  DLL entry point.
 *
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/
//==========================================================================
//                                Include files
//==========================================================================
// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

// Application specific
#include "cyyports.h"
#include <msports.h>


//==========================================================================
//                                Globals
//==========================================================================

HANDLE  g_hInst  = NULL;

TCHAR g_szErrMem[ 200 ];            //  Low memory message
TCHAR g_szPortsApplet[ 30 ];        //  "Ports Control Panel Applet" title
TCHAR g_szNull[]  = TEXT("");       //  Null string

TCHAR  m_szColon[]      = TEXT( ":" );
TCHAR  m_szPorts[]      = TEXT( "Ports" );
TCHAR  m_szCOM[]        = TEXT( "COM" );

//
//  NT Registry keys to find COM port to Serial Device mapping
//
TCHAR m_szRegSerialMap[]    = TEXT( "Hardware\\DeviceMap\\SerialComm" );

//
//  Registry Serial Port Advanced I/O settings key and valuenames
//
TCHAR m_szFIFO[]            = TEXT( "ForceFifoEnable" );

TCHAR m_szPollingPeriod[]   = TEXT( "PollingPeriod" );
TCHAR m_szPortName[]        = REGSTR_VAL_PORTNAME;

TCHAR m_szDefParams[]       = TEXT( "9600,n,8,1" );


//==========================================================================
//                            Local Function Prototypes
//==========================================================================
LPTSTR GetDIFString(IN DI_FUNCTION Func);


//==========================================================================
//                                Dll Entry Point
//==========================================================================
BOOL APIENTRY LibMain( HANDLE hDll, DWORD dwReason, LPVOID lpReserved )
{
   
    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
//      DbgOut(TEXT("cyyports DLL_PROCESS_ATTACH\n"));
        g_hInst = hDll;
        DisableThreadLibraryCalls(hDll);
        InitStrings();

        break;

    case DLL_PROCESS_DETACH:
//      DbgOut(TEXT("cyyports DLL_PROCESS_DETACH\n"));
        break;

    default:
        break;
    }

    return TRUE;
}


//==========================================================================
//                                Functions
//==========================================================================



HRESULT
CyyportCoInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA    Context
)
/*++

Routine Description:

    This routine is a Co-Installer for the Cyclom-Y Port device.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

    Context - Points to a coinstaller-specific context structure for this 
        installation request. 

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/
{
    DWORD   dwSize;
    TCHAR   instanceId[MAX_DEVICE_ID_LEN];
    TCHAR   parentIdPrefix[50];
    HKEY    enumKey,instKey;
    BOOL    gotParentIdPrefix;
    DWORD   Status = NO_ERROR;


//  #if DBG
//  {
//   TCHAR buf[500];
//   wsprintf(buf, TEXT("CyyportCoInstaller:InstallFunction(%s) PostProcessing:%d\n"), GetDIFString(InstallFunction), Context->PostProcessing);
//   DbgOut(buf);
//  }
//  #endif

    switch(InstallFunction) {
        case DIF_INSTALLDEVICE :
            //
            // We should not copy any INF files until the install has completed
            // like the primary INF, all secondary INF's must exist on each disk
            // of a multi-disk install.
            //

            if(!Context->PostProcessing) {
                Status = ERROR_DI_POSTPROCESSING_REQUIRED;
            } else {
                if (Context->InstallResult != NO_ERROR) {
                    DbgOut(TEXT("DIF_INSTALLDEVICE PostProcessing on failure"));
                    Status = Context->InstallResult;
                    break;
                }

                ReplaceFriendlyName(DeviceInfoSet,DeviceInfoData,NULL);
            }
            break;
        default :
            break;
    }
    return Status;
}

LPTSTR GetDIFString(IN DI_FUNCTION Func)
/*++

Routine Description:

    Given a DI_FUNCTION value, returns a text representation.

Arguments:

    Func - DI_FUNCTON value

Return Value:

    Text string if value is known.  Hex representation if not.

--*/
{
    static TCHAR buf[32];
#define MakeCase(d)  case d: return TEXT(#d)
    switch (Func)
    {
        MakeCase(DIF_SELECTDEVICE);
        MakeCase(DIF_INSTALLDEVICE);
        MakeCase(DIF_ASSIGNRESOURCES);
        MakeCase(DIF_PROPERTIES);
        MakeCase(DIF_REMOVE);
        MakeCase(DIF_FIRSTTIMESETUP);
        MakeCase(DIF_FOUNDDEVICE);
        MakeCase(DIF_SELECTCLASSDRIVERS);
        MakeCase(DIF_VALIDATECLASSDRIVERS);
        MakeCase(DIF_INSTALLCLASSDRIVERS);
        MakeCase(DIF_CALCDISKSPACE);
        MakeCase(DIF_DESTROYPRIVATEDATA);
        MakeCase(DIF_VALIDATEDRIVER);
        MakeCase(DIF_MOVEDEVICE);
        MakeCase(DIF_DETECT);
        MakeCase(DIF_INSTALLWIZARD);
        MakeCase(DIF_DESTROYWIZARDDATA);
        MakeCase(DIF_PROPERTYCHANGE);
        MakeCase(DIF_ENABLECLASS);
        MakeCase(DIF_DETECTVERIFY);
        MakeCase(DIF_INSTALLDEVICEFILES);
        MakeCase(DIF_UNREMOVE);
        MakeCase(DIF_SELECTBESTCOMPATDRV);
        MakeCase(DIF_ALLOW_INSTALL);
        MakeCase(DIF_REGISTERDEVICE);
        MakeCase(DIF_INSTALLINTERFACES);
        MakeCase(DIF_DETECTCANCEL);
        MakeCase(DIF_REGISTER_COINSTALLERS);
        MakeCase(DIF_NEWDEVICEWIZARD_FINISHINSTALL);
        MakeCase(DIF_ADDPROPERTYPAGE_ADVANCED);
        MakeCase(DIF_TROUBLESHOOTER);
        default:
            wsprintf(buf, TEXT("%x"), Func);
            return buf;
    }
}

void InitStrings(void)
{
    DWORD  dwClass, dwShare;
    TCHAR  szClass[ 40 ];

    LoadString(g_hInst, 
               INITS,
               g_szErrMem,
               CharSizeOf(g_szErrMem));
    LoadString(g_hInst, 
               IDS_INIT_NAME,
               g_szPortsApplet,
               CharSizeOf(g_szPortsApplet));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\z\cyclad-z\cyclomz.h ===
/*----------------------------------------------------------------------*
 * cyclomz.h: Cyclades-Z hardware-related definitions.					*
 *																		*
 * Copyright (C) Cyclades Corporation, 1996.							*
 * All Rights Reserved.													*
 *																		*
 * revision 1.0 03/14/95 Marcio Saito									*
 * revision 2.0 01/04/96 Marcio Saito	Changes due to HW design		*
 *										alterations.					*
 * revision 2.1 03/15/96 Marcio Saito	Changes due to HW design		*
 *										alterations.					*
 * revision 3.0	04/11/97 Ivan Passos	Changes to support the			*
 *										new boards (8Zo and Ze).		*
 *----------------------------------------------------------------------*/

/*
 *	The data types defined below are used in all ZFIRM interface
 *	data structures. They accomodate differences between HW
 *	architectures and compilers.
 */

typedef unsigned long	uclong;		/* 32 bits, unsigned */
typedef unsigned short	ucshort;	/* 16 bits, unsigned */
typedef unsigned char	ucchar;		/* 8 bits, unsigned */

/*
 *	Memory Window Sizes
 */

#define	DP_WINDOW_SIZE		(0x00080000)	/* window size 512 Kb */
#define	ZE_DP_WINDOW_SIZE	(0x00100000)	/* window size 1 Mb (for the 
											   Ze V_1 and 8Zo V_2) */
#define	CTRL_WINDOW_SIZE	(0x00000080)	/* runtime regs 128 bytes */

/*
 *	CUSTOM_REG - Cyclades-8Zo/PCI Custom Registers Set. The driver
 *	normally will access only interested on the fpga_id, fpga_version,
 *	start_cpu and stop_cpu.
 */

struct	CUSTOM_REG {
	uclong	fpga_id;			/* FPGA Identification Register */
	uclong	fpga_version;		/* FPGA Version Number Register */
	uclong	cpu_start;			/* CPU start Register (write) */
	uclong	cpu_stop;			/* CPU stop Register (write) */
	uclong	misc_reg;			/* Miscelaneous Register */
	uclong	idt_mode;			/* IDT mode Register */
	uclong	uart_irq_status;	/* UART IRQ status Register */
	uclong	clear_timer0_irq;	/* Clear timer interrupt Register */
	uclong	clear_timer1_irq;	/* Clear timer interrupt Register */
	uclong	clear_timer2_irq;	/* Clear timer interrupt Register */
	uclong	test_register;		/* Test Register */
	uclong	test_count;			/* Test Count Register */
	uclong	timer_select;		/* Timer select register */
	uclong	pr_uart_irq_status;	/* Prioritized UART IRQ stat Reg */
	uclong	ram_wait_state;		/* RAM wait-state Register */
	uclong	uart_wait_state;	/* UART wait-state Register */
	uclong	timer_wait_state;	/* timer wait-state Register */
	uclong	ack_wait_state;		/* ACK wait State Register */
};

/*
 *	CUSTOM_REG_ZE - Cyclades-Ze/PCI Custom Registers Set. The driver
 *	normally will access only interested on the fpga_id, fpga_version,
 *	start_cpu and stop_cpu.
 */

struct	CUSTOM_REG_ZE {
	uclong	fpga_id;		/* FPGA Identification Register */
	uclong	fpga_version;	/* FPGA Version Number Register */
	uclong	cpu_start;			/* CPU start Register (write) */
	uclong	cpu_stop;			/* CPU stop Register (write) */
	uclong	cpu_ctrl;
	uclong	zbus_wait;		/* Z-Bus wait states */
	uclong	timer_div;		/* Timer divider */
	uclong	timer_irq_ack;	/* Write anything to ack/clear Timer 
							   Interrupt Register */
};


/*
 *	RUNTIME_9060 - PLX PCI9060ES local configuration and shared runtime
 *	registers. This structure can be used to access the 9060 registers
 *	(memory mapped).
 */

struct RUNTIME_9060 {
	uclong	loc_addr_range;	/* 00h - Local Address Range */
	uclong	loc_addr_base;	/* 04h - Local Address Base */
	uclong	loc_arbitr;		/* 08h - Local Arbitration */
	uclong	endian_descr;	/* 0Ch - Big/Little Endian Descriptor */
	uclong	loc_rom_range;	/* 10h - Local ROM Range */
	uclong	loc_rom_base;	/* 14h - Local ROM Base */
	uclong	loc_bus_descr;	/* 18h - Local Bus descriptor */
	uclong	loc_range_mst;	/* 1Ch - Local Range for Master to PCI */
	uclong	loc_base_mst;	/* 20h - Local Base for Master PCI */
	uclong	loc_range_io;	/* 24h - Local Range for Master IO */
	uclong	pci_base_mst;	/* 28h - PCI Base for Master PCI */
	uclong	pci_conf_io;	/* 2Ch - PCI configuration for Master IO */
	uclong	filler1;		/* 30h */
	uclong	filler2;		/* 34h */
	uclong	filler3;		/* 38h */
	uclong	filler4;		/* 3Ch */
	uclong	mail_box_0;		/* 40h - Mail Box 0 */
	uclong	mail_box_1;		/* 44h - Mail Box 1 */
	uclong	mail_box_2;		/* 48h - Mail Box 2 */
	uclong	mail_box_3;		/* 4Ch - Mail Box 3 */
	uclong	filler5;		/* 50h */
	uclong	filler6;		/* 54h */
	uclong	filler7;		/* 58h */
	uclong	filler8;		/* 5Ch */
	uclong	pci_doorbell;	/* 60h - PCI to Local Doorbell */
	uclong	loc_doorbell;	/* 64h - Local to PCI Doorbell */
	uclong	intr_ctrl_stat;	/* 68h - Interrupt Control/Status */
	uclong	init_ctrl;		/* 6Ch - EEPROM control, Init Control, etc */
};

/* Values for the Local Base Address re-map register */

#define	WIN_RAM			0x00000001L	/* set the sliding window to RAM */
#define	WIN_CREG		0x14000001L	/* set the window to custom Registers */

/* Values timer select registers */

#define	TIMER_BY_1M		0x00		/* clock divided by 1M */
#define	TIMER_BY_256K	0x01		/* clock divided by 256k */
#define	TIMER_BY_128K	0x02		/* clock divided by 128k */
#define	TIMER_BY_32K	0x03		/* clock divided by 32k */

/*
 *	Starting from here, the compilation is conditional to the definition
 *	of FIRMWARE
 */

#ifdef FIRMWARE

struct RUNTIME_9060_FW {
	uclong	mail_box_0;	/* 40h - Mail Box 0 */
	uclong	mail_box_1;	/* 44h - Mail Box 1 */
	uclong	mail_box_2;	/* 48h - Mail Box 2 */
	uclong	mail_box_3;	/* 4Ch - Mail Box 3 */
	uclong	filler5;	/* 50h */
	uclong	filler6;	/* 54h */
	uclong	filler7;	/* 58h */
	uclong	filler8;	/* 5Ch */
	uclong	pci_doorbell;	/* 60h - PCI to Local Doorbell */
	uclong	loc_doorbell;	/* 64h - Local to PCI Doorbell */
	uclong	intr_ctrl_stat;	/* 68h - Interrupt Control/Status */
	uclong	init_ctrl;	/* 6Ch - EEPROM control, Init Control, etc */
};

/* Hardware related constants */

#define ZF_UART_PTR		(0xb0000000UL)
#define ZF_UART_SPACE	0x00000080UL
#define	ZF_UART_CLOCK	7372800

#define	ZO_V1_FPGA_ID	0x95
#define	ZO_V2_FPGA_ID	0x84
#define	ZE_V1_FPGA_ID	0x89

#define	ZF_TIMER_PTR	(0xb2000000UL)

#define	ZF_9060_PTR		(0xb6000000UL)
#define	ZF_9060_ZE_PTR	(0xb8000000UL)
#define	ZF_CUSTOM_PTR	(0xb4000000UL)

#define	ZF_NO_CACHE		(0xa0000000UL)
#define	ZF_CACHE		(0x80000000UL)

#define	ZF_I_TIMER		(EXT_INT0)
#define	ZF_I_SERIAL		(EXT_INT2)
#define ZF_I_HOST		(EXT_INT3)
#define	ZF_I_ALL		(EXT_INT0|EXT_INT2|EXT_INT3)
#define	ZF_I_TOTAL		(EXT_INT0|EXT_INT1|EXT_INT2|EXT_INT3|EXT_INT4|EXT_INT5)

#define	ZF_IRQ03		0xfffffffeUL
#define	ZF_IRQ05		0xfffffffdUL
#define	ZF_IRQ09		0xfffffffbUL
#define	ZF_IRQ10		0xfffffff7UL
#define	ZF_IRQ11		0xffffffefUL
#define	ZF_IRQ12		0xffffffdfUL
#define	ZF_IRQ15		0xffffffbfUL

#endif /* FIRMWARE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\z\cyclad-z\cyclad-z.c ===
/*--------------------------------------------------------------------------
*
*   Copyright (C) Cyclades Corporation, 2000-2001.
*   All rights reserved.
*
*   Cyclades-Z Enumerator Driver
*	
*   This file:      cyclad-z.c
*
*   Description:    This module contains contains the entry points 
*                   for a standard bus PNP / WDM driver.
*					
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*
*   Complies with Cyclades SW Coding Standard rev 1.3.
*
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "pch.h"

//
// Declare some entry functions as pageable, and make DriverEntry
// discardable
//

NTSTATUS DriverEntry(PDRIVER_OBJECT, PUNICODE_STRING);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, Cycladz_DriverUnload)
#endif

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING UniRegistryPath
    )
/*++
Routine Description:

    Initialize the entry points of the driver.

--*/
{
    ULONG i;
    PRTL_QUERY_REGISTRY_TABLE QueryTable = NULL;
    ULONG breakOnEntryDefault = FALSE;
    ULONG shouldBreakOnEntry = FALSE;

    UNREFERENCED_PARAMETER (UniRegistryPath);

    Cycladz_KdPrint_Def (SER_DBG_SS_TRACE, ("Driver Entry\n"));
    Cycladz_KdPrint_Def (SER_DBG_SS_TRACE, ("RegPath: %x\n", UniRegistryPath));

    //
    // Get the BreakOnEntry from the registry
    //

    if (NULL == (QueryTable = ExAllocatePool(
                         PagedPool,
                         sizeof(RTL_QUERY_REGISTRY_TABLE)*2
                          ))) {
        Cycladz_KdPrint_Def (SER_DBG_PNP_ERROR,
              ("Failed to allocate memory to query registry\n"));
    } else {
        RtlZeroMemory(
                 QueryTable,
                 sizeof(RTL_QUERY_REGISTRY_TABLE)*2
                  );

        QueryTable[0].QueryRoutine = NULL;
        QueryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        QueryTable[0].EntryContext = &shouldBreakOnEntry;
        QueryTable[0].Name      = L"BreakOnEntry";
        QueryTable[0].DefaultType   = REG_DWORD;
        QueryTable[0].DefaultData   = &breakOnEntryDefault;
        QueryTable[0].DefaultLength= sizeof(ULONG);

        // BUGBUG: The rest of the table isn't filled in!

        if (!NT_SUCCESS(RtlQueryRegistryValues(
             RTL_REGISTRY_SERVICES,
             L"cyclad-z",
             QueryTable,
             NULL,
             NULL))) {
               Cycladz_KdPrint_Def (SER_DBG_PNP_ERROR,
                   ("Failed to get BreakOnEntry level from registry.  Using default\n"));
               shouldBreakOnEntry = breakOnEntryDefault;
        }

        ExFreePool( QueryTable );
    }


    if (shouldBreakOnEntry) {
        DbgBreakPoint();
    }


    DriverObject->MajorFunction [IRP_MJ_CREATE] =
    DriverObject->MajorFunction [IRP_MJ_CLOSE]  = Cycladz_CreateClose;
    DriverObject->MajorFunction [IRP_MJ_PNP]    = Cycladz_PnP;
    DriverObject->MajorFunction [IRP_MJ_POWER]  = Cycladz_Power;
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = Cycladz_IoCtl;
    DriverObject->MajorFunction [IRP_MJ_SYSTEM_CONTROL] = Cycladz_DispatchPassThrough;
    DriverObject->DriverUnload = Cycladz_DriverUnload;
    DriverObject->DriverExtension->AddDevice = Cycladz_AddDevice;

    return STATUS_SUCCESS;
}


NTSTATUS
CycladzSyncCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                      IN PKEVENT CycladzSyncEvent)
{
   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);


   KeSetEvent(CycladzSyncEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
Cycladz_CreateClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++
Routine Description:
    Some outside source is trying to create a file against us.

    If this is for the FDO (the bus itself) then the caller is trying to
    open the propriatary conection to tell us which serial port to enumerate.

    If this is for the PDO (an object on the bus) then this is a client that
    wishes to use the serial port.
--*/
{
   PIO_STACK_LOCATION irpStack;
   NTSTATUS status;
   PFDO_DEVICE_DATA fdoData;
   KEVENT completionEvent;
   PDEVICE_OBJECT pNextDevice;


   UNREFERENCED_PARAMETER(DeviceObject);

   status = STATUS_INVALID_DEVICE_REQUEST;
   Irp->IoStatus.Information = 0;
    
   fdoData = DeviceObject->DeviceExtension;
   if (fdoData->IsFDO) {

      if (fdoData->DevicePnPState == Deleted){         
         status = STATUS_DELETE_PENDING;
      } else {

         irpStack = IoGetCurrentIrpStackLocation(Irp);

         switch (irpStack->MajorFunction) {

         case IRP_MJ_CREATE:

             Cycladz_KdPrint_Def(SER_DBG_SS_TRACE, ("Create"));
            if ((fdoData->DevicePnPState == RemovePending) || 
               (fdoData->DevicePnPState == SurpriseRemovePending)) {
               status = STATUS_DELETE_PENDING;
            } else {
               status = STATUS_SUCCESS;
            }
            break;

         case IRP_MJ_CLOSE:

            Cycladz_KdPrint_Def (SER_DBG_SS_TRACE, ("Close \n"));
            status = STATUS_SUCCESS;
            break;
         }
      }
   }

   Irp->IoStatus.Status = status;
   IoCompleteRequest (Irp, IO_NO_INCREMENT);
   return status;
}

NTSTATUS
Cycladz_IoCtl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    PCOMMON_DEVICE_DATA     commonData;
    PFDO_DEVICE_DATA        fdoData;

    Cycladz_KdPrint_Def (SER_DBG_IOCTL_TRACE, ("Cycladz_IoCtl\n"));

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_DEVICE_CONTROL == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;
    fdoData = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;

    //
    // We only take Device Control requests for the FDO.
    // That is the bus itself.

    if (!commonData->IsFDO) {
        //
        // These commands are only allowed to go to the FDO.
        //
        status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    status = Cycladz_IncIoCount (fdoData);

    if (!NT_SUCCESS (status)) {
        //
        // This bus has received the PlugPlay remove IRP.  It will no longer
        // respond to external requests.
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    // Actually, we don't handle any Ioctl.
    status = STATUS_INVALID_DEVICE_REQUEST;

    Cycladz_DecIoCount (fdoData);

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
}

VOID
Cycladz_DriverUnload (
    IN PDRIVER_OBJECT Driver
    )
/*++
Routine Description:
    Clean up everything we did in driver entry.

--*/
{
    UNREFERENCED_PARAMETER (Driver);
    PAGED_CODE();

    //
    // All the device objects should be gone.
    //

    ASSERT (NULL == Driver->DeviceObject);

    //
    // Here we free any resources allocated in DriverEntry
    //

    return;
}

NTSTATUS
Cycladz_IncIoCount (
    PFDO_DEVICE_DATA Data
    )
{
    InterlockedIncrement (&Data->OutstandingIO);
    if (Data->DevicePnPState == Deleted) {

        if (0 == InterlockedDecrement (&Data->OutstandingIO)) {
            KeSetEvent (&Data->RemoveEvent, 0, FALSE);
        }
        return STATUS_DELETE_PENDING;
    }
    return STATUS_SUCCESS;
}

VOID
Cycladz_DecIoCount (
    PFDO_DEVICE_DATA Data
    )
{
    if (0 == InterlockedDecrement (&Data->OutstandingIO)) {
        KeSetEvent (&Data->RemoveEvent, 0, FALSE);
    }
}

NTSTATUS
Cycladz_DispatchPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
Routine Description:

    Passes a request on to the lower driver.

--*/
{
    PIO_STACK_LOCATION IrpStack = 
            IoGetCurrentIrpStackLocation( Irp );

#if 1
        Cycladz_KdPrint_Def (SER_DBG_SS_TRACE, ( 
            "[Cycladz_DispatchPassThrough] "
            "IRP: %8x; "
            "MajorFunction: %d\n",
            Irp, 
            IrpStack->MajorFunction ));
#endif

    //
    // Pass the IRP to the target
    //
    IoSkipCurrentIrpStackLocation (Irp);
    
    if (((PPDO_DEVICE_DATA) DeviceObject->DeviceExtension)->IsFDO) {
        return IoCallDriver( 
            ((PFDO_DEVICE_DATA) DeviceObject->DeviceExtension)->TopOfStack,
            Irp );
    } else {
        return IoCallDriver( 
            ((PFDO_DEVICE_DATA) ((PPDO_DEVICE_DATA) DeviceObject->
                DeviceExtension)->ParentFdo->DeviceExtension)->TopOfStack,
                Irp );
    }
}           

void
Cycladz_InitPDO (
    ULONG               Index,
    PDEVICE_OBJECT      Pdo,
    PFDO_DEVICE_DATA    FdoData
    )
/*
Description:
    Common code to initialize a newly created cyclades-z pdo.
    Called either when the control panel exposes a device or when Cyclades-Z senses
    a new device was attached.

Parameters:
    Pdo - The pdo
    FdoData - The fdo's device extension
    //Exposed - Was this pdo was found by serenum (FALSE) or was it was EXPOSEd by 
    //    a control panel applet (TRUE)?        -> Removed in build 2072
*/
{

    ULONG FdoFlags = FdoData->Self->Flags;
    PPDO_DEVICE_DATA pdoData = Pdo->DeviceExtension;

    HANDLE keyHandle;
    NTSTATUS status;
    
    //
    // Check the IO style
    //
    if (FdoFlags & DO_BUFFERED_IO) {
        Pdo->Flags |= DO_BUFFERED_IO;
    } else if (FdoFlags & DO_DIRECT_IO) {
        Pdo->Flags |= DO_DIRECT_IO;
    }
    
    //
    // Increment the pdo's stacksize so that it can pass irps through
    //
    Pdo->StackSize += FdoData->Self->StackSize;
    
    //
    // Initialize the rest of the device extension
    //
    pdoData->PortIndex = Index;
    pdoData->IsFDO = FALSE;
    pdoData->Self = Pdo;
    pdoData->ParentFdo = FdoData->Self;
    pdoData->Attached = TRUE; // attached to the bus

    INITIALIZE_PNP_STATE(pdoData);

    pdoData->DebugLevel = FdoData->DebugLevel;  // Copy the debug level

    pdoData->DeviceState = PowerDeviceD0;
    pdoData->SystemState = PowerSystemWorking;

    //
    // Add the pdo to cyclades-z's list
    //

    ASSERT(FdoData->AttachedPDO[Index] == NULL);
    ASSERT(FdoData->PdoData[Index] == NULL);
//  ASSERT(FdoData->NumPDOs == 0);  rem because NumPDOs can be > 0 in cyclad-z

    FdoData->AttachedPDO[Index] = Pdo;
    FdoData->PdoData[Index] = pdoData;
    FdoData->NumPDOs++;

    Pdo->Flags &= ~DO_DEVICE_INITIALIZING;  // Moved to end in DDK final version
    Pdo->Flags |= DO_POWER_PAGABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\y\cyyports\util.c ===
/** FILE: util.c *********** Module Header ********************************
 *
 *  Ports applet utility library routines. This file contains string,
 *  cursor, SendWinIniChange() routines.
 *
 * History:
 *  15:30 on Thur  25 Apr 1991  -by-  Steve Cathcart   [stevecat]
 *        Took base code from Win 3.1 source
 *  10:30 on Tues  04 Feb 1992  -by-  Steve Cathcart   [stevecat]
 *        Updated code to latest Win 3.1 sources
 *  15:30 on Thur  03 May 1994  -by-  Steve Cathcart   [stevecat]
 *        Increased  MyMessageBox buffers, Restart dialog changes
 *  17:00 on Mon   18 Sep 1995  -by-  Steve Cathcart   [stevecat]
 *        Changes for product update - SUR release NT v4.0
 *  Nov 1997					-by-  Doron Holan	   [stevecat]
 *        Removed obsolete cpl code
 *
 *  Copyright (C) 1990-1995 Microsoft Corporation
 *
 *************************************************************************/
/* Notes -

    Global Functions:

      U T I L I T Y

        BackslashTerm () - add backslash char to path
        ErrMemDlg () - display Memory Error message box
        MyAtoi () - To convert from Unicode to ANSI string before calling atoi
        myatoi () - local implementation of atoi for Unicode strings
        MyItoa () - To convert from ANSI to Unicode string after calling itoa
        MyMessageBox () - display message to user, with parameters
        MyUltoa () - To convert from Unicode to ANSI string before calling ultoa
        SendWinIniChange () - broadcast system change message via USER
        strscan () - Find a string within another string
        StripBlanks () - Strip leading and trailing blanks from a string


    Local Functions:

 */

//==========================================================================
//                                Include files
//==========================================================================

// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

// Application specific
#include "cyyports.h"


#define INT_SIZE_LENGTH   20
#define LONG_SIZE_LENGTH  40


LPTSTR 
BackslashTerm(LPTSTR pszPath)
{
    LPTSTR pszEnd;

    pszEnd = pszPath + lstrlen(pszPath);

    //
    //  Get the end of the source directory
    //
    switch(*CharPrev(pszPath, pszEnd)) {
    case TEXT('\\'):
    case TEXT(':'):
        break;

    default:
        *pszEnd++ = TEXT('\\');
        *pszEnd = TEXT('\0');
    }

    return pszEnd;
}

void 
ErrMemDlg(HWND hParent)
{
    MessageBox(hParent, g_szErrMem, g_szPortsApplet,
               MB_OK | MB_ICONHAND | MB_SYSTEMMODAL );
}

///////////////////////////////////////////////////////////////////////////////
//
//   MyAtoi
//
//   Desc:  To convert from Unicode to ANSI string before
//          calling CRT atoi and atol functions.
//
///////////////////////////////////////////////////////////////////////////////

int 
MyAtoi(LPTSTR  string)
{
   CHAR   szAnsi[ INT_SIZE_LENGTH ];
   BOOL   fDefCharUsed;

#ifdef UNICODE
   WideCharToMultiByte(CP_ACP, 0, string, INT_SIZE_LENGTH,
                       szAnsi, INT_SIZE_LENGTH, NULL, &fDefCharUsed);

   return atoi(szAnsi);
#else
   return atoi(string);
#endif

}


int 
myatoi(LPTSTR pszInt)
{
    int   retval;
    TCHAR cSave;

    for (retval = 0; *pszInt; ++pszInt) {
        if ((cSave = (TCHAR) (*pszInt - TEXT('0'))) > (TCHAR) 9)
            break;

        retval = (int) (retval * 10 + (int) cSave);
    }
    return (retval);
}



///////////////////////////////////////////////////////////////////////////////
//
//   MyItoa
//
//   Desc:  To convert from ANSI to Unicode string after calling
//          CRT itoa function.
//
///////////////////////////////////////////////////////////////////////////////

LPTSTR 
MyItoa(INT value, LPTSTR string, INT radix)
{
   CHAR   szAnsi[INT_SIZE_LENGTH];

#ifdef UNICODE

   _itoa(value, szAnsi, radix);
   MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szAnsi, -1,
                       string, INT_SIZE_LENGTH );
#else

   _itoa(value, string, radix);

#endif

   return (string);
 
} // end of MyItoa()


LPTSTR 
MyUltoa(unsigned long value, 
		LPTSTR  string, 
		INT  radix)
{
   CHAR   szAnsi[ LONG_SIZE_LENGTH ];

#ifdef UNICODE

   _ultoa(value, szAnsi, radix);
   MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szAnsi, -1,
                       string, LONG_SIZE_LENGTH );
#else

   _ultoa(value, string, radix);

#endif

   return( string );

} // end of MyUltoa()


int 
MyMessageBox(HWND hWnd, 
			 DWORD wText, 
			 DWORD wCaption, 
			 DWORD wType, 
			 ...)
{
    TCHAR   szText[4 * PATHMAX], 
			szCaption[2 * PATHMAX];
    int     ival;
    va_list parg;

    va_start(parg, wType);

    if (wText == INITS)
        goto NoMem;

    if (!LoadString(g_hInst, wText, szCaption, CharSizeOf(szCaption)))
        goto NoMem;

    wvsprintf(szText, szCaption, parg);

    if (!LoadString(g_hInst, wCaption, szCaption, CharSizeOf(szCaption)))
        goto NoMem;

    if ((ival = MessageBox(hWnd, szText, szCaption, wType)) == 0)
        goto NoMem;

    va_end(parg);

    return ival;

NoMem:
    va_end(parg);
    ErrMemDlg(hWnd);

    return 0;
}

void 
SendWinIniChange(LPTSTR lpSection)
{
// NOTE: We have (are) gone through several iterations of which USER
//       api is the correct one to use.  The main problem for the Control
//       Panel is to avoid being HUNG if another app (top-level window)
//       is HUNG.  Another problem is that we pass a pointer to a message
//       string in our address space.  SendMessage will 'thunk' this properly
//       for each window, but PostMessage and SendNotifyMessage will not.
//       That finally brings us to try to use SendMessageTimeout(). 9/21/92
//
// Try SendNotifyMessage in build 260 or later - kills earlier builds
//    SendNotifyMessage ((HWND)-1, WM_WININICHANGE, 0L, (LONG)lpSection);
//    PostMessage ((HWND)-1, WM_WININICHANGE, 0L, (LONG)lpSection);
//  [stevecat] 4/4/92
//
//    SendMessage ((HWND)-1, WM_WININICHANGE, 0L, (LPARAM)lpSection);
//
    //  NOTE: The final parameter (LPDWORD lpdwResult) must be NULL

    SendMessageTimeout((HWND)-1, 
					   WM_WININICHANGE, 
					   0L, 
					   (WPARAM) lpSection,
					   SMTO_ABORTIFHUNG,
					   1000, 
					   NULL);
}

LPTSTR 
strscan(LPTSTR pszString, 
		LPTSTR pszTarget)
{
    LPTSTR psz;

    if (psz = _tcsstr( pszString, pszTarget))
        return (psz);
    else
        return (pszString + lstrlen(pszString));
}


///////////////////////////////////////////////////////////////////////////////
//
//  StripBlanks()
//
//   Strips leading and trailing blanks from a string.
//   Alters the memory where the string sits.
//
///////////////////////////////////////////////////////////////////////////////

void 
StripBlanks(LPTSTR pszString)
{
    LPTSTR  pszPosn;

    //
    //  strip leading blanks
    //

    pszPosn = pszString;

    while (*pszPosn == TEXT(' '))
        pszPosn++;

    if (pszPosn != pszString)
        lstrcpy(pszString, pszPosn);

    //
    //  strip trailing blanks
    //

    if ((pszPosn = pszString + lstrlen(pszString)) != pszString) {
       pszPosn = CharPrev(pszString, pszPosn);

       while (*pszPosn == TEXT(' '))
           pszPosn = CharPrev(pszString, pszPosn);

       pszPosn = CharNext(pszPosn);

       *pszPosn = TEXT('\0');
    }
}

BOOL ReadRegistryByte(HKEY       hKey,
                      PTCHAR     valueName,
                      PBYTE      regData)
{
    DWORD       regDataType = 0;
    DWORD       regDataSize = 0;

    regDataSize = sizeof(*regData);
    if ((ERROR_SUCCESS != RegQueryValueEx(hKey,
                                          valueName,
                                          NULL,
                                          &regDataType,
                                          regData,
                                          &regDataSize))
        || (regDataSize != sizeof(BYTE))
        || (regDataType != REG_BINARY))
    {
        //
        // Read was unsuccessful  or not a binary value, regData is not set
        //
        return FALSE;
    }

    //
    // Read was a success, regData contains the value read in
    //
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\z\cyclad-z\cyzguid.h ===
/*--------------------------------------------------------------------------
*
*   Copyright (C) Cyclades Corporation, 2000-2001.
*   All rights reserved.
*
*   Cyclades-Z Enumerator Driver
*   
*   This file:      cyzguid.h
*
*   Description:    Defines GUIDs for function device classes and device 
*                   events used in Plug & Play.
*                   
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*
*   Complies with Cyclades SW Coding Standard rev 1.3.
*
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#ifdef DEFINE_GUID   // don't break compiles of drivers that 
                     // include this header but don't want the
                     // GUIDs

// {E3D3A656-2E9E-44d3-BE40-A1C2C2C3DF6E}
DEFINE_GUID( GUID_BUS_TYPE_CYCLADESZ, 
             0xe3d3a656, 0x2e9e, 0x44d3, 0xbe, 0x40, 0xa1, 0xc2, 0xc2, 0xc3, 0xdf, 0x6e);

// {4C62392F-8A83-4c67-A286-2C879C3712B6}
DEFINE_GUID( GUID_CYCLADESZ_BUS_ENUMERATOR, 
             0x4c62392f, 0x8a83, 0x4c67, 0xa2, 0x86, 0x2c, 0x87, 0x9c, 0x37, 0x12, 0xb6);

#endif   // DEFINE_GUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\z\cyclad-z\cyzhw.h ===
/*--------------------------------------------------------------------------
*
*   Copyright (C) Cyclades Corporation, 2000-2001.
*   All rights reserved.
*
*   Cyclades-Z Enumerator/Port Driver
*	
*   This file:      cyzhw.h
*
*   Description:    This module contains the common hardware declarations 
*                   for the parent driver (cyclad-z) and child driver 
*                   (cyzport).
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*
*   Complies with Cyclades SW Coding Standard rev 1.3.
*
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#ifndef CYZHW_H
#define CYZHW_H


#define MAX_DEVICE_ID_LEN     200	// This definition was copied from NTDDK\inc\cfgmgr32.h
									// Always check if this value was changed. 
									// This is the maximum length for the Hardware ID.

#define CYZPORT_PNP_ID_WSTR         L"Cyclades-Z\\Port"
#define CYZPORT_PNP_ID_STR          "Cyclades-Z\\Port"
#define CYZPORT_DEV_ID_STR          "Cyclades-Z\\Port"

#ifdef POLL
#define CYZ_NUMBER_OF_RESOURCES     2     // Memory, PLX Memory
#else
#define CYZ_NUMBER_OF_RESOURCES     3     // Memory, PLX Memory, IRQ
#endif

// Cyclades-Z hardware
#define CYZ_RUNTIME_LENGTH          0x00000080
#define CYZ_MAX_PORTS	            64


#define CYZ_WRITE_ULONG(Pointer,Data)	\
WRITE_REGISTER_ULONG(Pointer,Data)

#define CYZ_WRITE_UCHAR(Pointer,Data)	\
WRITE_REGISTER_UCHAR(Pointer,Data)

#define CYZ_READ_ULONG(Pointer)			\
READ_REGISTER_ULONG(Pointer)

#define CYZ_READ_UCHAR(Pointer)			\
READ_REGISTER_UCHAR(Pointer)


#endif // endif CYZHW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\z\cyclad-z\cyzload.h ===
/*--------------------------------------------------------------------------
*
*   Copyright (C) Cyclades Corporation, 1997-2001.
*   All rights reserved.
*
*   Cyclades-Z Enumerator Driver
*	
*   This file:      cyzload.h
*
*   Description:    Cyclades-Z Firmware Loader Header
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*
*   Complies with Cyclades SW Coding Standard rev 1.3.
*
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

/* Include some standard header files.  These are used ONLY to support the
** open/close/read/write macros listed below, as well as the size_t typedef.
*/

// include of standard header files deleted for NT
//#include <stdio.h>
//#include <stdlib.h>


/*  This is an arbitrary data type that is passed to the copy functions.  It
**  serves no function inside z_load, except as a way to identify the board
**  to the copy functions.  The data type of Z_BOARD_IDENT can be changed
**  at port time to support the particular implimentation.
*/
typedef PFDO_DEVICE_DATA Z_BOARD_IDENT;

/* A standard 32 bit unsigned integer */
//removed in W2K typedef unsigned long UINT32;


/* These are some misc functions that z_load() requires.  They have been
** made into macros to help in the porting process.  These macros are
** equivalent to:
**
**  Z_STREAM *zl_open (char *path);
**  int zl_close (Z_STREAM);
**  int zl_fread (void *ptr, size_t size, int count, Z_STREAM *stream);
**  int zl_fwrite (void *ptr, size_t size, int count, Z_STREAM *stream);
**  int zl_fseek (Z_STREAM *stream, unsigned long offset);
*/
typedef HANDLE Z_STREAM;
				
#define zl_min(aaa,bbb) (((aaa)<(bbb))?(aaa):(bbb))

#ifndef NULL
#define NULL  ((void *)(0UL))
#endif

/* This defined the size of the buffer used in copying data.  This can be
** any power of two.
*/
#define ZBUF_SIZE       (256)

/* The loader can use static (read, "Permanent") buffers, or use the stack.
** Define this if the stack should be used.  If #undef'd, then permanent
** static buffers will be used.
*/
#define ZBUF_STACK

#define ZL_MAX_BLOCKS (16)

#define ZL_RET_SUCCESS					0
#define ZL_RET_NO_MATCHING_FW_CONFIG	1
#define ZL_RET_FILE_OPEN_ERROR			2
#define ZL_RET_FPGA_ERROR				3
#define ZL_RET_FILE_READ_ERROR			4

struct ZFILE_HEADER
  {
    char name[64];
	char date[32];
    char aux[32];
    UINT32 n_config;      /* The number of configurations in this file */
	UINT32 config_offset; /* The file offset to the ZFILE_CONFIG array */
    UINT32 n_blocks;      /* The number of data blocks in this file */
	UINT32 block_offset;  /* The offset for the ZFILE_BLOCK array */
	UINT32 reserved[9];   /* Reserved for future use */
  };

struct ZFILE_CONFIG
  {
	char   name[64];
    UINT32 mailbox;
    UINT32 function;
    UINT32 n_blocks;
    UINT32 block_list[ZL_MAX_BLOCKS];
  };

struct ZFILE_BLOCK
  {
    UINT32  type;
	UINT32  file_offset;
    UINT32  ram_offset;
    UINT32  size;
  };

enum ZBLOCK_TYPE {ZBLOCK_PRG, ZBLOCK_FPGA};
enum ZFUNCTION_TYPE {ZFUNCTION_NORMAL, ZFUNCTION_TEST, ZFUNCTION_DIAG};

//CYZLOAD.C 
int
z_load (
	Z_BOARD_IDENT board, 
	UINT32 function, 
	PCWSTR filename
);

VOID
z_reset_board( 
	Z_BOARD_IDENT board 
);

VOID
z_stop_cpu( 
	Z_BOARD_IDENT board
);

int
z_fpga_check(
	Z_BOARD_IDENT board 
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\z\cyclad-z\pch.h ===
#include <ntddk.h>
#include <devioctl.h>
#include <initguid.h>
#include <wdmguid.h>
#include <ntddser.h>
#include <stdarg.h>
#include <stdio.h>
#include "cyzguid.h"
#include "log.h"
#include "cyclad-z.h"
#include "cyclomz.h"
#include "zfwint.h"
#include "cyzload.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\z\cyclad-z\log.c ===
/*--------------------------------------------------------------------------
*	
*   Copyright (C) Cyclades Corporation, 1999-2001.
*   All rights reserved.
*	
*   Cyclades-Z Enumerator Driver
*	
*   This file:      log.c
*	
*   Description:    This module contains contains the entry points 
*                   for a standard bus PNP / WDM driver.
*
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*	
*   Complies with Cyclades SW Coding Standard rev 1.3.
*	
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/


#include "pch.h"

typedef enum _CYZ_MEM_COMPARES {
    AddressesAreEqual,
    AddressesOverlap,
    AddressesAreDisjoint
    } CYZ_MEM_COMPARES,*PCYZ_MEM_COMPARES;

static const PHYSICAL_ADDRESS CyzPhysicalZero = {0};

CYZ_MEM_COMPARES
CyzMemCompare(
                IN PHYSICAL_ADDRESS A,
                IN ULONG SpanOfA,
                IN PHYSICAL_ADDRESS B,
                IN ULONG SpanOfB
                )

/*++

Routine Description:

    Compare two phsical address.

Arguments:

    A - One half of the comparison.

    SpanOfA - In units of bytes, the span of A.

    B - One half of the comparison.

    SpanOfB - In units of bytes, the span of B.


Return Value:

    The result of the comparison.

--*/

{

   LARGE_INTEGER a;
   LARGE_INTEGER b;

   LARGE_INTEGER lower;
   ULONG lowerSpan;
   LARGE_INTEGER higher;

   //PAGED_CODE(); Non paged because it can be called during CyzLogError, which is no paged now.

   a = A;
   b = B;

   if (a.QuadPart == b.QuadPart) {

      return AddressesAreEqual;

   }

   if (a.QuadPart > b.QuadPart) {

      higher = a;
      lower = b;
      lowerSpan = SpanOfB;

   } else {

      higher = b;
      lower = a;
      lowerSpan = SpanOfA;

   }

   if ((higher.QuadPart - lower.QuadPart) >= lowerSpan) {

      return AddressesAreDisjoint;

   }

   return AddressesOverlap;

}


VOID
CyzLogError(
              IN PDRIVER_OBJECT DriverObject,
              IN PDEVICE_OBJECT DeviceObject OPTIONAL,
              IN PHYSICAL_ADDRESS P1,
              IN PHYSICAL_ADDRESS P2,
              IN ULONG SequenceNumber,
              IN UCHAR MajorFunctionCode,
              IN UCHAR RetryCount,
              IN ULONG UniqueErrorValue,
              IN NTSTATUS FinalStatus,
              IN NTSTATUS SpecificIOStatus,
              IN ULONG LengthOfInsert1,
              IN PWCHAR Insert1,
              IN ULONG LengthOfInsert2,
              IN PWCHAR Insert2
              )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject - A pointer to the driver object for the device.

    DeviceObject - A pointer to the device object associated with the
    device that had the error, early in initialization, one may not
    yet exist.

    P1,P2 - If phyical addresses for the controller ports involved
    with the error are available, put them through as dump data.

    SequenceNumber - A ulong value that is unique to an IRP over the
    life of the irp in this driver - 0 generally means an error not
    associated with an irp.

    MajorFunctionCode - If there is an error associated with the irp,
    this is the major function code of that irp.

    RetryCount - The number of times a particular operation has been
    retried.

    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.

    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.

    SpecificIOStatus - The IO status for a particular error.

    LengthOfInsert1 - The length in bytes (including the terminating NULL)
                      of the first insertion string.

    Insert1 - The first insertion string.

    LengthOfInsert2 - The length in bytes (including the terminating NULL)
                      of the second insertion string.  NOTE, there must
                      be a first insertion string for their to be
                      a second insertion string.

    Insert2 - The second insertion string.

Return Value:

    None.

--*/

{
   PIO_ERROR_LOG_PACKET errorLogEntry;

   PVOID objectToUse;
   SHORT dumpToAllocate = 0;
   PUCHAR ptrToFirstInsert;
   PUCHAR ptrToSecondInsert;

   //PAGED_CODE(); It can be called at raised IRQL.

   if (Insert1 == NULL) {
      LengthOfInsert1 = 0;
   }

   if (Insert2 == NULL) {
      LengthOfInsert2 = 0;
   }


   if (ARGUMENT_PRESENT(DeviceObject)) {

      objectToUse = DeviceObject;

   } else {

      objectToUse = DriverObject;

   }

   if (CyzMemCompare(
                       P1,
                       (ULONG)1,
                       CyzPhysicalZero,
                       (ULONG)1
                       ) != AddressesAreEqual) {

      dumpToAllocate = (SHORT)sizeof(PHYSICAL_ADDRESS);

   }

   if (CyzMemCompare(
                       P2,
                       (ULONG)1,
                       CyzPhysicalZero,
                       (ULONG)1
                       ) != AddressesAreEqual) {

      dumpToAllocate += (SHORT)sizeof(PHYSICAL_ADDRESS);

   }

   errorLogEntry = IoAllocateErrorLogEntry(
                                          objectToUse,
                                          (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                                  dumpToAllocate
                                                  + LengthOfInsert1 +
                                                  LengthOfInsert2)
                                          );

   if ( errorLogEntry != NULL ) {

      errorLogEntry->ErrorCode = SpecificIOStatus;
      errorLogEntry->SequenceNumber = SequenceNumber;
      errorLogEntry->MajorFunctionCode = MajorFunctionCode;
      errorLogEntry->RetryCount = RetryCount;
      errorLogEntry->UniqueErrorValue = UniqueErrorValue;
      errorLogEntry->FinalStatus = FinalStatus;
      errorLogEntry->DumpDataSize = dumpToAllocate;

      if (dumpToAllocate) {

         RtlCopyMemory(
                      &errorLogEntry->DumpData[0],
                      &P1,
                      sizeof(PHYSICAL_ADDRESS)
                      );

         if (dumpToAllocate > sizeof(PHYSICAL_ADDRESS)) {

            RtlCopyMemory(
                         ((PUCHAR)&errorLogEntry->DumpData[0])
                         +sizeof(PHYSICAL_ADDRESS),
                         &P2,
                         sizeof(PHYSICAL_ADDRESS)
                         );

            ptrToFirstInsert =
            ((PUCHAR)&errorLogEntry->DumpData[0])+(2*sizeof(PHYSICAL_ADDRESS));

         } else {

            ptrToFirstInsert =
            ((PUCHAR)&errorLogEntry->DumpData[0])+sizeof(PHYSICAL_ADDRESS);


         }

      } else {

         ptrToFirstInsert = (PUCHAR)&errorLogEntry->DumpData[0];

      }

      ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

      if (LengthOfInsert1) {

         errorLogEntry->NumberOfStrings = 1;
         errorLogEntry->StringOffset = (USHORT)(ptrToFirstInsert -
                                                (PUCHAR)errorLogEntry);
         RtlCopyMemory(
                      ptrToFirstInsert,
                      Insert1,
                      LengthOfInsert1
                      );

         if (LengthOfInsert2) {

            errorLogEntry->NumberOfStrings = 2;
            RtlCopyMemory(
                         ptrToSecondInsert,
                         Insert2,
                         LengthOfInsert2
                         );

         }

      }

      IoWriteErrorLogEntry(errorLogEntry);

   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\z\cyclad-z\log.h ===
/*--------------------------------------------------------------------------
*
*   Copyright (C) Cyclades Corporation, 1997-2000.
*   All rights reserved.
*
*   Cyclades-Z Enumerator Driver
*	
*   This file:      log.mc
*
*   Description:    Messages that goes to the eventlog.
*
*   Notes:          This code supports Windows 2000 and i386 processor.
*
*   Complies with Cyclades SW Coding Standard rev 1.3.
*
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*   Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#ifndef _LOG_
#define _LOG_

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: CYZ_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Not enough resources were available for the driver.
//
#define CYZ_INSUFFICIENT_RESOURCES       ((NTSTATUS)0xC0041000L)

//
// MessageId: CYZ_BOARD_NOT_MAPPED
//
// MessageText:
//
//  The Board Memory could not be translated to something the memory management system could understand.
//
#define CYZ_BOARD_NOT_MAPPED             ((NTSTATUS)0xC0041001L)

//
// MessageId: CYZ_RUNTIME_NOT_MAPPED
//
// MessageText:
//
//  The Runtime Registers could not be translated to something the memory management system could understand.
//
#define CYZ_RUNTIME_NOT_MAPPED           ((NTSTATUS)0xC0041002L)

//
// MessageId: CYZ_INVALID_RUNTIME_REGISTERS
//
// MessageText:
//
//  Invalid Runtime Registers base address.
//
#define CYZ_INVALID_RUNTIME_REGISTERS    ((NTSTATUS)0xC0041003L)

//
// MessageId: CYZ_INVALID_BOARD_MEMORY
//
// MessageText:
//
//  Invalid Board Memory address.
//
#define CYZ_INVALID_BOARD_MEMORY         ((NTSTATUS)0xC0041004L)

//
// MessageId: CYZ_INVALID_INTERRUPT
//
// MessageText:
//
//  Invalid Interrupt Vector.
//
#define CYZ_INVALID_INTERRUPT            ((NTSTATUS)0xC0041005L)

//
// MessageId: CYZ_UNKNOWN_BUS
//
// MessageText:
//
//  The bus type is not recognizable.
//
#define CYZ_UNKNOWN_BUS                  ((NTSTATUS)0xC0041006L)

//
// MessageId: CYZ_BUS_NOT_PRESENT
//
// MessageText:
//
//  The bus type is not available on this computer.
//
#define CYZ_BUS_NOT_PRESENT              ((NTSTATUS)0xC0041007L)

//
// MessageId: CYZ_FILE_OPEN_ERROR
//
// MessageText:
//
//  Error opening the zlogic.cyz file.
//
#define CYZ_FILE_OPEN_ERROR              ((NTSTATUS)0xC0041008L)

//
// MessageId: CYZ_FILE_READ_ERROR
//
// MessageText:
//
//  Error reading the zlogic.cyz file.
//
#define CYZ_FILE_READ_ERROR              ((NTSTATUS)0xC0041009L)

//
// MessageId: CYZ_NO_MATCHING_FW_CONFIG
//
// MessageText:
//
//  No matching configuration in the zlogic.cyz file.
//
#define CYZ_NO_MATCHING_FW_CONFIG        ((NTSTATUS)0xC004100AL)

//
// MessageId: CYZ_FPGA_ERROR
//
// MessageText:
//
//  Error initializing the FPGA.
//
#define CYZ_FPGA_ERROR                   ((NTSTATUS)0xC004100BL)

//
// MessageId: CYZ_POWER_SUPPLY
//
// MessageText:
//
//  External power supply needed for Serial Expanders.
//
#define CYZ_POWER_SUPPLY                 ((NTSTATUS)0xC004100CL)

//
// MessageId: CYZ_FIRMWARE_NOT_STARTED
//
// MessageText:
//
//  Cyclades-Z firmware not able to start.
//
#define CYZ_FIRMWARE_NOT_STARTED         ((NTSTATUS)0xC004100DL)

//
// MessageId: CYZ_FIRMWARE_VERSION
//
// MessageText:
//
//  Cyclades-Z firmware version: %2.
//
#define CYZ_FIRMWARE_VERSION             ((NTSTATUS)0x4004100EL)

//
// MessageId: CYZ_INCOMPATIBLE_FIRMWARE
//
// MessageText:
//
//  Cyclades-Z incompatible firmware version.
//
#define CYZ_INCOMPATIBLE_FIRMWARE        ((NTSTATUS)0xC004100FL)

//
// MessageId: CYZ_BOARD_WITH_NO_PORT
//
// MessageText:
//
//  Cyclades-Z board with no ports.
//
#define CYZ_BOARD_WITH_NO_PORT           ((NTSTATUS)0xC0041010L)

//
// MessageId: CYZ_BOARD_WITH_TOO_MANY_PORTS
//
// MessageText:
//
//  Cyclades-Z board with more than 64 ports attached.
//
#define CYZ_BOARD_WITH_TOO_MANY_PORTS    ((NTSTATUS)0xC0041011L)

//
// MessageId: CYZ_DEVICE_CREATION_FAILURE
//
// MessageText:
//
//  IoCreateDevice failed.
//
#define CYZ_DEVICE_CREATION_FAILURE      ((NTSTATUS)0xC0041012L)

//
// MessageId: CYZ_REGISTER_INTERFACE_FAILURE
//
// MessageText:
//
//  IoRegisterDeviceInterface failed.
//
#define CYZ_REGISTER_INTERFACE_FAILURE   ((NTSTATUS)0xC0041013L)

//
// MessageId: CYZ_GET_UINUMBER_FAILURE
//
// MessageText:
//
//  IoGetDeviceProperty DevicePropertyUINumber failed.
//
#define CYZ_GET_UINUMBER_FAILURE         ((NTSTATUS)0x80041014L)

//
// MessageId: CYZ_SET_INTERFACE_STATE_FAILURE
//
// MessageText:
//
//  IoSetDeviceInterfaceState failed.
//
#define CYZ_SET_INTERFACE_STATE_FAILURE  ((NTSTATUS)0xC0041015L)


#endif /* _LOG_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\z\cyclad-z\cyzload.c ===
/*--------------------------------------------------------------------------
*
*   Copyright (C) Cyclades Corporation, 1997-2001.
*   All rights reserved.
*
*   Cyclades-Z Enumerator Driver
*	
*   This file:      cyzload.c
*
*   Description:    This is the firmware loader for the Cyclades-Z series
*                   of multiport serial cards.
*					
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*
*   Complies with Cyclades SW Coding Standard rev 1.3.
*
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*
*
*--------------------------------------------------------------------------
*/

#include "pch.h"


/*-------------------------------
*
*	Prototypes
*
*--------------------------------
*/

ULONG	
z_ident( Z_BOARD_IDENT board );

VOID
z_block_copy( Z_BOARD_IDENT board, PVOID ptr, ULONG offset, ULONG size );

VOID 
z_fpga_copy( Z_BOARD_IDENT board, PVOID ptr, ULONG size );

VOID
z_start_cpu( Z_BOARD_IDENT board );

//VOID
//z_stop_cpu( 
//	Z_BOARD_IDENT board
//);
//
//int
//z_fpga_check(
//	Z_BOARD_IDENT board 
//);
//
//VOID
//z_reset_board( Z_BOARD_IDENT board );


HANDLE
zl_fopen( PCWSTR file_name );

VOID
zl_fclose( IN Z_STREAM NtFileHandle );

ULONG 	
zl_fread( IN PVOID ptr, 
		  IN ULONG size,
	   	  IN ULONG count,
	   	  IN Z_STREAM stream,
	   	  IN ULONG Uoffset );
		  
VOID		  
zl_delay( LONG number_of_ms );
		  

#ifdef CHANGE_FOR_Z
//#ifdef ALLOC_PRAGMA
//#pragma alloc_text(INIT,z_load)
//#pragma alloc_text(INIT,z_ident)
//#pragma alloc_text(INIT,z_block_copy)
//#pragma alloc_text(INIT,z_fpga_copy)
//#pragma alloc_text(INIT,z_start_cpu)
//#pragma alloc_text(INIT,zl_fopen)
//#pragma alloc_text(INIT,zl_fclose)
//#pragma alloc_text(INIT,zl_fread)
//#pragma alloc_text(INIT,zl_delay)
//#ifdef RESET_BOARD
//#pragma alloc_text(PAGESER,z_reset_board)
//#else
//#pragma alloc_text(INIT,z_reset_board)
//#endif
//#pragma alloc_text(PAGESER,z_fpga_check)
//#pragma alloc_text(PAGESER,z_stop_cpu)
//#endif
#endif

#ifndef ZBUF_STACK
static struct ZFILE_HEADER header;
static struct ZFILE_CONFIG config;
static struct ZFILE_BLOCK  block;
static char data[ZBUF_SIZE];
#endif



/*------------------------------------------------------------------------
*
*	z_load( IN Z_BOARD_IDENT board,
*		  	IN UINT32 function,
*			IN PCWSTR filename )
*
*-------------------------------------------------------------------------
*
*	Description: Loads the Cyclades-Z Firmware. Returns a non-zero on error.
*
*-------------------------------------------------------------------------
*/
int
z_load (
	Z_BOARD_IDENT board, UINT32 function, PCWSTR filename)
{

	unsigned long 	i;
	unsigned long	dpmem;
	unsigned long 	count;
	Z_STREAM 		file;
	//*********************
	//size_t 		s, s2;
	//*********************
	unsigned long	s,s2;
	unsigned long	mailbox;
	unsigned long	load_fpga_flag = TRUE;
	unsigned long	first_time = TRUE;


#ifdef ZBUF_STACK
	struct ZFILE_HEADER header;
	struct ZFILE_CONFIG config;
	struct ZFILE_BLOCK  block;
	char data[ZBUF_SIZE];
#endif

	mailbox = z_ident(board);

	file = zl_fopen (filename);

	if (file!=NULL)
	{
		/* Read the header */
		zl_fread (&header, sizeof(header), 1, file, 0);

		/* Find the correct configuration */
		for (i=0; i<header.n_config; i++)
		{
			zl_fread (&config, sizeof(config), 1, file,
					  header.config_offset + (sizeof(config)*i));

			if (config.mailbox==mailbox && config.function==function)
				break;
		}

		/* Return error:  No matching configuration */
		if (i>=header.n_config)
		{
			zl_fclose (file);
			return (ZL_RET_NO_MATCHING_FW_CONFIG);
		}

#ifndef DEBUG_LOAD
		if ((mailbox == 0) || (z_fpga_check(board))) {
		    load_fpga_flag = FALSE;
			z_stop_cpu(board);
		}
#endif		

#ifdef RESET_BOARD
		load_fpga_flag = TRUE;
		/* Reset the board */
		z_reset_board (board);
#endif		

		/* Load each block */
		for (i=0; i<config.n_blocks; i++)
		{
				
			/* Load block struct */
			zl_fread (&block, sizeof(block), 1, file,
				header.block_offset+(sizeof(block)*config.block_list[i]));

			/* Load and Copy the data block */
			count=0;
			s = block.size;
			while (s>0)
			{			
				s2 = zl_min(ZBUF_SIZE,s);
				if (zl_fread (data, 1, s2, file, block.file_offset + count)!=0) {

					/* Call the copy function */
					if (block.type==ZBLOCK_FPGA) {
						if (load_fpga_flag) {
							z_fpga_copy (board, data, s2);
						}
					} else {
						if (first_time) {
							CYZ_WRITE_ULONG(&((board->Runtime)->loc_addr_base),
											WIN_RAM);
							//Code added to debug pentium II
							//RtlFillMemory( (PUCHAR)board->BoardMemory, 
							//				board->DPMemSize, 0x00 );
												
							for (dpmem=0; dpmem<board->BoardMemoryLength; dpmem++) {
								CYZ_WRITE_UCHAR(board->BoardMemory+dpmem,0x00);
							}
							first_time = FALSE;
						}
						z_block_copy (board, data, block.ram_offset + count, s2);
					}
					count += s2;
					s -= s2;
				} else {
					zl_fclose (file);
					return (ZL_RET_FILE_READ_ERROR);
				}
			} // end for (reading every ZBUF_SIZE)
			
			if (block.type==ZBLOCK_FPGA) {
				/* Delay for around for 1ms */
				zl_delay(1); /* Is this needed? */
				
				if (!z_fpga_check(board)) {
					zl_fclose(file);
					return(ZL_RET_FPGA_ERROR);
				}
			}
		} // end for (reading every block)
		zl_fclose (file);

		z_start_cpu(board);

		return (ZL_RET_SUCCESS);

	} else {
	
		/* Return error:  Error opening file */
		return (ZL_RET_FILE_OPEN_ERROR);
	}
}


/*------------------------------------------------------------------------
*
*	z_ident( IN Z_BOARD_IDENT board )
*
*-------------------------------------------------------------------------
*
*	Description: Returns the ID number (the mailbox reg)
*
*-------------------------------------------------------------------------
*/
ULONG	
z_ident( Z_BOARD_IDENT board )
{
	ULONG mailbox;

	mailbox = CYZ_READ_ULONG(&(board->Runtime)->mail_box_0);

	return (mailbox);
}


/*------------------------------------------------------------------------
*
*	z_reset_board( IN Z_BOARD_IDENT board )
*
*-------------------------------------------------------------------------
*
*	Description: Resets the board using the PLX registers.
*
*-------------------------------------------------------------------------
*/
VOID
z_reset_board( Z_BOARD_IDENT board )
{

	ULONG sav_buf[12];
	PULONG loc_reg;
	ULONG j;
	ULONG init_ctrl;
	LARGE_INTEGER d100ms = RtlConvertLongToLargeInteger(-100*10000);

	// Prepare board for reset.
	// The PLX9060 seems to destroy the local registers
	// when there is a hard reset. So, we save all
	// important registers before resetting the board.

	loc_reg = (ULONG *) board->Runtime;
	for (j=0; j<12; j++) {
		sav_buf[j] = CYZ_READ_ULONG(&loc_reg[j]);
	}

	// Reset board

	init_ctrl = CYZ_READ_ULONG(&(board->Runtime)->init_ctrl);
	init_ctrl |= 0x40000000;
	CYZ_WRITE_ULONG(&(board->Runtime)->init_ctrl,init_ctrl);
	KeDelayExecutionThread(KernelMode,FALSE,&d100ms);
	init_ctrl &= ~(0x40000000);
	CYZ_WRITE_ULONG(&(board->Runtime)->init_ctrl,init_ctrl);
	KeDelayExecutionThread(KernelMode,FALSE,&d100ms);
	
	// Restore loc conf registers

	for (j=0; j<12; j++) {
		CYZ_WRITE_ULONG(&loc_reg[j],sav_buf[j]);
	}
}


/*------------------------------------------------------------------------
*
*	z_block_copy( IN Z_BOARD_IDENT board,
*				  IN PVOID ptr,
*				  IN ULONG offset,
*				  IN ULONG size )
*
*-------------------------------------------------------------------------
*
*	Description: This function should copy size bytes of data from the 
*	buffer pointed to by ptr into the Cyclades-Z's memory starting at 
*	offset.
*
*-------------------------------------------------------------------------
*/

VOID
z_block_copy (Z_BOARD_IDENT board, PVOID ptr, ULONG offset, ULONG size)
{
//Code added to debug Pentium II
//	RtlCopyMemory( (PUCHAR)board->BoardMemory + offset, ptr, size );


	ULONG numOfLongs;
	ULONG numOfBytes;

	numOfLongs = size/sizeof(ULONG);
	numOfBytes = size%sizeof(ULONG);

	while (numOfLongs--) {

		CYZ_WRITE_ULONG((PULONG)(board->BoardMemory + offset), *((PULONG)ptr));
		//offset++;
		offset += sizeof(ULONG);
		((PULONG)ptr)++;
	}

	while (numOfBytes--) {

		CYZ_WRITE_UCHAR((PUCHAR)board->BoardMemory + offset, *((PUCHAR)ptr));
		offset++;
		((PUCHAR)ptr)++;
	}
}


/*------------------------------------------------------------------------
*
*	z_fpga_copy( IN Z_BOARD_IDENT board,
*				 IN PVOID ptr,
*				 IN ULONG size )
*
*-------------------------------------------------------------------------
*
*	Description: This function is the same as z_block_copy, except the 
*	offset is assumed to always be zero (and not increment) and the copy
*	is done one byte at a time. Essentially, this is the same as writing
*	a buffer to a byte-wide FIFO.
*
*-------------------------------------------------------------------------
*/

VOID
z_fpga_copy  (Z_BOARD_IDENT board, PVOID ptr, ULONG size)
{
	int i;
	char *data;
	char *fpga;

	fpga = board->BoardMemory;
	data = (char *)ptr;

	while (size>0)
	{
		CYZ_WRITE_UCHAR(fpga,*data);

		KeStallExecutionProcessor(10);	// wait 10 microseconds
		
		size--;
		data++;
	}

}


/*------------------------------------------------------------------------
*
*	z_fpga_check( IN Z_BOARD_IDENT board )
*
*-------------------------------------------------------------------------
*
*	Description: Returns 1 if FPGA is configured.
*
*-------------------------------------------------------------------------
*/
int
z_fpga_check( Z_BOARD_IDENT board )
{	
	if (CYZ_READ_ULONG(&(board->Runtime)->init_ctrl) & 0x00020000) {
			
		return 1;
		
	} else {
		
		return 0;
	}
}


/*------------------------------------------------------------------------
*
*	z_start_cpu( IN Z_BOARD_IDENT board )
*
*-------------------------------------------------------------------------
*
*	Description: Starts CPU.
*
*-------------------------------------------------------------------------
*/
VOID
z_start_cpu( Z_BOARD_IDENT board )
{
	
	CYZ_WRITE_ULONG(&(board->Runtime)->loc_addr_base,WIN_CREG);

	CYZ_WRITE_ULONG(&((struct CUSTOM_REG *) board->BoardMemory)->cpu_start,
													0x00000000);

	CYZ_WRITE_ULONG(&(board->Runtime)->loc_addr_base,WIN_RAM);

}


/*------------------------------------------------------------------------
*
*	z_stop_cpu( IN Z_BOARD_IDENT board )
*
*-------------------------------------------------------------------------
*
*	Description: Stops CPU.
*
*-------------------------------------------------------------------------
*/
VOID
z_stop_cpu( Z_BOARD_IDENT board )
{
	
	CYZ_WRITE_ULONG(&(board->Runtime)->loc_addr_base,WIN_CREG);

	CYZ_WRITE_ULONG(&((struct CUSTOM_REG *) board->BoardMemory)->cpu_stop,
													0x00000000);

	CYZ_WRITE_ULONG(&(board->Runtime)->loc_addr_base,WIN_RAM);

}


/****************************************************************
*
*	In David's code, the below functions were macros.
*
*****************************************************************/

/*------------------------------------------------------------------------
*
*	zl_fopen(PCWSTR file_name)
*
*-------------------------------------------------------------------------
*
*	Description: This routine opens a file, and returns the file handle
*	if successful. Otherwise, it returns NULL.
*
*-------------------------------------------------------------------------
*/

HANDLE zl_fopen( PCWSTR file_name )
{
	UNICODE_STRING fileName;
	NTSTATUS ntStatus;
	IO_STATUS_BLOCK IoStatus;
	HANDLE NtFileHandle;
	OBJECT_ATTRIBUTES ObjectAttributes;
	ULONG LengthOfFile;
	//WCHAR PathPrefix[] = L"\\SystemRoot\\system32\\drivers\\";
	WCHAR PathPrefix[] = L"\\SystemRoot\\system32\\cyclad-z\\";
	UNICODE_STRING FullFileName;
	ULONG FullFileNameLength;
	FILE_STANDARD_INFORMATION StandardInfo;


	RtlInitUnicodeString( &fileName, file_name );

	FullFileNameLength = sizeof(PathPrefix) + fileName.MaximumLength;

	FullFileName.Buffer = ExAllocatePool (NonPagedPool,FullFileNameLength);

	if (FullFileName.Buffer == NULL) {
		return NULL;
	}

	FullFileName.Length = sizeof(PathPrefix) - sizeof(WCHAR);
	FullFileName.MaximumLength = (USHORT)FullFileNameLength;
	RtlMoveMemory (FullFileName.Buffer, PathPrefix, sizeof(PathPrefix));
	RtlAppendUnicodeStringToString (&FullFileName, &fileName);

	InitializeObjectAttributes ( &ObjectAttributes,
								 &FullFileName,
								 OBJ_CASE_INSENSITIVE,
								 NULL,
								 NULL );

	ntStatus = ZwCreateFile( &NtFileHandle,
							 SYNCHRONIZE | FILE_READ_DATA,
							 &ObjectAttributes,
							 &IoStatus,
							 NULL,  // alloc size = none
							 FILE_ATTRIBUTE_NORMAL,
							 FILE_SHARE_READ,
							 FILE_OPEN,
							 FILE_SYNCHRONOUS_IO_NONALERT,
							 NULL,  // eabuffer
							 0 );   // ealength

	if ( !NT_SUCCESS( ntStatus ) )
	 {
		  ExFreePool(FullFileName.Buffer);
		  return NULL;
	 }

	ExFreePool(FullFileName.Buffer);

	//
	// Query the object to determine its length.
	//

	ntStatus = ZwQueryInformationFile( NtFileHandle,
									   &IoStatus,
									   &StandardInfo,
									   sizeof(FILE_STANDARD_INFORMATION),
									   FileStandardInformation );

 	if (!NT_SUCCESS(ntStatus)) {

		  ZwClose( NtFileHandle );
		  return NULL;
	}

	LengthOfFile = StandardInfo.EndOfFile.LowPart;

	//
	// Might be corrupted.
	//

	if( LengthOfFile < 1 )
	{
		  ZwClose( NtFileHandle );
		  return NULL;
	}

	return NtFileHandle;

}


/*------------------------------------------------------------------------
*
*	zl_fclose(IN Z_STREAM NtFileHandle)
*
*-------------------------------------------------------------------------
*
*	Description: This routine closes a file.
*
*-------------------------------------------------------------------------
*/
VOID zl_fclose(IN Z_STREAM NtFileHandle)
{
	ZwClose(NtFileHandle);
}


/*------------------------------------------------------------------------
*
*	zl_fread( IN PVOID ptr,
*			  IN ULONG size,
*			  IN ULONG count,
*			  IN Z_STREAM stream,
*			  IN ULONG Uoffset
*
*-------------------------------------------------------------------------
*
*	Description: This routine opens a file, and returns the file handle
*	if successful. Otherwise, it returns NULL.
*
*-------------------------------------------------------------------------
*/
ULONG zl_fread( IN PVOID ptr,
				IN ULONG size,
				IN ULONG count,
				IN Z_STREAM stream,
				IN ULONG Uoffset)
{
	IO_STATUS_BLOCK IoStatus;
	LARGE_INTEGER Loffset;
	NTSTATUS ntStatus;
	ULONG	readsize;

	readsize = size*count;
	Loffset = RtlConvertUlongToLargeInteger(Uoffset);

	ntStatus = ZwReadFile (stream, NULL, NULL, NULL, &IoStatus, 
						   ptr, readsize, &Loffset, NULL);
											
	if( (!NT_SUCCESS(ntStatus)) || (IoStatus.Information != readsize) )
	 {
		return 0;
	 }
	return readsize;
}			   


/*------------------------------------------------------------------------
*
*	zl_delay( number_of_ms )
*		
*-------------------------------------------------------------------------
*
*	Description: Delay of milliseconds.
*
*-------------------------------------------------------------------------
*/
VOID		  
zl_delay( 
LONG number_of_ms 
)
{
	LARGE_INTEGER delaytime;
	
	delaytime = RtlConvertLongToLargeInteger(-number_of_ms*10000);
	
	KeDelayExecutionThread(KernelMode,FALSE,&delaytime);

}


/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/****************************************************************************/


#if 0
//*******************************************************************
//
//	Added for debug
//
//*******************************************************************
int
z_verify (
	Z_BOARD_IDENT board, UINT32 function, PCWSTR filename)
{

	unsigned long	i;
	unsigned long	count;
	Z_STREAM 		file;
	//*********************
	//size_t   		s, s2;
	//*********************
	long			s,s2;
	unsigned long 	mailbox;


#ifdef ZBUF_STACK
	struct ZFILE_HEADER header;
	struct ZFILE_CONFIG config;
	struct ZFILE_BLOCK  block;
	char data[ZBUF_SIZE];
#endif

	maibox = z_ident(board);

	file = zl_fopen (filename);

	if (file!=NULL)
	{
		/* Read the header */
		zl_fread (&header, sizeof(header), 1, file, 0);

		/* Find the correct configuration */
		for (i=0; i<header.n_config; i++)
		{
			zl_fread (&config, sizeof(config), 1, file,
						  header.config_offset + (sizeof(config)*i));

			if (config.mailbox==mailbox && config.function==function)
				break;
		}

		/* Return error:  No matching configuration */
		if (i>=header.n_config)
		{
			zl_fclose (file);
			return (ZL_RET_NO_MATCHING_FW_CONFIG);
		}

		/* Load each block */
		for (i=0; i<config.n_blocks; i++)
		{
			/* Load block struct */
			zl_fread (&block, sizeof(block), 1, file,
				header.block_offset+(sizeof(block)*config.block_list[i]));

			/* Load and Copy the data block */
			count=0;

			for (s=block.size; s>0; s-=ZBUF_SIZE)
			{
				s2 = zl_min(ZBUF_SIZE,s);
				if (zl_fread (data, 1, s2, file, block.file_offset + count)!=0) {

					/* Call the copy function */
					if (block.type==ZBLOCK_FPGA)
						z_fpga_copy (board, data, s2);
					else {
						if (z_block_comp (board, data, block.ram_offset + count,
							s2)==0){
						zl_fclose(file);
						return (3);
						}
					}
					count += s2;
				} else {
					zl_fclose (file);
					return (3);
				}
			} // end for
		} // end for

		zl_fclose (file);
		return (0);

	} else {
		/* Return error:  Error opening file */
		return (2);
	}
}

ULONG
z_block_comp (Z_BOARD_IDENT board, PVOID ptr, UINT32 offset, long size)
{
	return (RtlCompareMemory( (PUCHAR)board->BoardMemory + offset, ptr, size ));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\z\cyclad-z\enum.c ===
/*--------------------------------------------------------------------------
*
*   Copyright (C) Cyclades Corporation, 2000-2001.
*   All rights reserved.
*
*   Cyclades-Z Enumerator Driver
*	
*   This file:      enum.c
*
*   Description:    This module contains the enumeration code needed 
*                   to figure out whether or not a device is attached 
*                   to the serial port.  If there is one, it will obtain 
*                   the PNP COM ID (if the device is PNP) and parse out 
*                   the relevant fields.
*					
*   Notes:			This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*
*   Complies with Cyclades SW Coding Standard rev 1.3.
*
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "pch.h"

#define MAX_DEVNODE_NAME        256 // Total size of Device ID


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESENM, Cycladz_ReenumerateDevices)

//#pragma alloc_text (PAGE, Cycladz_GetRegistryKeyValue)
#endif

#if !defined(__isascii)
#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#endif // !defined(__isascii)

NTSTATUS
Cycladz_ReenumerateDevices(IN PIRP Irp, IN PFDO_DEVICE_DATA FdoData)
/*++

Routine Description:

    This enumerates the cyclades-z bus which is represented by Fdo (a pointer
    to the device object representing the cyclades-z bus). It creates new PDOs
    for any new devices which have been discovered since the last enumeration

Arguments:

    FdoData - Pointer to the fdo's device extension
              for the serial bus which needs to be enumerated
    Irp - Pointer to the Irp which was sent to reenumerate.

Return value:

    NTSTATUS

--*/
{
   PIRP NewIrp;
   NTSTATUS status = STATUS_SUCCESS;
   KEVENT event;
   KTIMER timer;

   IO_STATUS_BLOCK IoStatusBlock;
   UNICODE_STRING pdoUniName;
   UNICODE_STRING instanceStr;
   WCHAR instanceNumberBuffer[20];
   static ULONG currentInstance = 0;
//   PDEVICE_OBJECT pdo = FdoData->AttachedPDO;
   PDEVICE_OBJECT pdo;
   PPDO_DEVICE_DATA pdoData;

   UNICODE_STRING HardwareIDs;
   UNICODE_STRING CompIDs;
   UNICODE_STRING DeviceIDs;
   UNICODE_STRING DevDesc;
   UNICODE_STRING InstanceIDs;

   ULONG i;

   WCHAR pdoName[] = CYZ_PDO_NAME_BASE;

   ULONG FdoFlags = FdoData->Self->Flags;

   ULONG numPorts = FdoData->NumPorts;

   UNREFERENCED_PARAMETER (Irp);

   PAGED_CODE();


   // Cyclades-Z port enumeration

//************************************************************************
// HARDCODE NUMBER OF PORTS TO 1
// numPorts = 1;
//************************************************************************

   Cycladz_KdPrint(FdoData,SER_DBG_CYCLADES,("numPorts detected = %d\n",numPorts));

   if (numPorts < FdoData->NumPDOs) {
      for (i=numPorts; i < CYZ_MAX_PORTS; i++) {
         pdo = FdoData->AttachedPDO[i];
         if (pdo != NULL) {
            // Something was there. The device must have been unplugged.
            // Remove the PDO.
            Cycladz_PDO_EnumMarkMissing(FdoData, pdo->DeviceExtension);
         }
      }
      goto ExitReenumerate;
   }

   if (numPorts == FdoData->NumPDOs) {
      // All ports already enumerated.
      Cycladz_KdPrint(FdoData,SER_DBG_CYCLADES,("All ports already enumerated\n",numPorts));
      goto ExitReenumerate;
   }


   // New ports that need to be enumerated.

   RtlZeroMemory(&pdoUniName,sizeof(UNICODE_STRING));
   pdoUniName.MaximumLength = DEVICE_OBJECT_NAME_LENGTH * sizeof(WCHAR);
   pdoUniName.Buffer = ExAllocatePool(PagedPool,pdoUniName.MaximumLength
                                    + sizeof(WCHAR));
   if (pdoUniName.Buffer == NULL) {
      Cycladz_KdPrint(FdoData,SER_DBG_CYCLADES,("Couldn't allocate memory for device name\n"));
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto ExitReenumerate; 
   }


   for (i=FdoData->NumPDOs; numPorts && (i< CYZ_MAX_PORTS); i++) {
      
      UCHAR          RawString[MAX_DEVICE_ID_LEN];
      ANSI_STRING    AnsiString;


      RtlZeroMemory(pdoUniName.Buffer,pdoUniName.MaximumLength);
      pdoUniName.Length = 0;
      RtlAppendUnicodeToString(&pdoUniName,pdoName);
      RtlInitUnicodeString(&instanceStr, NULL);
      instanceStr.MaximumLength = sizeof(instanceNumberBuffer);
      instanceStr.Buffer = instanceNumberBuffer;
      RtlIntegerToUnicodeString(currentInstance++, 10, &instanceStr);
      RtlAppendUnicodeStringToString(&pdoUniName, &instanceStr);


      //
      // Allocate a pdo
      //
      status = IoCreateDevice(FdoData->Self->DriverObject,
                              sizeof(PDO_DEVICE_DATA), &pdoUniName,
                              FILE_DEVICE_UNKNOWN,
                              FILE_AUTOGENERATED_DEVICE_NAME, FALSE, &pdo);

      if (!NT_SUCCESS(status)) {
         Cycladz_KdPrint(FdoData, SER_DBG_SS_ERROR, ("Create device failed\n"));
         ExFreePool(pdoUniName.Buffer);
         goto ExitReenumerate; 
      }

      Cycladz_KdPrint(FdoData, SER_DBG_SS_TRACE,
                      ("Created PDO on top of filter: %x\n",pdo));

      pdoData = pdo->DeviceExtension;
         

      RtlInitUnicodeString(&pdoData->HardwareIDs, NULL);
      RtlInitUnicodeString(&pdoData->CompIDs, NULL);
      RtlInitUnicodeString(&pdoData->DeviceIDs, NULL);
      RtlInitUnicodeString(&pdoData->DevDesc, NULL);
      RtlInitUnicodeString(&pdoData->InstanceIDs,NULL);


      // Hardware ID
      sprintf((PCHAR)RawString,"%s%u",CYZPORT_PNP_ID_STR,i+1); // Cyclades-Z\\Port1, etc
      Cycladz_InitMultiString(FdoData, &pdoData->HardwareIDs, RawString, NULL);
      Cycladz_KdPrint(FdoData,SER_DBG_CYCLADES,("Hardware Id %ws\n",pdoData->HardwareIDs.Buffer));

      // That's how ..\parclass\pnppdo.c does. (Fanny)
      // Instance ID
      sprintf((PCHAR)RawString,"%02u",i+1);
      RtlInitAnsiString(&AnsiString,(PCHAR)RawString);
      RtlAnsiStringToUnicodeString(&pdoData->InstanceIDs,&AnsiString,TRUE);
      Cycladz_KdPrint(FdoData,SER_DBG_CYCLADES,("Instance Id %s\n",AnsiString.Buffer));

      // Device ID
      sprintf((PCHAR)RawString,CYZPORT_DEV_ID_STR); 
      RtlInitAnsiString(&AnsiString,(PCHAR)RawString);
      RtlAnsiStringToUnicodeString(&pdoData->DeviceIDs,&AnsiString,TRUE);
      Cycladz_KdPrint(FdoData,SER_DBG_CYCLADES,("Device Id %s\n",AnsiString.Buffer));

      // Device Description
      sprintf((PCHAR)RawString,"Cyclades-Z Port %2u",i+1);
      RtlInitAnsiString(&AnsiString,(PUCHAR)RawString);
      RtlAnsiStringToUnicodeString(&pdoData->DevDesc,&AnsiString,TRUE);
      Cycladz_KdPrint(FdoData,SER_DBG_CYCLADES,("Device Description %s\n",AnsiString.Buffer));

      Cycladz_InitPDO(i, pdo, FdoData);
      
      numPorts--;
   
   }

   ExFreePool(pdoUniName.Buffer);


ExitReenumerate:;

   return status;
}

// "Cycladz_RemovePDO" CHANGED TO "Cycladz_PDO_EnumMarkMissing" in build 2072.
void
Cycladz_PDO_EnumMarkMissing(PFDO_DEVICE_DATA FdoData, PPDO_DEVICE_DATA PdoData)
/*++

Routine Description:
    Removes the attached pdo from the fdo's list of children.

    NOTE: THIS FUNCTION CAN ONLY BE CALLED DURING AN ENUMERATION. If called
          outside of enumeration, Cyclades-Z might delete it's PDO before PnP has
          been told the PDO is gone.

Arguments:
    FdoData - Pointer to the fdo's device extension
    PdoData - Pointer to the pdo's device extension

Return value:
    none

--*/
{
    ULONG IndexPDO = PdoData->PortIndex;
    Cycladz_KdPrint (FdoData, SER_DBG_SS_TRACE, ("Removing Pdo %x\n",
                                                 PdoData->Self));
    ASSERT(PdoData->Attached);
    PdoData->Attached = FALSE;
    FdoData->AttachedPDO[IndexPDO] = NULL;
    FdoData->PdoData[IndexPDO] = NULL;
    FdoData->NumPDOs--;
}

NTSTATUS
Cycladz_GetRegistryKeyValue(IN HANDLE Handle, IN PWCHAR KeyNameString,
                            IN ULONG KeyNameStringLength, IN PVOID Data,
                            IN ULONG DataLength, OUT PULONG ActualLength)
/*++

Routine Description:

    Reads a registry key value from an already opened registry key.

Arguments:

    Handle              Handle to the opened registry key

    KeyNameString       ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString

    Data                Buffer to place the key value in

    DataLength          Length of the data buffer

Return Value:

    STATUS_SUCCESS if all works, otherwise status of system call that
    went wrong.

--*/
{
    UNICODE_STRING              keyName;
    ULONG                       length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    NTSTATUS                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

    RtlInitUnicodeString (&keyName, KeyNameString);

    length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength
      + DataLength;
    fullInfo = ExAllocatePool(PagedPool, length);

    if (ActualLength != NULL) {
       *ActualLength = 0;
    }

    if (fullInfo) {
        ntStatus = ZwQueryValueKey (Handle,
                                  &keyName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

        if (NT_SUCCESS(ntStatus)) {
            //
            // If there is enough room in the data buffer, copy the output
            //

            if (DataLength >= fullInfo->DataLength) {
                RtlCopyMemory(Data, ((PUCHAR)fullInfo) + fullInfo->DataOffset,
                              fullInfo->DataLength);
                if (ActualLength != NULL) {
                   *ActualLength = fullInfo->DataLength;
                }
            }
        }

        ExFreePool(fullInfo);
    }

    if (!NT_SUCCESS(ntStatus) && !NT_ERROR(ntStatus)) {
       if (ntStatus == STATUS_BUFFER_OVERFLOW) {
          ntStatus = STATUS_BUFFER_TOO_SMALL;
       } else {
          ntStatus = STATUS_UNSUCCESSFUL;
       }
    }
    return ntStatus;
}

int myatoi( WCHAR * pszInt )
{
    int   retval;
    WCHAR cSave;

    for( retval = 0; *pszInt; ++pszInt )
    {
        if( ( cSave = (WCHAR) ( *pszInt - L'0') ) > (WCHAR) 9 )
            break;
        retval = (int) ( retval * 10 + (int) cSave );
    }
    return( retval );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\z\cyzcoins\cyfriend.h ===
/** FILE: cyfriend.h ********* Module Header ********************************
 *
 *
 * History:
 *
 *  Copyright (C) 2000 Cyclades Corporation
 *
 *************************************************************************/
//==========================================================================
//                            Include Files
//==========================================================================

#ifndef CYFRIEND_H
#define CYFRIEND_H


//==========================================================================
//                            Function Prototypes
//==========================================================================

//
//  cyfriend.c
//
extern
BOOL
ReplaceFriendlyName(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PTCHAR           NewComName
);



#endif // CYFRIEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\cyclades\z\cyclad-z\pnp.c ===
/*--------------------------------------------------------------------------
*
*   Copyright (C) Cyclades Corporation, 2000-2001.
*   All rights reserved.
*
*   Cyclades-Z Enumerator Driver
*	
*   This file:      pnp.c
*
*   Description:    This module contains contains the plugplay calls
*                   PNP / WDM BUS driver.
*					
*   Notes:          This code supports Windows 2000 and Windows XP,
*                   x86 and ia64 processors.
*
*   Complies with Cyclades SW Coding Standard rev 1.3.
*
*--------------------------------------------------------------------------
*/

/*-------------------------------------------------------------------------
*
*	Change History
*
*--------------------------------------------------------------------------
*   Initial implementation based on Microsoft sample code.
*
*--------------------------------------------------------------------------
*/

#include "pch.h"

static const PHYSICAL_ADDRESS CyzPhysicalZero = {0};

// FANNY_ADDPAGABLE_LATER
//#ifdef ALLOC_PRAGMA
//#pragma alloc_text (PAGE, Cycladz_AddDevice)
//#pragma alloc_text (PAGE, Cycladz_PnP)
//#pragma alloc_text (PAGE, Cycladz_FDO_PnP)
//#pragma alloc_text (PAGE, Cycladz_PDO_PnP)
//#pragma alloc_text (PAGE, Cycladz_PnPRemove)
//#pragma alloc_text (PAGE, Cycladz_StartDevice)
////#pragma alloc_text (PAGE, Cycladz_Remove)
//#endif


NTSTATUS
Cycladz_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusPhysicalDeviceObject
    )
/*++
Routine Description.
    A bus has been found.  Attach our FDO to it.
    Allocate any required resources.  Set things up.  And be prepared for the
    first ``start device.''

Arguments:
    DriverObject - This very self referenced driver.

    BusPhysicalDeviceObject - Device object representing the bus.  That to which
        we attach a new FDO.

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PFDO_DEVICE_DATA    DeviceData;
    ULONG               nameLength;
    ULONG               i;
    INTERFACE_TYPE      interfaceType;
    ULONG               interfaceTypeLength;
    ULONG               uiNumber,uiNumberLength;
    
    PAGED_CODE ();

    Cycladz_KdPrint_Def (SER_DBG_PNP_TRACE, ("Add Device: 0x%x\n",
                                              BusPhysicalDeviceObject));
    //
    // Create our FDO
    //

    status = IoCreateDevice(DriverObject, sizeof(FDO_DEVICE_DATA), NULL,
                           FILE_DEVICE_BUS_EXTENDER, 0, TRUE, &deviceObject);

    if (NT_SUCCESS (status)) {
        DeviceData = (PFDO_DEVICE_DATA) deviceObject->DeviceExtension;
        RtlFillMemory (DeviceData, sizeof (FDO_DEVICE_DATA), 0);

        DeviceData->IsFDO = TRUE;
        DeviceData->DebugLevel = SER_DEFAULT_DEBUG_OUTPUT_LEVEL;
        DeviceData->Self = deviceObject;
        DeviceData->DriverObject = DriverObject;
        for (i=0; i<CYZ_MAX_PORTS; i++) {
           DeviceData->AttachedPDO[i] = NULL;
        }
        DeviceData->NumPDOs = 0;

        DeviceData->DeviceState = PowerDeviceD0;
        DeviceData->SystemState = PowerSystemWorking; // FANNY: This seems to be not needed

        DeviceData->SystemWake=PowerSystemUnspecified;
        DeviceData->DeviceWake=PowerDeviceUnspecified;

        INITIALIZE_PNP_STATE(DeviceData);

        // Set the PDO for use with PlugPlay functions
        DeviceData->UnderlyingPDO = BusPhysicalDeviceObject;


        //
        // Attach our filter driver to the device stack.
        // the return value of IoAttachDeviceToDeviceStack is the top of the
        // attachment chain.  This is where all the IRPs should be routed.
        //
        // Our filter will send IRPs to the top of the stack and use the PDO
        // for all PlugPlay functions.
        //
        DeviceData->TopOfStack
            = IoAttachDeviceToDeviceStack(deviceObject, BusPhysicalDeviceObject);

        deviceObject->Flags |= DO_BUFFERED_IO;

        // Bias outstanding request to 1 so that we can look for a
        // transition to zero when processing the remove device PlugPlay IRP.
        DeviceData->OutstandingIO = 1;

        KeInitializeEvent(&DeviceData->RemoveEvent, SynchronizationEvent,
                        FALSE);

        //
        // Tell the PlugPlay system that this device will need an interface
        // device class shingle.
        //
        // It may be that the driver cannot hang the shingle until it starts
        // the device itself, so that it can query some of its properties.
        // (Aka the shingles guid (or ref string) is based on the properties
        // of the device.)
        //
        status = IoRegisterDeviceInterface (BusPhysicalDeviceObject,
                                            (LPGUID) &GUID_CYCLADESZ_BUS_ENUMERATOR,
                                            NULL,
                                            &DeviceData->DevClassAssocName);

        if (!NT_SUCCESS (status)) {
            CyzLogError(DriverObject, NULL, CyzPhysicalZero, CyzPhysicalZero,
                        0, 0, 0, 0, status, CYZ_REGISTER_INTERFACE_FAILURE,
                        0, NULL, 0, NULL);
            Cycladz_KdPrint_Def (SER_DBG_PNP_ERROR,
                                ("AddDevice: IoRegisterDCA failed (%x)", status));
            goto CycladzAddDevice_Error;
        }

        //
        // If for any reason you need to save values in a safe location that
        // clients of this DeviceClassAssociate might be interested in reading
        // here is the time to do so, with the function
        // IoOpenDeviceClassRegistryKey
        // the symbolic link name used is was returned in
        // DeviceData->DevClassAssocName (the same name which is returned by
        // IoGetDeviceClassAssociations and the SetupAPI equivs.
        //

#if DBG
{
        PWCHAR deviceName = NULL;

        status = IoGetDeviceProperty (BusPhysicalDeviceObject,
                                      DevicePropertyPhysicalDeviceObjectName,0,
                                      NULL,&nameLength);

        if ((nameLength != 0) && (status == STATUS_BUFFER_TOO_SMALL)) {
            deviceName = ExAllocatePool (NonPagedPool, nameLength);

            if (NULL == deviceName) {
               goto someDebugStuffExit;
            }

            IoGetDeviceProperty (BusPhysicalDeviceObject,
                                 DevicePropertyPhysicalDeviceObjectName,
                                 nameLength, deviceName, &nameLength);

            Cycladz_KdPrint_Def (SER_DBG_PNP_TRACE,
                               ("AddDevice: %x to %x->%x (%ws) \n",
                                 deviceObject, DeviceData->TopOfStack,
                                 BusPhysicalDeviceObject, deviceName));
        }

someDebugStuffExit:;
        if (deviceName != NULL) {
            ExFreePool(deviceName);
        }
}
#endif

        DeviceData->IsPci = 1; // Z is always PCI

        status = IoGetDeviceProperty (BusPhysicalDeviceObject,
                                      DevicePropertyUINumber ,
                                      sizeof(uiNumber),
                                      &uiNumber,
                                      &uiNumberLength);

        if (!NT_SUCCESS (status)) {
            uiNumber = 0xFFFFFFFF;

            Cycladz_KdPrint_Def (SER_DBG_PNP_ERROR,
                                ("AddDevice: IoGetDeviceProperty DevicePropertyUINumber failed (%x)", 
                                  status));
        }

        DeviceData->UINumber = uiNumber;

        //
        // Turn on the shingle and point it to the given device object.
        //
        status = IoSetDeviceInterfaceState (
                        &DeviceData->DevClassAssocName,
                        TRUE);

        if (!NT_SUCCESS (status)) {
            Cycladz_KdPrint_Def (SER_DBG_PNP_ERROR,
                                ("AddDevice: IoSetDeviceClass failed (%x)", status));
            //return status;
            goto CycladzAddDevice_Error;
        }

        deviceObject->Flags |= DO_POWER_PAGABLE;
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    
    } else {
      CyzLogError(DriverObject, NULL, CyzPhysicalZero, CyzPhysicalZero,
                  0, 0, 0, 0, status, CYZ_DEVICE_CREATION_FAILURE,
                  0, NULL, 0, NULL);
    }

    return status;


CycladzAddDevice_Error:

    if (DeviceData->DevClassAssocName.Buffer) {
       RtlFreeUnicodeString(&DeviceData->DevClassAssocName);
    }

    if (DeviceData->TopOfStack) {
       IoDetachDevice(DeviceData->TopOfStack);
    }
    if (deviceObject) {
       IoDeleteDevice(deviceObject);
    }
 
    return status;
}

NTSTATUS
Cycladz_PnP (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++
Routine Description:
    Answer the plethora of Irp Major PnP IRPS.
--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    PCOMMON_DEVICE_DATA     commonData;
    KIRQL                   oldIrq;
#if DBG
    UCHAR                   MinorFunction;
#endif

    PAGED_CODE ();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (irpStack->MajorFunction == IRP_MJ_PNP);
#if DBG
    MinorFunction = irpStack->MinorFunction;
#endif

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    //
    // If removed, fail the request and get out
    //

    if (commonData->DevicePnPState == Deleted) {   // if (commonData->Removed) added in build 2072.

        Cycladz_KdPrint(commonData, SER_DBG_PNP_TRACE,
                        ("PNP: removed DO: %x got IRP: %x\n", DeviceObject, 
                         Irp));

        Irp->IoStatus.Status = status = STATUS_NO_SUCH_DEVICE;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        goto PnPDone;
    }

    //
    // Call either the FDO or PDO Pnp code
    //

    if (commonData->IsFDO) {
        Cycladz_KdPrint(commonData, SER_DBG_PNP_TRACE,
                         ("FDO(%x):%s IRP:%x\n", DeviceObject, 
                          PnPMinorFunctionString(irpStack->MinorFunction),Irp));

        status = Cycladz_FDO_PnP(DeviceObject, Irp, irpStack,
                    (PFDO_DEVICE_DATA) commonData);
        goto PnPDone;

    } 
    
    //
    // PDO
    //
    
    Cycladz_KdPrint(commonData, SER_DBG_PNP_TRACE,
                    ("PDO(%x):%s IRP:%x\n", DeviceObject, 
                     PnPMinorFunctionString(irpStack->MinorFunction),Irp));

    status = Cycladz_PDO_PnP(DeviceObject, Irp, irpStack,
                             (PPDO_DEVICE_DATA) commonData);

PnPDone:;
    return status;
}

NTSTATUS
Cycladz_FDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the BUS itself

    NB: the various Minor functions of the PlugPlay system will not be
    overlapped and do not have to be reentrant

--*/
{
    NTSTATUS    status;
    KIRQL       oldIrq;
    KEVENT      event;
    ULONG       length;
    ULONG       i;
    PLIST_ENTRY entry;
    PPDO_DEVICE_DATA    pdoData;
    PDEVICE_RELATIONS   relations;
    PIO_STACK_LOCATION  stack;
    PRTL_QUERY_REGISTRY_TABLE QueryTable = NULL;
    ULONG DebugLevelDefault = SER_DEFAULT_DEBUG_OUTPUT_LEVEL;
    HANDLE      instanceKey;
    UNICODE_STRING  keyName;
    ULONG       numOfPorts;

    PAGED_CODE ();

    status = Cycladz_IncIoCount (DeviceData);
    if (!NT_SUCCESS (status)) {
        //Irp->IoStatus.Information = 0; Removed in build 2072
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    stack = IoGetCurrentIrpStackLocation (Irp);

    switch (IrpStack->MinorFunction) {

       case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: {

         PIO_RESOURCE_REQUIREMENTS_LIST pReqList;
         PIO_RESOURCE_LIST pResList;
         PIO_RESOURCE_DESCRIPTOR pResDesc;
         ULONG i, j;
         ULONG reqCnt;
         ULONG gotPLX;
         ULONG gotMemory;
         ULONG gotInt;
         ULONG listNum;

         // FANNY: The serial driver had it as SynchronizationEvent.
         KeInitializeEvent(&event, NotificationEvent, FALSE);

         IoCopyCurrentIrpStackLocationToNext(Irp);
         IoSetCompletionRoutine(Irp, CycladzSyncCompletion, &event,
                                TRUE, TRUE, TRUE);

         status = IoCallDriver(DeviceData->TopOfStack, Irp);


         //
         // Wait for lower drivers to be done with the Irp
         //

         if (status == STATUS_PENDING) {
            KeWaitForSingleObject (&event, Executive, KernelMode, FALSE,
                                   NULL);
         }

         if (Irp->IoStatus.Information == 0) {
            if (stack->Parameters.FilterResourceRequirements
                .IoResourceRequirementList == 0) {
               Cycladz_KdPrint(DeviceData, SER_DBG_CYCLADES, ("Can't filter NULL resources!"
                                                       "\n"));
               status = Irp->IoStatus.Status;
               IoCompleteRequest (Irp, IO_NO_INCREMENT);
               Cycladz_DecIoCount (DeviceData);
               return status;
            }

            Irp->IoStatus.Information = (ULONG_PTR)stack->Parameters
                                        .FilterResourceRequirements
                                        .IoResourceRequirementList;

         }


         //
         // Force ISR ports in IO_RES_REQ_LIST to shared status
         // Force interrupts to shared status
         //

         //
         // We will only process the first list -- multiport boards
         // should not have alternative resources
         //

         pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information;
         pResList = &pReqList->List[0];

         Cycladz_KdPrint(DeviceData, SER_DBG_CYCLADES, ("------- List has %x lists "
                                                      "(including alternatives)\n",
                                                        pReqList->AlternativeLists));

         for (listNum = 0; listNum < (pReqList->AlternativeLists);
              listNum++) {
            gotPLX = 0;
            gotMemory = 0;
            gotInt = 0;

            Cycladz_KdPrint(DeviceData, SER_DBG_CYCLADES, ("------- List has %x resources in it\n",
                                                           pResList->Count));

            for (j = 0; (j < pResList->Count); j++) {
               pResDesc = &pResList->Descriptors[j];

               switch (pResDesc->Type) {
               case CmResourceTypeMemory:
                  if (pResDesc->u.Memory.Length == CYZ_RUNTIME_LENGTH) {
                      gotPLX = 1;
                      //wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
                      //pResDesc->ShareDisposition = CmResourceShareShared; 
                      //wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
                      //pResDesc->ShareDisposition = CmResourceShareDriverExclusive; 
                      //Cycladz_KdPrint(DeviceData,SER_DBG_CYCLADES,
                      //                              ("------- Sharing PLX Memory for "
                      //                               "device %x\n", DeviceData->TopOfStack));

                  } else {
                      gotMemory = 1;
                      //wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
                      //pResDesc->ShareDisposition = CmResourceShareShared; 
                      //wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
                      //pResDesc->ShareDisposition = CmResourceShareDriverExclusive; 
                      //Cycladz_KdPrint(DeviceData,SER_DBG_CYCLADES,
                      //                              ("------- Sharing Board Memory for "
                      //                               "device %x\n", DeviceData->TopOfStack));
                  }
                  break;

               case CmResourceTypePort:
                  Cycladz_KdPrint(DeviceData,SER_DBG_CYCLADES,
                                         ("------- We should not have Port resource\n"));
                  break;

               case CmResourceTypeInterrupt:
                  gotInt = 1;
                  if (DeviceData->IsPci) {
                      pResDesc->ShareDisposition = CmResourceShareShared;
                  }
                  Cycladz_KdPrint(DeviceData,SER_DBG_CYCLADES,("------- Sharing interrupt for "
                                                 "device %x\n", DeviceData->TopOfStack));
                  break;

               default:
                  break;
               }

               //
               // If we found what we need, we can break out of the loop
               //

               // FANNY: STRANGE, THERE ARE TWICE FOR EACH TYPE. IT SEEMS THAT 
               // BOTH RAW AND TRANSLATED ARE LISTED.
               // (gotPLX && gotMemory && gotInt) {
               // break;
               //
            }

            pResList = (PIO_RESOURCE_LIST)((PUCHAR)pResList
                                           + sizeof(IO_RESOURCE_LIST)
                                           + sizeof(IO_RESOURCE_DESCRIPTOR)
                                           * (pResList->Count - 1));
         }



         Irp->IoStatus.Status = STATUS_SUCCESS;
         IoCompleteRequest (Irp, IO_NO_INCREMENT);
         Cycladz_DecIoCount (DeviceData);
         return STATUS_SUCCESS;
    }

    case IRP_MN_START_DEVICE:
        //
        // BEFORE you are allowed to ``touch'' the device object to which
        // the FDO is attached (that send an irp from the bus to the Device
        // object to which the bus is attached).   You must first pass down
        // the start IRP.  It might not be powered on, or able to access or
        // something.
        //


        // FANNY_TODO
        // SHOULD I CALL MmLockPagableCodeSection as the serial driver?


//        if (DeviceData->Started) {
//            Cycladz_KdPrint (DeviceData, SER_DBG_PNP_TRACE,
//                ("Device already started\n"));
//            status = STATUS_SUCCESS;
//            break;
//        }


        KeInitializeEvent (&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine (Irp,
                                CycladzSyncCompletion,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            // wait for it...

            status = KeWaitForSingleObject (&event,
                                            Executive,
                                            KernelMode,
                                            FALSE, // Not allertable
                                            NULL); // No timeout structure

            ASSERT (STATUS_SUCCESS == status);

            status = Irp->IoStatus.Status;
        }

        if (NT_SUCCESS(status)) {

            //
            // Get the debug level from the registry
            //

            if (NULL == (QueryTable = ExAllocatePool(                                        
                                        PagedPool,
                                        sizeof(RTL_QUERY_REGISTRY_TABLE)*2
                                        ))) {
                Cycladz_KdPrint (DeviceData, SER_DBG_PNP_ERROR,
                                ("Failed to allocate memory to query registy\n"));
                DeviceData->DebugLevel = DebugLevelDefault;
            } else {
                RtlZeroMemory(
                           QueryTable,
                           sizeof(RTL_QUERY_REGISTRY_TABLE)*2
                           );

                QueryTable[0].QueryRoutine = NULL;
                QueryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
                QueryTable[0].EntryContext = &DeviceData->DebugLevel;
                QueryTable[0].Name      = L"DebugLevel";
                QueryTable[0].DefaultType   = REG_DWORD;
                QueryTable[0].DefaultData   = &DebugLevelDefault;
                QueryTable[0].DefaultLength= sizeof(ULONG);

                // CIMEXCIMEX: The rest of the table isn't filled in!  Comment changed bld 2128

                if (!NT_SUCCESS(RtlQueryRegistryValues(
                    RTL_REGISTRY_SERVICES,
                    L"cyclad-z",
                    QueryTable,
                    NULL,
                    NULL))) {
                    Cycladz_KdPrint (DeviceData,SER_DBG_PNP_ERROR,
                        ("Failed to get debug level from registry.  "
                         "Using default\n"));
                    DeviceData->DebugLevel = DebugLevelDefault;
                }

                ExFreePool( QueryTable );
            }

            status = Cycladz_GetResourceInfo(DeviceObject,                    
                        IrpStack->Parameters.StartDevice.AllocatedResources,
                        IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated);

            if (NT_SUCCESS(status)) {

                ULONG numberOfResources = CYZ_NUMBER_OF_RESOURCES;
                if (!DeviceData->IsPci) {
                    numberOfResources--;
                }
                status = Cycladz_BuildResourceList(&DeviceData->PChildResourceList,
                                    &DeviceData->PChildResourceListSize,
                                    IrpStack->Parameters.StartDevice.AllocatedResources,
                                    numberOfResources);

                if (!NT_SUCCESS(status)) {
                    goto CaseSTART_end;
                }

                status = Cycladz_BuildResourceList(&DeviceData->PChildResourceListTr,
                                    &DeviceData->PChildResourceListSizeTr,
                                    IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated,
                                    numberOfResources);

                if (!NT_SUCCESS(status)) {
                    goto CaseSTART_end;
                }
              
                status = Cycladz_BuildRequirementsList(&DeviceData->PChildRequiredList,
                                    IrpStack->Parameters.StartDevice.AllocatedResources,
                                    numberOfResources);

                if (!NT_SUCCESS(status)) {
                    goto CaseSTART_end;
                }

                //
                // See if we are in the proper power state.
                //

                if (DeviceData->DeviceState != PowerDeviceD0) {

                    status = Cycladz_GotoPowerState(DeviceData->UnderlyingPDO, DeviceData, 
                                              PowerDeviceD0);

                    if (!NT_SUCCESS(status)) {
                        goto CaseSTART_end;
                    }
                }
              
                numOfPorts=Cycladz_DoesBoardExist(DeviceData);
                if (!numOfPorts){
                    Cycladz_KdPrint(DeviceData,SER_DBG_CYCLADES,("Does Port exist test failed\n"));
                    status = STATUS_SERIAL_NO_DEVICE_INITED;
                    goto CaseSTART_end;
                }
                Cycladz_KdPrint(DeviceData,SER_DBG_CYCLADES,("Board found!\n"));

                // Save number of ports to the Registry, so that Property Page
                // code can retrieve it.
    
                IoOpenDeviceRegistryKey(DeviceData->UnderlyingPDO,PLUGPLAY_REGKEY_DEVICE,
                    STANDARD_RIGHTS_WRITE,&instanceKey);

                RtlInitUnicodeString(&keyName,L"NumOfPorts");
                ZwSetValueKey(instanceKey,&keyName,0,REG_DWORD,&numOfPorts,sizeof(ULONG));

              